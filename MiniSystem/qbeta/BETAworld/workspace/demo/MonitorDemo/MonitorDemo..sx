 -- QBETA 
 -- OG:markForCodeGen: "%id "BETAworld"{   %modules BETA, LIB, LIB.StringLib, LIB.BasicIo;   error: ;      %basic 999;   --BETA;--DK;--LIB;--OOPM;--Sequential;--no;--workspace ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%id "BETAworld"{   %modules BETA, LIB, LIB.StringLib, LIB.BasicIo;   error: ;      %basic 999;   --BETA;--DK;--LIB;--OOPM;--Sequential;--no;--workspace;}" 
 -- OG:Qalloc: "%id "BETAworld"{   %modules BETA, LIB, LIB.StringLib, LIB.BasicIo;   error: ;      %basic 999;   --BETA;--DK;--LIB;--OOPM;--Sequential;--no;--workspace;}" qDes ... 0 
 -- OG:Qalloc:A:  "BETAworld"  super:  ""  marked:  true "BETAworld: obj {   %id "BETAworld";   %modules BETA, LIB, LIB.StringLib, LIB.BasicIo;   error: ;      %basic 999;   - ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57; ...} 
 -- OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic  ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%id "BETAworld"{   %modules BETA, LIB, LIB.StringLib, LIB.BasicIo;   error: ;      %basic 999;   --BETA;--DK;--LIB;--OOPM;--Sequential;--no;--workspace;}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "BETAworld" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 1 IS.newDescNo: 1 objSize: 0 1: 1 "%id "BETAworld"{%modules BETA, LIB, LIB.StringLib, LIB.BasicIo;error: ;   %basic 999;--BETA;--DK;--LIB;--OOPM ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 1 "%id "BETAworld"{%modules BETA, LIB, LIB.StringLib, LIB.BasicIo;error: ;   %basic 999;--BETA;--DK;--LIB;--OOPM;--Sequential;--no;--wo ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Pattern:Qalloc: error 
 -- ModuleItem:Qalloc:  --BETA{} 
 -- Qalloc:module: BETA 
 -- Module:alloc:off: 2 BETA: obj {   %ID BETA;   %OSDvisibility disguised;   %module LIB, LIB.StringLib;   %public;   Object: ;      %ID Object;      %basic 64;      %public; ...} 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- ModuleItem:Qalloc:  --DK{} 
 -- ModuleItem:Qalloc:  --LIB{} 
 -- Qalloc:module: LIB 
 -- Module:alloc:off: 3 LIB: obj {   %id "LIB";   %module BETA;   %Include BETA;   x_dummy_LIB: var integer;   --AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsyst ...} 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- ModuleItem:Qalloc:  --OOPM{} 
 -- ModuleItem:Qalloc:  --Sequential{} 
 -- ModuleItem:Qalloc:  --no{} 
 -- ModuleItem:Qalloc:  --workspace{} 
 -- Qalloc:module: workspace 
 -- Module:alloc:off: 4 workspace: obj {   %id "workspace";   %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib;   %domain_boundary;   --AbstractEx;--AccessEx;--A ...} 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 1 "%id "BETAworld"{%modules BETA, LIB, LIB.StringLib, LIB.BasicIo;error: ;   %basic 999;--BETA;--DK;--LIB;--OOPM;--Sequential;--no; ...}" 
 -- IS.newDescNo: 1 IS.objSize: 4 "%id "BETAworld"{%modules BETA, LIB, LIB.StringLib, LIB.BasicIo;error: ;   %basic 999;--BETA;--DK;--LIB;--OOPM;--Sequential;--no;--workspace; ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  1 "%id "BETAworld"{   %modules BETA, LIB, LIB.StringLib, LIB.BasicIo;   error: ;      %basic 999;   --BETA;--DK;--LIB;--OOPM;--Sequential;--n ...}" 
 -- ObjTmpStack:add: "BETAworld" : "%id "BETAworld"{   %modules BETA, LIB, LIB.StringLib, LIB.BasicIo;   error: ;      %basic 999;   --BETA;--DK;--LIB;--OOPM;--Sequential;--no ...}" 
 -- items:markForCodeGen: "%id "BETAworld"{%modules BETA, LIB, LIB.StringLib, LIB.BasicIo;error: ;   %basic 999;--BETA;--DK;--LIB;--OOPM;--Sequential;--no;--workspace;}" 
 -- markItem: "%id "BETAworld"" Property 
 -- markItem: "%modules BETA, LIB, LIB.StringLib, LIB.BasicIo" Property 
 -- OG:markForCodeGen: "%ID BETA{   %OSDvisibility disguised;   %module LIB, LIB.StringLib;   %public;   Object: ;      %ID Object;      %basic 64;      %public;      ==  : ;  ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%ID BETA{   %OSDvisibility disguised;   %module LIB, LIB.StringLib;   %public;   Object: ;      %ID Object;      %basic 64;      %public;      ==  : ;          ...}" 
 -- OG:Qalloc: "%ID BETA{   %OSDvisibility disguised;   %module LIB, LIB.StringLib;   %public;   Object: ;      %ID Object;      %basic 64;      %public;      ==  : ;          ...}" q ... 0 
 -- OG:Qalloc:A:  "BETA"  super:  ""  marked:  true "BETA: obj {   %ID BETA;   %OSDvisibility disguised;   %module LIB, LIB.StringLib;   %public;   Object: ;      %ID Object;  ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57; ...} 
 -- OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic  ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%ID BETA{   %OSDvisibility disguised;   %module LIB, LIB.StringLib;   %public;   Object: ;      %ID Object;      %basic 64;      %public;      ==  : ;         %basic 56;  ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "BETA" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 2 IS.newDescNo: 2 objSize: 0 1: 1 "%ID BETA{%OSDvisibility disguised;%module LIB, LIB.StringLib;%public;Object: ;   %ID Object;   %basic 64;   % ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 2 "%ID BETA{%OSDvisibility disguised;%module LIB, LIB.StringLib;%public;Object: ;   %ID Object;   %basic 64;   %public;   ==  : ;       ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Pattern:Qalloc: Object 
 -- Pattern:Qalloc: Value 
 -- Pattern:Qalloc: universal 
 -- Pattern:Qalloc: integer 
 -- Pattern:Qalloc: Boolean 
 -- Pattern:Qalloc: False 
 -- Pattern:Qalloc:B: False 
 -- Pattern:Qalloc: True 
 -- Pattern:Qalloc:B: True 
 -- Pattern:Qalloc: char 
 -- Pattern:Qalloc: universalFloat 
 -- Pattern:Qalloc: float 
 -- Pattern:Qalloc: put 
 -- Pattern:Qalloc: _put 
 -- Pattern:Qalloc: _get 
 -- Pattern:Qalloc: _iget 
 -- Pattern:Qalloc:B: _iget 
 -- Pattern:Qalloc: _kbhit 
 -- Pattern:Qalloc:B: _kbhit 
 -- Pattern:Qalloc: none 
 -- Pattern:Qalloc: immutable 
 -- Pattern:Qalloc: unique 
 -- Pattern:Qalloc:B: unique 
 -- Pattern:Qalloc: inner 
 -- Pattern:Qalloc: this 
 -- Pattern:Qalloc: disable 
 -- Pattern:Qalloc: enable 
 -- Pattern:Qalloc: fork 
 -- Pattern:Qalloc: sleep 
 -- Pattern:Qalloc: SuperCore 
 -- Pattern:Qalloc:B: SuperCore 
 -- Pattern:Qalloc: SuperScheduler 
 -- Pattern:Qalloc:B: SuperScheduler 
 -- Pattern:Qalloc: GeneralProcess 
 -- Pattern:Qalloc:B: GeneralProcess 
 -- Pattern:Qalloc: thisCoreIdx 
 -- Pattern:Qalloc: thisCore 
 -- Pattern:Qalloc: inSub 
 -- Pattern:Qalloc: method 
 -- Pattern:Qalloc:B: method 
 -- Pattern:Qalloc: disguised 
 -- Pattern:Qalloc:B: disguised 
 -- Pattern:Qalloc: SkipInternal 
 -- Pattern:Qalloc:B: SkipInternal 
 -- Pattern:Qalloc: Show 
 -- Pattern:Qalloc:B: Show 
 -- Pattern:Qalloc: Array 
 -- Pattern:Qalloc: Indexed 
 -- Pattern:Qalloc: IndexedRef 
 -- Pattern:Qalloc: restart 
 -- Pattern:Qalloc: leave 
 -- Pattern:Qalloc: if:then 
 -- Pattern:Qalloc: if:then:else 
 -- Pattern:Qalloc:B: if:then:else 
 -- Pattern:Qalloc: cycle 
 -- Pattern:Qalloc:B: cycle 
 -- Pattern:Qalloc: for:to:repeat 
 -- Pattern:Qalloc:B: for:to:repeat 
 -- Pattern:Qalloc: Condition 
 -- Pattern:Qalloc:B: Condition 
 -- Pattern:Qalloc: while:repeat 
 -- Pattern:Qalloc:B: while:repeat 
 -- Pattern:Qalloc: switch 
 -- Pattern:Qalloc:B: switch 
 -- Pattern:Qalloc: rswitch 
 -- Pattern:Qalloc:B: rswitch 
 -- dataitem:qalloc: "ascii" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "ascii: obj {   asciiFoo: ;      msg1:  -- obj;         _put('F');         asciiBar.msg2;   asciiBar:  -- obj;      msg2: ;         _put('B');   nl: val 1 ...}" 
 -- OG:Qalloc: "asciiFoo: {      msg1:  -- obj;         _put('F');         asciiBar.msg2;   asciiBar:  -- obj;      msg2: ;         _put('B');   nl: val 10;   cr: val 13;   nu ...}" q ... 0 
 -- OG:Qalloc:A:  "ascii"  super:  ""  marked:  false "ascii: obj {   asciiFoo: ;      msg1:  -- obj;         _put('F');         asciiBar.msg2;   asciiBar:  -- obj;      msg2: ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57; ...} 
 -- OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic  ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "asciiFoo: {      msg1:  -- obj;         _put('F');         asciiBar.msg2;   asciiBar:  -- obj;      msg2: ;         _put('B');   nl: val 10;   cr: val 13;   null: val 0;  ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "ascii" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 3 IS.newDescNo: 3 objSize: 0 1: 1 "asciiFoo: {   msg1:  -- obj;      _put('F');      asciiBar.msg2;asciiBar:  -- obj;   msg2: ;      _put('B');n ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 3 "asciiFoo: {   msg1:  -- obj;      _put('F');      asciiBar.msg2;asciiBar:  -- obj;   msg2: ;      _put('B');nl: val 10;cr: val 13;nu ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Pattern:Qalloc: asciiFoo 
 -- Pattern:Qalloc:B: asciiFoo 
 -- Pattern:Qalloc: asciiBar 
 -- Pattern:Qalloc:B: asciiBar 
 -- dataitem:qalloc: "nl" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- dataitem:qalloc: "cr" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "null" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- dataitem:qalloc: "newline" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Pattern:Qalloc: isLetter 
 -- Pattern:Qalloc:B: isLetter 
 -- Pattern:Qalloc: isDigit 
 -- Pattern:Qalloc:B: isDigit 
 -- Invocation:Qalloc: "newline" 
 -- ObjectInvocation:Qalloc: "newline" 
 -- name: "newline" 
 -- Arguments "" 
 -- OG:Qalloc: "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}"  marked:  false "newline := nl -- Win:<cr><lf>, Unix:<lf>, ..." s ... n ... 
 -- Invocation:Qalloc: "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" 
 -- ObjectInvocation:Qalloc: "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" 
 -- name: "nl" 
 -- Arguments "-- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:Qalloc:SuperAlloc: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var inte ...}" 
 -- OG:Qalloc: "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      out R: var ...}" q ... 0 
 -- OG:Qalloc:A:  "integer"  super:  "value"  marked:  false "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;  ...}" s ... v ... 
 -- Invocation:Qalloc: "value" 
 -- ObjectInvocation:Qalloc: "value" 
 -- name: "value" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Value{%globals;%basic 21;%public;=  :< ;   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inne ...} 
 -- OG:Qalloc:SuperAlloc: "Value: {   %ID Value;   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out Beq: var boolean;      in ...}" 
 -- OG:Qalloc: "%ID Value{   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out Beq: var boolean;      inner(= );   <=  :< ;    ...}" q ... 0 
 -- OG:Qalloc:A:  "Value"  super:  ""  marked:  false "Value: {   %ID Value;   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      o ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57; ...} 
 -- OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic  ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%ID Value{   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out Beq: var boolean;      inner(= );   <=  :< ;      %basic 5 ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "Value" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 4 IS.newDescNo: 4 objSize: 0 1: 1 "%ID Value{%globals;%basic 21;%public;=  :< ;   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;  ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 4 "%ID Value{%globals;%basic 21;%public;=  :< ;   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= );<=  :< ;    ...}" 
 -- Items:Qalloc:Super:C:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 "" 
 -- Pattern:Qalloc: = 
 -- Pattern:Qalloc: <= 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 4 "%ID Value{%globals;%basic 21;%public;=  :< ;   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= );<=  :<  ...}" 
 -- IS.newDescNo: 4 IS.objSize: 0 "%ID Value{%globals;%basic 21;%public;=  :< ;   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= );<=  :< ;   %basic 5 ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  4 "%ID Value{   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out Beq: var boolean;      inn ...}" 
 -- OG:super:  "Value: {   %ID Value;   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out Beq: var boolean;      inner(= );    ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      out R: var integer;   ...}" 
 -- super:  "value" 
 -- E:  "value" 
 -- OG:Qalloc:B: "integer" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 5 IS.newDescNo: 5 objSize: 0 1: 1 "%ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var inte ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 5 "%ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   out R: var integ ...}" 
 -- Items:Qalloc:super: "value" size: 0 "integer" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 "" 
 -- dataitem:qalloc: "_thisBasicValue" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Pattern:Qalloc: + 
 -- Pattern:Qalloc: - 
 -- Pattern:Qalloc: * 
 -- Pattern:Qalloc: / 
 -- Pattern:Qalloc: // 
 -- Pattern:Qalloc: /% 
 -- Pattern:Qalloc: =? 
 -- Pattern:Qalloc: < 
 -- Pattern:Qalloc: <=? 
 -- Pattern:Qalloc: > 
 -- Pattern:Qalloc: >= 
 -- Pattern:Qalloc: <> 
 -- Pattern:Qalloc: cmpAndSwap 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 5 "%ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   out R: var i ...}" 
 -- IS.newDescNo: 5 IS.objSize: 1 "%ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   out R: var integer;-  :  ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  5 "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var int ...}" 
 -- OG:super:  "nl: val 10" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" 
 -- super:  "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" 
 -- E:  "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 3 "asciiFoo: {   msg1:  -- obj;      _put('F');      asciiBar.msg2;asciiBar:  -- obj;   msg2: ;      _put('B');nl: val 10;cr: val 1 ...}" 
 -- IS.newDescNo: 3 IS.objSize: 5 "asciiFoo: {   msg1:  -- obj;      _put('F');      asciiBar.msg2;asciiBar:  -- obj;   msg2: ;      _put('B');nl: val 10;cr: val 13;null: val  ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  3 "asciiFoo: {      msg1:  -- obj;         _put('F');         asciiBar.msg2;   asciiBar:  -- obj;      msg2: ;         _put('B');   nl: val 1 ...}" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Pattern:Qalloc: newline 
 -- Pattern:Qalloc:B: newline 
 -- Pattern:Qalloc: int2chars 
 -- Pattern:Qalloc:B: int2chars 
 -- Pattern:Qalloc: putint 
 -- Pattern:Qalloc:B: putint 
 -- Pattern:Qalloc: exp 
 -- Pattern:Qalloc:B: exp 
 -- Pattern:Qalloc: sqrt 
 -- Pattern:Qalloc: cbrt 
 -- Pattern:Qalloc: log 
 -- Pattern:Qalloc: putFloat 
 -- Pattern:Qalloc: putFloatX 
 -- Pattern:Qalloc:B: putFloatX 
 -- Pattern:Qalloc: ConsoleIF 
 -- Pattern:Qalloc:B: ConsoleIF 
 -- dataitem:qalloc: "console" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 3 "console: ref ConsoleIF" 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 2 "%ID BETA{%OSDvisibility disguised;%module LIB, LIB.StringLib;%public;Object: ;   %ID Object;   %basic 64;   %public;   ==  : ;   ...}" 
 -- IS.newDescNo: 2 IS.objSize: 3 "%ID BETA{%OSDvisibility disguised;%module LIB, LIB.StringLib;%public;Object: ;   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 5 ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  2 "%ID BETA{   %OSDvisibility disguised;   %module LIB, LIB.StringLib;   %public;   Object: ;      %ID Object;      %basic 64;      %public;  ...}" 
 -- ObjTmpStack:add: "BETA" : "%ID BETA{   %OSDvisibility disguised;   %module LIB, LIB.StringLib;   %public;   Object: ;      %ID Object;      %basic 64;      %public;      = ...}" 
 -- items:markForCodeGen: "%ID BETA{%OSDvisibility disguised;%module LIB, LIB.StringLib;%public;Object: ;   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;       ...}" 
 -- markItem: "%ID BETA" Property 
 -- markItem: "%OSDvisibility disguised" Property 
 -- markItem: "%module LIB, LIB.StringLib" Property 
 -- markItem: "%public" Property 
 -- DataItem:markForCodeGen: "ascii" :descNo: 3 :OG.primNo: 0 
 -- OG:markForCodeGen: "asciiFoo: {      msg1:  -- obj;         _put('F');         asciiBar.msg2;   asciiBar:  -- obj;      msg2: ;         _put('B');   nl: val 10;   cr: val  ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "asciiFoo: {      msg1:  -- obj;         _put('F');         asciiBar.msg2;   asciiBar:  -- obj;      msg2: ;         _put('B');   nl: val 10;   cr: val 13;   nu ...}" 
 -- OG:Qalloc: "asciiFoo: {      msg1:  -- obj;         _put('F');         asciiBar.msg2;   asciiBar:  -- obj;      msg2: ;         _put('B');   nl: val 10;   cr: val 13;   nu ...}" q ... 3 
 -- ObjTmpStack:add: "ascii" : "asciiFoo: {      msg1:  -- obj;         _put('F');         asciiBar.msg2;   asciiBar:  -- obj;      msg2: ;         _put('B');   nl: val 10;    ...}" 
 -- items:markForCodeGen: "asciiFoo: {   msg1:  -- obj;      _put('F');      asciiBar.msg2;asciiBar:  -- obj;   msg2: ;      _put('B');nl: val 10;cr: val 13;null: val 0;newlin ...}" 
 -- DataItem:markForCodeGen: "nl" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "10" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "10" 
 -- "10" true 
 -- 
 -- OG:markSuper: "10" 
 -- Invocation:markForCodeGen: "10" 
 -- OG:markForCodeGen: "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      ou ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "value" 
 -- "value" true 
 -- 
 -- OG:markSuper: "value" 
 -- Invocation:markForCodeGen: "value" 
 -- ObjectInvocation:markForCodeGen: "value"  ATd: "Value: {   %ID Value;   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out  ...}" 
 -- Pattern:markForCodeGen: "Value: {   %ID Value;   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out Beq: var boolean;       ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "%ID Value{   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out Beq: var boolean;      inner(= );   <=  ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%ID Value{   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out Beq: var boolean;      inner(= );   <=  :< ;    ...}" 
 -- OG:Qalloc: "%ID Value{   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out Beq: var boolean;      inner(= );   <=  :< ;    ...}" q ... 4 
 -- ObjTmpStack:add: "Value" : "%ID Value{   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out Beq: var boolean;      inner(=  ...}" 
 -- items:markForCodeGen: "%ID Value{%globals;%basic 21;%public;=  :< ;   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= );<=  :< ;   %basic 52;   in  ...}" 
 -- markItem: "%ID Value" Property 
 -- markItem: "%globals" Property 
 -- markItem: "%basic 21" Property 
 -- markItem: "%public" Property 
 -- Pattern:markForCodeGen: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- items:markForCodeGen: "" 
 -- Pattern:markForCodeGen: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- items:markForCodeGen: "" 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      out R: var ...}" 
 -- OG:Qalloc: "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      out R: var ...}" q ... 5 
 -- ObjTmpStack:add: "integer" : "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- items:markForCodeGen: "%ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   out R: var integer;-  : ;   %bas ...}" 
 -- markItem: "%ID integer" Property 
 -- markItem: "%basic 1, 32" Property 
 -- markItem: "%globals" Property 
 -- markItem: "%public" Property 
 -- DataItem:markForCodeGen: "_thisBasicValue" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "Universal" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Universal" 
 -- "Universal" true 
 -- 
 -- OG:markSuper: "Universal" 
 -- Invocation:markForCodeGen: "Universal" 
 -- ObjectInvocation:markForCodeGen: "Universal"  ATd: "universal: Value{   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic 61;      in V: var integer;      ou ...}" 
 -- Pattern:markForCodeGen: "universal: Value{   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic 61;      in V: var integer;      out R: var integer;   -  : ;  ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "Value{   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic 61;      in V: var integer;      out R: var integer;   -  : ;      %basic 62;  ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Value" 
 -- "Value" true 
 -- 
 -- OG:markSuper: "Value" 
 -- Invocation:markForCodeGen: "Value" 
 -- ObjectInvocation:markForCodeGen: "Value"  ATd: "Value: {   %ID Value;   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out  ...}" 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "Value{   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic 61;      in V: var integer;      out R: var integer;   -  : ;      %basic 62;      in  ...}" 
 -- OG:Qalloc: "Value{   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic 61;      in V: var integer;      out R: var integer;   -  : ;      %basic 62;      in  ...}" q ... 0 
 -- OG:Qalloc:A:  "universal"  super:  "Value"  marked:  true "universal: Value{   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic 61;      in V: var integer;  ...}" s ... V ... 
 -- Invocation:Qalloc: "Value" 
 -- ObjectInvocation:Qalloc: "Value" 
 -- name: "Value" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  4 0 %ID Value{%globals;%basic 21;%public;=  :< ;   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inne ...} 
 -- OG:super:  "Value: {   %ID Value;   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out Beq: var boolean;      inner(= );    ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Value{   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic 61;      in V: var integer;      out R: var integer;   -  : ;      %basic 62;      in V: var inte ...}" 
 -- super:  "Value" 
 -- E:  "Value" 
 -- OG:Qalloc:B: "universal" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 6 IS.newDescNo: 6 objSize: 0 1: 1 "%ID universal{%basic 1, 32;%globals;+  : ;   %basic 61;   in V: var integer;   out R: var integer;-  : ;   %b ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 6 "%ID universal{%basic 1, 32;%globals;+  : ;   %basic 61;   in V: var integer;   out R: var integer;-  : ;   %basic 62;   in V: var in ...}" 
 -- Items:Qalloc:super: "Value" size: 0 "universal" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 "" 
 -- Pattern:Qalloc: + 
 -- Pattern:Qalloc: - 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 6 "%ID universal{%basic 1, 32;%globals;+  : ;   %basic 61;   in V: var integer;   out R: var integer;-  : ;   %basic 62;   in V: va ...}" 
 -- IS.newDescNo: 6 IS.objSize: 0 "%ID universal{%basic 1, 32;%globals;+  : ;   %basic 61;   in V: var integer;   out R: var integer;-  : ;   %basic 62;   in V: var integer;   ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  6 "Value{   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic 61;      in V: var integer;      out R: var integer;   -  : ;     ...}" 
 -- ObjTmpStack:add: "universal" : "Value{   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic 61;      in V: var integer;      out R: var integer;   -  : ;      ...}" 
 -- items:markForCodeGen: "%ID universal{%basic 1, 32;%globals;+  : ;   %basic 61;   in V: var integer;   out R: var integer;-  : ;   %basic 62;   in V: var integer;   out R:  ...}" 
 -- markItem: "%ID universal" Property 
 -- markItem: "%basic 1, 32" Property 
 -- markItem: "%globals" Property 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Universal"  IS.isEmpty:  true 
 -- not ObjDesc:  "10"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "cr" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "13" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "13" 
 -- "13" true 
 -- 
 -- OG:markSuper: "13" 
 -- Invocation:markForCodeGen: "13" 
 -- not ObjDesc:  "13"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "null" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "0" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "0" 
 -- "0" true 
 -- 
 -- OG:markSuper: "0" 
 -- Invocation:markForCodeGen: "0" 
 -- not ObjDesc:  "0"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "newline" :descNo: 0 :OG.primNo: 3 
 -- OG:markForCodeGen: "char" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "char" 
 -- "char" true 
 -- 
 -- OG:markSuper: "char" 
 -- Invocation:markForCodeGen: "char" 
 -- ObjectInvocation:markForCodeGen: "char"  ATd: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61; ...}" 
 -- Pattern:markForCodeGen: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;  ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;      out R: ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "value" 
 -- "value" true 
 -- 
 -- OG:markSuper: "value" 
 -- Invocation:markForCodeGen: "value" 
 -- ObjectInvocation:markForCodeGen: "value"  ATd: "Value: {   %ID Value;   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out  ...}" 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;      out R: var cha ...}" 
 -- OG:Qalloc: "value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;      out R: var cha ...}" q ... 0 
 -- OG:Qalloc:A:  "char"  super:  "value"  marked:  true "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" s ... v ... 
 -- Invocation:Qalloc: "value" 
 -- ObjectInvocation:Qalloc: "value" 
 -- name: "value" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  4 0 %ID Value{%globals;%basic 21;%public;=  :< ;   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inne ...} 
 -- OG:super:  "Value: {   %ID Value;   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out Beq: var boolean;      inner(= );    ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;      out R: var char;   -  : ; ...}" 
 -- super:  "value" 
 -- E:  "value" 
 -- OG:Qalloc:B: "char" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 7 IS.newDescNo: 7 objSize: 0 1: 1 "%id "char"{%globals;%basic 3, 16;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var char; ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 7 "%id "char"{%globals;%basic 3, 16;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var char;   out R: var char;-  : ...}" 
 -- Items:Qalloc:super: "value" size: 0 "char" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 "" 
 -- dataitem:qalloc: "_thisBasicValue" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Pattern:Qalloc: + 
 -- Pattern:Qalloc: - 
 -- Pattern:Qalloc: =? 
 -- Pattern:Qalloc: < 
 -- Pattern:Qalloc: <=? 
 -- Pattern:Qalloc: > 
 -- Pattern:Qalloc: >= 
 -- Pattern:Qalloc: <> 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 7 "%id "char"{%globals;%basic 3, 16;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var char;   out R: var char; ...}" 
 -- IS.newDescNo: 7 IS.objSize: 1 "%id "char"{%globals;%basic 3, 16;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var char;   out R: var char;-  : ;   %ba ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  7 "value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char ...}" 
 -- ObjTmpStack:add: "char" : "value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;      ...}" 
 -- items:markForCodeGen: "%id "char"{%globals;%basic 3, 16;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var char;   out R: var char;-  : ;   %basic 62;  ...}" 
 -- markItem: "%id "char"" Property 
 -- markItem: "%globals" Property 
 -- markItem: "%basic 3, 16" Property 
 -- markItem: "%public" Property 
 -- DataItem:markForCodeGen: "_thisBasicValue" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "Universal" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Universal" 
 -- "Universal" true 
 -- 
 -- OG:markSuper: "Universal" 
 -- Invocation:markForCodeGen: "Universal" 
 -- ObjectInvocation:markForCodeGen: "Universal"  ATd: "universal: Value{   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic 61;      in V: var integer;      ou ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Universal"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "char"  IS.isEmpty:  true 
 -- markItem: "newline := nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" Assign 
 -- Invocation:markForCodeGen: "newline" 
 -- ObjectInvocation:markForCodeGen: "newline"  ATd: "newline: var char" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" 
 -- "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" true 
 -- 
 -- DataItem:markForCodeGen: "console" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "ConsoleIF" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "ConsoleIF" 
 -- "ConsoleIF" false 
 -- 
 -- OG:markForCodeGen: "put:< {      ...;   puttext(T: var LIB.StringLib.String):< ;      inner(puttext);   putint(V: var Integer):< ;      inner(putint)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "put:< {      ...;   puttext(T: var LIB.StringLib.String):< ;      inner(puttext);   putint(V: var Integer):< ;      inner(putint)}" 
 -- OG:Qalloc: "put:< {      ...;   puttext(T: var LIB.StringLib.String):< ;      inner(puttext);   putint(V: var Integer):< ;      inner(putint)}" qDescno:  0 
 -- OG:Qalloc:A:  "ConsoleIF"  super:  ""  marked:  true "ConsoleIF: {   put:< ;      ...;   puttext(T: var LIB.StringLib.String):< ;      inner(puttext);   putint(V: var Inte ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57; ...} 
 -- OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic  ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "put:< {      ...;   puttext(T: var LIB.StringLib.String):< ;      inner(puttext);   putint(V: var Integer):< ;      inner(putint)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "ConsoleIF" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 8 IS.newDescNo: 8 objSize: 0 1: 1 "put:< {   ...;puttext(T: var LIB.StringLib.String):< ;   inner(puttext);putint(V: var Integer):< ;   inner(pu ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 8 "put:< {   ...;puttext(T: var LIB.StringLib.String):< ;   inner(puttext);putint(V: var Integer):< ;   inner(putint)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Pattern:Qalloc: put 
 -- Pattern:Qalloc:B: put 
 -- Pattern:Qalloc: puttext 
 -- Pattern:Qalloc:B: puttext 
 -- Pattern:Qalloc: putint 
 -- Pattern:Qalloc:B: putint 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 8 "put:< {   ...;puttext(T: var LIB.StringLib.String):< ;   inner(puttext);putint(V: var Integer):< ;   inner(putint)}" 
 -- IS.newDescNo: 8 IS.objSize: 1 "put:< {   ...;puttext(T: var LIB.StringLib.String):< ;   inner(puttext);putint(V: var Integer):< ;   inner(putint)}" 
 -- OG:Qalloc:end: IS.newDescNo:  8 "put:< {      ...;   puttext(T: var LIB.StringLib.String):< ;      inner(puttext);   putint(V: var Integer):< ;      inner(putint)}" 
 -- ObjTmpStack:add: "ConsoleIF" : "put:< {      ...;   puttext(T: var LIB.StringLib.String):< ;      inner(puttext);   putint(V: var Integer):< ;      inner(putint)}" 
 -- items:markForCodeGen: "put:< {   ...;puttext(T: var LIB.StringLib.String):< ;   inner(puttext);putint(V: var Integer):< ;   inner(putint)}" 
 -- Pattern:markForCodeGen: "put:< {   ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "..." 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "..." 
 -- OG:Qalloc: "..." qDescno:  0 
 -- OG:Qalloc:A:  "put"  super:  ""  marked:  true "put:< {   ...}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57; ...} 
 -- OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic  ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "..." 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "put" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 9 IS.newDescNo: 9 objSize: 0 1: 1 "..." 
 -- Items:Qalloc:objSize: 0  newDescNo: 9 "..." 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 9 "..." 
 -- IS.newDescNo: 9 IS.objSize: 1 "..." 
 -- OG:Qalloc:end: IS.newDescNo:  9 "..." 
 -- ObjTmpStack:add: "put" : "..." 
 -- items:markForCodeGen: "..." 
 -- markItem: "..." Dots 
 -- Pattern:markForCodeGen: "puttext(T: var LIB.StringLib.String):< {   inner(puttext)}" 
 -- items:markForCodeGen: "%$B "("{T: var LIB.StringLib.String;%$E ")"}" 
 -- markItem: "%$B "("" Property 
 -- DataItem:markForCodeGen: "T" :descNo: 0 :OG.primNo: 5 
 -- OG:markForCodeGen: "LIB.StringLib.String" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "LIB.StringLib.String" 
 -- "LIB" false 
 -- "StringLib" false 
 -- "String" true 
 -- 
 -- OG:markForCodeGen: "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- actually an  ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Value" 
 -- "Value" true 
 -- 
 -- OG:markSuper: "Value" 
 -- Invocation:markForCodeGen: "Value" 
 -- ObjectInvocation:markForCodeGen: "Value"  ATd: "Value: {   %ID Value;   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out  ...}" 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- actually an index er ...}" 
 -- OG:Qalloc: "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- actually an index er ...}" q ... 0 
 -- OG:Qalloc:A:  "String"  super:  "Value"  marked:  true "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: v ...}" s ... V ... 
 -- Invocation:Qalloc: "Value" 
 -- ObjectInvocation:Qalloc: "Value" 
 -- name: "Value" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  4 0 %ID Value{%globals;%basic 21;%public;=  :< ;   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inne ...} 
 -- OG:super:  "Value: {   %ID Value;   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out Beq: var boolean;      inner(= );    ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- actually an index error, access ...}" 
 -- super:  "Value" 
 -- E:  "Value" 
 -- OG:Qalloc:B: "String" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 10 IS.newDescNo: 10 objSize: 0 1: 1 "%id "String pattern"{%OSDvisibility disguised;%basic 5;%public;length: ;   out V: var integer;   V := get[0 ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 10 "%id "String pattern"{%OSDvisibility disguised;%basic 5;%public;length: ;   out V: var integer;   V := get[0] -- actually an index e ...}" 
 -- Items:Qalloc:super: "Value" size: 0 "String" 
 -- super.isThisBlockLevel: false superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 "" 
 -- Pattern:Qalloc: length 
 -- Pattern:Qalloc:B: length 
 -- Pattern:Qalloc: get 
 -- Pattern:Qalloc: + 
 -- Pattern:Qalloc:B: + 
 -- Pattern:Qalloc: asLowerCase 
 -- Pattern:Qalloc:B: asLowerCase 
 -- Pattern:Qalloc: scan 
 -- Pattern:Qalloc:B: scan 
 -- Pattern:Qalloc: print 
 -- Pattern:Qalloc:B: print 
 -- Pattern:Qalloc: = 
 -- Pattern:Qalloc:B: = 
 -- Pattern:Qalloc: <> 
 -- Pattern:Qalloc:B: <> 
 -- Pattern:Qalloc: <= 
 -- Pattern:Qalloc:B: <= 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 10 "%id "String pattern"{%OSDvisibility disguised;%basic 5;%public;length: ;   out V: var integer;   V := get[0] -- actually an ind ...}" 
 -- IS.newDescNo: 10 IS.objSize: 0 "%id "String pattern"{%OSDvisibility disguised;%basic 5;%public;length: ;   out V: var integer;   V := get[0] -- actually an index error, ac ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  10 "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] - ...}" 
 -- ObjTmpStack:add: "String" : "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- act ...}" 
 -- items:markForCodeGen: "%id "String pattern"{%OSDvisibility disguised;%basic 5;%public;length: ;   out V: var integer;   V := get[0] -- actually an index error, accessing l ...}" 
 -- markItem: "%id "String pattern"" Property 
 -- markItem: "%OSDvisibility disguised" Property 
 -- markItem: "%basic 5" Property 
 -- markItem: "%public" Property 
 -- Pattern:markForCodeGen: "=  :: {   loop: do ;      c1: var char;      c2: var char;      L: var integer;      L := length;      if (L <> Veq.length) :then ;         leave( ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "loop: do {      c1: var char;      c2: var char;      L: var integer;      L := length;      if (L <> Veq.length) :then ;         leave(loop);      beq ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "loop: do {      c1: var char;      c2: var char;      L: var integer;      L := length;      if (L <> Veq.length) :then ;         leave(loop);      beq := true ...}" 
 -- OG:Qalloc: "loop: do {      c1: var char;      c2: var char;      L: var integer;      L := length;      if (L <> Veq.length) :then ;         leave(loop);      beq := true ...}" q ... 0 
 -- OG:Qalloc:A:  "="  super:  ""  marked:  true "=  :: {   loop: do ;      c1: var char;      c2: var char;      L: var integer;      L := length;      if (L <> Veq.length) : ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 50{in Veq: var this(Value);out Beq: var boolean;inner(= )} 
 -- OG:Qalloc:SuperAlloc: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OG:Qalloc: "%basic 50{   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" qDescno:  0 
 -- OG:Qalloc:A:  "="  super:  ""  marked:  false "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57; ...} 
 -- OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic  ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 50{   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "=" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 11 IS.newDescNo: 11 objSize: 0 1: 1 "%basic 50{in Veq: var this(Value);out Beq: var boolean;inner(= )}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 11 "%basic 50{in Veq: var this(Value);out Beq: var boolean;inner(= )}" 
 -- Items:Qalloc:Super:C:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "Veq" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: false 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- dataitem:qalloc: "Beq" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- OG:Qalloc: "inner(= )" qDescno:  0 
 -- OG:Qalloc:A:  "inner"  super:  "inner(= )"  marked:  false "%basic 50{in Veq: var this(Value);out Beq: var boolean;inner(= )}" super:  inner(= ) 
 -- Invocation:Qalloc: "inner(= )" 
 -- ObjectInvocation:Qalloc: "inner(= )" 
 -- name: "inner" 
 -- Arguments "inner(= )" 
 -- OG:Qalloc: "= " qDescno:  0 
 -- OG:Qalloc:A:  "="  super:  "= "  marked:  false "inner(= )" super:  =  
 -- Invocation:Qalloc: "= " 
 -- ObjectInvocation:Qalloc: "= " 
 -- name: "=" 
 -- Arguments "" 
 -- OG:Qalloc: "" qDescno:  0 
 -- OG:Qalloc:A:  "emptyOG"  super:  ""  marked:  false "" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57; ...} 
 -- OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  11 5 %basic 50{in Veq: var this(Value);out Beq: var boolean;inner(= )} 
 -- OG:super:  "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "= " 
 -- super:  "= " 
 -- E:  "= " 
 -- OG:Qalloc:end: IS.newDescNo:  0 "= " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 101{in inner: ref Object} 
 -- OG:Qalloc:SuperAlloc: "inner: {   %basic 101;   in inner: ref Object}" 
 -- OG:Qalloc: "%basic 101{   in inner: ref Object}" qDescno:  0 
 -- OG:Qalloc:A:  "inner"  super:  ""  marked:  false "inner: {   %basic 101;   in inner: ref Object}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57; ...} 
 -- OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic  ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 101{   in inner: ref Object}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "inner" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 12 IS.newDescNo: 12 objSize: 0 1: 1 "%basic 101{in inner: ref Object}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 12 "%basic 101{in inner: ref Object}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "inner" isValue: false  isPrimitive: true  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "in inner: ref Object" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 12 "%basic 101{in inner: ref Object}" 
 -- IS.newDescNo: 12 IS.objSize: 2 "%basic 101{in inner: ref Object}" 
 -- OG:Qalloc:end: IS.newDescNo:  12 "%basic 101{   in inner: ref Object}" 
 -- OG:super:  "inner: {   %basic 101;   in inner: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(= )" 
 -- super:  "inner(= )" 
 -- E:  "inner(= )" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(= )" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 11 "%basic 50{in Veq: var this(Value);out Beq: var boolean;inner(= )}" 
 -- IS.newDescNo: 11 IS.objSize: 5 "%basic 50{in Veq: var this(Value);out Beq: var boolean;inner(= )}" 
 -- OG:Qalloc:end: IS.newDescNo:  11 "%basic 50{   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "loop: do {      c1: var char;      c2: var char;      L: var integer;      L := length;      if (L <> Veq.length) :then ;         leave(loop);      beq := true;      for( ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "=" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 13 IS.newDescNo: 13 objSize: 0 1: 1 "loop: do {   c1: var char;   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;  ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 13 "loop: do {   c1: var char;   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);   beq  ...}" 
 -- Items:Qalloc:super: "" size: 5 "=" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 5 originOff: 1 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 13 "loop: do {   c1: var char;   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);    ...}" 
 -- IS.newDescNo: 13 IS.objSize: 5 "loop: do {   c1: var char;   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);   beq := true; ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  13 "loop: do {      c1: var char;      c2: var char;      L: var integer;      L := length;      if (L <> Veq.length) :then ;         leave(l ...}" 
 -- ObjTmpStack:add: "=  " : "loop: do {      c1: var char;      c2: var char;      L: var integer;      L := length;      if (L <> Veq.length) :then ;         leave(loop);    ...}" 
 -- items:markForCodeGen: "loop: do {   c1: var char;   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);   beq := true;   for(1) ...}" 
 -- OG:markForCodeGen: "c1: var char{   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);   beq := true;   for(1):to(length):repe ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "c1: var char{   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);   beq := true;   for(1):to(length):repeat;      ...}" 
 -- OG:Qalloc: "c1: var char{   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);   beq := true;   for(1):to(length):repeat;      ...}" q ... 0 
 -- OG:Qalloc:A:  "loop"  super:  ""  marked:  true "loop: do {   c1: var char;   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57; ...} 
 -- OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic  ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "c1: var char{   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);   beq := true;   for(1):to(length):repeat;      c1 := get[ ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "loop" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 14 IS.newDescNo: 14 objSize: 0 1: 1 "c1: var char{c2: var char;L: var integer;L := length;if (L <> Veq.length) :then ;   leave(loop);beq := true ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 14 "c1: var char{c2: var char;L: var integer;L := length;if (L <> Veq.length) :then ;   leave(loop);beq := true;for(1):to(length):repea ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- dataitem:qalloc: "c1" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- dataitem:qalloc: "c2" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "L" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- Invocation:Qalloc: "L" 
 -- ObjectInvocation:Qalloc: "L" 
 -- name: "L" 
 -- Arguments "" 
 -- OG:Qalloc: "length" qDescno:  0 
 -- OG:Qalloc:A:  "length"  super:  "length"  marked:  false "L := length" super:  length 
 -- Invocation:Qalloc: "length" 
 -- ObjectInvocation:Qalloc: "length" 
 -- name: "length" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 out V: var integer{V := get[0] -- actually an index error, accessing length} 
 -- OG:Qalloc:SuperAlloc: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OG:Qalloc: "out V: var integer{   V := get[0] -- actually an index error, accessing length}" qDescno:  0 
 -- OG:Qalloc:A:  "length"  super:  ""  marked:  false "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57; ...} 
 -- OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic  ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "out V: var integer{   V := get[0] -- actually an index error, accessing length}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "length" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 15 IS.newDescNo: 15 objSize: 0 1: 1 "out V: var integer{V := get[0] -- actually an index error, accessing length}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 15 "out V: var integer{V := get[0] -- actually an index error, accessing length}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Invocation:Qalloc: "V" 
 -- ObjectInvocation:Qalloc: "V" 
 -- name: "V" 
 -- Arguments "" 
 -- OG:Qalloc: "get[0] -- actually an index error, accessing length" qDescno:  0 
 -- OG:Qalloc:A:  "get"  super:  "get[0] -- actually an index error, accessing length"  marked:  false "V := get[0] -- actually an index error, accessing length" super:  get[0 ... 
 -- Invocation:Qalloc: "get[0] -- actually an index error, accessing length" 
 -- ObjectInvocation:Qalloc: "get[0] -- actually an index error, accessing length" 
 -- name: "get" 
 -- Arguments "get[0]" 
 -- OG:Qalloc: "0" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "0"  marked:  false "get[0]" super:  0 
 -- Invocation:Qalloc: "0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "0" 
 -- super:  "0" 
 -- E:  "0" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 117{out ch: var char} 
 -- OG:Qalloc:SuperAlloc: "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- OG:Qalloc: "%basic 117{   out ch: var char}" qDescno:  0 
 -- OG:Qalloc:A:  "get"  super:  ""  marked:  false "get[inx: var integer]: {   %basic 117;   out ch: var char}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57; ...} 
 -- OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic  ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 117{   out ch: var char}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "get" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 16 IS.newDescNo: 16 objSize: 0 1: 1 "%basic 117{out ch: var char}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 16 "%basic 117{out ch: var char}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "%$B "["{inx: var integer;%$E "]"}" 
 -- dataitem:qalloc: "inx" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "%$B "["{inx: var integer;%$E "]"}" 
 -- dataitem:qalloc: "ch" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 16 "%basic 117{out ch: var char}" 
 -- IS.newDescNo: 16 IS.objSize: 3 "%basic 117{out ch: var char}" 
 -- OG:Qalloc:end: IS.newDescNo:  16 "%basic 117{   out ch: var char}" 
 -- OG:super:  "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "get[0] -- actually an index error, accessing length" 
 -- super:  "get[0] -- actually an index error, accessing length" 
 -- E:  "get[0] -- actually an index error, accessing length" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "get[0] -- actually an index error, accessing length" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 15 "out V: var integer{V := get[0] -- actually an index error, accessing length}" 
 -- IS.newDescNo: 15 IS.objSize: 2 "out V: var integer{V := get[0] -- actually an index error, accessing length}" 
 -- OG:Qalloc:end: IS.newDescNo:  15 "out V: var integer{   V := get[0] -- actually an index error, accessing length}" 
 -- OG:super:  "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "length" 
 -- super:  "length" 
 -- E:  "length" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "length" 
 -- OG:Qalloc: "if (L <> Veq.length) :then {   leave(loop)}" qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (L <> Veq.length) :then {   leave(loop)}"  marked:  false "c1: var char{c2: var char;L: var integer;L := length;if (L <> Veq.length) ...}" s ... i ... 
 -- Invocation:Qalloc: "if (L <> Veq.length) :then {   leave(loop)}" 
 -- OG:Qalloc: "(L <> Veq.length)" qDescno:  0 
 -- OG:Qalloc:A:  "<>"  super:  "(L <> Veq.length)"  marked:  false "if (L <> Veq.length) :then {   leave(loop)}" super:  (L <> Veq.length) 
 -- Invocation:Qalloc: "(L <> Veq.length)" 
 -- Invocation:Qalloc: "L <> Veq.length" 
 -- BinaryExp:Qalloc: "L <> Veq.length" 
 -- Invocation:Qalloc: "L" 
 -- ObjectInvocation:Qalloc: "L" 
 -- name: "L" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "<> Veq.length" 
 -- name: "<>" 
 -- Arguments "Veq.length" 
 -- OG:Qalloc: "Veq.length" qDescno:  0 
 -- OG:Qalloc:A:  "length"  super:  "Veq.length"  marked:  false "Veq.length" super:  Veq.length 
 -- Invocation:Qalloc: "Veq.length" 
 -- ObjectInvocation:Qalloc: "Veq" 
 -- name: "Veq" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "length" 
 -- name: "length" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  15 2 out V: var integer{V := get[0] -- actually an index error, accessing length} 
 -- OG:super:  "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Veq.length" 
 -- super:  "Veq.length" 
 -- E:  "length" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Veq.length" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 55{in V: var integer;out B: var boolean} 
 -- OG:Qalloc:SuperAlloc: "<>  : {   %basic 55;   in V: var integer;   out B: var boolean}" 
 -- OG:Qalloc: "%basic 55{   in V: var integer;   out B: var boolean}" qDescno:  0 
 -- OG:Qalloc:A:  "<>"  super:  ""  marked:  false "<>  : {   %basic 55;   in V: var integer;   out B: var boolean}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57; ...} 
 -- OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic  ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 55{   in V: var integer;   out B: var boolean}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "<>" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 17 IS.newDescNo: 17 objSize: 0 1: 1 "%basic 55{in V: var integer;out B: var boolean}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 17 "%basic 55{in V: var integer;out B: var boolean}" 
 -- Items:Qalloc:Super:C:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- dataitem:qalloc: "B" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 17 "%basic 55{in V: var integer;out B: var boolean}" 
 -- IS.newDescNo: 17 IS.objSize: 5 "%basic 55{in V: var integer;out B: var boolean}" 
 -- OG:Qalloc:end: IS.newDescNo:  17 "%basic 55{   in V: var integer;   out B: var boolean}" 
 -- OG:super:  "<>  : {   %basic 55;   in V: var integer;   out B: var boolean}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(L <> Veq.length)" 
 -- super:  "(L <> Veq.length)" 
 -- E:  "(L <> Veq.length)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(L <> Veq.length)" 
 -- OG:Qalloc: "leave(loop)" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (L <> Veq.length) :then {   leave(loop)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57; ...} 
 -- OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic  ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "leave(loop)" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 18 IS.newDescNo: 18 objSize: 0 1: 1 "leave(loop)" 
 -- Items:Qalloc:objSize: 0  newDescNo: 18 "leave(loop)" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: "leave(loop)" qDescno:  0 
 -- OG:Qalloc:A:  "leave"  super:  "leave(loop)"  marked:  false "leave(loop)" super:  leave(loop) 
 -- Invocation:Qalloc: "leave(loop)" 
 -- ObjectInvocation:Qalloc: "leave(loop)" 
 -- name: "leave" 
 -- Arguments "leave(loop)" 
 -- OG:Qalloc: "loop" qDescno:  0 
 -- OG:Qalloc:A:  "loop"  super:  "loop"  marked:  false "leave(loop)" super:  loop 
 -- Invocation:Qalloc: "loop" 
 -- ObjectInvocation:Qalloc: "loop" 
 -- name: "loop" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  14 4 c1: var char{c2: var char;L: var integer;L := length;if (L <> Veq.length) :then ;   leave(loop);beq := true;for(1) ...} 
 -- OG:super:  "loop: do {   c1: var char;   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);   beq := true;   for(1):to(length) ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "loop" 
 -- super:  "loop" 
 -- E:  "loop" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "loop" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 103 
 -- OG:Qalloc:SuperAlloc: "leave(V: var integer): {   %basic 103}" 
 -- OG:Qalloc: "%basic 103" qDescno:  0 
 -- OG:Qalloc:A:  "leave"  super:  ""  marked:  false "leave(V: var integer): {   %basic 103}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57; ...} 
 -- OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic  ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 103" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "leave" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 19 IS.newDescNo: 19 objSize: 0 1: 1 "%basic 103" 
 -- Items:Qalloc:objSize: 0  newDescNo: 19 "%basic 103" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "%$B "("{V: var integer;%$E ")"}" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "%$B "("{V: var integer;%$E ")"}" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 19 "%basic 103" 
 -- IS.newDescNo: 19 IS.objSize: 2 "%basic 103" 
 -- OG:Qalloc:end: IS.newDescNo:  19 "%basic 103" 
 -- OG:super:  "leave(V: var integer): {   %basic 103}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "leave(loop)" 
 -- super:  "leave(loop)" 
 -- E:  "leave(loop)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "leave(loop)" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 18 "leave(loop)" 
 -- IS.newDescNo: 18 IS.objSize: 1 "leave(loop)" 
 -- OG:Qalloc:end: IS.newDescNo:  18 "leave(loop)" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:Qalloc:SuperAlloc: "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc: "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" qDescno:  0 
 -- OG:Qalloc:A:  "if:then"  super:  ""  marked:  false "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" super ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57; ...} 
 -- OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic  ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "if:then" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 20 IS.newDescNo: 20 objSize: 0 1: 1 "%OSDvisibility skipInternal{%basic 100;%globals inSub}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 20 "%OSDvisibility skipInternal{%basic 100;%globals inSub}" 
 -- Items:Qalloc:Super:C:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 "%$B "("{cond: var boolean;%$S "):then{";thenPart:< object;%$E "}"}" 
 -- dataitem:qalloc: "cond" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Pattern:Qalloc: thenPart 
 -- Pattern:Qalloc:B: thenPart 
 -- (OG.super.desc).newDescNo = 0 
 -- OG:Qalloc: "%ID Object{   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic 57;      in objx: ref O ...}" q ... 0 
 -- OG:Qalloc:A:  "Object"  super:  ""  marked:  false "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boo ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  false  IS.superDesc.newDescNo:  
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%ID Object{   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic 57;      in objx: ref Object;      ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "Object" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 21 IS.newDescNo: 21 objSize: 0 1: 1 "%ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %b ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 21 "%ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57;   in objx: ref  ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Pattern:Qalloc: == 
 -- Pattern:Qalloc: =/= 
 -- Pattern:Qalloc: suspend 
 -- Pattern:Qalloc: attach 
 -- Pattern:Qalloc: call 
 -- Pattern:Qalloc: resume 
 -- Pattern:Qalloc: onResume 
 -- Pattern:Qalloc: onSuspend 
 -- Pattern:Qalloc: dumpObj 
 -- Pattern:Qalloc: X_asString 
 -- Pattern:Qalloc:B: X_asString 
 -- OG:Qalloc: "inner(Object)" qDescno:  0 
 -- OG:Qalloc:A:  "inner"  super:  "inner(Object)"  marked:  false "%ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %b ...}" s ... i ... 
 -- Invocation:Qalloc: "inner(Object)" 
 -- ObjectInvocation:Qalloc: "inner(Object)" 
 -- name: "inner" 
 -- Arguments "inner(Object)" 
 -- OG:Qalloc: "Object" qDescno:  0 
 -- OG:Qalloc:A:  "Object"  super:  "Object"  marked:  false "inner(Object)" super:  Object 
 -- Invocation:Qalloc: "Object" 
 -- ObjectInvocation:Qalloc: "Object" 
 -- name: "Object" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:super:  "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic 57;      in ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Object" 
 -- super:  "Object" 
 -- E:  "Object" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Object" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 %basic 101{in inner: ref Object} 
 -- OG:super:  "inner: {   %basic 101;   in inner: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(Object)" 
 -- super:  "inner(Object)" 
 -- E:  "inner(Object)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(Object)" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 21 "%ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57;   in objx:  ...}" 
 -- IS.newDescNo: 21 IS.objSize: 1 "%ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57;   in objx: ref Object;  ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  21 "%ID Object{   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic 5 ...}" 
 -- Pattern:qalloc:super:descNo: 21 thenPart:< object 
 -- Pattern:Qalloc: thenPart$22 
 -- Pattern:Qalloc:B: thenPart$22 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "%$B "("{cond: var boolean;%$S "):then{";thenPart:< object;%$E "}"}" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 20 "%OSDvisibility skipInternal{%basic 100;%globals inSub}" 
 -- IS.newDescNo: 20 IS.objSize: 1 "%OSDvisibility skipInternal{%basic 100;%globals inSub}" 
 -- OG:Qalloc:end: IS.newDescNo:  20 "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (L <> Veq.length) :then {   leave(loop)}" 
 -- super:  "if (L <> Veq.length) :then {   leave(loop)}" 
 -- E:  "if (L <> Veq.length) :then {   leave(loop)}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (L <> Veq.length) :then {   leave(loop)}" 
 -- Invocation:Qalloc: "beq" 
 -- ObjectInvocation:Qalloc: "beq" 
 -- name: "beq" 
 -- Arguments "" 
 -- OG:Qalloc: "true" qDescno:  0 
 -- OG:Qalloc:A:  "True"  super:  "true"  marked:  false "beq := true" super:  true 
 -- Invocation:Qalloc: "true" 
 -- ObjectInvocation:Qalloc: "true" 
 -- name: "true" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %globals{out B: var boolean;B := 1} 
 -- OG:Qalloc:SuperAlloc: "True: {   %globals;   out B: var boolean;   B := 1}" 
 -- OG:Qalloc: "%globals{   out B: var boolean;   B := 1}" qDescno:  0 
 -- OG:Qalloc:A:  "True"  super:  ""  marked:  false "True: {   %globals;   out B: var boolean;   B := 1}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%globals{   out B: var boolean;   B := 1}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "True" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 23 IS.newDescNo: 23 objSize: 0 1: 1 "%globals{out B: var boolean;B := 1}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 23 "%globals{out B: var boolean;B := 1}" 
 -- Items:Qalloc:Super:C:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 "" 
 -- dataitem:qalloc: "B" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Invocation:Qalloc: "B" 
 -- ObjectInvocation:Qalloc: "B" 
 -- name: "B" 
 -- Arguments "" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "B := 1" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 23 "%globals{out B: var boolean;B := 1}" 
 -- IS.newDescNo: 23 IS.objSize: 1 "%globals{out B: var boolean;B := 1}" 
 -- OG:Qalloc:end: IS.newDescNo:  23 "%globals{   out B: var boolean;   B := 1}" 
 -- OG:super:  "True: {   %globals;   out B: var boolean;   B := 1}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "true" 
 -- super:  "true" 
 -- E:  "true" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "true" 
 -- OG:Qalloc: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" qDescno:  0 
 -- OG:Qalloc:A:  "for:to:repeat$0"  super:  "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}"   ... false "c ..." s ... f ... 
 -- Invocation:Qalloc: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- ObjectInvocation:Qalloc: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- name: "for:to:repeat" 
 -- Arguments "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      lea ...}" s ... 1 ... 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- OG:Qalloc: "length" qDescno:  0 
 -- OG:Qalloc:A:  "length"  super:  "length"  marked:  false "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      ...}" s ... l ... 
 -- Invocation:Qalloc: "length" 
 -- ObjectInvocation:Qalloc: "length" 
 -- name: "length" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  15 2 out V: var integer{V := get[0] -- actually an index error, accessing length} 
 -- OG:super:  "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "length" 
 -- super:  "length" 
 -- E:  "length" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "length" 
 -- OG:Qalloc: "c1 := get[inx]{   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop)}" qDescno:  0 
 -- OG:Qalloc:A:  "repeat$0"  super:  ""  marked:  false "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      lea ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "c1 := get[inx]{   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "repeat$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 24 IS.newDescNo: 24 objSize: 0 1: 1 "c1 := get[inx]{c2 := Veq.get[inx];if (c1 <> c2) :then ;   Beq := false;   leave(loop)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 24 "c1 := get[inx]{c2 := Veq.get[inx];if (c1 <> c2) :then ;   Beq := false;   leave(loop)}" 
 -- Items:Qalloc:super: "" size: 1 "repeat$24" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "c1" 
 -- ObjectInvocation:Qalloc: "c1" 
 -- name: "c1" 
 -- Arguments "" 
 -- OG:Qalloc: "get[inx]" qDescno:  0 
 -- OG:Qalloc:A:  "get"  super:  "get[inx]"  marked:  false "c1 := get[inx]" super:  get[inx] 
 -- Invocation:Qalloc: "get[inx]" 
 -- ObjectInvocation:Qalloc: "get[inx]" 
 -- name: "get" 
 -- Arguments "get[inx]" 
 -- OG:Qalloc: "inx" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "inx"  marked:  false "get[inx]" super:  inx 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "inx: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx" 
 -- super:  "inx" 
 -- E:  "inx" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  16 3 %basic 117{out ch: var char} 
 -- OG:super:  "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "get[inx]" 
 -- super:  "get[inx]" 
 -- E:  "get[inx]" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "get[inx]" 
 -- Invocation:Qalloc: "c2" 
 -- ObjectInvocation:Qalloc: "c2" 
 -- name: "c2" 
 -- Arguments "" 
 -- OG:Qalloc: "Veq.get[inx]" qDescno:  0 
 -- OG:Qalloc:A:  "get"  super:  "Veq.get[inx]"  marked:  false "c2 := Veq.get[inx]" super:  Veq.get[inx] 
 -- Invocation:Qalloc: "Veq.get[inx]" 
 -- ObjectInvocation:Qalloc: "Veq" 
 -- name: "Veq" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "get[inx]" 
 -- name: "get" 
 -- Arguments "get[inx]" 
 -- OG:Qalloc: "inx" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "inx"  marked:  false "get[inx]" super:  inx 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "inx: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx" 
 -- super:  "inx" 
 -- E:  "inx" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  16 3 %basic 117{out ch: var char} 
 -- OG:super:  "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Veq.get[inx]" 
 -- super:  "Veq.get[inx]" 
 -- E:  "get[inx]" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Veq.get[inx]" 
 -- OG:Qalloc: "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (c1 <> c2) :then {   Beq := false;   leave(loop)}"  marked:  false "c1 := get[inx]{c2 := Veq.get[inx];if (c1 <> c2) :then ;   Beq := ...}" s ... i ... 
 -- Invocation:Qalloc: "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- OG:Qalloc: "(c1 <> c2)" qDescno:  0 
 -- OG:Qalloc:A:  "<>"  super:  "(c1 <> c2)"  marked:  false "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" super:  (c1 <> c2) 
 -- Invocation:Qalloc: "(c1 <> c2)" 
 -- Invocation:Qalloc: "c1 <> c2" 
 -- BinaryExp:Qalloc: "c1 <> c2" 
 -- Invocation:Qalloc: "c1" 
 -- ObjectInvocation:Qalloc: "c1" 
 -- name: "c1" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "<> c2" 
 -- name: "<>" 
 -- Arguments "c2" 
 -- OG:Qalloc: "c2" qDescno:  0 
 -- OG:Qalloc:A:  "char"  super:  "c2"  marked:  false "c2" super:  c2 
 -- Invocation:Qalloc: "c2" 
 -- ObjectInvocation:Qalloc: "c2" 
 -- name: "c2" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  7 1 %id "char"{%globals;%basic 3, 16;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var char;   out ...} 
 -- OG:super:  "c2: var char" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "c2" 
 -- super:  "c2" 
 -- E:  "c2" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "c2" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 55{in V: var char;out B: var boolean} 
 -- OG:Qalloc:SuperAlloc: "<>  : {   %basic 55;   in V: var char;   out B: var boolean}" 
 -- OG:Qalloc: "%basic 55{   in V: var char;   out B: var boolean}" qDescno:  0 
 -- OG:Qalloc:A:  "<>"  super:  ""  marked:  false "<>  : {   %basic 55;   in V: var char;   out B: var boolean}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 55{   in V: var char;   out B: var boolean}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "<>" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 25 IS.newDescNo: 25 objSize: 0 1: 1 "%basic 55{in V: var char;out B: var boolean}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 25 "%basic 55{in V: var char;out B: var boolean}" 
 -- Items:Qalloc:Super:C:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- dataitem:qalloc: "B" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 25 "%basic 55{in V: var char;out B: var boolean}" 
 -- IS.newDescNo: 25 IS.objSize: 5 "%basic 55{in V: var char;out B: var boolean}" 
 -- OG:Qalloc:end: IS.newDescNo:  25 "%basic 55{   in V: var char;   out B: var boolean}" 
 -- OG:super:  "<>  : {   %basic 55;   in V: var char;   out B: var boolean}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(c1 <> c2)" 
 -- super:  "(c1 <> c2)" 
 -- E:  "(c1 <> c2)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(c1 <> c2)" 
 -- OG:Qalloc: "Beq := false{   leave(loop)}" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Beq := false{   leave(loop)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 26 IS.newDescNo: 26 objSize: 0 1: 1 "Beq := false{leave(loop)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 26 "Beq := false{leave(loop)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "Beq" 
 -- ObjectInvocation:Qalloc: "Beq" 
 -- name: "Beq" 
 -- Arguments "" 
 -- OG:Qalloc: "false" qDescno:  0 
 -- OG:Qalloc:A:  "False"  super:  "false"  marked:  false "Beq := false" super:  false 
 -- Invocation:Qalloc: "false" 
 -- ObjectInvocation:Qalloc: "false" 
 -- name: "false" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %globals{out B: var boolean;B := 0} 
 -- OG:Qalloc:SuperAlloc: "False: {   %globals;   out B: var boolean;   B := 0}" 
 -- OG:Qalloc: "%globals{   out B: var boolean;   B := 0}" qDescno:  0 
 -- OG:Qalloc:A:  "False"  super:  ""  marked:  false "False: {   %globals;   out B: var boolean;   B := 0}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%globals{   out B: var boolean;   B := 0}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "False" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 27 IS.newDescNo: 27 objSize: 0 1: 1 "%globals{out B: var boolean;B := 0}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 27 "%globals{out B: var boolean;B := 0}" 
 -- Items:Qalloc:Super:C:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 "" 
 -- dataitem:qalloc: "B" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Invocation:Qalloc: "B" 
 -- ObjectInvocation:Qalloc: "B" 
 -- name: "B" 
 -- Arguments "" 
 -- OG:Qalloc: "0" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "0"  marked:  false "B := 0" super:  0 
 -- Invocation:Qalloc: "0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "0" 
 -- super:  "0" 
 -- E:  "0" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "0" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 27 "%globals{out B: var boolean;B := 0}" 
 -- IS.newDescNo: 27 IS.objSize: 1 "%globals{out B: var boolean;B := 0}" 
 -- OG:Qalloc:end: IS.newDescNo:  27 "%globals{   out B: var boolean;   B := 0}" 
 -- OG:super:  "False: {   %globals;   out B: var boolean;   B := 0}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "false" 
 -- super:  "false" 
 -- E:  "false" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "false" 
 -- OG:Qalloc: "leave(loop)" qDescno:  0 
 -- OG:Qalloc:A:  "leave"  super:  "leave(loop)"  marked:  false "Beq := false{leave(loop)}" super:  leave(loop) 
 -- Invocation:Qalloc: "leave(loop)" 
 -- ObjectInvocation:Qalloc: "leave(loop)" 
 -- name: "leave" 
 -- Arguments "leave(loop)" 
 -- OG:Qalloc: "loop" qDescno:  0 
 -- OG:Qalloc:A:  "loop"  super:  "loop"  marked:  false "leave(loop)" super:  loop 
 -- Invocation:Qalloc: "loop" 
 -- ObjectInvocation:Qalloc: "loop" 
 -- name: "loop" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  14 4 c1: var char{c2: var char;L: var integer;L := length;if (L <> Veq.length) :then ;   leave(loop);beq := true;for(1) ...} 
 -- OG:super:  "loop: do {   c1: var char;   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);   beq := true;   for(1):to(length) ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "loop" 
 -- super:  "loop" 
 -- E:  "loop" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "loop" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  19 2 %basic 103 
 -- OG:super:  "leave(V: var integer): {   %basic 103}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "leave(loop)" 
 -- super:  "leave(loop)" 
 -- E:  "leave(loop)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "leave(loop)" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 26 "Beq := false{leave(loop)}" 
 -- IS.newDescNo: 26 IS.objSize: 1 "Beq := false{leave(loop)}" 
 -- OG:Qalloc:end: IS.newDescNo:  26 "Beq := false{   leave(loop)}" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- super:  "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- E:  "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 24 "c1 := get[inx]{c2 := Veq.get[inx];if (c1 <> c2) :then ;   Beq := false;   leave(loop)}" 
 -- IS.newDescNo: 24 IS.objSize: 1 "c1 := get[inx]{c2 := Veq.get[inx];if (c1 <> c2) :then ;   Beq := false;   leave(loop)}" 
 -- OG:Qalloc:end: IS.newDescNo:  24 "c1 := get[inx]{   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop)}" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %OSDvisibility skipInternal{%globals inSub;inx: var integer;inx := first;_doIt: do ;   if (inx <= last) :then ;     ...} 
 -- OG:Qalloc:SuperAlloc: "for(first: var integer):to(last: var integer):repeat{repeat:< object}: {   %OSDvisibility skipInternal;   %globals inSub;   inx: var integer;   inx  ...}" 
 -- OG:Qalloc: "%OSDvisibility skipInternal{   %globals inSub;   inx: var integer;   inx := first;   _doIt: do ;      if (inx <= last) :then ;         repeat;         inx := i ...}" q ... 0 
 -- OG:Qalloc:A:  "for:to:repeat"  super:  ""  marked:  false "for(first: var integer):to(last: var integer):repeat{repeat:< object}: {   %OSDvisibility skipInternal;   %globa ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%OSDvisibility skipInternal{   %globals inSub;   inx: var integer;   inx := first;   _doIt: do ;      if (inx <= last) :then ;         repeat;         inx := inx + 1;     ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "for:to:repeat" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 28 IS.newDescNo: 28 objSize: 0 1: 1 "%OSDvisibility skipInternal{%globals inSub;inx: var integer;inx := first;_doIt: do ;   if (inx <= last) :th ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 28 "%OSDvisibility skipInternal{%globals inSub;inx: var integer;inx := first;_doIt: do ;   if (inx <= last) :then ;      repeat;      i ...}" 
 -- Items:Qalloc:Super:C:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 "%$B "("{first: var integer;%$S "):to(";last: var integer;%$S "):repeat{";repeat:< object;%$E "}"}" 
 -- dataitem:qalloc: "first" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "last" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Pattern:Qalloc: repeat 
 -- Pattern:Qalloc:B: repeat 
 -- Pattern:Qalloc: repeat$29 
 -- Pattern:Qalloc:B: repeat$29 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "%$B "("{first: var integer;%$S "):to(";last: var integer;%$S "):repeat{";repeat:< object;%$E "}"}" 
 -- dataitem:qalloc: "inx" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- OG:Qalloc: "first" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "first"  marked:  false "inx := first" super:  first 
 -- Invocation:Qalloc: "first" 
 -- ObjectInvocation:Qalloc: "first" 
 -- name: "first" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "first: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "first" 
 -- super:  "first" 
 -- E:  "first" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "first" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 28 "%OSDvisibility skipInternal{%globals inSub;inx: var integer;inx := first;_doIt: do ;   if (inx <= last) :then ;      repeat;    ...}" 
 -- IS.newDescNo: 28 IS.objSize: 3 "%OSDvisibility skipInternal{%globals inSub;inx: var integer;inx := first;_doIt: do ;   if (inx <= last) :then ;      repeat;      inx := in ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  28 "%OSDvisibility skipInternal{   %globals inSub;   inx: var integer;   inx := first;   _doIt: do ;      if (inx <= last) :then ;         re ...}" 
 -- OG:super:  "for(first: var integer):to(last: var integer):repeat{repeat:< object}: {   %OSDvisibility skipInternal;   %globals inSub;   inx: var integer;   inx := first;   ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- super:  "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- E:  "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- OG:Qalloc:B: "for:to:repeat$0" newDescNo: 0 objSize: 3 
 -- OG:isObjectDesc:NewDescNo: 30 IS.newDescNo: 30 objSize: 3 1: 1 "" 
 -- Items:Qalloc:objSize: 0  newDescNo: 30 "" 
 -- Items:Qalloc:super: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" size: 3 "for:to:repea ..." 
 -- super.isThisBlockLevel: false superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 4 originOff: 4 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 30 "" 
 -- IS.newDescNo: 30 IS.objSize: 3 "" 
 -- OG:Qalloc:end: IS.newDescNo:  30 "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 14 "c1: var char{c2: var char;L: var integer;L := length;if (L <> Veq.length) :then ;   leave(loop);beq := true;for(1):to(length):r ...}" 
 -- IS.newDescNo: 14 IS.objSize: 4 "c1: var char{c2: var char;L: var integer;L := length;if (L <> Veq.length) :then ;   leave(loop);beq := true;for(1):to(length):repeat;   c1  ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  14 "c1: var char{   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);   beq := true;   for(1):t ...}" 
 -- ObjTmpStack:add: "loop" : "c1: var char{   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);   beq := true;   for(1):to(lengt ...}" 
 -- items:markForCodeGen: "c1: var char{c2: var char;L: var integer;L := length;if (L <> Veq.length) :then ;   leave(loop);beq := true;for(1):to(length):repeat;   c1 := get[in ...}" 
 -- DataItem:markForCodeGen: "c1" :descNo: 0 :OG.primNo: 3 
 -- OG:markForCodeGen: "char" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "char" 
 -- "char" true 
 -- 
 -- OG:markSuper: "char" 
 -- Invocation:markForCodeGen: "char" 
 -- ObjectInvocation:markForCodeGen: "char"  ATd: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61; ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "char"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "c2" :descNo: 0 :OG.primNo: 3 
 -- OG:markForCodeGen: "char" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "char" 
 -- "char" true 
 -- 
 -- OG:markSuper: "char" 
 -- Invocation:markForCodeGen: "char" 
 -- ObjectInvocation:markForCodeGen: "char"  ATd: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61; ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "char"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "L" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- Pattern:markForCodeGen: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var in ...}" 
 -- items:markForCodeGen: "" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- markItem: "L := length" Assign 
 -- Invocation:markForCodeGen: "L" 
 -- ObjectInvocation:markForCodeGen: "L"  ATd: "L: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "length" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "length" 
 -- "length" false 
 -- 
 -- OG:markSuper: "length" 
 -- Invocation:markForCodeGen: "length" 
 -- ObjectInvocation:markForCodeGen: "length"  ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- Pattern:markForCodeGen: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "out V: var integer{   V := get[0] -- actually an index error, accessing length}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "out V: var integer{   V := get[0] -- actually an index error, accessing length}" 
 -- OG:Qalloc: "out V: var integer{   V := get[0] -- actually an index error, accessing length}" qDescno:  15 
 -- ObjTmpStack:add: "length" : "out V: var integer{   V := get[0] -- actually an index error, accessing length}" 
 -- items:markForCodeGen: "out V: var integer{V := get[0] -- actually an index error, accessing length}" 
 -- DataItem:markForCodeGen: "V" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- markItem: "V := get[0] -- actually an index error, accessing length" Assign 
 -- Invocation:markForCodeGen: "V" 
 -- ObjectInvocation:markForCodeGen: "V"  ATd: "out V: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "length"  IS.isEmpty:  true 
 -- markItem: "if (L <> Veq.length) :then {   leave(loop)}" ObjectGenerator 
 -- OG:markForCodeGen: "if (L <> Veq.length) :then {   leave(loop)}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (L <> Veq.length) :then {   leave(loop)}" 
 -- "if (L <> Veq.length) :then {   leave(loop)}" true 
 -- 
 -- OG:markSuper: "if (L <> Veq.length) :then {   leave(loop)}" 
 -- Invocation:markForCodeGen: "if (L <> Veq.length) :then {   leave(loop)}" 
 -- OG:markForCodeGen: "(L <> Veq.length)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(L <> Veq.length)" 
 -- "(L <> Veq.length)" true 
 -- 
 -- OG:markSuper: "(L <> Veq.length)" 
 -- Invocation:markForCodeGen: "(L <> Veq.length)" 
 -- Invocation:markForCodeGen: "L <> Veq.length" 
 -- BinaryExp:markForCodeGen: "L <> Veq.length" 
 -- Invocation:markForCodeGen: "L" 
 -- ObjectInvocation:markForCodeGen: "L"  ATd: "L: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "<> Veq.length"  ATd: "<>  : {   %basic 55;   in V: var integer;   out B: var boolean}" 
 -- Pattern:markForCodeGen: "<>  : {   %basic 55;   in V: var integer;   out B: var boolean}" 
 -- items:markForCodeGen: "" 
 -- OI:args:markForCodgen: "Veq.length" 
 -- OG:markForCodeGen: "Veq.length" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Veq.length" 
 -- "Veq" true 
 -- "length" false 
 -- 
 -- OG:markSuper: "Veq.length" 
 -- Invocation:markForCodeGen: "Veq.length" 
 -- ObjectInvocation:markForCodeGen: "Veq"  ATd: "in Veq: var this(Value)" 
 -- DataItem:markForCodeGen: "Veq" :descNo: 0 :OG.primNo: 18 
 -- OG:markForCodeGen: "this(Value)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "this(Value)" 
 -- "this(Value)" true 
 -- 
 -- OG:markSuper: "this(Value)" 
 -- Invocation:markForCodeGen: "this(Value)" 
 -- ObjectInvocation:markForCodeGen: "this(Value)"  ATd: "this: {   %basic 18;   in this: ref Object}" 
 -- Pattern:markForCodeGen: "this: {   %basic 18;   in this: ref Object}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "%basic 18{   in this: ref Object}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%basic 18{   in this: ref Object}" 
 -- OG:Qalloc: "%basic 18{   in this: ref Object}" qDescno:  0 
 -- OG:Qalloc:A:  "this"  super:  ""  marked:  true "this: {   %basic 18;   in this: ref Object}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 18{   in this: ref Object}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "this" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 31 IS.newDescNo: 31 objSize: 0 1: 1 "%basic 18{in this: ref Object}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 31 "%basic 18{in this: ref Object}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "this" isValue: false  isPrimitive: true  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "in this: ref Object" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 31 "%basic 18{in this: ref Object}" 
 -- IS.newDescNo: 31 IS.objSize: 2 "%basic 18{in this: ref Object}" 
 -- OG:Qalloc:end: IS.newDescNo:  31 "%basic 18{   in this: ref Object}" 
 -- ObjTmpStack:add: "this" : "%basic 18{   in this: ref Object}" 
 -- items:markForCodeGen: "%basic 18{in this: ref Object}" 
 -- markItem: "%basic 18" Property 
 -- DataItem:markForCodeGen: "this" :descNo: 0 :OG.primNo: 64 
 -- OG:markForCodeGen: "Object" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Object" 
 -- "Object" true 
 -- 
 -- OG:markForCodeGen: "%ID Object{   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic 57;      in obj ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%ID Object{   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic 57;      in objx: ref O ...}" 
 -- OG:Qalloc: "%ID Object{   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic 57;      in objx: ref O ...}" q ... 21 
 -- ObjTmpStack:add: "Object" : "%ID Object{   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic 57;    ...}" 
 -- items:markForCodeGen: "%ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57;   in objx: ref Object;   out V:  ...}" 
 -- markItem: "%ID Object" Property 
 -- markItem: "%basic 64" Property 
 -- markItem: "%public" Property 
 -- Pattern:markForCodeGen: "X_asString:<  -- does not wokr, problem with virtual in Object{   out S: var LIB.StringLib.String;   inner(X_asString)}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "-- does not wokr, problem with virtual in Object{   out S: var LIB.StringLib.String;   inner(X_asString)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "-- does not wokr, problem with virtual in Object" 
 -- "" false 
 -- 
 -- OG:markIS: "-- does not wokr, problem with virtual in Object{   out S: var LIB.StringLib.String;   inner(X_asString)}" 
 -- OG:Qalloc: "-- does not wokr, problem with virtual in Object{   out S: var LIB.StringLib.String;   inner(X_asString)}" qDescno:  0 
 -- OG:Qalloc:A:  "X_asString"  super:  "-- does not wokr, problem with virtual in Object"  marked:  true "X_asString:<  -- does not wokr, problem with virtual in Object{   ou ...}" s ... - ... 
 -- Invocation:Qalloc: "-- does not wokr, problem with virtual in Object" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "-- does not wokr, problem with virtual in Object{   out S: var LIB.StringLib.String;   inner(X_asString)}" 
 -- super:  "-- does not wokr, problem with virtual in Object" 
 -- E:  "" 
 -- OG:Qalloc:B: "X_asString" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 32 IS.newDescNo: 32 objSize: 0 1: 1 "out S: var LIB.StringLib.String{inner(X_asString)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 32 "out S: var LIB.StringLib.String{inner(X_asString)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "S" isValue: true  isPrimitive: true  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "out S: var LIB.StringLib.String" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- OG:Qalloc: "inner(X_asString)" qDescno:  0 
 -- OG:Qalloc:A:  "inner"  super:  "inner(X_asString)"  marked:  false "out S: var LIB.StringLib.String{inner(X_asString)}" super:  inner(X_asString) 
 -- Invocation:Qalloc: "inner(X_asString)" 
 -- ObjectInvocation:Qalloc: "inner(X_asString)" 
 -- name: "inner" 
 -- Arguments "inner(X_asString)" 
 -- OG:Qalloc: "X_asString" qDescno:  0 
 -- OG:Qalloc:A:  "X_asString"  super:  "X_asString"  marked:  false "inner(X_asString)" super:  X_asString 
 -- Invocation:Qalloc: "X_asString" 
 -- ObjectInvocation:Qalloc: "X_asString" 
 -- name: "X_asString" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  32 2 out S: var LIB.StringLib.String{inner(X_asString)} 
 -- OG:super:  "X_asString:<  -- does not wokr, problem with virtual in Object{   out S: var LIB.StringLib.String;   inner(X_asString)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "X_asString" 
 -- super:  "X_asString" 
 -- E:  "X_asString" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "X_asString" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 %basic 101{in inner: ref Object} 
 -- OG:super:  "inner: {   %basic 101;   in inner: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(X_asString)" 
 -- super:  "inner(X_asString)" 
 -- E:  "inner(X_asString)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(X_asString)" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 32 "out S: var LIB.StringLib.String{inner(X_asString)}" 
 -- IS.newDescNo: 32 IS.objSize: 2 "out S: var LIB.StringLib.String{inner(X_asString)}" 
 -- OG:Qalloc:end: IS.newDescNo:  32 "-- does not wokr, problem with virtual in Object{   out S: var LIB.StringLib.String;   inner(X_asString)}" 
 -- ObjTmpStack:add: "X_asString" : "-- does not wokr, problem with virtual in Object{   out S: var LIB.StringLib.String;   inner(X_asString)}" 
 -- items:markForCodeGen: "out S: var LIB.StringLib.String{inner(X_asString)}" 
 -- DataItem:markForCodeGen: "S" :descNo: 0 :OG.primNo: 5 
 -- OG:markForCodeGen: "LIB.StringLib.String" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "LIB.StringLib.String" 
 -- "LIB" false 
 -- "StringLib" false 
 -- "String" true 
 -- 
 -- OG:markSuper: "LIB.StringLib.String" 
 -- Invocation:markForCodeGen: "LIB.StringLib.String" 
 -- ObjectInvocation:markForCodeGen: "LIB"  ATd: "--LIB{}" 
 -- OG:markForCodeGen: "%id "LIB"{   %module BETA;   %Include BETA;   x_dummy_LIB: var integer;   --AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--Collecti ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%id "LIB"{   %module BETA;   %Include BETA;   x_dummy_LIB: var integer;   --AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--Collections;--Co ...}" 
 -- OG:Qalloc: "%id "LIB"{   %module BETA;   %Include BETA;   x_dummy_LIB: var integer;   --AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--Collections;--Co ...}" q ... 0 
 -- OG:Qalloc:A:  "LIB"  super:  ""  marked:  true "LIB: obj {   %id "LIB";   %module BETA;   %Include BETA;   x_dummy_LIB: var integer;   --AgentSystem;--Associations;--Basic ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%id "LIB"{   %module BETA;   %Include BETA;   x_dummy_LIB: var integer;   --AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--Collections;--Compiler;--Co ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "LIB" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 33 IS.newDescNo: 33 objSize: 0 1: 1 "%id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--Basi ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 33 "%id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;-- ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- dataitem:qalloc: "x_dummy_LIB" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- ModuleItem:Qalloc:  --AgentSystem{} 
 -- ModuleItem:Qalloc:  --Associations{} 
 -- ModuleItem:Qalloc:  --BasicIO{} 
 -- Qalloc:module: BasicIO 
 -- Module:alloc:off: 3 BasicIO: obj {   %module LIB.StringLib;   %Public;   Lock: ;      dummy: var integer;      %Public;      M: var integer;      init: ;         M := 0;   ...} 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- ModuleItem:Qalloc:  --BasicSystemLib{} 
 -- Qalloc:module: BasicSystemLib 
 -- Module:alloc:off: 4 BasicSystemLib: obj {   %module Collections, LIB.StringLib, LIB.Collections.QueueLib;   %include Collections, LIB.StringLib;   %public;   Lock: ;       ...} 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- ModuleItem:Qalloc:  --COsystem{} 
 -- ModuleItem:Qalloc:  --Collections{} 
 -- Qalloc:module: Collections 
 -- Module:alloc:off: 5 Collections: obj {   %visible StringLib;   Collection: ;      %id "Collection";      %globals;      in elm:< Object;      insert:< ;         in e: ref  ...} 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- ModuleItem:Qalloc:  --Compiler{} 
 -- ModuleItem:Qalloc:  --Complex{} 
 -- ModuleItem:Qalloc:  --DateTimeLib{} 
 -- ModuleItem:Qalloc:  --Dimensions{} 
 -- Qalloc:module: Dimensions 
 -- Module:alloc:off: 6 Dimensions: obj {   %domain_boundary;   %public;   Dimension: ;      %dimension "-top-";      %public;      PrimaryUnit:< Unit;      Unit: Value;       ...} 
 -- Items:Qalloc:objSize: 6  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 6  newDescNo: 0 "" 
 -- ModuleItem:Qalloc:  --EMC2array{} 
 -- ModuleItem:Qalloc:  --Embedded{} 
 -- ModuleItem:Qalloc:  --FileSys{} 
 -- ModuleItem:Qalloc:  --ForkJoinSystem{} 
 -- ModuleItem:Qalloc:  --MetaSystem{} 
 -- ModuleItem:Qalloc:  --MonitorSystemLib{} 
 -- Qalloc:module: MonitorSystemLib 
 -- Module:alloc:off: 7 MonitorSystemLib: obj {   %domain_boundary;   %visible LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib;   %module LIB.BasicSystemLib, LIB.BasicSyst ...} 
 -- Items:Qalloc:objSize: 7  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 7  newDescNo: 0 "" 
 -- ModuleItem:Qalloc:  --NonBlockingIO{} 
 -- ModuleItem:Qalloc:  --RandomNumberGeneratorLib{} 
 -- ModuleItem:Qalloc:  --SimpleConcurrentProcesses{} 
 -- ModuleItem:Qalloc:  --Socket{} 
 -- ModuleItem:Qalloc:  --SocketSystem{} 
 -- ModuleItem:Qalloc:  --StringLib{} 
 -- Qalloc:module: StringLib 
 -- Module:alloc:off: 8 StringLib: obj {   %id "String module";   %module LIB;   %public;   String: Value;      %id "String pattern";      %OSDvisibility disguised;      %basi ...} 
 -- Items:Qalloc:objSize: 8  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 8  newDescNo: 0 "" 
 -- ModuleItem:Qalloc:  --Xarray{} 
 -- Items:Qalloc:END:objSize: 8  newDescNo: 33 "%id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsyste ...}" 
 -- IS.newDescNo: 33 IS.objSize: 8 "%id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--Collecti ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  33 "%id "LIB"{   %module BETA;   %Include BETA;   x_dummy_LIB: var integer;   --AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsys ...}" 
 -- ObjTmpStack:add: "LIB" : "%id "LIB"{   %module BETA;   %Include BETA;   x_dummy_LIB: var integer;   --AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--Co ...}" 
 -- items:markForCodeGen: "%id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--Collections;--Com ...}" 
 -- markItem: "%id "LIB"" Property 
 -- markItem: "%module BETA" Property 
 -- markItem: "%Include BETA" Property 
 -- DataItem:markForCodeGen: "x_dummy_LIB" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "%module LIB.StringLib{   %Public;   Lock: ;      dummy: var integer;      %Public;      M: var integer;      init: ;         M := 0;      get: ;        ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%module LIB.StringLib{   %Public;   Lock: ;      dummy: var integer;      %Public;      M: var integer;      init: ;         M := 0;      get: ;         res: v ...}" 
 -- OG:Qalloc: "%module LIB.StringLib{   %Public;   Lock: ;      dummy: var integer;      %Public;      M: var integer;      init: ;         M := 0;      get: ;         res: v ...}" q ... 0 
 -- OG:Qalloc:A:  "BasicIO"  super:  ""  marked:  true "BasicIO: obj {   %module LIB.StringLib;   %Public;   Lock: ;      dummy: var integer;      %Public;      M: var integer ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%module LIB.StringLib{   %Public;   Lock: ;      dummy: var integer;      %Public;      M: var integer;      init: ;         M := 0;      get: ;         res: var integer; ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "BasicIO" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 34 IS.newDescNo: 34 objSize: 0 1: 1 "%module LIB.StringLib{%Public;Lock: ;   dummy: var integer;   %Public;   M: var integer;   init: ;      M : ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 34 "%module LIB.StringLib{%Public;Lock: ;   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res:  ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Pattern:Qalloc: Lock 
 -- Pattern:Qalloc:B: Lock 
 -- dataitem:qalloc: "keyboard" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "keyboard: obj {   %Public;   readLine: ;      out M: var LIB.StringLib.String;      inx: var integer;      msg: obj Indexed(30,integer);      read: obj ; ...}" 
 -- OG:Qalloc: "%Public{   readLine: ;      out M: var LIB.StringLib.String;      inx: var integer;      msg: obj Indexed(30,integer);      read: obj ;         ch: var Char;   ...}" q ... 0 
 -- OG:Qalloc:A:  "keyboard"  super:  ""  marked:  false "keyboard: obj {   %Public;   readLine: ;      out M: var LIB.StringLib.String;      inx: var integer;      msg: obj I ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%Public{   readLine: ;      out M: var LIB.StringLib.String;      inx: var integer;      msg: obj Indexed(30,integer);      read: obj ;         ch: var Char;         ch : ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "keyboard" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 35 IS.newDescNo: 35 objSize: 0 1: 1 "%Public{readLine: ;   out M: var LIB.StringLib.String;   inx: var integer;   msg: obj Indexed(30,integer);  ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 35 "%Public{readLine: ;   out M: var LIB.StringLib.String;   inx: var integer;   msg: obj Indexed(30,integer);   read: obj ;      ch: v ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Pattern:Qalloc: readLine 
 -- Pattern:Qalloc:B: readLine 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 35 "%Public{readLine: ;   out M: var LIB.StringLib.String;   inx: var integer;   msg: obj Indexed(30,integer);   read: obj ;      c ...}" 
 -- IS.newDescNo: 35 IS.objSize: 1 "%Public{readLine: ;   out M: var LIB.StringLib.String;   inx: var integer;   msg: obj Indexed(30,integer);   read: obj ;      ch: var Char; ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  35 "%Public{   readLine: ;      out M: var LIB.StringLib.String;      inx: var integer;      msg: obj Indexed(30,integer);      read: obj ;   ...}" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- dataitem:qalloc: "screen" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 3 "screen: obj {   L: obj Lock;   %Public;   init: ;      L.get;      L.init;      L.free;   display: ;      L.get;      inner;      L.free}" 
 -- OG:Qalloc: "L: obj Lock{   %Public;   init: ;      L.get;      L.init;      L.free;   display: ;      L.get;      inner;      L.free}" qDescno:  0 
 -- OG:Qalloc:A:  "screen"  super:  ""  marked:  false "screen: obj {   L: obj Lock;   %Public;   init: ;      L.get;      L.init;      L.free;   display: ;      L.get;      i ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L: obj Lock{   %Public;   init: ;      L.get;      L.init;      L.free;   display: ;      L.get;      inner;      L.free}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "screen" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 36 IS.newDescNo: 36 objSize: 0 1: 1 "L: obj Lock{%Public;init: ;   L.get;   L.init;   L.free;display: ;   L.get;   inner;   L.free}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 36 "L: obj Lock{%Public;init: ;   L.get;   L.init;   L.free;display: ;   L.get;   inner;   L.free}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- dataitem:qalloc: "L" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "L: obj Lock" 
 -- OG:Qalloc: "Lock" qDescno:  0 
 -- OG:Qalloc:A:  "Lock"  super:  "Lock"  marked:  false "L: obj Lock" super:  Lock 
 -- Invocation:Qalloc: "Lock" 
 -- ObjectInvocation:Qalloc: "Lock" 
 -- name: "Lock" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 dummy: var integer{%Public;M: var integer;init: ;   M := 0;get: ;   res: var integer;   loop: obj ;      disable;   ...} 
 -- OG:Qalloc:SuperAlloc: "Lock: {   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;         disable;  ...}" 
 -- OG:Qalloc: "dummy: var integer{   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;         disable;         res := 17;    ...}" q ... 0 
 -- OG:Qalloc:A:  "Lock"  super:  ""  marked:  false "Lock: {   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      lo ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "dummy: var integer{   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;         disable;         res := 17;         res : ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "Lock" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 37 IS.newDescNo: 37 objSize: 0 1: 1 "dummy: var integer{%Public;M: var integer;init: ;   M := 0;get: ;   res: var integer;   loop: obj ;      di ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 37 "dummy: var integer{%Public;M: var integer;init: ;   M := 0;get: ;   res: var integer;   loop: obj ;      disable;      res := 17;   ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "dummy" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- dataitem:qalloc: "M" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- Pattern:Qalloc: init 
 -- Pattern:Qalloc:B: init 
 -- Pattern:Qalloc: get 
 -- Pattern:Qalloc:B: get 
 -- Pattern:Qalloc: free 
 -- Pattern:Qalloc:B: free 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 37 "dummy: var integer{%Public;M: var integer;init: ;   M := 0;get: ;   res: var integer;   loop: obj ;      disable;      res := 1 ...}" 
 -- IS.newDescNo: 37 IS.objSize: 3 "dummy: var integer{%Public;M: var integer;init: ;   M := 0;get: ;   res: var integer;   loop: obj ;      disable;      res := 17;      res  ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  37 "dummy: var integer{   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;         disable; ...}" 
 -- OG:super:  "Lock: {   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;         disable;         res ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Lock" 
 -- super:  "Lock" 
 -- E:  "Lock" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Lock" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Pattern:Qalloc: init 
 -- Pattern:Qalloc:B: init 
 -- Pattern:Qalloc: display 
 -- Pattern:Qalloc:B: display 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 36 "L: obj Lock{%Public;init: ;   L.get;   L.init;   L.free;display: ;   L.get;   inner;   L.free}" 
 -- IS.newDescNo: 36 IS.objSize: 2 "L: obj Lock{%Public;init: ;   L.get;   L.init;   L.free;display: ;   L.get;   inner;   L.free}" 
 -- OG:Qalloc:end: IS.newDescNo:  36 "L: obj Lock{   %Public;   init: ;      L.get;      L.init;      L.free;   display: ;      L.get;      inner;      L.free}" 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 34 "%module LIB.StringLib{%Public;Lock: ;   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      r ...}" 
 -- IS.newDescNo: 34 IS.objSize: 3 "%module LIB.StringLib{%Public;Lock: ;   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var inte ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  34 "%module LIB.StringLib{   %Public;   Lock: ;      dummy: var integer;      %Public;      M: var integer;      init: ;         M := 0;      ...}" 
 -- ObjTmpStack:add: "BasicIO" : "%module LIB.StringLib{   %Public;   Lock: ;      dummy: var integer;      %Public;      M: var integer;      init: ;         M := 0;      get ...}" 
 -- items:markForCodeGen: "%module LIB.StringLib{%Public;Lock: ;   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      ...}" 
 -- markItem: "%module LIB.StringLib" Property 
 -- markItem: "%Public" Property 
 -- DataItem:markForCodeGen: "keyboard" :descNo: 35 :OG.primNo: 0 
 -- OG:markForCodeGen: "%Public{   readLine: ;      out M: var LIB.StringLib.String;      inx: var integer;      msg: obj Indexed(30,integer);      read: obj ;         ch: var ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%Public{   readLine: ;      out M: var LIB.StringLib.String;      inx: var integer;      msg: obj Indexed(30,integer);      read: obj ;         ch: var Char;   ...}" 
 -- OG:Qalloc: "%Public{   readLine: ;      out M: var LIB.StringLib.String;      inx: var integer;      msg: obj Indexed(30,integer);      read: obj ;         ch: var Char;   ...}" q ... 35 
 -- ObjTmpStack:add: "keyboard" : "%Public{   readLine: ;      out M: var LIB.StringLib.String;      inx: var integer;      msg: obj Indexed(30,integer);      read: obj ;      ...}" 
 -- items:markForCodeGen: "%Public{readLine: ;   out M: var LIB.StringLib.String;   inx: var integer;   msg: obj Indexed(30,integer);   read: obj ;      ch: var Char;      ch  ...}" 
 -- markItem: "%Public" Property 
 -- DataItem:markForCodeGen: "screen" :descNo: 36 :OG.primNo: 0 
 -- OG:markForCodeGen: "L: obj Lock{   %Public;   init: ;      L.get;      L.init;      L.free;   display: ;      L.get;      inner;      L.free}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "L: obj Lock{   %Public;   init: ;      L.get;      L.init;      L.free;   display: ;      L.get;      inner;      L.free}" 
 -- OG:Qalloc: "L: obj Lock{   %Public;   init: ;      L.get;      L.init;      L.free;   display: ;      L.get;      inner;      L.free}" qDescno:  36 
 -- ObjTmpStack:add: "screen" : "L: obj Lock{   %Public;   init: ;      L.get;      L.init;      L.free;   display: ;      L.get;      inner;      L.free}" 
 -- items:markForCodeGen: "L: obj Lock{%Public;init: ;   L.get;   L.init;   L.free;display: ;   L.get;   inner;   L.free}" 
 -- DataItem:markForCodeGen: "L" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Lock" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Lock" 
 -- "Lock" false 
 -- 
 -- OG:markSuper: "Lock" 
 -- Invocation:markForCodeGen: "Lock" 
 -- ObjectInvocation:markForCodeGen: "Lock"  ATd: "Lock: {   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: ...}" 
 -- Pattern:markForCodeGen: "Lock: {   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;         disable ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "dummy: var integer{   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;         disable;         res : ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "dummy: var integer{   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;         disable;         res := 17;    ...}" 
 -- OG:Qalloc: "dummy: var integer{   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;         disable;         res := 17;    ...}" q ... 37 
 -- ObjTmpStack:add: "Lock" : "dummy: var integer{   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;         disable;        ...}" 
 -- items:markForCodeGen: "dummy: var integer{%Public;M: var integer;init: ;   M := 0;get: ;   res: var integer;   loop: obj ;      disable;      res := 17;      res := M.cmpA ...}" 
 -- DataItem:markForCodeGen: "dummy" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- markItem: "%Public" Property 
 -- DataItem:markForCodeGen: "M" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Lock"  IS.isEmpty:  true 
 -- markItem: "%Public" Property 
 -- OG:markForCodeGen: "%module Collections, LIB.StringLib, LIB.Collections.QueueLib{   %include Collections, LIB.StringLib;   %public;   Lock: ;      %globals;      %Public;  ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%module Collections, LIB.StringLib, LIB.Collections.QueueLib{   %include Collections, LIB.StringLib;   %public;   Lock: ;      %globals;      %Public;      in  ...}" 
 -- OG:Qalloc: "%module Collections, LIB.StringLib, LIB.Collections.QueueLib{   %include Collections, LIB.StringLib;   %public;   Lock: ;      %globals;      %Public;      in  ...}" q ... 0 
 -- OG:Qalloc:A:  "BasicSystemLib"  super:  ""  marked:  true "BasicSystemLib: obj {   %module Collections, LIB.StringLib, LIB.Collections.QueueLib;   %include Collections, LI ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%module Collections, LIB.StringLib, LIB.Collections.QueueLib{   %include Collections, LIB.StringLib;   %public;   Lock: ;      %globals;      %Public;      in id: var Str ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "BasicSystemLib" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 38 IS.newDescNo: 38 objSize: 0 1: 1 "%module Collections, LIB.StringLib, LIB.Collections.QueueLib{%include Collections, LIB.StringLib;%public;Lo ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 38 "%module Collections, LIB.StringLib, LIB.Collections.QueueLib{%include Collections, LIB.StringLib;%public;Lock: ;   %globals;   %Pub ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Pattern:Qalloc: Lock 
 -- Pattern:Qalloc:B: Lock 
 -- Pattern:Qalloc: BasicSystem 
 -- Pattern:Qalloc:B: BasicSystem 
 -- ModuleItem:Qalloc:  --SemaphoreLib{} 
 -- Qalloc:module: SemaphoreLib 
 -- Module:alloc:off: 2 SemaphoreLib: obj {   -- Issues when setting status to WAITING in wait;;   -- preemptive suspend may happen before cooperative suspend after addWaiting ...} 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 38 "%module Collections, LIB.StringLib, LIB.Collections.QueueLib{%include Collections, LIB.StringLib;%public;Lock: ;   %globals;    ...}" 
 -- IS.newDescNo: 38 IS.objSize: 2 "%module Collections, LIB.StringLib, LIB.Collections.QueueLib{%include Collections, LIB.StringLib;%public;Lock: ;   %globals;   %Public;   i ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  38 "%module Collections, LIB.StringLib, LIB.Collections.QueueLib{   %include Collections, LIB.StringLib;   %public;   Lock: ;      %globals;  ...}" 
 -- ObjTmpStack:add: "BasicSystemLib" : "%module Collections, LIB.StringLib, LIB.Collections.QueueLib{   %include Collections, LIB.StringLib;   %public;   Lock: ;      %global ...}" 
 -- items:markForCodeGen: "%module Collections, LIB.StringLib, LIB.Collections.QueueLib{%include Collections, LIB.StringLib;%public;Lock: ;   %globals;   %Public;   in id: var ...}" 
 -- markItem: "%module Collections, LIB.StringLib, LIB.Collections.QueueLib" Property 
 -- markItem: "%include Collections, LIB.StringLib" Property 
 -- markItem: "%public" Property 
 -- OG:markForCodeGen: "-- Issues when setting status to WAITING in wait;{   -- preemptive suspend may happen before cooperative suspend after addWaiting;   -- we need to cons ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "-- Issues when setting status to WAITING in wait;{   -- preemptive suspend may happen before cooperative suspend after addWaiting;   -- we need to consider if  ...}" 
 -- OG:Qalloc: "-- Issues when setting status to WAITING in wait;{   -- preemptive suspend may happen before cooperative suspend after addWaiting;   -- we need to consider if  ...}" q ... 0 
 -- OG:Qalloc:A:  "SemaphoreLib"  super:  ""  marked:  true "SemaphoreLib: obj {   -- Issues when setting status to WAITING in wait;;   -- preemptive suspend may happen before ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "-- Issues when setting status to WAITING in wait;{   -- preemptive suspend may happen before cooperative suspend after addWaiting;   -- we need to consider if this can be ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "SemaphoreLib" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 39 IS.newDescNo: 39 objSize: 0 1: 1 "-- Issues when setting status to WAITING in wait;{-- preemptive suspend may happen before cooperative suspe ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 39 "-- Issues when setting status to WAITING in wait;{-- preemptive suspend may happen before cooperative suspend after addWaiting;-- w ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Pattern:Qalloc: Semaphore 
 -- Pattern:Qalloc:B: Semaphore 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 39 "-- Issues when setting status to WAITING in wait;{-- preemptive suspend may happen before cooperative suspend after addWaiting; ...}" 
 -- IS.newDescNo: 39 IS.objSize: 1 "-- Issues when setting status to WAITING in wait;{-- preemptive suspend may happen before cooperative suspend after addWaiting;-- we need t ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  39 "-- Issues when setting status to WAITING in wait;{   -- preemptive suspend may happen before cooperative suspend after addWaiting;   -- w ...}" 
 -- ObjTmpStack:add: "SemaphoreLib" : "-- Issues when setting status to WAITING in wait;{   -- preemptive suspend may happen before cooperative suspend after addWaiting;   --  ...}" 
 -- items:markForCodeGen: "-- Issues when setting status to WAITING in wait;{-- preemptive suspend may happen before cooperative suspend after addWaiting;-- we need to conside ...}" 
 -- OG:markForCodeGen: "%visible StringLib{   Collection: ;      %id "Collection";      %globals;      in elm:< Object;      insert:< ;         in e: ref elm;         inner(in ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%visible StringLib{   Collection: ;      %id "Collection";      %globals;      in elm:< Object;      insert:< ;         in e: ref elm;         inner(insert);   ...}" 
 -- OG:Qalloc: "%visible StringLib{   Collection: ;      %id "Collection";      %globals;      in elm:< Object;      insert:< ;         in e: ref elm;         inner(insert);   ...}" q ... 0 
 -- OG:Qalloc:A:  "Collections"  super:  ""  marked:  true "Collections: obj {   %visible StringLib;   Collection: ;      %id "Collection";      %globals;      in elm:< Object ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%visible StringLib{   Collection: ;      %id "Collection";      %globals;      in elm:< Object;      insert:< ;         in e: ref elm;         inner(insert);      has:< ; ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "Collections" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 40 IS.newDescNo: 40 objSize: 0 1: 1 "%visible StringLib{Collection: ;   %id "Collection";   %globals;   in elm:< Object;   insert:< ;      in e: ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 40 "%visible StringLib{Collection: ;   %id "Collection";   %globals;   in elm:< Object;   insert:< ;      in e: ref elm;      inner(ins ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Pattern:Qalloc: Collection 
 -- Pattern:Qalloc:B: Collection 
 -- ModuleItem:Qalloc:  --BoundedBufferLib{} 
 -- ModuleItem:Qalloc:  --List{} 
 -- ModuleItem:Qalloc:  --MapLib{} 
 -- ModuleItem:Qalloc:  --OrderedList{} 
 -- ModuleItem:Qalloc:  --QueueLib{} 
 -- Qalloc:module: QueueLib 
 -- Module:alloc:off: 2 QueueLib: obj {   -- defines a first-in first-out queue%Public;   Queue: ;      %globals;      idf: var LIB.StringLib.String;      idc: var integer;    ...} 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- ModuleItem:Qalloc:  --SetLib{} 
 -- ModuleItem:Qalloc:  --SimpleList{} 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 40 "%visible StringLib{Collection: ;   %id "Collection";   %globals;   in elm:< Object;   insert:< ;      in e: ref elm;      inner ...}" 
 -- IS.newDescNo: 40 IS.objSize: 2 "%visible StringLib{Collection: ;   %id "Collection";   %globals;   in elm:< Object;   insert:< ;      in e: ref elm;      inner(insert);    ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  40 "%visible StringLib{   Collection: ;      %id "Collection";      %globals;      in elm:< Object;      insert:< ;         in e: ref elm;    ...}" 
 -- ObjTmpStack:add: "Collections" : "%visible StringLib{   Collection: ;      %id "Collection";      %globals;      in elm:< Object;      insert:< ;         in e: ref elm;    ...}" 
 -- items:markForCodeGen: "%visible StringLib{Collection: ;   %id "Collection";   %globals;   in elm:< Object;   insert:< ;      in e: ref elm;      inner(insert);   has:< ;   ...}" 
 -- markItem: "%visible StringLib" Property 
 -- OG:markForCodeGen: "-- defines a first-in first-out queue%Public{   Queue: ;      %globals;      idf: var LIB.StringLib.String;      idc: var integer;      noOfElm: var in ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "-- defines a first-in first-out queue%Public{   Queue: ;      %globals;      idf: var LIB.StringLib.String;      idc: var integer;      noOfElm: var integer;   ...}" 
 -- OG:Qalloc: "-- defines a first-in first-out queue%Public{   Queue: ;      %globals;      idf: var LIB.StringLib.String;      idc: var integer;      noOfElm: var integer;   ...}" q ... 0 
 -- OG:Qalloc:A:  "QueueLib"  super:  ""  marked:  true "QueueLib: obj {   -- defines a first-in first-out queue%Public;   Queue: ;      %globals;      idf: var LIB.StringLib. ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "-- defines a first-in first-out queue%Public{   Queue: ;      %globals;      idf: var LIB.StringLib.String;      idc: var integer;      noOfElm: var integer;      Element ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "QueueLib" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 41 IS.newDescNo: 41 objSize: 0 1: 1 "-- defines a first-in first-out queue%Public{Queue: ;   %globals;   idf: var LIB.StringLib.String;   idc: v ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 41 "-- defines a first-in first-out queue%Public{Queue: ;   %globals;   idf: var LIB.StringLib.String;   idc: var integer;   noOfElm: v ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Pattern:Qalloc: Queue 
 -- Pattern:Qalloc:B: Queue 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 41 "-- defines a first-in first-out queue%Public{Queue: ;   %globals;   idf: var LIB.StringLib.String;   idc: var integer;   noOfEl ...}" 
 -- IS.newDescNo: 41 IS.objSize: 1 "-- defines a first-in first-out queue%Public{Queue: ;   %globals;   idf: var LIB.StringLib.String;   idc: var integer;   noOfElm: var integ ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  41 "-- defines a first-in first-out queue%Public{   Queue: ;      %globals;      idf: var LIB.StringLib.String;      idc: var integer;      n ...}" 
 -- ObjTmpStack:add: "QueueLib" : "-- defines a first-in first-out queue%Public{   Queue: ;      %globals;      idf: var LIB.StringLib.String;      idc: var integer;      noOf ...}" 
 -- items:markForCodeGen: "-- defines a first-in first-out queue%Public{Queue: ;   %globals;   idf: var LIB.StringLib.String;   idc: var integer;   noOfElm: var integer;   Ele ...}" 
 -- markItem: "%Public" Property 
 -- OG:markForCodeGen: "%domain_boundary{   %public;   Dimension: ;      %dimension "-top-";      %public;      PrimaryUnit:< Unit;      Unit: Value;         %unit "U", 1;     ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%domain_boundary{   %public;   Dimension: ;      %dimension "-top-";      %public;      PrimaryUnit:< Unit;      Unit: Value;         %unit "U", 1;         %pu ...}" 
 -- OG:Qalloc: "%domain_boundary{   %public;   Dimension: ;      %dimension "-top-";      %public;      PrimaryUnit:< Unit;      Unit: Value;         %unit "U", 1;         %pu ...}" q ... 0 
 -- OG:Qalloc:A:  "Dimensions"  super:  ""  marked:  true "Dimensions: obj {   %domain_boundary;   %public;   Dimension: ;      %dimension "-top-";      %public;      PrimaryU ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%domain_boundary{   %public;   Dimension: ;      %dimension "-top-";      %public;      PrimaryUnit:< Unit;      Unit: Value;         %unit "U", 1;         %public;       ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "Dimensions" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 42 IS.newDescNo: 42 objSize: 0 1: 1 "%domain_boundary{%public;Dimension: ;   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value; ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 42 "%domain_boundary{%public;Dimension: ;   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Pattern:Qalloc: Dimension 
 -- Pattern:Qalloc:B: Dimension 
 -- ModuleItem:Qalloc:  --Acceleration{} 
 -- ModuleItem:Qalloc:  --AmountOfSubstance{} 
 -- ModuleItem:Qalloc:  --AngularAcceleration{} 
 -- ModuleItem:Qalloc:  --Area{} 
 -- ModuleItem:Qalloc:  --Currency{} 
 -- ModuleItem:Qalloc:  --Density{} 
 -- ModuleItem:Qalloc:  --ElectricCurrent{} 
 -- ModuleItem:Qalloc:  --ElectricFrequency{} 
 -- ModuleItem:Qalloc:  --ElectricPower{} 
 -- ModuleItem:Qalloc:  --ElectricVoltage{} 
 -- ModuleItem:Qalloc:  --Energy{} 
 -- ModuleItem:Qalloc:  --Force{} 
 -- ModuleItem:Qalloc:  --Length{} 
 -- ModuleItem:Qalloc:  --LuminousIntensity{} 
 -- ModuleItem:Qalloc:  --MagneticFluxDensity{} 
 -- ModuleItem:Qalloc:  --Mass{} 
 -- ModuleItem:Qalloc:  --MassFlowRate{} 
 -- ModuleItem:Qalloc:  --MeterPowerN{} 
 -- ModuleItem:Qalloc:  --RadioNuclide{} 
 -- ModuleItem:Qalloc:  --Temperature{} 
 -- ModuleItem:Qalloc:  --ThermodynamicTemperature{} 
 -- ModuleItem:Qalloc:  --Time{} 
 -- ModuleItem:Qalloc:  --Velocity{} 
 -- ModuleItem:Qalloc:  --Volume{} 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 42 "%domain_boundary{%public;Dimension: ;   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;  ...}" 
 -- IS.newDescNo: 42 IS.objSize: 1 "%domain_boundary{%public;Dimension: ;   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  42 "%domain_boundary{   %public;   Dimension: ;      %dimension "-top-";      %public;      PrimaryUnit:< Unit;      Unit: Value;         %un ...}" 
 -- ObjTmpStack:add: "Dimensions" : "%domain_boundary{   %public;   Dimension: ;      %dimension "-top-";      %public;      PrimaryUnit:< Unit;      Unit: Value;         %uni ...}" 
 -- items:markForCodeGen: "%domain_boundary{%public;Dimension: ;   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public;      ma ...}" 
 -- markItem: "%domain_boundary" Property 
 -- markItem: "%public" Property 
 -- OG:markForCodeGen: "%domain_boundary{   %visible LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib;   %module LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib;   %pub ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%domain_boundary{   %visible LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib;   %module LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib;   %public;   M ...}" 
 -- OG:Qalloc: "%domain_boundary{   %visible LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib;   %module LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib;   %public;   M ...}" q ... 0 
 -- OG:Qalloc:A:  "MonitorSystemLib"  super:  ""  marked:  true "MonitorSystemLib: obj {   %domain_boundary;   %visible LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib;    ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%domain_boundary{   %visible LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib;   %module LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib;   %public;   MonitorSyste ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "MonitorSystemLib" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 43 IS.newDescNo: 43 objSize: 0 1: 1 "%domain_boundary{%visible LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib;%module LIB.BasicSystemLib, L ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 43 "%domain_boundary{%visible LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib;%module LIB.BasicSystemLib, LIB.BasicSystemLib.Semaph ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Pattern:Qalloc: MonitorSystem 
 -- Pattern:Qalloc:B: MonitorSystem 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 43 "%domain_boundary{%visible LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib;%module LIB.BasicSystemLib, LIB.BasicSystemLib.Se ...}" 
 -- IS.newDescNo: 43 IS.objSize: 1 "%domain_boundary{%visible LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib;%module LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib;% ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  43 "%domain_boundary{   %visible LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib;   %module LIB.BasicSystemLib, LIB.BasicSystemLib.Semaph ...}" 
 -- ObjTmpStack:add: "MonitorSystemLib" : "%domain_boundary{   %visible LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib;   %module LIB.BasicSystemLib, LIB.BasicSystemLib.S ...}" 
 -- items:markForCodeGen: "%domain_boundary{%visible LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib;%module LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib;%public;Mo ...}" 
 -- markItem: "%domain_boundary" Property 
 -- markItem: "%visible LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib" Property 
 -- markItem: "%module LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib" Property 
 -- markItem: "%public" Property 
 -- OG:markForCodeGen: "%id "String module"{   %module LIB;   %public;   String: Value;      %id "String pattern";      %OSDvisibility disguised;      %basic 5;      %public;  ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%id "String module"{   %module LIB;   %public;   String: Value;      %id "String pattern";      %OSDvisibility disguised;      %basic 5;      %public;      len ...}" 
 -- OG:Qalloc: "%id "String module"{   %module LIB;   %public;   String: Value;      %id "String pattern";      %OSDvisibility disguised;      %basic 5;      %public;      len ...}" q ... 0 
 -- OG:Qalloc:A:  "StringLib"  super:  ""  marked:  true "StringLib: obj {   %id "String module";   %module LIB;   %public;   String: Value;      %id "String pattern";      %O ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%id "String module"{   %module LIB;   %public;   String: Value;      %id "String pattern";      %OSDvisibility disguised;      %basic 5;      %public;      length: ;      ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "StringLib" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 44 IS.newDescNo: 44 objSize: 0 1: 1 "%id "String module"{%module LIB;%public;String: Value;   %id "String pattern";   %OSDvisibility disguised;  ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 44 "%id "String module"{%module LIB;%public;String: Value;   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Pattern:Qalloc: String 
 -- Pattern:Qalloc: C 
 -- Pattern:Qalloc:B: C 
 -- Pattern:Qalloc: I2S 
 -- Pattern:Qalloc:B: I2S 
 -- Pattern:Qalloc: F2S 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 44 "%id "String module"{%module LIB;%public;String: Value;   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %publi ...}" 
 -- IS.newDescNo: 44 IS.objSize: 1 "%id "String module"{%module LIB;%public;String: Value;   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  44 "%id "String module"{   %module LIB;   %public;   String: Value;      %id "String pattern";      %OSDvisibility disguised;      %basic 5;  ...}" 
 -- ObjTmpStack:add: "StringLib" : "%id "String module"{   %module LIB;   %public;   String: Value;      %id "String pattern";      %OSDvisibility disguised;      %basic 5;    ...}" 
 -- items:markForCodeGen: "%id "String module"{%module LIB;%public;String: Value;   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      o ...}" 
 -- markItem: "%id "String module"" Property 
 -- markItem: "%module LIB" Property 
 -- markItem: "%public" Property 
 -- Items:markString %id "String module"{%module LIB;%public;String: Value;   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V:  ...} 
 -- Pattern:markForCodeGen: "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ...}" 
 -- items:markForCodeGen: "" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "StringLib"  ATd: "--StringLib{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "String"  ATd: "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var inte ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "LIB.StringLib.String"  IS.isEmpty:  true 
 -- markItem: "inner(X_asString)" ObjectGenerator 
 -- markItem: "inner(Object)" ObjectGenerator 
 -- not ObjDesc:  "Object"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "this(Value)" 
 -- OG:markForCodeGen: "Value" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Value" 
 -- "Value" true 
 -- 
 -- OG:markSuper: "Value" 
 -- Invocation:markForCodeGen: "Value" 
 -- ObjectInvocation:markForCodeGen: "Value"  ATd: "Value: {   %ID Value;   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Value"  IS.isEmpty:  true 
 -- arg:   "Value" 
 -- not ObjDesc:  "this(Value)"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "length"  ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Veq.length"  IS.isEmpty:  true 
 -- not ObjDesc:  "(L <> Veq.length)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "leave(loop)" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "leave(loop)" 
 -- OG:Qalloc: "leave(loop)" qDescno:  18 
 -- ObjTmpStack:add: "leave(loop)" 
 -- items:markForCodeGen: "leave(loop)" 
 -- markItem: "leave(loop)" ObjectGenerator 
 -- OG:markForCodeGen: "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- OG:Qalloc: "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" qDescno:  20 
 -- ObjTmpStack:add: "if(cond: var boolean):then{thenPart:< object}" : "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- items:markForCodeGen: "%OSDvisibility skipInternal{%basic 100;%globals inSub}" 
 -- markItem: "%OSDvisibility skipInternal" Property 
 -- markItem: "%basic 100" Property 
 -- markItem: "%globals inSub" Property 
 -- not ObjDesc:  "if (L <> Veq.length) :then {   leave(loop)}"  IS.isEmpty:  true 
 -- markItem: "beq := true" Assign 
 -- Invocation:markForCodeGen: "beq" 
 -- ObjectInvocation:markForCodeGen: "beq"  ATd: "out Beq: var boolean" 
 -- DataItem:markForCodeGen: "Beq" :descNo: 0 :OG.primNo: 4 
 -- OG:markForCodeGen: "boolean" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "boolean" 
 -- "boolean" true 
 -- 
 -- OG:markSuper: "boolean" 
 -- Invocation:markForCodeGen: "boolean" 
 -- ObjectInvocation:markForCodeGen: "boolean"  ATd: "Boolean: value{   %id "Boolean";   %globals inSub;   %basic 4, 8;   %public;   _thisBasicValue: var Universal;   &&  : ;  ...}" 
 -- Pattern:markForCodeGen: "Boolean: value{   %id "Boolean";   %globals inSub;   %basic 4, 8;   %public;   _thisBasicValue: var Universal;   &&  : ;      %basic 70;      in B ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "value{   %id "Boolean";   %globals inSub;   %basic 4, 8;   %public;   _thisBasicValue: var Universal;   &&  : ;      %basic 70;      in B: var boolean; ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "value" 
 -- "value" true 
 -- 
 -- OG:markSuper: "value" 
 -- Invocation:markForCodeGen: "value" 
 -- ObjectInvocation:markForCodeGen: "value"  ATd: "Value: {   %ID Value;   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out  ...}" 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "value{   %id "Boolean";   %globals inSub;   %basic 4, 8;   %public;   _thisBasicValue: var Universal;   &&  : ;      %basic 70;      in B: var boolean;      ou ...}" 
 -- OG:Qalloc: "value{   %id "Boolean";   %globals inSub;   %basic 4, 8;   %public;   _thisBasicValue: var Universal;   &&  : ;      %basic 70;      in B: var boolean;      ou ...}" q ... 0 
 -- OG:Qalloc:A:  "Boolean"  super:  "value"  marked:  true "Boolean: value{   %id "Boolean";   %globals inSub;   %basic 4, 8;   %public;   _thisBasicValue: var Universal;   & ...}" s ... v ... 
 -- Invocation:Qalloc: "value" 
 -- ObjectInvocation:Qalloc: "value" 
 -- name: "value" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  4 0 %ID Value{%globals;%basic 21;%public;=  :< ;   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inne ...} 
 -- OG:super:  "Value: {   %ID Value;   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out Beq: var boolean;      inner(= );    ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "value{   %id "Boolean";   %globals inSub;   %basic 4, 8;   %public;   _thisBasicValue: var Universal;   &&  : ;      %basic 70;      in B: var boolean;      out R: var bo ...}" 
 -- super:  "value" 
 -- E:  "value" 
 -- OG:Qalloc:B: "Boolean" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 45 IS.newDescNo: 45 objSize: 0 1: 1 "%id "Boolean"{%globals inSub;%basic 4, 8;%public;_thisBasicValue: var Universal;&&  : ;   %basic 70;   in B ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 45 "%id "Boolean"{%globals inSub;%basic 4, 8;%public;_thisBasicValue: var Universal;&&  : ;   %basic 70;   in B: var boolean;   out R:  ...}" 
 -- Items:Qalloc:super: "value" size: 0 "Boolean" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 "" 
 -- dataitem:qalloc: "_thisBasicValue" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Pattern:Qalloc: && 
 -- Pattern:Qalloc: || 
 -- Pattern:Qalloc: =? 
 -- Pattern:Qalloc: not 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 45 "%id "Boolean"{%globals inSub;%basic 4, 8;%public;_thisBasicValue: var Universal;&&  : ;   %basic 70;   in B: var boolean;   out ...}" 
 -- IS.newDescNo: 45 IS.objSize: 1 "%id "Boolean"{%globals inSub;%basic 4, 8;%public;_thisBasicValue: var Universal;&&  : ;   %basic 70;   in B: var boolean;   out R: var bool ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  45 "value{   %id "Boolean";   %globals inSub;   %basic 4, 8;   %public;   _thisBasicValue: var Universal;   &&  : ;      %basic 70;      in B ...}" 
 -- ObjTmpStack:add: "Boolean" : "value{   %id "Boolean";   %globals inSub;   %basic 4, 8;   %public;   _thisBasicValue: var Universal;   &&  : ;      %basic 70;      in B: va ...}" 
 -- items:markForCodeGen: "%id "Boolean"{%globals inSub;%basic 4, 8;%public;_thisBasicValue: var Universal;&&  : ;   %basic 70;   in B: var boolean;   out R: var boolean;||  : ...}" 
 -- markItem: "%id "Boolean"" Property 
 -- markItem: "%globals inSub" Property 
 -- markItem: "%basic 4, 8" Property 
 -- markItem: "%public" Property 
 -- DataItem:markForCodeGen: "_thisBasicValue" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "Universal" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Universal" 
 -- "Universal" true 
 -- 
 -- OG:markSuper: "Universal" 
 -- Invocation:markForCodeGen: "Universal" 
 -- ObjectInvocation:markForCodeGen: "Universal"  ATd: "universal: Value{   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic 61;      in V: var integer;      ou ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Universal"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "boolean"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "true" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "true" 
 -- "true" false 
 -- 
 -- OG:markSuper: "true" 
 -- Invocation:markForCodeGen: "true" 
 -- ObjectInvocation:markForCodeGen: "true"  ATd: "True: {   %globals;   out B: var boolean;   B := 1}" 
 -- Pattern:markForCodeGen: "True: {   %globals;   out B: var boolean;   B := 1}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "%globals{   out B: var boolean;   B := 1}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%globals{   out B: var boolean;   B := 1}" 
 -- OG:Qalloc: "%globals{   out B: var boolean;   B := 1}" qDescno:  23 
 -- ObjTmpStack:add: "True" : "%globals{   out B: var boolean;   B := 1}" 
 -- items:markForCodeGen: "%globals{out B: var boolean;B := 1}" 
 -- markItem: "%globals" Property 
 -- DataItem:markForCodeGen: "B" :descNo: 0 :OG.primNo: 4 
 -- OG:markForCodeGen: "boolean" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "boolean" 
 -- "boolean" true 
 -- 
 -- OG:markSuper: "boolean" 
 -- Invocation:markForCodeGen: "boolean" 
 -- ObjectInvocation:markForCodeGen: "boolean"  ATd: "Boolean: value{   %id "Boolean";   %globals inSub;   %basic 4, 8;   %public;   _thisBasicValue: var Universal;   &&  : ;  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "boolean"  IS.isEmpty:  true 
 -- markItem: "B := 1" Assign 
 -- Invocation:markForCodeGen: "B" 
 -- ObjectInvocation:markForCodeGen: "B"  ATd: "out B: var boolean" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "true"  IS.isEmpty:  true 
 -- markItem: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" ObjectGenerator 
 -- OG:markForCodeGen: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- isObjectDesc: true  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" false 
 -- 
 -- OG:markSuper: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- Invocation:markForCodeGen: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- ObjectInvocation:markForCodeGen: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}"  ATd: "f ..." 
 -- Pattern:markForCodeGen: "for(first: var integer):to(last: var integer):repeat{repeat:< object}: {   %OSDvisibility skipInternal;   %globals inSub;   inx: var integer;   in ...}" 
 -- items:markForCodeGen: "%$B "("{first: var integer;%$S "):to(";last: var integer;%$S "):repeat{";repeat:< object;%$E "}"}" 
 -- markItem: "%$B "("" Property 
 -- DataItem:markForCodeGen: "first" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- markItem: "%$S "):to("" Property 
 -- DataItem:markForCodeGen: "last" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- markItem: "%$S "):repeat{"" Property 
 -- Pattern:markForCodeGen: "repeat:< object" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "object" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "object" 
 -- "object" true 
 -- 
 -- not ObjDesc:  "object"  IS.isEmpty:  true 
 -- markItem: "%$E "}"" Property 
 -- OG:markForCodeGen: "%OSDvisibility skipInternal{   %globals inSub;   inx: var integer;   inx := first;   _doIt: do ;      if (inx <= last) :then ;         repeat;          ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%OSDvisibility skipInternal{   %globals inSub;   inx: var integer;   inx := first;   _doIt: do ;      if (inx <= last) :then ;         repeat;         inx := i ...}" 
 -- OG:Qalloc: "%OSDvisibility skipInternal{   %globals inSub;   inx: var integer;   inx := first;   _doIt: do ;      if (inx <= last) :then ;         repeat;         inx := i ...}" q ... 28 
 -- ObjTmpStack:add: "for(first: var integer):to(last: var integer):repeat{repeat:< object}" : "%OSDvisibility skipInternal{   %globals inSub;   inx: var integer;   inx := fir ...}" 
 -- items:markForCodeGen: "%OSDvisibility skipInternal{%globals inSub;inx: var integer;inx := first;_doIt: do ;   if (inx <= last) :then ;      repeat;      inx := inx + 1;    ...}" 
 -- markItem: "%OSDvisibility skipInternal" Property 
 -- markItem: "%globals inSub" Property 
 -- DataItem:markForCodeGen: "inx" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- markItem: "inx := first" Assign 
 -- Invocation:markForCodeGen: "inx" 
 -- ObjectInvocation:markForCodeGen: "inx"  ATd: "inx: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "first" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "first" 
 -- "first" true 
 -- 
 -- OG:markForCodeGen: "if (inx <= last) :then {      repeat;      inx := inx + 1;      restart(_doIt);   :else ;      inx := inx}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "if (inx <= last) :then {      repeat;      inx := inx + 1;      restart(_doIt);   :else ;      inx := inx}" 
 -- OG:Qalloc: "if (inx <= last) :then {      repeat;      inx := inx + 1;      restart(_doIt);   :else ;      inx := inx}" qDescno:  0 
 -- OG:Qalloc:A:  "_doIt"  super:  ""  marked:  true "_doIt: do {   if (inx <= last) :then ;      repeat;      inx := inx + 1;      restart(_doIt);   :else ;      inx := inx}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "if (inx <= last) :then {      repeat;      inx := inx + 1;      restart(_doIt);   :else ;      inx := inx}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "_doIt" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 46 IS.newDescNo: 46 objSize: 0 1: 1 "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 46 "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}"  marked:  false "if (inx <= last) :then {  ...}" s ... i ... 
 -- Invocation:Qalloc: "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- OG:Qalloc: "(inx <= last)" qDescno:  0 
 -- OG:Qalloc:A:  "<="  super:  "(inx <= last)"  marked:  false "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" super:  (inx <= l ... 
 -- Invocation:Qalloc: "(inx <= last)" 
 -- Invocation:Qalloc: "inx <= last" 
 -- BinaryExp:Qalloc: "inx <= last" 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "<= last" 
 -- name: "<=" 
 -- Arguments "last" 
 -- OG:Qalloc: "last" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "last"  marked:  false "last" super:  last 
 -- Invocation:Qalloc: "last" 
 -- ObjectInvocation:Qalloc: "last" 
 -- name: "last" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "last: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "last" 
 -- super:  "last" 
 -- E:  "last" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "last" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 52{in Veq: var this(Value);out Beq: var boolean} 
 -- OG:Qalloc:SuperAlloc: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- OG:Qalloc: "%basic 52{   in Veq: var this(Value);   out Beq: var boolean}" qDescno:  0 
 -- OG:Qalloc:A:  "<="  super:  ""  marked:  false "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 52{   in Veq: var this(Value);   out Beq: var boolean}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "<=" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 47 IS.newDescNo: 47 objSize: 0 1: 1 "%basic 52{in Veq: var this(Value);out Beq: var boolean}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 47 "%basic 52{in Veq: var this(Value);out Beq: var boolean}" 
 -- Items:Qalloc:Super:C:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "Veq" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: false 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- dataitem:qalloc: "Beq" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 47 "%basic 52{in Veq: var this(Value);out Beq: var boolean}" 
 -- IS.newDescNo: 47 IS.objSize: 5 "%basic 52{in Veq: var this(Value);out Beq: var boolean}" 
 -- OG:Qalloc:end: IS.newDescNo:  47 "%basic 52{   in Veq: var this(Value);   out Beq: var boolean}" 
 -- OG:super:  "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(inx <= last)" 
 -- super:  "(inx <= last)" 
 -- E:  "(inx <= last)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(inx <= last)" 
 -- OG:Qalloc: "repeat{   inx := inx + 1;   restart(_doIt)}" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "repeat{   inx := inx + 1;   restart(_doIt)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 48 IS.newDescNo: 48 objSize: 0 1: 1 "repeat{inx := inx + 1;restart(_doIt)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 48 "repeat{inx := inx + 1;restart(_doIt)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: "repeat" qDescno:  0 
 -- OG:Qalloc:A:  "Object"  super:  "repeat"  marked:  false "repeat{inx := inx + 1;restart(_doIt)}" super:  repeat 
 -- Invocation:Qalloc: "repeat" 
 -- ObjectInvocation:Qalloc: "repeat" 
 -- name: "repeat" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:super:  "repeat:< object" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "repeat" 
 -- super:  "repeat" 
 -- E:  "repeat" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "repeat" 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- OG:Qalloc: "inx + 1" qDescno:  0 
 -- OG:Qalloc:A:  "+"  super:  "inx + 1"  marked:  false "inx := inx + 1" super:  inx + 1 
 -- Invocation:Qalloc: "inx + 1" 
 -- BinaryExp:Qalloc: "inx + 1" 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "+ 1" 
 -- name: "+" 
 -- Arguments "1" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "1" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 61{in V: var integer;out R: var integer} 
 -- OG:Qalloc:SuperAlloc: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OG:Qalloc: "%basic 61{   in V: var integer;   out R: var integer}" qDescno:  0 
 -- OG:Qalloc:A:  "+"  super:  ""  marked:  false "+  : {   %basic 61;   in V: var integer;   out R: var integer}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 61{   in V: var integer;   out R: var integer}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "+" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 49 IS.newDescNo: 49 objSize: 0 1: 1 "%basic 61{in V: var integer;out R: var integer}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 49 "%basic 61{in V: var integer;out R: var integer}" 
 -- Items:Qalloc:Super:C:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- dataitem:qalloc: "R" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 49 "%basic 61{in V: var integer;out R: var integer}" 
 -- IS.newDescNo: 49 IS.objSize: 5 "%basic 61{in V: var integer;out R: var integer}" 
 -- OG:Qalloc:end: IS.newDescNo:  49 "%basic 61{   in V: var integer;   out R: var integer}" 
 -- OG:super:  "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx + 1" 
 -- super:  "inx + 1" 
 -- E:  "inx + 1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx + 1" 
 -- OG:Qalloc: "restart(_doIt)" qDescno:  0 
 -- OG:Qalloc:A:  "restart"  super:  "restart(_doIt)"  marked:  false "repeat{inx := inx + 1;restart(_doIt)}" super:  restart(_doIt) 
 -- Invocation:Qalloc: "restart(_doIt)" 
 -- ObjectInvocation:Qalloc: "restart(_doIt)" 
 -- name: "restart" 
 -- Arguments "restart(_doIt)" 
 -- OG:Qalloc: "_doIt" qDescno:  0 
 -- OG:Qalloc:A:  "_doIt"  super:  "_doIt"  marked:  false "restart(_doIt)" super:  _doIt 
 -- Invocation:Qalloc: "_doIt" 
 -- ObjectInvocation:Qalloc: "_doIt" 
 -- name: "_doIt" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  46 1 if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx} 
 -- OG:super:  "_doIt: do {   if (inx <= last) :then ;      repeat;      inx := inx + 1;      restart(_doIt);   :else ;      inx := inx}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "_doIt" 
 -- super:  "_doIt" 
 -- E:  "_doIt" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "_doIt" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 102 
 -- OG:Qalloc:SuperAlloc: "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- OG:Qalloc: "-- odd parameter type!{   %basic 102}" qDescno:  0 
 -- OG:Qalloc:A:  "restart"  super:  "-- odd parameter type!"  marked:  false "restart(V: var integer):  -- odd parameter type!{   %basic 102}" super:  -- odd parameter type! 
 -- Invocation:Qalloc: "-- odd parameter type!" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "-- odd parameter type!{   %basic 102}" 
 -- super:  "-- odd parameter type!" 
 -- E:  "" 
 -- OG:Qalloc:B: "restart" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 50 IS.newDescNo: 50 objSize: 0 1: 1 "%basic 102" 
 -- Items:Qalloc:objSize: 0  newDescNo: 50 "%basic 102" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "%$B "("{V: var integer;%$E ")"}" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "%$B "("{V: var integer;%$E ")"}" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 50 "%basic 102" 
 -- IS.newDescNo: 50 IS.objSize: 2 "%basic 102" 
 -- OG:Qalloc:end: IS.newDescNo:  50 "-- odd parameter type!{   %basic 102}" 
 -- OG:super:  "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "restart(_doIt)" 
 -- super:  "restart(_doIt)" 
 -- E:  "restart(_doIt)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "restart(_doIt)" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 48 "repeat{inx := inx + 1;restart(_doIt)}" 
 -- IS.newDescNo: 48 IS.objSize: 1 "repeat{inx := inx + 1;restart(_doIt)}" 
 -- OG:Qalloc:end: IS.newDescNo:  48 "repeat{   inx := inx + 1;   restart(_doIt)}" 
 -- OG:Qalloc: "inx := inx" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx := inx" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 51 IS.newDescNo: 51 objSize: 0 1: 1 "inx := inx" 
 -- Items:Qalloc:objSize: 0  newDescNo: 51 "inx := inx" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- OG:Qalloc: "inx" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "inx"  marked:  false "inx := inx" super:  inx 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "inx: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx" 
 -- super:  "inx" 
 -- E:  "inx" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 51 "inx := inx" 
 -- IS.newDescNo: 51 IS.objSize: 1 "inx := inx" 
 -- OG:Qalloc:end: IS.newDescNo:  51 "inx := inx" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- super:  "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- E:  "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 46 "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- IS.newDescNo: 46 IS.objSize: 1 "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- OG:Qalloc:end: IS.newDescNo:  46 "if (inx <= last) :then {      repeat;      inx := inx + 1;      restart(_doIt);   :else ;      inx := inx}" 
 -- ObjTmpStack:add: "_doIt" : "if (inx <= last) :then {      repeat;      inx := inx + 1;      restart(_doIt);   :else ;      inx := inx}" 
 -- items:markForCodeGen: "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- markItem: "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" ObjectGenerator 
 -- OG:markForCodeGen: "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" true 
 -- 
 -- OG:markSuper: "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- Invocation:markForCodeGen: "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- OG:markForCodeGen: "(inx <= last)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(inx <= last)" 
 -- "(inx <= last)" true 
 -- 
 -- OG:markSuper: "(inx <= last)" 
 -- Invocation:markForCodeGen: "(inx <= last)" 
 -- Invocation:markForCodeGen: "inx <= last" 
 -- BinaryExp:markForCodeGen: "inx <= last" 
 -- Invocation:markForCodeGen: "inx" 
 -- ObjectInvocation:markForCodeGen: "inx"  ATd: "inx: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "<= last"  ATd: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- OI:args:markForCodgen: "last" 
 -- OG:markForCodeGen: "last" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "last" 
 -- "last" true 
 -- 
 -- not ObjDesc:  "(inx <= last)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "repeat{   inx := inx + 1;   restart(_doIt)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "repeat{   inx := inx + 1;   restart(_doIt)}" 
 -- OG:Qalloc: "repeat{   inx := inx + 1;   restart(_doIt)}" qDescno:  48 
 -- ObjTmpStack:add: "repeat{   inx := inx + 1;   restart(_doIt)}" 
 -- items:markForCodeGen: "repeat{inx := inx + 1;restart(_doIt)}" 
 -- markItem: "repeat" ObjectGenerator 
 -- OG:markForCodeGen: "repeat" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "repeat" 
 -- "repeat" false 
 -- 
 -- OG:markSuper: "repeat" 
 -- Invocation:markForCodeGen: "repeat" 
 -- ObjectInvocation:markForCodeGen: "repeat"  ATd: "repeat:< object" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "repeat"  IS.isEmpty:  true 
 -- markItem: "inx := inx + 1" Assign 
 -- Invocation:markForCodeGen: "inx" 
 -- ObjectInvocation:markForCodeGen: "inx"  ATd: "inx: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "inx + 1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "inx + 1" 
 -- "inx + 1" true 
 -- 
 -- OG:markSuper: "inx + 1" 
 -- Invocation:markForCodeGen: "inx + 1" 
 -- BinaryExp:markForCodeGen: "inx + 1" 
 -- Invocation:markForCodeGen: "inx" 
 -- ObjectInvocation:markForCodeGen: "inx"  ATd: "inx: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "+ 1"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- Pattern:markForCodeGen: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- items:markForCodeGen: "" 
 -- OI:args:markForCodgen: "1" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- not ObjDesc:  "inx + 1"  IS.isEmpty:  true 
 -- markItem: "restart(_doIt)" ObjectGenerator 
 -- OG:markForCodeGen: "inx := inx" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "inx := inx" 
 -- OG:Qalloc: "inx := inx" qDescno:  51 
 -- ObjTmpStack:add: "inx := inx" 
 -- items:markForCodeGen: "inx := inx" 
 -- markItem: "inx := inx" Assign 
 -- Invocation:markForCodeGen: "inx" 
 -- ObjectInvocation:markForCodeGen: "inx"  ATd: "inx: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "inx" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "inx" 
 -- "inx" true 
 -- 
 -- not ObjDesc:  "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "length" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "length" 
 -- "length" false 
 -- 
 -- OG:markSuper: "length" 
 -- Invocation:markForCodeGen: "length" 
 -- ObjectInvocation:markForCodeGen: "length"  ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "length"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "c1 := get[inx]{   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "c1 := get[inx]{   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop)}" 
 -- OG:Qalloc: "c1 := get[inx]{   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop)}" qDescno:  24 
 -- ObjTmpStack:add: "c1 := get[inx]{   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop)}" 
 -- items:markForCodeGen: "c1 := get[inx]{c2 := Veq.get[inx];if (c1 <> c2) :then ;   Beq := false;   leave(loop)}" 
 -- markItem: "c1 := get[inx]" Assign 
 -- Invocation:markForCodeGen: "c1" 
 -- ObjectInvocation:markForCodeGen: "c1"  ATd: "c1: var char" 
 -- OI:args:markForCodgen: "" 
 -- markItem: "c2 := Veq.get[inx]" Assign 
 -- Invocation:markForCodeGen: "c2" 
 -- ObjectInvocation:markForCodeGen: "c2"  ATd: "c2: var char" 
 -- OI:args:markForCodgen: "" 
 -- markItem: "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" ObjectGenerator 
 -- OG:markForCodeGen: "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" true 
 -- 
 -- OG:markSuper: "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- Invocation:markForCodeGen: "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- OG:markForCodeGen: "(c1 <> c2)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(c1 <> c2)" 
 -- "(c1 <> c2)" true 
 -- 
 -- OG:markSuper: "(c1 <> c2)" 
 -- Invocation:markForCodeGen: "(c1 <> c2)" 
 -- Invocation:markForCodeGen: "c1 <> c2" 
 -- BinaryExp:markForCodeGen: "c1 <> c2" 
 -- Invocation:markForCodeGen: "c1" 
 -- ObjectInvocation:markForCodeGen: "c1"  ATd: "c1: var char" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "<> c2"  ATd: "<>  : {   %basic 55;   in V: var char;   out B: var boolean}" 
 -- Pattern:markForCodeGen: "<>  : {   %basic 55;   in V: var char;   out B: var boolean}" 
 -- items:markForCodeGen: "" 
 -- OI:args:markForCodgen: "c2" 
 -- OG:markForCodeGen: "c2" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "c2" 
 -- "c2" true 
 -- 
 -- not ObjDesc:  "(c1 <> c2)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "Beq := false{   leave(loop)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "Beq := false{   leave(loop)}" 
 -- OG:Qalloc: "Beq := false{   leave(loop)}" qDescno:  26 
 -- ObjTmpStack:add: "Beq := false{   leave(loop)}" 
 -- items:markForCodeGen: "Beq := false{leave(loop)}" 
 -- markItem: "Beq := false" Assign 
 -- Invocation:markForCodeGen: "Beq" 
 -- ObjectInvocation:markForCodeGen: "Beq"  ATd: "out Beq: var boolean" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "false" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "false" 
 -- "false" false 
 -- 
 -- OG:markSuper: "false" 
 -- Invocation:markForCodeGen: "false" 
 -- ObjectInvocation:markForCodeGen: "false"  ATd: "False: {   %globals;   out B: var boolean;   B := 0}" 
 -- Pattern:markForCodeGen: "False: {   %globals;   out B: var boolean;   B := 0}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "%globals{   out B: var boolean;   B := 0}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%globals{   out B: var boolean;   B := 0}" 
 -- OG:Qalloc: "%globals{   out B: var boolean;   B := 0}" qDescno:  27 
 -- ObjTmpStack:add: "False" : "%globals{   out B: var boolean;   B := 0}" 
 -- items:markForCodeGen: "%globals{out B: var boolean;B := 0}" 
 -- markItem: "%globals" Property 
 -- DataItem:markForCodeGen: "B" :descNo: 0 :OG.primNo: 4 
 -- OG:markForCodeGen: "boolean" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "boolean" 
 -- "boolean" true 
 -- 
 -- OG:markSuper: "boolean" 
 -- Invocation:markForCodeGen: "boolean" 
 -- ObjectInvocation:markForCodeGen: "boolean"  ATd: "Boolean: value{   %id "Boolean";   %globals inSub;   %basic 4, 8;   %public;   _thisBasicValue: var Universal;   &&  : ;  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "boolean"  IS.isEmpty:  true 
 -- markItem: "B := 0" Assign 
 -- Invocation:markForCodeGen: "B" 
 -- ObjectInvocation:markForCodeGen: "B"  ATd: "out B: var boolean" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "0" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "0" 
 -- "0" true 
 -- 
 -- OG:markSuper: "0" 
 -- Invocation:markForCodeGen: "0" 
 -- not ObjDesc:  "0"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "false"  IS.isEmpty:  true 
 -- markItem: "leave(loop)" ObjectGenerator 
 -- not ObjDesc:  "if (c1 <> c2) :then {   Beq := false;   leave(loop)}"  IS.isEmpty:  true 
 -- arg:   "1" 
 -- arg:   "length" 
 -- arg:   "c1 := get[inx]{   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop)}" 
 -- OG:markIS: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- OG:Qalloc: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" qDescno:  30 
 -- ObjTmpStack:add: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- items:markForCodeGen: "" 
 -- Pattern:markForCodeGen: "<=  :: {   loop: obj ;      -- "Hello"  <= "World" since H <= W;      -- "Qweabc" <= "Qwevwxy" since a <= e;      -- "Qweayc" <= "Qwexby";      -- ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "loop: obj {      -- "Hello"  <= "World" since H <= W;      -- "Qweabc" <= "Qwevwxy" since a <= e;      -- "Qweayc" <= "Qwexby";      -- "Qwe"    <= "Qw ..."}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "loop: obj {      -- "Hello"  <= "World" since H <= W;      -- "Qweabc" <= "Qwevwxy" since a <= e;      -- "Qweayc" <= "Qwexby";      -- "Qwe"    <= "Qwerty";   ...}" 
 -- OG:Qalloc: "loop: obj {      -- "Hello"  <= "World" since H <= W;      -- "Qweabc" <= "Qwevwxy" since a <= e;      -- "Qweayc" <= "Qwexby";      -- "Qwe"    <= "Qwerty";   ...}" q ... 0 
 -- OG:Qalloc:A:  "<="  super:  ""  marked:  true "<=  :: {   loop: obj ;      -- "Hello"  <= "World" since H <= W;      -- "Qweabc" <= "Qwevwxy" since a <= e;      -- "Qweayc ..."}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  47 5 %basic 52{in Veq: var this(Value);out Beq: var boolean} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "loop: obj {      -- "Hello"  <= "World" since H <= W;      -- "Qweabc" <= "Qwevwxy" since a <= e;      -- "Qweayc" <= "Qwexby";      -- "Qwe"    <= "Qwerty";      -- "Qwe ..."}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "<=" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 52 IS.newDescNo: 52 objSize: 0 1: 1 "loop: obj {   -- "Hello"  <= "World" since H <= W;   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" < ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 52 "loop: obj {   -- "Hello"  <= "World" since H <= W;   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"   ...}" 
 -- Items:Qalloc:super: "" size: 5 "<=" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 5 originOff: 1 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- dataitem:qalloc: "loop" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 6 "loop: obj {   -- "Hello"  <= "World" since H <= W;   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"    <= "Qwerty";   -- "Q ..."}" 
 -- OG:Qalloc: "-- "Hello"  <= "World" since H <= W{   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"    <= "Qwerty";   -- "Qwerty" <= "Qwe" - fa ...}" q ... 0 
 -- OG:Qalloc:A:  "loop"  super:  ""  marked:  false "loop: obj {   -- "Hello"  <= "World" since H <= W;   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";    ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "-- "Hello"  <= "World" since H <= W{   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"    <= "Qwerty";   -- "Qwerty" <= "Qwe" - false;   -- " ..."}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "loop" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 53 IS.newDescNo: 53 objSize: 0 1: 1 "-- "Hello"  <= "World" since H <= W{-- "Qweabc" <= "Qwevwxy" since a <= e;-- "Qweayc" <= "Qwexby";-- "Qwe"  ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 53 "-- "Hello"  <= "World" since H <= W{-- "Qweabc" <= "Qwevwxy" since a <= e;-- "Qweayc" <= "Qwexby";-- "Qwe"    <= "Qwerty";-- "Qwert ..."}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Pattern:Qalloc: matchEq 
 -- Pattern:Qalloc:B: matchEq 
 -- dataitem:qalloc: "L" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- dataitem:qalloc: "L1" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "L2" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- Invocation:Qalloc: "L1" 
 -- ObjectInvocation:Qalloc: "L1" 
 -- name: "L1" 
 -- Arguments "" 
 -- OG:Qalloc: "length{-- min length of this and V}" qDescno:  0 
 -- OG:Qalloc:A:  "length"  super:  "length{-- min length of this and V}"  marked:  false "L1 := length{-- min length of this and V}" super:  length{-- min length of this and  ...} 
 -- Invocation:Qalloc: "length{-- min length of this and V}" 
 -- ObjectInvocation:Qalloc: "length{-- min length of this and V}" 
 -- name: "length" 
 -- Arguments "-- min length of this and V" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  15 2 out V: var integer{V := get[0] -- actually an index error, accessing length} 
 -- OG:super:  "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "length{-- min length of this and V}" 
 -- super:  "length{-- min length of this and V}" 
 -- E:  "length{-- min length of this and V}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "length{-- min length of this and V}" 
 -- Invocation:Qalloc: "L2" 
 -- ObjectInvocation:Qalloc: "L2" 
 -- name: "L2" 
 -- Arguments "" 
 -- OG:Qalloc: "Veq.length" qDescno:  0 
 -- OG:Qalloc:A:  "length"  super:  "Veq.length"  marked:  false "L2 := Veq.length" super:  Veq.length 
 -- Invocation:Qalloc: "Veq.length" 
 -- ObjectInvocation:Qalloc: "Veq" 
 -- name: "Veq" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "length" 
 -- name: "length" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  15 2 out V: var integer{V := get[0] -- actually an index error, accessing length} 
 -- OG:super:  "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Veq.length" 
 -- super:  "Veq.length" 
 -- E:  "length" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Veq.length" 
 -- OG:Qalloc: "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (L1 < L2) :then {   L := L1;:else ;   L := L2}"  marked:  false "-- "Hello"  <= "World" since H <= W{-- "Qweabc" <= "Qwevwxy" since  ...}" s ... i ... 
 -- Invocation:Qalloc: "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- OG:Qalloc: "(L1 < L2)" qDescno:  0 
 -- OG:Qalloc:A:  "<"  super:  "(L1 < L2)"  marked:  false "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" super:  (L1 < L2) 
 -- Invocation:Qalloc: "(L1 < L2)" 
 -- Invocation:Qalloc: "L1 < L2" 
 -- BinaryExp:Qalloc: "L1 < L2" 
 -- Invocation:Qalloc: "L1" 
 -- ObjectInvocation:Qalloc: "L1" 
 -- name: "L1" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "< L2" 
 -- name: "<" 
 -- Arguments "L2" 
 -- OG:Qalloc: "L2" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "L2"  marked:  false "L2" super:  L2 
 -- Invocation:Qalloc: "L2" 
 -- ObjectInvocation:Qalloc: "L2" 
 -- name: "L2" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "L2: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L2" 
 -- super:  "L2" 
 -- E:  "L2" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L2" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 51{in V: var integer;out B: var boolean} 
 -- OG:Qalloc:SuperAlloc: "<  : {   %basic 51;   in V: var integer;   out B: var boolean}" 
 -- OG:Qalloc: "%basic 51{   in V: var integer;   out B: var boolean}" qDescno:  0 
 -- OG:Qalloc:A:  "<"  super:  ""  marked:  false "<  : {   %basic 51;   in V: var integer;   out B: var boolean}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 51{   in V: var integer;   out B: var boolean}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "<" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 54 IS.newDescNo: 54 objSize: 0 1: 1 "%basic 51{in V: var integer;out B: var boolean}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 54 "%basic 51{in V: var integer;out B: var boolean}" 
 -- Items:Qalloc:Super:C:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- dataitem:qalloc: "B" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 54 "%basic 51{in V: var integer;out B: var boolean}" 
 -- IS.newDescNo: 54 IS.objSize: 5 "%basic 51{in V: var integer;out B: var boolean}" 
 -- OG:Qalloc:end: IS.newDescNo:  54 "%basic 51{   in V: var integer;   out B: var boolean}" 
 -- OG:super:  "<  : {   %basic 51;   in V: var integer;   out B: var boolean}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(L1 < L2)" 
 -- super:  "(L1 < L2)" 
 -- E:  "(L1 < L2)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(L1 < L2)" 
 -- OG:Qalloc: "L := L1" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L := L1" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 55 IS.newDescNo: 55 objSize: 0 1: 1 "L := L1" 
 -- Items:Qalloc:objSize: 0  newDescNo: 55 "L := L1" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "L" 
 -- ObjectInvocation:Qalloc: "L" 
 -- name: "L" 
 -- Arguments "" 
 -- OG:Qalloc: "L1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "L1"  marked:  false "L := L1" super:  L1 
 -- Invocation:Qalloc: "L1" 
 -- ObjectInvocation:Qalloc: "L1" 
 -- name: "L1" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "L1: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L1" 
 -- super:  "L1" 
 -- E:  "L1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L1" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 55 "L := L1" 
 -- IS.newDescNo: 55 IS.objSize: 1 "L := L1" 
 -- OG:Qalloc:end: IS.newDescNo:  55 "L := L1" 
 -- OG:Qalloc: "L := L2" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L := L2" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 56 IS.newDescNo: 56 objSize: 0 1: 1 "L := L2" 
 -- Items:Qalloc:objSize: 0  newDescNo: 56 "L := L2" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "L" 
 -- ObjectInvocation:Qalloc: "L" 
 -- name: "L" 
 -- Arguments "" 
 -- OG:Qalloc: "L2" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "L2"  marked:  false "L := L2" super:  L2 
 -- Invocation:Qalloc: "L2" 
 -- ObjectInvocation:Qalloc: "L2" 
 -- name: "L2" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "L2: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L2" 
 -- super:  "L2" 
 -- E:  "L2" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L2" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 56 "L := L2" 
 -- IS.newDescNo: 56 IS.objSize: 1 "L := L2" 
 -- OG:Qalloc:end: IS.newDescNo:  56 "L := L2" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- super:  "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- E:  "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- OG:Qalloc: "matchEq" qDescno:  0 
 -- OG:Qalloc:A:  "matchEq"  super:  "matchEq"  marked:  false "-- "Hello"  <= "World" since H <= W{-- "Qweabc" <= "Qwevwxy" since a <= e;-- "Qweayc" <= "Qwexby";-- "Qwe"    < ...}" s ... m ... 
 -- Invocation:Qalloc: "matchEq" 
 -- ObjectInvocation:Qalloc: "matchEq" 
 -- name: "matchEq" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 inx: var integer{c1: var char;c2: var char;isEmpty: do ;   if (L1 = 0) :then ;      Beq := L1 <= L2;      leave(mat ...} 
 -- OG:Qalloc:SuperAlloc: "matchEq: {   inx: var integer;   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := L1 <= L2;         leave(match ...}" 
 -- OG:Qalloc: "inx: var integer{   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := L1 <= L2;         leave(matchEq);      if (L2 = 0) :t ...}" q ... 0 
 -- OG:Qalloc:A:  "matchEq"  super:  ""  marked:  false "matchEq: {   inx: var integer;   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx: var integer{   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := L1 <= L2;         leave(matchEq);      if (L2 = 0) :then ;       ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "matchEq" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 57 IS.newDescNo: 57 objSize: 0 1: 1 "inx: var integer{c1: var char;c2: var char;isEmpty: do ;   if (L1 = 0) :then ;      Beq := L1 <= L2;      l ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 57 "inx: var integer{c1: var char;c2: var char;isEmpty: do ;   if (L1 = 0) :then ;      Beq := L1 <= L2;      leave(matchEq);   if (L2  ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "inx" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- dataitem:qalloc: "c1" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "c2" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 57 "inx: var integer{c1: var char;c2: var char;isEmpty: do ;   if (L1 = 0) :then ;      Beq := L1 <= L2;      leave(matchEq);   if  ...}" 
 -- IS.newDescNo: 57 IS.objSize: 4 "inx: var integer{c1: var char;c2: var char;isEmpty: do ;   if (L1 = 0) :then ;      Beq := L1 <= L2;      leave(matchEq);   if (L2 = 0) :th ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  57 "inx: var integer{   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := L1 <= L2;         leave(matchEq ...}" 
 -- OG:super:  "matchEq: {   inx: var integer;   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := L1 <= L2;         leave(matchEq);      i ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "matchEq" 
 -- super:  "matchEq" 
 -- E:  "matchEq" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "matchEq" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 53 "-- "Hello"  <= "World" since H <= W{-- "Qweabc" <= "Qwevwxy" since a <= e;-- "Qweayc" <= "Qwexby";-- "Qwe"    <= "Qwerty";-- "Q ..."}" 
 -- IS.newDescNo: 53 IS.objSize: 4 "-- "Hello"  <= "World" since H <= W{-- "Qweabc" <= "Qwevwxy" since a <= e;-- "Qweayc" <= "Qwexby";-- "Qwe"    <= "Qwerty";-- "Qwerty" <= "Q ..."}" 
 -- OG:Qalloc:end: IS.newDescNo:  53 "-- "Hello"  <= "World" since H <= W{   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"    <= "Qwerty";   --  ...}" 
 -- Items:Qalloc:objSize: 6  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 6  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 6  newDescNo: 52 "loop: obj {   -- "Hello"  <= "World" since H <= W;   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qw ..."}" 
 -- IS.newDescNo: 52 IS.objSize: 6 "loop: obj {   -- "Hello"  <= "World" since H <= W;   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"    <= "Qw ..."}" 
 -- OG:Qalloc:end: IS.newDescNo:  52 "loop: obj {      -- "Hello"  <= "World" since H <= W;      -- "Qweabc" <= "Qwevwxy" since a <= e;      -- "Qweayc" <= "Qwexby";      -- " ..."}" 
 -- ObjTmpStack:add: "<=  " : "loop: obj {      -- "Hello"  <= "World" since H <= W;      -- "Qweabc" <= "Qwevwxy" since a <= e;      -- "Qweayc" <= "Qwexby";      -- "Qwe"    ...}" 
 -- items:markForCodeGen: "loop: obj {   -- "Hello"  <= "World" since H <= W;   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"    <= "Qwerty";    ...}" 
 -- DataItem:markForCodeGen: "loop" :descNo: 53 :OG.primNo: 0 
 -- OG:markForCodeGen: "-- "Hello"  <= "World" since H <= W{   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"    <= "Qwerty";   -- "Qwerty" <= "Q ..."}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "-- "Hello"  <= "World" since H <= W{   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"    <= "Qwerty";   -- "Qwerty" <= "Qwe" - fa ...}" 
 -- OG:Qalloc: "-- "Hello"  <= "World" since H <= W{   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"    <= "Qwerty";   -- "Qwerty" <= "Qwe" - fa ...}" q ... 53 
 -- ObjTmpStack:add: "loop" : "-- "Hello"  <= "World" since H <= W{   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"    <= "Qwerty";   -- "Qwerty ..."}" 
 -- items:markForCodeGen: "-- "Hello"  <= "World" since H <= W{-- "Qweabc" <= "Qwevwxy" since a <= e;-- "Qweayc" <= "Qwexby";-- "Qwe"    <= "Qwerty";-- "Qwerty" <= "Qwe" - fal ...}" 
 -- DataItem:markForCodeGen: "L" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "L1" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "L2" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- markItem: "L1 := length{-- min length of this and V}" Assign 
 -- Invocation:markForCodeGen: "L1" 
 -- ObjectInvocation:markForCodeGen: "L1"  ATd: "L1: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "length{-- min length of this and V}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "length{-- min length of this and V}" 
 -- "length{-- min length of this and V}" false 
 -- 
 -- OG:markSuper: "length{-- min length of this and V}" 
 -- Invocation:markForCodeGen: "length{-- min length of this and V}" 
 -- ObjectInvocation:markForCodeGen: "length{-- min length of this and V}"  ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OI:args:markForCodgen: "-- min length of this and V" 
 -- not ObjDesc:  "length{-- min length of this and V}"  IS.isEmpty:  true 
 -- markItem: "L2 := Veq.length" Assign 
 -- Invocation:markForCodeGen: "L2" 
 -- ObjectInvocation:markForCodeGen: "L2"  ATd: "L2: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "Veq.length" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Veq.length" 
 -- "Veq" true 
 -- "length" false 
 -- 
 -- OG:markSuper: "Veq.length" 
 -- Invocation:markForCodeGen: "Veq.length" 
 -- ObjectInvocation:markForCodeGen: "Veq"  ATd: "in Veq: var this(Value)" 
 -- DataItem:markForCodeGen: "Veq" :descNo: 0 :OG.primNo: 18 
 -- OG:markForCodeGen: "this(Value)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "this(Value)" 
 -- "this(Value)" true 
 -- 
 -- OG:markSuper: "this(Value)" 
 -- Invocation:markForCodeGen: "this(Value)" 
 -- ObjectInvocation:markForCodeGen: "this(Value)"  ATd: "this: {   %basic 18;   in this: ref Object}" 
 -- OI:args:markForCodgen: "this(Value)" 
 -- OG:markForCodeGen: "Value" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Value" 
 -- "Value" true 
 -- 
 -- OG:markSuper: "Value" 
 -- Invocation:markForCodeGen: "Value" 
 -- ObjectInvocation:markForCodeGen: "Value"  ATd: "Value: {   %ID Value;   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Value"  IS.isEmpty:  true 
 -- arg:   "Value" 
 -- not ObjDesc:  "this(Value)"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "length"  ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Veq.length"  IS.isEmpty:  true 
 -- markItem: "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" ObjectGenerator 
 -- OG:markForCodeGen: "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" true 
 -- 
 -- OG:markSuper: "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- Invocation:markForCodeGen: "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- OG:markForCodeGen: "(L1 < L2)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(L1 < L2)" 
 -- "(L1 < L2)" true 
 -- 
 -- OG:markSuper: "(L1 < L2)" 
 -- Invocation:markForCodeGen: "(L1 < L2)" 
 -- Invocation:markForCodeGen: "L1 < L2" 
 -- BinaryExp:markForCodeGen: "L1 < L2" 
 -- Invocation:markForCodeGen: "L1" 
 -- ObjectInvocation:markForCodeGen: "L1"  ATd: "L1: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "< L2"  ATd: "<  : {   %basic 51;   in V: var integer;   out B: var boolean}" 
 -- Pattern:markForCodeGen: "<  : {   %basic 51;   in V: var integer;   out B: var boolean}" 
 -- items:markForCodeGen: "" 
 -- OI:args:markForCodgen: "L2" 
 -- OG:markForCodeGen: "L2" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "L2" 
 -- "L2" true 
 -- 
 -- not ObjDesc:  "(L1 < L2)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "L := L1" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "L := L1" 
 -- OG:Qalloc: "L := L1" qDescno:  55 
 -- ObjTmpStack:add: "L := L1" 
 -- items:markForCodeGen: "L := L1" 
 -- markItem: "L := L1" Assign 
 -- Invocation:markForCodeGen: "L" 
 -- ObjectInvocation:markForCodeGen: "L"  ATd: "L: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "L1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "L1" 
 -- "L1" true 
 -- 
 -- OG:markForCodeGen: "L := L2" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "L := L2" 
 -- OG:Qalloc: "L := L2" qDescno:  56 
 -- ObjTmpStack:add: "L := L2" 
 -- items:markForCodeGen: "L := L2" 
 -- markItem: "L := L2" Assign 
 -- Invocation:markForCodeGen: "L" 
 -- ObjectInvocation:markForCodeGen: "L"  ATd: "L: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "L2" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "L2" 
 -- "L2" true 
 -- 
 -- not ObjDesc:  "if (L1 < L2) :then {   L := L1;:else ;   L := L2}"  IS.isEmpty:  true 
 -- markItem: "matchEq" ObjectGenerator 
 -- OG:markForCodeGen: "matchEq" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "matchEq" 
 -- "matchEq" false 
 -- 
 -- OG:markSuper: "matchEq" 
 -- Invocation:markForCodeGen: "matchEq" 
 -- ObjectInvocation:markForCodeGen: "matchEq"  ATd: "matchEq: {   inx: var integer;   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := L1 ...}" 
 -- Pattern:markForCodeGen: "matchEq: {   inx: var integer;   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := L1 <= L2;         leave(mat ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "inx: var integer{   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := L1 <= L2;         leave(matchEq);      if (L2 ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "inx: var integer{   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := L1 <= L2;         leave(matchEq);      if (L2 = 0) :t ...}" 
 -- OG:Qalloc: "inx: var integer{   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := L1 <= L2;         leave(matchEq);      if (L2 = 0) :t ...}" q ... 57 
 -- ObjTmpStack:add: "matchEq" : "inx: var integer{   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := L1 <= L2;         leave(matchEq);   ...}" 
 -- items:markForCodeGen: "inx: var integer{c1: var char;c2: var char;isEmpty: do ;   if (L1 = 0) :then ;      Beq := L1 <= L2;      leave(matchEq);   if (L2 = 0) :then ;      ...}" 
 -- DataItem:markForCodeGen: "inx" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "c1" :descNo: 0 :OG.primNo: 3 
 -- OG:markForCodeGen: "char" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "char" 
 -- "char" true 
 -- 
 -- OG:markSuper: "char" 
 -- Invocation:markForCodeGen: "char" 
 -- ObjectInvocation:markForCodeGen: "char"  ATd: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61; ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "char"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "c2" :descNo: 0 :OG.primNo: 3 
 -- OG:markForCodeGen: "char" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "char" 
 -- "char" true 
 -- 
 -- OG:markSuper: "char" 
 -- Invocation:markForCodeGen: "char" 
 -- ObjectInvocation:markForCodeGen: "char"  ATd: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61; ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "char"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "if (L1 = 0) :then {      Beq := L1 <= L2;      leave(matchEq);   if (L2 = 0) :then ;      Beq := false;      leave(matchEq)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "if (L1 = 0) :then {      Beq := L1 <= L2;      leave(matchEq);   if (L2 = 0) :then ;      Beq := false;      leave(matchEq)}" 
 -- OG:Qalloc: "if (L1 = 0) :then {      Beq := L1 <= L2;      leave(matchEq);   if (L2 = 0) :then ;      Beq := false;      leave(matchEq)}" qDescno:  0 
 -- OG:Qalloc:A:  "isEmpty"  super:  ""  marked:  true "isEmpty: do {   if (L1 = 0) :then ;      Beq := L1 <= L2;      leave(matchEq);   if (L2 = 0) :then ;      Beq := false; ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "if (L1 = 0) :then {      Beq := L1 <= L2;      leave(matchEq);   if (L2 = 0) :then ;      Beq := false;      leave(matchEq)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "isEmpty" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 58 IS.newDescNo: 58 objSize: 0 1: 1 "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq);if (L2 = 0) :then ;   Beq := false;   leave(matchEq ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 58 "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq);if (L2 = 0) :then ;   Beq := false;   leave(matchEq)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}"  marked:  false "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq);if ( ...}" s ... i ... 
 -- Invocation:Qalloc: "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- OG:Qalloc: "(L1 = 0)" qDescno:  0 
 -- OG:Qalloc:A:  "="  super:  "(L1 = 0)"  marked:  false "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" super:  (L1 = 0) 
 -- Invocation:Qalloc: "(L1 = 0)" 
 -- Invocation:Qalloc: "L1 = 0" 
 -- BinaryExp:Qalloc: "L1 = 0" 
 -- Invocation:Qalloc: "L1" 
 -- ObjectInvocation:Qalloc: "L1" 
 -- name: "L1" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "= 0" 
 -- name: "=" 
 -- Arguments "0" 
 -- OG:Qalloc: "0" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "0"  marked:  false "0" super:  0 
 -- Invocation:Qalloc: "0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "0" 
 -- super:  "0" 
 -- E:  "0" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  11 5 %basic 50{in Veq: var this(Value);out Beq: var boolean;inner(= )} 
 -- OG:super:  "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(L1 = 0)" 
 -- super:  "(L1 = 0)" 
 -- E:  "(L1 = 0)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(L1 = 0)" 
 -- OG:Qalloc: "Beq := L1 <= L2{   leave(matchEq)}" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Beq := L1 <= L2{   leave(matchEq)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 59 IS.newDescNo: 59 objSize: 0 1: 1 "Beq := L1 <= L2{leave(matchEq)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 59 "Beq := L1 <= L2{leave(matchEq)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "Beq" 
 -- ObjectInvocation:Qalloc: "Beq" 
 -- name: "Beq" 
 -- Arguments "" 
 -- OG:Qalloc: "L1 <= L2" qDescno:  0 
 -- OG:Qalloc:A:  "<="  super:  "L1 <= L2"  marked:  false "Beq := L1 <= L2" super:  L1 <= L2 
 -- Invocation:Qalloc: "L1 <= L2" 
 -- BinaryExp:Qalloc: "L1 <= L2" 
 -- Invocation:Qalloc: "L1" 
 -- ObjectInvocation:Qalloc: "L1" 
 -- name: "L1" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "<= L2" 
 -- name: "<=" 
 -- Arguments "L2" 
 -- OG:Qalloc: "L2" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "L2"  marked:  false "L2" super:  L2 
 -- Invocation:Qalloc: "L2" 
 -- ObjectInvocation:Qalloc: "L2" 
 -- name: "L2" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "L2: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L2" 
 -- super:  "L2" 
 -- E:  "L2" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L2" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  47 5 %basic 52{in Veq: var this(Value);out Beq: var boolean} 
 -- OG:super:  "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L1 <= L2" 
 -- super:  "L1 <= L2" 
 -- E:  "L1 <= L2" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L1 <= L2" 
 -- OG:Qalloc: "leave(matchEq)" qDescno:  0 
 -- OG:Qalloc:A:  "leave"  super:  "leave(matchEq)"  marked:  false "Beq := L1 <= L2{leave(matchEq)}" super:  leave(matchEq) 
 -- Invocation:Qalloc: "leave(matchEq)" 
 -- ObjectInvocation:Qalloc: "leave(matchEq)" 
 -- name: "leave" 
 -- Arguments "leave(matchEq)" 
 -- OG:Qalloc: "matchEq" qDescno:  0 
 -- OG:Qalloc:A:  "matchEq"  super:  "matchEq"  marked:  false "leave(matchEq)" super:  matchEq 
 -- Invocation:Qalloc: "matchEq" 
 -- ObjectInvocation:Qalloc: "matchEq" 
 -- name: "matchEq" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  57 4 inx: var integer{c1: var char;c2: var char;isEmpty: do ;   if (L1 = 0) :then ;      Beq := L1 <= L2;      leave(ma ...} 
 -- OG:super:  "matchEq: {   inx: var integer;   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := L1 <= L2;         leave(matchEq);      i ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "matchEq" 
 -- super:  "matchEq" 
 -- E:  "matchEq" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "matchEq" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  19 2 %basic 103 
 -- OG:super:  "leave(V: var integer): {   %basic 103}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "leave(matchEq)" 
 -- super:  "leave(matchEq)" 
 -- E:  "leave(matchEq)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "leave(matchEq)" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 59 "Beq := L1 <= L2{leave(matchEq)}" 
 -- IS.newDescNo: 59 IS.objSize: 1 "Beq := L1 <= L2{leave(matchEq)}" 
 -- OG:Qalloc:end: IS.newDescNo:  59 "Beq := L1 <= L2{   leave(matchEq)}" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- super:  "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- E:  "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- OG:Qalloc: "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}"  marked:  false "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq);if (L2  ...}" s ... i ... 
 -- Invocation:Qalloc: "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- OG:Qalloc: "(L2 = 0)" qDescno:  0 
 -- OG:Qalloc:A:  "="  super:  "(L2 = 0)"  marked:  false "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" super:  (L2 = 0) 
 -- Invocation:Qalloc: "(L2 = 0)" 
 -- Invocation:Qalloc: "L2 = 0" 
 -- BinaryExp:Qalloc: "L2 = 0" 
 -- Invocation:Qalloc: "L2" 
 -- ObjectInvocation:Qalloc: "L2" 
 -- name: "L2" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "= 0" 
 -- name: "=" 
 -- Arguments "0" 
 -- OG:Qalloc: "0" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "0"  marked:  false "0" super:  0 
 -- Invocation:Qalloc: "0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "0" 
 -- super:  "0" 
 -- E:  "0" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  11 5 %basic 50{in Veq: var this(Value);out Beq: var boolean;inner(= )} 
 -- OG:super:  "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(L2 = 0)" 
 -- super:  "(L2 = 0)" 
 -- E:  "(L2 = 0)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(L2 = 0)" 
 -- OG:Qalloc: "Beq := false{   leave(matchEq)}" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Beq := false{   leave(matchEq)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 60 IS.newDescNo: 60 objSize: 0 1: 1 "Beq := false{leave(matchEq)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 60 "Beq := false{leave(matchEq)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "Beq" 
 -- ObjectInvocation:Qalloc: "Beq" 
 -- name: "Beq" 
 -- Arguments "" 
 -- OG:Qalloc: "false" qDescno:  0 
 -- OG:Qalloc:A:  "False"  super:  "false"  marked:  false "Beq := false" super:  false 
 -- Invocation:Qalloc: "false" 
 -- ObjectInvocation:Qalloc: "false" 
 -- name: "false" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  27 1 %globals{out B: var boolean;B := 0} 
 -- OG:super:  "False: {   %globals;   out B: var boolean;   B := 0}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "false" 
 -- super:  "false" 
 -- E:  "false" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "false" 
 -- OG:Qalloc: "leave(matchEq)" qDescno:  0 
 -- OG:Qalloc:A:  "leave"  super:  "leave(matchEq)"  marked:  false "Beq := false{leave(matchEq)}" super:  leave(matchEq) 
 -- Invocation:Qalloc: "leave(matchEq)" 
 -- ObjectInvocation:Qalloc: "leave(matchEq)" 
 -- name: "leave" 
 -- Arguments "leave(matchEq)" 
 -- OG:Qalloc: "matchEq" qDescno:  0 
 -- OG:Qalloc:A:  "matchEq"  super:  "matchEq"  marked:  false "leave(matchEq)" super:  matchEq 
 -- Invocation:Qalloc: "matchEq" 
 -- ObjectInvocation:Qalloc: "matchEq" 
 -- name: "matchEq" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  57 4 inx: var integer{c1: var char;c2: var char;isEmpty: do ;   if (L1 = 0) :then ;      Beq := L1 <= L2;      leave(ma ...} 
 -- OG:super:  "matchEq: {   inx: var integer;   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := L1 <= L2;         leave(matchEq);      i ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "matchEq" 
 -- super:  "matchEq" 
 -- E:  "matchEq" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "matchEq" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  19 2 %basic 103 
 -- OG:super:  "leave(V: var integer): {   %basic 103}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "leave(matchEq)" 
 -- super:  "leave(matchEq)" 
 -- E:  "leave(matchEq)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "leave(matchEq)" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 60 "Beq := false{leave(matchEq)}" 
 -- IS.newDescNo: 60 IS.objSize: 1 "Beq := false{leave(matchEq)}" 
 -- OG:Qalloc:end: IS.newDescNo:  60 "Beq := false{   leave(matchEq)}" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- super:  "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- E:  "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 58 "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq);if (L2 = 0) :then ;   Beq := false;   leave(matchEq)}" 
 -- IS.newDescNo: 58 IS.objSize: 1 "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq);if (L2 = 0) :then ;   Beq := false;   leave(matchEq)}" 
 -- OG:Qalloc:end: IS.newDescNo:  58 "if (L1 = 0) :then {      Beq := L1 <= L2;      leave(matchEq);   if (L2 = 0) :then ;      Beq := false;      leave(matchEq)}" 
 -- ObjTmpStack:add: "isEmpty" : "if (L1 = 0) :then {      Beq := L1 <= L2;      leave(matchEq);   if (L2 = 0) :then ;      Beq := false;      leave(matchEq)}" 
 -- items:markForCodeGen: "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq);if (L2 = 0) :then ;   Beq := false;   leave(matchEq)}" 
 -- markItem: "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" ObjectGenerator 
 -- OG:markForCodeGen: "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" true 
 -- 
 -- OG:markSuper: "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- Invocation:markForCodeGen: "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- OG:markForCodeGen: "(L1 = 0)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(L1 = 0)" 
 -- "(L1 = 0)" true 
 -- 
 -- OG:markSuper: "(L1 = 0)" 
 -- Invocation:markForCodeGen: "(L1 = 0)" 
 -- Invocation:markForCodeGen: "L1 = 0" 
 -- BinaryExp:markForCodeGen: "L1 = 0" 
 -- Invocation:markForCodeGen: "L1" 
 -- ObjectInvocation:markForCodeGen: "L1"  ATd: "L1: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "= 0"  ATd: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OI:args:markForCodgen: "0" 
 -- OG:markForCodeGen: "0" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "0" 
 -- "0" true 
 -- 
 -- OG:markSuper: "0" 
 -- Invocation:markForCodeGen: "0" 
 -- not ObjDesc:  "0"  IS.isEmpty:  true 
 -- not ObjDesc:  "(L1 = 0)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "Beq := L1 <= L2{   leave(matchEq)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "Beq := L1 <= L2{   leave(matchEq)}" 
 -- OG:Qalloc: "Beq := L1 <= L2{   leave(matchEq)}" qDescno:  59 
 -- ObjTmpStack:add: "Beq := L1 <= L2{   leave(matchEq)}" 
 -- items:markForCodeGen: "Beq := L1 <= L2{leave(matchEq)}" 
 -- markItem: "Beq := L1 <= L2" Assign 
 -- Invocation:markForCodeGen: "Beq" 
 -- ObjectInvocation:markForCodeGen: "Beq"  ATd: "out Beq: var boolean" 
 -- DataItem:markForCodeGen: "Beq" :descNo: 0 :OG.primNo: 4 
 -- OG:markForCodeGen: "boolean" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "boolean" 
 -- "boolean" true 
 -- 
 -- OG:markSuper: "boolean" 
 -- Invocation:markForCodeGen: "boolean" 
 -- ObjectInvocation:markForCodeGen: "boolean"  ATd: "Boolean: value{   %id "Boolean";   %globals inSub;   %basic 4, 8;   %public;   _thisBasicValue: var Universal;   &&  : ;  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "boolean"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "L1 <= L2" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "L1 <= L2" 
 -- "L1 <= L2" true 
 -- 
 -- OG:markSuper: "L1 <= L2" 
 -- Invocation:markForCodeGen: "L1 <= L2" 
 -- BinaryExp:markForCodeGen: "L1 <= L2" 
 -- Invocation:markForCodeGen: "L1" 
 -- ObjectInvocation:markForCodeGen: "L1"  ATd: "L1: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "<= L2"  ATd: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- OI:args:markForCodgen: "L2" 
 -- OG:markForCodeGen: "L2" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "L2" 
 -- "L2" true 
 -- 
 -- not ObjDesc:  "L1 <= L2"  IS.isEmpty:  true 
 -- markItem: "leave(matchEq)" ObjectGenerator 
 -- not ObjDesc:  "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}"  IS.isEmpty:  true 
 -- markItem: "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" ObjectGenerator 
 -- OG:markForCodeGen: "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" true 
 -- 
 -- OG:markSuper: "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- Invocation:markForCodeGen: "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- OG:markForCodeGen: "(L2 = 0)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(L2 = 0)" 
 -- "(L2 = 0)" true 
 -- 
 -- OG:markSuper: "(L2 = 0)" 
 -- Invocation:markForCodeGen: "(L2 = 0)" 
 -- Invocation:markForCodeGen: "L2 = 0" 
 -- BinaryExp:markForCodeGen: "L2 = 0" 
 -- Invocation:markForCodeGen: "L2" 
 -- ObjectInvocation:markForCodeGen: "L2"  ATd: "L2: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "= 0"  ATd: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OI:args:markForCodgen: "0" 
 -- OG:markForCodeGen: "0" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "0" 
 -- "0" true 
 -- 
 -- OG:markSuper: "0" 
 -- Invocation:markForCodeGen: "0" 
 -- not ObjDesc:  "0"  IS.isEmpty:  true 
 -- not ObjDesc:  "(L2 = 0)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "Beq := false{   leave(matchEq)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "Beq := false{   leave(matchEq)}" 
 -- OG:Qalloc: "Beq := false{   leave(matchEq)}" qDescno:  60 
 -- ObjTmpStack:add: "Beq := false{   leave(matchEq)}" 
 -- items:markForCodeGen: "Beq := false{leave(matchEq)}" 
 -- markItem: "Beq := false" Assign 
 -- Invocation:markForCodeGen: "Beq" 
 -- ObjectInvocation:markForCodeGen: "Beq"  ATd: "out Beq: var boolean" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "false" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "false" 
 -- "false" false 
 -- 
 -- OG:markSuper: "false" 
 -- Invocation:markForCodeGen: "false" 
 -- ObjectInvocation:markForCodeGen: "false"  ATd: "False: {   %globals;   out B: var boolean;   B := 0}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "false"  IS.isEmpty:  true 
 -- markItem: "leave(matchEq)" ObjectGenerator 
 -- not ObjDesc:  "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "inx := inx + 1{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 = c2) :then ;      if (inx < L) :then ;         restart(loop)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "inx := inx + 1{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 = c2) :then ;      if (inx < L) :then ;         restart(loop)}" 
 -- OG:Qalloc: "inx := inx + 1{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 = c2) :then ;      if (inx < L) :then ;         restart(loop)}" qDescno:  0 
 -- OG:Qalloc:A:  "loop"  super:  ""  marked:  true "loop: do {   inx := inx + 1;   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 = c2) :then ;      if (inx < L) :then ;      ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx := inx + 1{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 = c2) :then ;      if (inx < L) :then ;         restart(loop)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "loop" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 61 IS.newDescNo: 61 objSize: 0 1: 1 "inx := inx + 1{c1 := get[inx];c2 := Veq.get[inx];if (c1 = c2) :then ;   if (inx < L) :then ;      restart(l ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 61 "inx := inx + 1{c1 := get[inx];c2 := Veq.get[inx];if (c1 = c2) :then ;   if (inx < L) :then ;      restart(loop)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- OG:Qalloc: "inx + 1" qDescno:  0 
 -- OG:Qalloc:A:  "+"  super:  "inx + 1"  marked:  false "inx := inx + 1" super:  inx + 1 
 -- Invocation:Qalloc: "inx + 1" 
 -- BinaryExp:Qalloc: "inx + 1" 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "+ 1" 
 -- name: "+" 
 -- Arguments "1" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "1" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  49 5 %basic 61{in V: var integer;out R: var integer} 
 -- OG:super:  "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx + 1" 
 -- super:  "inx + 1" 
 -- E:  "inx + 1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx + 1" 
 -- Invocation:Qalloc: "c1" 
 -- ObjectInvocation:Qalloc: "c1" 
 -- name: "c1" 
 -- Arguments "" 
 -- OG:Qalloc: "get[inx]" qDescno:  0 
 -- OG:Qalloc:A:  "get"  super:  "get[inx]"  marked:  false "c1 := get[inx]" super:  get[inx] 
 -- Invocation:Qalloc: "get[inx]" 
 -- ObjectInvocation:Qalloc: "get[inx]" 
 -- name: "get" 
 -- Arguments "get[inx]" 
 -- OG:Qalloc: "inx" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "inx"  marked:  false "get[inx]" super:  inx 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "inx: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx" 
 -- super:  "inx" 
 -- E:  "inx" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  16 3 %basic 117{out ch: var char} 
 -- OG:super:  "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "get[inx]" 
 -- super:  "get[inx]" 
 -- E:  "get[inx]" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "get[inx]" 
 -- Invocation:Qalloc: "c2" 
 -- ObjectInvocation:Qalloc: "c2" 
 -- name: "c2" 
 -- Arguments "" 
 -- OG:Qalloc: "Veq.get[inx]" qDescno:  0 
 -- OG:Qalloc:A:  "get"  super:  "Veq.get[inx]"  marked:  false "c2 := Veq.get[inx]" super:  Veq.get[inx] 
 -- Invocation:Qalloc: "Veq.get[inx]" 
 -- ObjectInvocation:Qalloc: "Veq" 
 -- name: "Veq" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "get[inx]" 
 -- name: "get" 
 -- Arguments "get[inx]" 
 -- OG:Qalloc: "inx" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "inx"  marked:  false "get[inx]" super:  inx 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "inx: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx" 
 -- super:  "inx" 
 -- E:  "inx" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  16 3 %basic 117{out ch: var char} 
 -- OG:super:  "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Veq.get[inx]" 
 -- super:  "Veq.get[inx]" 
 -- E:  "get[inx]" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Veq.get[inx]" 
 -- OG:Qalloc: "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}"  marked:  false "inx := inx + 1{c1 := get[inx];c2 := Veq.get[inx];if ( ...}" s ... i ... 
 -- Invocation:Qalloc: "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- OG:Qalloc: "(c1 = c2)" qDescno:  0 
 -- OG:Qalloc:A:  "="  super:  "(c1 = c2)"  marked:  false "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" super:  (c1 = c2) 
 -- Invocation:Qalloc: "(c1 = c2)" 
 -- Invocation:Qalloc: "c1 = c2" 
 -- BinaryExp:Qalloc: "c1 = c2" 
 -- Invocation:Qalloc: "c1" 
 -- ObjectInvocation:Qalloc: "c1" 
 -- name: "c1" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "= c2" 
 -- name: "=" 
 -- Arguments "c2" 
 -- OG:Qalloc: "c2" qDescno:  0 
 -- OG:Qalloc:A:  "char"  super:  "c2"  marked:  false "c2" super:  c2 
 -- Invocation:Qalloc: "c2" 
 -- ObjectInvocation:Qalloc: "c2" 
 -- name: "c2" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  7 1 %id "char"{%globals;%basic 3, 16;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var char;   out ...} 
 -- OG:super:  "c2: var char" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "c2" 
 -- super:  "c2" 
 -- E:  "c2" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "c2" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  11 5 %basic 50{in Veq: var this(Value);out Beq: var boolean;inner(= )} 
 -- OG:super:  "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(c1 = c2)" 
 -- super:  "(c1 = c2)" 
 -- E:  "(c1 = c2)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(c1 = c2)" 
 -- OG:Qalloc: "if (inx < L) :then {      restart(loop)}" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "if (inx < L) :then {      restart(loop)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 62 IS.newDescNo: 62 objSize: 0 1: 1 "if (inx < L) :then {   restart(loop)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 62 "if (inx < L) :then {   restart(loop)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: "if (inx < L) :then {   restart(loop)}" qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (inx < L) :then {   restart(loop)}"  marked:  false "if (inx < L) :then {   restart(loop)}" super:  if (inx < L) :then {   restart(l ...} 
 -- Invocation:Qalloc: "if (inx < L) :then {   restart(loop)}" 
 -- OG:Qalloc: "(inx < L)" qDescno:  0 
 -- OG:Qalloc:A:  "<"  super:  "(inx < L)"  marked:  false "if (inx < L) :then {   restart(loop)}" super:  (inx < L) 
 -- Invocation:Qalloc: "(inx < L)" 
 -- Invocation:Qalloc: "inx < L" 
 -- BinaryExp:Qalloc: "inx < L" 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "< L" 
 -- name: "<" 
 -- Arguments "L" 
 -- OG:Qalloc: "L" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "L"  marked:  false "L" super:  L 
 -- Invocation:Qalloc: "L" 
 -- ObjectInvocation:Qalloc: "L" 
 -- name: "L" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "L: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L" 
 -- super:  "L" 
 -- E:  "L" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  54 5 %basic 51{in V: var integer;out B: var boolean} 
 -- OG:super:  "<  : {   %basic 51;   in V: var integer;   out B: var boolean}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(inx < L)" 
 -- super:  "(inx < L)" 
 -- E:  "(inx < L)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(inx < L)" 
 -- OG:Qalloc: "restart(loop)" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (inx < L) :then {   restart(loop)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "restart(loop)" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 63 IS.newDescNo: 63 objSize: 0 1: 1 "restart(loop)" 
 -- Items:Qalloc:objSize: 0  newDescNo: 63 "restart(loop)" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: "restart(loop)" qDescno:  0 
 -- OG:Qalloc:A:  "restart"  super:  "restart(loop)"  marked:  false "restart(loop)" super:  restart(loop) 
 -- Invocation:Qalloc: "restart(loop)" 
 -- ObjectInvocation:Qalloc: "restart(loop)" 
 -- name: "restart" 
 -- Arguments "restart(loop)" 
 -- OG:Qalloc: "loop" qDescno:  0 
 -- OG:Qalloc:A:  "loop"  super:  "loop"  marked:  false "restart(loop)" super:  loop 
 -- Invocation:Qalloc: "loop" 
 -- ObjectInvocation:Qalloc: "loop" 
 -- name: "loop" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  61 1 inx := inx + 1{c1 := get[inx];c2 := Veq.get[inx];if (c1 = c2) :then ;   if (inx < L) :then ;      restart(loop)} 
 -- OG:super:  "loop: do {   inx := inx + 1;   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 = c2) :then ;      if (inx < L) :then ;         restart(loop)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "loop" 
 -- super:  "loop" 
 -- E:  "loop" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "loop" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  50 2 %basic 102 
 -- OG:super:  "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "restart(loop)" 
 -- super:  "restart(loop)" 
 -- E:  "restart(loop)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "restart(loop)" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 63 "restart(loop)" 
 -- IS.newDescNo: 63 IS.objSize: 1 "restart(loop)" 
 -- OG:Qalloc:end: IS.newDescNo:  63 "restart(loop)" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (inx < L) :then {   restart(loop)}" 
 -- super:  "if (inx < L) :then {   restart(loop)}" 
 -- E:  "if (inx < L) :then {   restart(loop)}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (inx < L) :then {   restart(loop)}" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 62 "if (inx < L) :then {   restart(loop)}" 
 -- IS.newDescNo: 62 IS.objSize: 1 "if (inx < L) :then {   restart(loop)}" 
 -- OG:Qalloc:end: IS.newDescNo:  62 "if (inx < L) :then {      restart(loop)}" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- super:  "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- E:  "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 61 "inx := inx + 1{c1 := get[inx];c2 := Veq.get[inx];if (c1 = c2) :then ;   if (inx < L) :then ;      restart(loop)}" 
 -- IS.newDescNo: 61 IS.objSize: 1 "inx := inx + 1{c1 := get[inx];c2 := Veq.get[inx];if (c1 = c2) :then ;   if (inx < L) :then ;      restart(loop)}" 
 -- OG:Qalloc:end: IS.newDescNo:  61 "inx := inx + 1{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 = c2) :then ;      if (inx < L) :then ;         restart(loop)}" 
 -- ObjTmpStack:add: "loop" : "inx := inx + 1{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 = c2) :then ;      if (inx < L) :then ;         restart(loop)}" 
 -- items:markForCodeGen: "inx := inx + 1{c1 := get[inx];c2 := Veq.get[inx];if (c1 = c2) :then ;   if (inx < L) :then ;      restart(loop)}" 
 -- markItem: "inx := inx + 1" Assign 
 -- Invocation:markForCodeGen: "inx" 
 -- ObjectInvocation:markForCodeGen: "inx"  ATd: "inx: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "inx + 1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "inx + 1" 
 -- "inx + 1" true 
 -- 
 -- OG:markSuper: "inx + 1" 
 -- Invocation:markForCodeGen: "inx + 1" 
 -- BinaryExp:markForCodeGen: "inx + 1" 
 -- Invocation:markForCodeGen: "inx" 
 -- ObjectInvocation:markForCodeGen: "inx"  ATd: "inx: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "+ 1"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OI:args:markForCodgen: "1" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- not ObjDesc:  "inx + 1"  IS.isEmpty:  true 
 -- markItem: "c1 := get[inx]" Assign 
 -- Invocation:markForCodeGen: "c1" 
 -- ObjectInvocation:markForCodeGen: "c1"  ATd: "c1: var char" 
 -- OI:args:markForCodgen: "" 
 -- markItem: "c2 := Veq.get[inx]" Assign 
 -- Invocation:markForCodeGen: "c2" 
 -- ObjectInvocation:markForCodeGen: "c2"  ATd: "c2: var char" 
 -- OI:args:markForCodgen: "" 
 -- markItem: "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" ObjectGenerator 
 -- OG:markForCodeGen: "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" true 
 -- 
 -- OG:markSuper: "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- Invocation:markForCodeGen: "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- OG:markForCodeGen: "(c1 = c2)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(c1 = c2)" 
 -- "(c1 = c2)" true 
 -- 
 -- OG:markSuper: "(c1 = c2)" 
 -- Invocation:markForCodeGen: "(c1 = c2)" 
 -- Invocation:markForCodeGen: "c1 = c2" 
 -- BinaryExp:markForCodeGen: "c1 = c2" 
 -- Invocation:markForCodeGen: "c1" 
 -- ObjectInvocation:markForCodeGen: "c1"  ATd: "c1: var char" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "= c2"  ATd: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OI:args:markForCodgen: "c2" 
 -- OG:markForCodeGen: "c2" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "c2" 
 -- "c2" true 
 -- 
 -- not ObjDesc:  "(c1 = c2)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "if (inx < L) :then {      restart(loop)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "if (inx < L) :then {      restart(loop)}" 
 -- OG:Qalloc: "if (inx < L) :then {      restart(loop)}" qDescno:  62 
 -- ObjTmpStack:add: "if (inx < L) :then {      restart(loop)}" 
 -- items:markForCodeGen: "if (inx < L) :then {   restart(loop)}" 
 -- markItem: "if (inx < L) :then {   restart(loop)}" ObjectGenerator 
 -- OG:markForCodeGen: "if (inx < L) :then {   restart(loop)}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (inx < L) :then {   restart(loop)}" 
 -- "if (inx < L) :then {   restart(loop)}" true 
 -- 
 -- OG:markSuper: "if (inx < L) :then {   restart(loop)}" 
 -- Invocation:markForCodeGen: "if (inx < L) :then {   restart(loop)}" 
 -- OG:markForCodeGen: "(inx < L)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(inx < L)" 
 -- "(inx < L)" true 
 -- 
 -- OG:markSuper: "(inx < L)" 
 -- Invocation:markForCodeGen: "(inx < L)" 
 -- Invocation:markForCodeGen: "inx < L" 
 -- BinaryExp:markForCodeGen: "inx < L" 
 -- Invocation:markForCodeGen: "inx" 
 -- ObjectInvocation:markForCodeGen: "inx"  ATd: "inx: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "< L"  ATd: "<  : {   %basic 51;   in V: var integer;   out B: var boolean}" 
 -- OI:args:markForCodgen: "L" 
 -- OG:markForCodeGen: "L" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "L" 
 -- "L" true 
 -- 
 -- not ObjDesc:  "(inx < L)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "restart(loop)" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "restart(loop)" 
 -- OG:Qalloc: "restart(loop)" qDescno:  63 
 -- ObjTmpStack:add: "restart(loop)" 
 -- items:markForCodeGen: "restart(loop)" 
 -- markItem: "restart(loop)" ObjectGenerator 
 -- not ObjDesc:  "if (inx < L) :then {   restart(loop)}"  IS.isEmpty:  true 
 -- not ObjDesc:  "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "if (c1 = c2) :then {      -- we have inx = LBeq := L1 <= L2;      leave(matchEq);   :else ;      Beq := c1 < c2;      leave(matchEq)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "if (c1 = c2) :then {      -- we have inx = LBeq := L1 <= L2;      leave(matchEq);   :else ;      Beq := c1 < c2;      leave(matchEq)}" 
 -- OG:Qalloc: "if (c1 = c2) :then {      -- we have inx = LBeq := L1 <= L2;      leave(matchEq);   :else ;      Beq := c1 < c2;      leave(matchEq)}" qDescno:  0 
 -- OG:Qalloc:A:  "doit"  super:  ""  marked:  true "doit: do {   if (c1 = c2) :then ;      -- we have inx = LBeq := L1 <= L2;      leave(matchEq);   :else ;      Beq := c1 <  ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "if (c1 = c2) :then {      -- we have inx = LBeq := L1 <= L2;      leave(matchEq);   :else ;      Beq := c1 < c2;      leave(matchEq)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "doit" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 64 IS.newDescNo: 64 objSize: 0 1: 1 "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leav ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 64 "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}"  marked:  false "i ..." s ... i ... 
 -- Invocation:Qalloc: "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- OG:Qalloc: "(c1 = c2)" qDescno:  0 
 -- OG:Qalloc:A:  "="  super:  "(c1 = c2)"  marked:  false "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchE ...}" s ... ( ... 
 -- Invocation:Qalloc: "(c1 = c2)" 
 -- Invocation:Qalloc: "c1 = c2" 
 -- BinaryExp:Qalloc: "c1 = c2" 
 -- Invocation:Qalloc: "c1" 
 -- ObjectInvocation:Qalloc: "c1" 
 -- name: "c1" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "= c2" 
 -- name: "=" 
 -- Arguments "c2" 
 -- OG:Qalloc: "c2" qDescno:  0 
 -- OG:Qalloc:A:  "char"  super:  "c2"  marked:  false "c2" super:  c2 
 -- Invocation:Qalloc: "c2" 
 -- ObjectInvocation:Qalloc: "c2" 
 -- name: "c2" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  7 1 %id "char"{%globals;%basic 3, 16;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var char;   out ...} 
 -- OG:super:  "c2: var char" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "c2" 
 -- super:  "c2" 
 -- E:  "c2" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "c2" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  11 5 %basic 50{in Veq: var this(Value);out Beq: var boolean;inner(= )} 
 -- OG:super:  "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(c1 = c2)" 
 -- super:  "(c1 = c2)" 
 -- E:  "(c1 = c2)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(c1 = c2)" 
 -- OG:Qalloc: "-- we have inx = LBeq := L1 <= L2{   leave(matchEq)}" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" sup ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "-- we have inx = LBeq := L1 <= L2{   leave(matchEq)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 65 IS.newDescNo: 65 objSize: 0 1: 1 "-- we have inx = LBeq := L1 <= L2{leave(matchEq)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 65 "-- we have inx = LBeq := L1 <= L2{leave(matchEq)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "Beq" 
 -- ObjectInvocation:Qalloc: "Beq" 
 -- name: "Beq" 
 -- Arguments "" 
 -- OG:Qalloc: "L1 <= L2" qDescno:  0 
 -- OG:Qalloc:A:  "<="  super:  "L1 <= L2"  marked:  false "Beq := L1 <= L2" super:  L1 <= L2 
 -- Invocation:Qalloc: "L1 <= L2" 
 -- BinaryExp:Qalloc: "L1 <= L2" 
 -- Invocation:Qalloc: "L1" 
 -- ObjectInvocation:Qalloc: "L1" 
 -- name: "L1" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "<= L2" 
 -- name: "<=" 
 -- Arguments "L2" 
 -- OG:Qalloc: "L2" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "L2"  marked:  false "L2" super:  L2 
 -- Invocation:Qalloc: "L2" 
 -- ObjectInvocation:Qalloc: "L2" 
 -- name: "L2" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "L2: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L2" 
 -- super:  "L2" 
 -- E:  "L2" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L2" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  47 5 %basic 52{in Veq: var this(Value);out Beq: var boolean} 
 -- OG:super:  "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L1 <= L2" 
 -- super:  "L1 <= L2" 
 -- E:  "L1 <= L2" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L1 <= L2" 
 -- OG:Qalloc: "leave(matchEq)" qDescno:  0 
 -- OG:Qalloc:A:  "leave"  super:  "leave(matchEq)"  marked:  false "-- we have inx = LBeq := L1 <= L2{leave(matchEq)}" super:  leave(matchEq) 
 -- Invocation:Qalloc: "leave(matchEq)" 
 -- ObjectInvocation:Qalloc: "leave(matchEq)" 
 -- name: "leave" 
 -- Arguments "leave(matchEq)" 
 -- OG:Qalloc: "matchEq" qDescno:  0 
 -- OG:Qalloc:A:  "matchEq"  super:  "matchEq"  marked:  false "leave(matchEq)" super:  matchEq 
 -- Invocation:Qalloc: "matchEq" 
 -- ObjectInvocation:Qalloc: "matchEq" 
 -- name: "matchEq" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  57 4 inx: var integer{c1: var char;c2: var char;isEmpty: do ;   if (L1 = 0) :then ;      Beq := L1 <= L2;      leave(ma ...} 
 -- OG:super:  "matchEq: {   inx: var integer;   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := L1 <= L2;         leave(matchEq);      i ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "matchEq" 
 -- super:  "matchEq" 
 -- E:  "matchEq" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "matchEq" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  19 2 %basic 103 
 -- OG:super:  "leave(V: var integer): {   %basic 103}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "leave(matchEq)" 
 -- super:  "leave(matchEq)" 
 -- E:  "leave(matchEq)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "leave(matchEq)" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 65 "-- we have inx = LBeq := L1 <= L2{leave(matchEq)}" 
 -- IS.newDescNo: 65 IS.objSize: 1 "-- we have inx = LBeq := L1 <= L2{leave(matchEq)}" 
 -- OG:Qalloc:end: IS.newDescNo:  65 "-- we have inx = LBeq := L1 <= L2{   leave(matchEq)}" 
 -- OG:Qalloc: "Beq := c1 < c2{   leave(matchEq)}" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" sup ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Beq := c1 < c2{   leave(matchEq)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 66 IS.newDescNo: 66 objSize: 0 1: 1 "Beq := c1 < c2{leave(matchEq)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 66 "Beq := c1 < c2{leave(matchEq)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "Beq" 
 -- ObjectInvocation:Qalloc: "Beq" 
 -- name: "Beq" 
 -- Arguments "" 
 -- OG:Qalloc: "c1 < c2" qDescno:  0 
 -- OG:Qalloc:A:  "<"  super:  "c1 < c2"  marked:  false "Beq := c1 < c2" super:  c1 < c2 
 -- Invocation:Qalloc: "c1 < c2" 
 -- BinaryExp:Qalloc: "c1 < c2" 
 -- Invocation:Qalloc: "c1" 
 -- ObjectInvocation:Qalloc: "c1" 
 -- name: "c1" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "< c2" 
 -- name: "<" 
 -- Arguments "c2" 
 -- OG:Qalloc: "c2" qDescno:  0 
 -- OG:Qalloc:A:  "char"  super:  "c2"  marked:  false "c2" super:  c2 
 -- Invocation:Qalloc: "c2" 
 -- ObjectInvocation:Qalloc: "c2" 
 -- name: "c2" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  7 1 %id "char"{%globals;%basic 3, 16;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var char;   out ...} 
 -- OG:super:  "c2: var char" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "c2" 
 -- super:  "c2" 
 -- E:  "c2" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "c2" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 51{in V: var char;out B: var boolean} 
 -- OG:Qalloc:SuperAlloc: "<  : {   %basic 51;   in V: var char;   out B: var boolean}" 
 -- OG:Qalloc: "%basic 51{   in V: var char;   out B: var boolean}" qDescno:  0 
 -- OG:Qalloc:A:  "<"  super:  ""  marked:  false "<  : {   %basic 51;   in V: var char;   out B: var boolean}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 51{   in V: var char;   out B: var boolean}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "<" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 67 IS.newDescNo: 67 objSize: 0 1: 1 "%basic 51{in V: var char;out B: var boolean}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 67 "%basic 51{in V: var char;out B: var boolean}" 
 -- Items:Qalloc:Super:C:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- dataitem:qalloc: "B" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 67 "%basic 51{in V: var char;out B: var boolean}" 
 -- IS.newDescNo: 67 IS.objSize: 5 "%basic 51{in V: var char;out B: var boolean}" 
 -- OG:Qalloc:end: IS.newDescNo:  67 "%basic 51{   in V: var char;   out B: var boolean}" 
 -- OG:super:  "<  : {   %basic 51;   in V: var char;   out B: var boolean}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "c1 < c2" 
 -- super:  "c1 < c2" 
 -- E:  "c1 < c2" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "c1 < c2" 
 -- OG:Qalloc: "leave(matchEq)" qDescno:  0 
 -- OG:Qalloc:A:  "leave"  super:  "leave(matchEq)"  marked:  false "Beq := c1 < c2{leave(matchEq)}" super:  leave(matchEq) 
 -- Invocation:Qalloc: "leave(matchEq)" 
 -- ObjectInvocation:Qalloc: "leave(matchEq)" 
 -- name: "leave" 
 -- Arguments "leave(matchEq)" 
 -- OG:Qalloc: "matchEq" qDescno:  0 
 -- OG:Qalloc:A:  "matchEq"  super:  "matchEq"  marked:  false "leave(matchEq)" super:  matchEq 
 -- Invocation:Qalloc: "matchEq" 
 -- ObjectInvocation:Qalloc: "matchEq" 
 -- name: "matchEq" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  57 4 inx: var integer{c1: var char;c2: var char;isEmpty: do ;   if (L1 = 0) :then ;      Beq := L1 <= L2;      leave(ma ...} 
 -- OG:super:  "matchEq: {   inx: var integer;   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := L1 <= L2;         leave(matchEq);      i ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "matchEq" 
 -- super:  "matchEq" 
 -- E:  "matchEq" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "matchEq" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  19 2 %basic 103 
 -- OG:super:  "leave(V: var integer): {   %basic 103}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "leave(matchEq)" 
 -- super:  "leave(matchEq)" 
 -- E:  "leave(matchEq)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "leave(matchEq)" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 66 "Beq := c1 < c2{leave(matchEq)}" 
 -- IS.newDescNo: 66 IS.objSize: 1 "Beq := c1 < c2{leave(matchEq)}" 
 -- OG:Qalloc:end: IS.newDescNo:  66 "Beq := c1 < c2{   leave(matchEq)}" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- super:  "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- E:  "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 64 "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- IS.newDescNo: 64 IS.objSize: 1 "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- OG:Qalloc:end: IS.newDescNo:  64 "if (c1 = c2) :then {      -- we have inx = LBeq := L1 <= L2;      leave(matchEq);   :else ;      Beq := c1 < c2;      leave(matchEq)}" 
 -- ObjTmpStack:add: "doit" : "if (c1 = c2) :then {      -- we have inx = LBeq := L1 <= L2;      leave(matchEq);   :else ;      Beq := c1 < c2;      leave(matchEq)}" 
 -- items:markForCodeGen: "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- markItem: "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" ObjectGenerator 
 -- OG:markForCodeGen: "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" true 
 -- 
 -- OG:markSuper: "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- Invocation:markForCodeGen: "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- OG:markForCodeGen: "(c1 = c2)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(c1 = c2)" 
 -- "(c1 = c2)" true 
 -- 
 -- OG:markSuper: "(c1 = c2)" 
 -- Invocation:markForCodeGen: "(c1 = c2)" 
 -- Invocation:markForCodeGen: "c1 = c2" 
 -- BinaryExp:markForCodeGen: "c1 = c2" 
 -- Invocation:markForCodeGen: "c1" 
 -- ObjectInvocation:markForCodeGen: "c1"  ATd: "c1: var char" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "= c2"  ATd: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OI:args:markForCodgen: "c2" 
 -- OG:markForCodeGen: "c2" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "c2" 
 -- "c2" true 
 -- 
 -- not ObjDesc:  "(c1 = c2)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "-- we have inx = LBeq := L1 <= L2{   leave(matchEq)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "-- we have inx = LBeq := L1 <= L2{   leave(matchEq)}" 
 -- OG:Qalloc: "-- we have inx = LBeq := L1 <= L2{   leave(matchEq)}" qDescno:  65 
 -- ObjTmpStack:add: "-- we have inx = LBeq := L1 <= L2{   leave(matchEq)}" 
 -- items:markForCodeGen: "-- we have inx = LBeq := L1 <= L2{leave(matchEq)}" 
 -- markItem: "Beq := L1 <= L2" Assign 
 -- Invocation:markForCodeGen: "Beq" 
 -- ObjectInvocation:markForCodeGen: "Beq"  ATd: "out Beq: var boolean" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "L1 <= L2" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "L1 <= L2" 
 -- "L1 <= L2" true 
 -- 
 -- OG:markSuper: "L1 <= L2" 
 -- Invocation:markForCodeGen: "L1 <= L2" 
 -- BinaryExp:markForCodeGen: "L1 <= L2" 
 -- Invocation:markForCodeGen: "L1" 
 -- ObjectInvocation:markForCodeGen: "L1"  ATd: "L1: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "<= L2"  ATd: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- OI:args:markForCodgen: "L2" 
 -- OG:markForCodeGen: "L2" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "L2" 
 -- "L2" true 
 -- 
 -- not ObjDesc:  "L1 <= L2"  IS.isEmpty:  true 
 -- markItem: "leave(matchEq)" ObjectGenerator 
 -- OG:markForCodeGen: "Beq := c1 < c2{   leave(matchEq)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "Beq := c1 < c2{   leave(matchEq)}" 
 -- OG:Qalloc: "Beq := c1 < c2{   leave(matchEq)}" qDescno:  66 
 -- ObjTmpStack:add: "Beq := c1 < c2{   leave(matchEq)}" 
 -- items:markForCodeGen: "Beq := c1 < c2{leave(matchEq)}" 
 -- markItem: "Beq := c1 < c2" Assign 
 -- Invocation:markForCodeGen: "Beq" 
 -- ObjectInvocation:markForCodeGen: "Beq"  ATd: "out Beq: var boolean" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "c1 < c2" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "c1 < c2" 
 -- "c1 < c2" true 
 -- 
 -- OG:markSuper: "c1 < c2" 
 -- Invocation:markForCodeGen: "c1 < c2" 
 -- BinaryExp:markForCodeGen: "c1 < c2" 
 -- Invocation:markForCodeGen: "c1" 
 -- ObjectInvocation:markForCodeGen: "c1"  ATd: "c1: var char" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "< c2"  ATd: "<  : {   %basic 51;   in V: var char;   out B: var boolean}" 
 -- Pattern:markForCodeGen: "<  : {   %basic 51;   in V: var char;   out B: var boolean}" 
 -- items:markForCodeGen: "" 
 -- OI:args:markForCodgen: "c2" 
 -- OG:markForCodeGen: "c2" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "c2" 
 -- "c2" true 
 -- 
 -- not ObjDesc:  "c1 < c2"  IS.isEmpty:  true 
 -- markItem: "leave(matchEq)" ObjectGenerator 
 -- not ObjDesc:  "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "matchEq"  IS.isEmpty:  true 
 -- not ObjDesc:  "LIB.StringLib.String"  IS.isEmpty:  true 
 -- markItem: "%$E ")"" Property 
 -- OG:markForCodeGen: "inner(puttext)" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "inner(puttext)" 
 -- OG:Qalloc: "inner(puttext)" qDescno:  0 
 -- OG:Qalloc:A:  "puttext"  super:  ""  marked:  true "puttext(T: var LIB.StringLib.String):< {   inner(puttext)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(puttext)" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "puttext" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 68 IS.newDescNo: 68 objSize: 0 1: 1 "inner(puttext)" 
 -- Items:Qalloc:objSize: 0  newDescNo: 68 "inner(puttext)" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "%$B "("{T: var LIB.StringLib.String;%$E ")"}" 
 -- dataitem:qalloc: "T" isValue: false  isPrimitive: true  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "T: var LIB.StringLib.String" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "%$B "("{T: var LIB.StringLib.String;%$E ")"}" 
 -- OG:Qalloc: "inner(puttext)" qDescno:  0 
 -- OG:Qalloc:A:  "inner"  super:  "inner(puttext)"  marked:  false "inner(puttext)" super:  inner(puttext) 
 -- Invocation:Qalloc: "inner(puttext)" 
 -- ObjectInvocation:Qalloc: "inner(puttext)" 
 -- name: "inner" 
 -- Arguments "inner(puttext)" 
 -- OG:Qalloc: "puttext" qDescno:  0 
 -- OG:Qalloc:A:  "puttext"  super:  "puttext"  marked:  false "inner(puttext)" super:  puttext 
 -- Invocation:Qalloc: "puttext" 
 -- ObjectInvocation:Qalloc: "puttext" 
 -- name: "puttext" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  68 2 inner(puttext) 
 -- OG:super:  "puttext(T: var LIB.StringLib.String):< {   inner(puttext)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "puttext" 
 -- super:  "puttext" 
 -- E:  "puttext" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "puttext" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 %basic 101{in inner: ref Object} 
 -- OG:super:  "inner: {   %basic 101;   in inner: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(puttext)" 
 -- super:  "inner(puttext)" 
 -- E:  "inner(puttext)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(puttext)" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 68 "inner(puttext)" 
 -- IS.newDescNo: 68 IS.objSize: 2 "inner(puttext)" 
 -- OG:Qalloc:end: IS.newDescNo:  68 "inner(puttext)" 
 -- ObjTmpStack:add: "puttext(T: var LIB.StringLib.String)" : "inner(puttext)" 
 -- items:markForCodeGen: "inner(puttext)" 
 -- markItem: "inner(puttext)" ObjectGenerator 
 -- Pattern:markForCodeGen: "putint(V: var Integer):< {   inner(putint)}" 
 -- items:markForCodeGen: "%$B "("{V: var Integer;%$E ")"}" 
 -- markItem: "%$B "("" Property 
 -- DataItem:markForCodeGen: "V" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "Integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Integer" 
 -- "Integer" true 
 -- 
 -- OG:markSuper: "Integer" 
 -- Invocation:markForCodeGen: "Integer" 
 -- ObjectInvocation:markForCodeGen: "Integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Integer"  IS.isEmpty:  true 
 -- markItem: "%$E ")"" Property 
 -- OG:markForCodeGen: "inner(putint)" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "inner(putint)" 
 -- OG:Qalloc: "inner(putint)" qDescno:  0 
 -- OG:Qalloc:A:  "putint"  super:  ""  marked:  true "putint(V: var Integer):< {   inner(putint)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(putint)" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "putint" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 69 IS.newDescNo: 69 objSize: 0 1: 1 "inner(putint)" 
 -- Items:Qalloc:objSize: 0  newDescNo: 69 "inner(putint)" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "%$B "("{V: var Integer;%$E ")"}" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "%$B "("{V: var Integer;%$E ")"}" 
 -- OG:Qalloc: "inner(putint)" qDescno:  0 
 -- OG:Qalloc:A:  "inner"  super:  "inner(putint)"  marked:  false "inner(putint)" super:  inner(putint) 
 -- Invocation:Qalloc: "inner(putint)" 
 -- ObjectInvocation:Qalloc: "inner(putint)" 
 -- name: "inner" 
 -- Arguments "inner(putint)" 
 -- OG:Qalloc: "putint" qDescno:  0 
 -- OG:Qalloc:A:  "putint"  super:  "putint"  marked:  false "inner(putint)" super:  putint 
 -- Invocation:Qalloc: "putint" 
 -- ObjectInvocation:Qalloc: "putint" 
 -- name: "putint" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  69 2 inner(putint) 
 -- OG:super:  "putint(V: var Integer):< {   inner(putint)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "putint" 
 -- super:  "putint" 
 -- E:  "putint" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "putint" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 %basic 101{in inner: ref Object} 
 -- OG:super:  "inner: {   %basic 101;   in inner: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(putint)" 
 -- super:  "inner(putint)" 
 -- E:  "inner(putint)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(putint)" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 69 "inner(putint)" 
 -- IS.newDescNo: 69 IS.objSize: 2 "inner(putint)" 
 -- OG:Qalloc:end: IS.newDescNo:  69 "inner(putint)" 
 -- ObjTmpStack:add: "putint(V: var Integer)" : "inner(putint)" 
 -- items:markForCodeGen: "inner(putint)" 
 -- markItem: "inner(putint)" ObjectGenerator 
 -- not ObjDesc:  "ConsoleIF"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "%id "workspace"{   %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib;   %domain_boundary;   --AbstractEx;--AccessEx;--ApplyPred;--ArduinoE ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%id "workspace"{   %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib;   %domain_boundary;   --AbstractEx;--AccessEx;--ApplyPred;--ArduinoEx;--ArmB ...}" 
 -- OG:Qalloc: "%id "workspace"{   %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib;   %domain_boundary;   --AbstractEx;--AccessEx;--ApplyPred;--ArduinoEx;--ArmB ...}" q ... 0 
 -- OG:Qalloc:A:  "workspace"  super:  ""  marked:  true "workspace: obj {   %id "workspace";   %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib;   %domain_bound ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%id "workspace"{   %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib;   %domain_boundary;   --AbstractEx;--AccessEx;--ApplyPred;--ArduinoEx;--ArmBasicSys;--A ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "workspace" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 70 IS.newDescNo: 70 objSize: 0 1: 1 "%id "workspace"{%visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib;%domain_boundary;--AbstractE ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 70 "%id "workspace"{%visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib;%domain_boundary;--AbstractEx;--AccessEx;--ApplyPred ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- ModuleItem:Qalloc:  --AbstractEx{} 
 -- ModuleItem:Qalloc:  --AccessEx{} 
 -- ModuleItem:Qalloc:  --ApplyPred{} 
 -- ModuleItem:Qalloc:  --ArduinoEx{} 
 -- ModuleItem:Qalloc:  --ArmBasicSys{} 
 -- ModuleItem:Qalloc:  --ArmLed{} 
 -- ModuleItem:Qalloc:  --ArmMultiCore{} 
 -- ModuleItem:Qalloc:  --CAStest{} 
 -- ModuleItem:Qalloc:  --CAStestCore{} 
 -- ModuleItem:Qalloc:  --CoroutineEx{} 
 -- ModuleItem:Qalloc:  --CppEx{} 
 -- ModuleItem:Qalloc:  --DumpObjEx{} 
 -- ModuleItem:Qalloc:  --Errors{} 
 -- ModuleItem:Qalloc:  --FoolishUnitEx{} 
 -- ModuleItem:Qalloc:  --ForkGC{} 
 -- ModuleItem:Qalloc:  --FuncVirtExVclass{} 
 -- ModuleItem:Qalloc:  --FunctionalVirtEx{} 
 -- ModuleItem:Qalloc:  --Jurgen{} 
 -- ModuleItem:Qalloc:  --LLVMex{} 
 -- ModuleItem:Qalloc:  --ListLiteralEx{} 
 -- ModuleItem:Qalloc:  --LockTestCore{} 
 -- ModuleItem:Qalloc:  --MVRsystem{} 
 -- ModuleItem:Qalloc:  --MapEx{} 
 -- ModuleItem:Qalloc:  --MiniVal{} 
 -- ModuleItem:Qalloc:  --NewInner{} 
 -- ModuleItem:Qalloc:  --NewSyntax{} 
 -- ModuleItem:Qalloc:  --NoneEx{} 
 -- ModuleItem:Qalloc:  --ObjectAndValues{} 
 -- ModuleItem:Qalloc:  --ReadersSingleWriter{} 
 -- ModuleItem:Qalloc:  --RemoteSuperVC{} 
 -- ModuleItem:Qalloc:  --Restrictions{} 
 -- ModuleItem:Qalloc:  --SlideEx{} 
 -- ModuleItem:Qalloc:  --Sub1{} 
 -- ModuleItem:Qalloc:  --TST{} 
 -- ModuleItem:Qalloc:  --TstBreak{} 
 -- ModuleItem:Qalloc:  --UnitIssues{} 
 -- ModuleItem:Qalloc:  --UnitKindEx{} 
 -- ModuleItem:Qalloc:  --UnitTest{} 
 -- ModuleItem:Qalloc:  --ValueArray{} 
 -- ModuleItem:Qalloc:  --ValueConv{} 
 -- ModuleItem:Qalloc:  --ValueEx{} 
 -- ModuleItem:Qalloc:  --ValueItemEx{} 
 -- ModuleItem:Qalloc:  --ValueTypes{} 
 -- ModuleItem:Qalloc:  --VirtError{} 
 -- ModuleItem:Qalloc:  --VirtualEx{} 
 -- ModuleItem:Qalloc:  --Visibility{} 
 -- ModuleItem:Qalloc:  --demo{} 
 -- Qalloc:module: demo 
 -- Module:alloc:off: 2 demo: obj {   %id "demo";   --AnimalMonitorSystem;--ArrayDemos;--Bank;--BasicValueSub;--BinTreeMerge;--Break;--COSex;--ChemicalPlantSystem;--CoArg;--Co ...} 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- ModuleItem:Qalloc:  --embodyex{} 
 -- ModuleItem:Qalloc:  --hello{} 
 -- ModuleItem:Qalloc:  --qbetaCmp{} 
 -- ModuleItem:Qalloc:  --test{} 
 -- ModuleItem:Qalloc:  --tiny{} 
 -- ModuleItem:Qalloc:  --tinyA{} 
 -- ModuleItem:Qalloc:  --tinyAA{} 
 -- ModuleItem:Qalloc:  --tinyAB{} 
 -- ModuleItem:Qalloc:  --tinyAC{} 
 -- ModuleItem:Qalloc:  --tinyB{} 
 -- ModuleItem:Qalloc:  --tinyC{} 
 -- ModuleItem:Qalloc:  --tinyD{} 
 -- ModuleItem:Qalloc:  --tinyE{} 
 -- ModuleItem:Qalloc:  --tinyF{} 
 -- ModuleItem:Qalloc:  --tinyG{} 
 -- ModuleItem:Qalloc:  --tinyH{} 
 -- ModuleItem:Qalloc:  --tinyI{} 
 -- ModuleItem:Qalloc:  --tinyJ{} 
 -- ModuleItem:Qalloc:  --tinyP{} 
 -- ModuleItem:Qalloc:  --tinyQ{} 
 -- ModuleItem:Qalloc:  --tinyR{} 
 -- ModuleItem:Qalloc:  --tinyS{} 
 -- ModuleItem:Qalloc:  --tinyV{} 
 -- ModuleItem:Qalloc:  --tinyW{} 
 -- ModuleItem:Qalloc:  --tinyX{} 
 -- ModuleItem:Qalloc:  --tinyY{} 
 -- ModuleItem:Qalloc:  --tinyZ{} 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 70 "%id "workspace"{%visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib;%domain_boundary;--AbstractEx;--AccessEx;--Apply ...}" 
 -- IS.newDescNo: 70 IS.objSize: 2 "%id "workspace"{%visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib;%domain_boundary;--AbstractEx;--AccessEx;--ApplyPred;--Ardui ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  70 "%id "workspace"{   %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib;   %domain_boundary;   --AbstractEx;--AccessEx;--ApplyP ...}" 
 -- ObjTmpStack:add: "workspace" : "%id "workspace"{   %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib;   %domain_boundary;   --AbstractEx;--AccessEx;--ApplyPre ...}" 
 -- items:markForCodeGen: "%id "workspace"{%visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib;%domain_boundary;--AbstractEx;--AccessEx;--ApplyPred;--ArduinoEx;--Ar ...}" 
 -- markItem: "%id "workspace"" Property 
 -- markItem: "%visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib" Property 
 -- markItem: "%domain_boundary" Property 
 -- OG:markForCodeGen: "%id "demo"{   --AnimalMonitorSystem;--ArrayDemos;--Bank;--BasicValueSub;--BinTreeMerge;--Break;--COSex;--ChemicalPlantSystem;--CoArg;--CollectionEx;--C ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%id "demo"{   --AnimalMonitorSystem;--ArrayDemos;--Bank;--BasicValueSub;--BinTreeMerge;--Break;--COSex;--ChemicalPlantSystem;--CoArg;--CollectionEx;--ComplexEx ...}" 
 -- OG:Qalloc: "%id "demo"{   --AnimalMonitorSystem;--ArrayDemos;--Bank;--BasicValueSub;--BinTreeMerge;--Break;--COSex;--ChemicalPlantSystem;--CoArg;--CollectionEx;--ComplexEx ...}" q ... 0 
 -- OG:Qalloc:A:  "demo"  super:  ""  marked:  true "demo: obj {   %id "demo";   --AnimalMonitorSystem;--ArrayDemos;--Bank;--BasicValueSub;--BinTreeMerge;--Break;--COSex;--Che ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%id "demo"{   --AnimalMonitorSystem;--ArrayDemos;--Bank;--BasicValueSub;--BinTreeMerge;--Break;--COSex;--ChemicalPlantSystem;--CoArg;--CollectionEx;--ComplexEx;--Factoria ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "demo" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 71 IS.newDescNo: 71 objSize: 0 1: 1 "%id "demo"{--AnimalMonitorSystem;--ArrayDemos;--Bank;--BasicValueSub;--BinTreeMerge;--Break;--COSex;--Chemi ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 71 "%id "demo"{--AnimalMonitorSystem;--ArrayDemos;--Bank;--BasicValueSub;--BinTreeMerge;--Break;--COSex;--ChemicalPlantSystem;--CoArg;- ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- ModuleItem:Qalloc:  --AnimalMonitorSystem{} 
 -- ModuleItem:Qalloc:  --ArrayDemos{} 
 -- ModuleItem:Qalloc:  --Bank{} 
 -- ModuleItem:Qalloc:  --BasicValueSub{} 
 -- ModuleItem:Qalloc:  --BinTreeMerge{} 
 -- ModuleItem:Qalloc:  --Break{} 
 -- ModuleItem:Qalloc:  --COSex{} 
 -- ModuleItem:Qalloc:  --ChemicalPlantSystem{} 
 -- ModuleItem:Qalloc:  --CoArg{} 
 -- ModuleItem:Qalloc:  --CollectionEx{} 
 -- ModuleItem:Qalloc:  --ComplexEx{} 
 -- ModuleItem:Qalloc:  --FactorialEx{} 
 -- ModuleItem:Qalloc:  --FileDemo{} 
 -- ModuleItem:Qalloc:  --ForkJoinEx{} 
 -- ModuleItem:Qalloc:  --Formater{} 
 -- ModuleItem:Qalloc:  --ISoLA2022{} 
 -- ModuleItem:Qalloc:  --KBprocess{} 
 -- ModuleItem:Qalloc:  --LibraEx{} 
 -- ModuleItem:Qalloc:  --MixedScheduling{} 
 -- ModuleItem:Qalloc:  --MonitorDemo{} 
 -- Qalloc:module: MonitorDemo 
 -- Module:alloc:off: 2 MonitorDemo: obj LIB.MonitorSystemLib.MonitorSystem{   %requires MonitorSystemLib;   %include LIB.StringLib;   P1: obj MonitorProcess("PP1");      fac( ...} 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- ModuleItem:Qalloc:  --NonBlockingIOex{} 
 -- ModuleItem:Qalloc:  --NullList{} 
 -- ModuleItem:Qalloc:  --PointEx{} 
 -- ModuleItem:Qalloc:  --Robots{} 
 -- ModuleItem:Qalloc:  --SCPex{} 
 -- ModuleItem:Qalloc:  --SimpleEx{} 
 -- ModuleItem:Qalloc:  --SimpleThreadEx{} 
 -- ModuleItem:Qalloc:  --SocketEx{} 
 -- ModuleItem:Qalloc:  --Static{} 
 -- ModuleItem:Qalloc:  --TempEx{} 
 -- ModuleItem:Qalloc:  --ToyCar{} 
 -- ModuleItem:Qalloc:  --UnitEx{} 
 -- ModuleItem:Qalloc:  --Units{} 
 -- ModuleItem:Qalloc:  --ValueDemo{} 
 -- ModuleItem:Qalloc:  --localsEx{} 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 71 "%id "demo"{--AnimalMonitorSystem;--ArrayDemos;--Bank;--BasicValueSub;--BinTreeMerge;--Break;--COSex;--ChemicalPlantSystem;--CoA ...}" 
 -- IS.newDescNo: 71 IS.objSize: 2 "%id "demo"{--AnimalMonitorSystem;--ArrayDemos;--Bank;--BasicValueSub;--BinTreeMerge;--Break;--COSex;--ChemicalPlantSystem;--CoArg;--Collect ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  71 "%id "demo"{   --AnimalMonitorSystem;--ArrayDemos;--Bank;--BasicValueSub;--BinTreeMerge;--Break;--COSex;--ChemicalPlantSystem;--CoArg;--Co ...}" 
 -- ObjTmpStack:add: "demo" : "%id "demo"{   --AnimalMonitorSystem;--ArrayDemos;--Bank;--BasicValueSub;--BinTreeMerge;--Break;--COSex;--ChemicalPlantSystem;--CoArg;--Collectio ...}" 
 -- items:markForCodeGen: "%id "demo"{--AnimalMonitorSystem;--ArrayDemos;--Bank;--BasicValueSub;--BinTreeMerge;--Break;--COSex;--ChemicalPlantSystem;--CoArg;--CollectionEx;--C ...}" 
 -- markItem: "%id "demo"" Property 
 -- OG:markForCodeGen: "LIB.MonitorSystemLib.MonitorSystem{   %requires MonitorSystemLib;   %include LIB.StringLib;   P1: obj MonitorProcess("PP1");      fac(V: var integer):  ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "LIB.MonitorSystemLib.MonitorSystem" 
 -- "LIB" false 
 -- "MonitorSystemLib" false 
 -- "MonitorSystem" false 
 -- 
 -- OG:markSuper: "LIB.MonitorSystemLib.MonitorSystem" 
 -- Invocation:markForCodeGen: "LIB.MonitorSystemLib.MonitorSystem" 
 -- ObjectInvocation:markForCodeGen: "LIB"  ATd: "--LIB{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "MonitorSystemLib"  ATd: "--MonitorSystemLib{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "MonitorSystem"  ATd: "MonitorSystem: LIB.BasicSystemLib.BasicSystem{   %public;   MonitorProcess: BasicProcess;      %globals Monitor, Mo ...}" 
 -- Pattern:markForCodeGen: "MonitorSystem: LIB.BasicSystemLib.BasicSystem{   %public;   MonitorProcess: BasicProcess;      %globals Monitor, MonitorProcess(""), immutable, co ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "LIB.BasicSystemLib.BasicSystem{   %public;   MonitorProcess: BasicProcess;      %globals Monitor, MonitorProcess(""), immutable, console;      -- we ne ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "LIB.BasicSystemLib.BasicSystem" 
 -- "LIB" false 
 -- "BasicSystemLib" false 
 -- "BasicSystem" false 
 -- 
 -- OG:markSuper: "LIB.BasicSystemLib.BasicSystem" 
 -- Invocation:markForCodeGen: "LIB.BasicSystemLib.BasicSystem" 
 -- ObjectInvocation:markForCodeGen: "LIB"  ATd: "--LIB{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "BasicSystemLib"  ATd: "--BasicSystemLib{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "BasicSystem"  ATd: "BasicSystem: {   %public;   BasicProcess: GeneralProcess;      mkActive::< ;         -- start and mkActive are identi ...}" 
 -- Pattern:markForCodeGen: "BasicSystem: {   %public;   BasicProcess: GeneralProcess;      mkActive::< ;         -- start and mkActive are identical and one may be eliminated ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "%public{   BasicProcess: GeneralProcess;      mkActive::< ;         -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACT ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%public{   BasicProcess: GeneralProcess;      mkActive::< ;         -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;     ...}" 
 -- OG:Qalloc: "%public{   BasicProcess: GeneralProcess;      mkActive::< ;         -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;     ...}" q ... 0 
 -- OG:Qalloc:A:  "BasicSystem"  super:  ""  marked:  true "BasicSystem: {   %public;   BasicProcess: GeneralProcess;      mkActive::< ;         -- start and mkActive are iden ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%public{   BasicProcess: GeneralProcess;      mkActive::< ;         -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;         SQS.in ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "BasicSystem" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 72 IS.newDescNo: 72 objSize: 0 1: 1 "%public{BasicProcess: GeneralProcess;   mkActive::< ;      -- start and mkActive are identical and one may  ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 72 "%public{BasicProcess: GeneralProcess;   mkActive::< ;      -- start and mkActive are identical and one may be eliminatedstatus := p ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Pattern:Qalloc: BasicProcess 
 -- Pattern:Qalloc:B: BasicProcess 
 -- Pattern:Qalloc: Scheduler 
 -- Pattern:Qalloc:B: Scheduler 
 -- Pattern:Qalloc: Core 
 -- Pattern:Qalloc:B: Core 
 -- dataitem:qalloc: "noOfCores" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- dataitem:qalloc: "cores" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 3 "cores: obj {   C1: ref Core;   C2: ref Core;   C3: ref Core;   C4: ref Core;   -- should be array         ;   init: ;      S: ref Scheduler;      C1 := C ...}" 
 -- OG:Qalloc: "C1: ref Core{   C2: ref Core;   C3: ref Core;   C4: ref Core;   -- should be array         ;   init: ;      S: ref Scheduler;      C1 := Core;      fork(C1);   ...}" q ... 0 
 -- OG:Qalloc:A:  "cores"  super:  ""  marked:  false "cores: obj {   C1: ref Core;   C2: ref Core;   C3: ref Core;   C4: ref Core;   -- should be array         ;   init: ;    ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "C1: ref Core{   C2: ref Core;   C3: ref Core;   C4: ref Core;   -- should be array         ;   init: ;      S: ref Scheduler;      C1 := Core;      fork(C1);      C2 := C ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "cores" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 73 IS.newDescNo: 73 objSize: 0 1: 1 "C1: ref Core{C2: ref Core;C3: ref Core;C4: ref Core;-- should be array         ;init: ;   S: ref Scheduler; ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 73 "C1: ref Core{C2: ref Core;C3: ref Core;C4: ref Core;-- should be array         ;init: ;   S: ref Scheduler;   C1 := Core;   fork(C1 ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- dataitem:qalloc: "C1" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "C1: ref Core" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- dataitem:qalloc: "C2" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 3 "C2: ref Core" 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "C3" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 4 "C3: ref Core" 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- dataitem:qalloc: "C4" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 5 "C4: ref Core{-- should be array         }" 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Pattern:Qalloc: init 
 -- Pattern:Qalloc:B: init 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 73 "C1: ref Core{C2: ref Core;C3: ref Core;C4: ref Core;-- should be array         ;init: ;   S: ref Scheduler;   C1 := Core;   for ...}" 
 -- IS.newDescNo: 73 IS.objSize: 5 "C1: ref Core{C2: ref Core;C3: ref Core;C4: ref Core;-- should be array         ;init: ;   S: ref Scheduler;   C1 := Core;   fork(C1);   C2  ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  73 "C1: ref Core{   C2: ref Core;   C3: ref Core;   C4: ref Core;   -- should be array         ;   init: ;      S: ref Scheduler;      C1 :=  ...}" 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "P_status" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 4 "P_status: obj {   %globals;   %Public;   ACTIVE: val 1;   WAITING: val 2;   TERMINATED: val 3}" 
 -- OG:Qalloc: "%globals{   %Public;   ACTIVE: val 1;   WAITING: val 2;   TERMINATED: val 3}" qDescno:  0 
 -- OG:Qalloc:A:  "P_status"  super:  ""  marked:  false "P_status: obj {   %globals;   %Public;   ACTIVE: val 1;   WAITING: val 2;   TERMINATED: val 3}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%globals{   %Public;   ACTIVE: val 1;   WAITING: val 2;   TERMINATED: val 3}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "P_status" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 74 IS.newDescNo: 74 objSize: 0 1: 1 "%globals{%Public;ACTIVE: val 1;WAITING: val 2;TERMINATED: val 3}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 74 "%globals{%Public;ACTIVE: val 1;WAITING: val 2;TERMINATED: val 3}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- dataitem:qalloc: "ACTIVE" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- dataitem:qalloc: "WAITING" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "TERMINATED" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 74 "%globals{%Public;ACTIVE: val 1;WAITING: val 2;TERMINATED: val 3}" 
 -- IS.newDescNo: 74 IS.objSize: 4 "%globals{%Public;ACTIVE: val 1;WAITING: val 2;TERMINATED: val 3}" 
 -- OG:Qalloc:end: IS.newDescNo:  74 "%globals{   %Public;   ACTIVE: val 1;   WAITING: val 2;   TERMINATED: val 3}" 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- Pattern:Qalloc: ProcessQueue 
 -- Pattern:Qalloc:B: ProcessQueue 
 -- dataitem:qalloc: "sch" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 5 "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      entry;         M  ...}" 
 -- OG:Qalloc: "L: obj Lock("Sch:lock"){   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      entry;         M := M + 1;   dcr: ;  ...}" q ... 0 
 -- OG:Qalloc:A:  "sch"  super:  ""  marked:  false "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;  ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L: obj Lock("Sch:lock"){   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      entry;         M := M + 1;   dcr: ;      entry; ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "sch" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 75 IS.newDescNo: 75 objSize: 0 1: 1 "L: obj Lock("Sch:lock"){M: var integer;%Public;entry: ;   L.get;   inner(entry);   L.free;add: ;   entry;   ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 75 "L: obj Lock("Sch:lock"){M: var integer;%Public;entry: ;   L.get;   inner(entry);   L.free;add: ;   entry;      M := M + 1;dcr: ;    ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- dataitem:qalloc: "L" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "L: obj Lock("Sch:lock")" 
 -- OG:Qalloc: "Lock("Sch:lock")" qDescno:  0 
 -- OG:Qalloc:A:  "Lock"  super:  "Lock("Sch:lock")"  marked:  false "L: obj Lock("Sch:lock")" super:  Lock("Sch:lock") 
 -- Invocation:Qalloc: "Lock("Sch:lock")" 
 -- ObjectInvocation:Qalloc: "Lock("Sch:lock")" 
 -- name: "Lock" 
 -- Arguments "Lock("Sch:lock")" 
 -- OG:Qalloc: ""Sch:lock"" qDescno:  0 
 -- OG:Qalloc:A:  "String"  super:  ""Sch:lock""  marked:  false "Lock("Sch:lock")" super:  "Sch:lock" 
 -- Invocation:Qalloc: ""Sch:lock"" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  10 0 %id "String pattern"{%OSDvisibility disguised;%basic 5;%public;length: ;   out V: var integer;   V := get[0] -- ac ...} 
 -- OG:super:  "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- actually an  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""Sch:lock"" 
 -- super:  ""Sch:lock"" 
 -- E:  ""Sch:lock"" 
 -- OG:Qalloc:end: IS.newDescNo:  0 ""Sch:lock"" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %globals{%Public;in id: var String;%private;free_M: var integer;%public;init: ;   free_M := 0;get: ;   loop: obj ;  ...} 
 -- OG:Qalloc:SuperAlloc: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: ob ...}" 
 -- OG:Qalloc: "%globals{   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ;         res: var  ...}" q ... 0 
 -- OG:Qalloc:A:  "Lock"  super:  ""  marked:  false "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M : ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%globals{   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ;         res: var integer;    ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "Lock" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 76 IS.newDescNo: 76 objSize: 0 1: 1 "%globals{%Public;in id: var String;%private;free_M: var integer;%public;init: ;   free_M := 0;get: ;   loop ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 76 "%globals{%Public;in id: var String;%private;free_M: var integer;%public;init: ;   free_M := 0;get: ;   loop: obj ;      res: var in ...}" 
 -- Items:Qalloc:Super:C:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 "" 
 -- dataitem:qalloc: "id" isValue: false  isPrimitive: true  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 1 "in id: var String" 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "free_M" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Pattern:Qalloc: init 
 -- Pattern:Qalloc:B: init 
 -- Pattern:Qalloc: get 
 -- Pattern:Qalloc:B: get 
 -- Pattern:Qalloc: free 
 -- Pattern:Qalloc:B: free 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 76 "%globals{%Public;in id: var String;%private;free_M: var integer;%public;init: ;   free_M := 0;get: ;   loop: obj ;      res: va ...}" 
 -- IS.newDescNo: 76 IS.objSize: 2 "%globals{%Public;in id: var String;%private;free_M: var integer;%public;init: ;   free_M := 0;get: ;   loop: obj ;      res: var integer;   ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  76 "%globals{   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: o ...}" 
 -- OG:super:  "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ;         ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Lock("Sch:lock")" 
 -- super:  "Lock("Sch:lock")" 
 -- E:  "Lock("Sch:lock")" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Lock("Sch:lock")" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- dataitem:qalloc: "M" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- Pattern:Qalloc: entry 
 -- Pattern:Qalloc:B: entry 
 -- Pattern:Qalloc: add 
 -- Pattern:Qalloc:B: add 
 -- Pattern:Qalloc: dcr 
 -- Pattern:Qalloc:B: dcr 
 -- Pattern:Qalloc: running 
 -- Pattern:Qalloc:B: running 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 75 "L: obj Lock("Sch:lock"){M: var integer;%Public;entry: ;   L.get;   inner(entry);   L.free;add: ;   entry;      M := M + 1;dcr:  ...}" 
 -- IS.newDescNo: 75 IS.objSize: 3 "L: obj Lock("Sch:lock"){M: var integer;%Public;entry: ;   L.get;   inner(entry);   L.free;add: ;   entry;      M := M + 1;dcr: ;   entry;   ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  75 "L: obj Lock("Sch:lock"){   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      entry;         ...}" 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- dataitem:qalloc: "SQS" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 6 "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      ...}" 
 -- OG:Qalloc: "Q: obj ProcessQueue{   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if (V > 1) :then ; ...}" q ... 0 
 -- OG:Qalloc:A:  "SQS"  super:  ""  marked:  false "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;    ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Q: obj ProcessQueue{   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if (V > 1) :then ;         pu ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "SQS" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 77 IS.newDescNo: 77 objSize: 0 1: 1 "Q: obj ProcessQueue{L: obj Lock("SQS:Lock:");V: var integer;W: var integer;%Public;entry: ;   L.get;   V := ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 77 "Q: obj ProcessQueue{L: obj Lock("SQS:Lock:");V: var integer;W: var integer;%Public;entry: ;   L.get;   V := V + 1;   if (V > 1) :th ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- dataitem:qalloc: "Q" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "Q: obj ProcessQueue" 
 -- OG:Qalloc: "ProcessQueue" qDescno:  0 
 -- OG:Qalloc:A:  "ProcessQueue"  super:  "ProcessQueue"  marked:  false "Q: obj ProcessQueue" super:  ProcessQueue 
 -- Invocation:Qalloc: "ProcessQueue" 
 -- ObjectInvocation:Qalloc: "ProcessQueue" 
 -- name: "ProcessQueue" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %Public{displayx: ;   put('Q')} 
 -- OG:Qalloc:SuperAlloc: "ProcessQueue: LIB.Collections.QueueLib.Queue{   %Public;   displayx: ;      put('Q')}" 
 -- OG:Qalloc: "LIB.Collections.QueueLib.Queue{   %Public;   displayx: ;      put('Q')}" qDescno:  0 
 -- OG:Qalloc:A:  "ProcessQueue"  super:  "LIB.Collections.QueueLib.Queue"  marked:  false "ProcessQueue: LIB.Collections.QueueLib.Queue{   %Public;   displayx: ;      put('Q' ...}" s ... L ... 
 -- Invocation:Qalloc: "LIB.Collections.QueueLib.Queue" 
 -- ObjectInvocation:Qalloc: "LIB" 
 -- name: "LIB" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "Collections" 
 -- name: "Collections" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "QueueLib" 
 -- name: "QueueLib" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "Queue" 
 -- name: "Queue" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %globals{idf: var LIB.StringLib.String;idc: var integer;noOfElm: var integer;Element: ;   in elm: ref Object;   out ...} 
 -- OG:Qalloc:SuperAlloc: "Queue: {   %globals;   idf: var LIB.StringLib.String;   idc: var integer;   noOfElm: var integer;   Element: ;      in elm: ref Object;      out res ...}" 
 -- OG:Qalloc: "%globals{   idf: var LIB.StringLib.String;   idc: var integer;   noOfElm: var integer;   Element: ;      in elm: ref Object;      out res: ref Element;      id ...}" q ... 0 
 -- OG:Qalloc:A:  "Queue"  super:  ""  marked:  false "Queue: {   %globals;   idf: var LIB.StringLib.String;   idc: var integer;   noOfElm: var integer;   Element: ;      in e ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%globals{   idf: var LIB.StringLib.String;   idc: var integer;   noOfElm: var integer;   Element: ;      in elm: ref Object;      out res: ref Element;      id: var integ ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "Queue" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 78 IS.newDescNo: 78 objSize: 0 1: 1 "%globals{idf: var LIB.StringLib.String;idc: var integer;noOfElm: var integer;Element: ;   in elm: ref Objec ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 78 "%globals{idf: var LIB.StringLib.String;idc: var integer;noOfElm: var integer;Element: ;   in elm: ref Object;   out res: ref Elemen ...}" 
 -- Items:Qalloc:Super:C:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 "" 
 -- dataitem:qalloc: "idf" isValue: false  isPrimitive: true  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 1 "idf: var LIB.StringLib.String" 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "idc" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- dataitem:qalloc: "noOfElm" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- Pattern:Qalloc: Element 
 -- Pattern:Qalloc:B: Element 
 -- dataitem:qalloc: "head" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 4 "head: ref Element" 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- dataitem:qalloc: "last" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 5 "last: ref Element" 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Pattern:Qalloc: has 
 -- Pattern:Qalloc:B: has 
 -- Pattern:Qalloc: scan 
 -- Pattern:Qalloc:B: scan 
 -- Pattern:Qalloc: scanFromLast 
 -- Pattern:Qalloc:B: scanFromLast 
 -- Pattern:Qalloc: insert 
 -- Pattern:Qalloc:B: insert 
 -- Pattern:Qalloc: remove 
 -- Pattern:Qalloc:B: remove 
 -- Pattern:Qalloc: removeNext 
 -- Pattern:Qalloc:B: removeNext 
 -- Pattern:Qalloc: isEmpty 
 -- Pattern:Qalloc:B: isEmpty 
 -- Pattern:Qalloc: clear 
 -- Pattern:Qalloc:B: clear 
 -- Pattern:Qalloc: display 
 -- Pattern:Qalloc:B: display 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 78 "%globals{idf: var LIB.StringLib.String;idc: var integer;noOfElm: var integer;Element: ;   in elm: ref Object;   out res: ref El ...}" 
 -- IS.newDescNo: 78 IS.objSize: 5 "%globals{idf: var LIB.StringLib.String;idc: var integer;noOfElm: var integer;Element: ;   in elm: ref Object;   out res: ref Element;   id: ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  78 "%globals{   idf: var LIB.StringLib.String;   idc: var integer;   noOfElm: var integer;   Element: ;      in elm: ref Object;      out res ...}" 
 -- OG:super:  "Queue: {   %globals;   idf: var LIB.StringLib.String;   idc: var integer;   noOfElm: var integer;   Element: ;      in elm: ref Object;      out res: ref Eleme ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "LIB.Collections.QueueLib.Queue{   %Public;   displayx: ;      put('Q')}" 
 -- super:  "LIB.Collections.QueueLib.Queue" 
 -- E:  "Queue" 
 -- OG:Qalloc:B: "ProcessQueue" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 79 IS.newDescNo: 79 objSize: 0 1: 1 "%Public{displayx: ;   put('Q')}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 79 "%Public{displayx: ;   put('Q')}" 
 -- Items:Qalloc:super: "LIB.Collections.QueueLib.Queue" size: 5 "ProcessQueue" 
 -- super.isThisBlockLevel: false superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 5 originOff: 0 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Pattern:Qalloc: displayx 
 -- Pattern:Qalloc:B: displayx 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 79 "%Public{displayx: ;   put('Q')}" 
 -- IS.newDescNo: 79 IS.objSize: 5 "%Public{displayx: ;   put('Q')}" 
 -- OG:Qalloc:end: IS.newDescNo:  79 "LIB.Collections.QueueLib.Queue{   %Public;   displayx: ;      put('Q')}" 
 -- OG:super:  "ProcessQueue: LIB.Collections.QueueLib.Queue{   %Public;   displayx: ;      put('Q')}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "ProcessQueue" 
 -- super:  "ProcessQueue" 
 -- E:  "ProcessQueue" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "ProcessQueue" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- dataitem:qalloc: "L" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 3 "L: obj Lock("SQS:Lock:")" 
 -- OG:Qalloc: "Lock("SQS:Lock:")" qDescno:  0 
 -- OG:Qalloc:A:  "Lock"  super:  "Lock("SQS:Lock:")"  marked:  false "L: obj Lock("SQS:Lock:")" super:  Lock("SQS:Lock:") 
 -- Invocation:Qalloc: "Lock("SQS:Lock:")" 
 -- ObjectInvocation:Qalloc: "Lock("SQS:Lock:")" 
 -- name: "Lock" 
 -- Arguments "Lock("SQS:Lock:")" 
 -- OG:Qalloc: ""SQS:Lock:"" qDescno:  0 
 -- OG:Qalloc:A:  "String"  super:  ""SQS:Lock:""  marked:  false "Lock("SQS:Lock:")" super:  "SQS:Lock:" 
 -- Invocation:Qalloc: ""SQS:Lock:"" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  10 0 %id "String pattern"{%OSDvisibility disguised;%basic 5;%public;length: ;   out V: var integer;   V := get[0] -- ac ...} 
 -- OG:super:  "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- actually an  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""SQS:Lock:"" 
 -- super:  ""SQS:Lock:"" 
 -- E:  ""SQS:Lock:"" 
 -- OG:Qalloc:end: IS.newDescNo:  0 ""SQS:Lock:"" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  76 2 %globals{%Public;in id: var String;%private;free_M: var integer;%public;init: ;   free_M := 0;get: ;   loop: obj ; ...} 
 -- OG:super:  "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ;         ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Lock("SQS:Lock:")" 
 -- super:  "Lock("SQS:Lock:")" 
 -- E:  "Lock("SQS:Lock:")" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Lock("SQS:Lock:")" 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- dataitem:qalloc: "W" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Pattern:Qalloc: entry 
 -- Pattern:Qalloc:B: entry 
 -- Pattern:Qalloc: init 
 -- Pattern:Qalloc:B: init 
 -- Pattern:Qalloc: insert 
 -- Pattern:Qalloc:B: insert 
 -- Pattern:Qalloc: removeNext 
 -- Pattern:Qalloc:B: removeNext 
 -- Pattern:Qalloc: remove 
 -- Pattern:Qalloc:B: remove 
 -- Pattern:Qalloc: isEmpty 
 -- Pattern:Qalloc:B: isEmpty 
 -- Pattern:Qalloc: display 
 -- Pattern:Qalloc:B: display 
 -- Pattern:Qalloc: addWaiting 
 -- Pattern:Qalloc:B: addWaiting 
 -- Pattern:Qalloc: dcrWaiting 
 -- Pattern:Qalloc:B: dcrWaiting 
 -- Pattern:Qalloc: hasWaiting 
 -- Pattern:Qalloc:B: hasWaiting 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 77 "Q: obj ProcessQueue{L: obj Lock("SQS:Lock:");V: var integer;W: var integer;%Public;entry: ;   L.get;   V := V + 1;   if (V > 1) ...}" 
 -- IS.newDescNo: 77 IS.objSize: 5 "Q: obj ProcessQueue{L: obj Lock("SQS:Lock:");V: var integer;W: var integer;%Public;entry: ;   L.get;   V := V + 1;   if (V > 1) :then ;     ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  77 "Q: obj ProcessQueue{   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;   ...}" 
 -- Items:Qalloc:objSize: 6  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 6  newDescNo: 0 "" 
 -- dataitem:qalloc: "coreLock" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 7 "coreLock: obj Lock("CoreLock")" 
 -- OG:Qalloc: "Lock("CoreLock")" qDescno:  0 
 -- OG:Qalloc:A:  "Lock"  super:  "Lock("CoreLock")"  marked:  false "coreLock: obj Lock("CoreLock")" super:  Lock("CoreLock") 
 -- Invocation:Qalloc: "Lock("CoreLock")" 
 -- ObjectInvocation:Qalloc: "Lock("CoreLock")" 
 -- name: "Lock" 
 -- Arguments "Lock("CoreLock")" 
 -- OG:Qalloc: ""CoreLock"" qDescno:  0 
 -- OG:Qalloc:A:  "String"  super:  ""CoreLock""  marked:  false "Lock("CoreLock")" super:  "CoreLock" 
 -- Invocation:Qalloc: ""CoreLock"" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  10 0 %id "String pattern"{%OSDvisibility disguised;%basic 5;%public;length: ;   out V: var integer;   V := get[0] -- ac ...} 
 -- OG:super:  "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- actually an  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""CoreLock"" 
 -- super:  ""CoreLock"" 
 -- E:  ""CoreLock"" 
 -- OG:Qalloc:end: IS.newDescNo:  0 ""CoreLock"" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  76 2 %globals{%Public;in id: var String;%private;free_M: var integer;%public;init: ;   free_M := 0;get: ;   loop: obj ; ...} 
 -- OG:super:  "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ;         ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Lock("CoreLock")" 
 -- super:  "Lock("CoreLock")" 
 -- E:  "Lock("CoreLock")" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Lock("CoreLock")" 
 -- Items:Qalloc:objSize: 7  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 7  newDescNo: 0 "" 
 -- dataitem:qalloc: "console" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 8 "console: obj {   L: obj Lock("Console:lock");   %public;   display: ;      L.get;      inner(display);      L.free;   L.init}" 
 -- OG:Qalloc: "L: obj Lock("Console:lock"){   %public;   display: ;      L.get;      inner(display);      L.free;   L.init}" qDescno:  0 
 -- OG:Qalloc:A:  "console"  super:  ""  marked:  false "console: obj {   L: obj Lock("Console:lock");   %public;   display: ;      L.get;      inner(display);      L.free;    ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L: obj Lock("Console:lock"){   %public;   display: ;      L.get;      inner(display);      L.free;   L.init}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "console" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 80 IS.newDescNo: 80 objSize: 0 1: 1 "L: obj Lock("Console:lock"){%public;display: ;   L.get;   inner(display);   L.free;L.init}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 80 "L: obj Lock("Console:lock"){%public;display: ;   L.get;   inner(display);   L.free;L.init}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- dataitem:qalloc: "L" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "L: obj Lock("Console:lock")" 
 -- OG:Qalloc: "Lock("Console:lock")" qDescno:  0 
 -- OG:Qalloc:A:  "Lock"  super:  "Lock("Console:lock")"  marked:  false "L: obj Lock("Console:lock")" super:  Lock("Console:lock") 
 -- Invocation:Qalloc: "Lock("Console:lock")" 
 -- ObjectInvocation:Qalloc: "Lock("Console:lock")" 
 -- name: "Lock" 
 -- Arguments "Lock("Console:lock")" 
 -- OG:Qalloc: ""Console:lock"" qDescno:  0 
 -- OG:Qalloc:A:  "String"  super:  ""Console:lock""  marked:  false "Lock("Console:lock")" super:  "Console:lock" 
 -- Invocation:Qalloc: ""Console:lock"" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  10 0 %id "String pattern"{%OSDvisibility disguised;%basic 5;%public;length: ;   out V: var integer;   V := get[0] -- ac ...} 
 -- OG:super:  "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- actually an  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""Console:lock"" 
 -- super:  ""Console:lock"" 
 -- E:  ""Console:lock"" 
 -- OG:Qalloc:end: IS.newDescNo:  0 ""Console:lock"" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  76 2 %globals{%Public;in id: var String;%private;free_M: var integer;%public;init: ;   free_M := 0;get: ;   loop: obj ; ...} 
 -- OG:super:  "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ;         ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Lock("Console:lock")" 
 -- super:  "Lock("Console:lock")" 
 -- E:  "Lock("Console:lock")" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Lock("Console:lock")" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Pattern:Qalloc: display 
 -- Pattern:Qalloc:B: display 
 -- OG:Qalloc: "L.init" qDescno:  0 
 -- OG:Qalloc:A:  "init"  super:  "L.init"  marked:  false "L: obj Lock("Console:lock"){%public;display: ;   L.get;   inner(display);   L.free;L.init}" super:  L.init 
 -- Invocation:Qalloc: "L.init" 
 -- ObjectInvocation:Qalloc: "L" 
 -- name: "L" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "init" 
 -- name: "init" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 free_M := 0 
 -- OG:Qalloc:SuperAlloc: "init: {   free_M := 0}" 
 -- OG:Qalloc: "free_M := 0" qDescno:  0 
 -- OG:Qalloc:A:  "init"  super:  ""  marked:  false "init: {   free_M := 0}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "free_M := 0" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "init" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 81 IS.newDescNo: 81 objSize: 0 1: 1 "free_M := 0" 
 -- Items:Qalloc:objSize: 0  newDescNo: 81 "free_M := 0" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Invocation:Qalloc: "free_M" 
 -- ObjectInvocation:Qalloc: "free_M" 
 -- name: "free_M" 
 -- Arguments "" 
 -- OG:Qalloc: "0" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "0"  marked:  false "free_M := 0" super:  0 
 -- Invocation:Qalloc: "0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "0" 
 -- super:  "0" 
 -- E:  "0" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "0" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 81 "free_M := 0" 
 -- IS.newDescNo: 81 IS.objSize: 1 "free_M := 0" 
 -- OG:Qalloc:end: IS.newDescNo:  81 "free_M := 0" 
 -- OG:super:  "init: {   free_M := 0}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L.init" 
 -- super:  "L.init" 
 -- E:  "init" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L.init" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 80 "L: obj Lock("Console:lock"){%public;display: ;   L.get;   inner(display);   L.free;L.init}" 
 -- IS.newDescNo: 80 IS.objSize: 2 "L: obj Lock("Console:lock"){%public;display: ;   L.get;   inner(display);   L.free;L.init}" 
 -- OG:Qalloc:end: IS.newDescNo:  80 "L: obj Lock("Console:lock"){   %public;   display: ;      L.get;      inner(display);      L.free;   L.init}" 
 -- Items:Qalloc:objSize: 8  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 8  newDescNo: 0 "" 
 -- dataitem:qalloc: "keyboard" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 9 "keyboard: obj BasicProcess("Keyboard"){   B: obj Indexed(100,integer);   next: var integer;   top: var integer;   echo: var Boolean;   %Public;   Kscan:  ...}" 
 -- OG:Qalloc: "BasicProcess("Keyboard"){   B: obj Indexed(100,integer);   next: var integer;   top: var integer;   echo: var Boolean;   %Public;   Kscan: ;      loopB: obj ;  ...}" q ... 0 
 -- OG:Qalloc:A:  "keyboard"  super:  "BasicProcess("Keyboard")"  marked:  false "keyboard: obj BasicProcess("Keyboard"){   B: obj Indexed(100,integer);   next: var integer;   ...}" s ... B ... 
 -- Invocation:Qalloc: "BasicProcess("Keyboard")" 
 -- ObjectInvocation:Qalloc: "BasicProcess("Keyboard")" 
 -- name: "BasicProcess" 
 -- Arguments "BasicProcess("Keyboard")" 
 -- OG:Qalloc: ""Keyboard"" qDescno:  0 
 -- OG:Qalloc:A:  "String"  super:  ""Keyboard""  marked:  false "BasicProcess("Keyboard")" super:  "Keyboard" 
 -- Invocation:Qalloc: ""Keyboard"" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  10 0 %id "String pattern"{%OSDvisibility disguised;%basic 5;%public;length: ;   out V: var integer;   V := get[0] -- ac ...} 
 -- OG:super:  "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- actually an  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""Keyboard"" 
 -- super:  ""Keyboard"" 
 -- E:  ""Keyboard"" 
 -- OG:Qalloc:end: IS.newDescNo:  0 ""Keyboard"" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 mkActive::< {   -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;   SQS.inser ...} 
 -- OG:Qalloc:SuperAlloc: "BasicProcess: GeneralProcess{   mkActive::< ;      -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;      SQS. ...}" 
 -- OG:Qalloc: "GeneralProcess{   mkActive::< ;      -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;      SQS.insert(this(BasicProcess) ...}" q ... 0 
 -- OG:Qalloc:A:  "BasicProcess"  super:  "GeneralProcess"  marked:  false "BasicProcess: GeneralProcess{   mkActive::< ;      -- start and mkActive are identical and one may  ...}" s ... G ... 
 -- Invocation:Qalloc: "GeneralProcess" 
 -- ObjectInvocation:Qalloc: "GeneralProcess" 
 -- name: "GeneralProcess" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 start:< {   inner(start);mkActive:< ;   inner(mkActive);addWaiting:< ;   --put('q')inner(addWaiting);   --put('R'); ...} 
 -- OG:Qalloc:SuperAlloc: "GeneralProcess(id: var LIB.StringLib.String): {   start:< ;      inner(start);   mkActive:< ;      inner(mkActive);   addWaiting:< ;      --put('q') ...}" 
 -- OG:Qalloc: "start:< {      inner(start);   mkActive:< ;      inner(mkActive);   addWaiting:< ;      --put('q')inner(addWaiting);      --put('R');   dcrWaiting:< ;      inn ...}" q ... 0 
 -- OG:Qalloc:A:  "GeneralProcess"  super:  ""  marked:  false "GeneralProcess(id: var LIB.StringLib.String): {   start:< ;      inner(start);   mkActive:< ;      inner(mkActi ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "start:< {      inner(start);   mkActive:< ;      inner(mkActive);   addWaiting:< ;      --put('q')inner(addWaiting);      --put('R');   dcrWaiting:< ;      inner(dcrWaiti ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "GeneralProcess" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 82 IS.newDescNo: 82 objSize: 0 1: 1 "start:< {   inner(start);mkActive:< ;   inner(mkActive);addWaiting:< ;   --put('q')inner(addWaiting);   --p ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 82 "start:< {   inner(start);mkActive:< ;   inner(mkActive);addWaiting:< ;   --put('q')inner(addWaiting);   --put('R');dcrWaiting:< ;   ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "%$B "("{id: var LIB.StringLib.String;%$E ")"}" 
 -- dataitem:qalloc: "id" isValue: false  isPrimitive: true  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "id: var LIB.StringLib.String" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "%$B "("{id: var LIB.StringLib.String;%$E ")"}" 
 -- Pattern:Qalloc: start 
 -- Pattern:Qalloc:B: start 
 -- Pattern:Qalloc: mkActive 
 -- Pattern:Qalloc:B: mkActive 
 -- Pattern:Qalloc: addWaiting 
 -- Pattern:Qalloc:B: addWaiting 
 -- Pattern:Qalloc: dcrWaiting 
 -- Pattern:Qalloc:B: dcrWaiting 
 -- Pattern:Qalloc: display 
 -- Pattern:Qalloc:B: display 
 -- dataitem:qalloc: "status" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- OG:Qalloc: "inner(GeneralProcess)" qDescno:  0 
 -- OG:Qalloc:A:  "inner"  super:  "inner(GeneralProcess)"  marked:  false "start:< {   inner(start);mkActive:< ;   inner(mkActive);addWaiting:< ;   --put('q')inner(addWaiting ...}" s ... i ... 
 -- Invocation:Qalloc: "inner(GeneralProcess)" 
 -- ObjectInvocation:Qalloc: "inner(GeneralProcess)" 
 -- name: "inner" 
 -- Arguments "inner(GeneralProcess)" 
 -- OG:Qalloc: "GeneralProcess" qDescno:  0 
 -- OG:Qalloc:A:  "GeneralProcess"  super:  "GeneralProcess"  marked:  false "inner(GeneralProcess)" super:  GeneralProcess 
 -- Invocation:Qalloc: "GeneralProcess" 
 -- ObjectInvocation:Qalloc: "GeneralProcess" 
 -- name: "GeneralProcess" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  82 3 start:< {   inner(start);mkActive:< ;   inner(mkActive);addWaiting:< ;   --put('q')inner(addWaiting);   --put('R') ...} 
 -- OG:super:  "GeneralProcess(id: var LIB.StringLib.String): {   start:< ;      inner(start);   mkActive:< ;      inner(mkActive);   addWaiting:< ;      --put('q')inner(addWa ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "GeneralProcess" 
 -- super:  "GeneralProcess" 
 -- E:  "GeneralProcess" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "GeneralProcess" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 %basic 101{in inner: ref Object} 
 -- OG:super:  "inner: {   %basic 101;   in inner: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(GeneralProcess)" 
 -- super:  "inner(GeneralProcess)" 
 -- E:  "inner(GeneralProcess)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(GeneralProcess)" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 82 "start:< {   inner(start);mkActive:< ;   inner(mkActive);addWaiting:< ;   --put('q')inner(addWaiting);   --put('R');dcrWaiting:< ...}" 
 -- IS.newDescNo: 82 IS.objSize: 3 "start:< {   inner(start);mkActive:< ;   inner(mkActive);addWaiting:< ;   --put('q')inner(addWaiting);   --put('R');dcrWaiting:< ;   inner(d ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  82 "start:< {      inner(start);   mkActive:< ;      inner(mkActive);   addWaiting:< ;      --put('q')inner(addWaiting);      --put('R');   d ...}" 
 -- OG:super:  "GeneralProcess(id: var LIB.StringLib.String): {   start:< ;      inner(start);   mkActive:< ;      inner(mkActive);   addWaiting:< ;      --put('q')inner(addWa ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "GeneralProcess{   mkActive::< ;      -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;      SQS.insert(this(BasicProcess));   %Publi ...}" 
 -- super:  "GeneralProcess" 
 -- E:  "GeneralProcess" 
 -- OG:Qalloc:B: "BasicProcess" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 83 IS.newDescNo: 83 objSize: 0 1: 1 "mkActive::< {   -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;   S ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 83 "mkActive::< {   -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;   SQS.insert(this(BasicProc ...}" 
 -- Items:Qalloc:super: "GeneralProcess" size: 3 "BasicProcess" 
 -- super.isThisBlockLevel: false superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 4 originOff: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- Pattern:Qalloc: mkActive 
 -- Pattern:Qalloc:B: mkActive 
 -- Pattern:Qalloc: start 
 -- Pattern:Qalloc:B: start 
 -- Pattern:Qalloc: isTerminated 
 -- Pattern:Qalloc:B: isTerminated 
 -- Pattern:Qalloc: addWaiting 
 -- Pattern:Qalloc:B: addWaiting 
 -- Pattern:Qalloc: dcrWaiting 
 -- Pattern:Qalloc:B: dcrWaiting 
 -- Pattern:Qalloc: display 
 -- Pattern:Qalloc:B: display 
 -- OG:Qalloc: "this(BasicProcess).suspend{--(id + ":B:").print	 	 }" qDescno:  0 
 -- OG:Qalloc:A:  "suspend"  super:  "this(BasicProcess).suspend{--(id + ":B:").print	 	 }"  marked:  false "mkActive::< {   -- start and mkActive are identical and one may be ...}" s ... t ... 
 -- Invocation:Qalloc: "this(BasicProcess).suspend{--(id + ":B:").print	 	 }" 
 -- ObjectInvocation:Qalloc: "this(BasicProcess)" 
 -- name: "this" 
 -- Arguments "this(BasicProcess)" 
 -- OG:Qalloc: "BasicProcess" qDescno:  0 
 -- OG:Qalloc:A:  "BasicProcess"  super:  "BasicProcess"  marked:  false "this(BasicProcess)" super:  BasicProcess 
 -- Invocation:Qalloc: "BasicProcess" 
 -- ObjectInvocation:Qalloc: "BasicProcess" 
 -- name: "BasicProcess" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  83 4 mkActive::< {   -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;   SQS.inse ...} 
 -- OG:super:  "BasicProcess: GeneralProcess{   mkActive::< ;      -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;      SQS.insert(this ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "BasicProcess" 
 -- super:  "BasicProcess" 
 -- E:  "BasicProcess" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "BasicProcess" 
 -- ObjectInvocation:Qalloc: "suspend{--(id + ":B:").print	 	 }" 
 -- name: "suspend" 
 -- Arguments "--(id + ":B:").print	 	 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 111 
 -- OG:Qalloc:SuperAlloc: "suspend: {   %basic 111}" 
 -- OG:Qalloc: "%basic 111" qDescno:  0 
 -- OG:Qalloc:A:  "suspend"  super:  ""  marked:  false "suspend: {   %basic 111}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 111" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "suspend" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 84 IS.newDescNo: 84 objSize: 0 1: 1 "%basic 111" 
 -- Items:Qalloc:objSize: 0  newDescNo: 84 "%basic 111" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 84 "%basic 111" 
 -- IS.newDescNo: 84 IS.objSize: 1 "%basic 111" 
 -- OG:Qalloc:end: IS.newDescNo:  84 "%basic 111" 
 -- OG:super:  "suspend: {   %basic 111}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "this(BasicProcess).suspend{--(id + ":B:").print	 	 }" 
 -- super:  "this(BasicProcess).suspend{--(id + ":B:").print	 	 }" 
 -- E:  "suspend{--(id + ":B:").print	 	 }" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "this(BasicProcess).suspend{--(id + ":B:").print	 	 }" 
 -- OG:Qalloc: "inner(BasicProcess)" qDescno:  0 
 -- OG:Qalloc:A:  "inner"  super:  "inner(BasicProcess)"  marked:  false "mkActive::< {   -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIV ...}" s ... i ... 
 -- Invocation:Qalloc: "inner(BasicProcess)" 
 -- ObjectInvocation:Qalloc: "inner(BasicProcess)" 
 -- name: "inner" 
 -- Arguments "inner(BasicProcess)" 
 -- OG:Qalloc: "BasicProcess" qDescno:  0 
 -- OG:Qalloc:A:  "BasicProcess"  super:  "BasicProcess"  marked:  false "inner(BasicProcess)" super:  BasicProcess 
 -- Invocation:Qalloc: "BasicProcess" 
 -- ObjectInvocation:Qalloc: "BasicProcess" 
 -- name: "BasicProcess" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  83 4 mkActive::< {   -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;   SQS.inse ...} 
 -- OG:super:  "BasicProcess: GeneralProcess{   mkActive::< ;      -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;      SQS.insert(this ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "BasicProcess" 
 -- super:  "BasicProcess" 
 -- E:  "BasicProcess" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "BasicProcess" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 %basic 101{in inner: ref Object} 
 -- OG:super:  "inner: {   %basic 101;   in inner: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(BasicProcess)" 
 -- super:  "inner(BasicProcess)" 
 -- E:  "inner(BasicProcess)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(BasicProcess)" 
 -- Invocation:Qalloc: "status" 
 -- ObjectInvocation:Qalloc: "status" 
 -- name: "status" 
 -- Arguments "" 
 -- OG:Qalloc: "P_status.TERMINATED" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "P_status.TERMINATED"  marked:  false "status := P_status.TERMINATED" super:  P_status.TERMINATED 
 -- Invocation:Qalloc: "P_status.TERMINATED" 
 -- ObjectInvocation:Qalloc: "P_status" 
 -- name: "P_status" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "TERMINATED" 
 -- name: "TERMINATED" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "TERMINATED: val 3" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "P_status.TERMINATED" 
 -- super:  "P_status.TERMINATED" 
 -- E:  "TERMINATED" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "P_status.TERMINATED" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 83 "mkActive::< {   -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;   SQS.insert(this(Basic ...}" 
 -- IS.newDescNo: 83 IS.objSize: 4 "mkActive::< {   -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;   SQS.insert(this(BasicProcess));%P ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  83 "GeneralProcess{   mkActive::< ;      -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;      SQS.ins ...}" 
 -- OG:super:  "BasicProcess: GeneralProcess{   mkActive::< ;      -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;      SQS.insert(this ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "BasicProcess("Keyboard"){   B: obj Indexed(100,integer);   next: var integer;   top: var integer;   echo: var Boolean;   %Public;   Kscan: ;      loopB: obj ;         if  ...}" 
 -- super:  "BasicProcess("Keyboard")" 
 -- E:  "BasicProcess("Keyboard")" 
 -- OG:Qalloc:B: "keyboard" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 85 IS.newDescNo: 85 objSize: 0 1: 1 "B: obj Indexed(100,integer){next: var integer;top: var integer;echo: var Boolean;%Public;Kscan: ;   loopB:  ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 85 "B: obj Indexed(100,integer){next: var integer;top: var integer;echo: var Boolean;%Public;Kscan: ;   loopB: obj ;      if (_kbhit) : ...}" 
 -- Items:Qalloc:super: "BasicProcess("Keyboard")" size: 4 "keyboard" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 4 originOff: 4 
 -- dataitem:qalloc: "B" isValue: false  isPrimitive: true  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 5 "B: obj Indexed(100,integer)" 
 -- OG:Qalloc: "Indexed(100,integer)" qDescno:  0 
 -- OG:Qalloc:A:  "B"  super:  "Indexed(100,integer)"  marked:  false "B: obj Indexed(100,integer)" super:  Indexed(100,integer) 
 -- Invocation:Qalloc: "Indexed(100,integer)" 
 -- ObjectInvocation:Qalloc: "Indexed(100,integer)" 
 -- name: "Indexed" 
 -- Arguments "(100,integer)" 
 -- OG:Qalloc: "100" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "100"  marked:  false "(100,integer)" super:  100 
 -- Invocation:Qalloc: "100" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "100" 
 -- super:  "100" 
 -- E:  "100" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "100" 
 -- OG:Qalloc: "integer" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "integer"  marked:  false "(100,integer)" super:  integer 
 -- Invocation:Qalloc: "integer" 
 -- ObjectInvocation:Qalloc: "integer" 
 -- name: "integer" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "integer" 
 -- super:  "integer" 
 -- E:  "integer" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "integer" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %globals{%basic 114;%public;in range: var Integer;in elm:< Object;length: ;   out res: var integer;   res := get[0] ...} 
 -- OG:Qalloc:SuperAlloc: "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0 ...}" 
 -- OG:Qalloc: "%globals{   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];   put(V: var integer) ...}" q ... 0 
 -- OG:Qalloc:A:  "Indexed"  super:  ""  marked:  false "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res:  ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%globals{   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];   put(V: var integer):at[inx: va ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "Indexed" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 86 IS.newDescNo: 86 objSize: 0 1: 1 "%globals{%basic 114;%public;in range: var Integer;in elm:< Object;length: ;   out res: var integer;   res : ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 86 "%globals{%basic 114;%public;in range: var Integer;in elm:< Object;length: ;   out res: var integer;   res := get[0];put(V: var inte ...}" 
 -- Items:Qalloc:Super:C:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 "" 
 -- dataitem:qalloc: "range" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Pattern:Qalloc: elm 
 -- Pattern:Qalloc:B: elm 
 -- Pattern:Qalloc: elm$87 
 -- Pattern:Qalloc:B: elm$87 
 -- Pattern:Qalloc: length 
 -- Pattern:Qalloc:B: length 
 -- Pattern:Qalloc: put:at 
 -- Pattern:Qalloc: get 
 -- Pattern:Qalloc: has 
 -- Pattern:Qalloc:B: has 
 -- Pattern:Qalloc: scan 
 -- Pattern:Qalloc:B: scan 
 -- Pattern:Qalloc: asString 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 86 "%globals{%basic 114;%public;in range: var Integer;in elm:< Object;length: ;   out res: var integer;   res := get[0];put(V: var  ...}" 
 -- IS.newDescNo: 86 IS.objSize: 1 "%globals{%basic 114;%public;in range: var Integer;in elm:< Object;length: ;   out res: var integer;   res := get[0];put(V: var integer):at[ ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  86 "%globals{   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0]; ...}" 
 -- OG:super:  "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];   put(V: ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "Indexed(100,integer)" 
 -- super:  "Indexed(100,integer)" 
 -- E:  "Indexed(100,integer)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Indexed(100,integer)" 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- dataitem:qalloc: "next" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 6 
 -- Items:Qalloc:objSize: 6  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 6  newDescNo: 0 "" 
 -- dataitem:qalloc: "top" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 7 
 -- Items:Qalloc:objSize: 7  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 7  newDescNo: 0 "" 
 -- dataitem:qalloc: "echo" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 8 
 -- Items:Qalloc:objSize: 8  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 8  newDescNo: 0 "" 
 -- Pattern:Qalloc: Kscan 
 -- Pattern:Qalloc:B: Kscan 
 -- Pattern:Qalloc: get 
 -- Pattern:Qalloc:B: get 
 -- OG:Qalloc: "Kscan" qDescno:  0 
 -- OG:Qalloc:A:  "Kscan"  super:  "Kscan"  marked:  false "B: obj Indexed(100,integer){next: var integer;top: var integer;echo: var Boolean;%Public;Kscan: ;   loopB: obj ;    ...}" s ... K ... 
 -- Invocation:Qalloc: "Kscan" 
 -- ObjectInvocation:Qalloc: "Kscan" 
 -- name: "Kscan" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 loopB: obj {   if (_kbhit) :then ;      top := top + 1;      B.put(_iget):at[top];   keyboard.suspend;   restart(lo ...} 
 -- OG:Qalloc:SuperAlloc: "Kscan: {   loopB: obj ;      if (_kbhit) :then ;         top := top + 1;         B.put(_iget):at[top];      keyboard.suspend;      restart(loopB)}" 
 -- OG:Qalloc: "loopB: obj {      if (_kbhit) :then ;         top := top + 1;         B.put(_iget):at[top];      keyboard.suspend;      restart(loopB)}" qDescno:  0 
 -- OG:Qalloc:A:  "Kscan"  super:  ""  marked:  false "Kscan: {   loopB: obj ;      if (_kbhit) :then ;         top := top + 1;         B.put(_iget):at[top];      keyboard.sus ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "loopB: obj {      if (_kbhit) :then ;         top := top + 1;         B.put(_iget):at[top];      keyboard.suspend;      restart(loopB)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "Kscan" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 88 IS.newDescNo: 88 objSize: 0 1: 1 "loopB: obj {   if (_kbhit) :then ;      top := top + 1;      B.put(_iget):at[top];   keyboard.suspend;   re ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 88 "loopB: obj {   if (_kbhit) :then ;      top := top + 1;      B.put(_iget):at[top];   keyboard.suspend;   restart(loopB)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "loopB" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "loopB: obj {   if (_kbhit) :then ;      top := top + 1;      B.put(_iget):at[top];   keyboard.suspend;   restart(loopB)}" 
 -- OG:Qalloc: "if (_kbhit) :then {      top := top + 1;      B.put(_iget):at[top];   keyboard.suspend;   restart(loopB)}" qDescno:  0 
 -- OG:Qalloc:A:  "loopB"  super:  ""  marked:  false "loopB: obj {   if (_kbhit) :then ;      top := top + 1;      B.put(_iget):at[top];   keyboard.suspend;   restart(loopB)}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "if (_kbhit) :then {      top := top + 1;      B.put(_iget):at[top];   keyboard.suspend;   restart(loopB)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "loopB" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 89 IS.newDescNo: 89 objSize: 0 1: 1 "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top];keyboard.suspend;restart(loopB)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 89 "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top];keyboard.suspend;restart(loopB)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top]}" qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top]}"  marked:  false "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at ...}" s ... i ... 
 -- Invocation:Qalloc: "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top]}" 
 -- OG:Qalloc: "(_kbhit)" qDescno:  0 
 -- OG:Qalloc:A:  "_kbhit"  super:  "(_kbhit)"  marked:  false "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top]}" super:  (_kbhit) 
 -- Invocation:Qalloc: "(_kbhit)" 
 -- Invocation:Qalloc: "_kbhit" 
 -- ObjectInvocation:Qalloc: "_kbhit" 
 -- name: "_kbhit" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %external 5{out B: var boolean} 
 -- OG:Qalloc:SuperAlloc: "_kbhit: {   %external 5;   out B: var boolean}" 
 -- OG:Qalloc: "%external 5{   out B: var boolean}" qDescno:  0 
 -- OG:Qalloc:A:  "_kbhit"  super:  ""  marked:  false "_kbhit: {   %external 5;   out B: var boolean}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%external 5{   out B: var boolean}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "_kbhit" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 90 IS.newDescNo: 90 objSize: 0 1: 1 "%external 5{out B: var boolean}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 90 "%external 5{out B: var boolean}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "B" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 90 "%external 5{out B: var boolean}" 
 -- IS.newDescNo: 90 IS.objSize: 2 "%external 5{out B: var boolean}" 
 -- OG:Qalloc:end: IS.newDescNo:  90 "%external 5{   out B: var boolean}" 
 -- OG:super:  "_kbhit: {   %external 5;   out B: var boolean}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(_kbhit)" 
 -- super:  "(_kbhit)" 
 -- E:  "(_kbhit)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(_kbhit)" 
 -- OG:Qalloc: "top := top + 1{   B.put(_iget):at[top]}" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top]}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "top := top + 1{   B.put(_iget):at[top]}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 91 IS.newDescNo: 91 objSize: 0 1: 1 "top := top + 1{B.put(_iget):at[top]}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 91 "top := top + 1{B.put(_iget):at[top]}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "top" 
 -- ObjectInvocation:Qalloc: "top" 
 -- name: "top" 
 -- Arguments "" 
 -- OG:Qalloc: "top + 1" qDescno:  0 
 -- OG:Qalloc:A:  "+"  super:  "top + 1"  marked:  false "top := top + 1" super:  top + 1 
 -- Invocation:Qalloc: "top + 1" 
 -- BinaryExp:Qalloc: "top + 1" 
 -- Invocation:Qalloc: "top" 
 -- ObjectInvocation:Qalloc: "top" 
 -- name: "top" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "+ 1" 
 -- name: "+" 
 -- Arguments "1" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "1" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  49 5 %basic 61{in V: var integer;out R: var integer} 
 -- OG:super:  "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "top + 1" 
 -- super:  "top + 1" 
 -- E:  "top + 1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "top + 1" 
 -- OG:Qalloc: "B.put(_iget):at[top]" qDescno:  0 
 -- OG:Qalloc:A:  "put:at"  super:  "B.put(_iget):at[top]"  marked:  false "top := top + 1{B.put(_iget):at[top]}" super:  B.put(_iget):at[top] 
 -- Invocation:Qalloc: "B.put(_iget):at[top]" 
 -- ObjectInvocation:Qalloc: "B" 
 -- name: "B" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "put(_iget):at[top]" 
 -- name: "put:at" 
 -- Arguments "put(_iget):at[top]" 
 -- OG:Qalloc: "_iget" qDescno:  0 
 -- OG:Qalloc:A:  "_iget"  super:  "_iget"  marked:  false "put(_iget):at[top]" super:  _iget 
 -- Invocation:Qalloc: "_iget" 
 -- ObjectInvocation:Qalloc: "_iget" 
 -- name: "_iget" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %external 4{out ch: var char} 
 -- OG:Qalloc:SuperAlloc: "_iget: {   %external 4;   out ch: var char}" 
 -- OG:Qalloc: "%external 4{   out ch: var char}" qDescno:  0 
 -- OG:Qalloc:A:  "_iget"  super:  ""  marked:  false "_iget: {   %external 4;   out ch: var char}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%external 4{   out ch: var char}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "_iget" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 92 IS.newDescNo: 92 objSize: 0 1: 1 "%external 4{out ch: var char}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 92 "%external 4{out ch: var char}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "ch" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 92 "%external 4{out ch: var char}" 
 -- IS.newDescNo: 92 IS.objSize: 2 "%external 4{out ch: var char}" 
 -- OG:Qalloc:end: IS.newDescNo:  92 "%external 4{   out ch: var char}" 
 -- OG:super:  "_iget: {   %external 4;   out ch: var char}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "_iget" 
 -- super:  "_iget" 
 -- E:  "_iget" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "_iget" 
 -- OG:Qalloc: "top" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "top"  marked:  false "put(_iget):at[top]" super:  top 
 -- Invocation:Qalloc: "top" 
 -- ObjectInvocation:Qalloc: "top" 
 -- name: "top" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "top: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "top" 
 -- super:  "top" 
 -- E:  "top" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "top" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 115 
 -- OG:Qalloc:SuperAlloc: "put(V: var integer):at[inx: var integer]: {   %basic 115}" 
 -- OG:Qalloc: "%basic 115" qDescno:  0 
 -- OG:Qalloc:A:  "put:at"  super:  ""  marked:  false "put(V: var integer):at[inx: var integer]: {   %basic 115}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 115" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "put:at" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 93 IS.newDescNo: 93 objSize: 0 1: 1 "%basic 115" 
 -- Items:Qalloc:objSize: 0  newDescNo: 93 "%basic 115" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "%$B "("{V: var integer;%$S "):at[";inx: var integer;%$E "]"}" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- dataitem:qalloc: "inx" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "%$B "("{V: var integer;%$S "):at[";inx: var integer;%$E "]"}" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 93 "%basic 115" 
 -- IS.newDescNo: 93 IS.objSize: 3 "%basic 115" 
 -- OG:Qalloc:end: IS.newDescNo:  93 "%basic 115" 
 -- OG:super:  "put(V: var integer):at[inx: var integer]: {   %basic 115}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "B.put(_iget):at[top]" 
 -- super:  "B.put(_iget):at[top]" 
 -- E:  "put(_iget):at[top]" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "B.put(_iget):at[top]" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 91 "top := top + 1{B.put(_iget):at[top]}" 
 -- IS.newDescNo: 91 IS.objSize: 1 "top := top + 1{B.put(_iget):at[top]}" 
 -- OG:Qalloc:end: IS.newDescNo:  91 "top := top + 1{   B.put(_iget):at[top]}" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top]}" 
 -- super:  "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top]}" 
 -- E:  "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top]}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top]}" 
 -- OG:Qalloc: "keyboard.suspend" qDescno:  0 
 -- OG:Qalloc:A:  "suspend"  super:  "keyboard.suspend"  marked:  false "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top];keyboard.suspend;restart(loopB)}" super:  ... k ... 
 -- Invocation:Qalloc: "keyboard.suspend" 
 -- ObjectInvocation:Qalloc: "keyboard" 
 -- name: "keyboard" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "suspend" 
 -- name: "suspend" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  84 1 %basic 111 
 -- OG:super:  "suspend: {   %basic 111}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "keyboard.suspend" 
 -- super:  "keyboard.suspend" 
 -- E:  "suspend" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "keyboard.suspend" 
 -- OG:Qalloc: "restart(loopB)" qDescno:  0 
 -- OG:Qalloc:A:  "restart"  super:  "restart(loopB)"  marked:  false "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top];keyboard.suspend;restart(loopB)}" super:  r ... 
 -- Invocation:Qalloc: "restart(loopB)" 
 -- ObjectInvocation:Qalloc: "restart(loopB)" 
 -- name: "restart" 
 -- Arguments "restart(loopB)" 
 -- OG:Qalloc: "loopB" qDescno:  0 
 -- OG:Qalloc:A:  "loopB"  super:  "loopB"  marked:  false "restart(loopB)" super:  loopB 
 -- Invocation:Qalloc: "loopB" 
 -- ObjectInvocation:Qalloc: "loopB" 
 -- name: "loopB" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  89 1 if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top];keyboard.suspend;restart(loopB)} 
 -- OG:super:  "loopB: obj {   if (_kbhit) :then ;      top := top + 1;      B.put(_iget):at[top];   keyboard.suspend;   restart(loopB)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "loopB" 
 -- super:  "loopB" 
 -- E:  "loopB" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "loopB" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  50 2 %basic 102 
 -- OG:super:  "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "restart(loopB)" 
 -- super:  "restart(loopB)" 
 -- E:  "restart(loopB)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "restart(loopB)" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 89 "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top];keyboard.suspend;restart(loopB)}" 
 -- IS.newDescNo: 89 IS.objSize: 1 "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top];keyboard.suspend;restart(loopB)}" 
 -- OG:Qalloc:end: IS.newDescNo:  89 "if (_kbhit) :then {      top := top + 1;      B.put(_iget):at[top];   keyboard.suspend;   restart(loopB)}" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 88 "loopB: obj {   if (_kbhit) :then ;      top := top + 1;      B.put(_iget):at[top];   keyboard.suspend;   restart(loopB)}" 
 -- IS.newDescNo: 88 IS.objSize: 2 "loopB: obj {   if (_kbhit) :then ;      top := top + 1;      B.put(_iget):at[top];   keyboard.suspend;   restart(loopB)}" 
 -- OG:Qalloc:end: IS.newDescNo:  88 "loopB: obj {      if (_kbhit) :then ;         top := top + 1;         B.put(_iget):at[top];      keyboard.suspend;      restart(loopB)}" 
 -- OG:super:  "Kscan: {   loopB: obj ;      if (_kbhit) :then ;         top := top + 1;         B.put(_iget):at[top];      keyboard.suspend;      restart(loopB)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Kscan" 
 -- super:  "Kscan" 
 -- E:  "Kscan" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Kscan" 
 -- Items:Qalloc:END:objSize: 8  newDescNo: 85 "B: obj Indexed(100,integer){next: var integer;top: var integer;echo: var Boolean;%Public;Kscan: ;   loopB: obj ;      if (_kbhi ...}" 
 -- IS.newDescNo: 85 IS.objSize: 8 "B: obj Indexed(100,integer){next: var integer;top: var integer;echo: var Boolean;%Public;Kscan: ;   loopB: obj ;      if (_kbhit) :then ;   ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  85 "BasicProcess("Keyboard"){   B: obj Indexed(100,integer);   next: var integer;   top: var integer;   echo: var Boolean;   %Public;   Kscan ...}" 
 -- Items:Qalloc:objSize: 9  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 9  newDescNo: 0 "" 
 -- Pattern:Qalloc: init 
 -- Pattern:Qalloc:B: init 
 -- OG:Qalloc: "init" qDescno:  0 
 -- OG:Qalloc:A:  "init"  super:  "init"  marked:  false "%public{BasicProcess: GeneralProcess;   mkActive::< ;      -- start and mkActive are identical and one may be elimina ...}" s ... i ... 
 -- Invocation:Qalloc: "init" 
 -- ObjectInvocation:Qalloc: "init" 
 -- name: "init" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 SQS.init 
 -- OG:Qalloc:SuperAlloc: "init: {   SQS.init}" 
 -- OG:Qalloc: "SQS.init" qDescno:  0 
 -- OG:Qalloc:A:  "init"  super:  ""  marked:  false "init: {   SQS.init}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "SQS.init" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "init" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 94 IS.newDescNo: 94 objSize: 0 1: 1 "SQS.init" 
 -- Items:Qalloc:objSize: 0  newDescNo: 94 "SQS.init" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- OG:Qalloc: "SQS.init" qDescno:  0 
 -- OG:Qalloc:A:  "init"  super:  "SQS.init"  marked:  false "SQS.init" super:  SQS.init 
 -- Invocation:Qalloc: "SQS.init" 
 -- ObjectInvocation:Qalloc: "SQS" 
 -- name: "SQS" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "init" 
 -- name: "init" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 V := 1{L.init;L.id := "SQS";Q.idf := "SQS:"} 
 -- OG:Qalloc:SuperAlloc: "init: entry{   V := 1;   L.init;   L.id := "SQS";   Q.idf := "SQS:"}" 
 -- OG:Qalloc: "entry{   V := 1;   L.init;   L.id := "SQS";   Q.idf := "SQS:"}" qDescno:  0 
 -- OG:Qalloc:A:  "init"  super:  "entry"  marked:  false "init: entry{   V := 1;   L.init;   L.id := "SQS";   Q.idf := "SQS:"}" super:  entry 
 -- Invocation:Qalloc: "entry" 
 -- ObjectInvocation:Qalloc: "entry" 
 -- name: "entry" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 L.get{V := V + 1;if (V > 1) :then ;   put('V');inner(entry);V := V - 1;L.free} 
 -- OG:Qalloc:SuperAlloc: "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free}" 
 -- OG:Qalloc: "L.get{   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free}" qDescno:  0 
 -- OG:Qalloc:A:  "entry"  super:  ""  marked:  false "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L.get{   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "entry" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 95 IS.newDescNo: 95 objSize: 0 1: 1 "L.get{V := V + 1;if (V > 1) :then ;   put('V');inner(entry);V := V - 1;L.free}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 95 "L.get{V := V + 1;if (V > 1) :then ;   put('V');inner(entry);V := V - 1;L.free}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- OG:Qalloc: "L.get" qDescno:  0 
 -- OG:Qalloc:A:  "get"  super:  "L.get"  marked:  false "L.get{V := V + 1;if (V > 1) :then ;   put('V');inner(entry);V := V - 1;L.free}" super:  L.get 
 -- Invocation:Qalloc: "L.get" 
 -- ObjectInvocation:Qalloc: "L" 
 -- name: "L" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "get" 
 -- name: "get" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 loop: obj {   res: var integer;   i: var integer;   --disable;   res := free_M.cmpAndSwap(1);   if (res = 1) :then  ...} 
 -- OG:Qalloc:SuperAlloc: "get: {   loop: obj ;      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);      if (res = 1) :then ;         ...}" 
 -- OG:Qalloc: "loop: obj {      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);      if (res = 1) :then ;         --enablesleep(50);  ...}" q ... 0 
 -- OG:Qalloc:A:  "get"  super:  ""  marked:  false "get: {   loop: obj ;      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);      if ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "loop: obj {      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);      if (res = 1) :then ;         --enablesleep(50);         i : ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "get" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 96 IS.newDescNo: 96 objSize: 0 1: 1 "loop: obj {   res: var integer;   i: var integer;   --disable;   res := free_M.cmpAndSwap(1);   if (res = 1 ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 96 "loop: obj {   res: var integer;   i: var integer;   --disable;   res := free_M.cmpAndSwap(1);   if (res = 1) :then ;      --enables ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "loop" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "loop: obj {   res: var integer;   i: var integer;   --disable;   res := free_M.cmpAndSwap(1);   if (res = 1) :then ;      --enablesleep(50);      i := i  ...}" 
 -- OG:Qalloc: "res: var integer{   i: var integer;   --disable;   res := free_M.cmpAndSwap(1);   if (res = 1) :then ;      --enablesleep(50);      i := i + 1;      if (i > 10 ...}" q ... 0 
 -- OG:Qalloc:A:  "loop"  super:  ""  marked:  false "loop: obj {   res: var integer;   i: var integer;   --disable;   res := free_M.cmpAndSwap(1);   if (res = 1) :then ;      ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "res: var integer{   i: var integer;   --disable;   res := free_M.cmpAndSwap(1);   if (res = 1) :then ;      --enablesleep(50);      i := i + 1;      if (i > 10000) :then  ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "loop" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 97 IS.newDescNo: 97 objSize: 0 1: 1 "res: var integer{i: var integer;--disable;res := free_M.cmpAndSwap(1);if (res = 1) :then ;   --enablesleep( ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 97 "res: var integer{i: var integer;--disable;res := free_M.cmpAndSwap(1);if (res = 1) :then ;   --enablesleep(50);   i := i + 1;   if  ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- dataitem:qalloc: "res" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- dataitem:qalloc: "i" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- Invocation:Qalloc: "res" 
 -- ObjectInvocation:Qalloc: "res" 
 -- name: "res" 
 -- Arguments "" 
 -- OG:Qalloc: "free_M.cmpAndSwap(1)" qDescno:  0 
 -- OG:Qalloc:A:  "cmpAndSwap"  super:  "free_M.cmpAndSwap(1)"  marked:  false "res := free_M.cmpAndSwap(1)" super:  free_M.cmpAndSwap(1) 
 -- Invocation:Qalloc: "free_M.cmpAndSwap(1)" 
 -- ObjectInvocation:Qalloc: "free_M" 
 -- name: "free_M" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "cmpAndSwap(1)" 
 -- name: "cmpAndSwap" 
 -- Arguments "cmpAndSwap(1)" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "cmpAndSwap(1)" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 14{in V: var integer;out res: var integer} 
 -- OG:Qalloc:SuperAlloc: "cmpAndSwap: {   %basic 14;   in V: var integer;   out res: var integer}" 
 -- OG:Qalloc: "%basic 14{   in V: var integer;   out res: var integer}" qDescno:  0 
 -- OG:Qalloc:A:  "cmpAndSwap"  super:  ""  marked:  false "cmpAndSwap: {   %basic 14;   in V: var integer;   out res: var integer}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 14{   in V: var integer;   out res: var integer}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "cmpAndSwap" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 98 IS.newDescNo: 98 objSize: 0 1: 1 "%basic 14{in V: var integer;out res: var integer}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 98 "%basic 14{in V: var integer;out res: var integer}" 
 -- Items:Qalloc:Super:C:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- dataitem:qalloc: "res" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 98 "%basic 14{in V: var integer;out res: var integer}" 
 -- IS.newDescNo: 98 IS.objSize: 5 "%basic 14{in V: var integer;out res: var integer}" 
 -- OG:Qalloc:end: IS.newDescNo:  98 "%basic 14{   in V: var integer;   out res: var integer}" 
 -- OG:super:  "cmpAndSwap: {   %basic 14;   in V: var integer;   out res: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "free_M.cmpAndSwap(1)" 
 -- super:  "free_M.cmpAndSwap(1)" 
 -- E:  "cmpAndSwap(1)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "free_M.cmpAndSwap(1)" 
 -- OG:Qalloc: "if (res = 1) :then {   --enablesleep(50);   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts").print;      i := 0;   restart(loo ...}" q ... 0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (res = 1) :then {   --enablesleep(50);   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts").print;    ...}"   ... false "r ..." s ... i ... 
 -- Invocation:Qalloc: "if (res = 1) :then {   --enablesleep(50);   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts").print;      i := 0;   res ...}" 
 -- OG:Qalloc: "(res = 1)" qDescno:  0 
 -- OG:Qalloc:A:  "="  super:  "(res = 1)"  marked:  false "if (res = 1) :then {   --enablesleep(50);   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000  ..."}" s ... ( ... 
 -- Invocation:Qalloc: "(res = 1)" 
 -- Invocation:Qalloc: "res = 1" 
 -- BinaryExp:Qalloc: "res = 1" 
 -- Invocation:Qalloc: "res" 
 -- ObjectInvocation:Qalloc: "res" 
 -- name: "res" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "= 1" 
 -- name: "=" 
 -- Arguments "1" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "1" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  11 5 %basic 50{in Veq: var this(Value);out Beq: var boolean;inner(= )} 
 -- OG:super:  "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(res = 1)" 
 -- super:  "(res = 1)" 
 -- E:  "(res = 1)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(res = 1)" 
 -- OG:Qalloc: "--enablesleep(50){   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts").print;      i := 0;   restart(loop)}" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (res = 1) :then {   --enablesleep(50);   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts ..."}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "--enablesleep(50){   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts").print;      i := 0;   restart(loop)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 99 IS.newDescNo: 99 objSize: 0 1: 1 "--enablesleep(50){i := i + 1;if (i > 10000) :then ;   (id + " not free after 10000 attempts").print;   i := ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 99 "--enablesleep(50){i := i + 1;if (i > 10000) :then ;   (id + " not free after 10000 attempts").print;   i := 0;restart(loop)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: "sleep(50)" qDescno:  0 
 -- OG:Qalloc:A:  "sleep"  super:  "sleep(50)"  marked:  false "--enablesleep(50){i := i + 1;if (i > 10000) :then ;   (id + " not free after 10000 attempts").print;   i := 0;r ...}" s ... s ... 
 -- Invocation:Qalloc: "sleep(50)" 
 -- ObjectInvocation:Qalloc: "sleep(50)" 
 -- name: "sleep" 
 -- Arguments "sleep(50)" 
 -- OG:Qalloc: "50" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "50"  marked:  false "sleep(50)" super:  50 
 -- Invocation:Qalloc: "50" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "50" 
 -- super:  "50" 
 -- E:  "50" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "50" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 15{in V: var integer} 
 -- OG:Qalloc:SuperAlloc: "sleep: {   %basic 15;   in V: var integer}" 
 -- OG:Qalloc: "%basic 15{   in V: var integer}" qDescno:  0 
 -- OG:Qalloc:A:  "sleep"  super:  ""  marked:  false "sleep: {   %basic 15;   in V: var integer}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 15{   in V: var integer}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "sleep" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 100 IS.newDescNo: 100 objSize: 0 1: 1 "%basic 15{in V: var integer}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 100 "%basic 15{in V: var integer}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 100 "%basic 15{in V: var integer}" 
 -- IS.newDescNo: 100 IS.objSize: 2 "%basic 15{in V: var integer}" 
 -- OG:Qalloc:end: IS.newDescNo:  100 "%basic 15{   in V: var integer}" 
 -- OG:super:  "sleep: {   %basic 15;   in V: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "sleep(50)" 
 -- super:  "sleep(50)" 
 -- E:  "sleep(50)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "sleep(50)" 
 -- Invocation:Qalloc: "i" 
 -- ObjectInvocation:Qalloc: "i" 
 -- name: "i" 
 -- Arguments "" 
 -- OG:Qalloc: "i + 1" qDescno:  0 
 -- OG:Qalloc:A:  "+"  super:  "i + 1"  marked:  false "i := i + 1" super:  i + 1 
 -- Invocation:Qalloc: "i + 1" 
 -- BinaryExp:Qalloc: "i + 1" 
 -- Invocation:Qalloc: "i" 
 -- ObjectInvocation:Qalloc: "i" 
 -- name: "i" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "+ 1" 
 -- name: "+" 
 -- Arguments "1" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "1" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  49 5 %basic 61{in V: var integer;out R: var integer} 
 -- OG:super:  "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "i + 1" 
 -- super:  "i + 1" 
 -- E:  "i + 1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "i + 1" 
 -- OG:Qalloc: "if (i > 10000) :then {   (id + " not free after 10000 attempts").print;   i := 0}" qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (i > 10000) :then {   (id + " not free after 10000 attempts").print;   i := 0}"  marked:  false "--enablesleep(50){i := i + 1;if (i  ...}" s ... i ... 
 -- Invocation:Qalloc: "if (i > 10000) :then {   (id + " not free after 10000 attempts").print;   i := 0}" 
 -- OG:Qalloc: "(i > 10000)" qDescno:  0 
 -- OG:Qalloc:A:  ">"  super:  "(i > 10000)"  marked:  false "if (i > 10000) :then {   (id + " not free after 10000 attempts").print;   i := 0}" super:  (i > 10000) 
 -- Invocation:Qalloc: "(i > 10000)" 
 -- Invocation:Qalloc: "i > 10000" 
 -- BinaryExp:Qalloc: "i > 10000" 
 -- Invocation:Qalloc: "i" 
 -- ObjectInvocation:Qalloc: "i" 
 -- name: "i" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "> 10000" 
 -- name: ">" 
 -- Arguments "10000" 
 -- OG:Qalloc: "10000" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "10000"  marked:  false "10000" super:  10000 
 -- Invocation:Qalloc: "10000" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "10000" 
 -- super:  "10000" 
 -- E:  "10000" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "10000" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 53{in V: var integer;out B: var boolean} 
 -- OG:Qalloc:SuperAlloc: ">  : {   %basic 53;   in V: var integer;   out B: var boolean}" 
 -- OG:Qalloc: "%basic 53{   in V: var integer;   out B: var boolean}" qDescno:  0 
 -- OG:Qalloc:A:  ">"  super:  ""  marked:  false ">  : {   %basic 53;   in V: var integer;   out B: var boolean}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 53{   in V: var integer;   out B: var boolean}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: ">" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 101 IS.newDescNo: 101 objSize: 0 1: 1 "%basic 53{in V: var integer;out B: var boolean}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 101 "%basic 53{in V: var integer;out B: var boolean}" 
 -- Items:Qalloc:Super:C:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- dataitem:qalloc: "B" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 101 "%basic 53{in V: var integer;out B: var boolean}" 
 -- IS.newDescNo: 101 IS.objSize: 5 "%basic 53{in V: var integer;out B: var boolean}" 
 -- OG:Qalloc:end: IS.newDescNo:  101 "%basic 53{   in V: var integer;   out B: var boolean}" 
 -- OG:super:  ">  : {   %basic 53;   in V: var integer;   out B: var boolean}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(i > 10000)" 
 -- super:  "(i > 10000)" 
 -- E:  "(i > 10000)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(i > 10000)" 
 -- OG:Qalloc: "(id + " not free after 10000 attempts").print{   i := 0}" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (i > 10000) :then {   (id + " not free after 10000 attempts").print;   i := 0}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(id + " not free after 10000 attempts").print{   i := 0}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 102 IS.newDescNo: 102 objSize: 0 1: 1 "(id + " not free after 10000 attempts").print{i := 0}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 102 "(id + " not free after 10000 attempts").print{i := 0}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: "(id + " not free after 10000 attempts").print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "(id + " not free after 10000 attempts").print"  marked:  false "(id + " not free after 10000 attempts").print{i := 0}" super:  (id + " not  ..." 
 -- Invocation:Qalloc: "(id + " not free after 10000 attempts").print" 
 -- Invocation:Qalloc: "id + " not free after 10000 attempts"" 
 -- BinaryExp:Qalloc: "id + " not free after 10000 attempts"" 
 -- Invocation:Qalloc: "id" 
 -- ObjectInvocation:Qalloc: "id" 
 -- name: "id" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "+ " not free after 10000 attempts"" 
 -- name: "+" 
 -- Arguments "" not free after 10000 attempts"" 
 -- OG:Qalloc: "" not free after 10000 attempts"" qDescno:  0 
 -- OG:Qalloc:A:  "String"  super:  "" not free after 10000 attempts""  marked:  false "" not free after 10000 attempts"" super:  " not free after 10000 attempts" 
 -- Invocation:Qalloc: "" not free after 10000 attempts"" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  10 0 %id "String pattern"{%OSDvisibility disguised;%basic 5;%public;length: ;   out V: var integer;   V := get[0] -- ac ...} 
 -- OG:super:  "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- actually an  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "" not free after 10000 attempts"" 
 -- super:  "" not free after 10000 attempts"" 
 -- E:  "" not free after 10000 attempts"" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "" not free after 10000 attempts"" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);} 
 -- OG:Qalloc:SuperAlloc: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OG:Qalloc: "gogo: {      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  ""  marked:  false "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "gogo: {      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "print" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 103 IS.newDescNo: 103 objSize: 0 1: 1 "gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 103 "gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Pattern:Qalloc: gogo 
 -- Pattern:Qalloc:B: gogo 
 -- OG:Qalloc: "for(1):to(length):repeat{   put(get[inx]);}" qDescno:  0 
 -- OG:Qalloc:A:  "for:to:repeat$0"  super:  "for(1):to(length):repeat{   put(get[inx]);}"  marked:  false "gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]); ...}" s ... f ... 
 -- Invocation:Qalloc: "for(1):to(length):repeat{   put(get[inx]);}" 
 -- ObjectInvocation:Qalloc: "for(1):to(length):repeat{   put(get[inx]);}" 
 -- name: "for:to:repeat" 
 -- Arguments "for(1):to(length):repeat{   put(get[inx]);}" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "for(1):to(length):repeat{   put(get[inx]);}" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- OG:Qalloc: "length" qDescno:  0 
 -- OG:Qalloc:A:  "length"  super:  "length"  marked:  false "for(1):to(length):repeat{   put(get[inx]);}" super:  length 
 -- Invocation:Qalloc: "length" 
 -- ObjectInvocation:Qalloc: "length" 
 -- name: "length" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  15 2 out V: var integer{V := get[0] -- actually an index error, accessing length} 
 -- OG:super:  "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "length" 
 -- super:  "length" 
 -- E:  "length" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "length" 
 -- OG:Qalloc: "put(get[inx])" qDescno:  0 
 -- OG:Qalloc:A:  "repeat$0"  super:  ""  marked:  false "for(1):to(length):repeat{   put(get[inx]);}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "put(get[inx])" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "repeat$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 104 IS.newDescNo: 104 objSize: 0 1: 1 "put(get[inx])" 
 -- Items:Qalloc:objSize: 0  newDescNo: 104 "put(get[inx])" 
 -- Items:Qalloc:super: "" size: 1 "repeat$104" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- OG:Qalloc: "put(get[inx])" qDescno:  0 
 -- OG:Qalloc:A:  "put"  super:  "put(get[inx])"  marked:  false "put(get[inx])" super:  put(get[inx]) 
 -- Invocation:Qalloc: "put(get[inx])" 
 -- ObjectInvocation:Qalloc: "put(get[inx])" 
 -- name: "put" 
 -- Arguments "put(get[inx])" 
 -- OG:Qalloc: "get[inx]" qDescno:  0 
 -- OG:Qalloc:A:  "get"  super:  "get[inx]"  marked:  false "put(get[inx])" super:  get[inx] 
 -- Invocation:Qalloc: "get[inx]" 
 -- ObjectInvocation:Qalloc: "get[inx]" 
 -- name: "get" 
 -- Arguments "get[inx]" 
 -- OG:Qalloc: "inx" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "inx"  marked:  false "get[inx]" super:  inx 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "inx: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx" 
 -- super:  "inx" 
 -- E:  "inx" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  16 3 %basic 117{out ch: var char} 
 -- OG:super:  "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "get[inx]" 
 -- super:  "get[inx]" 
 -- E:  "get[inx]" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "get[inx]" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %globals{%basic 2;in ch: val char} 
 -- OG:Qalloc:SuperAlloc: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OG:Qalloc: "-- to be eliminated{   %globals;   %basic 2;   in ch: val char}" qDescno:  0 
 -- OG:Qalloc:A:  "put"  super:  "-- to be eliminated"  marked:  false "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" super:  -- to be eliminated 
 -- Invocation:Qalloc: "-- to be eliminated" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "-- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- super:  "-- to be eliminated" 
 -- E:  "" 
 -- OG:Qalloc:B: "put" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 105 IS.newDescNo: 105 objSize: 0 1: 1 "%globals{%basic 2;in ch: val char}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 105 "%globals{%basic 2;in ch: val char}" 
 -- Items:Qalloc:Super:C:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 "" 
 -- dataitem:qalloc: "ch" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 105 "%globals{%basic 2;in ch: val char}" 
 -- IS.newDescNo: 105 IS.objSize: 1 "%globals{%basic 2;in ch: val char}" 
 -- OG:Qalloc:end: IS.newDescNo:  105 "-- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OG:super:  "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "put(get[inx])" 
 -- super:  "put(get[inx])" 
 -- E:  "put(get[inx])" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "put(get[inx])" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 104 "put(get[inx])" 
 -- IS.newDescNo: 104 IS.objSize: 1 "put(get[inx])" 
 -- OG:Qalloc:end: IS.newDescNo:  104 "put(get[inx])" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  28 3 %OSDvisibility skipInternal{%globals inSub;inx: var integer;inx := first;_doIt: do ;   if (inx <= last) :then ;    ...} 
 -- OG:super:  "for(first: var integer):to(last: var integer):repeat{repeat:< object}: {   %OSDvisibility skipInternal;   %globals inSub;   inx: var integer;   inx := first;   ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "for(1):to(length):repeat{   put(get[inx]);}" 
 -- super:  "for(1):to(length):repeat{   put(get[inx]);}" 
 -- E:  "for(1):to(length):repeat{   put(get[inx]);}" 
 -- OG:Qalloc:B: "for:to:repeat$0" newDescNo: 0 objSize: 3 
 -- OG:isObjectDesc:NewDescNo: 106 IS.newDescNo: 106 objSize: 3 1: 1 "" 
 -- Items:Qalloc:objSize: 0  newDescNo: 106 "" 
 -- Items:Qalloc:super: "for(1):to(length):repeat{   put(get[inx]);}" size: 3 "for:to:repeat$106" 
 -- super.isThisBlockLevel: false superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 4 originOff: 4 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 106 "" 
 -- IS.newDescNo: 106 IS.objSize: 3 "" 
 -- OG:Qalloc:end: IS.newDescNo:  106 "for(1):to(length):repeat{   put(get[inx]);}" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 103 "gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);}" 
 -- IS.newDescNo: 103 IS.objSize: 1 "gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);}" 
 -- OG:Qalloc:end: IS.newDescNo:  103 "gogo: {      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OG:super:  "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(id + " not free after 10000 attempts").print" 
 -- super:  "(id + " not free after 10000 attempts").print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(id + " not free after 10000 attempts").print" 
 -- Invocation:Qalloc: "i" 
 -- ObjectInvocation:Qalloc: "i" 
 -- name: "i" 
 -- Arguments "" 
 -- OG:Qalloc: "0" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "0"  marked:  false "i := 0" super:  0 
 -- Invocation:Qalloc: "0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "0" 
 -- super:  "0" 
 -- E:  "0" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "0" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 102 "(id + " not free after 10000 attempts").print{i := 0}" 
 -- IS.newDescNo: 102 IS.objSize: 1 "(id + " not free after 10000 attempts").print{i := 0}" 
 -- OG:Qalloc:end: IS.newDescNo:  102 "(id + " not free after 10000 attempts").print{   i := 0}" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (i > 10000) :then {   (id + " not free after 10000 attempts").print;   i := 0}" 
 -- super:  "if (i > 10000) :then {   (id + " not free after 10000 attempts").print;   i := 0}" 
 -- E:  "if (i > 10000) :then {   (id + " not free after 10000 attempts").print;   i := 0}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (i > 10000) :then {   (id + " not free after 10000 attempts").print;   i := 0}" 
 -- OG:Qalloc: "restart(loop)" qDescno:  0 
 -- OG:Qalloc:A:  "restart"  super:  "restart(loop)"  marked:  false "--enablesleep(50){i := i + 1;if (i > 10000) :then ;   (id + " not free after 10000 attempts").print;   i  ...}" s ... r ... 
 -- Invocation:Qalloc: "restart(loop)" 
 -- ObjectInvocation:Qalloc: "restart(loop)" 
 -- name: "restart" 
 -- Arguments "restart(loop)" 
 -- OG:Qalloc: "loop" qDescno:  0 
 -- OG:Qalloc:A:  "loop"  super:  "loop"  marked:  false "restart(loop)" super:  loop 
 -- Invocation:Qalloc: "loop" 
 -- ObjectInvocation:Qalloc: "loop" 
 -- name: "loop" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  97 3 res: var integer{i: var integer;--disable;res := free_M.cmpAndSwap(1);if (res = 1) :then ;   --enablesleep(50);    ...} 
 -- OG:super:  "loop: obj {   res: var integer;   i: var integer;   --disable;   res := free_M.cmpAndSwap(1);   if (res = 1) :then ;      --enablesleep(50);      i := i + 1;   ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "loop" 
 -- super:  "loop" 
 -- E:  "loop" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "loop" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  50 2 %basic 102 
 -- OG:super:  "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "restart(loop)" 
 -- super:  "restart(loop)" 
 -- E:  "restart(loop)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "restart(loop)" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 99 "--enablesleep(50){i := i + 1;if (i > 10000) :then ;   (id + " not free after 10000 attempts").print;   i := 0;restart(loop)}" 
 -- IS.newDescNo: 99 IS.objSize: 1 "--enablesleep(50){i := i + 1;if (i > 10000) :then ;   (id + " not free after 10000 attempts").print;   i := 0;restart(loop)}" 
 -- OG:Qalloc:end: IS.newDescNo:  99 "--enablesleep(50){   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts").print;      i := 0;   restart(loop ...}" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (res = 1) :then {   --enablesleep(50);   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts").print;      i := 0;   restart(loop)}" 
 -- super:  "if (res = 1) :then {   --enablesleep(50);   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts").print;      i := 0;   restart(loop)}" 
 -- E:  "if (res = 1) :then {   --enablesleep(50);   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts").print;      i := 0;   restart(loop)}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (res = 1) :then {   --enablesleep(50);   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts").print;       ...}" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 97 "res: var integer{i: var integer;--disable;res := free_M.cmpAndSwap(1);if (res = 1) :then ;   --enablesleep(50);   i := i + 1;   ...}" 
 -- IS.newDescNo: 97 IS.objSize: 3 "res: var integer{i: var integer;--disable;res := free_M.cmpAndSwap(1);if (res = 1) :then ;   --enablesleep(50);   i := i + 1;   if (i > 100 ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  97 "res: var integer{   i: var integer;   --disable;   res := free_M.cmpAndSwap(1);   if (res = 1) :then ;      --enablesleep(50);      i :=  ...}" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 96 "loop: obj {   res: var integer;   i: var integer;   --disable;   res := free_M.cmpAndSwap(1);   if (res = 1) :then ;      --ena ...}" 
 -- IS.newDescNo: 96 IS.objSize: 2 "loop: obj {   res: var integer;   i: var integer;   --disable;   res := free_M.cmpAndSwap(1);   if (res = 1) :then ;      --enablesleep(50) ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  96 "loop: obj {      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);      if (res = 1) :then ;       ...}" 
 -- OG:super:  "get: {   loop: obj ;      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);      if (res = 1) :then ;         --enablesl ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L.get" 
 -- super:  "L.get" 
 -- E:  "get" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L.get" 
 -- Invocation:Qalloc: "V" 
 -- ObjectInvocation:Qalloc: "V" 
 -- name: "V" 
 -- Arguments "" 
 -- OG:Qalloc: "V + 1" qDescno:  0 
 -- OG:Qalloc:A:  "+"  super:  "V + 1"  marked:  false "V := V + 1" super:  V + 1 
 -- Invocation:Qalloc: "V + 1" 
 -- BinaryExp:Qalloc: "V + 1" 
 -- Invocation:Qalloc: "V" 
 -- ObjectInvocation:Qalloc: "V" 
 -- name: "V" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "+ 1" 
 -- name: "+" 
 -- Arguments "1" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "1" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  49 5 %basic 61{in V: var integer;out R: var integer} 
 -- OG:super:  "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "V + 1" 
 -- super:  "V + 1" 
 -- E:  "V + 1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "V + 1" 
 -- OG:Qalloc: "if (V > 1) :then {   put('V')}" qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (V > 1) :then {   put('V')}"  marked:  false "L.get{V := V + 1;if (V > 1) :then ;   put('V');inner(entry);V := V - 1;L.free}" super: ... i ... 
 -- Invocation:Qalloc: "if (V > 1) :then {   put('V')}" 
 -- OG:Qalloc: "(V > 1)" qDescno:  0 
 -- OG:Qalloc:A:  ">"  super:  "(V > 1)"  marked:  false "if (V > 1) :then {   put('V')}" super:  (V > 1) 
 -- Invocation:Qalloc: "(V > 1)" 
 -- Invocation:Qalloc: "V > 1" 
 -- BinaryExp:Qalloc: "V > 1" 
 -- Invocation:Qalloc: "V" 
 -- ObjectInvocation:Qalloc: "V" 
 -- name: "V" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "> 1" 
 -- name: ">" 
 -- Arguments "1" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "1" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  101 5 %basic 53{in V: var integer;out B: var boolean} 
 -- OG:super:  ">  : {   %basic 53;   in V: var integer;   out B: var boolean}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(V > 1)" 
 -- super:  "(V > 1)" 
 -- E:  "(V > 1)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(V > 1)" 
 -- OG:Qalloc: "put('V')" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (V > 1) :then {   put('V')}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "put('V')" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 107 IS.newDescNo: 107 objSize: 0 1: 1 "put('V')" 
 -- Items:Qalloc:objSize: 0  newDescNo: 107 "put('V')" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: "put('V')" qDescno:  0 
 -- OG:Qalloc:A:  "put"  super:  "put('V')"  marked:  false "put('V')" super:  put('V') 
 -- Invocation:Qalloc: "put('V')" 
 -- ObjectInvocation:Qalloc: "put('V')" 
 -- name: "put" 
 -- Arguments "put('V')" 
 -- OG:Qalloc: "'V'" qDescno:  0 
 -- OG:Qalloc:A:  "char"  super:  "'V'"  marked:  false "put('V')" super:  'V' 
 -- Invocation:Qalloc: "'V'" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  7 1 %id "char"{%globals;%basic 3, 16;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var char;   out ...} 
 -- OG:super:  "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;      out R: v ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "'V'" 
 -- super:  "'V'" 
 -- E:  "'V'" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "'V'" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  105 1 %globals{%basic 2;in ch: val char} 
 -- OG:super:  "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "put('V')" 
 -- super:  "put('V')" 
 -- E:  "put('V')" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "put('V')" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 107 "put('V')" 
 -- IS.newDescNo: 107 IS.objSize: 1 "put('V')" 
 -- OG:Qalloc:end: IS.newDescNo:  107 "put('V')" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (V > 1) :then {   put('V')}" 
 -- super:  "if (V > 1) :then {   put('V')}" 
 -- E:  "if (V > 1) :then {   put('V')}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (V > 1) :then {   put('V')}" 
 -- OG:Qalloc: "inner(entry)" qDescno:  0 
 -- OG:Qalloc:A:  "inner"  super:  "inner(entry)"  marked:  false "L.get{V := V + 1;if (V > 1) :then ;   put('V');inner(entry);V := V - 1;L.free}" super:  inner(entry) 
 -- Invocation:Qalloc: "inner(entry)" 
 -- ObjectInvocation:Qalloc: "inner(entry)" 
 -- name: "inner" 
 -- Arguments "inner(entry)" 
 -- OG:Qalloc: "entry" qDescno:  0 
 -- OG:Qalloc:A:  "entry"  super:  "entry"  marked:  false "inner(entry)" super:  entry 
 -- Invocation:Qalloc: "entry" 
 -- ObjectInvocation:Qalloc: "entry" 
 -- name: "entry" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  95 1 L.get{V := V + 1;if (V > 1) :then ;   put('V');inner(entry);V := V - 1;L.free} 
 -- OG:super:  "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "entry" 
 -- super:  "entry" 
 -- E:  "entry" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "entry" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 %basic 101{in inner: ref Object} 
 -- OG:super:  "inner: {   %basic 101;   in inner: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(entry)" 
 -- super:  "inner(entry)" 
 -- E:  "inner(entry)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(entry)" 
 -- Invocation:Qalloc: "V" 
 -- ObjectInvocation:Qalloc: "V" 
 -- name: "V" 
 -- Arguments "" 
 -- OG:Qalloc: "V - 1" qDescno:  0 
 -- OG:Qalloc:A:  "-"  super:  "V - 1"  marked:  false "V := V - 1" super:  V - 1 
 -- Invocation:Qalloc: "V - 1" 
 -- BinaryExp:Qalloc: "V - 1" 
 -- Invocation:Qalloc: "V" 
 -- ObjectInvocation:Qalloc: "V" 
 -- name: "V" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "- 1" 
 -- name: "-" 
 -- Arguments "1" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "1" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 62{in V: var integer;out R: var integer} 
 -- OG:Qalloc:SuperAlloc: "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- OG:Qalloc: "%basic 62{   in V: var integer;   out R: var integer}" qDescno:  0 
 -- OG:Qalloc:A:  "-"  super:  ""  marked:  false "-  : {   %basic 62;   in V: var integer;   out R: var integer}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 62{   in V: var integer;   out R: var integer}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "-" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 108 IS.newDescNo: 108 objSize: 0 1: 1 "%basic 62{in V: var integer;out R: var integer}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 108 "%basic 62{in V: var integer;out R: var integer}" 
 -- Items:Qalloc:Super:C:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- dataitem:qalloc: "R" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 108 "%basic 62{in V: var integer;out R: var integer}" 
 -- IS.newDescNo: 108 IS.objSize: 5 "%basic 62{in V: var integer;out R: var integer}" 
 -- OG:Qalloc:end: IS.newDescNo:  108 "%basic 62{   in V: var integer;   out R: var integer}" 
 -- OG:super:  "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "V - 1" 
 -- super:  "V - 1" 
 -- E:  "V - 1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "V - 1" 
 -- OG:Qalloc: "L.free" qDescno:  0 
 -- OG:Qalloc:A:  "free"  super:  "L.free"  marked:  false "L.get{V := V + 1;if (V > 1) :then ;   put('V');inner(entry);V := V - 1;L.free}" super:  L.free 
 -- Invocation:Qalloc: "L.free" 
 -- ObjectInvocation:Qalloc: "L" 
 -- name: "L" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "free" 
 -- name: "free" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 free_M := 0 
 -- OG:Qalloc:SuperAlloc: "free: {   free_M := 0}" 
 -- OG:Qalloc: "free_M := 0" qDescno:  0 
 -- OG:Qalloc:A:  "free"  super:  ""  marked:  false "free: {   free_M := 0}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "free_M := 0" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "free" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 109 IS.newDescNo: 109 objSize: 0 1: 1 "free_M := 0" 
 -- Items:Qalloc:objSize: 0  newDescNo: 109 "free_M := 0" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Invocation:Qalloc: "free_M" 
 -- ObjectInvocation:Qalloc: "free_M" 
 -- name: "free_M" 
 -- Arguments "" 
 -- OG:Qalloc: "0" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "0"  marked:  false "free_M := 0" super:  0 
 -- Invocation:Qalloc: "0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "0" 
 -- super:  "0" 
 -- E:  "0" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "0" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 109 "free_M := 0" 
 -- IS.newDescNo: 109 IS.objSize: 1 "free_M := 0" 
 -- OG:Qalloc:end: IS.newDescNo:  109 "free_M := 0" 
 -- OG:super:  "free: {   free_M := 0}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L.free" 
 -- super:  "L.free" 
 -- E:  "free" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L.free" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 95 "L.get{V := V + 1;if (V > 1) :then ;   put('V');inner(entry);V := V - 1;L.free}" 
 -- IS.newDescNo: 95 IS.objSize: 1 "L.get{V := V + 1;if (V > 1) :then ;   put('V');inner(entry);V := V - 1;L.free}" 
 -- OG:Qalloc:end: IS.newDescNo:  95 "L.get{   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free}" 
 -- OG:super:  "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "entry{   V := 1;   L.init;   L.id := "SQS";   Q.idf := "SQS:"}" 
 -- super:  "entry" 
 -- E:  "entry" 
 -- OG:Qalloc:B: "init" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 110 IS.newDescNo: 110 objSize: 0 1: 1 "V := 1{L.init;L.id := "SQS";Q.idf := "SQS:"}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 110 "V := 1{L.init;L.id := "SQS";Q.idf := "SQS:"}" 
 -- Items:Qalloc:super: "entry" size: 1 "init" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Invocation:Qalloc: "V" 
 -- ObjectInvocation:Qalloc: "V" 
 -- name: "V" 
 -- Arguments "" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "V := 1" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- OG:Qalloc: "L.init" qDescno:  0 
 -- OG:Qalloc:A:  "init"  super:  "L.init"  marked:  false "V := 1{L.init;L.id := "SQS";Q.idf := "SQS:"}" super:  L.init 
 -- Invocation:Qalloc: "L.init" 
 -- ObjectInvocation:Qalloc: "L" 
 -- name: "L" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "init" 
 -- name: "init" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  81 1 free_M := 0 
 -- OG:super:  "init: {   free_M := 0}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L.init" 
 -- super:  "L.init" 
 -- E:  "init" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L.init" 
 -- Invocation:Qalloc: "L.id" 
 -- ObjectInvocation:Qalloc: "L" 
 -- name: "L" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "id" 
 -- name: "id" 
 -- Arguments "" 
 -- OG:Qalloc: ""SQS"" qDescno:  0 
 -- OG:Qalloc:A:  "String"  super:  ""SQS""  marked:  false "L.id := "SQS"" super:  "SQS" 
 -- Invocation:Qalloc: ""SQS"" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  10 0 %id "String pattern"{%OSDvisibility disguised;%basic 5;%public;length: ;   out V: var integer;   V := get[0] -- ac ...} 
 -- OG:super:  "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- actually an  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""SQS"" 
 -- super:  ""SQS"" 
 -- E:  ""SQS"" 
 -- OG:Qalloc:end: IS.newDescNo:  0 ""SQS"" 
 -- Invocation:Qalloc: "Q.idf" 
 -- ObjectInvocation:Qalloc: "Q" 
 -- name: "Q" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "idf" 
 -- name: "idf" 
 -- Arguments "" 
 -- OG:Qalloc: ""SQS:"" qDescno:  0 
 -- OG:Qalloc:A:  "String"  super:  ""SQS:""  marked:  false "Q.idf := "SQS:"" super:  "SQS:" 
 -- Invocation:Qalloc: ""SQS:"" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  10 0 %id "String pattern"{%OSDvisibility disguised;%basic 5;%public;length: ;   out V: var integer;   V := get[0] -- ac ...} 
 -- OG:super:  "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- actually an  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""SQS:"" 
 -- super:  ""SQS:"" 
 -- E:  ""SQS:"" 
 -- OG:Qalloc:end: IS.newDescNo:  0 ""SQS:"" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 110 "V := 1{L.init;L.id := "SQS";Q.idf := "SQS:"}" 
 -- IS.newDescNo: 110 IS.objSize: 1 "V := 1{L.init;L.id := "SQS";Q.idf := "SQS:"}" 
 -- OG:Qalloc:end: IS.newDescNo:  110 "entry{   V := 1;   L.init;   L.id := "SQS";   Q.idf := "SQS:"}" 
 -- OG:super:  "init: entry{   V := 1;   L.init;   L.id := "SQS";   Q.idf := "SQS:"}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "SQS.init" 
 -- super:  "SQS.init" 
 -- E:  "init" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "SQS.init" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 94 "SQS.init" 
 -- IS.newDescNo: 94 IS.objSize: 1 "SQS.init" 
 -- OG:Qalloc:end: IS.newDescNo:  94 "SQS.init" 
 -- OG:super:  "init: {   SQS.init}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "init" 
 -- super:  "init" 
 -- E:  "init" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "init" 
 -- OG:Qalloc: "inner(BasicSystem)" qDescno:  0 
 -- OG:Qalloc:A:  "inner"  super:  "inner(BasicSystem)"  marked:  false "%public{BasicProcess: GeneralProcess;   mkActive::< ;      -- start and mkActive are identical and one ...}" s ... i ... 
 -- Invocation:Qalloc: "inner(BasicSystem)" 
 -- ObjectInvocation:Qalloc: "inner(BasicSystem)" 
 -- name: "inner" 
 -- Arguments "inner(BasicSystem)" 
 -- OG:Qalloc: "BasicSystem" qDescno:  0 
 -- OG:Qalloc:A:  "BasicSystem"  super:  "BasicSystem"  marked:  false "inner(BasicSystem)" super:  BasicSystem 
 -- Invocation:Qalloc: "BasicSystem" 
 -- ObjectInvocation:Qalloc: "BasicSystem" 
 -- name: "BasicSystem" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  72 9 %public{BasicProcess: GeneralProcess;   mkActive::< ;      -- start and mkActive are identical and one may be elim ...} 
 -- OG:super:  "BasicSystem: {   %public;   BasicProcess: GeneralProcess;      mkActive::< ;         -- start and mkActive are identical and one may be eliminatedstatus := p_s ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "BasicSystem" 
 -- super:  "BasicSystem" 
 -- E:  "BasicSystem" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "BasicSystem" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 %basic 101{in inner: ref Object} 
 -- OG:super:  "inner: {   %basic 101;   in inner: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(BasicSystem)" 
 -- super:  "inner(BasicSystem)" 
 -- E:  "inner(BasicSystem)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(BasicSystem)" 
 -- OG:Qalloc: "cores.init" qDescno:  0 
 -- OG:Qalloc:A:  "init"  super:  "cores.init"  marked:  false "%public{BasicProcess: GeneralProcess;   mkActive::< ;      -- start and mkActive are identical and one may be e ...}" s ... c ... 
 -- Invocation:Qalloc: "cores.init" 
 -- ObjectInvocation:Qalloc: "cores" 
 -- name: "cores" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "init" 
 -- name: "init" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 S: ref Scheduler{C1 := Core;fork(C1);C2 := Core;fork(C2);C3 := Core;fork(C3);C4 := Core;fork(C4);S := Scheduler;C1. ...} 
 -- OG:Qalloc:SuperAlloc: "init: {   S: ref Scheduler;   C1 := Core;   fork(C1);   C2 := Core;   fork(C2);   C3 := Core;   fork(C3);   C4 := Core;   fork(C4);   S := Scheduler ...}" 
 -- OG:Qalloc: "S: ref Scheduler{   C1 := Core;   fork(C1);   C2 := Core;   fork(C2);   C3 := Core;   fork(C3);   C4 := Core;   fork(C4);   S := Scheduler;   C1.attach(S);   S ...}" q ... 0 
 -- OG:Qalloc:A:  "init"  super:  ""  marked:  false "init: {   S: ref Scheduler;   C1 := Core;   fork(C1);   C2 := Core;   fork(C2);   C3 := Core;   fork(C3);   C4 := Core;   ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "S: ref Scheduler{   C1 := Core;   fork(C1);   C2 := Core;   fork(C2);   C3 := Core;   fork(C3);   C4 := Core;   fork(C4);   S := Scheduler;   C1.attach(S);   S := Schedul ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "init" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 111 IS.newDescNo: 111 objSize: 0 1: 1 "S: ref Scheduler{C1 := Core;fork(C1);C2 := Core;fork(C2);C3 := Core;fork(C3);C4 := Core;fork(C4);S := Sch ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 111 "S: ref Scheduler{C1 := Core;fork(C1);C2 := Core;fork(C2);C3 := Core;fork(C3);C4 := Core;fork(C4);S := Scheduler;C1.attach(S);S :=  ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "S" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "S: ref Scheduler" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Invocation:Qalloc: "C1" 
 -- ObjectInvocation:Qalloc: "C1" 
 -- name: "C1" 
 -- Arguments "" 
 -- OG:Qalloc: "Core" qDescno:  0 
 -- OG:Qalloc:A:  "Core"  super:  "Core"  marked:  false "C1 := Core" super:  Core 
 -- Invocation:Qalloc: "Core" 
 -- ObjectInvocation:Qalloc: "Core" 
 -- name: "Core" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %Public{attach: ;   in M: ref Scheduler;   main := M;%Private;dummy: var integer;go: ;   loopX: obj ;      if (main ...} 
 -- OG:Qalloc:SuperAlloc: "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: obj ;        ...}" 
 -- OG:Qalloc: "SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: obj ;         if (main =/= no ...}" q ... 0 
 -- OG:Qalloc:A:  "Core"  super:  "SuperCore"  marked:  false "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integ ...}" s ... S ... 
 -- Invocation:Qalloc: "SuperCore" 
 -- ObjectInvocation:Qalloc: "SuperCore" 
 -- name: "SuperCore" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %core 16{main: ref SuperScheduler;inner(SuperCore)} 
 -- OG:Qalloc:SuperAlloc: "SuperCore: {   %core 16;   main: ref SuperScheduler;   inner(SuperCore)}" 
 -- OG:Qalloc: "%core 16{   main: ref SuperScheduler;   inner(SuperCore)}" qDescno:  0 
 -- OG:Qalloc:A:  "SuperCore"  super:  ""  marked:  false "SuperCore: {   %core 16;   main: ref SuperScheduler;   inner(SuperCore)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%core 16{   main: ref SuperScheduler;   inner(SuperCore)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "SuperCore" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 112 IS.newDescNo: 112 objSize: 0 1: 1 "%core 16{main: ref SuperScheduler;inner(SuperCore)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 112 "%core 16{main: ref SuperScheduler;inner(SuperCore)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "main" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "main: ref SuperScheduler" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- OG:Qalloc: "inner(SuperCore)" qDescno:  0 
 -- OG:Qalloc:A:  "inner"  super:  "inner(SuperCore)"  marked:  false "%core 16{main: ref SuperScheduler;inner(SuperCore)}" super:  inner(SuperCore) 
 -- Invocation:Qalloc: "inner(SuperCore)" 
 -- ObjectInvocation:Qalloc: "inner(SuperCore)" 
 -- name: "inner" 
 -- Arguments "inner(SuperCore)" 
 -- OG:Qalloc: "SuperCore" qDescno:  0 
 -- OG:Qalloc:A:  "SuperCore"  super:  "SuperCore"  marked:  false "inner(SuperCore)" super:  SuperCore 
 -- Invocation:Qalloc: "SuperCore" 
 -- ObjectInvocation:Qalloc: "SuperCore" 
 -- name: "SuperCore" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  112 2 %core 16{main: ref SuperScheduler;inner(SuperCore)} 
 -- OG:super:  "SuperCore: {   %core 16;   main: ref SuperScheduler;   inner(SuperCore)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "SuperCore" 
 -- super:  "SuperCore" 
 -- E:  "SuperCore" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "SuperCore" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 %basic 101{in inner: ref Object} 
 -- OG:super:  "inner: {   %basic 101;   in inner: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(SuperCore)" 
 -- super:  "inner(SuperCore)" 
 -- E:  "inner(SuperCore)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(SuperCore)" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 112 "%core 16{main: ref SuperScheduler;inner(SuperCore)}" 
 -- IS.newDescNo: 112 IS.objSize: 2 "%core 16{main: ref SuperScheduler;inner(SuperCore)}" 
 -- OG:Qalloc:end: IS.newDescNo:  112 "%core 16{   main: ref SuperScheduler;   inner(SuperCore)}" 
 -- OG:super:  "SuperCore: {   %core 16;   main: ref SuperScheduler;   inner(SuperCore)}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: obj ;         if (main =/= none) :then ; ...}" 
 -- super:  "SuperCore" 
 -- E:  "SuperCore" 
 -- OG:Qalloc:B: "Core" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 113 IS.newDescNo: 113 objSize: 0 1: 1 "%Public{attach: ;   in M: ref Scheduler;   main := M;%Private;dummy: var integer;go: ;   loopX: obj ;     ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 113 "%Public{attach: ;   in M: ref Scheduler;   main := M;%Private;dummy: var integer;go: ;   loopX: obj ;      if (main =/= none) :the ...}" 
 -- Items:Qalloc:super: "SuperCore" size: 2 "Core" 
 -- super.isThisBlockLevel: false superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 3 originOff: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- Pattern:Qalloc: attach 
 -- Pattern:Qalloc:B: attach 
 -- dataitem:qalloc: "dummy" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- Pattern:Qalloc: go 
 -- Pattern:Qalloc:B: go 
 -- OG:Qalloc: "(this(Core)).suspend{--main:= none         }" qDescno:  0 
 -- OG:Qalloc:A:  "suspend"  super:  "(this(Core)).suspend{--main:= none         }"  marked:  false "%Public{attach: ;   in M: ref Scheduler;   main := M;%Private;dummy: var i ...}" s ... ( ... 
 -- Invocation:Qalloc: "(this(Core)).suspend{--main:= none         }" 
 -- Invocation:Qalloc: "this(Core)" 
 -- ObjectInvocation:Qalloc: "this(Core)" 
 -- name: "this" 
 -- Arguments "this(Core)" 
 -- OG:Qalloc: "Core" qDescno:  0 
 -- OG:Qalloc:A:  "Core"  super:  "Core"  marked:  false "this(Core)" super:  Core 
 -- Invocation:Qalloc: "Core" 
 -- ObjectInvocation:Qalloc: "Core" 
 -- name: "Core" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  113 4 %Public{attach: ;   in M: ref Scheduler;   main := M;%Private;dummy: var integer;go: ;   loopX: obj ;      if (ma ...} 
 -- OG:super:  "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: obj ;         if (main  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Core" 
 -- super:  "Core" 
 -- E:  "Core" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Core" 
 -- ObjectInvocation:Qalloc: "suspend{--main:= none         }" 
 -- name: "suspend" 
 -- Arguments "--main:= none         " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  84 1 %basic 111 
 -- OG:super:  "suspend: {   %basic 111}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(this(Core)).suspend{--main:= none         }" 
 -- super:  "(this(Core)).suspend{--main:= none         }" 
 -- E:  "suspend{--main:= none         }" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(this(Core)).suspend{--main:= none         }" 
 -- Invocation:Qalloc: "dummy" 
 -- ObjectInvocation:Qalloc: "dummy" 
 -- name: "dummy" 
 -- Arguments "" 
 -- OG:Qalloc: "213" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "213"  marked:  false "dummy := 213" super:  213 
 -- Invocation:Qalloc: "213" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "213" 
 -- super:  "213" 
 -- E:  "213" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "213" 
 -- OG:Qalloc: "go" qDescno:  0 
 -- OG:Qalloc:A:  "go"  super:  "go"  marked:  false "%Public{attach: ;   in M: ref Scheduler;   main := M;%Private;dummy: var integer;go: ;   loopX: obj ;      if (main =/= n ...}" s ... g ... 
 -- Invocation:Qalloc: "go" 
 -- ObjectInvocation:Qalloc: "go" 
 -- name: "go" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 loopX: obj {   if (main =/= none) :then ;      main.call;   :else ;      sleep(100);      restart(loopX)} 
 -- OG:Qalloc:SuperAlloc: "go: {   loopX: obj ;      if (main =/= none) :then ;         main.call;      :else ;         sleep(100);         restart(loopX)}" 
 -- OG:Qalloc: "loopX: obj {      if (main =/= none) :then ;         main.call;      :else ;         sleep(100);         restart(loopX)}" qDescno:  0 
 -- OG:Qalloc:A:  "go"  super:  ""  marked:  false "go: {   loopX: obj ;      if (main =/= none) :then ;         main.call;      :else ;         sleep(100);         restart(lo ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "loopX: obj {      if (main =/= none) :then ;         main.call;      :else ;         sleep(100);         restart(loopX)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "go" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 114 IS.newDescNo: 114 objSize: 0 1: 1 "loopX: obj {   if (main =/= none) :then ;      main.call;   :else ;      sleep(100);      restart(loopX)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 114 "loopX: obj {   if (main =/= none) :then ;      main.call;   :else ;      sleep(100);      restart(loopX)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "loopX" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "loopX: obj {   if (main =/= none) :then ;      main.call;   :else ;      sleep(100);      restart(loopX)}" 
 -- OG:Qalloc: "if (main =/= none) :then {      main.call;   :else ;      sleep(100);      restart(loopX)}" qDescno:  0 
 -- OG:Qalloc:A:  "loopX"  super:  ""  marked:  false "loopX: obj {   if (main =/= none) :then ;      main.call;   :else ;      sleep(100);      restart(loopX)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "if (main =/= none) :then {      main.call;   :else ;      sleep(100);      restart(loopX)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "loopX" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 115 IS.newDescNo: 115 objSize: 0 1: 1 "if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 115 "if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: "if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)}" qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)}"  marked:  false "if (main =/= none) :then {   main.call ...}" s ... i ... 
 -- Invocation:Qalloc: "if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)}" 
 -- OG:Qalloc: "(main =/= none)" qDescno:  0 
 -- OG:Qalloc:A:  "=/="  super:  "(main =/= none)"  marked:  false "if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)}" super:  (main =/= none) 
 -- Invocation:Qalloc: "(main =/= none)" 
 -- Invocation:Qalloc: "main =/= none" 
 -- BinaryExp:Qalloc: "main =/= none" 
 -- Invocation:Qalloc: "main" 
 -- ObjectInvocation:Qalloc: "main" 
 -- name: "main" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "=/= none" 
 -- name: "=/=" 
 -- Arguments "none" 
 -- OG:Qalloc: "none" qDescno:  0 
 -- OG:Qalloc:A:  "none"  super:  "none"  marked:  false "none" super:  none 
 -- Invocation:Qalloc: "none" 
 -- ObjectInvocation:Qalloc: "none" 
 -- name: "none" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 19{none_x: var integer} 
 -- OG:Qalloc:SuperAlloc: "none: {   %basic 19;   none_x: var integer}" 
 -- OG:Qalloc: "%basic 19{   none_x: var integer}" qDescno:  0 
 -- OG:Qalloc:A:  "none"  super:  ""  marked:  false "none: {   %basic 19;   none_x: var integer}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 19{   none_x: var integer}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "none" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 116 IS.newDescNo: 116 objSize: 0 1: 1 "%basic 19{none_x: var integer}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 116 "%basic 19{none_x: var integer}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "none_x" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 116 "%basic 19{none_x: var integer}" 
 -- IS.newDescNo: 116 IS.objSize: 2 "%basic 19{none_x: var integer}" 
 -- OG:Qalloc:end: IS.newDescNo:  116 "%basic 19{   none_x: var integer}" 
 -- OG:super:  "none: {   %basic 19;   none_x: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "none" 
 -- super:  "none" 
 -- E:  "none" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "none" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 57{in objx: ref Object;out V: var boolean} 
 -- OG:Qalloc:SuperAlloc: "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean}" 
 -- OG:Qalloc: "%basic 57{   in objx: ref Object;   out V: var boolean}" qDescno:  0 
 -- OG:Qalloc:A:  "=/="  super:  ""  marked:  false "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 57{   in objx: ref Object;   out V: var boolean}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "=/=" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 117 IS.newDescNo: 117 objSize: 0 1: 1 "%basic 57{in objx: ref Object;out V: var boolean}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 117 "%basic 57{in objx: ref Object;out V: var boolean}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "objx" isValue: false  isPrimitive: true  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "in objx: ref Object" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 117 "%basic 57{in objx: ref Object;out V: var boolean}" 
 -- IS.newDescNo: 117 IS.objSize: 3 "%basic 57{in objx: ref Object;out V: var boolean}" 
 -- OG:Qalloc:end: IS.newDescNo:  117 "%basic 57{   in objx: ref Object;   out V: var boolean}" 
 -- OG:super:  "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(main =/= none)" 
 -- super:  "(main =/= none)" 
 -- E:  "(main =/= none)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(main =/= none)" 
 -- OG:Qalloc: "main.call" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "main.call" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 118 IS.newDescNo: 118 objSize: 0 1: 1 "main.call" 
 -- Items:Qalloc:objSize: 0  newDescNo: 118 "main.call" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: "main.call" qDescno:  0 
 -- OG:Qalloc:A:  "call"  super:  "main.call"  marked:  false "main.call" super:  main.call 
 -- Invocation:Qalloc: "main.call" 
 -- ObjectInvocation:Qalloc: "main" 
 -- name: "main" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "call" 
 -- name: "call" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 113 
 -- OG:Qalloc:SuperAlloc: "call: {   %basic 113}" 
 -- OG:Qalloc: "%basic 113" qDescno:  0 
 -- OG:Qalloc:A:  "call"  super:  ""  marked:  false "call: {   %basic 113}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 113" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "call" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 119 IS.newDescNo: 119 objSize: 0 1: 1 "%basic 113" 
 -- Items:Qalloc:objSize: 0  newDescNo: 119 "%basic 113" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 119 "%basic 113" 
 -- IS.newDescNo: 119 IS.objSize: 1 "%basic 113" 
 -- OG:Qalloc:end: IS.newDescNo:  119 "%basic 113" 
 -- OG:super:  "call: {   %basic 113}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "main.call" 
 -- super:  "main.call" 
 -- E:  "call" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "main.call" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 118 "main.call" 
 -- IS.newDescNo: 118 IS.objSize: 1 "main.call" 
 -- OG:Qalloc:end: IS.newDescNo:  118 "main.call" 
 -- OG:Qalloc: "sleep(100){   restart(loopX)}" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "sleep(100){   restart(loopX)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 120 IS.newDescNo: 120 objSize: 0 1: 1 "sleep(100){restart(loopX)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 120 "sleep(100){restart(loopX)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: "sleep(100)" qDescno:  0 
 -- OG:Qalloc:A:  "sleep"  super:  "sleep(100)"  marked:  false "sleep(100){restart(loopX)}" super:  sleep(100) 
 -- Invocation:Qalloc: "sleep(100)" 
 -- ObjectInvocation:Qalloc: "sleep(100)" 
 -- name: "sleep" 
 -- Arguments "sleep(100)" 
 -- OG:Qalloc: "100" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "100"  marked:  false "sleep(100)" super:  100 
 -- Invocation:Qalloc: "100" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "100" 
 -- super:  "100" 
 -- E:  "100" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "100" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  100 2 %basic 15{in V: var integer} 
 -- OG:super:  "sleep: {   %basic 15;   in V: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "sleep(100)" 
 -- super:  "sleep(100)" 
 -- E:  "sleep(100)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "sleep(100)" 
 -- OG:Qalloc: "restart(loopX)" qDescno:  0 
 -- OG:Qalloc:A:  "restart"  super:  "restart(loopX)"  marked:  false "sleep(100){restart(loopX)}" super:  restart(loopX) 
 -- Invocation:Qalloc: "restart(loopX)" 
 -- ObjectInvocation:Qalloc: "restart(loopX)" 
 -- name: "restart" 
 -- Arguments "restart(loopX)" 
 -- OG:Qalloc: "loopX" qDescno:  0 
 -- OG:Qalloc:A:  "loopX"  super:  "loopX"  marked:  false "restart(loopX)" super:  loopX 
 -- Invocation:Qalloc: "loopX" 
 -- ObjectInvocation:Qalloc: "loopX" 
 -- name: "loopX" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  115 1 if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)} 
 -- OG:super:  "loopX: obj {   if (main =/= none) :then ;      main.call;   :else ;      sleep(100);      restart(loopX)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "loopX" 
 -- super:  "loopX" 
 -- E:  "loopX" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "loopX" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  50 2 %basic 102 
 -- OG:super:  "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "restart(loopX)" 
 -- super:  "restart(loopX)" 
 -- E:  "restart(loopX)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "restart(loopX)" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 120 "sleep(100){restart(loopX)}" 
 -- IS.newDescNo: 120 IS.objSize: 1 "sleep(100){restart(loopX)}" 
 -- OG:Qalloc:end: IS.newDescNo:  120 "sleep(100){   restart(loopX)}" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)}" 
 -- super:  "if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)}" 
 -- E:  "if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)}" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 115 "if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)}" 
 -- IS.newDescNo: 115 IS.objSize: 1 "if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)}" 
 -- OG:Qalloc:end: IS.newDescNo:  115 "if (main =/= none) :then {      main.call;   :else ;      sleep(100);      restart(loopX)}" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 114 "loopX: obj {   if (main =/= none) :then ;      main.call;   :else ;      sleep(100);      restart(loopX)}" 
 -- IS.newDescNo: 114 IS.objSize: 2 "loopX: obj {   if (main =/= none) :then ;      main.call;   :else ;      sleep(100);      restart(loopX)}" 
 -- OG:Qalloc:end: IS.newDescNo:  114 "loopX: obj {      if (main =/= none) :then ;         main.call;      :else ;         sleep(100);         restart(loopX)}" 
 -- OG:super:  "go: {   loopX: obj ;      if (main =/= none) :then ;         main.call;      :else ;         sleep(100);         restart(loopX)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "go" 
 -- super:  "go" 
 -- E:  "go" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "go" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 113 "%Public{attach: ;   in M: ref Scheduler;   main := M;%Private;dummy: var integer;go: ;   loopX: obj ;      if (main =/= none)  ...}" 
 -- IS.newDescNo: 113 IS.objSize: 4 "%Public{attach: ;   in M: ref Scheduler;   main := M;%Private;dummy: var integer;go: ;   loopX: obj ;      if (main =/= none) :then ;      ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  113 "SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: obj ;  ...}" 
 -- OG:super:  "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: obj ;         if (main  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Core" 
 -- super:  "Core" 
 -- E:  "Core" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Core" 
 -- OG:Qalloc: "fork(C1)" qDescno:  0 
 -- OG:Qalloc:A:  "fork"  super:  "fork(C1)"  marked:  false "S: ref Scheduler{C1 := Core;fork(C1);C2 := Core;fork(C2);C3 := Core;fork(C3);C4 := Core;fork(C4);S := Scheduler;C ...}" s ... f ... 
 -- Invocation:Qalloc: "fork(C1)" 
 -- ObjectInvocation:Qalloc: "fork(C1)" 
 -- name: "fork" 
 -- Arguments "fork(C1)" 
 -- OG:Qalloc: "C1" qDescno:  0 
 -- OG:Qalloc:A:  "Core"  super:  "C1"  marked:  false "fork(C1)" super:  C1 
 -- Invocation:Qalloc: "C1" 
 -- ObjectInvocation:Qalloc: "C1" 
 -- name: "C1" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  113 4 %Public{attach: ;   in M: ref Scheduler;   main := M;%Private;dummy: var integer;go: ;   loopX: obj ;      if (ma ...} 
 -- OG:super:  "C1: ref Core" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "C1" 
 -- super:  "C1" 
 -- E:  "C1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "C1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 13{in S: ref Object} 
 -- OG:Qalloc:SuperAlloc: "fork: {   %basic 13;   in S: ref Object}" 
 -- OG:Qalloc: "%basic 13{   in S: ref Object}" qDescno:  0 
 -- OG:Qalloc:A:  "fork"  super:  ""  marked:  false "fork: {   %basic 13;   in S: ref Object}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 13{   in S: ref Object}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "fork" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 121 IS.newDescNo: 121 objSize: 0 1: 1 "%basic 13{in S: ref Object}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 121 "%basic 13{in S: ref Object}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "S" isValue: false  isPrimitive: true  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "in S: ref Object" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 121 "%basic 13{in S: ref Object}" 
 -- IS.newDescNo: 121 IS.objSize: 2 "%basic 13{in S: ref Object}" 
 -- OG:Qalloc:end: IS.newDescNo:  121 "%basic 13{   in S: ref Object}" 
 -- OG:super:  "fork: {   %basic 13;   in S: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "fork(C1)" 
 -- super:  "fork(C1)" 
 -- E:  "fork(C1)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "fork(C1)" 
 -- Invocation:Qalloc: "C2" 
 -- ObjectInvocation:Qalloc: "C2" 
 -- name: "C2" 
 -- Arguments "" 
 -- OG:Qalloc: "Core" qDescno:  0 
 -- OG:Qalloc:A:  "Core"  super:  "Core"  marked:  false "C2 := Core" super:  Core 
 -- Invocation:Qalloc: "Core" 
 -- ObjectInvocation:Qalloc: "Core" 
 -- name: "Core" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  113 4 %Public{attach: ;   in M: ref Scheduler;   main := M;%Private;dummy: var integer;go: ;   loopX: obj ;      if (ma ...} 
 -- OG:super:  "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: obj ;         if (main  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Core" 
 -- super:  "Core" 
 -- E:  "Core" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Core" 
 -- OG:Qalloc: "fork(C2)" qDescno:  0 
 -- OG:Qalloc:A:  "fork"  super:  "fork(C2)"  marked:  false "S: ref Scheduler{C1 := Core;fork(C1);C2 := Core;fork(C2);C3 := Core;fork(C3);C4 := Core;fork(C4);S := Scheduler;C ...}" s ... f ... 
 -- Invocation:Qalloc: "fork(C2)" 
 -- ObjectInvocation:Qalloc: "fork(C2)" 
 -- name: "fork" 
 -- Arguments "fork(C2)" 
 -- OG:Qalloc: "C2" qDescno:  0 
 -- OG:Qalloc:A:  "Core"  super:  "C2"  marked:  false "fork(C2)" super:  C2 
 -- Invocation:Qalloc: "C2" 
 -- ObjectInvocation:Qalloc: "C2" 
 -- name: "C2" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  113 4 %Public{attach: ;   in M: ref Scheduler;   main := M;%Private;dummy: var integer;go: ;   loopX: obj ;      if (ma ...} 
 -- OG:super:  "C2: ref Core" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "C2" 
 -- super:  "C2" 
 -- E:  "C2" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "C2" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  121 2 %basic 13{in S: ref Object} 
 -- OG:super:  "fork: {   %basic 13;   in S: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "fork(C2)" 
 -- super:  "fork(C2)" 
 -- E:  "fork(C2)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "fork(C2)" 
 -- Invocation:Qalloc: "C3" 
 -- ObjectInvocation:Qalloc: "C3" 
 -- name: "C3" 
 -- Arguments "" 
 -- OG:Qalloc: "Core" qDescno:  0 
 -- OG:Qalloc:A:  "Core"  super:  "Core"  marked:  false "C3 := Core" super:  Core 
 -- Invocation:Qalloc: "Core" 
 -- ObjectInvocation:Qalloc: "Core" 
 -- name: "Core" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  113 4 %Public{attach: ;   in M: ref Scheduler;   main := M;%Private;dummy: var integer;go: ;   loopX: obj ;      if (ma ...} 
 -- OG:super:  "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: obj ;         if (main  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Core" 
 -- super:  "Core" 
 -- E:  "Core" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Core" 
 -- OG:Qalloc: "fork(C3)" qDescno:  0 
 -- OG:Qalloc:A:  "fork"  super:  "fork(C3)"  marked:  false "S: ref Scheduler{C1 := Core;fork(C1);C2 := Core;fork(C2);C3 := Core;fork(C3);C4 := Core;fork(C4);S := Scheduler;C ...}" s ... f ... 
 -- Invocation:Qalloc: "fork(C3)" 
 -- ObjectInvocation:Qalloc: "fork(C3)" 
 -- name: "fork" 
 -- Arguments "fork(C3)" 
 -- OG:Qalloc: "C3" qDescno:  0 
 -- OG:Qalloc:A:  "Core"  super:  "C3"  marked:  false "fork(C3)" super:  C3 
 -- Invocation:Qalloc: "C3" 
 -- ObjectInvocation:Qalloc: "C3" 
 -- name: "C3" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  113 4 %Public{attach: ;   in M: ref Scheduler;   main := M;%Private;dummy: var integer;go: ;   loopX: obj ;      if (ma ...} 
 -- OG:super:  "C3: ref Core" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "C3" 
 -- super:  "C3" 
 -- E:  "C3" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "C3" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  121 2 %basic 13{in S: ref Object} 
 -- OG:super:  "fork: {   %basic 13;   in S: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "fork(C3)" 
 -- super:  "fork(C3)" 
 -- E:  "fork(C3)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "fork(C3)" 
 -- Invocation:Qalloc: "C4" 
 -- ObjectInvocation:Qalloc: "C4" 
 -- name: "C4" 
 -- Arguments "" 
 -- OG:Qalloc: "Core" qDescno:  0 
 -- OG:Qalloc:A:  "Core"  super:  "Core"  marked:  false "C4 := Core" super:  Core 
 -- Invocation:Qalloc: "Core" 
 -- ObjectInvocation:Qalloc: "Core" 
 -- name: "Core" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  113 4 %Public{attach: ;   in M: ref Scheduler;   main := M;%Private;dummy: var integer;go: ;   loopX: obj ;      if (ma ...} 
 -- OG:super:  "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: obj ;         if (main  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Core" 
 -- super:  "Core" 
 -- E:  "Core" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Core" 
 -- OG:Qalloc: "fork(C4)" qDescno:  0 
 -- OG:Qalloc:A:  "fork"  super:  "fork(C4)"  marked:  false "S: ref Scheduler{C1 := Core;fork(C1);C2 := Core;fork(C2);C3 := Core;fork(C3);C4 := Core;fork(C4);S := Scheduler;C ...}" s ... f ... 
 -- Invocation:Qalloc: "fork(C4)" 
 -- ObjectInvocation:Qalloc: "fork(C4)" 
 -- name: "fork" 
 -- Arguments "fork(C4)" 
 -- OG:Qalloc: "C4" qDescno:  0 
 -- OG:Qalloc:A:  "Core"  super:  "C4"  marked:  false "fork(C4)" super:  C4 
 -- Invocation:Qalloc: "C4" 
 -- ObjectInvocation:Qalloc: "C4" 
 -- name: "C4" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  113 4 %Public{attach: ;   in M: ref Scheduler;   main := M;%Private;dummy: var integer;go: ;   loopX: obj ;      if (ma ...} 
 -- OG:super:  "C4: ref Core{-- should be array         }" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "C4" 
 -- super:  "C4" 
 -- E:  "C4" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "C4" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  121 2 %basic 13{in S: ref Object} 
 -- OG:super:  "fork: {   %basic 13;   in S: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "fork(C4)" 
 -- super:  "fork(C4)" 
 -- E:  "fork(C4)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "fork(C4)" 
 -- Invocation:Qalloc: "S" 
 -- ObjectInvocation:Qalloc: "S" 
 -- name: "S" 
 -- Arguments "" 
 -- OG:Qalloc: "Scheduler" qDescno:  0 
 -- OG:Qalloc:A:  "Scheduler"  super:  "Scheduler"  marked:  false "S := Scheduler" super:  Scheduler 
 -- Invocation:Qalloc: "Scheduler" 
 -- ObjectInvocation:Qalloc: "Scheduler" 
 -- name: "Scheduler" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 thisScheduler::< Scheduler{ProcessType::< BasicProcess;%Public;%Private;dummyB: var Boolean;inScheduler: var Boolea ...} 
 -- OG:Qalloc:SuperAlloc: "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB: var Boolean;   inScheduler: ...}" 
 -- OG:Qalloc: "SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB: var Boolean;   inScheduler: var Boolean;   P: ref ...}" q ... 0 
 -- OG:Qalloc:A:  "Scheduler"  super:  "SuperScheduler"  marked:  false "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   % ...}" s ... S ... 
 -- Invocation:Qalloc: "SuperScheduler" 
 -- ObjectInvocation:Qalloc: "SuperScheduler" 
 -- name: "SuperScheduler" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 thisScheduler:< Object{ProcessType:< GeneralProcess;active: ref ProcessType;inner(SuperScheduler)} 
 -- OG:Qalloc:SuperAlloc: "SuperScheduler: {   thisScheduler:< Object;   ProcessType:< GeneralProcess;   active: ref ProcessType;   inner(SuperScheduler)}" 
 -- OG:Qalloc: "thisScheduler:< Object{   ProcessType:< GeneralProcess;   active: ref ProcessType;   inner(SuperScheduler)}" qDescno:  0 
 -- OG:Qalloc:A:  "SuperScheduler"  super:  ""  marked:  false "SuperScheduler: {   thisScheduler:< Object;   ProcessType:< GeneralProcess;   active: ref ProcessType;   inner( ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "thisScheduler:< Object{   ProcessType:< GeneralProcess;   active: ref ProcessType;   inner(SuperScheduler)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "SuperScheduler" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 122 IS.newDescNo: 122 objSize: 0 1: 1 "thisScheduler:< Object{ProcessType:< GeneralProcess;active: ref ProcessType;inner(SuperScheduler)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 122 "thisScheduler:< Object{ProcessType:< GeneralProcess;active: ref ProcessType;inner(SuperScheduler)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Pattern:Qalloc: thisScheduler 
 -- Pattern:Qalloc:B: thisScheduler 
 -- Pattern:Qalloc: thisScheduler$123 
 -- Pattern:Qalloc:B: thisScheduler$123 
 -- Pattern:Qalloc: ProcessType 
 -- Pattern:Qalloc:B: ProcessType 
 -- Pattern:Qalloc: ProcessType$124 
 -- Pattern:Qalloc:B: ProcessType$124 
 -- dataitem:qalloc: "active" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "active: ref ProcessType" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- OG:Qalloc: "inner(SuperScheduler)" qDescno:  0 
 -- OG:Qalloc:A:  "inner"  super:  "inner(SuperScheduler)"  marked:  false "thisScheduler:< Object{ProcessType:< GeneralProcess;active: ref ProcessType;inner(SuperScheduler)}" s ... i ... 
 -- Invocation:Qalloc: "inner(SuperScheduler)" 
 -- ObjectInvocation:Qalloc: "inner(SuperScheduler)" 
 -- name: "inner" 
 -- Arguments "inner(SuperScheduler)" 
 -- OG:Qalloc: "SuperScheduler" qDescno:  0 
 -- OG:Qalloc:A:  "SuperScheduler"  super:  "SuperScheduler"  marked:  false "inner(SuperScheduler)" super:  SuperScheduler 
 -- Invocation:Qalloc: "SuperScheduler" 
 -- ObjectInvocation:Qalloc: "SuperScheduler" 
 -- name: "SuperScheduler" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  122 2 thisScheduler:< Object{ProcessType:< GeneralProcess;active: ref ProcessType;inner(SuperScheduler)} 
 -- OG:super:  "SuperScheduler: {   thisScheduler:< Object;   ProcessType:< GeneralProcess;   active: ref ProcessType;   inner(SuperScheduler)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "SuperScheduler" 
 -- super:  "SuperScheduler" 
 -- E:  "SuperScheduler" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "SuperScheduler" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 %basic 101{in inner: ref Object} 
 -- OG:super:  "inner: {   %basic 101;   in inner: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(SuperScheduler)" 
 -- super:  "inner(SuperScheduler)" 
 -- E:  "inner(SuperScheduler)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(SuperScheduler)" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 122 "thisScheduler:< Object{ProcessType:< GeneralProcess;active: ref ProcessType;inner(SuperScheduler)}" 
 -- IS.newDescNo: 122 IS.objSize: 2 "thisScheduler:< Object{ProcessType:< GeneralProcess;active: ref ProcessType;inner(SuperScheduler)}" 
 -- OG:Qalloc:end: IS.newDescNo:  122 "thisScheduler:< Object{   ProcessType:< GeneralProcess;   active: ref ProcessType;   inner(SuperScheduler)}" 
 -- OG:super:  "SuperScheduler: {   thisScheduler:< Object;   ProcessType:< GeneralProcess;   active: ref ProcessType;   inner(SuperScheduler)}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB: var Boolean;   inScheduler: var Boolean;   P: ref BasicProce ...}" 
 -- super:  "SuperScheduler" 
 -- E:  "SuperScheduler" 
 -- OG:Qalloc:B: "Scheduler" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 125 IS.newDescNo: 125 objSize: 0 1: 1 "thisScheduler::< Scheduler{ProcessType::< BasicProcess;%Public;%Private;dummyB: var Boolean;inScheduler:  ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 125 "thisScheduler::< Scheduler{ProcessType::< BasicProcess;%Public;%Private;dummyB: var Boolean;inScheduler: var Boolean;P: ref BasicP ...}" 
 -- Items:Qalloc:super: "SuperScheduler" size: 2 "Scheduler" 
 -- super.isThisBlockLevel: false superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 3 originOff: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- Pattern:Qalloc: thisScheduler 
 -- Pattern:Qalloc:B: thisScheduler 
 -- Pattern:Qalloc: thisScheduler$126 
 -- Pattern:Qalloc:B: thisScheduler$126 
 -- Pattern:Qalloc: ProcessType 
 -- Pattern:Qalloc:B: ProcessType 
 -- Pattern:Qalloc: ProcessType$127 
 -- Pattern:Qalloc:B: ProcessType$127 
 -- dataitem:qalloc: "dummyB" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- dataitem:qalloc: "inScheduler" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- dataitem:qalloc: "P" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 6 "P: ref BasicProcess" 
 -- Items:Qalloc:objSize: 6  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 6  newDescNo: 0 "" 
 -- OG:Qalloc: "(this(Scheduler)).suspend" qDescno:  0 
 -- OG:Qalloc:A:  "suspend"  super:  "(this(Scheduler)).suspend"  marked:  false "thisScheduler::< Scheduler{ProcessType::< BasicProcess;%Public;%Private;dummyB: var Boolean;i ...}" s ... ( ... 
 -- Invocation:Qalloc: "(this(Scheduler)).suspend" 
 -- Invocation:Qalloc: "this(Scheduler)" 
 -- ObjectInvocation:Qalloc: "this(Scheduler)" 
 -- name: "this" 
 -- Arguments "this(Scheduler)" 
 -- OG:Qalloc: "Scheduler" qDescno:  0 
 -- OG:Qalloc:A:  "Scheduler"  super:  "Scheduler"  marked:  false "this(Scheduler)" super:  Scheduler 
 -- Invocation:Qalloc: "Scheduler" 
 -- ObjectInvocation:Qalloc: "Scheduler" 
 -- name: "Scheduler" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  125 6 thisScheduler::< Scheduler{ProcessType::< BasicProcess;%Public;%Private;dummyB: var Boolean;inScheduler: var Bool ...} 
 -- OG:super:  "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB: var Boolean;   inScheduler: var Boolea ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Scheduler" 
 -- super:  "Scheduler" 
 -- E:  "Scheduler" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Scheduler" 
 -- ObjectInvocation:Qalloc: "suspend" 
 -- name: "suspend" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  84 1 %basic 111 
 -- OG:super:  "suspend: {   %basic 111}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(this(Scheduler)).suspend" 
 -- super:  "(this(Scheduler)).suspend" 
 -- E:  "suspend" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(this(Scheduler)).suspend" 
 -- OG:Qalloc: "sch.add" qDescno:  0 
 -- OG:Qalloc:A:  "add"  super:  "sch.add"  marked:  false "thisScheduler::< Scheduler{ProcessType::< BasicProcess;%Public;%Private;dummyB: var Boolean;inScheduler: var Boolea ...}" s ... s ... 
 -- Invocation:Qalloc: "sch.add" 
 -- ObjectInvocation:Qalloc: "sch" 
 -- name: "sch" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "add" 
 -- name: "add" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 entry{   M := M + 1} 
 -- OG:Qalloc:SuperAlloc: "add: {   entry;      M := M + 1}" 
 -- OG:Qalloc: "entry{      M := M + 1}" qDescno:  0 
 -- OG:Qalloc:A:  "add"  super:  ""  marked:  false "add: {   entry;      M := M + 1}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "entry{      M := M + 1}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "add" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 128 IS.newDescNo: 128 objSize: 0 1: 1 "entry{   M := M + 1}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 128 "entry{   M := M + 1}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- OG:Qalloc: "entry{   M := M + 1}" qDescno:  0 
 -- OG:Qalloc:A:  "entry$0"  super:  "entry"  marked:  false "entry{   M := M + 1}" super:  entry 
 -- Invocation:Qalloc: "entry" 
 -- ObjectInvocation:Qalloc: "entry" 
 -- name: "entry" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 L.get{inner(entry);L.free} 
 -- OG:Qalloc:SuperAlloc: "entry: {   L.get;   inner(entry);   L.free}" 
 -- OG:Qalloc: "L.get{   inner(entry);   L.free}" qDescno:  0 
 -- OG:Qalloc:A:  "entry"  super:  ""  marked:  false "entry: {   L.get;   inner(entry);   L.free}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L.get{   inner(entry);   L.free}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "entry" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 129 IS.newDescNo: 129 objSize: 0 1: 1 "L.get{inner(entry);L.free}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 129 "L.get{inner(entry);L.free}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- OG:Qalloc: "L.get" qDescno:  0 
 -- OG:Qalloc:A:  "get"  super:  "L.get"  marked:  false "L.get{inner(entry);L.free}" super:  L.get 
 -- Invocation:Qalloc: "L.get" 
 -- ObjectInvocation:Qalloc: "L" 
 -- name: "L" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "get" 
 -- name: "get" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  96 2 loop: obj {   res: var integer;   i: var integer;   --disable;   res := free_M.cmpAndSwap(1);   if (res = 1) :then ...} 
 -- OG:super:  "get: {   loop: obj ;      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);      if (res = 1) :then ;         --enablesl ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L.get" 
 -- super:  "L.get" 
 -- E:  "get" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L.get" 
 -- OG:Qalloc: "inner(entry)" qDescno:  0 
 -- OG:Qalloc:A:  "inner"  super:  "inner(entry)"  marked:  false "L.get{inner(entry);L.free}" super:  inner(entry) 
 -- Invocation:Qalloc: "inner(entry)" 
 -- ObjectInvocation:Qalloc: "inner(entry)" 
 -- name: "inner" 
 -- Arguments "inner(entry)" 
 -- OG:Qalloc: "entry" qDescno:  0 
 -- OG:Qalloc:A:  "entry"  super:  "entry"  marked:  false "inner(entry)" super:  entry 
 -- Invocation:Qalloc: "entry" 
 -- ObjectInvocation:Qalloc: "entry" 
 -- name: "entry" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  129 1 L.get{inner(entry);L.free} 
 -- OG:super:  "entry: {   L.get;   inner(entry);   L.free}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "entry" 
 -- super:  "entry" 
 -- E:  "entry" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "entry" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 %basic 101{in inner: ref Object} 
 -- OG:super:  "inner: {   %basic 101;   in inner: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(entry)" 
 -- super:  "inner(entry)" 
 -- E:  "inner(entry)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(entry)" 
 -- OG:Qalloc: "L.free" qDescno:  0 
 -- OG:Qalloc:A:  "free"  super:  "L.free"  marked:  false "L.get{inner(entry);L.free}" super:  L.free 
 -- Invocation:Qalloc: "L.free" 
 -- ObjectInvocation:Qalloc: "L" 
 -- name: "L" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "free" 
 -- name: "free" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  109 1 free_M := 0 
 -- OG:super:  "free: {   free_M := 0}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L.free" 
 -- super:  "L.free" 
 -- E:  "free" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L.free" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 129 "L.get{inner(entry);L.free}" 
 -- IS.newDescNo: 129 IS.objSize: 1 "L.get{inner(entry);L.free}" 
 -- OG:Qalloc:end: IS.newDescNo:  129 "L.get{   inner(entry);   L.free}" 
 -- OG:super:  "entry: {   L.get;   inner(entry);   L.free}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "entry{   M := M + 1}" 
 -- super:  "entry" 
 -- E:  "entry" 
 -- OG:Qalloc:B: "entry$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 130 IS.newDescNo: 130 objSize: 0 1: 1 "M := M + 1" 
 -- Items:Qalloc:objSize: 0  newDescNo: 130 "M := M + 1" 
 -- Items:Qalloc:super: "entry" size: 1 "entry$130" 
 -- super.isThisBlockLevel: false superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 2 originOff: 2 
 -- Invocation:Qalloc: "M" 
 -- ObjectInvocation:Qalloc: "M" 
 -- name: "M" 
 -- Arguments "" 
 -- OG:Qalloc: "M + 1" qDescno:  0 
 -- OG:Qalloc:A:  "+"  super:  "M + 1"  marked:  false "M := M + 1" super:  M + 1 
 -- Invocation:Qalloc: "M + 1" 
 -- BinaryExp:Qalloc: "M + 1" 
 -- Invocation:Qalloc: "M" 
 -- ObjectInvocation:Qalloc: "M" 
 -- name: "M" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "+ 1" 
 -- name: "+" 
 -- Arguments "1" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "1" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  49 5 %basic 61{in V: var integer;out R: var integer} 
 -- OG:super:  "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "M + 1" 
 -- super:  "M + 1" 
 -- E:  "M + 1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "M + 1" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 130 "M := M + 1" 
 -- IS.newDescNo: 130 IS.objSize: 2 "M := M + 1" 
 -- OG:Qalloc:end: IS.newDescNo:  130 "entry{   M := M + 1}" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 128 "entry{   M := M + 1}" 
 -- IS.newDescNo: 128 IS.objSize: 1 "entry{   M := M + 1}" 
 -- OG:Qalloc:end: IS.newDescNo:  128 "entry{      M := M + 1}" 
 -- OG:super:  "add: {   entry;      M := M + 1}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "sch.add" 
 -- super:  "sch.add" 
 -- E:  "add" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "sch.add" 
 -- Items:Qalloc:END:objSize: 6  newDescNo: 125 "thisScheduler::< Scheduler{ProcessType::< BasicProcess;%Public;%Private;dummyB: var Boolean;inScheduler: var Boolean;P: ref Ba ...}" 
 -- IS.newDescNo: 125 IS.objSize: 6 "thisScheduler::< Scheduler{ProcessType::< BasicProcess;%Public;%Private;dummyB: var Boolean;inScheduler: var Boolean;P: ref BasicProcess;( ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  125 "SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB: var Boolean;   inScheduler ...}" 
 -- OG:super:  "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB: var Boolean;   inScheduler: var Boolea ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Scheduler" 
 -- super:  "Scheduler" 
 -- E:  "Scheduler" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Scheduler" 
 -- OG:Qalloc: "C1.attach(S)" qDescno:  0 
 -- OG:Qalloc:A:  "attach"  super:  "C1.attach(S)"  marked:  false "S: ref Scheduler{C1 := Core;fork(C1);C2 := Core;fork(C2);C3 := Core;fork(C3);C4 := Core;fork(C4);S := Sched ...}" s ... C ... 
 -- Invocation:Qalloc: "C1.attach(S)" 
 -- ObjectInvocation:Qalloc: "C1" 
 -- name: "C1" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "attach(S)" 
 -- name: "attach" 
 -- Arguments "attach(S)" 
 -- OG:Qalloc: "S" qDescno:  0 
 -- OG:Qalloc:A:  "Scheduler"  super:  "S"  marked:  false "attach(S)" super:  S 
 -- Invocation:Qalloc: "S" 
 -- ObjectInvocation:Qalloc: "S" 
 -- name: "S" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  125 6 thisScheduler::< Scheduler{ProcessType::< BasicProcess;%Public;%Private;dummyB: var Boolean;inScheduler: var Bool ...} 
 -- OG:super:  "S: ref Scheduler" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "S" 
 -- super:  "S" 
 -- E:  "S" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "S" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 in M: ref Scheduler{main := M} 
 -- OG:Qalloc:SuperAlloc: "attach: {   in M: ref Scheduler;   main := M}" 
 -- OG:Qalloc: "in M: ref Scheduler{   main := M}" qDescno:  0 
 -- OG:Qalloc:A:  "attach"  super:  ""  marked:  false "attach: {   in M: ref Scheduler;   main := M}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "in M: ref Scheduler{   main := M}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "attach" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 131 IS.newDescNo: 131 objSize: 0 1: 1 "in M: ref Scheduler{main := M}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 131 "in M: ref Scheduler{main := M}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "M" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "in M: ref Scheduler" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Invocation:Qalloc: "main" 
 -- ObjectInvocation:Qalloc: "main" 
 -- name: "main" 
 -- Arguments "" 
 -- OG:Qalloc: "M" qDescno:  0 
 -- OG:Qalloc:A:  "Scheduler"  super:  "M"  marked:  false "main := M" super:  M 
 -- Invocation:Qalloc: "M" 
 -- ObjectInvocation:Qalloc: "M" 
 -- name: "M" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  125 6 thisScheduler::< Scheduler{ProcessType::< BasicProcess;%Public;%Private;dummyB: var Boolean;inScheduler: var Bool ...} 
 -- OG:super:  "in M: ref Scheduler" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "M" 
 -- super:  "M" 
 -- E:  "M" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "M" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 131 "in M: ref Scheduler{main := M}" 
 -- IS.newDescNo: 131 IS.objSize: 2 "in M: ref Scheduler{main := M}" 
 -- OG:Qalloc:end: IS.newDescNo:  131 "in M: ref Scheduler{   main := M}" 
 -- OG:super:  "attach: {   in M: ref Scheduler;   main := M}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "C1.attach(S)" 
 -- super:  "C1.attach(S)" 
 -- E:  "attach(S)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "C1.attach(S)" 
 -- Invocation:Qalloc: "S" 
 -- ObjectInvocation:Qalloc: "S" 
 -- name: "S" 
 -- Arguments "" 
 -- OG:Qalloc: "Scheduler" qDescno:  0 
 -- OG:Qalloc:A:  "Scheduler"  super:  "Scheduler"  marked:  false "S := Scheduler" super:  Scheduler 
 -- Invocation:Qalloc: "Scheduler" 
 -- ObjectInvocation:Qalloc: "Scheduler" 
 -- name: "Scheduler" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  125 6 thisScheduler::< Scheduler{ProcessType::< BasicProcess;%Public;%Private;dummyB: var Boolean;inScheduler: var Bool ...} 
 -- OG:super:  "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB: var Boolean;   inScheduler: var Boolea ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Scheduler" 
 -- super:  "Scheduler" 
 -- E:  "Scheduler" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Scheduler" 
 -- OG:Qalloc: "C2.attach(S)" qDescno:  0 
 -- OG:Qalloc:A:  "attach"  super:  "C2.attach(S)"  marked:  false "S: ref Scheduler{C1 := Core;fork(C1);C2 := Core;fork(C2);C3 := Core;fork(C3);C4 := Core;fork(C4);S := Sched ...}" s ... C ... 
 -- Invocation:Qalloc: "C2.attach(S)" 
 -- ObjectInvocation:Qalloc: "C2" 
 -- name: "C2" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "attach(S)" 
 -- name: "attach" 
 -- Arguments "attach(S)" 
 -- OG:Qalloc: "S" qDescno:  0 
 -- OG:Qalloc:A:  "Scheduler"  super:  "S"  marked:  false "attach(S)" super:  S 
 -- Invocation:Qalloc: "S" 
 -- ObjectInvocation:Qalloc: "S" 
 -- name: "S" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  125 6 thisScheduler::< Scheduler{ProcessType::< BasicProcess;%Public;%Private;dummyB: var Boolean;inScheduler: var Bool ...} 
 -- OG:super:  "S: ref Scheduler" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "S" 
 -- super:  "S" 
 -- E:  "S" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "S" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  131 2 in M: ref Scheduler{main := M} 
 -- OG:super:  "attach: {   in M: ref Scheduler;   main := M}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "C2.attach(S)" 
 -- super:  "C2.attach(S)" 
 -- E:  "attach(S)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "C2.attach(S)" 
 -- Invocation:Qalloc: "S" 
 -- ObjectInvocation:Qalloc: "S" 
 -- name: "S" 
 -- Arguments "" 
 -- OG:Qalloc: "Scheduler" qDescno:  0 
 -- OG:Qalloc:A:  "Scheduler"  super:  "Scheduler"  marked:  false "S := Scheduler" super:  Scheduler 
 -- Invocation:Qalloc: "Scheduler" 
 -- ObjectInvocation:Qalloc: "Scheduler" 
 -- name: "Scheduler" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  125 6 thisScheduler::< Scheduler{ProcessType::< BasicProcess;%Public;%Private;dummyB: var Boolean;inScheduler: var Bool ...} 
 -- OG:super:  "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB: var Boolean;   inScheduler: var Boolea ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Scheduler" 
 -- super:  "Scheduler" 
 -- E:  "Scheduler" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Scheduler" 
 -- OG:Qalloc: "C3.attach(S)" qDescno:  0 
 -- OG:Qalloc:A:  "attach"  super:  "C3.attach(S)"  marked:  false "S: ref Scheduler{C1 := Core;fork(C1);C2 := Core;fork(C2);C3 := Core;fork(C3);C4 := Core;fork(C4);S := Sched ...}" s ... C ... 
 -- Invocation:Qalloc: "C3.attach(S)" 
 -- ObjectInvocation:Qalloc: "C3" 
 -- name: "C3" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "attach(S)" 
 -- name: "attach" 
 -- Arguments "attach(S)" 
 -- OG:Qalloc: "S" qDescno:  0 
 -- OG:Qalloc:A:  "Scheduler"  super:  "S"  marked:  false "attach(S)" super:  S 
 -- Invocation:Qalloc: "S" 
 -- ObjectInvocation:Qalloc: "S" 
 -- name: "S" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  125 6 thisScheduler::< Scheduler{ProcessType::< BasicProcess;%Public;%Private;dummyB: var Boolean;inScheduler: var Bool ...} 
 -- OG:super:  "S: ref Scheduler" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "S" 
 -- super:  "S" 
 -- E:  "S" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "S" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  131 2 in M: ref Scheduler{main := M} 
 -- OG:super:  "attach: {   in M: ref Scheduler;   main := M}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "C3.attach(S)" 
 -- super:  "C3.attach(S)" 
 -- E:  "attach(S)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "C3.attach(S)" 
 -- OG:Qalloc: "C4.attach(Scheduler)" qDescno:  0 
 -- OG:Qalloc:A:  "attach"  super:  "C4.attach(Scheduler)"  marked:  false "S: ref Scheduler{C1 := Core;fork(C1);C2 := Core;fork(C2);C3 := Core;fork(C3);C4 := Core;fork(C4);S  ...}" s ... C ... 
 -- Invocation:Qalloc: "C4.attach(Scheduler)" 
 -- ObjectInvocation:Qalloc: "C4" 
 -- name: "C4" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "attach(Scheduler)" 
 -- name: "attach" 
 -- Arguments "attach(Scheduler)" 
 -- OG:Qalloc: "Scheduler" qDescno:  0 
 -- OG:Qalloc:A:  "Scheduler"  super:  "Scheduler"  marked:  false "attach(Scheduler)" super:  Scheduler 
 -- Invocation:Qalloc: "Scheduler" 
 -- ObjectInvocation:Qalloc: "Scheduler" 
 -- name: "Scheduler" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  125 6 thisScheduler::< Scheduler{ProcessType::< BasicProcess;%Public;%Private;dummyB: var Boolean;inScheduler: var Bool ...} 
 -- OG:super:  "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB: var Boolean;   inScheduler: var Boolea ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Scheduler" 
 -- super:  "Scheduler" 
 -- E:  "Scheduler" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Scheduler" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  131 2 in M: ref Scheduler{main := M} 
 -- OG:super:  "attach: {   in M: ref Scheduler;   main := M}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "C4.attach(Scheduler)" 
 -- super:  "C4.attach(Scheduler)" 
 -- E:  "attach(Scheduler)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "C4.attach(Scheduler)" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 111 "S: ref Scheduler{C1 := Core;fork(C1);C2 := Core;fork(C2);C3 := Core;fork(C3);C4 := Core;fork(C4);S := Scheduler;C1.attach(S);S ...}" 
 -- IS.newDescNo: 111 IS.objSize: 2 "S: ref Scheduler{C1 := Core;fork(C1);C2 := Core;fork(C2);C3 := Core;fork(C3);C4 := Core;fork(C4);S := Scheduler;C1.attach(S);S := Schedule ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  111 "S: ref Scheduler{   C1 := Core;   fork(C1);   C2 := Core;   fork(C2);   C3 := Core;   fork(C3);   C4 := Core;   fork(C4);   S := Schedul ...}" 
 -- OG:super:  "init: {   S: ref Scheduler;   C1 := Core;   fork(C1);   C2 := Core;   fork(C2);   C3 := Core;   fork(C3);   C4 := Core;   fork(C4);   S := Scheduler;   C1.atta ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "cores.init" 
 -- super:  "cores.init" 
 -- E:  "init" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "cores.init" 
 -- Items:Qalloc:END:objSize: 9  newDescNo: 72 "%public{BasicProcess: GeneralProcess;   mkActive::< ;      -- start and mkActive are identical and one may be eliminatedstatus  ...}" 
 -- IS.newDescNo: 72 IS.objSize: 9 "%public{BasicProcess: GeneralProcess;   mkActive::< ;      -- start and mkActive are identical and one may be eliminatedstatus := p_status. ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  72 "%public{   BasicProcess: GeneralProcess;      mkActive::< ;         -- start and mkActive are identical and one may be eliminatedstatus : ...}" 
 -- ObjTmpStack:add: "BasicSystem" : "%public{   BasicProcess: GeneralProcess;      mkActive::< ;         -- start and mkActive are identical and one may be eliminatedstatus : ...}" 
 -- items:markForCodeGen: "%public{BasicProcess: GeneralProcess;   mkActive::< ;      -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;   ...}" 
 -- markItem: "%public" Property 
 -- DataItem:markForCodeGen: "noOfCores" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "4" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "4" 
 -- "4" true 
 -- 
 -- OG:markSuper: "4" 
 -- Invocation:markForCodeGen: "4" 
 -- not ObjDesc:  "4"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "cores" :descNo: 73 :OG.primNo: 0 
 -- OG:markForCodeGen: "C1: ref Core{   C2: ref Core;   C3: ref Core;   C4: ref Core;   -- should be array         ;   init: ;      S: ref Scheduler;      C1 := Core;      for ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "C1: ref Core{   C2: ref Core;   C3: ref Core;   C4: ref Core;   -- should be array         ;   init: ;      S: ref Scheduler;      C1 := Core;      fork(C1);   ...}" 
 -- OG:Qalloc: "C1: ref Core{   C2: ref Core;   C3: ref Core;   C4: ref Core;   -- should be array         ;   init: ;      S: ref Scheduler;      C1 := Core;      fork(C1);   ...}" q ... 73 
 -- ObjTmpStack:add: "cores" : "C1: ref Core{   C2: ref Core;   C3: ref Core;   C4: ref Core;   -- should be array         ;   init: ;      S: ref Scheduler;      C1 := Core;  ...}" 
 -- items:markForCodeGen: "C1: ref Core{C2: ref Core;C3: ref Core;C4: ref Core;-- should be array         ;init: ;   S: ref Scheduler;   C1 := Core;   fork(C1);   C2 := Core;  ...}" 
 -- DataItem:markForCodeGen: "C1" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Core" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Core" 
 -- "Core" false 
 -- 
 -- OG:markForCodeGen: "SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: obj ;         if (mai ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "SuperCore" 
 -- "SuperCore" false 
 -- 
 -- OG:markSuper: "SuperCore" 
 -- Invocation:markForCodeGen: "SuperCore" 
 -- ObjectInvocation:markForCodeGen: "SuperCore"  ATd: "SuperCore: {   %core 16;   main: ref SuperScheduler;   inner(SuperCore)}" 
 -- Pattern:markForCodeGen: "SuperCore: {   %core 16;   main: ref SuperScheduler;   inner(SuperCore)}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "%core 16{   main: ref SuperScheduler;   inner(SuperCore)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%core 16{   main: ref SuperScheduler;   inner(SuperCore)}" 
 -- OG:Qalloc: "%core 16{   main: ref SuperScheduler;   inner(SuperCore)}" qDescno:  112 
 -- ObjTmpStack:add: "SuperCore" : "%core 16{   main: ref SuperScheduler;   inner(SuperCore)}" 
 -- items:markForCodeGen: "%core 16{main: ref SuperScheduler;inner(SuperCore)}" 
 -- markItem: "%core 16" Property 
 -- DataItem:markForCodeGen: "main" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "SuperScheduler" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "SuperScheduler" 
 -- "SuperScheduler" false 
 -- 
 -- OG:markForCodeGen: "thisScheduler:< Object{   ProcessType:< GeneralProcess;   active: ref ProcessType;   inner(SuperScheduler)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "thisScheduler:< Object{   ProcessType:< GeneralProcess;   active: ref ProcessType;   inner(SuperScheduler)}" 
 -- OG:Qalloc: "thisScheduler:< Object{   ProcessType:< GeneralProcess;   active: ref ProcessType;   inner(SuperScheduler)}" qDescno:  122 
 -- ObjTmpStack:add: "SuperScheduler" : "thisScheduler:< Object{   ProcessType:< GeneralProcess;   active: ref ProcessType;   inner(SuperScheduler)}" 
 -- items:markForCodeGen: "thisScheduler:< Object{ProcessType:< GeneralProcess;active: ref ProcessType;inner(SuperScheduler)}" 
 -- Pattern:markForCodeGen: "thisScheduler:< Object" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "Object" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Object" 
 -- "Object" true 
 -- 
 -- not ObjDesc:  "Object"  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "ProcessType:< GeneralProcess" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "GeneralProcess" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "GeneralProcess" 
 -- "GeneralProcess" false 
 -- 
 -- OG:markSuper: "GeneralProcess" 
 -- Invocation:markForCodeGen: "GeneralProcess" 
 -- ObjectInvocation:markForCodeGen: "GeneralProcess"  ATd: "GeneralProcess(id: var LIB.StringLib.String): {   start:< ;      inner(start);   mkActive:< ;      inner(mkActive) ...}" 
 -- Pattern:markForCodeGen: "GeneralProcess(id: var LIB.StringLib.String): {   start:< ;      inner(start);   mkActive:< ;      inner(mkActive);   addWaiting:< ;      --put('q ...}" 
 -- items:markForCodeGen: "%$B "("{id: var LIB.StringLib.String;%$E ")"}" 
 -- markItem: "%$B "("" Property 
 -- DataItem:markForCodeGen: "id" :descNo: 0 :OG.primNo: 5 
 -- OG:markForCodeGen: "LIB.StringLib.String" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "LIB.StringLib.String" 
 -- "LIB" false 
 -- "StringLib" false 
 -- "String" true 
 -- 
 -- not ObjDesc:  "LIB.StringLib.String"  IS.isEmpty:  true 
 -- markItem: "%$E ")"" Property 
 -- OG:markForCodeGen: "start:< {      inner(start);   mkActive:< ;      inner(mkActive);   addWaiting:< ;      --put('q')inner(addWaiting);      --put('R');   dcrWaiting:< ;  ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "start:< {      inner(start);   mkActive:< ;      inner(mkActive);   addWaiting:< ;      --put('q')inner(addWaiting);      --put('R');   dcrWaiting:< ;      inn ...}" 
 -- OG:Qalloc: "start:< {      inner(start);   mkActive:< ;      inner(mkActive);   addWaiting:< ;      --put('q')inner(addWaiting);      --put('R');   dcrWaiting:< ;      inn ...}" q ... 82 
 -- ObjTmpStack:add: "GeneralProcess(id: var LIB.StringLib.String)" : "start:< {      inner(start);   mkActive:< ;      inner(mkActive);   addWaiting:< ;      --put('q')inner( ...}" 
 -- items:markForCodeGen: "start:< {   inner(start);mkActive:< ;   inner(mkActive);addWaiting:< ;   --put('q')inner(addWaiting);   --put('R');dcrWaiting:< ;   inner(dcrWaiting ...}" 
 -- Pattern:markForCodeGen: "start:< {   inner(start)}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "inner(start)" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "inner(start)" 
 -- OG:Qalloc: "inner(start)" qDescno:  0 
 -- OG:Qalloc:A:  "start"  super:  ""  marked:  true "start:< {   inner(start)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(start)" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "start" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 132 IS.newDescNo: 132 objSize: 0 1: 1 "inner(start)" 
 -- Items:Qalloc:objSize: 0  newDescNo: 132 "inner(start)" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- OG:Qalloc: "inner(start)" qDescno:  0 
 -- OG:Qalloc:A:  "inner"  super:  "inner(start)"  marked:  false "inner(start)" super:  inner(start) 
 -- Invocation:Qalloc: "inner(start)" 
 -- ObjectInvocation:Qalloc: "inner(start)" 
 -- name: "inner" 
 -- Arguments "inner(start)" 
 -- OG:Qalloc: "start" qDescno:  0 
 -- OG:Qalloc:A:  "start"  super:  "start"  marked:  false "inner(start)" super:  start 
 -- Invocation:Qalloc: "start" 
 -- ObjectInvocation:Qalloc: "start" 
 -- name: "start" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  132 1 inner(start) 
 -- OG:super:  "start:< {   inner(start)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "start" 
 -- super:  "start" 
 -- E:  "start" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "start" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 %basic 101{in inner: ref Object} 
 -- OG:super:  "inner: {   %basic 101;   in inner: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(start)" 
 -- super:  "inner(start)" 
 -- E:  "inner(start)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(start)" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 132 "inner(start)" 
 -- IS.newDescNo: 132 IS.objSize: 1 "inner(start)" 
 -- OG:Qalloc:end: IS.newDescNo:  132 "inner(start)" 
 -- ObjTmpStack:add: "start" : "inner(start)" 
 -- items:markForCodeGen: "inner(start)" 
 -- markItem: "inner(start)" ObjectGenerator 
 -- Pattern:markForCodeGen: "mkActive:< {   inner(mkActive)}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "inner(mkActive)" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "inner(mkActive)" 
 -- OG:Qalloc: "inner(mkActive)" qDescno:  0 
 -- OG:Qalloc:A:  "mkActive"  super:  ""  marked:  true "mkActive:< {   inner(mkActive)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(mkActive)" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "mkActive" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 133 IS.newDescNo: 133 objSize: 0 1: 1 "inner(mkActive)" 
 -- Items:Qalloc:objSize: 0  newDescNo: 133 "inner(mkActive)" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- OG:Qalloc: "inner(mkActive)" qDescno:  0 
 -- OG:Qalloc:A:  "inner"  super:  "inner(mkActive)"  marked:  false "inner(mkActive)" super:  inner(mkActive) 
 -- Invocation:Qalloc: "inner(mkActive)" 
 -- ObjectInvocation:Qalloc: "inner(mkActive)" 
 -- name: "inner" 
 -- Arguments "inner(mkActive)" 
 -- OG:Qalloc: "mkActive" qDescno:  0 
 -- OG:Qalloc:A:  "mkActive"  super:  "mkActive"  marked:  false "inner(mkActive)" super:  mkActive 
 -- Invocation:Qalloc: "mkActive" 
 -- ObjectInvocation:Qalloc: "mkActive" 
 -- name: "mkActive" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  133 1 inner(mkActive) 
 -- OG:super:  "mkActive:< {   inner(mkActive)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "mkActive" 
 -- super:  "mkActive" 
 -- E:  "mkActive" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "mkActive" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 %basic 101{in inner: ref Object} 
 -- OG:super:  "inner: {   %basic 101;   in inner: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(mkActive)" 
 -- super:  "inner(mkActive)" 
 -- E:  "inner(mkActive)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(mkActive)" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 133 "inner(mkActive)" 
 -- IS.newDescNo: 133 IS.objSize: 1 "inner(mkActive)" 
 -- OG:Qalloc:end: IS.newDescNo:  133 "inner(mkActive)" 
 -- ObjTmpStack:add: "mkActive" : "inner(mkActive)" 
 -- items:markForCodeGen: "inner(mkActive)" 
 -- markItem: "inner(mkActive)" ObjectGenerator 
 -- Pattern:markForCodeGen: "addWaiting:< {   --put('q')inner(addWaiting);   --put('R')}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "--put('q')inner(addWaiting){   --put('R')}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "--put('q')inner(addWaiting){   --put('R')}" 
 -- OG:Qalloc: "--put('q')inner(addWaiting){   --put('R')}" qDescno:  0 
 -- OG:Qalloc:A:  "addWaiting"  super:  ""  marked:  true "addWaiting:< {   --put('q')inner(addWaiting);   --put('R')}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "--put('q')inner(addWaiting){   --put('R')}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "addWaiting" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 134 IS.newDescNo: 134 objSize: 0 1: 1 "--put('q')inner(addWaiting){--put('R')}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 134 "--put('q')inner(addWaiting){--put('R')}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- OG:Qalloc: "inner(addWaiting){--put('R')}" qDescno:  0 
 -- OG:Qalloc:A:  "inner"  super:  "inner(addWaiting){--put('R')}"  marked:  false "--put('q')inner(addWaiting){--put('R')}" super:  inner(addWaiting){--put('R')} 
 -- Invocation:Qalloc: "inner(addWaiting){--put('R')}" 
 -- ObjectInvocation:Qalloc: "inner(addWaiting)" 
 -- name: "inner" 
 -- Arguments "inner(addWaiting)" 
 -- OG:Qalloc: "addWaiting" qDescno:  0 
 -- OG:Qalloc:A:  "addWaiting"  super:  "addWaiting"  marked:  false "inner(addWaiting)" super:  addWaiting 
 -- Invocation:Qalloc: "addWaiting" 
 -- ObjectInvocation:Qalloc: "addWaiting" 
 -- name: "addWaiting" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  134 1 --put('q')inner(addWaiting){--put('R')} 
 -- OG:super:  "addWaiting:< {   --put('q')inner(addWaiting);   --put('R')}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "addWaiting" 
 -- super:  "addWaiting" 
 -- E:  "addWaiting" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "addWaiting" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 %basic 101{in inner: ref Object} 
 -- OG:super:  "inner: {   %basic 101;   in inner: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(addWaiting){--put('R')}" 
 -- super:  "inner(addWaiting){--put('R')}" 
 -- E:  "inner(addWaiting)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(addWaiting){--put('R')}" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 134 "--put('q')inner(addWaiting){--put('R')}" 
 -- IS.newDescNo: 134 IS.objSize: 1 "--put('q')inner(addWaiting){--put('R')}" 
 -- OG:Qalloc:end: IS.newDescNo:  134 "--put('q')inner(addWaiting){   --put('R')}" 
 -- ObjTmpStack:add: "addWaiting" : "--put('q')inner(addWaiting){   --put('R')}" 
 -- items:markForCodeGen: "--put('q')inner(addWaiting){--put('R')}" 
 -- markItem: "inner(addWaiting){--put('R')}" ObjectGenerator 
 -- Pattern:markForCodeGen: "dcrWaiting:< {   inner(dcrWaiting)}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "inner(dcrWaiting)" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "inner(dcrWaiting)" 
 -- OG:Qalloc: "inner(dcrWaiting)" qDescno:  0 
 -- OG:Qalloc:A:  "dcrWaiting"  super:  ""  marked:  true "dcrWaiting:< {   inner(dcrWaiting)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(dcrWaiting)" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "dcrWaiting" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 135 IS.newDescNo: 135 objSize: 0 1: 1 "inner(dcrWaiting)" 
 -- Items:Qalloc:objSize: 0  newDescNo: 135 "inner(dcrWaiting)" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- OG:Qalloc: "inner(dcrWaiting)" qDescno:  0 
 -- OG:Qalloc:A:  "inner"  super:  "inner(dcrWaiting)"  marked:  false "inner(dcrWaiting)" super:  inner(dcrWaiting) 
 -- Invocation:Qalloc: "inner(dcrWaiting)" 
 -- ObjectInvocation:Qalloc: "inner(dcrWaiting)" 
 -- name: "inner" 
 -- Arguments "inner(dcrWaiting)" 
 -- OG:Qalloc: "dcrWaiting" qDescno:  0 
 -- OG:Qalloc:A:  "dcrWaiting"  super:  "dcrWaiting"  marked:  false "inner(dcrWaiting)" super:  dcrWaiting 
 -- Invocation:Qalloc: "dcrWaiting" 
 -- ObjectInvocation:Qalloc: "dcrWaiting" 
 -- name: "dcrWaiting" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  135 1 inner(dcrWaiting) 
 -- OG:super:  "dcrWaiting:< {   inner(dcrWaiting)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "dcrWaiting" 
 -- super:  "dcrWaiting" 
 -- E:  "dcrWaiting" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "dcrWaiting" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 %basic 101{in inner: ref Object} 
 -- OG:super:  "inner: {   %basic 101;   in inner: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(dcrWaiting)" 
 -- super:  "inner(dcrWaiting)" 
 -- E:  "inner(dcrWaiting)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(dcrWaiting)" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 135 "inner(dcrWaiting)" 
 -- IS.newDescNo: 135 IS.objSize: 1 "inner(dcrWaiting)" 
 -- OG:Qalloc:end: IS.newDescNo:  135 "inner(dcrWaiting)" 
 -- ObjTmpStack:add: "dcrWaiting" : "inner(dcrWaiting)" 
 -- items:markForCodeGen: "inner(dcrWaiting)" 
 -- markItem: "inner(dcrWaiting)" ObjectGenerator 
 -- Pattern:markForCodeGen: "display:< {   "\n---GP:---".print;   inner(display)}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: ""\n---GP:---".print{   inner(display)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: ""\n---GP:---".print{   inner(display)}" 
 -- OG:Qalloc: ""\n---GP:---".print{   inner(display)}" qDescno:  0 
 -- OG:Qalloc:A:  "display"  super:  ""  marked:  true "display:< {   "\n---GP:---".print;   inner(display)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""\n---GP:---".print{   inner(display)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "display" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 136 IS.newDescNo: 136 objSize: 0 1: 1 ""\n---GP:---".print{inner(display)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 136 ""\n---GP:---".print{inner(display)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- OG:Qalloc: ""\n---GP:---".print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  ""\n---GP:---".print"  marked:  false ""\n---GP:---".print{inner(display)}" super:  "\n---GP:---".print 
 -- Invocation:Qalloc: ""\n---GP:---".print" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  103 1 gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);} 
 -- OG:super:  "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""\n---GP:---".print" 
 -- super:  ""\n---GP:---".print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 ""\n---GP:---".print" 
 -- OG:Qalloc: "inner(display)" qDescno:  0 
 -- OG:Qalloc:A:  "inner"  super:  "inner(display)"  marked:  false ""\n---GP:---".print{inner(display)}" super:  inner(display) 
 -- Invocation:Qalloc: "inner(display)" 
 -- ObjectInvocation:Qalloc: "inner(display)" 
 -- name: "inner" 
 -- Arguments "inner(display)" 
 -- OG:Qalloc: "display" qDescno:  0 
 -- OG:Qalloc:A:  "display"  super:  "display"  marked:  false "inner(display)" super:  display 
 -- Invocation:Qalloc: "display" 
 -- ObjectInvocation:Qalloc: "display" 
 -- name: "display" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  136 1 "\n---GP:---".print{inner(display)} 
 -- OG:super:  "display:< {   "\n---GP:---".print;   inner(display)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "display" 
 -- super:  "display" 
 -- E:  "display" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "display" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 %basic 101{in inner: ref Object} 
 -- OG:super:  "inner: {   %basic 101;   in inner: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(display)" 
 -- super:  "inner(display)" 
 -- E:  "inner(display)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(display)" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 136 ""\n---GP:---".print{inner(display)}" 
 -- IS.newDescNo: 136 IS.objSize: 1 ""\n---GP:---".print{inner(display)}" 
 -- OG:Qalloc:end: IS.newDescNo:  136 ""\n---GP:---".print{   inner(display)}" 
 -- ObjTmpStack:add: "display" : ""\n---GP:---".print{   inner(display)}" 
 -- items:markForCodeGen: ""\n---GP:---".print{inner(display)}" 
 -- markItem: ""\n---GP:---".print" ObjectGenerator 
 -- OG:markForCodeGen: ""\n---GP:---".print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- ""\n---GP:---".print" 
 -- ""\n---GP:---"" true 
 -- "print" false 
 -- 
 -- OG:markSuper: ""\n---GP:---".print" 
 -- Invocation:markForCodeGen: ""\n---GP:---".print" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- Pattern:markForCodeGen: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "gogo: {      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "gogo: {      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OG:Qalloc: "gogo: {      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" qDescno:  103 
 -- ObjTmpStack:add: "print" : "gogo: {      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- items:markForCodeGen: "gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);}" 
 -- markItem: "for(1):to(length):repeat{   put(get[inx]);}" ObjectGenerator 
 -- OG:markForCodeGen: "for(1):to(length):repeat{   put(get[inx]);}" 
 -- isObjectDesc: true  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "for(1):to(length):repeat{   put(get[inx]);}" 
 -- "for(1):to(length):repeat{   put(get[inx]);}" false 
 -- 
 -- OG:markSuper: "for(1):to(length):repeat{   put(get[inx]);}" 
 -- Invocation:markForCodeGen: "for(1):to(length):repeat{   put(get[inx]);}" 
 -- ObjectInvocation:markForCodeGen: "for(1):to(length):repeat{   put(get[inx]);}"  ATd: "for(first: var integer):to(last: var integer):repeat{repeat:< object}: {   %OSDvisibi ...}" 
 -- OI:args:markForCodgen: "for(1):to(length):repeat{   put(get[inx]);}" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "length" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "length" 
 -- "length" false 
 -- 
 -- OG:markSuper: "length" 
 -- Invocation:markForCodeGen: "length" 
 -- ObjectInvocation:markForCodeGen: "length"  ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "length"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "put(get[inx])" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "put(get[inx])" 
 -- OG:Qalloc: "put(get[inx])" qDescno:  104 
 -- ObjTmpStack:add: "put(get[inx])" 
 -- items:markForCodeGen: "put(get[inx])" 
 -- markItem: "put(get[inx])" ObjectGenerator 
 -- OG:markForCodeGen: "put(get[inx])" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "put(get[inx])" 
 -- "put(get[inx])" true 
 -- 
 -- OG:markSuper: "put(get[inx])" 
 -- Invocation:markForCodeGen: "put(get[inx])" 
 -- ObjectInvocation:markForCodeGen: "put(get[inx])"  ATd: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- Pattern:markForCodeGen: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "-- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "-- to be eliminated" 
 -- "" false 
 -- 
 -- OG:markIS: "-- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OG:Qalloc: "-- to be eliminated{   %globals;   %basic 2;   in ch: val char}" qDescno:  105 
 -- ObjTmpStack:add: "put" : "-- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- items:markForCodeGen: "%globals{%basic 2;in ch: val char}" 
 -- markItem: "%globals" Property 
 -- markItem: "%basic 2" Property 
 -- DataItem:markForCodeGen: "ch" :descNo: 0 :OG.primNo: 3 
 -- OG:markForCodeGen: "char" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "char" 
 -- "char" true 
 -- 
 -- OG:markSuper: "char" 
 -- Invocation:markForCodeGen: "char" 
 -- ObjectInvocation:markForCodeGen: "char"  ATd: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61; ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "char"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "put(get[inx])" 
 -- arg:   "get[inx]" 
 -- not ObjDesc:  "put(get[inx])"  IS.isEmpty:  true 
 -- arg:   "1" 
 -- arg:   "length" 
 -- arg:   "put(get[inx])" 
 -- OG:markIS: "for(1):to(length):repeat{   put(get[inx]);}" 
 -- OG:Qalloc: "for(1):to(length):repeat{   put(get[inx]);}" qDescno:  106 
 -- ObjTmpStack:add: "for(1):to(length):repeat{   put(get[inx]);}" 
 -- items:markForCodeGen: "" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  ""\n---GP:---".print"  IS.isEmpty:  true 
 -- markItem: "inner(display)" ObjectGenerator 
 -- DataItem:markForCodeGen: "status" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- markItem: "inner(GeneralProcess)" ObjectGenerator 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "GeneralProcess"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "active" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "ProcessType" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "ProcessType" 
 -- "ProcessType" false 
 -- 
 -- not ObjDesc:  "ProcessType"  IS.isEmpty:  true 
 -- markItem: "inner(SuperScheduler)" ObjectGenerator 
 -- not ObjDesc:  "SuperScheduler"  IS.isEmpty:  true 
 -- markItem: "inner(SuperCore)" ObjectGenerator 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: obj ;         if (main =/= no ...}" 
 -- OG:Qalloc: "SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: obj ;         if (main =/= no ...}" q ... 113 
 -- ObjTmpStack:add: "Core" : "SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: obj ;          ...}" 
 -- items:markForCodeGen: "%Public{attach: ;   in M: ref Scheduler;   main := M;%Private;dummy: var integer;go: ;   loopX: obj ;      if (main =/= none) :then ;         main.c ...}" 
 -- markItem: "%Public" Property 
 -- markItem: "%Private" Property 
 -- DataItem:markForCodeGen: "dummy" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- markItem: "(this(Core)).suspend{--main:= none         }" ObjectGenerator 
 -- markItem: "dummy := 213" Assign 
 -- Invocation:markForCodeGen: "dummy" 
 -- ObjectInvocation:markForCodeGen: "dummy"  ATd: "dummy: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "213" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "213" 
 -- "213" true 
 -- 
 -- OG:markSuper: "213" 
 -- Invocation:markForCodeGen: "213" 
 -- not ObjDesc:  "213"  IS.isEmpty:  true 
 -- markItem: "go" ObjectGenerator 
 -- OG:markForCodeGen: "go" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "go" 
 -- "go" false 
 -- 
 -- OG:markSuper: "go" 
 -- Invocation:markForCodeGen: "go" 
 -- ObjectInvocation:markForCodeGen: "go"  ATd: "go: {   loopX: obj ;      if (main =/= none) :then ;         main.call;      :else ;         sleep(100);         restart(loopX ...}" 
 -- Pattern:markForCodeGen: "go: {   loopX: obj ;      if (main =/= none) :then ;         main.call;      :else ;         sleep(100);         restart(loopX)}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "loopX: obj {      if (main =/= none) :then ;         main.call;      :else ;         sleep(100);         restart(loopX)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "loopX: obj {      if (main =/= none) :then ;         main.call;      :else ;         sleep(100);         restart(loopX)}" 
 -- OG:Qalloc: "loopX: obj {      if (main =/= none) :then ;         main.call;      :else ;         sleep(100);         restart(loopX)}" qDescno:  114 
 -- ObjTmpStack:add: "go" : "loopX: obj {      if (main =/= none) :then ;         main.call;      :else ;         sleep(100);         restart(loopX)}" 
 -- items:markForCodeGen: "loopX: obj {   if (main =/= none) :then ;      main.call;   :else ;      sleep(100);      restart(loopX)}" 
 -- DataItem:markForCodeGen: "loopX" :descNo: 115 :OG.primNo: 0 
 -- OG:markForCodeGen: "if (main =/= none) :then {      main.call;   :else ;      sleep(100);      restart(loopX)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "if (main =/= none) :then {      main.call;   :else ;      sleep(100);      restart(loopX)}" 
 -- OG:Qalloc: "if (main =/= none) :then {      main.call;   :else ;      sleep(100);      restart(loopX)}" qDescno:  115 
 -- ObjTmpStack:add: "loopX" : "if (main =/= none) :then {      main.call;   :else ;      sleep(100);      restart(loopX)}" 
 -- items:markForCodeGen: "if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)}" 
 -- markItem: "if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)}" ObjectGenerator 
 -- OG:markForCodeGen: "if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)}" 
 -- "if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)}" true 
 -- 
 -- OG:markSuper: "if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)}" 
 -- Invocation:markForCodeGen: "if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)}" 
 -- OG:markForCodeGen: "(main =/= none)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(main =/= none)" 
 -- "(main =/= none)" true 
 -- 
 -- OG:markSuper: "(main =/= none)" 
 -- Invocation:markForCodeGen: "(main =/= none)" 
 -- Invocation:markForCodeGen: "main =/= none" 
 -- BinaryExp:markForCodeGen: "main =/= none" 
 -- Invocation:markForCodeGen: "main" 
 -- ObjectInvocation:markForCodeGen: "main"  ATd: "main: ref SuperScheduler" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "=/= none"  ATd: "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean}" 
 -- Pattern:markForCodeGen: "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean}" 
 -- items:markForCodeGen: "" 
 -- OI:args:markForCodgen: "none" 
 -- not ObjDesc:  "(main =/= none)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "main.call" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "main.call" 
 -- OG:Qalloc: "main.call" qDescno:  118 
 -- ObjTmpStack:add: "main.call" 
 -- items:markForCodeGen: "main.call" 
 -- markItem: "main.call" ObjectGenerator 
 -- OG:markForCodeGen: "sleep(100){   restart(loopX)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "sleep(100){   restart(loopX)}" 
 -- OG:Qalloc: "sleep(100){   restart(loopX)}" qDescno:  120 
 -- ObjTmpStack:add: "sleep(100){   restart(loopX)}" 
 -- items:markForCodeGen: "sleep(100){restart(loopX)}" 
 -- markItem: "sleep(100)" ObjectGenerator 
 -- markItem: "restart(loopX)" ObjectGenerator 
 -- not ObjDesc:  "if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)}"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "go"  IS.isEmpty:  true 
 -- not ObjDesc:  "Core"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "C2" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Core" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Core" 
 -- "Core" false 
 -- 
 -- not ObjDesc:  "Core"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "C3" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Core" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Core" 
 -- "Core" false 
 -- 
 -- not ObjDesc:  "Core"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "C4" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Core{-- should be array         }" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Core{-- should be array         }" 
 -- "Core{-- should be array         }" false 
 -- 
 -- not ObjDesc:  "Core{-- should be array         }"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "P_status" :descNo: 74 :OG.primNo: 0 
 -- OG:markForCodeGen: "%globals{   %Public;   ACTIVE: val 1;   WAITING: val 2;   TERMINATED: val 3}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%globals{   %Public;   ACTIVE: val 1;   WAITING: val 2;   TERMINATED: val 3}" 
 -- OG:Qalloc: "%globals{   %Public;   ACTIVE: val 1;   WAITING: val 2;   TERMINATED: val 3}" qDescno:  74 
 -- ObjTmpStack:add: "P_status" : "%globals{   %Public;   ACTIVE: val 1;   WAITING: val 2;   TERMINATED: val 3}" 
 -- items:markForCodeGen: "%globals{%Public;ACTIVE: val 1;WAITING: val 2;TERMINATED: val 3}" 
 -- markItem: "%globals" Property 
 -- markItem: "%Public" Property 
 -- DataItem:markForCodeGen: "ACTIVE" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "WAITING" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "2" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "2" 
 -- "2" true 
 -- 
 -- OG:markSuper: "2" 
 -- Invocation:markForCodeGen: "2" 
 -- not ObjDesc:  "2"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "TERMINATED" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "3" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "3" 
 -- "3" true 
 -- 
 -- OG:markSuper: "3" 
 -- Invocation:markForCodeGen: "3" 
 -- not ObjDesc:  "3"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "sch" :descNo: 75 :OG.primNo: 0 
 -- OG:markForCodeGen: "L: obj Lock("Sch:lock"){   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      entry;         M := M + 1;   ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "L: obj Lock("Sch:lock"){   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      entry;         M := M + 1;   dcr: ;  ...}" 
 -- OG:Qalloc: "L: obj Lock("Sch:lock"){   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      entry;         M := M + 1;   dcr: ;  ...}" q ... 75 
 -- ObjTmpStack:add: "sch" : "L: obj Lock("Sch:lock"){   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      entry;         M := M  ...}" 
 -- items:markForCodeGen: "L: obj Lock("Sch:lock"){M: var integer;%Public;entry: ;   L.get;   inner(entry);   L.free;add: ;   entry;      M := M + 1;dcr: ;   entry;      M :=  ...}" 
 -- DataItem:markForCodeGen: "L" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Lock("Sch:lock")" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Lock("Sch:lock")" 
 -- "Lock("Sch:lock")" false 
 -- 
 -- OG:markSuper: "Lock("Sch:lock")" 
 -- Invocation:markForCodeGen: "Lock("Sch:lock")" 
 -- ObjectInvocation:markForCodeGen: "Lock("Sch:lock")"  ATd: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      ...}" 
 -- Pattern:markForCodeGen: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop:  ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "%globals{   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ;         r ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%globals{   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ;         res: var  ...}" 
 -- OG:Qalloc: "%globals{   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ;         res: var  ...}" q ... 76 
 -- ObjTmpStack:add: "Lock" : "%globals{   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ;    ...}" 
 -- items:markForCodeGen: "%globals{%Public;in id: var String;%private;free_M: var integer;%public;init: ;   free_M := 0;get: ;   loop: obj ;      res: var integer;      i: va ...}" 
 -- markItem: "%globals" Property 
 -- markItem: "%Public" Property 
 -- DataItem:markForCodeGen: "id" :descNo: 0 :OG.primNo: 5 
 -- OG:markForCodeGen: "String" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "String" 
 -- "String" true 
 -- 
 -- not ObjDesc:  "String"  IS.isEmpty:  true 
 -- markItem: "%private" Property 
 -- DataItem:markForCodeGen: "free_M" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- markItem: "%public" Property 
 -- OI:args:markForCodgen: "Lock("Sch:lock")" 
 -- OG:markForCodeGen: ""Sch:lock"" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- ""Sch:lock"" 
 -- ""Sch:lock"" true 
 -- 
 -- OG:markSuper: ""Sch:lock"" 
 -- Invocation:markForCodeGen: ""Sch:lock"" 
 -- not ObjDesc:  ""Sch:lock""  IS.isEmpty:  true 
 -- arg:   ""Sch:lock"" 
 -- not ObjDesc:  "Lock("Sch:lock")"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "M" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- markItem: "%Public" Property 
 -- DataItem:markForCodeGen: "SQS" :descNo: 77 :OG.primNo: 0 
 -- OG:markForCodeGen: "Q: obj ProcessQueue{   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if (V > 1) ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "Q: obj ProcessQueue{   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if (V > 1) :then ; ...}" 
 -- OG:Qalloc: "Q: obj ProcessQueue{   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if (V > 1) :then ; ...}" q ... 77 
 -- ObjTmpStack:add: "SQS" : "Q: obj ProcessQueue{   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if ( ...}" 
 -- items:markForCodeGen: "Q: obj ProcessQueue{L: obj Lock("SQS:Lock:");V: var integer;W: var integer;%Public;entry: ;   L.get;   V := V + 1;   if (V > 1) :then ;      put('V' ...}" 
 -- DataItem:markForCodeGen: "Q" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "ProcessQueue" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "ProcessQueue" 
 -- "ProcessQueue" false 
 -- 
 -- OG:markSuper: "ProcessQueue" 
 -- Invocation:markForCodeGen: "ProcessQueue" 
 -- ObjectInvocation:markForCodeGen: "ProcessQueue"  ATd: "ProcessQueue: LIB.Collections.QueueLib.Queue{   %Public;   displayx: ;      put('Q')}" 
 -- Pattern:markForCodeGen: "ProcessQueue: LIB.Collections.QueueLib.Queue{   %Public;   displayx: ;      put('Q')}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "LIB.Collections.QueueLib.Queue{   %Public;   displayx: ;      put('Q')}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "LIB.Collections.QueueLib.Queue" 
 -- "LIB" false 
 -- "Collections" false 
 -- "QueueLib" false 
 -- "Queue" false 
 -- 
 -- OG:markSuper: "LIB.Collections.QueueLib.Queue" 
 -- Invocation:markForCodeGen: "LIB.Collections.QueueLib.Queue" 
 -- ObjectInvocation:markForCodeGen: "LIB"  ATd: "--LIB{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "Collections"  ATd: "--Collections{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "QueueLib"  ATd: "--QueueLib{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "Queue"  ATd: "Queue: {   %globals;   idf: var LIB.StringLib.String;   idc: var integer;   noOfElm: var integer;   Element: ;      in elm: ...}" 
 -- Pattern:markForCodeGen: "Queue: {   %globals;   idf: var LIB.StringLib.String;   idc: var integer;   noOfElm: var integer;   Element: ;      in elm: ref Object;      out r ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "%globals{   idf: var LIB.StringLib.String;   idc: var integer;   noOfElm: var integer;   Element: ;      in elm: ref Object;      out res: ref Element; ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%globals{   idf: var LIB.StringLib.String;   idc: var integer;   noOfElm: var integer;   Element: ;      in elm: ref Object;      out res: ref Element;      id ...}" 
 -- OG:Qalloc: "%globals{   idf: var LIB.StringLib.String;   idc: var integer;   noOfElm: var integer;   Element: ;      in elm: ref Object;      out res: ref Element;      id ...}" q ... 78 
 -- ObjTmpStack:add: "Queue" : "%globals{   idf: var LIB.StringLib.String;   idc: var integer;   noOfElm: var integer;   Element: ;      in elm: ref Object;      out res: ref  ...}" 
 -- items:markForCodeGen: "%globals{idf: var LIB.StringLib.String;idc: var integer;noOfElm: var integer;Element: ;   in elm: ref Object;   out res: ref Element;   id: var inte ...}" 
 -- markItem: "%globals" Property 
 -- DataItem:markForCodeGen: "idf" :descNo: 0 :OG.primNo: 5 
 -- OG:markForCodeGen: "LIB.StringLib.String" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "LIB.StringLib.String" 
 -- "LIB" false 
 -- "StringLib" false 
 -- "String" true 
 -- 
 -- not ObjDesc:  "LIB.StringLib.String"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "idc" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "noOfElm" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "head" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Element" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Element" 
 -- "Element" false 
 -- 
 -- OG:markForCodeGen: "in elm: ref Object{   out res: ref Element;   id: var integer;   pred: ref Element;   succ: ref Element;   res := this(Element);   idc := idc + 1;   id ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "in elm: ref Object{   out res: ref Element;   id: var integer;   pred: ref Element;   succ: ref Element;   res := this(Element);   idc := idc + 1;   id := idc}" 
 -- OG:Qalloc: "in elm: ref Object{   out res: ref Element;   id: var integer;   pred: ref Element;   succ: ref Element;   res := this(Element);   idc := idc + 1;   id := idc}" q ... 0 
 -- OG:Qalloc:A:  "Element"  super:  ""  marked:  true "Element: {   in elm: ref Object;   out res: ref Element;   id: var integer;   pred: ref Element;   succ: ref Element;   ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "in elm: ref Object{   out res: ref Element;   id: var integer;   pred: ref Element;   succ: ref Element;   res := this(Element);   idc := idc + 1;   id := idc}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "Element" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 137 IS.newDescNo: 137 objSize: 0 1: 1 "in elm: ref Object{out res: ref Element;id: var integer;pred: ref Element;succ: ref Element;res := this(E ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 137 "in elm: ref Object{out res: ref Element;id: var integer;pred: ref Element;succ: ref Element;res := this(Element);idc := idc + 1;id ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "elm" isValue: false  isPrimitive: true  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "in elm: ref Object" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- dataitem:qalloc: "res" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 3 "out res: ref Element" 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "id" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- dataitem:qalloc: "pred" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 5 "pred: ref Element" 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- dataitem:qalloc: "succ" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 6 "succ: ref Element" 
 -- Items:Qalloc:objSize: 6  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 6  newDescNo: 0 "" 
 -- Invocation:Qalloc: "res" 
 -- ObjectInvocation:Qalloc: "res" 
 -- name: "res" 
 -- Arguments "" 
 -- OG:Qalloc: "this(Element)" qDescno:  0 
 -- OG:Qalloc:A:  "this"  super:  "this(Element)"  marked:  false "res := this(Element)" super:  this(Element) 
 -- Invocation:Qalloc: "this(Element)" 
 -- ObjectInvocation:Qalloc: "this(Element)" 
 -- name: "this" 
 -- Arguments "this(Element)" 
 -- OG:Qalloc: "Element" qDescno:  0 
 -- OG:Qalloc:A:  "Element"  super:  "Element"  marked:  false "this(Element)" super:  Element 
 -- Invocation:Qalloc: "Element" 
 -- ObjectInvocation:Qalloc: "Element" 
 -- name: "Element" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  137 6 in elm: ref Object{out res: ref Element;id: var integer;pred: ref Element;succ: ref Element;res := this(Element); ...} 
 -- OG:super:  "Element: {   in elm: ref Object;   out res: ref Element;   id: var integer;   pred: ref Element;   succ: ref Element;   res := this(Element);   idc := idc + 1; ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Element" 
 -- super:  "Element" 
 -- E:  "Element" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Element" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  31 2 %basic 18{in this: ref Object} 
 -- OG:super:  "this: {   %basic 18;   in this: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "this(Element)" 
 -- super:  "this(Element)" 
 -- E:  "this(Element)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "this(Element)" 
 -- Invocation:Qalloc: "idc" 
 -- ObjectInvocation:Qalloc: "idc" 
 -- name: "idc" 
 -- Arguments "" 
 -- OG:Qalloc: "idc + 1" qDescno:  0 
 -- OG:Qalloc:A:  "+"  super:  "idc + 1"  marked:  false "idc := idc + 1" super:  idc + 1 
 -- Invocation:Qalloc: "idc + 1" 
 -- BinaryExp:Qalloc: "idc + 1" 
 -- Invocation:Qalloc: "idc" 
 -- ObjectInvocation:Qalloc: "idc" 
 -- name: "idc" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "+ 1" 
 -- name: "+" 
 -- Arguments "1" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "1" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  49 5 %basic 61{in V: var integer;out R: var integer} 
 -- OG:super:  "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "idc + 1" 
 -- super:  "idc + 1" 
 -- E:  "idc + 1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "idc + 1" 
 -- Invocation:Qalloc: "id" 
 -- ObjectInvocation:Qalloc: "id" 
 -- name: "id" 
 -- Arguments "" 
 -- OG:Qalloc: "idc" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "idc"  marked:  false "id := idc" super:  idc 
 -- Invocation:Qalloc: "idc" 
 -- ObjectInvocation:Qalloc: "idc" 
 -- name: "idc" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "idc: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "idc" 
 -- super:  "idc" 
 -- E:  "idc" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "idc" 
 -- Items:Qalloc:END:objSize: 6  newDescNo: 137 "in elm: ref Object{out res: ref Element;id: var integer;pred: ref Element;succ: ref Element;res := this(Element);idc := idc +  ...}" 
 -- IS.newDescNo: 137 IS.objSize: 6 "in elm: ref Object{out res: ref Element;id: var integer;pred: ref Element;succ: ref Element;res := this(Element);idc := idc + 1;id := idc}" 
 -- OG:Qalloc:end: IS.newDescNo:  137 "in elm: ref Object{   out res: ref Element;   id: var integer;   pred: ref Element;   succ: ref Element;   res := this(Element);   idc : ...}" 
 -- ObjTmpStack:add: "Element" : "in elm: ref Object{   out res: ref Element;   id: var integer;   pred: ref Element;   succ: ref Element;   res := this(Element);   idc := idc ...}" 
 -- items:markForCodeGen: "in elm: ref Object{out res: ref Element;id: var integer;pred: ref Element;succ: ref Element;res := this(Element);idc := idc + 1;id := idc}" 
 -- DataItem:markForCodeGen: "elm" :descNo: 0 :OG.primNo: 64 
 -- OG:markForCodeGen: "Object" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Object" 
 -- "Object" true 
 -- 
 -- not ObjDesc:  "Object"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "res" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Element" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Element" 
 -- "Element" false 
 -- 
 -- not ObjDesc:  "Element"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "id" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "pred" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Element" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Element" 
 -- "Element" false 
 -- 
 -- not ObjDesc:  "Element"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "succ" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Element" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Element" 
 -- "Element" false 
 -- 
 -- not ObjDesc:  "Element"  IS.isEmpty:  true 
 -- markItem: "res := this(Element)" Assign 
 -- Invocation:markForCodeGen: "res" 
 -- ObjectInvocation:markForCodeGen: "res"  ATd: "out res: ref Element" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "this(Element)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "this(Element)" 
 -- "this(Element)" true 
 -- 
 -- OG:markSuper: "this(Element)" 
 -- Invocation:markForCodeGen: "this(Element)" 
 -- ObjectInvocation:markForCodeGen: "this(Element)"  ATd: "this: {   %basic 18;   in this: ref Object}" 
 -- OI:args:markForCodgen: "this(Element)" 
 -- OG:markForCodeGen: "Element" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Element" 
 -- "Element" false 
 -- 
 -- OG:markSuper: "Element" 
 -- Invocation:markForCodeGen: "Element" 
 -- ObjectInvocation:markForCodeGen: "Element"  ATd: "Element: {   in elm: ref Object;   out res: ref Element;   id: var integer;   pred: ref Element;   succ: ref Element;   r ...}" 
 -- Pattern:markForCodeGen: "Element: {   in elm: ref Object;   out res: ref Element;   id: var integer;   pred: ref Element;   succ: ref Element;   res := this(Element);   id ...}" 
 -- items:markForCodeGen: "" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Element"  IS.isEmpty:  true 
 -- arg:   "Element" 
 -- not ObjDesc:  "this(Element)"  IS.isEmpty:  true 
 -- markItem: "idc := idc + 1" Assign 
 -- Invocation:markForCodeGen: "idc" 
 -- ObjectInvocation:markForCodeGen: "idc"  ATd: "idc: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "idc + 1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "idc + 1" 
 -- "idc + 1" true 
 -- 
 -- OG:markSuper: "idc + 1" 
 -- Invocation:markForCodeGen: "idc + 1" 
 -- BinaryExp:markForCodeGen: "idc + 1" 
 -- Invocation:markForCodeGen: "idc" 
 -- ObjectInvocation:markForCodeGen: "idc"  ATd: "idc: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "+ 1"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OI:args:markForCodgen: "1" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- not ObjDesc:  "idc + 1"  IS.isEmpty:  true 
 -- markItem: "id := idc" Assign 
 -- Invocation:markForCodeGen: "id" 
 -- ObjectInvocation:markForCodeGen: "id"  ATd: "id: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "idc" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "idc" 
 -- "idc" true 
 -- 
 -- not ObjDesc:  "Element"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "last" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Element" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Element" 
 -- "Element" false 
 -- 
 -- not ObjDesc:  "Element"  IS.isEmpty:  true 
 -- markItem: "%Public" Property 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "LIB.Collections.QueueLib.Queue{   %Public;   displayx: ;      put('Q')}" 
 -- OG:Qalloc: "LIB.Collections.QueueLib.Queue{   %Public;   displayx: ;      put('Q')}" qDescno:  79 
 -- ObjTmpStack:add: "ProcessQueue" : "LIB.Collections.QueueLib.Queue{   %Public;   displayx: ;      put('Q')}" 
 -- items:markForCodeGen: "%Public{displayx: ;   put('Q')}" 
 -- markItem: "%Public" Property 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "ProcessQueue"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "L" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Lock("SQS:Lock:")" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Lock("SQS:Lock:")" 
 -- "Lock("SQS:Lock:")" false 
 -- 
 -- OG:markSuper: "Lock("SQS:Lock:")" 
 -- Invocation:markForCodeGen: "Lock("SQS:Lock:")" 
 -- ObjectInvocation:markForCodeGen: "Lock("SQS:Lock:")"  ATd: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;     ...}" 
 -- OI:args:markForCodgen: "Lock("SQS:Lock:")" 
 -- OG:markForCodeGen: ""SQS:Lock:"" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- ""SQS:Lock:"" 
 -- ""SQS:Lock:"" true 
 -- 
 -- OG:markSuper: ""SQS:Lock:"" 
 -- Invocation:markForCodeGen: ""SQS:Lock:"" 
 -- not ObjDesc:  ""SQS:Lock:""  IS.isEmpty:  true 
 -- arg:   ""SQS:Lock:"" 
 -- not ObjDesc:  "Lock("SQS:Lock:")"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "V" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "W" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- markItem: "%Public" Property 
 -- DataItem:markForCodeGen: "coreLock" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Lock("CoreLock")" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Lock("CoreLock")" 
 -- "Lock("CoreLock")" false 
 -- 
 -- OG:markSuper: "Lock("CoreLock")" 
 -- Invocation:markForCodeGen: "Lock("CoreLock")" 
 -- ObjectInvocation:markForCodeGen: "Lock("CoreLock")"  ATd: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      ...}" 
 -- OI:args:markForCodgen: "Lock("CoreLock")" 
 -- OG:markForCodeGen: ""CoreLock"" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- ""CoreLock"" 
 -- ""CoreLock"" true 
 -- 
 -- OG:markSuper: ""CoreLock"" 
 -- Invocation:markForCodeGen: ""CoreLock"" 
 -- not ObjDesc:  ""CoreLock""  IS.isEmpty:  true 
 -- arg:   ""CoreLock"" 
 -- not ObjDesc:  "Lock("CoreLock")"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "console" :descNo: 80 :OG.primNo: 0 
 -- OG:markForCodeGen: "L: obj Lock("Console:lock"){   %public;   display: ;      L.get;      inner(display);      L.free;   L.init}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "L: obj Lock("Console:lock"){   %public;   display: ;      L.get;      inner(display);      L.free;   L.init}" 
 -- OG:Qalloc: "L: obj Lock("Console:lock"){   %public;   display: ;      L.get;      inner(display);      L.free;   L.init}" qDescno:  80 
 -- ObjTmpStack:add: "console" : "L: obj Lock("Console:lock"){   %public;   display: ;      L.get;      inner(display);      L.free;   L.init}" 
 -- items:markForCodeGen: "L: obj Lock("Console:lock"){%public;display: ;   L.get;   inner(display);   L.free;L.init}" 
 -- DataItem:markForCodeGen: "L" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Lock("Console:lock")" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Lock("Console:lock")" 
 -- "Lock("Console:lock")" false 
 -- 
 -- OG:markSuper: "Lock("Console:lock")" 
 -- Invocation:markForCodeGen: "Lock("Console:lock")" 
 -- ObjectInvocation:markForCodeGen: "Lock("Console:lock")"  ATd: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;  ...}" 
 -- OI:args:markForCodgen: "Lock("Console:lock")" 
 -- OG:markForCodeGen: ""Console:lock"" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- ""Console:lock"" 
 -- ""Console:lock"" true 
 -- 
 -- OG:markSuper: ""Console:lock"" 
 -- Invocation:markForCodeGen: ""Console:lock"" 
 -- not ObjDesc:  ""Console:lock""  IS.isEmpty:  true 
 -- arg:   ""Console:lock"" 
 -- not ObjDesc:  "Lock("Console:lock")"  IS.isEmpty:  true 
 -- markItem: "%public" Property 
 -- markItem: "L.init" ObjectGenerator 
 -- OG:markForCodeGen: "L.init" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "L.init" 
 -- "L" false 
 -- "init" false 
 -- 
 -- OG:markSuper: "L.init" 
 -- Invocation:markForCodeGen: "L.init" 
 -- ObjectInvocation:markForCodeGen: "L"  ATd: "L: obj Lock("Console:lock")" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "init"  ATd: "init: {   free_M := 0}" 
 -- Pattern:markForCodeGen: "init: {   free_M := 0}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "free_M := 0" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "free_M := 0" 
 -- OG:Qalloc: "free_M := 0" qDescno:  81 
 -- ObjTmpStack:add: "init" : "free_M := 0" 
 -- items:markForCodeGen: "free_M := 0" 
 -- markItem: "free_M := 0" Assign 
 -- Invocation:markForCodeGen: "free_M" 
 -- ObjectInvocation:markForCodeGen: "free_M"  ATd: "free_M: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "0" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "0" 
 -- "0" true 
 -- 
 -- OG:markSuper: "0" 
 -- Invocation:markForCodeGen: "0" 
 -- not ObjDesc:  "0"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "L.init"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "keyboard" :descNo: 85 :OG.primNo: 0 
 -- OG:markForCodeGen: "BasicProcess("Keyboard"){   B: obj Indexed(100,integer);   next: var integer;   top: var integer;   echo: var Boolean;   %Public;   Kscan: ;      loopB ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "BasicProcess("Keyboard")" 
 -- "BasicProcess("Keyboard")" false 
 -- 
 -- OG:markSuper: "BasicProcess("Keyboard")" 
 -- Invocation:markForCodeGen: "BasicProcess("Keyboard")" 
 -- ObjectInvocation:markForCodeGen: "BasicProcess("Keyboard")"  ATd: "BasicProcess: GeneralProcess{   mkActive::< ;      -- start and mkActive are identical and one may be el ...}" 
 -- Pattern:markForCodeGen: "BasicProcess: GeneralProcess{   mkActive::< ;      -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;      SQ ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "GeneralProcess{   mkActive::< ;      -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;      SQS.insert(this(Basic ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "GeneralProcess" 
 -- "GeneralProcess" false 
 -- 
 -- OG:markSuper: "GeneralProcess" 
 -- Invocation:markForCodeGen: "GeneralProcess" 
 -- ObjectInvocation:markForCodeGen: "GeneralProcess"  ATd: "GeneralProcess(id: var LIB.StringLib.String): {   start:< ;      inner(start);   mkActive:< ;      inner(mkActive) ...}" 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "GeneralProcess{   mkActive::< ;      -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;      SQS.insert(this(BasicProcess) ...}" 
 -- OG:Qalloc: "GeneralProcess{   mkActive::< ;      -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;      SQS.insert(this(BasicProcess) ...}" q ... 83 
 -- ObjTmpStack:add: "BasicProcess" : "GeneralProcess{   mkActive::< ;      -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;      SQS.in ...}" 
 -- items:markForCodeGen: "mkActive::< {   -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;   SQS.insert(this(BasicProcess));%Public;sta ...}" 
 -- Pattern:markForCodeGen: "mkActive::< {   -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;   SQS.insert(this(BasicProcess))}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "-- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE{   SQS.insert(this(BasicProcess))}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "-- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE{   SQS.insert(this(BasicProcess))}" 
 -- OG:Qalloc: "-- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE{   SQS.insert(this(BasicProcess))}" qDescno:  0 
 -- OG:Qalloc:A:  "mkActive"  super:  ""  marked:  true "mkActive::< {   -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;   SQS.insert(t ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  133 1 inner(mkActive) 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "-- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE{   SQS.insert(this(BasicProcess))}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "mkActive" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 138 IS.newDescNo: 138 objSize: 0 1: 1 "-- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE{SQS.insert(this(Ba ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 138 "-- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE{SQS.insert(this(BasicProcess))}" 
 -- Items:Qalloc:super: "" size: 1 "mkActive" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Invocation:Qalloc: "status" 
 -- ObjectInvocation:Qalloc: "status" 
 -- name: "status" 
 -- Arguments "" 
 -- OG:Qalloc: "p_status.ACTIVE" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "p_status.ACTIVE"  marked:  false "status := p_status.ACTIVE" super:  p_status.ACTIVE 
 -- Invocation:Qalloc: "p_status.ACTIVE" 
 -- ObjectInvocation:Qalloc: "p_status" 
 -- name: "p_status" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "ACTIVE" 
 -- name: "ACTIVE" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "ACTIVE: val 1" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "p_status.ACTIVE" 
 -- super:  "p_status.ACTIVE" 
 -- E:  "ACTIVE" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "p_status.ACTIVE" 
 -- OG:Qalloc: "SQS.insert(this(BasicProcess))" qDescno:  0 
 -- OG:Qalloc:A:  "insert"  super:  "SQS.insert(this(BasicProcess))"  marked:  false "-- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE{SQ ...}" s ... S ... 
 -- Invocation:Qalloc: "SQS.insert(this(BasicProcess))" 
 -- ObjectInvocation:Qalloc: "SQS" 
 -- name: "SQS" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "insert(this(BasicProcess))" 
 -- name: "insert" 
 -- Arguments "insert(this(BasicProcess))" 
 -- OG:Qalloc: "this(BasicProcess)" qDescno:  0 
 -- OG:Qalloc:A:  "this"  super:  "this(BasicProcess)"  marked:  false "insert(this(BasicProcess))" super:  this(BasicProcess) 
 -- Invocation:Qalloc: "this(BasicProcess)" 
 -- ObjectInvocation:Qalloc: "this(BasicProcess)" 
 -- name: "this" 
 -- Arguments "this(BasicProcess)" 
 -- OG:Qalloc: "BasicProcess" qDescno:  0 
 -- OG:Qalloc:A:  "BasicProcess"  super:  "BasicProcess"  marked:  false "this(BasicProcess)" super:  BasicProcess 
 -- Invocation:Qalloc: "BasicProcess" 
 -- ObjectInvocation:Qalloc: "BasicProcess" 
 -- name: "BasicProcess" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  83 4 mkActive::< {   -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;   SQS.inse ...} 
 -- OG:super:  "BasicProcess: GeneralProcess{   mkActive::< ;      -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;      SQS.insert(this ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "BasicProcess" 
 -- super:  "BasicProcess" 
 -- E:  "BasicProcess" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "BasicProcess" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  31 2 %basic 18{in this: ref Object} 
 -- OG:super:  "this: {   %basic 18;   in this: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "this(BasicProcess)" 
 -- super:  "this(BasicProcess)" 
 -- E:  "this(BasicProcess)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "this(BasicProcess)" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 in P: ref BasicProcess{if (Q.has(P).not) :then ;   Q.insert(P)} 
 -- OG:Qalloc:SuperAlloc: "insert: entry{   in P: ref BasicProcess;   if (Q.has(P).not) :then ;      Q.insert(P)}" 
 -- OG:Qalloc: "entry{   in P: ref BasicProcess;   if (Q.has(P).not) :then ;      Q.insert(P)}" qDescno:  0 
 -- OG:Qalloc:A:  "insert"  super:  "entry"  marked:  false "insert: entry{   in P: ref BasicProcess;   if (Q.has(P).not) :then ;      Q.insert(P)}" super:  entry 
 -- Invocation:Qalloc: "entry" 
 -- ObjectInvocation:Qalloc: "entry" 
 -- name: "entry" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  95 1 L.get{V := V + 1;if (V > 1) :then ;   put('V');inner(entry);V := V - 1;L.free} 
 -- OG:super:  "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "entry{   in P: ref BasicProcess;   if (Q.has(P).not) :then ;      Q.insert(P)}" 
 -- super:  "entry" 
 -- E:  "entry" 
 -- OG:Qalloc:B: "insert" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 139 IS.newDescNo: 139 objSize: 0 1: 1 "in P: ref BasicProcess{if (Q.has(P).not) :then ;   Q.insert(P)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 139 "in P: ref BasicProcess{if (Q.has(P).not) :then ;   Q.insert(P)}" 
 -- Items:Qalloc:super: "entry" size: 1 "insert" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "P" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "in P: ref BasicProcess" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- OG:Qalloc: "if (Q.has(P).not) :then {   Q.insert(P)}" qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (Q.has(P).not) :then {   Q.insert(P)}"  marked:  false "in P: ref BasicProcess{if (Q.has(P).not) :then ;   Q.insert(P)}" super:  if  ... 
 -- Invocation:Qalloc: "if (Q.has(P).not) :then {   Q.insert(P)}" 
 -- OG:Qalloc: "(Q.has(P).not)" qDescno:  0 
 -- OG:Qalloc:A:  "not"  super:  "(Q.has(P).not)"  marked:  false "if (Q.has(P).not) :then {   Q.insert(P)}" super:  (Q.has(P).not) 
 -- Invocation:Qalloc: "(Q.has(P).not)" 
 -- Invocation:Qalloc: "Q.has(P).not" 
 -- ObjectInvocation:Qalloc: "Q" 
 -- name: "Q" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "has(P)" 
 -- name: "has" 
 -- Arguments "has(P)" 
 -- OG:Qalloc: "P" qDescno:  0 
 -- OG:Qalloc:A:  "BasicProcess"  super:  "P"  marked:  false "has(P)" super:  P 
 -- Invocation:Qalloc: "P" 
 -- ObjectInvocation:Qalloc: "P" 
 -- name: "P" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  83 4 mkActive::< {   -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;   SQS.inse ...} 
 -- OG:super:  "in P: ref BasicProcess" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "P" 
 -- super:  "P" 
 -- E:  "P" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "P" 
 -- ObjectInvocation:Qalloc: "not" 
 -- name: "not" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 65{out R: var boolean} 
 -- OG:Qalloc:SuperAlloc: "not: {   %basic 65;   out R: var boolean}" 
 -- OG:Qalloc: "%basic 65{   out R: var boolean}" qDescno:  0 
 -- OG:Qalloc:A:  "not"  super:  ""  marked:  false "not: {   %basic 65;   out R: var boolean}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 65{   out R: var boolean}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "not" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 140 IS.newDescNo: 140 objSize: 0 1: 1 "%basic 65{out R: var boolean}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 140 "%basic 65{out R: var boolean}" 
 -- Items:Qalloc:Super:C:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "R" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 140 "%basic 65{out R: var boolean}" 
 -- IS.newDescNo: 140 IS.objSize: 4 "%basic 65{out R: var boolean}" 
 -- OG:Qalloc:end: IS.newDescNo:  140 "%basic 65{   out R: var boolean}" 
 -- OG:super:  "not: {   %basic 65;   out R: var boolean}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(Q.has(P).not)" 
 -- super:  "(Q.has(P).not)" 
 -- E:  "(Q.has(P).not)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(Q.has(P).not)" 
 -- OG:Qalloc: "Q.insert(P)" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (Q.has(P).not) :then {   Q.insert(P)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Q.insert(P)" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 141 IS.newDescNo: 141 objSize: 0 1: 1 "Q.insert(P)" 
 -- Items:Qalloc:objSize: 0  newDescNo: 141 "Q.insert(P)" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: "Q.insert(P)" qDescno:  0 
 -- OG:Qalloc:A:  "insert"  super:  "Q.insert(P)"  marked:  false "Q.insert(P)" super:  Q.insert(P) 
 -- Invocation:Qalloc: "Q.insert(P)" 
 -- ObjectInvocation:Qalloc: "Q" 
 -- name: "Q" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "insert(P)" 
 -- name: "insert" 
 -- Arguments "insert(P)" 
 -- OG:Qalloc: "P" qDescno:  0 
 -- OG:Qalloc:A:  "BasicProcess"  super:  "P"  marked:  false "insert(P)" super:  P 
 -- Invocation:Qalloc: "P" 
 -- ObjectInvocation:Qalloc: "P" 
 -- name: "P" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  83 4 mkActive::< {   -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;   SQS.inse ...} 
 -- OG:super:  "in P: ref BasicProcess" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "P" 
 -- super:  "P" 
 -- E:  "P" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "P" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 in elm: ref Object{E: ref Element;b: var BOOLEAN;B := ELM =/= NONE;--if (has(elm)) :then;--    "insert:leave\n".pri ...} 
 -- OG:Qalloc:SuperAlloc: "insert: {   in elm: ref Object;   E: ref Element;   b: var BOOLEAN;   B := ELM =/= NONE;   --if (has(elm)) :then;   --    "insert:leave\n".print;    ...}" 
 -- OG:Qalloc: "in elm: ref Object{   E: ref Element;   b: var BOOLEAN;   B := ELM =/= NONE;   --if (has(elm)) :then;   --    "insert:leave\n".print;   --    leave(insert);    ...}" q ... 0 
 -- OG:Qalloc:A:  "insert"  super:  ""  marked:  false "insert: {   in elm: ref Object;   E: ref Element;   b: var BOOLEAN;   B := ELM =/= NONE;   --if (has(elm)) :then;   --  ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "in elm: ref Object{   E: ref Element;   b: var BOOLEAN;   B := ELM =/= NONE;   --if (has(elm)) :then;   --    "insert:leave\n".print;   --    leave(insert);   if (B) :the ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "insert" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 142 IS.newDescNo: 142 objSize: 0 1: 1 "in elm: ref Object{E: ref Element;b: var BOOLEAN;B := ELM =/= NONE;--if (has(elm)) :then;--    "insert:le ..."}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 142 "in elm: ref Object{E: ref Element;b: var BOOLEAN;B := ELM =/= NONE;--if (has(elm)) :then;--    "insert:leave\n".print;--    leave( ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "elm" isValue: false  isPrimitive: true  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "in elm: ref Object" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- dataitem:qalloc: "E" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 3 "E: ref Element" 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "b" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- Invocation:Qalloc: "B" 
 -- ObjectInvocation:Qalloc: "B" 
 -- name: "B" 
 -- Arguments "" 
 -- OG:Qalloc: "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" qDescno:  0 
 -- OG:Qalloc:A:  "=/="  super:  "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}"  marked:  false "B := ELM =/= NONE{--if (has(elm)) :the ...}" s ... E ... 
 -- Invocation:Qalloc: "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- BinaryExp:Qalloc: "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- Invocation:Qalloc: "ELM" 
 -- ObjectInvocation:Qalloc: "ELM" 
 -- name: "ELM" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "=/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- name: "=/=" 
 -- Arguments "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- OG:Qalloc: "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" qDescno:  0 
 -- OG:Qalloc:A:  "none"  super:  "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}"  marked:  false "NONE{--if (has(elm)) :then;--    "insert:leav ..."}" s ... N ... 
 -- Invocation:Qalloc: "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- ObjectInvocation:Qalloc: "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- name: "NONE" 
 -- Arguments "--if (has(elm)) :then{--    "insert:leave\n".print;--    leave(insert)}" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  116 2 %basic 19{none_x: var integer} 
 -- OG:super:  "none: {   %basic 19;   none_x: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- super:  "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- E:  "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  117 3 %basic 57{in objx: ref Object;out V: var boolean} 
 -- OG:super:  "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- super:  "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- E:  "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- OG:Qalloc: "if (B) :then {   E := Element(elm);   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head;   :else ;      E.succ := head;     ...}" q ... 0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (B) :then {   E := Element(elm);   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head;   :else ;  ...}"   ... false "i ..." s ... i ... 
 -- Invocation:Qalloc: "if (B) :then {   E := Element(elm);   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head;   :else ;      E.succ := h ...}" 
 -- OG:Qalloc: "(B)" qDescno:  0 
 -- OG:Qalloc:A:  "Boolean"  super:  "(B)"  marked:  false "if (B) :then {   E := Element(elm);   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last ...}" s ... ( ... 
 -- Invocation:Qalloc: "(B)" 
 -- Invocation:Qalloc: "B" 
 -- ObjectInvocation:Qalloc: "B" 
 -- name: "B" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  45 1 %id "Boolean"{%globals inSub;%basic 4, 8;%public;_thisBasicValue: var Universal;&&  : ;   %basic 70;   in B: var b ...} 
 -- OG:super:  "b: var BOOLEAN" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(B)" 
 -- super:  "(B)" 
 -- E:  "(B)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(B)" 
 -- OG:Qalloc: "E := Element(elm){   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head;   :else ;      E.succ := head;      head.pred := E; ...}" q ... 0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (B) :then {   E := Element(elm);   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "E := Element(elm){   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head;   :else ;      E.succ := head;      head.pred := E;      head  ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 143 IS.newDescNo: 143 objSize: 0 1: 1 "E := Element(elm){noOfElm := noOfElm + 1;if (head == none) :then ;   head := E;   last := head;:else ;    ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 143 "E := Element(elm){noOfElm := noOfElm + 1;if (head == none) :then ;   head := E;   last := head;:else ;   E.succ := head;   head.pr ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "E" 
 -- ObjectInvocation:Qalloc: "E" 
 -- name: "E" 
 -- Arguments "" 
 -- OG:Qalloc: "Element(elm)" qDescno:  0 
 -- OG:Qalloc:A:  "Element"  super:  "Element(elm)"  marked:  false "E := Element(elm)" super:  Element(elm) 
 -- Invocation:Qalloc: "Element(elm)" 
 -- ObjectInvocation:Qalloc: "Element(elm)" 
 -- name: "Element" 
 -- Arguments "Element(elm)" 
 -- OG:Qalloc: "elm" qDescno:  0 
 -- OG:Qalloc:A:  "Object"  super:  "elm"  marked:  false "Element(elm)" super:  elm 
 -- Invocation:Qalloc: "elm" 
 -- ObjectInvocation:Qalloc: "elm" 
 -- name: "elm" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:super:  "in elm: ref Object" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "elm" 
 -- super:  "elm" 
 -- E:  "elm" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "elm" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  137 6 in elm: ref Object{out res: ref Element;id: var integer;pred: ref Element;succ: ref Element;res := this(Element); ...} 
 -- OG:super:  "Element: {   in elm: ref Object;   out res: ref Element;   id: var integer;   pred: ref Element;   succ: ref Element;   res := this(Element);   idc := idc + 1; ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Element(elm)" 
 -- super:  "Element(elm)" 
 -- E:  "Element(elm)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Element(elm)" 
 -- Invocation:Qalloc: "noOfElm" 
 -- ObjectInvocation:Qalloc: "noOfElm" 
 -- name: "noOfElm" 
 -- Arguments "" 
 -- OG:Qalloc: "noOfElm + 1" qDescno:  0 
 -- OG:Qalloc:A:  "+"  super:  "noOfElm + 1"  marked:  false "noOfElm := noOfElm + 1" super:  noOfElm + 1 
 -- Invocation:Qalloc: "noOfElm + 1" 
 -- BinaryExp:Qalloc: "noOfElm + 1" 
 -- Invocation:Qalloc: "noOfElm" 
 -- ObjectInvocation:Qalloc: "noOfElm" 
 -- name: "noOfElm" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "+ 1" 
 -- name: "+" 
 -- Arguments "1" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "1" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  49 5 %basic 61{in V: var integer;out R: var integer} 
 -- OG:super:  "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "noOfElm + 1" 
 -- super:  "noOfElm + 1" 
 -- E:  "noOfElm + 1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "noOfElm + 1" 
 -- OG:Qalloc: "if (head == none) :then {   head := E;   last := head;:else ;   E.succ := head;   head.pred := E;   head := E;   --"insert:".print;   --idf.print;   --putint(n ...}" q ... 0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (head == none) :then {   head := E;   last := head;:else ;   E.succ := head;   head.pred := E;   head := E;   --"insert:".print;   - ...}"   ... false "E ..." s ... i ... 
 -- Invocation:Qalloc: "if (head == none) :then {   head := E;   last := head;:else ;   E.succ := head;   head.pred := E;   head := E;   --"insert:".print;   --idf.print;   -- ...}" 
 -- OG:Qalloc: "(head == none)" qDescno:  0 
 -- OG:Qalloc:A:  "=="  super:  "(head == none)"  marked:  false "if (head == none) :then {   head := E;   last := head;:else ;   E.succ := head;   head.pred := E;   head := E ...}" s ... ( ... 
 -- Invocation:Qalloc: "(head == none)" 
 -- Invocation:Qalloc: "head == none" 
 -- BinaryExp:Qalloc: "head == none" 
 -- Invocation:Qalloc: "head" 
 -- ObjectInvocation:Qalloc: "head" 
 -- name: "head" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "== none" 
 -- name: "==" 
 -- Arguments "none" 
 -- OG:Qalloc: "none" qDescno:  0 
 -- OG:Qalloc:A:  "none"  super:  "none"  marked:  false "none" super:  none 
 -- Invocation:Qalloc: "none" 
 -- ObjectInvocation:Qalloc: "none" 
 -- name: "none" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  116 2 %basic 19{none_x: var integer} 
 -- OG:super:  "none: {   %basic 19;   none_x: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "none" 
 -- super:  "none" 
 -- E:  "none" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "none" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 56{in objx: ref Object;out V: var boolean} 
 -- OG:Qalloc:SuperAlloc: "==  : {   %basic 56;   in objx: ref Object;   out V: var boolean}" 
 -- OG:Qalloc: "%basic 56{   in objx: ref Object;   out V: var boolean}" qDescno:  0 
 -- OG:Qalloc:A:  "=="  super:  ""  marked:  false "==  : {   %basic 56;   in objx: ref Object;   out V: var boolean}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 56{   in objx: ref Object;   out V: var boolean}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "==" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 144 IS.newDescNo: 144 objSize: 0 1: 1 "%basic 56{in objx: ref Object;out V: var boolean}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 144 "%basic 56{in objx: ref Object;out V: var boolean}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "objx" isValue: false  isPrimitive: true  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "in objx: ref Object" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 144 "%basic 56{in objx: ref Object;out V: var boolean}" 
 -- IS.newDescNo: 144 IS.objSize: 3 "%basic 56{in objx: ref Object;out V: var boolean}" 
 -- OG:Qalloc:end: IS.newDescNo:  144 "%basic 56{   in objx: ref Object;   out V: var boolean}" 
 -- OG:super:  "==  : {   %basic 56;   in objx: ref Object;   out V: var boolean}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(head == none)" 
 -- super:  "(head == none)" 
 -- E:  "(head == none)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(head == none)" 
 -- OG:Qalloc: "head := E{   last := head}" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (head == none) :then {   head := E;   last := head;:else ;   E.succ := head;   head.pred := E;   head := E;   --"insert: ..."}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "head := E{   last := head}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 145 IS.newDescNo: 145 objSize: 0 1: 1 "head := E{last := head}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 145 "head := E{last := head}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "head" 
 -- ObjectInvocation:Qalloc: "head" 
 -- name: "head" 
 -- Arguments "" 
 -- OG:Qalloc: "E" qDescno:  0 
 -- OG:Qalloc:A:  "Element"  super:  "E"  marked:  false "head := E" super:  E 
 -- Invocation:Qalloc: "E" 
 -- ObjectInvocation:Qalloc: "E" 
 -- name: "E" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  137 6 in elm: ref Object{out res: ref Element;id: var integer;pred: ref Element;succ: ref Element;res := this(Element); ...} 
 -- OG:super:  "E: ref Element" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "E" 
 -- super:  "E" 
 -- E:  "E" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "E" 
 -- Invocation:Qalloc: "last" 
 -- ObjectInvocation:Qalloc: "last" 
 -- name: "last" 
 -- Arguments "" 
 -- OG:Qalloc: "head" qDescno:  0 
 -- OG:Qalloc:A:  "Element"  super:  "head"  marked:  false "last := head" super:  head 
 -- Invocation:Qalloc: "head" 
 -- ObjectInvocation:Qalloc: "head" 
 -- name: "head" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  137 6 in elm: ref Object{out res: ref Element;id: var integer;pred: ref Element;succ: ref Element;res := this(Element); ...} 
 -- OG:super:  "head: ref Element" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "head" 
 -- super:  "head" 
 -- E:  "head" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "head" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 145 "head := E{last := head}" 
 -- IS.newDescNo: 145 IS.objSize: 1 "head := E{last := head}" 
 -- OG:Qalloc:end: IS.newDescNo:  145 "head := E{   last := head}" 
 -- OG:Qalloc: "E.succ := head{   head.pred := E;   head := E;   --"insert:".print;   --idf.print;   --putint(noOfElm);   --newline	 }" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (head == none) :then {   head := E;   last := head;:else ;   E.succ := head;   head.pred := E;   head := E;   --"insert: ..."}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "E.succ := head{   head.pred := E;   head := E;   --"insert:".print;   --idf.print;   --putint(noOfElm);   --newline	 }" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 146 IS.newDescNo: 146 objSize: 0 1: 1 "E.succ := head{head.pred := E;head := E;--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- Items:Qalloc:objSize: 0  newDescNo: 146 "E.succ := head{head.pred := E;head := E;--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "E.succ" 
 -- ObjectInvocation:Qalloc: "E" 
 -- name: "E" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "succ" 
 -- name: "succ" 
 -- Arguments "" 
 -- OG:Qalloc: "head" qDescno:  0 
 -- OG:Qalloc:A:  "Element"  super:  "head"  marked:  false "E.succ := head" super:  head 
 -- Invocation:Qalloc: "head" 
 -- ObjectInvocation:Qalloc: "head" 
 -- name: "head" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  137 6 in elm: ref Object{out res: ref Element;id: var integer;pred: ref Element;succ: ref Element;res := this(Element); ...} 
 -- OG:super:  "head: ref Element" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "head" 
 -- super:  "head" 
 -- E:  "head" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "head" 
 -- Invocation:Qalloc: "head.pred" 
 -- ObjectInvocation:Qalloc: "head" 
 -- name: "head" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "pred" 
 -- name: "pred" 
 -- Arguments "" 
 -- OG:Qalloc: "E" qDescno:  0 
 -- OG:Qalloc:A:  "Element"  super:  "E"  marked:  false "head.pred := E" super:  E 
 -- Invocation:Qalloc: "E" 
 -- ObjectInvocation:Qalloc: "E" 
 -- name: "E" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  137 6 in elm: ref Object{out res: ref Element;id: var integer;pred: ref Element;succ: ref Element;res := this(Element); ...} 
 -- OG:super:  "E: ref Element" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "E" 
 -- super:  "E" 
 -- E:  "E" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "E" 
 -- Invocation:Qalloc: "head" 
 -- ObjectInvocation:Qalloc: "head" 
 -- name: "head" 
 -- Arguments "" 
 -- OG:Qalloc: "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }" qDescno:  0 
 -- OG:Qalloc:A:  "Element"  super:  "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }"  marked:  false "head := E{--"insert:".print;--idf.print;--putint(noOfElm ...}" s ... E ... 
 -- Invocation:Qalloc: "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- ObjectInvocation:Qalloc: "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- name: "E" 
 -- Arguments "--"insert:".print{--idf.print;--putint(noOfElm);--newline	 }" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  137 6 in elm: ref Object{out res: ref Element;id: var integer;pred: ref Element;succ: ref Element;res := this(Element); ...} 
 -- OG:super:  "E: ref Element" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- super:  "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- E:  "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 146 "E.succ := head{head.pred := E;head := E;--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- IS.newDescNo: 146 IS.objSize: 1 "E.succ := head{head.pred := E;head := E;--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- OG:Qalloc:end: IS.newDescNo:  146 "E.succ := head{   head.pred := E;   head := E;   --"insert:".print;   --idf.print;   --putint(noOfElm);   --newline	 }" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (head == none) :then {   head := E;   last := head;:else ;   E.succ := head;   head.pred := E;   head := E;   --"insert:".print;   --idf.print;   --putint(noOfElm);    ...}" 
 -- super:  "if (head == none) :then {   head := E;   last := head;:else ;   E.succ := head;   head.pred := E;   head := E;   --"insert:".print;   --idf.print;   --putint(noOf ...}" 
 -- E:  "if (head == none) :then {   head := E;   last := head;:else ;   E.succ := head;   head.pred := E;   head := E;   --"insert:".print;   --idf.print;   --putint(noOfElm) ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (head == none) :then {   head := E;   last := head;:else ;   E.succ := head;   head.pred := E;   head := E;   --"insert:".print;   --id ...}" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 143 "E := Element(elm){noOfElm := noOfElm + 1;if (head == none) :then ;   head := E;   last := head;:else ;   E.succ := head;   hea ...}" 
 -- IS.newDescNo: 143 IS.objSize: 1 "E := Element(elm){noOfElm := noOfElm + 1;if (head == none) :then ;   head := E;   last := head;:else ;   E.succ := head;   head.pred := E; ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  143 "E := Element(elm){   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head;   :else ;      E.succ := hea ...}" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (B) :then {   E := Element(elm);   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head;   :else ;      E.succ := head;      head.pred ...}" 
 -- super:  "if (B) :then {   E := Element(elm);   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head;   :else ;      E.succ := head;      h ...}" 
 -- E:  "if (B) :then {   E := Element(elm);   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head;   :else ;      E.succ := head;      head. ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (B) :then {   E := Element(elm);   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head;   :else ;     ...}" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 142 "in elm: ref Object{E: ref Element;b: var BOOLEAN;B := ELM =/= NONE;--if (has(elm)) :then;--    "insert:leave\n".print;--    le ...}" 
 -- IS.newDescNo: 142 IS.objSize: 4 "in elm: ref Object{E: ref Element;b: var BOOLEAN;B := ELM =/= NONE;--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert); ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  142 "in elm: ref Object{   E: ref Element;   b: var BOOLEAN;   B := ELM =/= NONE;   --if (has(elm)) :then;   --    "insert:leave\n".print;    ...}" 
 -- OG:super:  "insert: {   in elm: ref Object;   E: ref Element;   b: var BOOLEAN;   B := ELM =/= NONE;   --if (has(elm)) :then;   --    "insert:leave\n".print;   --    leave ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Q.insert(P)" 
 -- super:  "Q.insert(P)" 
 -- E:  "insert(P)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Q.insert(P)" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 141 "Q.insert(P)" 
 -- IS.newDescNo: 141 IS.objSize: 1 "Q.insert(P)" 
 -- OG:Qalloc:end: IS.newDescNo:  141 "Q.insert(P)" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (Q.has(P).not) :then {   Q.insert(P)}" 
 -- super:  "if (Q.has(P).not) :then {   Q.insert(P)}" 
 -- E:  "if (Q.has(P).not) :then {   Q.insert(P)}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (Q.has(P).not) :then {   Q.insert(P)}" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 139 "in P: ref BasicProcess{if (Q.has(P).not) :then ;   Q.insert(P)}" 
 -- IS.newDescNo: 139 IS.objSize: 2 "in P: ref BasicProcess{if (Q.has(P).not) :then ;   Q.insert(P)}" 
 -- OG:Qalloc:end: IS.newDescNo:  139 "entry{   in P: ref BasicProcess;   if (Q.has(P).not) :then ;      Q.insert(P)}" 
 -- OG:super:  "insert: entry{   in P: ref BasicProcess;   if (Q.has(P).not) :then ;      Q.insert(P)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "SQS.insert(this(BasicProcess))" 
 -- super:  "SQS.insert(this(BasicProcess))" 
 -- E:  "insert(this(BasicProcess))" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "SQS.insert(this(BasicProcess))" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 138 "-- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE{SQS.insert(this(BasicProcess))}" 
 -- IS.newDescNo: 138 IS.objSize: 1 "-- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE{SQS.insert(this(BasicProcess))}" 
 -- OG:Qalloc:end: IS.newDescNo:  138 "-- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE{   SQS.insert(this(BasicProcess))}" 
 -- ObjTmpStack:add: "mkActive" : "-- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE{   SQS.insert(this(BasicProcess))}" 
 -- items:markForCodeGen: "-- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE{SQS.insert(this(BasicProcess))}" 
 -- markItem: "status := p_status.ACTIVE" Assign 
 -- Invocation:markForCodeGen: "status" 
 -- ObjectInvocation:markForCodeGen: "status"  ATd: "status: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "p_status.ACTIVE" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "p_status.ACTIVE" 
 -- "p_status" false 
 -- "ACTIVE" true 
 -- 
 -- markItem: "SQS.insert(this(BasicProcess))" ObjectGenerator 
 -- OG:markForCodeGen: "SQS.insert(this(BasicProcess))" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "SQS.insert(this(BasicProcess))" 
 -- "SQS" false 
 -- "insert(this(BasicProcess))" false 
 -- 
 -- OG:markSuper: "SQS.insert(this(BasicProcess))" 
 -- Invocation:markForCodeGen: "SQS.insert(this(BasicProcess))" 
 -- ObjectInvocation:markForCodeGen: "SQS"  ATd: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;       ...}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "insert(this(BasicProcess))"  ATd: "insert: entry{   in P: ref BasicProcess;   if (Q.has(P).not) :then ;      Q.insert(P)}" 
 -- Pattern:markForCodeGen: "insert: entry{   in P: ref BasicProcess;   if (Q.has(P).not) :then ;      Q.insert(P)}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "entry{   in P: ref BasicProcess;   if (Q.has(P).not) :then ;      Q.insert(P)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "entry" 
 -- "entry" false 
 -- 
 -- OG:markSuper: "entry" 
 -- Invocation:markForCodeGen: "entry" 
 -- ObjectInvocation:markForCodeGen: "entry"  ATd: "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free}" 
 -- Pattern:markForCodeGen: "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "L.get{   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "L.get{   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free}" 
 -- OG:Qalloc: "L.get{   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free}" qDescno:  95 
 -- ObjTmpStack:add: "entry" : "L.get{   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free}" 
 -- items:markForCodeGen: "L.get{V := V + 1;if (V > 1) :then ;   put('V');inner(entry);V := V - 1;L.free}" 
 -- markItem: "L.get" ObjectGenerator 
 -- OG:markForCodeGen: "L.get" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "L.get" 
 -- "L" false 
 -- "get" false 
 -- 
 -- OG:markSuper: "L.get" 
 -- Invocation:markForCodeGen: "L.get" 
 -- ObjectInvocation:markForCodeGen: "L"  ATd: "L: obj Lock("SQS:Lock:")" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "get"  ATd: "get: {   loop: obj ;      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);      if (r ...}" 
 -- Pattern:markForCodeGen: "get: {   loop: obj ;      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);      if (res = 1) :then ;       ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "loop: obj {      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);      if (res = 1) :then ;         --enablesle ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "loop: obj {      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);      if (res = 1) :then ;         --enablesleep(50);  ...}" 
 -- OG:Qalloc: "loop: obj {      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);      if (res = 1) :then ;         --enablesleep(50);  ...}" q ... 96 
 -- ObjTmpStack:add: "get" : "loop: obj {      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);      if (res = 1) :then ;         --ena ...}" 
 -- items:markForCodeGen: "loop: obj {   res: var integer;   i: var integer;   --disable;   res := free_M.cmpAndSwap(1);   if (res = 1) :then ;      --enablesleep(50);      i  ...}" 
 -- DataItem:markForCodeGen: "loop" :descNo: 97 :OG.primNo: 0 
 -- OG:markForCodeGen: "res: var integer{   i: var integer;   --disable;   res := free_M.cmpAndSwap(1);   if (res = 1) :then ;      --enablesleep(50);      i := i + 1;      if ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "res: var integer{   i: var integer;   --disable;   res := free_M.cmpAndSwap(1);   if (res = 1) :then ;      --enablesleep(50);      i := i + 1;      if (i > 10 ...}" 
 -- OG:Qalloc: "res: var integer{   i: var integer;   --disable;   res := free_M.cmpAndSwap(1);   if (res = 1) :then ;      --enablesleep(50);      i := i + 1;      if (i > 10 ...}" q ... 97 
 -- ObjTmpStack:add: "loop" : "res: var integer{   i: var integer;   --disable;   res := free_M.cmpAndSwap(1);   if (res = 1) :then ;      --enablesleep(50);      i := i + 1;  ...}" 
 -- items:markForCodeGen: "res: var integer{i: var integer;--disable;res := free_M.cmpAndSwap(1);if (res = 1) :then ;   --enablesleep(50);   i := i + 1;   if (i > 10000) :then ...}" 
 -- DataItem:markForCodeGen: "res" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "i" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer{--disable}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer{--disable}" 
 -- "integer{--disable}" true 
 -- 
 -- OG:markSuper: "integer{--disable}" 
 -- Invocation:markForCodeGen: "integer{--disable}" 
 -- ObjectInvocation:markForCodeGen: "integer{--disable}"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ...}" 
 -- OI:args:markForCodgen: "--disable" 
 -- not ObjDesc:  "integer{--disable}"  IS.isEmpty:  true 
 -- markItem: "res := free_M.cmpAndSwap(1)" Assign 
 -- Invocation:markForCodeGen: "res" 
 -- ObjectInvocation:markForCodeGen: "res"  ATd: "res: var integer" 
 -- OI:args:markForCodgen: "" 
 -- markItem: "if (res = 1) :then {   --enablesleep(50);   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts").print;      i := 0;   restart(loop ...}" O ... 
 -- OG:markForCodeGen: "if (res = 1) :then {   --enablesleep(50);   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts").print;      i := 0;   res ...}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (res = 1) :then {   --enablesleep(50);   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts").print;      i := 0;   restart(loop)}" 
 -- "if (res = 1) :then {   --enablesleep(50);   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts").print;      i := 0;   restart(loop)}" true 
 -- 
 -- OG:markSuper: "if (res = 1) :then {   --enablesleep(50);   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts").print;      i := 0;   restart( ...}" 
 -- Invocation:markForCodeGen: "if (res = 1) :then {   --enablesleep(50);   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts").print;      i :=  ...}" 
 -- OG:markForCodeGen: "(res = 1)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(res = 1)" 
 -- "(res = 1)" true 
 -- 
 -- OG:markSuper: "(res = 1)" 
 -- Invocation:markForCodeGen: "(res = 1)" 
 -- Invocation:markForCodeGen: "res = 1" 
 -- BinaryExp:markForCodeGen: "res = 1" 
 -- Invocation:markForCodeGen: "res" 
 -- ObjectInvocation:markForCodeGen: "res"  ATd: "res: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "= 1"  ATd: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OI:args:markForCodgen: "1" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- not ObjDesc:  "(res = 1)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "--enablesleep(50){   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts").print;      i := 0;   restart(loop)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "--enablesleep(50){   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts").print;      i := 0;   restart(loop)}" 
 -- OG:Qalloc: "--enablesleep(50){   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts").print;      i := 0;   restart(loop)}" qDescno:  99 
 -- ObjTmpStack:add: "--enablesleep(50){   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts").print;      i := 0;   restart(loop)}" 
 -- items:markForCodeGen: "--enablesleep(50){i := i + 1;if (i > 10000) :then ;   (id + " not free after 10000 attempts").print;   i := 0;restart(loop)}" 
 -- markItem: "sleep(50)" ObjectGenerator 
 -- markItem: "i := i + 1" Assign 
 -- Invocation:markForCodeGen: "i" 
 -- ObjectInvocation:markForCodeGen: "i"  ATd: "i: var integer{--disable}" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "i + 1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "i + 1" 
 -- "i + 1" true 
 -- 
 -- OG:markSuper: "i + 1" 
 -- Invocation:markForCodeGen: "i + 1" 
 -- BinaryExp:markForCodeGen: "i + 1" 
 -- Invocation:markForCodeGen: "i" 
 -- ObjectInvocation:markForCodeGen: "i"  ATd: "i: var integer{--disable}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "+ 1"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OI:args:markForCodgen: "1" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- not ObjDesc:  "i + 1"  IS.isEmpty:  true 
 -- markItem: "if (i > 10000) :then {   (id + " not free after 10000 attempts").print;   i := 0}" ObjectGenerator 
 -- OG:markForCodeGen: "if (i > 10000) :then {   (id + " not free after 10000 attempts").print;   i := 0}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (i > 10000) :then {   (id + " not free after 10000 attempts").print;   i := 0}" 
 -- "if (i > 10000) :then {   (id + " not free after 10000 attempts").print;   i := 0}" true 
 -- 
 -- OG:markSuper: "if (i > 10000) :then {   (id + " not free after 10000 attempts").print;   i := 0}" 
 -- Invocation:markForCodeGen: "if (i > 10000) :then {   (id + " not free after 10000 attempts").print;   i := 0}" 
 -- OG:markForCodeGen: "(i > 10000)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(i > 10000)" 
 -- "(i > 10000)" true 
 -- 
 -- OG:markSuper: "(i > 10000)" 
 -- Invocation:markForCodeGen: "(i > 10000)" 
 -- Invocation:markForCodeGen: "i > 10000" 
 -- BinaryExp:markForCodeGen: "i > 10000" 
 -- Invocation:markForCodeGen: "i" 
 -- ObjectInvocation:markForCodeGen: "i"  ATd: "i: var integer{--disable}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "> 10000"  ATd: ">  : {   %basic 53;   in V: var integer;   out B: var boolean}" 
 -- Pattern:markForCodeGen: ">  : {   %basic 53;   in V: var integer;   out B: var boolean}" 
 -- items:markForCodeGen: "" 
 -- OI:args:markForCodgen: "10000" 
 -- OG:markForCodeGen: "10000" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "10000" 
 -- "10000" true 
 -- 
 -- OG:markSuper: "10000" 
 -- Invocation:markForCodeGen: "10000" 
 -- not ObjDesc:  "10000"  IS.isEmpty:  true 
 -- not ObjDesc:  "(i > 10000)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "(id + " not free after 10000 attempts").print{   i := 0}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "(id + " not free after 10000 attempts").print{   i := 0}" 
 -- OG:Qalloc: "(id + " not free after 10000 attempts").print{   i := 0}" qDescno:  102 
 -- ObjTmpStack:add: "(id + " not free after 10000 attempts").print{   i := 0}" 
 -- items:markForCodeGen: "(id + " not free after 10000 attempts").print{i := 0}" 
 -- markItem: "(id + " not free after 10000 attempts").print" ObjectGenerator 
 -- OG:markForCodeGen: "(id + " not free after 10000 attempts").print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "(id + " not free after 10000 attempts").print" 
 -- "(id + " not free after 10000 attempts")" false 
 -- "print" false 
 -- 
 -- OG:markSuper: "(id + " not free after 10000 attempts").print" 
 -- Invocation:markForCodeGen: "(id + " not free after 10000 attempts").print" 
 -- Invocation:markForCodeGen: "id + " not free after 10000 attempts"" 
 -- BinaryExp:markForCodeGen: "id + " not free after 10000 attempts"" 
 -- Invocation:markForCodeGen: "id" 
 -- ObjectInvocation:markForCodeGen: "id"  ATd: "in id: var String" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "+ " not free after 10000 attempts""  ATd: "+  : {   in S: var String;   out V: var String;   L: var integer;   L := Length;   doplus: do  ...}" 
 -- Pattern:markForCodeGen: "+  : {   in S: var String;   out V: var String;   L: var integer;   L := Length;   doplus: do ;      e: var integer;      i: var integer;      T:  ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "in S: var String{   out V: var String;   L: var integer;   L := Length;   doplus: do ;      e: var integer;      i: var integer;      T: obj Indexed(L  ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "in S: var String{   out V: var String;   L: var integer;   L := Length;   doplus: do ;      e: var integer;      i: var integer;      T: obj Indexed(L + S.leng ...}" 
 -- OG:Qalloc: "in S: var String{   out V: var String;   L: var integer;   L := Length;   doplus: do ;      e: var integer;      i: var integer;      T: obj Indexed(L + S.leng ...}" q ... 0 
 -- OG:Qalloc:A:  "+"  super:  ""  marked:  true "+  : {   in S: var String;   out V: var String;   L: var integer;   L := Length;   doplus: do ;      e: var integer;      i:  ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "in S: var String{   out V: var String;   L: var integer;   L := Length;   doplus: do ;      e: var integer;      i: var integer;      T: obj Indexed(L + S.length,Integer) ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "+" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 147 IS.newDescNo: 147 objSize: 0 1: 1 "in S: var String{out V: var String;L: var integer;L := Length;doplus: do ;   e: var integer;   i: var int ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 147 "in S: var String{out V: var String;L: var integer;L := Length;doplus: do ;   e: var integer;   i: var integer;   T: obj Indexed(L  ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "S" isValue: false  isPrimitive: true  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "in S: var String" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: false  isPrimitive: true  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 3 "out V: var String" 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "L" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- Invocation:Qalloc: "L" 
 -- ObjectInvocation:Qalloc: "L" 
 -- name: "L" 
 -- Arguments "" 
 -- OG:Qalloc: "Length" qDescno:  0 
 -- OG:Qalloc:A:  "length"  super:  "Length"  marked:  false "L := Length" super:  Length 
 -- Invocation:Qalloc: "Length" 
 -- ObjectInvocation:Qalloc: "Length" 
 -- name: "Length" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  15 2 out V: var integer{V := get[0] -- actually an index error, accessing length} 
 -- OG:super:  "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Length" 
 -- super:  "Length" 
 -- E:  "Length" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Length" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 147 "in S: var String{out V: var String;L: var integer;L := Length;doplus: do ;   e: var integer;   i: var integer;   T: obj Indexe ...}" 
 -- IS.newDescNo: 147 IS.objSize: 4 "in S: var String{out V: var String;L: var integer;L := Length;doplus: do ;   e: var integer;   i: var integer;   T: obj Indexed(L + S.leng ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  147 "in S: var String{   out V: var String;   L: var integer;   L := Length;   doplus: do ;      e: var integer;      i: var integer;      T: ...}" 
 -- ObjTmpStack:add: "+  " : "in S: var String{   out V: var String;   L: var integer;   L := Length;   doplus: do ;      e: var integer;      i: var integer;      T: obj Inde ...}" 
 -- items:markForCodeGen: "in S: var String{out V: var String;L: var integer;L := Length;doplus: do ;   e: var integer;   i: var integer;   T: obj Indexed(L + S.length,Integer ...}" 
 -- DataItem:markForCodeGen: "S" :descNo: 0 :OG.primNo: 5 
 -- OG:markForCodeGen: "String" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "String" 
 -- "String" true 
 -- 
 -- not ObjDesc:  "String"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "V" :descNo: 0 :OG.primNo: 5 
 -- OG:markForCodeGen: "String" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "String" 
 -- "String" true 
 -- 
 -- not ObjDesc:  "String"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "L" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- markItem: "L := Length" Assign 
 -- Invocation:markForCodeGen: "L" 
 -- ObjectInvocation:markForCodeGen: "L"  ATd: "L: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "Length" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Length" 
 -- "Length" false 
 -- 
 -- OG:markSuper: "Length" 
 -- Invocation:markForCodeGen: "Length" 
 -- ObjectInvocation:markForCodeGen: "Length"  ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Length"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "e: var integer{   i: var integer;   T: obj Indexed(L + S.length,Integer);   for(1):to(L):repeat;      e := get[inx];      T.put(e):at[inx];   ;   for(1 ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "e: var integer{   i: var integer;   T: obj Indexed(L + S.length,Integer);   for(1):to(L):repeat;      e := get[inx];      T.put(e):at[inx];   ;   for(1):to(S.l ...}" 
 -- OG:Qalloc: "e: var integer{   i: var integer;   T: obj Indexed(L + S.length,Integer);   for(1):to(L):repeat;      e := get[inx];      T.put(e):at[inx];   ;   for(1):to(S.l ...}" q ... 0 
 -- OG:Qalloc:A:  "doplus"  super:  ""  marked:  true "doplus: do {   e: var integer;   i: var integer;   T: obj Indexed(L + S.length,Integer);   for(1):to(L):repeat;      e : ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "e: var integer{   i: var integer;   T: obj Indexed(L + S.length,Integer);   for(1):to(L):repeat;      e := get[inx];      T.put(e):at[inx];   ;   for(1):to(S.length):repe ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "doplus" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 148 IS.newDescNo: 148 objSize: 0 1: 1 "e: var integer{i: var integer;T: obj Indexed(L + S.length,Integer);for(1):to(L):repeat;   e := get[inx];  ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 148 "e: var integer{i: var integer;T: obj Indexed(L + S.length,Integer);for(1):to(L):repeat;   e := get[inx];   T.put(e):at[inx];;for(1 ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- dataitem:qalloc: "e" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- dataitem:qalloc: "i" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "T" isValue: false  isPrimitive: true  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 4 "T: obj Indexed(L + S.length,Integer)" 
 -- OG:Qalloc: "Indexed(L + S.length,Integer)" qDescno:  0 
 -- OG:Qalloc:A:  "T"  super:  "Indexed(L + S.length,Integer)"  marked:  false "T: obj Indexed(L + S.length,Integer)" super:  Indexed(L + S.length,Integer) 
 -- Invocation:Qalloc: "Indexed(L + S.length,Integer)" 
 -- ObjectInvocation:Qalloc: "Indexed(L + S.length,Integer)" 
 -- name: "Indexed" 
 -- Arguments "(L + S.length,Integer)" 
 -- OG:Qalloc: "L + S.length" qDescno:  0 
 -- OG:Qalloc:A:  "+"  super:  "L + S.length"  marked:  false "(L + S.length,Integer)" super:  L + S.length 
 -- Invocation:Qalloc: "L + S.length" 
 -- BinaryExp:Qalloc: "L + S.length" 
 -- Invocation:Qalloc: "L" 
 -- ObjectInvocation:Qalloc: "L" 
 -- name: "L" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "+ S.length" 
 -- name: "+" 
 -- Arguments "S.length" 
 -- OG:Qalloc: "S.length" qDescno:  0 
 -- OG:Qalloc:A:  "length"  super:  "S.length"  marked:  false "S.length" super:  S.length 
 -- Invocation:Qalloc: "S.length" 
 -- ObjectInvocation:Qalloc: "S" 
 -- name: "S" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "length" 
 -- name: "length" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  15 2 out V: var integer{V := get[0] -- actually an index error, accessing length} 
 -- OG:super:  "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "S.length" 
 -- super:  "S.length" 
 -- E:  "length" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "S.length" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  49 5 %basic 61{in V: var integer;out R: var integer} 
 -- OG:super:  "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L + S.length" 
 -- super:  "L + S.length" 
 -- E:  "L + S.length" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L + S.length" 
 -- OG:Qalloc: "Integer" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "Integer"  marked:  false "(L + S.length,Integer)" super:  Integer 
 -- Invocation:Qalloc: "Integer" 
 -- ObjectInvocation:Qalloc: "Integer" 
 -- name: "Integer" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Integer" 
 -- super:  "Integer" 
 -- E:  "Integer" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Integer" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  86 1 %globals{%basic 114;%public;in range: var Integer;in elm:< Object;length: ;   out res: var integer;   res := get[0 ...} 
 -- OG:super:  "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];   put(V: ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "Indexed(L + S.length,Integer)" 
 -- super:  "Indexed(L + S.length,Integer)" 
 -- E:  "Indexed(L + S.length,Integer)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Indexed(L + S.length,Integer)" 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- OG:Qalloc: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" qDescno:  0 
 -- OG:Qalloc:A:  "for:to:repeat$0"  super:  "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}"  marked:  false "e: var integer{i: var integer;T: obj Indexed(L + S.l ...}" s ... f ... 
 -- Invocation:Qalloc: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- ObjectInvocation:Qalloc: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- name: "for:to:repeat" 
 -- Arguments "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- OG:Qalloc: "L" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "L"  marked:  false "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" super:  L 
 -- Invocation:Qalloc: "L" 
 -- ObjectInvocation:Qalloc: "L" 
 -- name: "L" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "L: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L" 
 -- super:  "L" 
 -- E:  "L" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L" 
 -- OG:Qalloc: "e := get[inx]{   T.put(e):at[inx]}" qDescno:  0 
 -- OG:Qalloc:A:  "repeat$0"  super:  ""  marked:  false "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "e := get[inx]{   T.put(e):at[inx]}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "repeat$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 149 IS.newDescNo: 149 objSize: 0 1: 1 "e := get[inx]{T.put(e):at[inx]}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 149 "e := get[inx]{T.put(e):at[inx]}" 
 -- Items:Qalloc:super: "" size: 1 "repeat$149" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "e" 
 -- ObjectInvocation:Qalloc: "e" 
 -- name: "e" 
 -- Arguments "" 
 -- OG:Qalloc: "get[inx]" qDescno:  0 
 -- OG:Qalloc:A:  "get"  super:  "get[inx]"  marked:  false "e := get[inx]" super:  get[inx] 
 -- Invocation:Qalloc: "get[inx]" 
 -- ObjectInvocation:Qalloc: "get[inx]" 
 -- name: "get" 
 -- Arguments "get[inx]" 
 -- OG:Qalloc: "inx" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "inx"  marked:  false "get[inx]" super:  inx 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "inx: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx" 
 -- super:  "inx" 
 -- E:  "inx" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  16 3 %basic 117{out ch: var char} 
 -- OG:super:  "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "get[inx]" 
 -- super:  "get[inx]" 
 -- E:  "get[inx]" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "get[inx]" 
 -- OG:Qalloc: "T.put(e):at[inx]" qDescno:  0 
 -- OG:Qalloc:A:  "put:at"  super:  "T.put(e):at[inx]"  marked:  false "e := get[inx]{T.put(e):at[inx]}" super:  T.put(e):at[inx] 
 -- Invocation:Qalloc: "T.put(e):at[inx]" 
 -- ObjectInvocation:Qalloc: "T" 
 -- name: "T" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "put(e):at[inx]" 
 -- name: "put:at" 
 -- Arguments "put(e):at[inx]" 
 -- OG:Qalloc: "e" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "e"  marked:  false "put(e):at[inx]" super:  e 
 -- Invocation:Qalloc: "e" 
 -- ObjectInvocation:Qalloc: "e" 
 -- name: "e" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "e: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "e" 
 -- super:  "e" 
 -- E:  "e" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "e" 
 -- OG:Qalloc: "inx" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "inx"  marked:  false "put(e):at[inx]" super:  inx 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "inx: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx" 
 -- super:  "inx" 
 -- E:  "inx" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  93 3 %basic 115 
 -- OG:super:  "put(V: var integer):at[inx: var integer]: {   %basic 115}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "T.put(e):at[inx]" 
 -- super:  "T.put(e):at[inx]" 
 -- E:  "put(e):at[inx]" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "T.put(e):at[inx]" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 149 "e := get[inx]{T.put(e):at[inx]}" 
 -- IS.newDescNo: 149 IS.objSize: 1 "e := get[inx]{T.put(e):at[inx]}" 
 -- OG:Qalloc:end: IS.newDescNo:  149 "e := get[inx]{   T.put(e):at[inx]}" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  28 3 %OSDvisibility skipInternal{%globals inSub;inx: var integer;inx := first;_doIt: do ;   if (inx <= last) :then ;    ...} 
 -- OG:super:  "for(first: var integer):to(last: var integer):repeat{repeat:< object}: {   %OSDvisibility skipInternal;   %globals inSub;   inx: var integer;   inx := first;   ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- super:  "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- E:  "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- OG:Qalloc:B: "for:to:repeat$0" newDescNo: 0 objSize: 3 
 -- OG:isObjectDesc:NewDescNo: 150 IS.newDescNo: 150 objSize: 3 1: 1 "" 
 -- Items:Qalloc:objSize: 0  newDescNo: 150 "" 
 -- Items:Qalloc:super: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" size: 3 "for:to:repeat$150" 
 -- super.isThisBlockLevel: false superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 4 originOff: 4 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 150 "" 
 -- IS.newDescNo: 150 IS.objSize: 3 "" 
 -- OG:Qalloc:end: IS.newDescNo:  150 "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- OG:Qalloc: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" qDescno:  0 
 -- OG:Qalloc:A:  "for:to:repeat$0"  super:  "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}"  marked:  false "e: var integer{i: var integer ...}" s ... f ... 
 -- Invocation:Qalloc: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- ObjectInvocation:Qalloc: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- name: "for:to:repeat" 
 -- Arguments "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- OG:Qalloc: "S.length" qDescno:  0 
 -- OG:Qalloc:A:  "length"  super:  "S.length"  marked:  false "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" super:  S.length 
 -- Invocation:Qalloc: "S.length" 
 -- ObjectInvocation:Qalloc: "S" 
 -- name: "S" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "length" 
 -- name: "length" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  15 2 out V: var integer{V := get[0] -- actually an index error, accessing length} 
 -- OG:super:  "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "S.length" 
 -- super:  "S.length" 
 -- E:  "length" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "S.length" 
 -- OG:Qalloc: "e := S.get[inx]{   i := L + inx;   T.put(e):at[i]}" qDescno:  0 
 -- OG:Qalloc:A:  "repeat$0"  super:  ""  marked:  false "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "e := S.get[inx]{   i := L + inx;   T.put(e):at[i]}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "repeat$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 151 IS.newDescNo: 151 objSize: 0 1: 1 "e := S.get[inx]{i := L + inx;T.put(e):at[i]}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 151 "e := S.get[inx]{i := L + inx;T.put(e):at[i]}" 
 -- Items:Qalloc:super: "" size: 1 "repeat$151" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "e" 
 -- ObjectInvocation:Qalloc: "e" 
 -- name: "e" 
 -- Arguments "" 
 -- OG:Qalloc: "S.get[inx]" qDescno:  0 
 -- OG:Qalloc:A:  "get"  super:  "S.get[inx]"  marked:  false "e := S.get[inx]" super:  S.get[inx] 
 -- Invocation:Qalloc: "S.get[inx]" 
 -- ObjectInvocation:Qalloc: "S" 
 -- name: "S" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "get[inx]" 
 -- name: "get" 
 -- Arguments "get[inx]" 
 -- OG:Qalloc: "inx" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "inx"  marked:  false "get[inx]" super:  inx 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "inx: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx" 
 -- super:  "inx" 
 -- E:  "inx" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  16 3 %basic 117{out ch: var char} 
 -- OG:super:  "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "S.get[inx]" 
 -- super:  "S.get[inx]" 
 -- E:  "get[inx]" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "S.get[inx]" 
 -- Invocation:Qalloc: "i" 
 -- ObjectInvocation:Qalloc: "i" 
 -- name: "i" 
 -- Arguments "" 
 -- OG:Qalloc: "L + inx" qDescno:  0 
 -- OG:Qalloc:A:  "+"  super:  "L + inx"  marked:  false "i := L + inx" super:  L + inx 
 -- Invocation:Qalloc: "L + inx" 
 -- BinaryExp:Qalloc: "L + inx" 
 -- Invocation:Qalloc: "L" 
 -- ObjectInvocation:Qalloc: "L" 
 -- name: "L" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "+ inx" 
 -- name: "+" 
 -- Arguments "inx" 
 -- OG:Qalloc: "inx" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "inx"  marked:  false "inx" super:  inx 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "inx: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx" 
 -- super:  "inx" 
 -- E:  "inx" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  49 5 %basic 61{in V: var integer;out R: var integer} 
 -- OG:super:  "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L + inx" 
 -- super:  "L + inx" 
 -- E:  "L + inx" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L + inx" 
 -- OG:Qalloc: "T.put(e):at[i]" qDescno:  0 
 -- OG:Qalloc:A:  "put:at"  super:  "T.put(e):at[i]"  marked:  false "e := S.get[inx]{i := L + inx;T.put(e):at[i]}" super:  T.put(e):at[i] 
 -- Invocation:Qalloc: "T.put(e):at[i]" 
 -- ObjectInvocation:Qalloc: "T" 
 -- name: "T" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "put(e):at[i]" 
 -- name: "put:at" 
 -- Arguments "put(e):at[i]" 
 -- OG:Qalloc: "e" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "e"  marked:  false "put(e):at[i]" super:  e 
 -- Invocation:Qalloc: "e" 
 -- ObjectInvocation:Qalloc: "e" 
 -- name: "e" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "e: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "e" 
 -- super:  "e" 
 -- E:  "e" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "e" 
 -- OG:Qalloc: "i" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "i"  marked:  false "put(e):at[i]" super:  i 
 -- Invocation:Qalloc: "i" 
 -- ObjectInvocation:Qalloc: "i" 
 -- name: "i" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "i: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "i" 
 -- super:  "i" 
 -- E:  "i" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "i" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  93 3 %basic 115 
 -- OG:super:  "put(V: var integer):at[inx: var integer]: {   %basic 115}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "T.put(e):at[i]" 
 -- super:  "T.put(e):at[i]" 
 -- E:  "put(e):at[i]" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "T.put(e):at[i]" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 151 "e := S.get[inx]{i := L + inx;T.put(e):at[i]}" 
 -- IS.newDescNo: 151 IS.objSize: 1 "e := S.get[inx]{i := L + inx;T.put(e):at[i]}" 
 -- OG:Qalloc:end: IS.newDescNo:  151 "e := S.get[inx]{   i := L + inx;   T.put(e):at[i]}" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  28 3 %OSDvisibility skipInternal{%globals inSub;inx: var integer;inx := first;_doIt: do ;   if (inx <= last) :then ;    ...} 
 -- OG:super:  "for(first: var integer):to(last: var integer):repeat{repeat:< object}: {   %OSDvisibility skipInternal;   %globals inSub;   inx: var integer;   inx := first;   ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- super:  "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- E:  "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- OG:Qalloc:B: "for:to:repeat$0" newDescNo: 0 objSize: 3 
 -- OG:isObjectDesc:NewDescNo: 152 IS.newDescNo: 152 objSize: 3 1: 1 "" 
 -- Items:Qalloc:objSize: 0  newDescNo: 152 "" 
 -- Items:Qalloc:super: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" size: 3 "for:to:repeat$152" 
 -- super.isThisBlockLevel: false superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 4 originOff: 4 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 152 "" 
 -- IS.newDescNo: 152 IS.objSize: 3 "" 
 -- OG:Qalloc:end: IS.newDescNo:  152 "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- Invocation:Qalloc: "V" 
 -- ObjectInvocation:Qalloc: "V" 
 -- name: "V" 
 -- Arguments "" 
 -- OG:Qalloc: "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" qDescno:  0 
 -- OG:Qalloc:A:  "asString"  super:  "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}"  marked:  false "V := T.asString{-- V: obj Index ...}" s ... T ... 
 -- Invocation:Qalloc: "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- ObjectInvocation:Qalloc: "T" 
 -- name: "T" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- name: "asString" 
 -- Arguments "-- V: obj Indexed(Length + S.length){-- V := T[1:length] + S.T[1:S.length]}" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 118{out S: var LIB.StringLib.String} 
 -- OG:Qalloc:SuperAlloc: "asString: {   %basic 118;   out S: var LIB.StringLib.String}" 
 -- OG:Qalloc: "%basic 118{   out S: var LIB.StringLib.String}" qDescno:  0 
 -- OG:Qalloc:A:  "asString"  super:  ""  marked:  false "asString: {   %basic 118;   out S: var LIB.StringLib.String}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 118{   out S: var LIB.StringLib.String}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "asString" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 153 IS.newDescNo: 153 objSize: 0 1: 1 "%basic 118{out S: var LIB.StringLib.String}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 153 "%basic 118{out S: var LIB.StringLib.String}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "S" isValue: false  isPrimitive: true  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "out S: var LIB.StringLib.String" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 153 "%basic 118{out S: var LIB.StringLib.String}" 
 -- IS.newDescNo: 153 IS.objSize: 2 "%basic 118{out S: var LIB.StringLib.String}" 
 -- OG:Qalloc:end: IS.newDescNo:  153 "%basic 118{   out S: var LIB.StringLib.String}" 
 -- OG:super:  "asString: {   %basic 118;   out S: var LIB.StringLib.String}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- super:  "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- E:  "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 148 "e: var integer{i: var integer;T: obj Indexed(L + S.length,Integer);for(1):to(L):repeat;   e := get[inx];   T.put(e):at[inx];;f ...}" 
 -- IS.newDescNo: 148 IS.objSize: 4 "e: var integer{i: var integer;T: obj Indexed(L + S.length,Integer);for(1):to(L):repeat;   e := get[inx];   T.put(e):at[inx];;for(1):to(S.l ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  148 "e: var integer{   i: var integer;   T: obj Indexed(L + S.length,Integer);   for(1):to(L):repeat;      e := get[inx];      T.put(e):at[in ...}" 
 -- ObjTmpStack:add: "doplus" : "e: var integer{   i: var integer;   T: obj Indexed(L + S.length,Integer);   for(1):to(L):repeat;      e := get[inx];      T.put(e):at[inx];    ...}" 
 -- items:markForCodeGen: "e: var integer{i: var integer;T: obj Indexed(L + S.length,Integer);for(1):to(L):repeat;   e := get[inx];   T.put(e):at[inx];;for(1):to(S.length):rep ...}" 
 -- DataItem:markForCodeGen: "e" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "i" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "T" :descNo: 0 :OG.primNo: 114 
 -- OG:markForCodeGen: "Indexed(L + S.length,Integer)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Indexed(L + S.length,Integer)" 
 -- "Indexed(L + S.length,Integer)" true 
 -- 
 -- OG:markSuper: "Indexed(L + S.length,Integer)" 
 -- Invocation:markForCodeGen: "Indexed(L + S.length,Integer)" 
 -- ObjectInvocation:markForCodeGen: "Indexed(L + S.length,Integer)"  ATd: "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   lengt ...}" 
 -- Pattern:markForCodeGen: "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "%globals{   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];   put(V: var  ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%globals{   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];   put(V: var integer) ...}" 
 -- OG:Qalloc: "%globals{   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];   put(V: var integer) ...}" q ... 86 
 -- ObjTmpStack:add: "Indexed" : "%globals{   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];   p ...}" 
 -- items:markForCodeGen: "%globals{%basic 114;%public;in range: var Integer;in elm:< Object;length: ;   out res: var integer;   res := get[0];put(V: var integer):at[inx: var  ...}" 
 -- markItem: "%globals" Property 
 -- markItem: "%basic 114" Property 
 -- markItem: "%public" Property 
 -- DataItem:markForCodeGen: "range" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "Integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Integer" 
 -- "Integer" true 
 -- 
 -- OG:markSuper: "Integer" 
 -- Invocation:markForCodeGen: "Integer" 
 -- ObjectInvocation:markForCodeGen: "Integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Integer"  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "in elm:< Object" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "Object" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Object" 
 -- "Object" true 
 -- 
 -- not ObjDesc:  "Object"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "(L + S.length,Integer)" 
 -- OG:markForCodeGen: "L + S.length" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "L + S.length" 
 -- "L + S.length" true 
 -- 
 -- OG:markSuper: "L + S.length" 
 -- Invocation:markForCodeGen: "L + S.length" 
 -- BinaryExp:markForCodeGen: "L + S.length" 
 -- Invocation:markForCodeGen: "L" 
 -- ObjectInvocation:markForCodeGen: "L"  ATd: "L: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "+ S.length"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OI:args:markForCodgen: "S.length" 
 -- OG:markForCodeGen: "S.length" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "S.length" 
 -- "S" true 
 -- "length" false 
 -- 
 -- OG:markSuper: "S.length" 
 -- Invocation:markForCodeGen: "S.length" 
 -- ObjectInvocation:markForCodeGen: "S"  ATd: "in S: var String" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "length"  ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "S.length"  IS.isEmpty:  true 
 -- not ObjDesc:  "L + S.length"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "Integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Integer" 
 -- "Integer" true 
 -- 
 -- OG:markSuper: "Integer" 
 -- Invocation:markForCodeGen: "Integer" 
 -- ObjectInvocation:markForCodeGen: "Integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Integer"  IS.isEmpty:  true 
 -- arg:   "L + S.length" 
 -- arg:   "Integer" 
 -- not ObjDesc:  "Indexed(L + S.length,Integer)"  IS.isEmpty:  true 
 -- markItem: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" ObjectGenerator 
 -- OG:markForCodeGen: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- isObjectDesc: true  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" false 
 -- 
 -- OG:markSuper: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- Invocation:markForCodeGen: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- ObjectInvocation:markForCodeGen: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}"  ATd: "for(first: var integer):to(last: var integer):repeat{repeat:< object}: ..." 
 -- OI:args:markForCodgen: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "L" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "L" 
 -- "L" true 
 -- 
 -- OG:markForCodeGen: "e := get[inx]{   T.put(e):at[inx]}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "e := get[inx]{   T.put(e):at[inx]}" 
 -- OG:Qalloc: "e := get[inx]{   T.put(e):at[inx]}" qDescno:  149 
 -- ObjTmpStack:add: "e := get[inx]{   T.put(e):at[inx]}" 
 -- items:markForCodeGen: "e := get[inx]{T.put(e):at[inx]}" 
 -- markItem: "e := get[inx]" Assign 
 -- Invocation:markForCodeGen: "e" 
 -- ObjectInvocation:markForCodeGen: "e"  ATd: "e: var integer" 
 -- OI:args:markForCodgen: "" 
 -- markItem: "T.put(e):at[inx]" ObjectGenerator 
 -- arg:   "1" 
 -- arg:   "L" 
 -- arg:   "e := get[inx]{   T.put(e):at[inx]}" 
 -- OG:markIS: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- OG:Qalloc: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" qDescno:  150 
 -- ObjTmpStack:add: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- items:markForCodeGen: "" 
 -- markItem: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" ObjectGenerator 
 -- OG:markForCodeGen: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- isObjectDesc: true  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" false 
 -- 
 -- OG:markSuper: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- Invocation:markForCodeGen: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- ObjectInvocation:markForCodeGen: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}"  ATd: "for(first: var integer):to(last: var integer):r ..." 
 -- OI:args:markForCodgen: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "S.length" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "S.length" 
 -- "S" true 
 -- "length" false 
 -- 
 -- OG:markSuper: "S.length" 
 -- Invocation:markForCodeGen: "S.length" 
 -- ObjectInvocation:markForCodeGen: "S"  ATd: "in S: var String" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "length"  ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "S.length"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "e := S.get[inx]{   i := L + inx;   T.put(e):at[i]}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "e := S.get[inx]{   i := L + inx;   T.put(e):at[i]}" 
 -- OG:Qalloc: "e := S.get[inx]{   i := L + inx;   T.put(e):at[i]}" qDescno:  151 
 -- ObjTmpStack:add: "e := S.get[inx]{   i := L + inx;   T.put(e):at[i]}" 
 -- items:markForCodeGen: "e := S.get[inx]{i := L + inx;T.put(e):at[i]}" 
 -- markItem: "e := S.get[inx]" Assign 
 -- Invocation:markForCodeGen: "e" 
 -- ObjectInvocation:markForCodeGen: "e"  ATd: "e: var integer" 
 -- OI:args:markForCodgen: "" 
 -- markItem: "i := L + inx" Assign 
 -- Invocation:markForCodeGen: "i" 
 -- ObjectInvocation:markForCodeGen: "i"  ATd: "i: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "L + inx" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "L + inx" 
 -- "L + inx" true 
 -- 
 -- OG:markSuper: "L + inx" 
 -- Invocation:markForCodeGen: "L + inx" 
 -- BinaryExp:markForCodeGen: "L + inx" 
 -- Invocation:markForCodeGen: "L" 
 -- ObjectInvocation:markForCodeGen: "L"  ATd: "L: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "+ inx"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OI:args:markForCodgen: "inx" 
 -- OG:markForCodeGen: "inx" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "inx" 
 -- "inx" true 
 -- 
 -- not ObjDesc:  "L + inx"  IS.isEmpty:  true 
 -- markItem: "T.put(e):at[i]" ObjectGenerator 
 -- arg:   "1" 
 -- arg:   "S.length" 
 -- arg:   "e := S.get[inx]{   i := L + inx;   T.put(e):at[i]}" 
 -- OG:markIS: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- OG:Qalloc: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" qDescno:  152 
 -- ObjTmpStack:add: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- items:markForCodeGen: "" 
 -- markItem: "V := T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" Assign 
 -- Invocation:markForCodeGen: "V" 
 -- ObjectInvocation:markForCodeGen: "V"  ATd: "out V: var String" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- "T" true 
 -- "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" true 
 -- 
 -- OG:markSuper: "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- Invocation:markForCodeGen: "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- ObjectInvocation:markForCodeGen: "T"  ATd: "T: obj Indexed(L + S.length,Integer)" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}"  ATd: "asString: {   %basic 118;   out S: var LIB.S ...}" 
 -- Pattern:markForCodeGen: "asString: {   %basic 118;   out S: var LIB.StringLib.String}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "%basic 118{   out S: var LIB.StringLib.String}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%basic 118{   out S: var LIB.StringLib.String}" 
 -- OG:Qalloc: "%basic 118{   out S: var LIB.StringLib.String}" qDescno:  153 
 -- ObjTmpStack:add: "asString" : "%basic 118{   out S: var LIB.StringLib.String}" 
 -- items:markForCodeGen: "%basic 118{out S: var LIB.StringLib.String}" 
 -- markItem: "%basic 118" Property 
 -- DataItem:markForCodeGen: "S" :descNo: 0 :OG.primNo: 5 
 -- OG:markForCodeGen: "LIB.StringLib.String" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "LIB.StringLib.String" 
 -- "LIB" false 
 -- "StringLib" false 
 -- "String" true 
 -- 
 -- not ObjDesc:  "LIB.StringLib.String"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "-- V: obj Indexed(Length + S.length){-- V := T[1:length] + S.T[1:S.length]}" 
 -- not ObjDesc:  "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" not free after 10000 attempts"" 
 -- OG:markForCodeGen: "" not free after 10000 attempts"" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "" not free after 10000 attempts"" 
 -- "" not free after 10000 attempts"" true 
 -- 
 -- OG:markSuper: "" not free after 10000 attempts"" 
 -- Invocation:markForCodeGen: "" not free after 10000 attempts"" 
 -- not ObjDesc:  "" not free after 10000 attempts""  IS.isEmpty:  true 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "(id + " not free after 10000 attempts").print"  IS.isEmpty:  true 
 -- markItem: "i := 0" Assign 
 -- Invocation:markForCodeGen: "i" 
 -- ObjectInvocation:markForCodeGen: "i"  ATd: "i: var integer{--disable}" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "0" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "0" 
 -- "0" true 
 -- 
 -- OG:markSuper: "0" 
 -- Invocation:markForCodeGen: "0" 
 -- not ObjDesc:  "0"  IS.isEmpty:  true 
 -- not ObjDesc:  "if (i > 10000) :then {   (id + " not free after 10000 attempts").print;   i := 0}"  IS.isEmpty:  true 
 -- markItem: "restart(loop)" ObjectGenerator 
 -- not ObjDesc:  "if (res = 1) :then {   --enablesleep(50);   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts").print;      i := 0;   restart( ...}"   ... true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "L.get"  IS.isEmpty:  true 
 -- markItem: "V := V + 1" Assign 
 -- Invocation:markForCodeGen: "V" 
 -- ObjectInvocation:markForCodeGen: "V"  ATd: "V: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "V + 1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "V + 1" 
 -- "V + 1" true 
 -- 
 -- OG:markSuper: "V + 1" 
 -- Invocation:markForCodeGen: "V + 1" 
 -- BinaryExp:markForCodeGen: "V + 1" 
 -- Invocation:markForCodeGen: "V" 
 -- ObjectInvocation:markForCodeGen: "V"  ATd: "V: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "+ 1"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OI:args:markForCodgen: "1" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- not ObjDesc:  "V + 1"  IS.isEmpty:  true 
 -- markItem: "if (V > 1) :then {   put('V')}" ObjectGenerator 
 -- OG:markForCodeGen: "if (V > 1) :then {   put('V')}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (V > 1) :then {   put('V')}" 
 -- "if (V > 1) :then {   put('V')}" true 
 -- 
 -- OG:markSuper: "if (V > 1) :then {   put('V')}" 
 -- Invocation:markForCodeGen: "if (V > 1) :then {   put('V')}" 
 -- OG:markForCodeGen: "(V > 1)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(V > 1)" 
 -- "(V > 1)" true 
 -- 
 -- OG:markSuper: "(V > 1)" 
 -- Invocation:markForCodeGen: "(V > 1)" 
 -- Invocation:markForCodeGen: "V > 1" 
 -- BinaryExp:markForCodeGen: "V > 1" 
 -- Invocation:markForCodeGen: "V" 
 -- ObjectInvocation:markForCodeGen: "V"  ATd: "V: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "> 1"  ATd: ">  : {   %basic 53;   in V: var integer;   out B: var boolean}" 
 -- OI:args:markForCodgen: "1" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- not ObjDesc:  "(V > 1)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "put('V')" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "put('V')" 
 -- OG:Qalloc: "put('V')" qDescno:  107 
 -- ObjTmpStack:add: "put('V')" 
 -- items:markForCodeGen: "put('V')" 
 -- markItem: "put('V')" ObjectGenerator 
 -- OG:markForCodeGen: "put('V')" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "put('V')" 
 -- "put('V')" true 
 -- 
 -- OG:markSuper: "put('V')" 
 -- Invocation:markForCodeGen: "put('V')" 
 -- ObjectInvocation:markForCodeGen: "put('V')"  ATd: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OI:args:markForCodgen: "put('V')" 
 -- OG:markForCodeGen: "'V'" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "'V'" 
 -- "'V'" true 
 -- 
 -- OG:markSuper: "'V'" 
 -- Invocation:markForCodeGen: "'V'" 
 -- not ObjDesc:  "'V'"  IS.isEmpty:  true 
 -- arg:   "'V'" 
 -- not ObjDesc:  "put('V')"  IS.isEmpty:  true 
 -- not ObjDesc:  "if (V > 1) :then {   put('V')}"  IS.isEmpty:  true 
 -- markItem: "inner(entry)" ObjectGenerator 
 -- markItem: "V := V - 1" Assign 
 -- Invocation:markForCodeGen: "V" 
 -- ObjectInvocation:markForCodeGen: "V"  ATd: "V: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "V - 1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "V - 1" 
 -- "V - 1" true 
 -- 
 -- OG:markSuper: "V - 1" 
 -- Invocation:markForCodeGen: "V - 1" 
 -- BinaryExp:markForCodeGen: "V - 1" 
 -- Invocation:markForCodeGen: "V" 
 -- ObjectInvocation:markForCodeGen: "V"  ATd: "V: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "- 1"  ATd: "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- Pattern:markForCodeGen: "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- items:markForCodeGen: "" 
 -- OI:args:markForCodgen: "1" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- not ObjDesc:  "V - 1"  IS.isEmpty:  true 
 -- markItem: "L.free" ObjectGenerator 
 -- OG:markForCodeGen: "L.free" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "L.free" 
 -- "L" false 
 -- "free" false 
 -- 
 -- OG:markSuper: "L.free" 
 -- Invocation:markForCodeGen: "L.free" 
 -- ObjectInvocation:markForCodeGen: "L"  ATd: "L: obj Lock("SQS:Lock:")" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "free"  ATd: "free: {   free_M := 0}" 
 -- Pattern:markForCodeGen: "free: {   free_M := 0}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "free_M := 0" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "free_M := 0" 
 -- OG:Qalloc: "free_M := 0" qDescno:  109 
 -- ObjTmpStack:add: "free" : "free_M := 0" 
 -- items:markForCodeGen: "free_M := 0" 
 -- markItem: "free_M := 0" Assign 
 -- Invocation:markForCodeGen: "free_M" 
 -- ObjectInvocation:markForCodeGen: "free_M"  ATd: "free_M: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "0" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "0" 
 -- "0" true 
 -- 
 -- OG:markSuper: "0" 
 -- Invocation:markForCodeGen: "0" 
 -- not ObjDesc:  "0"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "L.free"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "entry{   in P: ref BasicProcess;   if (Q.has(P).not) :then ;      Q.insert(P)}" 
 -- OG:Qalloc: "entry{   in P: ref BasicProcess;   if (Q.has(P).not) :then ;      Q.insert(P)}" qDescno:  139 
 -- ObjTmpStack:add: "insert" : "entry{   in P: ref BasicProcess;   if (Q.has(P).not) :then ;      Q.insert(P)}" 
 -- items:markForCodeGen: "in P: ref BasicProcess{if (Q.has(P).not) :then ;   Q.insert(P)}" 
 -- DataItem:markForCodeGen: "P" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "BasicProcess" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "BasicProcess" 
 -- "BasicProcess" false 
 -- 
 -- not ObjDesc:  "BasicProcess"  IS.isEmpty:  true 
 -- markItem: "if (Q.has(P).not) :then {   Q.insert(P)}" ObjectGenerator 
 -- OG:markForCodeGen: "if (Q.has(P).not) :then {   Q.insert(P)}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (Q.has(P).not) :then {   Q.insert(P)}" 
 -- "if (Q.has(P).not) :then {   Q.insert(P)}" true 
 -- 
 -- OG:markSuper: "if (Q.has(P).not) :then {   Q.insert(P)}" 
 -- Invocation:markForCodeGen: "if (Q.has(P).not) :then {   Q.insert(P)}" 
 -- OG:markForCodeGen: "(Q.has(P).not)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(Q.has(P).not)" 
 -- "(Q.has(P).not)" true 
 -- 
 -- OG:markSuper: "(Q.has(P).not)" 
 -- Invocation:markForCodeGen: "(Q.has(P).not)" 
 -- Invocation:markForCodeGen: "Q.has(P).not" 
 -- ObjectInvocation:markForCodeGen: "Q"  ATd: "Q: obj ProcessQueue" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "has(P)"  ATd: "has: {   in elm: ref Object;   out B: var Boolean;   scan;      if (elm == current) :then ;         --"Queue:has:elm\n".pr ...}" 
 -- Pattern:markForCodeGen: "has: {   in elm: ref Object;   out B: var Boolean;   scan;      if (elm == current) :then ;         --"Queue:has:elm\n".printB := true;         le ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "in elm: ref Object{   out B: var Boolean;   scan;      if (elm == current) :then ;         --"Queue:has:elm\n".printB := true;         leave(has)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "in elm: ref Object{   out B: var Boolean;   scan;      if (elm == current) :then ;         --"Queue:has:elm\n".printB := true;         leave(has)}" 
 -- OG:Qalloc: "in elm: ref Object{   out B: var Boolean;   scan;      if (elm == current) :then ;         --"Queue:has:elm\n".printB := true;         leave(has)}" qDescno:  0 
 -- OG:Qalloc:A:  "has"  super:  ""  marked:  true "has: {   in elm: ref Object;   out B: var Boolean;   scan;      if (elm == current) :then ;         --"Queue:has:elm\n".pri ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "in elm: ref Object{   out B: var Boolean;   scan;      if (elm == current) :then ;         --"Queue:has:elm\n".printB := true;         leave(has)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "has" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 154 IS.newDescNo: 154 objSize: 0 1: 1 "in elm: ref Object{out B: var Boolean;scan;   if (elm == current) :then ;      --"Queue:has:elm\n".printB ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 154 "in elm: ref Object{out B: var Boolean;scan;   if (elm == current) :then ;      --"Queue:has:elm\n".printB := true;      leave(has) ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "elm" isValue: false  isPrimitive: true  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "in elm: ref Object" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- dataitem:qalloc: "B" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- OG:Qalloc: "scan{   if (elm == current) :then ;      --"Queue:has:elm\n".printB := true;      leave(has)}" qDescno:  0 
 -- OG:Qalloc:A:  "scan$0"  super:  "scan"  marked:  false "in elm: ref Object{out B: var Boolean;scan;   if (elm == current) :then ;      --"Queue:has:elm\n".printB := true;  ...}" s ... s ... 
 -- Invocation:Qalloc: "scan" 
 -- ObjectInvocation:Qalloc: "scan" 
 -- name: "scan" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %Public{current: ref Object;currentElement: ref Element;currentElement := head;loop: ;   if (currentElement =/= non ...} 
 -- OG:Qalloc:SuperAlloc: "scan: {   %Public;   current: ref Object;   currentElement: ref Element;   currentElement := head;   loop: ;      if (currentElement =/= none) :then ...}" 
 -- OG:Qalloc: "%Public{   current: ref Object;   currentElement: ref Element;   currentElement := head;   loop: ;      if (currentElement =/= none) :then ;         current := ...}" q ... 0 
 -- OG:Qalloc:A:  "scan"  super:  ""  marked:  false "scan: {   %Public;   current: ref Object;   currentElement: ref Element;   currentElement := head;   loop: ;      if (cur ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%Public{   current: ref Object;   currentElement: ref Element;   currentElement := head;   loop: ;      if (currentElement =/= none) :then ;         current := currentEle ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "scan" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 155 IS.newDescNo: 155 objSize: 0 1: 1 "%Public{current: ref Object;currentElement: ref Element;currentElement := head;loop: ;   if (currentEleme ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 155 "%Public{current: ref Object;currentElement: ref Element;currentElement := head;loop: ;   if (currentElement =/= none) :then ;      ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "current" isValue: false  isPrimitive: true  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "current: ref Object" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- dataitem:qalloc: "currentElement" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 3 "currentElement: ref Element" 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- Invocation:Qalloc: "currentElement" 
 -- ObjectInvocation:Qalloc: "currentElement" 
 -- name: "currentElement" 
 -- Arguments "" 
 -- OG:Qalloc: "head" qDescno:  0 
 -- OG:Qalloc:A:  "Element"  super:  "head"  marked:  false "currentElement := head" super:  head 
 -- Invocation:Qalloc: "head" 
 -- ObjectInvocation:Qalloc: "head" 
 -- name: "head" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  137 6 in elm: ref Object{out res: ref Element;id: var integer;pred: ref Element;succ: ref Element;res := this(Element); ...} 
 -- OG:super:  "head: ref Element" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "head" 
 -- super:  "head" 
 -- E:  "head" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "head" 
 -- Pattern:Qalloc: loop 
 -- Pattern:Qalloc:B: loop 
 -- OG:Qalloc: "loop" qDescno:  0 
 -- OG:Qalloc:A:  "loop"  super:  "loop"  marked:  false "%Public{current: ref Object;currentElement: ref Element;currentElement := head;loop: ;   if (currentElement =/= none) ...}" s ... l ... 
 -- Invocation:Qalloc: "loop" 
 -- ObjectInvocation:Qalloc: "loop" 
 -- name: "loop" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentElement := currentEle ...} 
 -- OG:Qalloc:SuperAlloc: "loop: {   if (currentElement =/= none) :then ;      current := currentElement.elm;      inner(scan);      currentElement := currentElement.succ;     ...}" 
 -- OG:Qalloc: "if (currentElement =/= none) :then {      current := currentElement.elm;      inner(scan);      currentElement := currentElement.succ;      restart(loop)}" qDe ... 0 
 -- OG:Qalloc:A:  "loop"  super:  ""  marked:  false "loop: {   if (currentElement =/= none) :then ;      current := currentElement.elm;      inner(scan);      currentElement  ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "if (currentElement =/= none) :then {      current := currentElement.elm;      inner(scan);      currentElement := currentElement.succ;      restart(loop)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "loop" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 156 IS.newDescNo: 156 objSize: 0 1: 1 "if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentElement :=  ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 156 "if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentElement := currentElement.succ;   re ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- OG:Qalloc: "if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentElement := currentElement.succ;   restart(loop)}" qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentElement := currentElement.succ;   restart ...}"   ... false "i ..." s ... i ... 
 -- Invocation:Qalloc: "if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentElement := currentElement.succ;   restart(loop)}" 
 -- OG:Qalloc: "(currentElement =/= none)" qDescno:  0 
 -- OG:Qalloc:A:  "=/="  super:  "(currentElement =/= none)"  marked:  false "if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentEle ...}" s ... ( ... 
 -- Invocation:Qalloc: "(currentElement =/= none)" 
 -- Invocation:Qalloc: "currentElement =/= none" 
 -- BinaryExp:Qalloc: "currentElement =/= none" 
 -- Invocation:Qalloc: "currentElement" 
 -- ObjectInvocation:Qalloc: "currentElement" 
 -- name: "currentElement" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "=/= none" 
 -- name: "=/=" 
 -- Arguments "none" 
 -- OG:Qalloc: "none" qDescno:  0 
 -- OG:Qalloc:A:  "none"  super:  "none"  marked:  false "none" super:  none 
 -- Invocation:Qalloc: "none" 
 -- ObjectInvocation:Qalloc: "none" 
 -- name: "none" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  116 2 %basic 19{none_x: var integer} 
 -- OG:super:  "none: {   %basic 19;   none_x: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "none" 
 -- super:  "none" 
 -- E:  "none" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "none" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  117 3 %basic 57{in objx: ref Object;out V: var boolean} 
 -- OG:super:  "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(currentElement =/= none)" 
 -- super:  "(currentElement =/= none)" 
 -- E:  "(currentElement =/= none)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(currentElement =/= none)" 
 -- OG:Qalloc: "current := currentElement.elm{   inner(scan);   currentElement := currentElement.succ;   restart(loop)}" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentElement := currentElement.suc ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "current := currentElement.elm{   inner(scan);   currentElement := currentElement.succ;   restart(loop)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 157 IS.newDescNo: 157 objSize: 0 1: 1 "current := currentElement.elm{inner(scan);currentElement := currentElement.succ;restart(loop)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 157 "current := currentElement.elm{inner(scan);currentElement := currentElement.succ;restart(loop)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "current" 
 -- ObjectInvocation:Qalloc: "current" 
 -- name: "current" 
 -- Arguments "" 
 -- OG:Qalloc: "currentElement.elm" qDescno:  0 
 -- OG:Qalloc:A:  "Object"  super:  "currentElement.elm"  marked:  false "current := currentElement.elm" super:  currentElement.elm 
 -- Invocation:Qalloc: "currentElement.elm" 
 -- ObjectInvocation:Qalloc: "currentElement" 
 -- name: "currentElement" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "elm" 
 -- name: "elm" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:super:  "in elm: ref Object" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "currentElement.elm" 
 -- super:  "currentElement.elm" 
 -- E:  "elm" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "currentElement.elm" 
 -- OG:Qalloc: "inner(scan)" qDescno:  0 
 -- OG:Qalloc:A:  "inner"  super:  "inner(scan)"  marked:  false "current := currentElement.elm{inner(scan);currentElement := currentElement.succ;restart(loop)}" super:  inner ... 
 -- Invocation:Qalloc: "inner(scan)" 
 -- ObjectInvocation:Qalloc: "inner(scan)" 
 -- name: "inner" 
 -- Arguments "inner(scan)" 
 -- OG:Qalloc: "scan" qDescno:  0 
 -- OG:Qalloc:A:  "scan"  super:  "scan"  marked:  false "inner(scan)" super:  scan 
 -- Invocation:Qalloc: "scan" 
 -- ObjectInvocation:Qalloc: "scan" 
 -- name: "scan" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  155 3 %Public{current: ref Object;currentElement: ref Element;currentElement := head;loop: ;   if (currentElement =/= n ...} 
 -- OG:super:  "scan: {   %Public;   current: ref Object;   currentElement: ref Element;   currentElement := head;   loop: ;      if (currentElement =/= none) :then ;          ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "scan" 
 -- super:  "scan" 
 -- E:  "scan" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "scan" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 %basic 101{in inner: ref Object} 
 -- OG:super:  "inner: {   %basic 101;   in inner: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(scan)" 
 -- super:  "inner(scan)" 
 -- E:  "inner(scan)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(scan)" 
 -- Invocation:Qalloc: "currentElement" 
 -- ObjectInvocation:Qalloc: "currentElement" 
 -- name: "currentElement" 
 -- Arguments "" 
 -- OG:Qalloc: "currentElement.succ" qDescno:  0 
 -- OG:Qalloc:A:  "Element"  super:  "currentElement.succ"  marked:  false "currentElement := currentElement.succ" super:  currentElement.succ 
 -- Invocation:Qalloc: "currentElement.succ" 
 -- ObjectInvocation:Qalloc: "currentElement" 
 -- name: "currentElement" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "succ" 
 -- name: "succ" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  137 6 in elm: ref Object{out res: ref Element;id: var integer;pred: ref Element;succ: ref Element;res := this(Element); ...} 
 -- OG:super:  "succ: ref Element" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "currentElement.succ" 
 -- super:  "currentElement.succ" 
 -- E:  "succ" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "currentElement.succ" 
 -- OG:Qalloc: "restart(loop)" qDescno:  0 
 -- OG:Qalloc:A:  "restart"  super:  "restart(loop)"  marked:  false "current := currentElement.elm{inner(scan);currentElement := currentElement.succ;restart(loop)}" super:  r ... 
 -- Invocation:Qalloc: "restart(loop)" 
 -- ObjectInvocation:Qalloc: "restart(loop)" 
 -- name: "restart" 
 -- Arguments "restart(loop)" 
 -- OG:Qalloc: "loop" qDescno:  0 
 -- OG:Qalloc:A:  "loop"  super:  "loop"  marked:  false "restart(loop)" super:  loop 
 -- Invocation:Qalloc: "loop" 
 -- ObjectInvocation:Qalloc: "loop" 
 -- name: "loop" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  156 1 if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentElement := currentE ...} 
 -- OG:super:  "loop: {   if (currentElement =/= none) :then ;      current := currentElement.elm;      inner(scan);      currentElement := currentElement.succ;      restart(l ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "loop" 
 -- super:  "loop" 
 -- E:  "loop" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "loop" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  50 2 %basic 102 
 -- OG:super:  "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "restart(loop)" 
 -- super:  "restart(loop)" 
 -- E:  "restart(loop)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "restart(loop)" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 157 "current := currentElement.elm{inner(scan);currentElement := currentElement.succ;restart(loop)}" 
 -- IS.newDescNo: 157 IS.objSize: 1 "current := currentElement.elm{inner(scan);currentElement := currentElement.succ;restart(loop)}" 
 -- OG:Qalloc:end: IS.newDescNo:  157 "current := currentElement.elm{   inner(scan);   currentElement := currentElement.succ;   restart(loop)}" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentElement := currentElement.succ;   restart(loop)}" 
 -- super:  "if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentElement := currentElement.succ;   restart(loop)}" 
 -- E:  "if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentElement := currentElement.succ;   restart(loop)}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentElement := currentElement.succ;   restart(lo ...}" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 156 "if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentElement := currentElement.succ;  ...}" 
 -- IS.newDescNo: 156 IS.objSize: 1 "if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentElement := currentElement.succ;   restart(lo ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  156 "if (currentElement =/= none) :then {      current := currentElement.elm;      inner(scan);      currentElement := currentElement.succ;   ...}" 
 -- OG:super:  "loop: {   if (currentElement =/= none) :then ;      current := currentElement.elm;      inner(scan);      currentElement := currentElement.succ;      restart(l ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "loop" 
 -- super:  "loop" 
 -- E:  "loop" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "loop" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 155 "%Public{current: ref Object;currentElement: ref Element;currentElement := head;loop: ;   if (currentElement =/= none) :then ;  ...}" 
 -- IS.newDescNo: 155 IS.objSize: 3 "%Public{current: ref Object;currentElement: ref Element;currentElement := head;loop: ;   if (currentElement =/= none) :then ;      current ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  155 "%Public{   current: ref Object;   currentElement: ref Element;   currentElement := head;   loop: ;      if (currentElement =/= none) :th ...}" 
 -- OG:super:  "scan: {   %Public;   current: ref Object;   currentElement: ref Element;   currentElement := head;   loop: ;      if (currentElement =/= none) :then ;          ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "scan{   if (elm == current) :then ;      --"Queue:has:elm\n".printB := true;      leave(has)}" 
 -- super:  "scan" 
 -- E:  "scan" 
 -- OG:Qalloc:B: "scan$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 158 IS.newDescNo: 158 objSize: 0 1: 1 "if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 158 "if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)}" 
 -- Items:Qalloc:super: "scan" size: 3 "scan$158" 
 -- super.isThisBlockLevel: false superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 4 originOff: 4 
 -- OG:Qalloc: "if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)}" qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)}"  marked:  false "if (elm == current) :then {   --"Queu ..."}" s ... i ... 
 -- Invocation:Qalloc: "if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)}" 
 -- OG:Qalloc: "(elm == current)" qDescno:  0 
 -- OG:Qalloc:A:  "=="  super:  "(elm == current)"  marked:  false "if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)}" super:  (elm == current) 
 -- Invocation:Qalloc: "(elm == current)" 
 -- Invocation:Qalloc: "elm == current" 
 -- BinaryExp:Qalloc: "elm == current" 
 -- Invocation:Qalloc: "elm" 
 -- ObjectInvocation:Qalloc: "elm" 
 -- name: "elm" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "== current" 
 -- name: "==" 
 -- Arguments "current" 
 -- OG:Qalloc: "current" qDescno:  0 
 -- OG:Qalloc:A:  "Object"  super:  "current"  marked:  false "current" super:  current 
 -- Invocation:Qalloc: "current" 
 -- ObjectInvocation:Qalloc: "current" 
 -- name: "current" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:super:  "current: ref Object" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "current" 
 -- super:  "current" 
 -- E:  "current" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "current" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  144 3 %basic 56{in objx: ref Object;out V: var boolean} 
 -- OG:super:  "==  : {   %basic 56;   in objx: ref Object;   out V: var boolean}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(elm == current)" 
 -- super:  "(elm == current)" 
 -- E:  "(elm == current)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(elm == current)" 
 -- OG:Qalloc: "--"Queue:has:elm\n".printB := true{   leave(has)}" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "--"Queue:has:elm\n".printB := true{   leave(has)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 159 IS.newDescNo: 159 objSize: 0 1: 1 "--"Queue:has:elm\n".printB := true{leave(has)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 159 "--"Queue:has:elm\n".printB := true{leave(has)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "B" 
 -- ObjectInvocation:Qalloc: "B" 
 -- name: "B" 
 -- Arguments "" 
 -- OG:Qalloc: "true" qDescno:  0 
 -- OG:Qalloc:A:  "True"  super:  "true"  marked:  false "B := true" super:  true 
 -- Invocation:Qalloc: "true" 
 -- ObjectInvocation:Qalloc: "true" 
 -- name: "true" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  23 1 %globals{out B: var boolean;B := 1} 
 -- OG:super:  "True: {   %globals;   out B: var boolean;   B := 1}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "true" 
 -- super:  "true" 
 -- E:  "true" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "true" 
 -- OG:Qalloc: "leave(has)" qDescno:  0 
 -- OG:Qalloc:A:  "leave"  super:  "leave(has)"  marked:  false "--"Queue:has:elm\n".printB := true{leave(has)}" super:  leave(has) 
 -- Invocation:Qalloc: "leave(has)" 
 -- ObjectInvocation:Qalloc: "leave(has)" 
 -- name: "leave" 
 -- Arguments "leave(has)" 
 -- OG:Qalloc: "has" qDescno:  0 
 -- OG:Qalloc:A:  "has"  super:  "has"  marked:  false "leave(has)" super:  has 
 -- Invocation:Qalloc: "has" 
 -- ObjectInvocation:Qalloc: "has" 
 -- name: "has" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  154 3 in elm: ref Object{out B: var Boolean;scan;   if (elm == current) :then ;      --"Queue:has:elm\n".printB := true ...} 
 -- OG:super:  "has: {   in elm: ref Object;   out B: var Boolean;   scan;      if (elm == current) :then ;         --"Queue:has:elm\n".printB := true;         leave(has)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "has" 
 -- super:  "has" 
 -- E:  "has" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "has" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  19 2 %basic 103 
 -- OG:super:  "leave(V: var integer): {   %basic 103}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "leave(has)" 
 -- super:  "leave(has)" 
 -- E:  "leave(has)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "leave(has)" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 159 "--"Queue:has:elm\n".printB := true{leave(has)}" 
 -- IS.newDescNo: 159 IS.objSize: 1 "--"Queue:has:elm\n".printB := true{leave(has)}" 
 -- OG:Qalloc:end: IS.newDescNo:  159 "--"Queue:has:elm\n".printB := true{   leave(has)}" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)}" 
 -- super:  "if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)}" 
 -- E:  "if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)}" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 158 "if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)}" 
 -- IS.newDescNo: 158 IS.objSize: 4 "if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)}" 
 -- OG:Qalloc:end: IS.newDescNo:  158 "scan{   if (elm == current) :then ;      --"Queue:has:elm\n".printB := true;      leave(has)}" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 154 "in elm: ref Object{out B: var Boolean;scan;   if (elm == current) :then ;      --"Queue:has:elm\n".printB := true;      leave( ...}" 
 -- IS.newDescNo: 154 IS.objSize: 3 "in elm: ref Object{out B: var Boolean;scan;   if (elm == current) :then ;      --"Queue:has:elm\n".printB := true;      leave(has)}" 
 -- OG:Qalloc:end: IS.newDescNo:  154 "in elm: ref Object{   out B: var Boolean;   scan;      if (elm == current) :then ;         --"Queue:has:elm\n".printB := true;         l ...}" 
 -- ObjTmpStack:add: "has" : "in elm: ref Object{   out B: var Boolean;   scan;      if (elm == current) :then ;         --"Queue:has:elm\n".printB := true;         leave(has) ...}" 
 -- items:markForCodeGen: "in elm: ref Object{out B: var Boolean;scan;   if (elm == current) :then ;      --"Queue:has:elm\n".printB := true;      leave(has)}" 
 -- DataItem:markForCodeGen: "elm" :descNo: 0 :OG.primNo: 64 
 -- OG:markForCodeGen: "Object" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Object" 
 -- "Object" true 
 -- 
 -- not ObjDesc:  "Object"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "B" :descNo: 0 :OG.primNo: 4 
 -- OG:markForCodeGen: "Boolean" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Boolean" 
 -- "Boolean" true 
 -- 
 -- OG:markSuper: "Boolean" 
 -- Invocation:markForCodeGen: "Boolean" 
 -- ObjectInvocation:markForCodeGen: "Boolean"  ATd: "Boolean: value{   %id "Boolean";   %globals inSub;   %basic 4, 8;   %public;   _thisBasicValue: var Universal;   &&  : ;  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Boolean"  IS.isEmpty:  true 
 -- markItem: "scan{   if (elm == current) :then ;      --"Queue:has:elm\n".printB := true;      leave(has)}" ObjectGenerator 
 -- OG:markForCodeGen: "scan{   if (elm == current) :then ;      --"Queue:has:elm\n".printB := true;      leave(has)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "scan" 
 -- "scan" false 
 -- 
 -- OG:markSuper: "scan" 
 -- Invocation:markForCodeGen: "scan" 
 -- ObjectInvocation:markForCodeGen: "scan"  ATd: "scan: {   %Public;   current: ref Object;   currentElement: ref Element;   currentElement := head;   loop: ;      if (curren ...}" 
 -- Pattern:markForCodeGen: "scan: {   %Public;   current: ref Object;   currentElement: ref Element;   currentElement := head;   loop: ;      if (currentElement =/= none) :th ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "%Public{   current: ref Object;   currentElement: ref Element;   currentElement := head;   loop: ;      if (currentElement =/= none) :then ;         cu ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%Public{   current: ref Object;   currentElement: ref Element;   currentElement := head;   loop: ;      if (currentElement =/= none) :then ;         current := ...}" 
 -- OG:Qalloc: "%Public{   current: ref Object;   currentElement: ref Element;   currentElement := head;   loop: ;      if (currentElement =/= none) :then ;         current := ...}" q ... 155 
 -- ObjTmpStack:add: "scan" : "%Public{   current: ref Object;   currentElement: ref Element;   currentElement := head;   loop: ;      if (currentElement =/= none) :then ;     ...}" 
 -- items:markForCodeGen: "%Public{current: ref Object;currentElement: ref Element;currentElement := head;loop: ;   if (currentElement =/= none) :then ;      current := curren ...}" 
 -- markItem: "%Public" Property 
 -- DataItem:markForCodeGen: "current" :descNo: 0 :OG.primNo: 64 
 -- OG:markForCodeGen: "Object" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Object" 
 -- "Object" true 
 -- 
 -- not ObjDesc:  "Object"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "currentElement" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Element" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Element" 
 -- "Element" false 
 -- 
 -- not ObjDesc:  "Element"  IS.isEmpty:  true 
 -- markItem: "currentElement := head" Assign 
 -- Invocation:markForCodeGen: "currentElement" 
 -- ObjectInvocation:markForCodeGen: "currentElement"  ATd: "currentElement: ref Element" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "head" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "head" 
 -- "head" false 
 -- 
 -- markItem: "loop" ObjectGenerator 
 -- OG:markForCodeGen: "loop" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "loop" 
 -- "loop" false 
 -- 
 -- OG:markSuper: "loop" 
 -- Invocation:markForCodeGen: "loop" 
 -- ObjectInvocation:markForCodeGen: "loop"  ATd: "loop: {   if (currentElement =/= none) :then ;      current := currentElement.elm;      inner(scan);      currentElement :=  ...}" 
 -- Pattern:markForCodeGen: "loop: {   if (currentElement =/= none) :then ;      current := currentElement.elm;      inner(scan);      currentElement := currentElement.succ;   ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "if (currentElement =/= none) :then {      current := currentElement.elm;      inner(scan);      currentElement := currentElement.succ;      restart(loo ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "if (currentElement =/= none) :then {      current := currentElement.elm;      inner(scan);      currentElement := currentElement.succ;      restart(loop)}" 
 -- OG:Qalloc: "if (currentElement =/= none) :then {      current := currentElement.elm;      inner(scan);      currentElement := currentElement.succ;      restart(loop)}" qDe ... 156 
 -- ObjTmpStack:add: "loop" : "if (currentElement =/= none) :then {      current := currentElement.elm;      inner(scan);      currentElement := currentElement.succ;      rest ...}" 
 -- items:markForCodeGen: "if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentElement := currentElement.succ;   restart(loop)}" 
 -- markItem: "if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentElement := currentElement.succ;   restart(loop)}" ObjectGenerator 
 -- OG:markForCodeGen: "if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentElement := currentElement.succ;   restart(loop)}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentElement := currentElement.succ;   restart(loop)}" 
 -- "if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentElement := currentElement.succ;   restart(loop)}" true 
 -- 
 -- OG:markSuper: "if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentElement := currentElement.succ;   restart(loop)}" 
 -- Invocation:markForCodeGen: "if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentElement := currentElement.succ;   restart(loop)}" 
 -- OG:markForCodeGen: "(currentElement =/= none)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(currentElement =/= none)" 
 -- "(currentElement =/= none)" true 
 -- 
 -- OG:markSuper: "(currentElement =/= none)" 
 -- Invocation:markForCodeGen: "(currentElement =/= none)" 
 -- Invocation:markForCodeGen: "currentElement =/= none" 
 -- BinaryExp:markForCodeGen: "currentElement =/= none" 
 -- Invocation:markForCodeGen: "currentElement" 
 -- ObjectInvocation:markForCodeGen: "currentElement"  ATd: "currentElement: ref Element" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "=/= none"  ATd: "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean}" 
 -- OI:args:markForCodgen: "none" 
 -- not ObjDesc:  "(currentElement =/= none)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "current := currentElement.elm{   inner(scan);   currentElement := currentElement.succ;   restart(loop)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "current := currentElement.elm{   inner(scan);   currentElement := currentElement.succ;   restart(loop)}" 
 -- OG:Qalloc: "current := currentElement.elm{   inner(scan);   currentElement := currentElement.succ;   restart(loop)}" qDescno:  157 
 -- ObjTmpStack:add: "current := currentElement.elm{   inner(scan);   currentElement := currentElement.succ;   restart(loop)}" 
 -- items:markForCodeGen: "current := currentElement.elm{inner(scan);currentElement := currentElement.succ;restart(loop)}" 
 -- markItem: "current := currentElement.elm" Assign 
 -- Invocation:markForCodeGen: "current" 
 -- ObjectInvocation:markForCodeGen: "current"  ATd: "current: ref Object" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "currentElement.elm" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "currentElement.elm" 
 -- "currentElement" false 
 -- "elm" true 
 -- 
 -- markItem: "inner(scan)" ObjectGenerator 
 -- markItem: "currentElement := currentElement.succ" Assign 
 -- Invocation:markForCodeGen: "currentElement" 
 -- ObjectInvocation:markForCodeGen: "currentElement"  ATd: "currentElement: ref Element" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "currentElement.succ" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "currentElement.succ" 
 -- "currentElement" false 
 -- "succ" false 
 -- 
 -- markItem: "restart(loop)" ObjectGenerator 
 -- not ObjDesc:  "if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentElement := currentElement.succ;   restart(loop)}"  IS.isEmpty: ... true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "loop"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "scan{   if (elm == current) :then ;      --"Queue:has:elm\n".printB := true;      leave(has)}" 
 -- OG:Qalloc: "scan{   if (elm == current) :then ;      --"Queue:has:elm\n".printB := true;      leave(has)}" qDescno:  158 
 -- ObjTmpStack:add: "scan{   if (elm == current) :then ;      --"Queue:has:elm\n".printB := true;      leave(has)}" 
 -- items:markForCodeGen: "if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)}" 
 -- markItem: "if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)}" ObjectGenerator 
 -- OG:markForCodeGen: "if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)}" 
 -- "if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)}" true 
 -- 
 -- OG:markSuper: "if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)}" 
 -- Invocation:markForCodeGen: "if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)}" 
 -- OG:markForCodeGen: "(elm == current)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(elm == current)" 
 -- "(elm == current)" true 
 -- 
 -- OG:markSuper: "(elm == current)" 
 -- Invocation:markForCodeGen: "(elm == current)" 
 -- Invocation:markForCodeGen: "elm == current" 
 -- BinaryExp:markForCodeGen: "elm == current" 
 -- Invocation:markForCodeGen: "elm" 
 -- ObjectInvocation:markForCodeGen: "elm"  ATd: "in elm: ref Object" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "== current"  ATd: "==  : {   %basic 56;   in objx: ref Object;   out V: var boolean}" 
 -- Pattern:markForCodeGen: "==  : {   %basic 56;   in objx: ref Object;   out V: var boolean}" 
 -- items:markForCodeGen: "" 
 -- OI:args:markForCodgen: "current" 
 -- OG:markForCodeGen: "current" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "current" 
 -- "current" true 
 -- 
 -- not ObjDesc:  "(elm == current)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "--"Queue:has:elm\n".printB := true{   leave(has)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "--"Queue:has:elm\n".printB := true{   leave(has)}" 
 -- OG:Qalloc: "--"Queue:has:elm\n".printB := true{   leave(has)}" qDescno:  159 
 -- ObjTmpStack:add: "--"Queue:has:elm\n".printB := true{   leave(has)}" 
 -- items:markForCodeGen: "--"Queue:has:elm\n".printB := true{leave(has)}" 
 -- markItem: "B := true" Assign 
 -- Invocation:markForCodeGen: "B" 
 -- ObjectInvocation:markForCodeGen: "B"  ATd: "out B: var Boolean" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "true" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "true" 
 -- "true" false 
 -- 
 -- OG:markSuper: "true" 
 -- Invocation:markForCodeGen: "true" 
 -- ObjectInvocation:markForCodeGen: "true"  ATd: "True: {   %globals;   out B: var boolean;   B := 1}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "true"  IS.isEmpty:  true 
 -- markItem: "leave(has)" ObjectGenerator 
 -- not ObjDesc:  "if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)}"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "has(P)" 
 -- OG:markForCodeGen: "P" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "P" 
 -- "P" false 
 -- 
 -- arg:   "P" 
 -- ObjectInvocation:markForCodeGen: "not"  ATd: "not: {   %basic 65;   out R: var boolean}" 
 -- Pattern:markForCodeGen: "not: {   %basic 65;   out R: var boolean}" 
 -- items:markForCodeGen: "" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "(Q.has(P).not)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "Q.insert(P)" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "Q.insert(P)" 
 -- OG:Qalloc: "Q.insert(P)" qDescno:  141 
 -- ObjTmpStack:add: "Q.insert(P)" 
 -- items:markForCodeGen: "Q.insert(P)" 
 -- markItem: "Q.insert(P)" ObjectGenerator 
 -- OG:markForCodeGen: "Q.insert(P)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Q.insert(P)" 
 -- "Q" false 
 -- "insert(P)" false 
 -- 
 -- OG:markSuper: "Q.insert(P)" 
 -- Invocation:markForCodeGen: "Q.insert(P)" 
 -- ObjectInvocation:markForCodeGen: "Q"  ATd: "Q: obj ProcessQueue" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "insert(P)"  ATd: "insert: {   in elm: ref Object;   E: ref Element;   b: var BOOLEAN;   B := ELM =/= NONE;   --if (has(elm)) :then;   --  ...}" 
 -- Pattern:markForCodeGen: "insert: {   in elm: ref Object;   E: ref Element;   b: var BOOLEAN;   B := ELM =/= NONE;   --if (has(elm)) :then;   --    "insert:leave\n".print;  ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "in elm: ref Object{   E: ref Element;   b: var BOOLEAN;   B := ELM =/= NONE;   --if (has(elm)) :then;   --    "insert:leave\n".print;   --    leave(ins ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "in elm: ref Object{   E: ref Element;   b: var BOOLEAN;   B := ELM =/= NONE;   --if (has(elm)) :then;   --    "insert:leave\n".print;   --    leave(insert);    ...}" 
 -- OG:Qalloc: "in elm: ref Object{   E: ref Element;   b: var BOOLEAN;   B := ELM =/= NONE;   --if (has(elm)) :then;   --    "insert:leave\n".print;   --    leave(insert);    ...}" q ... 142 
 -- ObjTmpStack:add: "insert" : "in elm: ref Object{   E: ref Element;   b: var BOOLEAN;   B := ELM =/= NONE;   --if (has(elm)) :then;   --    "insert:leave\n".print;   --     ...}" 
 -- items:markForCodeGen: "in elm: ref Object{E: ref Element;b: var BOOLEAN;B := ELM =/= NONE;--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert);if (B) :th ...}" 
 -- DataItem:markForCodeGen: "elm" :descNo: 0 :OG.primNo: 64 
 -- OG:markForCodeGen: "Object" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Object" 
 -- "Object" true 
 -- 
 -- not ObjDesc:  "Object"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "E" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Element" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Element" 
 -- "Element" false 
 -- 
 -- not ObjDesc:  "Element"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "b" :descNo: 0 :OG.primNo: 4 
 -- OG:markForCodeGen: "BOOLEAN" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "BOOLEAN" 
 -- "BOOLEAN" true 
 -- 
 -- OG:markSuper: "BOOLEAN" 
 -- Invocation:markForCodeGen: "BOOLEAN" 
 -- ObjectInvocation:markForCodeGen: "BOOLEAN"  ATd: "Boolean: value{   %id "Boolean";   %globals inSub;   %basic 4, 8;   %public;   _thisBasicValue: var Universal;   &&  : ;  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "BOOLEAN"  IS.isEmpty:  true 
 -- markItem: "B := ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" Assign 
 -- Invocation:markForCodeGen: "B" 
 -- ObjectInvocation:markForCodeGen: "B"  ATd: "b: var BOOLEAN" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" true 
 -- 
 -- OG:markSuper: "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- Invocation:markForCodeGen: "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- BinaryExp:markForCodeGen: "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- Invocation:markForCodeGen: "ELM" 
 -- ObjectInvocation:markForCodeGen: "ELM"  ATd: "in elm: ref Object" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "=/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}"  ATd: "=/=  : {   %basic 57;   in objx: ref Object;   o ...}" 
 -- OI:args:markForCodgen: "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- not ObjDesc:  "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}"  IS.isEmpty:  true 
 -- markItem: "if (B) :then {   E := Element(elm);   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head;   :else ;      E.succ := head;      ...}" O ... 
 -- OG:markForCodeGen: "if (B) :then {   E := Element(elm);   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head;   :else ;      E.succ := h ...}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (B) :then {   E := Element(elm);   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head;   :else ;      E.succ := head;      head.pred ...}" 
 -- "if (B) :then {   E := Element(elm);   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head;   :else ;      E.succ := head;      head.pred ...}" true 
 -- 
 -- OG:markSuper: "if (B) :then {   E := Element(elm);   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head;   :else ;      E.succ := head;  ...}" 
 -- Invocation:markForCodeGen: "if (B) :then {   E := Element(elm);   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head;   :else ;      E.s ...}" 
 -- OG:markForCodeGen: "(B)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(B)" 
 -- "(B)" true 
 -- 
 -- OG:markForCodeGen: "E := Element(elm){   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head;   :else ;      E.succ := head;      head.pr ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "E := Element(elm){   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head;   :else ;      E.succ := head;      head.pred := E; ...}" 
 -- OG:Qalloc: "E := Element(elm){   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head;   :else ;      E.succ := head;      head.pred := E; ...}" q ... 143 
 -- ObjTmpStack:add: "E := Element(elm){   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head;   :else ;      E.succ := head;      head.pred ...}" 
 -- items:markForCodeGen: "E := Element(elm){noOfElm := noOfElm + 1;if (head == none) :then ;   head := E;   last := head;:else ;   E.succ := head;   head.pred := E;   head := ...}" 
 -- markItem: "E := Element(elm)" Assign 
 -- Invocation:markForCodeGen: "E" 
 -- ObjectInvocation:markForCodeGen: "E"  ATd: "E: ref Element" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "Element(elm)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Element(elm)" 
 -- "Element(elm)" false 
 -- 
 -- OG:markSuper: "Element(elm)" 
 -- Invocation:markForCodeGen: "Element(elm)" 
 -- ObjectInvocation:markForCodeGen: "Element(elm)"  ATd: "Element: {   in elm: ref Object;   out res: ref Element;   id: var integer;   pred: ref Element;   succ: ref Element ...}" 
 -- OI:args:markForCodgen: "Element(elm)" 
 -- OG:markForCodeGen: "elm" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "elm" 
 -- "elm" true 
 -- 
 -- arg:   "elm" 
 -- not ObjDesc:  "Element(elm)"  IS.isEmpty:  true 
 -- markItem: "noOfElm := noOfElm + 1" Assign 
 -- Invocation:markForCodeGen: "noOfElm" 
 -- ObjectInvocation:markForCodeGen: "noOfElm"  ATd: "noOfElm: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "noOfElm + 1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "noOfElm + 1" 
 -- "noOfElm + 1" true 
 -- 
 -- OG:markSuper: "noOfElm + 1" 
 -- Invocation:markForCodeGen: "noOfElm + 1" 
 -- BinaryExp:markForCodeGen: "noOfElm + 1" 
 -- Invocation:markForCodeGen: "noOfElm" 
 -- ObjectInvocation:markForCodeGen: "noOfElm"  ATd: "noOfElm: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "+ 1"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OI:args:markForCodgen: "1" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- not ObjDesc:  "noOfElm + 1"  IS.isEmpty:  true 
 -- markItem: "if (head == none) :then {   head := E;   last := head;:else ;   E.succ := head;   head.pred := E;   head := E;   --"insert:".print;   --idf.print;   --putint(no ...}" O ... 
 -- OG:markForCodeGen: "if (head == none) :then {   head := E;   last := head;:else ;   E.succ := head;   head.pred := E;   head := E;   --"insert:".print;   --idf.print;   -- ...}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (head == none) :then {   head := E;   last := head;:else ;   E.succ := head;   head.pred := E;   head := E;   --"insert:".print;   --idf.print;   --putint(noOfElm);    ...}" 
 -- "if (head == none) :then {   head := E;   last := head;:else ;   E.succ := head;   head.pred := E;   head := E;   --"insert:".print;   --idf.print;   --putint(noOfElm);    ...}" true 
 -- 
 -- OG:markSuper: "if (head == none) :then {   head := E;   last := head;:else ;   E.succ := head;   head.pred := E;   head := E;   --"insert:".print;   --idf.print;   --putin ...}" 
 -- Invocation:markForCodeGen: "if (head == none) :then {   head := E;   last := head;:else ;   E.succ := head;   head.pred := E;   head := E;   --"insert:".print;   --idf.pri ...}" 
 -- OG:markForCodeGen: "(head == none)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(head == none)" 
 -- "(head == none)" true 
 -- 
 -- OG:markSuper: "(head == none)" 
 -- Invocation:markForCodeGen: "(head == none)" 
 -- Invocation:markForCodeGen: "head == none" 
 -- BinaryExp:markForCodeGen: "head == none" 
 -- Invocation:markForCodeGen: "head" 
 -- ObjectInvocation:markForCodeGen: "head"  ATd: "head: ref Element" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "== none"  ATd: "==  : {   %basic 56;   in objx: ref Object;   out V: var boolean}" 
 -- OI:args:markForCodgen: "none" 
 -- not ObjDesc:  "(head == none)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "head := E{   last := head}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "head := E{   last := head}" 
 -- OG:Qalloc: "head := E{   last := head}" qDescno:  145 
 -- ObjTmpStack:add: "head := E{   last := head}" 
 -- items:markForCodeGen: "head := E{last := head}" 
 -- markItem: "head := E" Assign 
 -- Invocation:markForCodeGen: "head" 
 -- ObjectInvocation:markForCodeGen: "head"  ATd: "head: ref Element" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "E" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "E" 
 -- "E" false 
 -- 
 -- markItem: "last := head" Assign 
 -- Invocation:markForCodeGen: "last" 
 -- ObjectInvocation:markForCodeGen: "last"  ATd: "last: ref Element" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "head" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "head" 
 -- "head" false 
 -- 
 -- OG:markForCodeGen: "E.succ := head{   head.pred := E;   head := E;   --"insert:".print;   --idf.print;   --putint(noOfElm);   --newline	 }" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "E.succ := head{   head.pred := E;   head := E;   --"insert:".print;   --idf.print;   --putint(noOfElm);   --newline	 }" 
 -- OG:Qalloc: "E.succ := head{   head.pred := E;   head := E;   --"insert:".print;   --idf.print;   --putint(noOfElm);   --newline	 }" qDescno:  146 
 -- ObjTmpStack:add: "E.succ := head{   head.pred := E;   head := E;   --"insert:".print;   --idf.print;   --putint(noOfElm);   --newline	 }" 
 -- items:markForCodeGen: "E.succ := head{head.pred := E;head := E;--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- markItem: "E.succ := head" Assign 
 -- Invocation:markForCodeGen: "E.succ" 
 -- ObjectInvocation:markForCodeGen: "E"  ATd: "E: ref Element" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "succ"  ATd: "succ: ref Element" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "head" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "head" 
 -- "head" false 
 -- 
 -- markItem: "head.pred := E" Assign 
 -- Invocation:markForCodeGen: "head.pred" 
 -- ObjectInvocation:markForCodeGen: "head"  ATd: "head: ref Element" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "pred"  ATd: "pred: ref Element" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "E" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "E" 
 -- "E" false 
 -- 
 -- markItem: "head := E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }" Assign 
 -- Invocation:markForCodeGen: "head" 
 -- ObjectInvocation:markForCodeGen: "head"  ATd: "head: ref Element" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }" false 
 -- 
 -- not ObjDesc:  "if (head == none) :then {   head := E;   last := head;:else ;   E.succ := head;   head.pred := E;   head := E;   --"insert:".print;   --idf.print;   --putin ...}"   ... true 
 -- not ObjDesc:  "if (B) :then {   E := Element(elm);   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head;   :else ;      E.succ := head;  ...}"   ... true 
 -- OI:args:markForCodgen: "insert(P)" 
 -- OG:markForCodeGen: "P" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "P" 
 -- "P" false 
 -- 
 -- arg:   "P" 
 -- not ObjDesc:  "Q.insert(P)"  IS.isEmpty:  true 
 -- not ObjDesc:  "if (Q.has(P).not) :then {   Q.insert(P)}"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "insert(this(BasicProcess))" 
 -- OG:markForCodeGen: "this(BasicProcess)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "this(BasicProcess)" 
 -- "this(BasicProcess)" true 
 -- 
 -- OG:markSuper: "this(BasicProcess)" 
 -- Invocation:markForCodeGen: "this(BasicProcess)" 
 -- ObjectInvocation:markForCodeGen: "this(BasicProcess)"  ATd: "this: {   %basic 18;   in this: ref Object}" 
 -- OI:args:markForCodgen: "this(BasicProcess)" 
 -- OG:markForCodeGen: "BasicProcess" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "BasicProcess" 
 -- "BasicProcess" false 
 -- 
 -- OG:markSuper: "BasicProcess" 
 -- Invocation:markForCodeGen: "BasicProcess" 
 -- ObjectInvocation:markForCodeGen: "BasicProcess"  ATd: "BasicProcess: GeneralProcess{   mkActive::< ;      -- start and mkActive are identical and one may be eliminatedstat ...}" 
 -- Pattern:markForCodeGen: "BasicProcess: GeneralProcess{   mkActive::< ;      -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;      SQ ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "BasicProcess"  IS.isEmpty:  true 
 -- arg:   "BasicProcess" 
 -- not ObjDesc:  "this(BasicProcess)"  IS.isEmpty:  true 
 -- arg:   "this(BasicProcess)" 
 -- not ObjDesc:  "SQS.insert(this(BasicProcess))"  IS.isEmpty:  true 
 -- markItem: "%Public" Property 
 -- Pattern:markForCodeGen: "start::<  -- need id as argument{   status := p_status.ACTIVE;   SQS.insert(this(BasicProcess));   inner(start)}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "-- need id as argument{   status := p_status.ACTIVE;   SQS.insert(this(BasicProcess));   inner(start)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "-- need id as argument" 
 -- "" false 
 -- 
 -- OG:markIS: "-- need id as argument{   status := p_status.ACTIVE;   SQS.insert(this(BasicProcess));   inner(start)}" 
 -- OG:Qalloc: "-- need id as argument{   status := p_status.ACTIVE;   SQS.insert(this(BasicProcess));   inner(start)}" qDescno:  0 
 -- OG:Qalloc:A:  "start"  super:  "-- need id as argument"  marked:  true "start::<  -- need id as argument{   status := p_status.ACTIVE;   SQS.insert(this(BasicProcess));    ...}" s ... - ... 
 -- Invocation:Qalloc: "-- need id as argument" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  132 1 inner(start) 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "-- need id as argument{   status := p_status.ACTIVE;   SQS.insert(this(BasicProcess));   inner(start)}" 
 -- super:  "-- need id as argument" 
 -- E:  "" 
 -- OG:Qalloc:B: "start" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 160 IS.newDescNo: 160 objSize: 0 1: 1 "status := p_status.ACTIVE{SQS.insert(this(BasicProcess));inner(start)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 160 "status := p_status.ACTIVE{SQS.insert(this(BasicProcess));inner(start)}" 
 -- Items:Qalloc:super: "-- need id as argument" size: 1 "start" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Invocation:Qalloc: "status" 
 -- ObjectInvocation:Qalloc: "status" 
 -- name: "status" 
 -- Arguments "" 
 -- OG:Qalloc: "p_status.ACTIVE" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "p_status.ACTIVE"  marked:  false "status := p_status.ACTIVE" super:  p_status.ACTIVE 
 -- Invocation:Qalloc: "p_status.ACTIVE" 
 -- ObjectInvocation:Qalloc: "p_status" 
 -- name: "p_status" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "ACTIVE" 
 -- name: "ACTIVE" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "ACTIVE: val 1" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "p_status.ACTIVE" 
 -- super:  "p_status.ACTIVE" 
 -- E:  "ACTIVE" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "p_status.ACTIVE" 
 -- OG:Qalloc: "SQS.insert(this(BasicProcess))" qDescno:  0 
 -- OG:Qalloc:A:  "insert"  super:  "SQS.insert(this(BasicProcess))"  marked:  false "status := p_status.ACTIVE{SQS.insert(this(BasicProcess));inner(start)}" super:  SQS.inser ... 
 -- Invocation:Qalloc: "SQS.insert(this(BasicProcess))" 
 -- ObjectInvocation:Qalloc: "SQS" 
 -- name: "SQS" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "insert(this(BasicProcess))" 
 -- name: "insert" 
 -- Arguments "insert(this(BasicProcess))" 
 -- OG:Qalloc: "this(BasicProcess)" qDescno:  0 
 -- OG:Qalloc:A:  "this"  super:  "this(BasicProcess)"  marked:  false "insert(this(BasicProcess))" super:  this(BasicProcess) 
 -- Invocation:Qalloc: "this(BasicProcess)" 
 -- ObjectInvocation:Qalloc: "this(BasicProcess)" 
 -- name: "this" 
 -- Arguments "this(BasicProcess)" 
 -- OG:Qalloc: "BasicProcess" qDescno:  0 
 -- OG:Qalloc:A:  "BasicProcess"  super:  "BasicProcess"  marked:  false "this(BasicProcess)" super:  BasicProcess 
 -- Invocation:Qalloc: "BasicProcess" 
 -- ObjectInvocation:Qalloc: "BasicProcess" 
 -- name: "BasicProcess" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  83 4 mkActive::< {   -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;   SQS.inse ...} 
 -- OG:super:  "BasicProcess: GeneralProcess{   mkActive::< ;      -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;      SQS.insert(this ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "BasicProcess" 
 -- super:  "BasicProcess" 
 -- E:  "BasicProcess" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "BasicProcess" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  31 2 %basic 18{in this: ref Object} 
 -- OG:super:  "this: {   %basic 18;   in this: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "this(BasicProcess)" 
 -- super:  "this(BasicProcess)" 
 -- E:  "this(BasicProcess)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "this(BasicProcess)" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  139 2 in P: ref BasicProcess{if (Q.has(P).not) :then ;   Q.insert(P)} 
 -- OG:super:  "insert: entry{   in P: ref BasicProcess;   if (Q.has(P).not) :then ;      Q.insert(P)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "SQS.insert(this(BasicProcess))" 
 -- super:  "SQS.insert(this(BasicProcess))" 
 -- E:  "insert(this(BasicProcess))" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "SQS.insert(this(BasicProcess))" 
 -- OG:Qalloc: "inner(start)" qDescno:  0 
 -- OG:Qalloc:A:  "inner"  super:  "inner(start)"  marked:  false "status := p_status.ACTIVE{SQS.insert(this(BasicProcess));inner(start)}" super:  inner(start) 
 -- Invocation:Qalloc: "inner(start)" 
 -- ObjectInvocation:Qalloc: "inner(start)" 
 -- name: "inner" 
 -- Arguments "inner(start)" 
 -- OG:Qalloc: "start" qDescno:  0 
 -- OG:Qalloc:A:  "start"  super:  "start"  marked:  false "inner(start)" super:  start 
 -- Invocation:Qalloc: "start" 
 -- ObjectInvocation:Qalloc: "start" 
 -- name: "start" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  160 1 status := p_status.ACTIVE{SQS.insert(this(BasicProcess));inner(start)} 
 -- OG:super:  "start::<  -- need id as argument{   status := p_status.ACTIVE;   SQS.insert(this(BasicProcess));   inner(start)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "start" 
 -- super:  "start" 
 -- E:  "start" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "start" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 %basic 101{in inner: ref Object} 
 -- OG:super:  "inner: {   %basic 101;   in inner: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(start)" 
 -- super:  "inner(start)" 
 -- E:  "inner(start)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(start)" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 160 "status := p_status.ACTIVE{SQS.insert(this(BasicProcess));inner(start)}" 
 -- IS.newDescNo: 160 IS.objSize: 1 "status := p_status.ACTIVE{SQS.insert(this(BasicProcess));inner(start)}" 
 -- OG:Qalloc:end: IS.newDescNo:  160 "-- need id as argument{   status := p_status.ACTIVE;   SQS.insert(this(BasicProcess));   inner(start)}" 
 -- ObjTmpStack:add: "start" : "-- need id as argument{   status := p_status.ACTIVE;   SQS.insert(this(BasicProcess));   inner(start)}" 
 -- items:markForCodeGen: "status := p_status.ACTIVE{SQS.insert(this(BasicProcess));inner(start)}" 
 -- markItem: "status := p_status.ACTIVE" Assign 
 -- Invocation:markForCodeGen: "status" 
 -- ObjectInvocation:markForCodeGen: "status"  ATd: "status: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "p_status.ACTIVE" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "p_status.ACTIVE" 
 -- "p_status" false 
 -- "ACTIVE" true 
 -- 
 -- markItem: "SQS.insert(this(BasicProcess))" ObjectGenerator 
 -- OG:markForCodeGen: "SQS.insert(this(BasicProcess))" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "SQS.insert(this(BasicProcess))" 
 -- "SQS" false 
 -- "insert(this(BasicProcess))" false 
 -- 
 -- OG:markSuper: "SQS.insert(this(BasicProcess))" 
 -- Invocation:markForCodeGen: "SQS.insert(this(BasicProcess))" 
 -- ObjectInvocation:markForCodeGen: "SQS"  ATd: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;       ...}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "insert(this(BasicProcess))"  ATd: "insert: entry{   in P: ref BasicProcess;   if (Q.has(P).not) :then ;      Q.insert(P)}" 
 -- OI:args:markForCodgen: "insert(this(BasicProcess))" 
 -- OG:markForCodeGen: "this(BasicProcess)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "this(BasicProcess)" 
 -- "this(BasicProcess)" true 
 -- 
 -- OG:markSuper: "this(BasicProcess)" 
 -- Invocation:markForCodeGen: "this(BasicProcess)" 
 -- ObjectInvocation:markForCodeGen: "this(BasicProcess)"  ATd: "this: {   %basic 18;   in this: ref Object}" 
 -- OI:args:markForCodgen: "this(BasicProcess)" 
 -- OG:markForCodeGen: "BasicProcess" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "BasicProcess" 
 -- "BasicProcess" false 
 -- 
 -- OG:markSuper: "BasicProcess" 
 -- Invocation:markForCodeGen: "BasicProcess" 
 -- ObjectInvocation:markForCodeGen: "BasicProcess"  ATd: "BasicProcess: GeneralProcess{   mkActive::< ;      -- start and mkActive are identical and one may be eliminatedstat ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "BasicProcess"  IS.isEmpty:  true 
 -- arg:   "BasicProcess" 
 -- not ObjDesc:  "this(BasicProcess)"  IS.isEmpty:  true 
 -- arg:   "this(BasicProcess)" 
 -- not ObjDesc:  "SQS.insert(this(BasicProcess))"  IS.isEmpty:  true 
 -- markItem: "inner(start)" ObjectGenerator 
 -- Pattern:markForCodeGen: "addWaiting::< {   --SQS.addWaitingstatus := P_status.WAITING}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "--SQS.addWaitingstatus := P_status.WAITING" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "--SQS.addWaitingstatus := P_status.WAITING" 
 -- OG:Qalloc: "--SQS.addWaitingstatus := P_status.WAITING" qDescno:  0 
 -- OG:Qalloc:A:  "addWaiting"  super:  ""  marked:  true "addWaiting::< {   --SQS.addWaitingstatus := P_status.WAITING}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  134 1 --put('q')inner(addWaiting){--put('R')} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "--SQS.addWaitingstatus := P_status.WAITING" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "addWaiting" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 161 IS.newDescNo: 161 objSize: 0 1: 1 "--SQS.addWaitingstatus := P_status.WAITING" 
 -- Items:Qalloc:objSize: 0  newDescNo: 161 "--SQS.addWaitingstatus := P_status.WAITING" 
 -- Items:Qalloc:super: "" size: 1 "addWaiting" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Invocation:Qalloc: "status" 
 -- ObjectInvocation:Qalloc: "status" 
 -- name: "status" 
 -- Arguments "" 
 -- OG:Qalloc: "P_status.WAITING" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "P_status.WAITING"  marked:  false "status := P_status.WAITING" super:  P_status.WAITING 
 -- Invocation:Qalloc: "P_status.WAITING" 
 -- ObjectInvocation:Qalloc: "P_status" 
 -- name: "P_status" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "WAITING" 
 -- name: "WAITING" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "WAITING: val 2" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "P_status.WAITING" 
 -- super:  "P_status.WAITING" 
 -- E:  "WAITING" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "P_status.WAITING" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 161 "--SQS.addWaitingstatus := P_status.WAITING" 
 -- IS.newDescNo: 161 IS.objSize: 1 "--SQS.addWaitingstatus := P_status.WAITING" 
 -- OG:Qalloc:end: IS.newDescNo:  161 "--SQS.addWaitingstatus := P_status.WAITING" 
 -- ObjTmpStack:add: "addWaiting" : "--SQS.addWaitingstatus := P_status.WAITING" 
 -- items:markForCodeGen: "--SQS.addWaitingstatus := P_status.WAITING" 
 -- markItem: "status := P_status.WAITING" Assign 
 -- Invocation:markForCodeGen: "status" 
 -- ObjectInvocation:markForCodeGen: "status"  ATd: "status: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "P_status.WAITING" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "P_status.WAITING" 
 -- "P_status" false 
 -- "WAITING" true 
 -- 
 -- Pattern:markForCodeGen: "dcrWaiting::< {   SQS.dcrWaiting}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "SQS.dcrWaiting" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "SQS.dcrWaiting" 
 -- OG:Qalloc: "SQS.dcrWaiting" qDescno:  0 
 -- OG:Qalloc:A:  "dcrWaiting"  super:  ""  marked:  true "dcrWaiting::< {   SQS.dcrWaiting}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  135 1 inner(dcrWaiting) 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "SQS.dcrWaiting" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "dcrWaiting" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 162 IS.newDescNo: 162 objSize: 0 1: 1 "SQS.dcrWaiting" 
 -- Items:Qalloc:objSize: 0  newDescNo: 162 "SQS.dcrWaiting" 
 -- Items:Qalloc:super: "" size: 1 "dcrWaiting" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- OG:Qalloc: "SQS.dcrWaiting" qDescno:  0 
 -- OG:Qalloc:A:  "dcrWaiting"  super:  "SQS.dcrWaiting"  marked:  false "SQS.dcrWaiting" super:  SQS.dcrWaiting 
 -- Invocation:Qalloc: "SQS.dcrWaiting" 
 -- ObjectInvocation:Qalloc: "SQS" 
 -- name: "SQS" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "dcrWaiting" 
 -- name: "dcrWaiting" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 W := W - 1 
 -- OG:Qalloc:SuperAlloc: "dcrWaiting: entry{   W := W - 1}" 
 -- OG:Qalloc: "entry{   W := W - 1}" qDescno:  0 
 -- OG:Qalloc:A:  "dcrWaiting"  super:  "entry"  marked:  false "dcrWaiting: entry{   W := W - 1}" super:  entry 
 -- Invocation:Qalloc: "entry" 
 -- ObjectInvocation:Qalloc: "entry" 
 -- name: "entry" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  95 1 L.get{V := V + 1;if (V > 1) :then ;   put('V');inner(entry);V := V - 1;L.free} 
 -- OG:super:  "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "entry{   W := W - 1}" 
 -- super:  "entry" 
 -- E:  "entry" 
 -- OG:Qalloc:B: "dcrWaiting" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 163 IS.newDescNo: 163 objSize: 0 1: 1 "W := W - 1" 
 -- Items:Qalloc:objSize: 0  newDescNo: 163 "W := W - 1" 
 -- Items:Qalloc:super: "entry" size: 1 "dcrWaiting" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Invocation:Qalloc: "W" 
 -- ObjectInvocation:Qalloc: "W" 
 -- name: "W" 
 -- Arguments "" 
 -- OG:Qalloc: "W - 1" qDescno:  0 
 -- OG:Qalloc:A:  "-"  super:  "W - 1"  marked:  false "W := W - 1" super:  W - 1 
 -- Invocation:Qalloc: "W - 1" 
 -- BinaryExp:Qalloc: "W - 1" 
 -- Invocation:Qalloc: "W" 
 -- ObjectInvocation:Qalloc: "W" 
 -- name: "W" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "- 1" 
 -- name: "-" 
 -- Arguments "1" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "1" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  108 5 %basic 62{in V: var integer;out R: var integer} 
 -- OG:super:  "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "W - 1" 
 -- super:  "W - 1" 
 -- E:  "W - 1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "W - 1" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 163 "W := W - 1" 
 -- IS.newDescNo: 163 IS.objSize: 1 "W := W - 1" 
 -- OG:Qalloc:end: IS.newDescNo:  163 "entry{   W := W - 1}" 
 -- OG:super:  "dcrWaiting: entry{   W := W - 1}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "SQS.dcrWaiting" 
 -- super:  "SQS.dcrWaiting" 
 -- E:  "dcrWaiting" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "SQS.dcrWaiting" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 162 "SQS.dcrWaiting" 
 -- IS.newDescNo: 162 IS.objSize: 1 "SQS.dcrWaiting" 
 -- OG:Qalloc:end: IS.newDescNo:  162 "SQS.dcrWaiting" 
 -- ObjTmpStack:add: "dcrWaiting" : "SQS.dcrWaiting" 
 -- items:markForCodeGen: "SQS.dcrWaiting" 
 -- markItem: "SQS.dcrWaiting" ObjectGenerator 
 -- OG:markForCodeGen: "SQS.dcrWaiting" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "SQS.dcrWaiting" 
 -- "SQS" false 
 -- "dcrWaiting" false 
 -- 
 -- OG:markSuper: "SQS.dcrWaiting" 
 -- Invocation:markForCodeGen: "SQS.dcrWaiting" 
 -- ObjectInvocation:markForCodeGen: "SQS"  ATd: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;       ...}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "dcrWaiting"  ATd: "dcrWaiting: entry{   W := W - 1}" 
 -- Pattern:markForCodeGen: "dcrWaiting: entry{   W := W - 1}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "entry{   W := W - 1}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "entry" 
 -- "entry" false 
 -- 
 -- OG:markSuper: "entry" 
 -- Invocation:markForCodeGen: "entry" 
 -- ObjectInvocation:markForCodeGen: "entry"  ATd: "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free}" 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "entry{   W := W - 1}" 
 -- OG:Qalloc: "entry{   W := W - 1}" qDescno:  163 
 -- ObjTmpStack:add: "dcrWaiting" : "entry{   W := W - 1}" 
 -- items:markForCodeGen: "W := W - 1" 
 -- markItem: "W := W - 1" Assign 
 -- Invocation:markForCodeGen: "W" 
 -- ObjectInvocation:markForCodeGen: "W"  ATd: "W: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "W - 1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "W - 1" 
 -- "W - 1" true 
 -- 
 -- OG:markSuper: "W - 1" 
 -- Invocation:markForCodeGen: "W - 1" 
 -- BinaryExp:markForCodeGen: "W - 1" 
 -- Invocation:markForCodeGen: "W" 
 -- ObjectInvocation:markForCodeGen: "W"  ATd: "W: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "- 1"  ATd: "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- OI:args:markForCodgen: "1" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- not ObjDesc:  "W - 1"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "SQS.dcrWaiting"  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "display::< {   "\n---BP:---\n".print;   --(id + ":A:").print	 }" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: ""\n---BP:---\n".print{   --(id + ":A:").print	 }" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: ""\n---BP:---\n".print{   --(id + ":A:").print	 }" 
 -- OG:Qalloc: ""\n---BP:---\n".print{   --(id + ":A:").print	 }" qDescno:  0 
 -- OG:Qalloc:A:  "display"  super:  ""  marked:  true "display::< {   "\n---BP:---\n".print;   --(id + ":A:").print	 }" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  136 1 "\n---GP:---".print{inner(display)} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""\n---BP:---\n".print{   --(id + ":A:").print	 }" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "display" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 164 IS.newDescNo: 164 objSize: 0 1: 1 ""\n---BP:---\n".print{--(id + ":A:").print	 }" 
 -- Items:Qalloc:objSize: 0  newDescNo: 164 ""\n---BP:---\n".print{--(id + ":A:").print	 }" 
 -- Items:Qalloc:super: "" size: 1 "display" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- OG:Qalloc: ""\n---BP:---\n".print{--(id + ":A:").print	 }" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  ""\n---BP:---\n".print{--(id + ":A:").print	 }"  marked:  false ""\n---BP:---\n".print{--(id + ":A:").print	 }" super:  "\n---BP:---\n".prin ... 
 -- Invocation:Qalloc: ""\n---BP:---\n".print{--(id + ":A:").print	 }" 
 -- ObjectInvocation:Qalloc: "print{--(id + ":A:").print	 }" 
 -- name: "print" 
 -- Arguments "--(id + ":A:").print	 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  103 1 gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);} 
 -- OG:super:  "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""\n---BP:---\n".print{--(id + ":A:").print	 }" 
 -- super:  ""\n---BP:---\n".print{--(id + ":A:").print	 }" 
 -- E:  "print{--(id + ":A:").print	 }" 
 -- OG:Qalloc:end: IS.newDescNo:  0 ""\n---BP:---\n".print{--(id + ":A:").print	 }" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 164 ""\n---BP:---\n".print{--(id + ":A:").print	 }" 
 -- IS.newDescNo: 164 IS.objSize: 1 ""\n---BP:---\n".print{--(id + ":A:").print	 }" 
 -- OG:Qalloc:end: IS.newDescNo:  164 ""\n---BP:---\n".print{   --(id + ":A:").print	 }" 
 -- ObjTmpStack:add: "display" : ""\n---BP:---\n".print{   --(id + ":A:").print	 }" 
 -- items:markForCodeGen: ""\n---BP:---\n".print{--(id + ":A:").print	 }" 
 -- markItem: ""\n---BP:---\n".print{--(id + ":A:").print	 }" ObjectGenerator 
 -- OG:markForCodeGen: ""\n---BP:---\n".print{--(id + ":A:").print	 }" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- ""\n---BP:---\n".print{--(id + ":A:").print	 }" 
 -- ""\n---BP:---\n"" true 
 -- "print{--(id + ":A:").print	 }" false 
 -- 
 -- OG:markSuper: ""\n---BP:---\n".print{--(id + ":A:").print	 }" 
 -- Invocation:markForCodeGen: ""\n---BP:---\n".print{--(id + ":A:").print	 }" 
 -- ObjectInvocation:markForCodeGen: "print{--(id + ":A:").print	 }"  ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:args:markForCodgen: "--(id + ":A:").print	 " 
 -- not ObjDesc:  ""\n---BP:---\n".print{--(id + ":A:").print	 }"  IS.isEmpty:  true 
 -- markItem: "this(BasicProcess).suspend{--(id + ":B:").print	 	 }" ObjectGenerator 
 -- markItem: "inner(BasicProcess)" ObjectGenerator 
 -- markItem: "status := P_status.TERMINATED" Assign 
 -- Invocation:markForCodeGen: "status" 
 -- ObjectInvocation:markForCodeGen: "status"  ATd: "status: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "P_status.TERMINATED" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "P_status.TERMINATED" 
 -- "P_status" false 
 -- "TERMINATED" true 
 -- 
 -- OI:args:markForCodgen: "BasicProcess("Keyboard")" 
 -- OG:markForCodeGen: ""Keyboard"" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- ""Keyboard"" 
 -- ""Keyboard"" true 
 -- 
 -- OG:markSuper: ""Keyboard"" 
 -- Invocation:markForCodeGen: ""Keyboard"" 
 -- not ObjDesc:  ""Keyboard""  IS.isEmpty:  true 
 -- arg:   ""Keyboard"" 
 -- OG:markIS: "BasicProcess("Keyboard"){   B: obj Indexed(100,integer);   next: var integer;   top: var integer;   echo: var Boolean;   %Public;   Kscan: ;      loopB: obj ;  ...}" 
 -- OG:Qalloc: "BasicProcess("Keyboard"){   B: obj Indexed(100,integer);   next: var integer;   top: var integer;   echo: var Boolean;   %Public;   Kscan: ;      loopB: obj ;  ...}" q ... 85 
 -- ObjTmpStack:add: "keyboard" : "BasicProcess("Keyboard"){   B: obj Indexed(100,integer);   next: var integer;   top: var integer;   echo: var Boolean;   %Public;   Kscan: ; ...}" 
 -- items:markForCodeGen: "B: obj Indexed(100,integer){next: var integer;top: var integer;echo: var Boolean;%Public;Kscan: ;   loopB: obj ;      if (_kbhit) :then ;         to ...}" 
 -- DataItem:markForCodeGen: "B" :descNo: 0 :OG.primNo: 114 
 -- OG:markForCodeGen: "Indexed(100,integer)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Indexed(100,integer)" 
 -- "Indexed(100,integer)" true 
 -- 
 -- OG:markSuper: "Indexed(100,integer)" 
 -- Invocation:markForCodeGen: "Indexed(100,integer)" 
 -- ObjectInvocation:markForCodeGen: "Indexed(100,integer)"  ATd: "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      ...}" 
 -- OI:args:markForCodgen: "(100,integer)" 
 -- OG:markForCodeGen: "100" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "100" 
 -- "100" true 
 -- 
 -- OG:markSuper: "100" 
 -- Invocation:markForCodeGen: "100" 
 -- not ObjDesc:  "100"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- arg:   "100" 
 -- arg:   "integer" 
 -- not ObjDesc:  "Indexed(100,integer)"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "next" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "top" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "echo" :descNo: 0 :OG.primNo: 4 
 -- OG:markForCodeGen: "Boolean" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Boolean" 
 -- "Boolean" true 
 -- 
 -- OG:markSuper: "Boolean" 
 -- Invocation:markForCodeGen: "Boolean" 
 -- ObjectInvocation:markForCodeGen: "Boolean"  ATd: "Boolean: value{   %id "Boolean";   %globals inSub;   %basic 4, 8;   %public;   _thisBasicValue: var Universal;   &&  : ;  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Boolean"  IS.isEmpty:  true 
 -- markItem: "%Public" Property 
 -- markItem: "Kscan" ObjectGenerator 
 -- OG:markForCodeGen: "Kscan" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Kscan" 
 -- "Kscan" false 
 -- 
 -- OG:markSuper: "Kscan" 
 -- Invocation:markForCodeGen: "Kscan" 
 -- ObjectInvocation:markForCodeGen: "Kscan"  ATd: "Kscan: {   loopB: obj ;      if (_kbhit) :then ;         top := top + 1;         B.put(_iget):at[top];      keyboard.suspen ...}" 
 -- Pattern:markForCodeGen: "Kscan: {   loopB: obj ;      if (_kbhit) :then ;         top := top + 1;         B.put(_iget):at[top];      keyboard.suspend;      restart(loopB)}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "loopB: obj {      if (_kbhit) :then ;         top := top + 1;         B.put(_iget):at[top];      keyboard.suspend;      restart(loopB)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "loopB: obj {      if (_kbhit) :then ;         top := top + 1;         B.put(_iget):at[top];      keyboard.suspend;      restart(loopB)}" 
 -- OG:Qalloc: "loopB: obj {      if (_kbhit) :then ;         top := top + 1;         B.put(_iget):at[top];      keyboard.suspend;      restart(loopB)}" qDescno:  88 
 -- ObjTmpStack:add: "Kscan" : "loopB: obj {      if (_kbhit) :then ;         top := top + 1;         B.put(_iget):at[top];      keyboard.suspend;      restart(loopB)}" 
 -- items:markForCodeGen: "loopB: obj {   if (_kbhit) :then ;      top := top + 1;      B.put(_iget):at[top];   keyboard.suspend;   restart(loopB)}" 
 -- DataItem:markForCodeGen: "loopB" :descNo: 89 :OG.primNo: 0 
 -- OG:markForCodeGen: "if (_kbhit) :then {      top := top + 1;      B.put(_iget):at[top];   keyboard.suspend;   restart(loopB)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "if (_kbhit) :then {      top := top + 1;      B.put(_iget):at[top];   keyboard.suspend;   restart(loopB)}" 
 -- OG:Qalloc: "if (_kbhit) :then {      top := top + 1;      B.put(_iget):at[top];   keyboard.suspend;   restart(loopB)}" qDescno:  89 
 -- ObjTmpStack:add: "loopB" : "if (_kbhit) :then {      top := top + 1;      B.put(_iget):at[top];   keyboard.suspend;   restart(loopB)}" 
 -- items:markForCodeGen: "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top];keyboard.suspend;restart(loopB)}" 
 -- markItem: "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top]}" ObjectGenerator 
 -- OG:markForCodeGen: "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top]}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top]}" 
 -- "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top]}" true 
 -- 
 -- OG:markSuper: "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top]}" 
 -- Invocation:markForCodeGen: "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top]}" 
 -- OG:markForCodeGen: "(_kbhit)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "(_kbhit)" 
 -- "(_kbhit)" false 
 -- 
 -- OG:markSuper: "(_kbhit)" 
 -- Invocation:markForCodeGen: "(_kbhit)" 
 -- Invocation:markForCodeGen: "_kbhit" 
 -- ObjectInvocation:markForCodeGen: "_kbhit"  ATd: "_kbhit: {   %external 5;   out B: var boolean}" 
 -- Pattern:markForCodeGen: "_kbhit: {   %external 5;   out B: var boolean}" 
 -- items:markForCodeGen: "" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "(_kbhit)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "top := top + 1{   B.put(_iget):at[top]}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "top := top + 1{   B.put(_iget):at[top]}" 
 -- OG:Qalloc: "top := top + 1{   B.put(_iget):at[top]}" qDescno:  91 
 -- ObjTmpStack:add: "top := top + 1{   B.put(_iget):at[top]}" 
 -- items:markForCodeGen: "top := top + 1{B.put(_iget):at[top]}" 
 -- markItem: "top := top + 1" Assign 
 -- Invocation:markForCodeGen: "top" 
 -- ObjectInvocation:markForCodeGen: "top"  ATd: "top: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "top + 1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "top + 1" 
 -- "top + 1" true 
 -- 
 -- OG:markSuper: "top + 1" 
 -- Invocation:markForCodeGen: "top + 1" 
 -- BinaryExp:markForCodeGen: "top + 1" 
 -- Invocation:markForCodeGen: "top" 
 -- ObjectInvocation:markForCodeGen: "top"  ATd: "top: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "+ 1"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OI:args:markForCodgen: "1" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- not ObjDesc:  "top + 1"  IS.isEmpty:  true 
 -- markItem: "B.put(_iget):at[top]" ObjectGenerator 
 -- not ObjDesc:  "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top]}"  IS.isEmpty:  true 
 -- markItem: "keyboard.suspend" ObjectGenerator 
 -- markItem: "restart(loopB)" ObjectGenerator 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Kscan"  IS.isEmpty:  true 
 -- markItem: "init" ObjectGenerator 
 -- OG:markForCodeGen: "init" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "init" 
 -- "init" false 
 -- 
 -- OG:markSuper: "init" 
 -- Invocation:markForCodeGen: "init" 
 -- ObjectInvocation:markForCodeGen: "init"  ATd: "init: {   SQS.init}" 
 -- Pattern:markForCodeGen: "init: {   SQS.init}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "SQS.init" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "SQS.init" 
 -- OG:Qalloc: "SQS.init" qDescno:  94 
 -- ObjTmpStack:add: "init" : "SQS.init" 
 -- items:markForCodeGen: "SQS.init" 
 -- markItem: "SQS.init" ObjectGenerator 
 -- OG:markForCodeGen: "SQS.init" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "SQS.init" 
 -- "SQS" false 
 -- "init" false 
 -- 
 -- OG:markSuper: "SQS.init" 
 -- Invocation:markForCodeGen: "SQS.init" 
 -- ObjectInvocation:markForCodeGen: "SQS"  ATd: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;       ...}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "init"  ATd: "init: entry{   V := 1;   L.init;   L.id := "SQS";   Q.idf := "SQS:"}" 
 -- Pattern:markForCodeGen: "init: entry{   V := 1;   L.init;   L.id := "SQS";   Q.idf := "SQS:"}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "entry{   V := 1;   L.init;   L.id := "SQS";   Q.idf := "SQS:"}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "entry" 
 -- "entry" false 
 -- 
 -- OG:markSuper: "entry" 
 -- Invocation:markForCodeGen: "entry" 
 -- ObjectInvocation:markForCodeGen: "entry"  ATd: "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free}" 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "entry{   V := 1;   L.init;   L.id := "SQS";   Q.idf := "SQS:"}" 
 -- OG:Qalloc: "entry{   V := 1;   L.init;   L.id := "SQS";   Q.idf := "SQS:"}" qDescno:  110 
 -- ObjTmpStack:add: "init" : "entry{   V := 1;   L.init;   L.id := "SQS";   Q.idf := "SQS:"}" 
 -- items:markForCodeGen: "V := 1{L.init;L.id := "SQS";Q.idf := "SQS:"}" 
 -- markItem: "V := 1" Assign 
 -- Invocation:markForCodeGen: "V" 
 -- ObjectInvocation:markForCodeGen: "V"  ATd: "V: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- markItem: "L.init" ObjectGenerator 
 -- OG:markForCodeGen: "L.init" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "L.init" 
 -- "L" false 
 -- "init" false 
 -- 
 -- OG:markSuper: "L.init" 
 -- Invocation:markForCodeGen: "L.init" 
 -- ObjectInvocation:markForCodeGen: "L"  ATd: "L: obj Lock("SQS:Lock:")" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "init"  ATd: "init: {   free_M := 0}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "L.init"  IS.isEmpty:  true 
 -- markItem: "L.id := "SQS"" Assign 
 -- Invocation:markForCodeGen: "L.id" 
 -- ObjectInvocation:markForCodeGen: "L"  ATd: "L: obj Lock("SQS:Lock:")" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "id"  ATd: "in id: var String" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: ""SQS"" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- ""SQS"" 
 -- ""SQS"" true 
 -- 
 -- OG:markSuper: ""SQS"" 
 -- Invocation:markForCodeGen: ""SQS"" 
 -- not ObjDesc:  ""SQS""  IS.isEmpty:  true 
 -- markItem: "Q.idf := "SQS:"" Assign 
 -- Invocation:markForCodeGen: "Q.idf" 
 -- ObjectInvocation:markForCodeGen: "Q"  ATd: "Q: obj ProcessQueue" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "idf"  ATd: "idf: var LIB.StringLib.String" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: ""SQS:"" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- ""SQS:"" 
 -- ""SQS:"" true 
 -- 
 -- OG:markSuper: ""SQS:"" 
 -- Invocation:markForCodeGen: ""SQS:"" 
 -- not ObjDesc:  ""SQS:""  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "SQS.init"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "init"  IS.isEmpty:  true 
 -- markItem: "inner(BasicSystem)" ObjectGenerator 
 -- markItem: "cores.init" ObjectGenerator 
 -- OG:markForCodeGen: "cores.init" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "cores.init" 
 -- "cores" false 
 -- "init" false 
 -- 
 -- OG:markSuper: "cores.init" 
 -- Invocation:markForCodeGen: "cores.init" 
 -- ObjectInvocation:markForCodeGen: "cores"  ATd: "cores: obj {   C1: ref Core;   C2: ref Core;   C3: ref Core;   C4: ref Core;   -- should be array         ;   init: ;       ...}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "init"  ATd: "init: {   S: ref Scheduler;   C1 := Core;   fork(C1);   C2 := Core;   fork(C2);   C3 := Core;   fork(C3);   C4 := Core;   fo ...}" 
 -- Pattern:markForCodeGen: "init: {   S: ref Scheduler;   C1 := Core;   fork(C1);   C2 := Core;   fork(C2);   C3 := Core;   fork(C3);   C4 := Core;   fork(C4);   S := Schedul ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "S: ref Scheduler{   C1 := Core;   fork(C1);   C2 := Core;   fork(C2);   C3 := Core;   fork(C3);   C4 := Core;   fork(C4);   S := Scheduler;   C1.attach ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "S: ref Scheduler{   C1 := Core;   fork(C1);   C2 := Core;   fork(C2);   C3 := Core;   fork(C3);   C4 := Core;   fork(C4);   S := Scheduler;   C1.attach(S);   S ...}" 
 -- OG:Qalloc: "S: ref Scheduler{   C1 := Core;   fork(C1);   C2 := Core;   fork(C2);   C3 := Core;   fork(C3);   C4 := Core;   fork(C4);   S := Scheduler;   C1.attach(S);   S ...}" q ... 111 
 -- ObjTmpStack:add: "init" : "S: ref Scheduler{   C1 := Core;   fork(C1);   C2 := Core;   fork(C2);   C3 := Core;   fork(C3);   C4 := Core;   fork(C4);   S := Scheduler;   C1 ...}" 
 -- items:markForCodeGen: "S: ref Scheduler{C1 := Core;fork(C1);C2 := Core;fork(C2);C3 := Core;fork(C3);C4 := Core;fork(C4);S := Scheduler;C1.attach(S);S := Scheduler;C2.attac ...}" 
 -- DataItem:markForCodeGen: "S" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Scheduler" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Scheduler" 
 -- "Scheduler" false 
 -- 
 -- OG:markForCodeGen: "SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB: var Boolean;   inScheduler: var Boolean;  ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "SuperScheduler" 
 -- "SuperScheduler" false 
 -- 
 -- OG:markSuper: "SuperScheduler" 
 -- Invocation:markForCodeGen: "SuperScheduler" 
 -- ObjectInvocation:markForCodeGen: "SuperScheduler"  ATd: "SuperScheduler: {   thisScheduler:< Object;   ProcessType:< GeneralProcess;   active: ref ProcessType;   inner(Sup ...}" 
 -- Pattern:markForCodeGen: "SuperScheduler: {   thisScheduler:< Object;   ProcessType:< GeneralProcess;   active: ref ProcessType;   inner(SuperScheduler)}" 
 -- items:markForCodeGen: "" 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB: var Boolean;   inScheduler: var Boolean;   P: ref ...}" 
 -- OG:Qalloc: "SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB: var Boolean;   inScheduler: var Boolean;   P: ref ...}" q ... 125 
 -- ObjTmpStack:add: "Scheduler" : "SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB: var Boolean;   inScheduler: v ...}" 
 -- items:markForCodeGen: "thisScheduler::< Scheduler{ProcessType::< BasicProcess;%Public;%Private;dummyB: var Boolean;inScheduler: var Boolean;P: ref BasicProcess;(this(Sched ...}" 
 -- Pattern:markForCodeGen: "thisScheduler::< Scheduler" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "Scheduler" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Scheduler" 
 -- "Scheduler" false 
 -- 
 -- OG:markSuper: "Scheduler" 
 -- Invocation:markForCodeGen: "Scheduler" 
 -- ObjectInvocation:markForCodeGen: "Scheduler"  ATd: "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB ...}" 
 -- Pattern:markForCodeGen: "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB: var Boolean;   inSchedule ...}" 
 -- items:markForCodeGen: "" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Scheduler"  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "ProcessType::< BasicProcess" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "BasicProcess" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "BasicProcess" 
 -- "BasicProcess" false 
 -- 
 -- OG:markSuper: "BasicProcess" 
 -- Invocation:markForCodeGen: "BasicProcess" 
 -- ObjectInvocation:markForCodeGen: "BasicProcess"  ATd: "BasicProcess: GeneralProcess{   mkActive::< ;      -- start and mkActive are identical and one may be eliminatedstat ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "BasicProcess"  IS.isEmpty:  true 
 -- markItem: "%Public" Property 
 -- markItem: "%Private" Property 
 -- DataItem:markForCodeGen: "dummyB" :descNo: 0 :OG.primNo: 4 
 -- OG:markForCodeGen: "Boolean" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Boolean" 
 -- "Boolean" true 
 -- 
 -- OG:markSuper: "Boolean" 
 -- Invocation:markForCodeGen: "Boolean" 
 -- ObjectInvocation:markForCodeGen: "Boolean"  ATd: "Boolean: value{   %id "Boolean";   %globals inSub;   %basic 4, 8;   %public;   _thisBasicValue: var Universal;   &&  : ;  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Boolean"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "inScheduler" :descNo: 0 :OG.primNo: 4 
 -- OG:markForCodeGen: "Boolean" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Boolean" 
 -- "Boolean" true 
 -- 
 -- OG:markSuper: "Boolean" 
 -- Invocation:markForCodeGen: "Boolean" 
 -- ObjectInvocation:markForCodeGen: "Boolean"  ATd: "Boolean: value{   %id "Boolean";   %globals inSub;   %basic 4, 8;   %public;   _thisBasicValue: var Universal;   &&  : ;  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Boolean"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "P" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "BasicProcess" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "BasicProcess" 
 -- "BasicProcess" false 
 -- 
 -- not ObjDesc:  "BasicProcess"  IS.isEmpty:  true 
 -- markItem: "(this(Scheduler)).suspend" ObjectGenerator 
 -- markItem: "sch.add" ObjectGenerator 
 -- OG:markForCodeGen: "sch.add" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "sch.add" 
 -- "sch" false 
 -- "add" false 
 -- 
 -- OG:markSuper: "sch.add" 
 -- Invocation:markForCodeGen: "sch.add" 
 -- ObjectInvocation:markForCodeGen: "sch"  ATd: "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   a ...}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "add"  ATd: "add: {   entry;      M := M + 1}" 
 -- Pattern:markForCodeGen: "add: {   entry;      M := M + 1}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "entry{      M := M + 1}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "entry{      M := M + 1}" 
 -- OG:Qalloc: "entry{      M := M + 1}" qDescno:  128 
 -- ObjTmpStack:add: "add" : "entry{      M := M + 1}" 
 -- items:markForCodeGen: "entry{   M := M + 1}" 
 -- markItem: "entry{   M := M + 1}" ObjectGenerator 
 -- OG:markForCodeGen: "entry{   M := M + 1}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "entry" 
 -- "entry" false 
 -- 
 -- OG:markSuper: "entry" 
 -- Invocation:markForCodeGen: "entry" 
 -- ObjectInvocation:markForCodeGen: "entry"  ATd: "entry: {   L.get;   inner(entry);   L.free}" 
 -- Pattern:markForCodeGen: "entry: {   L.get;   inner(entry);   L.free}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "L.get{   inner(entry);   L.free}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "L.get{   inner(entry);   L.free}" 
 -- OG:Qalloc: "L.get{   inner(entry);   L.free}" qDescno:  129 
 -- ObjTmpStack:add: "entry" : "L.get{   inner(entry);   L.free}" 
 -- items:markForCodeGen: "L.get{inner(entry);L.free}" 
 -- markItem: "L.get" ObjectGenerator 
 -- OG:markForCodeGen: "L.get" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "L.get" 
 -- "L" false 
 -- "get" false 
 -- 
 -- OG:markSuper: "L.get" 
 -- Invocation:markForCodeGen: "L.get" 
 -- ObjectInvocation:markForCodeGen: "L"  ATd: "L: obj Lock("Sch:lock")" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "get"  ATd: "get: {   loop: obj ;      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);      if (r ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "L.get"  IS.isEmpty:  true 
 -- markItem: "inner(entry)" ObjectGenerator 
 -- markItem: "L.free" ObjectGenerator 
 -- OG:markForCodeGen: "L.free" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "L.free" 
 -- "L" false 
 -- "free" false 
 -- 
 -- OG:markSuper: "L.free" 
 -- Invocation:markForCodeGen: "L.free" 
 -- ObjectInvocation:markForCodeGen: "L"  ATd: "L: obj Lock("Sch:lock")" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "free"  ATd: "free: {   free_M := 0}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "L.free"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "entry{   M := M + 1}" 
 -- OG:Qalloc: "entry{   M := M + 1}" qDescno:  130 
 -- ObjTmpStack:add: "entry{   M := M + 1}" 
 -- items:markForCodeGen: "M := M + 1" 
 -- markItem: "M := M + 1" Assign 
 -- Invocation:markForCodeGen: "M" 
 -- ObjectInvocation:markForCodeGen: "M"  ATd: "M: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "M + 1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "M + 1" 
 -- "M + 1" true 
 -- 
 -- OG:markSuper: "M + 1" 
 -- Invocation:markForCodeGen: "M + 1" 
 -- BinaryExp:markForCodeGen: "M + 1" 
 -- Invocation:markForCodeGen: "M" 
 -- ObjectInvocation:markForCodeGen: "M"  ATd: "M: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "+ 1"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OI:args:markForCodgen: "1" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- not ObjDesc:  "M + 1"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "sch.add"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "inScheduler := 1{   active := SQS.removeNext;   if (active =/= none) :then ;      active.status := P_status.ACTIVE;      inScheduler := 0;      active. ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "inScheduler := 1{   active := SQS.removeNext;   if (active =/= none) :then ;      active.status := P_status.ACTIVE;      inScheduler := 0;      active.attach(5 ...}" 
 -- OG:Qalloc: "inScheduler := 1{   active := SQS.removeNext;   if (active =/= none) :then ;      active.status := P_status.ACTIVE;      inScheduler := 0;      active.attach(5 ...}" q ... 0 
 -- OG:Qalloc:A:  "loop"  super:  ""  marked:  true "loop: do {   inScheduler := 1;   active := SQS.removeNext;   if (active =/= none) :then ;      active.status := P_status.A ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inScheduler := 1{   active := SQS.removeNext;   if (active =/= none) :then ;      active.status := P_status.ACTIVE;      inScheduler := 0;      active.attach(50);      in ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "loop" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 165 IS.newDescNo: 165 objSize: 0 1: 1 "inScheduler := 1{active := SQS.removeNext;if (active =/= none) :then ;   active.status := P_status.ACTIVE ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 165 "inScheduler := 1{active := SQS.removeNext;if (active =/= none) :then ;   active.status := P_status.ACTIVE;   inScheduler := 0;   a ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "inScheduler" 
 -- ObjectInvocation:Qalloc: "inScheduler" 
 -- name: "inScheduler" 
 -- Arguments "" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "inScheduler := 1" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- Invocation:Qalloc: "active" 
 -- ObjectInvocation:Qalloc: "active" 
 -- name: "active" 
 -- Arguments "" 
 -- OG:Qalloc: "SQS.removeNext" qDescno:  0 
 -- OG:Qalloc:A:  "removeNext"  super:  "SQS.removeNext"  marked:  false "active := SQS.removeNext" super:  SQS.removeNext 
 -- Invocation:Qalloc: "SQS.removeNext" 
 -- ObjectInvocation:Qalloc: "SQS" 
 -- name: "SQS" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "removeNext" 
 -- name: "removeNext" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 out P: ref BasicProcess{entry;   P := Q.removeNext} 
 -- OG:Qalloc:SuperAlloc: "removeNext: {   out P: ref BasicProcess;   entry;      P := Q.removeNext}" 
 -- OG:Qalloc: "out P: ref BasicProcess{   entry;      P := Q.removeNext}" qDescno:  0 
 -- OG:Qalloc:A:  "removeNext"  super:  ""  marked:  false "removeNext: {   out P: ref BasicProcess;   entry;      P := Q.removeNext}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "out P: ref BasicProcess{   entry;      P := Q.removeNext}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "removeNext" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 166 IS.newDescNo: 166 objSize: 0 1: 1 "out P: ref BasicProcess{entry;   P := Q.removeNext}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 166 "out P: ref BasicProcess{entry;   P := Q.removeNext}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "P" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "out P: ref BasicProcess" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- OG:Qalloc: "entry{   P := Q.removeNext}" qDescno:  0 
 -- OG:Qalloc:A:  "entry$0"  super:  "entry"  marked:  false "out P: ref BasicProcess{entry;   P := Q.removeNext}" super:  entry 
 -- Invocation:Qalloc: "entry" 
 -- ObjectInvocation:Qalloc: "entry" 
 -- name: "entry" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  95 1 L.get{V := V + 1;if (V > 1) :then ;   put('V');inner(entry);V := V - 1;L.free} 
 -- OG:super:  "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "entry{   P := Q.removeNext}" 
 -- super:  "entry" 
 -- E:  "entry" 
 -- OG:Qalloc:B: "entry$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 167 IS.newDescNo: 167 objSize: 0 1: 1 "P := Q.removeNext" 
 -- Items:Qalloc:objSize: 0  newDescNo: 167 "P := Q.removeNext" 
 -- Items:Qalloc:super: "entry" size: 1 "entry$167" 
 -- super.isThisBlockLevel: false superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 2 originOff: 2 
 -- Invocation:Qalloc: "P" 
 -- ObjectInvocation:Qalloc: "P" 
 -- name: "P" 
 -- Arguments "" 
 -- OG:Qalloc: "Q.removeNext" qDescno:  0 
 -- OG:Qalloc:A:  "removeNext"  super:  "Q.removeNext"  marked:  false "P := Q.removeNext" super:  Q.removeNext 
 -- Invocation:Qalloc: "Q.removeNext" 
 -- ObjectInvocation:Qalloc: "Q" 
 -- name: "Q" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "removeNext" 
 -- name: "removeNext" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 -- return last element in queue and remove it for queue      out elm: ref Object{if (last =/= none) :then ;   noOfE ...} 
 -- OG:Qalloc:SuperAlloc: "removeNext: {   -- return last element in queue and remove it for queue      out elm: ref Object;   if (last =/= none) :then ;      noOfElm := noOfE ...}" 
 -- OG:Qalloc: "-- return last element in queue and remove it for queue      out elm: ref Object{   if (last =/= none) :then ;      noOfElm := noOfElm - 1;      elm := last.el ...}" q ... 0 
 -- OG:Qalloc:A:  "removeNext"  super:  ""  marked:  false "removeNext: {   -- return last element in queue and remove it for queue      out elm: ref Object;   if (last =/= no ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "-- return last element in queue and remove it for queue      out elm: ref Object{   if (last =/= none) :then ;      noOfElm := noOfElm - 1;      elm := last.elm;      las ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "removeNext" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 168 IS.newDescNo: 168 objSize: 0 1: 1 "-- return last element in queue and remove it for queue      out elm: ref Object{if (last =/= none) :then ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 168 "-- return last element in queue and remove it for queue      out elm: ref Object{if (last =/= none) :then ;   noOfElm := noOfElm - ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "elm" isValue: false  isPrimitive: true  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "out elm: ref Object" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- OG:Qalloc: "if (last =/= none) :then {   noOfElm := noOfElm - 1;   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;      last.succ := none;   :else ;     ...}" q ... 0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (last =/= none) :then {   noOfElm := noOfElm - 1;   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;      last.suc ...}"   ... false "- ..." s ... i ... 
 -- Invocation:Qalloc: "if (last =/= none) :then {   noOfElm := noOfElm - 1;   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;      last.succ := none;   :el ...}" 
 -- OG:Qalloc: "(last =/= none)" qDescno:  0 
 -- OG:Qalloc:A:  "=/="  super:  "(last =/= none)"  marked:  false "if (last =/= none) :then {   noOfElm := noOfElm - 1;   elm := last.elm;   last := last.pred;   if (last =/= ...}" s ... ( ... 
 -- Invocation:Qalloc: "(last =/= none)" 
 -- Invocation:Qalloc: "last =/= none" 
 -- BinaryExp:Qalloc: "last =/= none" 
 -- Invocation:Qalloc: "last" 
 -- ObjectInvocation:Qalloc: "last" 
 -- name: "last" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "=/= none" 
 -- name: "=/=" 
 -- Arguments "none" 
 -- OG:Qalloc: "none" qDescno:  0 
 -- OG:Qalloc:A:  "none"  super:  "none"  marked:  false "none" super:  none 
 -- Invocation:Qalloc: "none" 
 -- ObjectInvocation:Qalloc: "none" 
 -- name: "none" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  116 2 %basic 19{none_x: var integer} 
 -- OG:super:  "none: {   %basic 19;   none_x: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "none" 
 -- super:  "none" 
 -- E:  "none" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "none" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  117 3 %basic 57{in objx: ref Object;out V: var boolean} 
 -- OG:super:  "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(last =/= none)" 
 -- super:  "(last =/= none)" 
 -- E:  "(last =/= none)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(last =/= none)" 
 -- OG:Qalloc: "noOfElm := noOfElm - 1{   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;      last.succ := none;   :else ;      head := none;      --"remov ..."}" q ... 0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (last =/= none) :then {   noOfElm := noOfElm - 1;   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;   ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "noOfElm := noOfElm - 1{   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;      last.succ := none;   :else ;      head := none;      --"removeNext:".pri ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 169 IS.newDescNo: 169 objSize: 0 1: 1 "noOfElm := noOfElm - 1{elm := last.elm;last := last.pred;if (last =/= none) :then ;   last.succ := none;: ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 169 "noOfElm := noOfElm - 1{elm := last.elm;last := last.pred;if (last =/= none) :then ;   last.succ := none;:else ;   head := none;    ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "noOfElm" 
 -- ObjectInvocation:Qalloc: "noOfElm" 
 -- name: "noOfElm" 
 -- Arguments "" 
 -- OG:Qalloc: "noOfElm - 1" qDescno:  0 
 -- OG:Qalloc:A:  "-"  super:  "noOfElm - 1"  marked:  false "noOfElm := noOfElm - 1" super:  noOfElm - 1 
 -- Invocation:Qalloc: "noOfElm - 1" 
 -- BinaryExp:Qalloc: "noOfElm - 1" 
 -- Invocation:Qalloc: "noOfElm" 
 -- ObjectInvocation:Qalloc: "noOfElm" 
 -- name: "noOfElm" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "- 1" 
 -- name: "-" 
 -- Arguments "1" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "1" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  108 5 %basic 62{in V: var integer;out R: var integer} 
 -- OG:super:  "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "noOfElm - 1" 
 -- super:  "noOfElm - 1" 
 -- E:  "noOfElm - 1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "noOfElm - 1" 
 -- Invocation:Qalloc: "elm" 
 -- ObjectInvocation:Qalloc: "elm" 
 -- name: "elm" 
 -- Arguments "" 
 -- OG:Qalloc: "last.elm" qDescno:  0 
 -- OG:Qalloc:A:  "Object"  super:  "last.elm"  marked:  false "elm := last.elm" super:  last.elm 
 -- Invocation:Qalloc: "last.elm" 
 -- ObjectInvocation:Qalloc: "last" 
 -- name: "last" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "elm" 
 -- name: "elm" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:super:  "in elm: ref Object" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "last.elm" 
 -- super:  "last.elm" 
 -- E:  "elm" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "last.elm" 
 -- Invocation:Qalloc: "last" 
 -- ObjectInvocation:Qalloc: "last" 
 -- name: "last" 
 -- Arguments "" 
 -- OG:Qalloc: "last.pred" qDescno:  0 
 -- OG:Qalloc:A:  "Element"  super:  "last.pred"  marked:  false "last := last.pred" super:  last.pred 
 -- Invocation:Qalloc: "last.pred" 
 -- ObjectInvocation:Qalloc: "last" 
 -- name: "last" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "pred" 
 -- name: "pred" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  137 6 in elm: ref Object{out res: ref Element;id: var integer;pred: ref Element;succ: ref Element;res := this(Element); ...} 
 -- OG:super:  "pred: ref Element" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "last.pred" 
 -- super:  "last.pred" 
 -- E:  "pred" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "last.pred" 
 -- OG:Qalloc: "if (last =/= none) :then {   last.succ := none;:else ;   head := none;   --"removeNext:".print;   --idf.print;   --putint(noOfElm);   --newline	 }" qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (last =/= none) :then {   last.succ := none;:else ;   head := none;   --"removeNext:".print;   --idf.print;   --putint(noOfElm);   - ...}"   ... false "n ..." s ... i ... 
 -- Invocation:Qalloc: "if (last =/= none) :then {   last.succ := none;:else ;   head := none;   --"removeNext:".print;   --idf.print;   --putint(noOfElm);   --newline	 }" 
 -- OG:Qalloc: "(last =/= none)" qDescno:  0 
 -- OG:Qalloc:A:  "=/="  super:  "(last =/= none)"  marked:  false "if (last =/= none) :then {   last.succ := none;:else ;   head := none;   --"removeNext:".print;   --idf.pri ...}" s ... ( ... 
 -- Invocation:Qalloc: "(last =/= none)" 
 -- Invocation:Qalloc: "last =/= none" 
 -- BinaryExp:Qalloc: "last =/= none" 
 -- Invocation:Qalloc: "last" 
 -- ObjectInvocation:Qalloc: "last" 
 -- name: "last" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "=/= none" 
 -- name: "=/=" 
 -- Arguments "none" 
 -- OG:Qalloc: "none" qDescno:  0 
 -- OG:Qalloc:A:  "none"  super:  "none"  marked:  false "none" super:  none 
 -- Invocation:Qalloc: "none" 
 -- ObjectInvocation:Qalloc: "none" 
 -- name: "none" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  116 2 %basic 19{none_x: var integer} 
 -- OG:super:  "none: {   %basic 19;   none_x: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "none" 
 -- super:  "none" 
 -- E:  "none" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "none" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  117 3 %basic 57{in objx: ref Object;out V: var boolean} 
 -- OG:super:  "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(last =/= none)" 
 -- super:  "(last =/= none)" 
 -- E:  "(last =/= none)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(last =/= none)" 
 -- OG:Qalloc: "last.succ := none" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (last =/= none) :then {   last.succ := none;:else ;   head := none;   --"removeNext:".print;   --idf.print;   --putint(n ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "last.succ := none" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 170 IS.newDescNo: 170 objSize: 0 1: 1 "last.succ := none" 
 -- Items:Qalloc:objSize: 0  newDescNo: 170 "last.succ := none" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "last.succ" 
 -- ObjectInvocation:Qalloc: "last" 
 -- name: "last" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "succ" 
 -- name: "succ" 
 -- Arguments "" 
 -- OG:Qalloc: "none" qDescno:  0 
 -- OG:Qalloc:A:  "none"  super:  "none"  marked:  false "last.succ := none" super:  none 
 -- Invocation:Qalloc: "none" 
 -- ObjectInvocation:Qalloc: "none" 
 -- name: "none" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  116 2 %basic 19{none_x: var integer} 
 -- OG:super:  "none: {   %basic 19;   none_x: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "none" 
 -- super:  "none" 
 -- E:  "none" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "none" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 170 "last.succ := none" 
 -- IS.newDescNo: 170 IS.objSize: 1 "last.succ := none" 
 -- OG:Qalloc:end: IS.newDescNo:  170 "last.succ := none" 
 -- OG:Qalloc: "head := none{   --"removeNext:".print;   --idf.print;   --putint(noOfElm);   --newline	 }" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (last =/= none) :then {   last.succ := none;:else ;   head := none;   --"removeNext:".print;   --idf.print;   --putint(n ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "head := none{   --"removeNext:".print;   --idf.print;   --putint(noOfElm);   --newline	 }" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 171 IS.newDescNo: 171 objSize: 0 1: 1 "head := none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- Items:Qalloc:objSize: 0  newDescNo: 171 "head := none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "head" 
 -- ObjectInvocation:Qalloc: "head" 
 -- name: "head" 
 -- Arguments "" 
 -- OG:Qalloc: "none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 }" qDescno:  0 
 -- OG:Qalloc:A:  "none"  super:  "none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 }"  marked:  false "head := none{--"removeNext:".print;--idf.print;--put ...}" s ... n ... 
 -- Invocation:Qalloc: "none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- ObjectInvocation:Qalloc: "none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- name: "none" 
 -- Arguments "--"removeNext:".print{--idf.print;--putint(noOfElm);--newline	 }" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  116 2 %basic 19{none_x: var integer} 
 -- OG:super:  "none: {   %basic 19;   none_x: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- super:  "none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- E:  "none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 171 "head := none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- IS.newDescNo: 171 IS.objSize: 1 "head := none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- OG:Qalloc:end: IS.newDescNo:  171 "head := none{   --"removeNext:".print;   --idf.print;   --putint(noOfElm);   --newline	 }" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (last =/= none) :then {   last.succ := none;:else ;   head := none;   --"removeNext:".print;   --idf.print;   --putint(noOfElm);   --newline	 }" 
 -- super:  "if (last =/= none) :then {   last.succ := none;:else ;   head := none;   --"removeNext:".print;   --idf.print;   --putint(noOfElm);   --newline	 }" 
 -- E:  "if (last =/= none) :then {   last.succ := none;:else ;   head := none;   --"removeNext:".print;   --idf.print;   --putint(noOfElm);   --newline	 }" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (last =/= none) :then {   last.succ := none;:else ;   head := none;   --"removeNext:".print;   --idf.print;   --putint(noOfElm);   --ne ...}" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 169 "noOfElm := noOfElm - 1{elm := last.elm;last := last.pred;if (last =/= none) :then ;   last.succ := none;:else ;   head := none ...}" 
 -- IS.newDescNo: 169 IS.objSize: 1 "noOfElm := noOfElm - 1{elm := last.elm;last := last.pred;if (last =/= none) :then ;   last.succ := none;:else ;   head := none;   --"remov ..."}" 
 -- OG:Qalloc:end: IS.newDescNo:  169 "noOfElm := noOfElm - 1{   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;      last.succ := none;   :else ;      head ...}" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (last =/= none) :then {   noOfElm := noOfElm - 1;   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;      last.succ := none;   :else ;      head := n ...}" 
 -- super:  "if (last =/= none) :then {   noOfElm := noOfElm - 1;   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;      last.succ := none;   :else ;      h ...}" 
 -- E:  "if (last =/= none) :then {   noOfElm := noOfElm - 1;   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;      last.succ := none;   :else ;      head  ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (last =/= none) :then {   noOfElm := noOfElm - 1;   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;      last.succ : ...}" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 168 "-- return last element in queue and remove it for queue      out elm: ref Object{if (last =/= none) :then ;   noOfElm := noOfE ...}" 
 -- IS.newDescNo: 168 IS.objSize: 2 "-- return last element in queue and remove it for queue      out elm: ref Object{if (last =/= none) :then ;   noOfElm := noOfElm - 1;   el ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  168 "-- return last element in queue and remove it for queue      out elm: ref Object{   if (last =/= none) :then ;      noOfElm := noOfElm - ...}" 
 -- OG:super:  "removeNext: {   -- return last element in queue and remove it for queue      out elm: ref Object;   if (last =/= none) :then ;      noOfElm := noOfElm - 1;     ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Q.removeNext" 
 -- super:  "Q.removeNext" 
 -- E:  "removeNext" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Q.removeNext" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 167 "P := Q.removeNext" 
 -- IS.newDescNo: 167 IS.objSize: 2 "P := Q.removeNext" 
 -- OG:Qalloc:end: IS.newDescNo:  167 "entry{   P := Q.removeNext}" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 166 "out P: ref BasicProcess{entry;   P := Q.removeNext}" 
 -- IS.newDescNo: 166 IS.objSize: 2 "out P: ref BasicProcess{entry;   P := Q.removeNext}" 
 -- OG:Qalloc:end: IS.newDescNo:  166 "out P: ref BasicProcess{   entry;      P := Q.removeNext}" 
 -- OG:super:  "removeNext: {   out P: ref BasicProcess;   entry;      P := Q.removeNext}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "SQS.removeNext" 
 -- super:  "SQS.removeNext" 
 -- E:  "removeNext" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "SQS.removeNext" 
 -- OG:Qalloc: "if (active =/= none) :then {   active.status := P_status.ACTIVE;   inScheduler := 0;   active.attach(50);   inScheduler := 1;   if (active.status = P_status.AC ...}" q ... 0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (active =/= none) :then {   active.status := P_status.ACTIVE;   inScheduler := 0;   active.attach(50);   inScheduler := 1;   if (act ...}"   ... false "i ..." s ... i ... 
 -- Invocation:Qalloc: "if (active =/= none) :then {   active.status := P_status.ACTIVE;   inScheduler := 0;   active.attach(50);   inScheduler := 1;   if (active.status = P_s ...}" 
 -- OG:Qalloc: "(active =/= none)" qDescno:  0 
 -- OG:Qalloc:A:  "=/="  super:  "(active =/= none)"  marked:  false "if (active =/= none) :then {   active.status := P_status.ACTIVE;   inScheduler := 0;   active.attach(50); ...}" s ... ( ... 
 -- Invocation:Qalloc: "(active =/= none)" 
 -- Invocation:Qalloc: "active =/= none" 
 -- BinaryExp:Qalloc: "active =/= none" 
 -- Invocation:Qalloc: "active" 
 -- ObjectInvocation:Qalloc: "active" 
 -- name: "active" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "=/= none" 
 -- name: "=/=" 
 -- Arguments "none" 
 -- OG:Qalloc: "none" qDescno:  0 
 -- OG:Qalloc:A:  "none"  super:  "none"  marked:  false "none" super:  none 
 -- Invocation:Qalloc: "none" 
 -- ObjectInvocation:Qalloc: "none" 
 -- name: "none" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  116 2 %basic 19{none_x: var integer} 
 -- OG:super:  "none: {   %basic 19;   none_x: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "none" 
 -- super:  "none" 
 -- E:  "none" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "none" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  117 3 %basic 57{in objx: ref Object;out V: var boolean} 
 -- OG:super:  "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(active =/= none)" 
 -- super:  "(active =/= none)" 
 -- E:  "(active =/= none)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(active =/= none)" 
 -- OG:Qalloc: "active.status := P_status.ACTIVE{   inScheduler := 0;   active.attach(50);   inScheduler := 1;   if (active.status = P_status.ACTIVE) :then ;      SQS.insert(a ...}" q ... 0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (active =/= none) :then {   active.status := P_status.ACTIVE;   inScheduler := 0;   active.attach(50);   inScheduler :=  ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "active.status := P_status.ACTIVE{   inScheduler := 0;   active.attach(50);   inScheduler := 1;   if (active.status = P_status.ACTIVE) :then ;      SQS.insert(active)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 172 IS.newDescNo: 172 objSize: 0 1: 1 "active.status := P_status.ACTIVE{inScheduler := 0;active.attach(50);inScheduler := 1;if (active.status =  ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 172 "active.status := P_status.ACTIVE{inScheduler := 0;active.attach(50);inScheduler := 1;if (active.status = P_status.ACTIVE) :then ;  ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "active.status" 
 -- ObjectInvocation:Qalloc: "active" 
 -- name: "active" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "status" 
 -- name: "status" 
 -- Arguments "" 
 -- OG:Qalloc: "P_status.ACTIVE" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "P_status.ACTIVE"  marked:  false "active.status := P_status.ACTIVE" super:  P_status.ACTIVE 
 -- Invocation:Qalloc: "P_status.ACTIVE" 
 -- ObjectInvocation:Qalloc: "P_status" 
 -- name: "P_status" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "ACTIVE" 
 -- name: "ACTIVE" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "ACTIVE: val 1" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "P_status.ACTIVE" 
 -- super:  "P_status.ACTIVE" 
 -- E:  "ACTIVE" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "P_status.ACTIVE" 
 -- Invocation:Qalloc: "inScheduler" 
 -- ObjectInvocation:Qalloc: "inScheduler" 
 -- name: "inScheduler" 
 -- Arguments "" 
 -- OG:Qalloc: "0" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "0"  marked:  false "inScheduler := 0" super:  0 
 -- Invocation:Qalloc: "0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "0" 
 -- super:  "0" 
 -- E:  "0" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "0" 
 -- OG:Qalloc: "active.attach(50)" qDescno:  0 
 -- OG:Qalloc:A:  "attach"  super:  "active.attach(50)"  marked:  false "active.status := P_status.ACTIVE{inScheduler := 0;active.attach(50);inScheduler := 1;if (active.status ...}" s ... a ... 
 -- Invocation:Qalloc: "active.attach(50)" 
 -- ObjectInvocation:Qalloc: "active" 
 -- name: "active" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "attach(50)" 
 -- name: "attach" 
 -- Arguments "attach(50)" 
 -- OG:Qalloc: "50" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "50"  marked:  false "attach(50)" super:  50 
 -- Invocation:Qalloc: "50" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "50" 
 -- super:  "50" 
 -- E:  "50" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "50" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 10{in V: var integer} 
 -- OG:Qalloc:SuperAlloc: "attach: {   %basic 10;   in V: var integer}" 
 -- OG:Qalloc: "%basic 10{   in V: var integer}" qDescno:  0 
 -- OG:Qalloc:A:  "attach"  super:  ""  marked:  false "attach: {   %basic 10;   in V: var integer}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 10{   in V: var integer}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "attach" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 173 IS.newDescNo: 173 objSize: 0 1: 1 "%basic 10{in V: var integer}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 173 "%basic 10{in V: var integer}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 173 "%basic 10{in V: var integer}" 
 -- IS.newDescNo: 173 IS.objSize: 2 "%basic 10{in V: var integer}" 
 -- OG:Qalloc:end: IS.newDescNo:  173 "%basic 10{   in V: var integer}" 
 -- OG:super:  "attach: {   %basic 10;   in V: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "active.attach(50)" 
 -- super:  "active.attach(50)" 
 -- E:  "attach(50)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "active.attach(50)" 
 -- Invocation:Qalloc: "inScheduler" 
 -- ObjectInvocation:Qalloc: "inScheduler" 
 -- name: "inScheduler" 
 -- Arguments "" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "inScheduler := 1" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- OG:Qalloc: "if (active.status = P_status.ACTIVE) :then {   SQS.insert(active)}" qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (active.status = P_status.ACTIVE) :then {   SQS.insert(active)}"  marked:  false "active.status := P_status.ACTIVE{inScheduler := 0; ...}" s ... i ... 
 -- Invocation:Qalloc: "if (active.status = P_status.ACTIVE) :then {   SQS.insert(active)}" 
 -- OG:Qalloc: "(active.status = P_status.ACTIVE)" qDescno:  0 
 -- OG:Qalloc:A:  "="  super:  "(active.status = P_status.ACTIVE)"  marked:  false "if (active.status = P_status.ACTIVE) :then {   SQS.insert(active)}" super:  (active.status  ... 
 -- Invocation:Qalloc: "(active.status = P_status.ACTIVE)" 
 -- Invocation:Qalloc: "active.status = P_status.ACTIVE" 
 -- BinaryExp:Qalloc: "active.status = P_status.ACTIVE" 
 -- Invocation:Qalloc: "active.status" 
 -- ObjectInvocation:Qalloc: "active" 
 -- name: "active" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "status" 
 -- name: "status" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "= P_status.ACTIVE" 
 -- name: "=" 
 -- Arguments "P_status.ACTIVE" 
 -- OG:Qalloc: "P_status.ACTIVE" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "P_status.ACTIVE"  marked:  false "P_status.ACTIVE" super:  P_status.ACTIVE 
 -- Invocation:Qalloc: "P_status.ACTIVE" 
 -- ObjectInvocation:Qalloc: "P_status" 
 -- name: "P_status" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "ACTIVE" 
 -- name: "ACTIVE" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "ACTIVE: val 1" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "P_status.ACTIVE" 
 -- super:  "P_status.ACTIVE" 
 -- E:  "ACTIVE" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "P_status.ACTIVE" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  11 5 %basic 50{in Veq: var this(Value);out Beq: var boolean;inner(= )} 
 -- OG:super:  "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(active.status = P_status.ACTIVE)" 
 -- super:  "(active.status = P_status.ACTIVE)" 
 -- E:  "(active.status = P_status.ACTIVE)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(active.status = P_status.ACTIVE)" 
 -- OG:Qalloc: "SQS.insert(active)" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (active.status = P_status.ACTIVE) :then {   SQS.insert(active)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "SQS.insert(active)" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 174 IS.newDescNo: 174 objSize: 0 1: 1 "SQS.insert(active)" 
 -- Items:Qalloc:objSize: 0  newDescNo: 174 "SQS.insert(active)" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: "SQS.insert(active)" qDescno:  0 
 -- OG:Qalloc:A:  "insert"  super:  "SQS.insert(active)"  marked:  false "SQS.insert(active)" super:  SQS.insert(active) 
 -- Invocation:Qalloc: "SQS.insert(active)" 
 -- ObjectInvocation:Qalloc: "SQS" 
 -- name: "SQS" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "insert(active)" 
 -- name: "insert" 
 -- Arguments "insert(active)" 
 -- OG:Qalloc: "active" qDescno:  0 
 -- OG:Qalloc:A:  "GeneralProcess"  super:  "active"  marked:  false "insert(active)" super:  active 
 -- Invocation:Qalloc: "active" 
 -- ObjectInvocation:Qalloc: "active" 
 -- name: "active" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  82 3 start:< {   inner(start);mkActive:< ;   inner(mkActive);addWaiting:< ;   --put('q')inner(addWaiting);   --put('R') ...} 
 -- OG:super:  "active: ref ProcessType" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "active" 
 -- super:  "active" 
 -- E:  "active" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "active" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  139 2 in P: ref BasicProcess{if (Q.has(P).not) :then ;   Q.insert(P)} 
 -- OG:super:  "insert: entry{   in P: ref BasicProcess;   if (Q.has(P).not) :then ;      Q.insert(P)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "SQS.insert(active)" 
 -- super:  "SQS.insert(active)" 
 -- E:  "insert(active)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "SQS.insert(active)" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 174 "SQS.insert(active)" 
 -- IS.newDescNo: 174 IS.objSize: 1 "SQS.insert(active)" 
 -- OG:Qalloc:end: IS.newDescNo:  174 "SQS.insert(active)" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (active.status = P_status.ACTIVE) :then {   SQS.insert(active)}" 
 -- super:  "if (active.status = P_status.ACTIVE) :then {   SQS.insert(active)}" 
 -- E:  "if (active.status = P_status.ACTIVE) :then {   SQS.insert(active)}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (active.status = P_status.ACTIVE) :then {   SQS.insert(active)}" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 172 "active.status := P_status.ACTIVE{inScheduler := 0;active.attach(50);inScheduler := 1;if (active.status = P_status.ACTIVE) :the ...}" 
 -- IS.newDescNo: 172 IS.objSize: 1 "active.status := P_status.ACTIVE{inScheduler := 0;active.attach(50);inScheduler := 1;if (active.status = P_status.ACTIVE) :then ;   SQS.in ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  172 "active.status := P_status.ACTIVE{   inScheduler := 0;   active.attach(50);   inScheduler := 1;   if (active.status = P_status.ACTIVE) :t ...}" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (active =/= none) :then {   active.status := P_status.ACTIVE;   inScheduler := 0;   active.attach(50);   inScheduler := 1;   if (active.status = P_status.ACTIVE) :then ...}" 
 -- super:  "if (active =/= none) :then {   active.status := P_status.ACTIVE;   inScheduler := 0;   active.attach(50);   inScheduler := 1;   if (active.status = P_status.ACTIV ...}" 
 -- E:  "if (active =/= none) :then {   active.status := P_status.ACTIVE;   inScheduler := 0;   active.attach(50);   inScheduler := 1;   if (active.status = P_status.ACTIVE) : ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (active =/= none) :then {   active.status := P_status.ACTIVE;   inScheduler := 0;   active.attach(50);   inScheduler := 1;   if (active ...}" 
 -- OG:Qalloc: "if (SQS.isEmpty) :then {   if (SQS.hasWaiting) :then ;      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) :then ;      sleep(50);      sch.add; ...}" q ... 0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (SQS.isEmpty) :then {   if (SQS.hasWaiting) :then ;      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) :then ;       ...}"   ... false "i ..." s ... i ... 
 -- Invocation:Qalloc: "if (SQS.isEmpty) :then {   if (SQS.hasWaiting) :then ;      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) :then ;      sleep(50);       ...}" 
 -- OG:Qalloc: "(SQS.isEmpty)" qDescno:  0 
 -- OG:Qalloc:A:  "isEmpty"  super:  "(SQS.isEmpty)"  marked:  false "if (SQS.isEmpty) :then {   if (SQS.hasWaiting) :then ;      sleep(100);      restart(Loop);   sch.dcr;    ...}" s ... ( ... 
 -- Invocation:Qalloc: "(SQS.isEmpty)" 
 -- Invocation:Qalloc: "SQS.isEmpty" 
 -- ObjectInvocation:Qalloc: "SQS" 
 -- name: "SQS" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "isEmpty" 
 -- name: "isEmpty" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 out B: var Boolean{entry;   B := Q.isEmpty} 
 -- OG:Qalloc:SuperAlloc: "isEmpty: {   out B: var Boolean;   entry;      B := Q.isEmpty}" 
 -- OG:Qalloc: "out B: var Boolean{   entry;      B := Q.isEmpty}" qDescno:  0 
 -- OG:Qalloc:A:  "isEmpty"  super:  ""  marked:  false "isEmpty: {   out B: var Boolean;   entry;      B := Q.isEmpty}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "out B: var Boolean{   entry;      B := Q.isEmpty}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "isEmpty" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 175 IS.newDescNo: 175 objSize: 0 1: 1 "out B: var Boolean{entry;   B := Q.isEmpty}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 175 "out B: var Boolean{entry;   B := Q.isEmpty}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "B" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- OG:Qalloc: "entry{   B := Q.isEmpty}" qDescno:  0 
 -- OG:Qalloc:A:  "entry$0"  super:  "entry"  marked:  false "out B: var Boolean{entry;   B := Q.isEmpty}" super:  entry 
 -- Invocation:Qalloc: "entry" 
 -- ObjectInvocation:Qalloc: "entry" 
 -- name: "entry" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  95 1 L.get{V := V + 1;if (V > 1) :then ;   put('V');inner(entry);V := V - 1;L.free} 
 -- OG:super:  "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "entry{   B := Q.isEmpty}" 
 -- super:  "entry" 
 -- E:  "entry" 
 -- OG:Qalloc:B: "entry$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 176 IS.newDescNo: 176 objSize: 0 1: 1 "B := Q.isEmpty" 
 -- Items:Qalloc:objSize: 0  newDescNo: 176 "B := Q.isEmpty" 
 -- Items:Qalloc:super: "entry" size: 1 "entry$176" 
 -- super.isThisBlockLevel: false superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 2 originOff: 2 
 -- Invocation:Qalloc: "B" 
 -- ObjectInvocation:Qalloc: "B" 
 -- name: "B" 
 -- Arguments "" 
 -- OG:Qalloc: "Q.isEmpty" qDescno:  0 
 -- OG:Qalloc:A:  "isEmpty"  super:  "Q.isEmpty"  marked:  false "B := Q.isEmpty" super:  Q.isEmpty 
 -- Invocation:Qalloc: "Q.isEmpty" 
 -- ObjectInvocation:Qalloc: "Q" 
 -- name: "Q" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "isEmpty" 
 -- name: "isEmpty" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 out B: var Boolean{B := head == none} 
 -- OG:Qalloc:SuperAlloc: "isEmpty: {   out B: var Boolean;   B := head == none}" 
 -- OG:Qalloc: "out B: var Boolean{   B := head == none}" qDescno:  0 
 -- OG:Qalloc:A:  "isEmpty"  super:  ""  marked:  false "isEmpty: {   out B: var Boolean;   B := head == none}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "out B: var Boolean{   B := head == none}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "isEmpty" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 177 IS.newDescNo: 177 objSize: 0 1: 1 "out B: var Boolean{B := head == none}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 177 "out B: var Boolean{B := head == none}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "B" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Invocation:Qalloc: "B" 
 -- ObjectInvocation:Qalloc: "B" 
 -- name: "B" 
 -- Arguments "" 
 -- OG:Qalloc: "head == none" qDescno:  0 
 -- OG:Qalloc:A:  "=="  super:  "head == none"  marked:  false "B := head == none" super:  head == none 
 -- Invocation:Qalloc: "head == none" 
 -- BinaryExp:Qalloc: "head == none" 
 -- Invocation:Qalloc: "head" 
 -- ObjectInvocation:Qalloc: "head" 
 -- name: "head" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "== none" 
 -- name: "==" 
 -- Arguments "none" 
 -- OG:Qalloc: "none" qDescno:  0 
 -- OG:Qalloc:A:  "none"  super:  "none"  marked:  false "none" super:  none 
 -- Invocation:Qalloc: "none" 
 -- ObjectInvocation:Qalloc: "none" 
 -- name: "none" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  116 2 %basic 19{none_x: var integer} 
 -- OG:super:  "none: {   %basic 19;   none_x: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "none" 
 -- super:  "none" 
 -- E:  "none" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "none" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  144 3 %basic 56{in objx: ref Object;out V: var boolean} 
 -- OG:super:  "==  : {   %basic 56;   in objx: ref Object;   out V: var boolean}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "head == none" 
 -- super:  "head == none" 
 -- E:  "head == none" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "head == none" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 177 "out B: var Boolean{B := head == none}" 
 -- IS.newDescNo: 177 IS.objSize: 2 "out B: var Boolean{B := head == none}" 
 -- OG:Qalloc:end: IS.newDescNo:  177 "out B: var Boolean{   B := head == none}" 
 -- OG:super:  "isEmpty: {   out B: var Boolean;   B := head == none}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Q.isEmpty" 
 -- super:  "Q.isEmpty" 
 -- E:  "isEmpty" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Q.isEmpty" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 176 "B := Q.isEmpty" 
 -- IS.newDescNo: 176 IS.objSize: 2 "B := Q.isEmpty" 
 -- OG:Qalloc:end: IS.newDescNo:  176 "entry{   B := Q.isEmpty}" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 175 "out B: var Boolean{entry;   B := Q.isEmpty}" 
 -- IS.newDescNo: 175 IS.objSize: 2 "out B: var Boolean{entry;   B := Q.isEmpty}" 
 -- OG:Qalloc:end: IS.newDescNo:  175 "out B: var Boolean{   entry;      B := Q.isEmpty}" 
 -- OG:super:  "isEmpty: {   out B: var Boolean;   entry;      B := Q.isEmpty}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(SQS.isEmpty)" 
 -- super:  "(SQS.isEmpty)" 
 -- E:  "(SQS.isEmpty)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(SQS.isEmpty)" 
 -- OG:Qalloc: "if (SQS.hasWaiting) :then {      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) :then ;      sleep(50);      sch.add;      restart(loop)}" qDesc ... 0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (SQS.isEmpty) :then {   if (SQS.hasWaiting) :then ;      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) : ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "if (SQS.hasWaiting) :then {      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) :then ;      sleep(50);      sch.add;      restart(loop)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 178 IS.newDescNo: 178 objSize: 0 1: 1 "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop);sch.dcr;if (sch.running) :then ;   sleep(50);   ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 178 "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop);sch.dcr;if (sch.running) :then ;   sleep(50);   sch.add;   restart(loop) ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop)}" qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop)}"  marked:  false "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop); ...}" s ... i ... 
 -- Invocation:Qalloc: "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop)}" 
 -- OG:Qalloc: "(SQS.hasWaiting)" qDescno:  0 
 -- OG:Qalloc:A:  "hasWaiting"  super:  "(SQS.hasWaiting)"  marked:  false "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop)}" super:  (SQS.hasWaiting) 
 -- Invocation:Qalloc: "(SQS.hasWaiting)" 
 -- Invocation:Qalloc: "SQS.hasWaiting" 
 -- ObjectInvocation:Qalloc: "SQS" 
 -- name: "SQS" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "hasWaiting" 
 -- name: "hasWaiting" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 out B: var boolean{entry;   B := W > 0} 
 -- OG:Qalloc:SuperAlloc: "hasWaiting: {   out B: var boolean;   entry;      B := W > 0}" 
 -- OG:Qalloc: "out B: var boolean{   entry;      B := W > 0}" qDescno:  0 
 -- OG:Qalloc:A:  "hasWaiting"  super:  ""  marked:  false "hasWaiting: {   out B: var boolean;   entry;      B := W > 0}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "out B: var boolean{   entry;      B := W > 0}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "hasWaiting" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 179 IS.newDescNo: 179 objSize: 0 1: 1 "out B: var boolean{entry;   B := W > 0}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 179 "out B: var boolean{entry;   B := W > 0}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "B" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- OG:Qalloc: "entry{   B := W > 0}" qDescno:  0 
 -- OG:Qalloc:A:  "entry$0"  super:  "entry"  marked:  false "out B: var boolean{entry;   B := W > 0}" super:  entry 
 -- Invocation:Qalloc: "entry" 
 -- ObjectInvocation:Qalloc: "entry" 
 -- name: "entry" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  95 1 L.get{V := V + 1;if (V > 1) :then ;   put('V');inner(entry);V := V - 1;L.free} 
 -- OG:super:  "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "entry{   B := W > 0}" 
 -- super:  "entry" 
 -- E:  "entry" 
 -- OG:Qalloc:B: "entry$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 180 IS.newDescNo: 180 objSize: 0 1: 1 "B := W > 0" 
 -- Items:Qalloc:objSize: 0  newDescNo: 180 "B := W > 0" 
 -- Items:Qalloc:super: "entry" size: 1 "entry$180" 
 -- super.isThisBlockLevel: false superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 2 originOff: 2 
 -- Invocation:Qalloc: "B" 
 -- ObjectInvocation:Qalloc: "B" 
 -- name: "B" 
 -- Arguments "" 
 -- OG:Qalloc: "W > 0" qDescno:  0 
 -- OG:Qalloc:A:  ">"  super:  "W > 0"  marked:  false "B := W > 0" super:  W > 0 
 -- Invocation:Qalloc: "W > 0" 
 -- BinaryExp:Qalloc: "W > 0" 
 -- Invocation:Qalloc: "W" 
 -- ObjectInvocation:Qalloc: "W" 
 -- name: "W" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "> 0" 
 -- name: ">" 
 -- Arguments "0" 
 -- OG:Qalloc: "0" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "0"  marked:  false "0" super:  0 
 -- Invocation:Qalloc: "0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "0" 
 -- super:  "0" 
 -- E:  "0" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  101 5 %basic 53{in V: var integer;out B: var boolean} 
 -- OG:super:  ">  : {   %basic 53;   in V: var integer;   out B: var boolean}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "W > 0" 
 -- super:  "W > 0" 
 -- E:  "W > 0" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "W > 0" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 180 "B := W > 0" 
 -- IS.newDescNo: 180 IS.objSize: 2 "B := W > 0" 
 -- OG:Qalloc:end: IS.newDescNo:  180 "entry{   B := W > 0}" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 179 "out B: var boolean{entry;   B := W > 0}" 
 -- IS.newDescNo: 179 IS.objSize: 2 "out B: var boolean{entry;   B := W > 0}" 
 -- OG:Qalloc:end: IS.newDescNo:  179 "out B: var boolean{   entry;      B := W > 0}" 
 -- OG:super:  "hasWaiting: {   out B: var boolean;   entry;      B := W > 0}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(SQS.hasWaiting)" 
 -- super:  "(SQS.hasWaiting)" 
 -- E:  "(SQS.hasWaiting)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(SQS.hasWaiting)" 
 -- OG:Qalloc: "sleep(100){   restart(Loop)}" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "sleep(100){   restart(Loop)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 181 IS.newDescNo: 181 objSize: 0 1: 1 "sleep(100){restart(Loop)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 181 "sleep(100){restart(Loop)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: "sleep(100)" qDescno:  0 
 -- OG:Qalloc:A:  "sleep"  super:  "sleep(100)"  marked:  false "sleep(100){restart(Loop)}" super:  sleep(100) 
 -- Invocation:Qalloc: "sleep(100)" 
 -- ObjectInvocation:Qalloc: "sleep(100)" 
 -- name: "sleep" 
 -- Arguments "sleep(100)" 
 -- OG:Qalloc: "100" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "100"  marked:  false "sleep(100)" super:  100 
 -- Invocation:Qalloc: "100" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "100" 
 -- super:  "100" 
 -- E:  "100" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "100" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  100 2 %basic 15{in V: var integer} 
 -- OG:super:  "sleep: {   %basic 15;   in V: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "sleep(100)" 
 -- super:  "sleep(100)" 
 -- E:  "sleep(100)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "sleep(100)" 
 -- OG:Qalloc: "restart(Loop)" qDescno:  0 
 -- OG:Qalloc:A:  "restart"  super:  "restart(Loop)"  marked:  false "sleep(100){restart(Loop)}" super:  restart(Loop) 
 -- Invocation:Qalloc: "restart(Loop)" 
 -- ObjectInvocation:Qalloc: "restart(Loop)" 
 -- name: "restart" 
 -- Arguments "restart(Loop)" 
 -- OG:Qalloc: "Loop" qDescno:  0 
 -- OG:Qalloc:A:  "loop"  super:  "Loop"  marked:  false "restart(Loop)" super:  Loop 
 -- Invocation:Qalloc: "Loop" 
 -- ObjectInvocation:Qalloc: "Loop" 
 -- name: "Loop" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  165 1 inScheduler := 1{active := SQS.removeNext;if (active =/= none) :then ;   active.status := P_status.ACTIVE;   inSc ...} 
 -- OG:super:  "loop: do {   inScheduler := 1;   active := SQS.removeNext;   if (active =/= none) :then ;      active.status := P_status.ACTIVE;      inScheduler := 0;      ac ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Loop" 
 -- super:  "Loop" 
 -- E:  "Loop" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Loop" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  50 2 %basic 102 
 -- OG:super:  "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "restart(Loop)" 
 -- super:  "restart(Loop)" 
 -- E:  "restart(Loop)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "restart(Loop)" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 181 "sleep(100){restart(Loop)}" 
 -- IS.newDescNo: 181 IS.objSize: 1 "sleep(100){restart(Loop)}" 
 -- OG:Qalloc:end: IS.newDescNo:  181 "sleep(100){   restart(Loop)}" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop)}" 
 -- super:  "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop)}" 
 -- E:  "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop)}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop)}" 
 -- OG:Qalloc: "sch.dcr" qDescno:  0 
 -- OG:Qalloc:A:  "dcr"  super:  "sch.dcr"  marked:  false "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop);sch.dcr;if (sch.running) :then ;   sleep(50);   sch.add;  ...}" s ... s ... 
 -- Invocation:Qalloc: "sch.dcr" 
 -- ObjectInvocation:Qalloc: "sch" 
 -- name: "sch" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "dcr" 
 -- name: "dcr" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 entry{   M := M - 1} 
 -- OG:Qalloc:SuperAlloc: "dcr: {   entry;      M := M - 1}" 
 -- OG:Qalloc: "entry{      M := M - 1}" qDescno:  0 
 -- OG:Qalloc:A:  "dcr"  super:  ""  marked:  false "dcr: {   entry;      M := M - 1}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "entry{      M := M - 1}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "dcr" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 182 IS.newDescNo: 182 objSize: 0 1: 1 "entry{   M := M - 1}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 182 "entry{   M := M - 1}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- OG:Qalloc: "entry{   M := M - 1}" qDescno:  0 
 -- OG:Qalloc:A:  "entry$0"  super:  "entry"  marked:  false "entry{   M := M - 1}" super:  entry 
 -- Invocation:Qalloc: "entry" 
 -- ObjectInvocation:Qalloc: "entry" 
 -- name: "entry" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  129 1 L.get{inner(entry);L.free} 
 -- OG:super:  "entry: {   L.get;   inner(entry);   L.free}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "entry{   M := M - 1}" 
 -- super:  "entry" 
 -- E:  "entry" 
 -- OG:Qalloc:B: "entry$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 183 IS.newDescNo: 183 objSize: 0 1: 1 "M := M - 1" 
 -- Items:Qalloc:objSize: 0  newDescNo: 183 "M := M - 1" 
 -- Items:Qalloc:super: "entry" size: 1 "entry$183" 
 -- super.isThisBlockLevel: false superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 2 originOff: 2 
 -- Invocation:Qalloc: "M" 
 -- ObjectInvocation:Qalloc: "M" 
 -- name: "M" 
 -- Arguments "" 
 -- OG:Qalloc: "M - 1" qDescno:  0 
 -- OG:Qalloc:A:  "-"  super:  "M - 1"  marked:  false "M := M - 1" super:  M - 1 
 -- Invocation:Qalloc: "M - 1" 
 -- BinaryExp:Qalloc: "M - 1" 
 -- Invocation:Qalloc: "M" 
 -- ObjectInvocation:Qalloc: "M" 
 -- name: "M" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "- 1" 
 -- name: "-" 
 -- Arguments "1" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "1" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  108 5 %basic 62{in V: var integer;out R: var integer} 
 -- OG:super:  "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "M - 1" 
 -- super:  "M - 1" 
 -- E:  "M - 1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "M - 1" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 183 "M := M - 1" 
 -- IS.newDescNo: 183 IS.objSize: 2 "M := M - 1" 
 -- OG:Qalloc:end: IS.newDescNo:  183 "entry{   M := M - 1}" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 182 "entry{   M := M - 1}" 
 -- IS.newDescNo: 182 IS.objSize: 1 "entry{   M := M - 1}" 
 -- OG:Qalloc:end: IS.newDescNo:  182 "entry{      M := M - 1}" 
 -- OG:super:  "dcr: {   entry;      M := M - 1}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "sch.dcr" 
 -- super:  "sch.dcr" 
 -- E:  "dcr" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "sch.dcr" 
 -- OG:Qalloc: "if (sch.running) :then {   sleep(50);   sch.add;   restart(loop)}" qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (sch.running) :then {   sleep(50);   sch.add;   restart(loop)}"  marked:  false "if (SQS.hasWaiting) :then {   sleep(100);   restart ...}" s ... i ... 
 -- Invocation:Qalloc: "if (sch.running) :then {   sleep(50);   sch.add;   restart(loop)}" 
 -- OG:Qalloc: "(sch.running)" qDescno:  0 
 -- OG:Qalloc:A:  "running"  super:  "(sch.running)"  marked:  false "if (sch.running) :then {   sleep(50);   sch.add;   restart(loop)}" super:  (sch.running) 
 -- Invocation:Qalloc: "(sch.running)" 
 -- Invocation:Qalloc: "sch.running" 
 -- ObjectInvocation:Qalloc: "sch" 
 -- name: "sch" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "running" 
 -- name: "running" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 out B: var Boolean{entry;   B := M > 0} 
 -- OG:Qalloc:SuperAlloc: "running: {   out B: var Boolean;   entry;      B := M > 0}" 
 -- OG:Qalloc: "out B: var Boolean{   entry;      B := M > 0}" qDescno:  0 
 -- OG:Qalloc:A:  "running"  super:  ""  marked:  false "running: {   out B: var Boolean;   entry;      B := M > 0}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "out B: var Boolean{   entry;      B := M > 0}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "running" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 184 IS.newDescNo: 184 objSize: 0 1: 1 "out B: var Boolean{entry;   B := M > 0}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 184 "out B: var Boolean{entry;   B := M > 0}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "B" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- OG:Qalloc: "entry{   B := M > 0}" qDescno:  0 
 -- OG:Qalloc:A:  "entry$0"  super:  "entry"  marked:  false "out B: var Boolean{entry;   B := M > 0}" super:  entry 
 -- Invocation:Qalloc: "entry" 
 -- ObjectInvocation:Qalloc: "entry" 
 -- name: "entry" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  129 1 L.get{inner(entry);L.free} 
 -- OG:super:  "entry: {   L.get;   inner(entry);   L.free}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "entry{   B := M > 0}" 
 -- super:  "entry" 
 -- E:  "entry" 
 -- OG:Qalloc:B: "entry$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 185 IS.newDescNo: 185 objSize: 0 1: 1 "B := M > 0" 
 -- Items:Qalloc:objSize: 0  newDescNo: 185 "B := M > 0" 
 -- Items:Qalloc:super: "entry" size: 1 "entry$185" 
 -- super.isThisBlockLevel: false superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 2 originOff: 2 
 -- Invocation:Qalloc: "B" 
 -- ObjectInvocation:Qalloc: "B" 
 -- name: "B" 
 -- Arguments "" 
 -- OG:Qalloc: "M > 0" qDescno:  0 
 -- OG:Qalloc:A:  ">"  super:  "M > 0"  marked:  false "B := M > 0" super:  M > 0 
 -- Invocation:Qalloc: "M > 0" 
 -- BinaryExp:Qalloc: "M > 0" 
 -- Invocation:Qalloc: "M" 
 -- ObjectInvocation:Qalloc: "M" 
 -- name: "M" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "> 0" 
 -- name: ">" 
 -- Arguments "0" 
 -- OG:Qalloc: "0" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "0"  marked:  false "0" super:  0 
 -- Invocation:Qalloc: "0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "0" 
 -- super:  "0" 
 -- E:  "0" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  101 5 %basic 53{in V: var integer;out B: var boolean} 
 -- OG:super:  ">  : {   %basic 53;   in V: var integer;   out B: var boolean}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "M > 0" 
 -- super:  "M > 0" 
 -- E:  "M > 0" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "M > 0" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 185 "B := M > 0" 
 -- IS.newDescNo: 185 IS.objSize: 2 "B := M > 0" 
 -- OG:Qalloc:end: IS.newDescNo:  185 "entry{   B := M > 0}" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 184 "out B: var Boolean{entry;   B := M > 0}" 
 -- IS.newDescNo: 184 IS.objSize: 2 "out B: var Boolean{entry;   B := M > 0}" 
 -- OG:Qalloc:end: IS.newDescNo:  184 "out B: var Boolean{   entry;      B := M > 0}" 
 -- OG:super:  "running: {   out B: var Boolean;   entry;      B := M > 0}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(sch.running)" 
 -- super:  "(sch.running)" 
 -- E:  "(sch.running)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(sch.running)" 
 -- OG:Qalloc: "sleep(50){   sch.add;   restart(loop)}" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (sch.running) :then {   sleep(50);   sch.add;   restart(loop)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "sleep(50){   sch.add;   restart(loop)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 186 IS.newDescNo: 186 objSize: 0 1: 1 "sleep(50){sch.add;restart(loop)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 186 "sleep(50){sch.add;restart(loop)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: "sleep(50)" qDescno:  0 
 -- OG:Qalloc:A:  "sleep"  super:  "sleep(50)"  marked:  false "sleep(50){sch.add;restart(loop)}" super:  sleep(50) 
 -- Invocation:Qalloc: "sleep(50)" 
 -- ObjectInvocation:Qalloc: "sleep(50)" 
 -- name: "sleep" 
 -- Arguments "sleep(50)" 
 -- OG:Qalloc: "50" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "50"  marked:  false "sleep(50)" super:  50 
 -- Invocation:Qalloc: "50" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "50" 
 -- super:  "50" 
 -- E:  "50" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "50" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  100 2 %basic 15{in V: var integer} 
 -- OG:super:  "sleep: {   %basic 15;   in V: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "sleep(50)" 
 -- super:  "sleep(50)" 
 -- E:  "sleep(50)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "sleep(50)" 
 -- OG:Qalloc: "sch.add" qDescno:  0 
 -- OG:Qalloc:A:  "add"  super:  "sch.add"  marked:  false "sleep(50){sch.add;restart(loop)}" super:  sch.add 
 -- Invocation:Qalloc: "sch.add" 
 -- ObjectInvocation:Qalloc: "sch" 
 -- name: "sch" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "add" 
 -- name: "add" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  128 1 entry{   M := M + 1} 
 -- OG:super:  "add: {   entry;      M := M + 1}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "sch.add" 
 -- super:  "sch.add" 
 -- E:  "add" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "sch.add" 
 -- OG:Qalloc: "restart(loop)" qDescno:  0 
 -- OG:Qalloc:A:  "restart"  super:  "restart(loop)"  marked:  false "sleep(50){sch.add;restart(loop)}" super:  restart(loop) 
 -- Invocation:Qalloc: "restart(loop)" 
 -- ObjectInvocation:Qalloc: "restart(loop)" 
 -- name: "restart" 
 -- Arguments "restart(loop)" 
 -- OG:Qalloc: "loop" qDescno:  0 
 -- OG:Qalloc:A:  "loop"  super:  "loop"  marked:  false "restart(loop)" super:  loop 
 -- Invocation:Qalloc: "loop" 
 -- ObjectInvocation:Qalloc: "loop" 
 -- name: "loop" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  165 1 inScheduler := 1{active := SQS.removeNext;if (active =/= none) :then ;   active.status := P_status.ACTIVE;   inSc ...} 
 -- OG:super:  "loop: do {   inScheduler := 1;   active := SQS.removeNext;   if (active =/= none) :then ;      active.status := P_status.ACTIVE;      inScheduler := 0;      ac ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "loop" 
 -- super:  "loop" 
 -- E:  "loop" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "loop" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  50 2 %basic 102 
 -- OG:super:  "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "restart(loop)" 
 -- super:  "restart(loop)" 
 -- E:  "restart(loop)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "restart(loop)" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 186 "sleep(50){sch.add;restart(loop)}" 
 -- IS.newDescNo: 186 IS.objSize: 1 "sleep(50){sch.add;restart(loop)}" 
 -- OG:Qalloc:end: IS.newDescNo:  186 "sleep(50){   sch.add;   restart(loop)}" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (sch.running) :then {   sleep(50);   sch.add;   restart(loop)}" 
 -- super:  "if (sch.running) :then {   sleep(50);   sch.add;   restart(loop)}" 
 -- E:  "if (sch.running) :then {   sleep(50);   sch.add;   restart(loop)}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (sch.running) :then {   sleep(50);   sch.add;   restart(loop)}" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 178 "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop);sch.dcr;if (sch.running) :then ;   sleep(50);   sch.add;   restart(l ...}" 
 -- IS.newDescNo: 178 IS.objSize: 1 "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop);sch.dcr;if (sch.running) :then ;   sleep(50);   sch.add;   restart(loop)}" 
 -- OG:Qalloc:end: IS.newDescNo:  178 "if (SQS.hasWaiting) :then {      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) :then ;      sleep(50);      sch.add;     ...}" 
 -- OG:Qalloc: "restart(Loop)" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (SQS.isEmpty) :then {   if (SQS.hasWaiting) :then ;      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) : ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "restart(Loop)" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 187 IS.newDescNo: 187 objSize: 0 1: 1 "restart(Loop)" 
 -- Items:Qalloc:objSize: 0  newDescNo: 187 "restart(Loop)" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: "restart(Loop)" qDescno:  0 
 -- OG:Qalloc:A:  "restart"  super:  "restart(Loop)"  marked:  false "restart(Loop)" super:  restart(Loop) 
 -- Invocation:Qalloc: "restart(Loop)" 
 -- ObjectInvocation:Qalloc: "restart(Loop)" 
 -- name: "restart" 
 -- Arguments "restart(Loop)" 
 -- OG:Qalloc: "Loop" qDescno:  0 
 -- OG:Qalloc:A:  "loop"  super:  "Loop"  marked:  false "restart(Loop)" super:  Loop 
 -- Invocation:Qalloc: "Loop" 
 -- ObjectInvocation:Qalloc: "Loop" 
 -- name: "Loop" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  165 1 inScheduler := 1{active := SQS.removeNext;if (active =/= none) :then ;   active.status := P_status.ACTIVE;   inSc ...} 
 -- OG:super:  "loop: do {   inScheduler := 1;   active := SQS.removeNext;   if (active =/= none) :then ;      active.status := P_status.ACTIVE;      inScheduler := 0;      ac ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Loop" 
 -- super:  "Loop" 
 -- E:  "Loop" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Loop" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  50 2 %basic 102 
 -- OG:super:  "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "restart(Loop)" 
 -- super:  "restart(Loop)" 
 -- E:  "restart(Loop)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "restart(Loop)" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 187 "restart(Loop)" 
 -- IS.newDescNo: 187 IS.objSize: 1 "restart(Loop)" 
 -- OG:Qalloc:end: IS.newDescNo:  187 "restart(Loop)" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (SQS.isEmpty) :then {   if (SQS.hasWaiting) :then ;      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) :then ;      sleep(50);      sch.add;      resta ...}" 
 -- super:  "if (SQS.isEmpty) :then {   if (SQS.hasWaiting) :then ;      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) :then ;      sleep(50);      sch.add;    ...}" 
 -- E:  "if (SQS.isEmpty) :then {   if (SQS.hasWaiting) :then ;      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) :then ;      sleep(50);      sch.add;      r ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (SQS.isEmpty) :then {   if (SQS.hasWaiting) :then ;      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) :then ;      sle ...}" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 165 "inScheduler := 1{active := SQS.removeNext;if (active =/= none) :then ;   active.status := P_status.ACTIVE;   inScheduler := 0; ...}" 
 -- IS.newDescNo: 165 IS.objSize: 1 "inScheduler := 1{active := SQS.removeNext;if (active =/= none) :then ;   active.status := P_status.ACTIVE;   inScheduler := 0;   active.at ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  165 "inScheduler := 1{   active := SQS.removeNext;   if (active =/= none) :then ;      active.status := P_status.ACTIVE;      inScheduler :=  ...}" 
 -- ObjTmpStack:add: "loop" : "inScheduler := 1{   active := SQS.removeNext;   if (active =/= none) :then ;      active.status := P_status.ACTIVE;      inScheduler := 0;       ...}" 
 -- items:markForCodeGen: "inScheduler := 1{active := SQS.removeNext;if (active =/= none) :then ;   active.status := P_status.ACTIVE;   inScheduler := 0;   active.attach(50);  ...}" 
 -- markItem: "inScheduler := 1" Assign 
 -- Invocation:markForCodeGen: "inScheduler" 
 -- ObjectInvocation:markForCodeGen: "inScheduler"  ATd: "inScheduler: var Boolean" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- markItem: "active := SQS.removeNext" Assign 
 -- Invocation:markForCodeGen: "active" 
 -- ObjectInvocation:markForCodeGen: "active"  ATd: "active: ref ProcessType" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "SQS.removeNext" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "SQS.removeNext" 
 -- "SQS" false 
 -- "removeNext" false 
 -- 
 -- OG:markSuper: "SQS.removeNext" 
 -- Invocation:markForCodeGen: "SQS.removeNext" 
 -- ObjectInvocation:markForCodeGen: "SQS"  ATd: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;       ...}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "removeNext"  ATd: "removeNext: {   out P: ref BasicProcess;   entry;      P := Q.removeNext}" 
 -- Pattern:markForCodeGen: "removeNext: {   out P: ref BasicProcess;   entry;      P := Q.removeNext}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "out P: ref BasicProcess{   entry;      P := Q.removeNext}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "out P: ref BasicProcess{   entry;      P := Q.removeNext}" 
 -- OG:Qalloc: "out P: ref BasicProcess{   entry;      P := Q.removeNext}" qDescno:  166 
 -- ObjTmpStack:add: "removeNext" : "out P: ref BasicProcess{   entry;      P := Q.removeNext}" 
 -- items:markForCodeGen: "out P: ref BasicProcess{entry;   P := Q.removeNext}" 
 -- DataItem:markForCodeGen: "P" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "BasicProcess" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "BasicProcess" 
 -- "BasicProcess" false 
 -- 
 -- not ObjDesc:  "BasicProcess"  IS.isEmpty:  true 
 -- markItem: "entry{   P := Q.removeNext}" ObjectGenerator 
 -- OG:markForCodeGen: "entry{   P := Q.removeNext}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "entry" 
 -- "entry" false 
 -- 
 -- OG:markSuper: "entry" 
 -- Invocation:markForCodeGen: "entry" 
 -- ObjectInvocation:markForCodeGen: "entry"  ATd: "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free}" 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "entry{   P := Q.removeNext}" 
 -- OG:Qalloc: "entry{   P := Q.removeNext}" qDescno:  167 
 -- ObjTmpStack:add: "entry{   P := Q.removeNext}" 
 -- items:markForCodeGen: "P := Q.removeNext" 
 -- markItem: "P := Q.removeNext" Assign 
 -- Invocation:markForCodeGen: "P" 
 -- ObjectInvocation:markForCodeGen: "P"  ATd: "out P: ref BasicProcess" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "Q.removeNext" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Q.removeNext" 
 -- "Q" false 
 -- "removeNext" false 
 -- 
 -- OG:markSuper: "Q.removeNext" 
 -- Invocation:markForCodeGen: "Q.removeNext" 
 -- ObjectInvocation:markForCodeGen: "Q"  ATd: "Q: obj ProcessQueue" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "removeNext"  ATd: "removeNext: {   -- return last element in queue and remove it for queue      out elm: ref Object;   if (last =/= none) ...}" 
 -- Pattern:markForCodeGen: "removeNext: {   -- return last element in queue and remove it for queue      out elm: ref Object;   if (last =/= none) :then ;      noOfElm := noO ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "-- return last element in queue and remove it for queue      out elm: ref Object{   if (last =/= none) :then ;      noOfElm := noOfElm - 1;      elm := ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "-- return last element in queue and remove it for queue      out elm: ref Object{   if (last =/= none) :then ;      noOfElm := noOfElm - 1;      elm := last.el ...}" 
 -- OG:Qalloc: "-- return last element in queue and remove it for queue      out elm: ref Object{   if (last =/= none) :then ;      noOfElm := noOfElm - 1;      elm := last.el ...}" q ... 168 
 -- ObjTmpStack:add: "removeNext" : "-- return last element in queue and remove it for queue      out elm: ref Object{   if (last =/= none) :then ;      noOfElm := noOfElm - 1 ...}" 
 -- items:markForCodeGen: "-- return last element in queue and remove it for queue      out elm: ref Object{if (last =/= none) :then ;   noOfElm := noOfElm - 1;   elm := last. ...}" 
 -- DataItem:markForCodeGen: "elm" :descNo: 0 :OG.primNo: 64 
 -- OG:markForCodeGen: "Object" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Object" 
 -- "Object" true 
 -- 
 -- not ObjDesc:  "Object"  IS.isEmpty:  true 
 -- markItem: "if (last =/= none) :then {   noOfElm := noOfElm - 1;   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;      last.succ := none;   :else ;      ...}" O ... 
 -- OG:markForCodeGen: "if (last =/= none) :then {   noOfElm := noOfElm - 1;   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;      last.succ := none;   :el ...}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (last =/= none) :then {   noOfElm := noOfElm - 1;   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;      last.succ := none;   :else ;      head := n ...}" 
 -- "if (last =/= none) :then {   noOfElm := noOfElm - 1;   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;      last.succ := none;   :else ;      head := n ...}" true 
 -- 
 -- OG:markSuper: "if (last =/= none) :then {   noOfElm := noOfElm - 1;   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;      last.succ := none;   :else ;  ...}" 
 -- Invocation:markForCodeGen: "if (last =/= none) :then {   noOfElm := noOfElm - 1;   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;      last.succ := non ...}" 
 -- OG:markForCodeGen: "(last =/= none)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(last =/= none)" 
 -- "(last =/= none)" true 
 -- 
 -- OG:markSuper: "(last =/= none)" 
 -- Invocation:markForCodeGen: "(last =/= none)" 
 -- Invocation:markForCodeGen: "last =/= none" 
 -- BinaryExp:markForCodeGen: "last =/= none" 
 -- Invocation:markForCodeGen: "last" 
 -- ObjectInvocation:markForCodeGen: "last"  ATd: "last: ref Element" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "=/= none"  ATd: "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean}" 
 -- OI:args:markForCodgen: "none" 
 -- not ObjDesc:  "(last =/= none)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "noOfElm := noOfElm - 1{   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;      last.succ := none;   :else ;      head := none;       ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "noOfElm := noOfElm - 1{   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;      last.succ := none;   :else ;      head := none;      --"remov ..."}" 
 -- OG:Qalloc: "noOfElm := noOfElm - 1{   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;      last.succ := none;   :else ;      head := none;      --"remov ..."}" q ... 169 
 -- ObjTmpStack:add: "noOfElm := noOfElm - 1{   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;      last.succ := none;   :else ;      head := none;      -- ...}" 
 -- items:markForCodeGen: "noOfElm := noOfElm - 1{elm := last.elm;last := last.pred;if (last =/= none) :then ;   last.succ := none;:else ;   head := none;   --"removeNext:".pr ...}" 
 -- markItem: "noOfElm := noOfElm - 1" Assign 
 -- Invocation:markForCodeGen: "noOfElm" 
 -- ObjectInvocation:markForCodeGen: "noOfElm"  ATd: "noOfElm: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "noOfElm - 1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "noOfElm - 1" 
 -- "noOfElm - 1" true 
 -- 
 -- OG:markSuper: "noOfElm - 1" 
 -- Invocation:markForCodeGen: "noOfElm - 1" 
 -- BinaryExp:markForCodeGen: "noOfElm - 1" 
 -- Invocation:markForCodeGen: "noOfElm" 
 -- ObjectInvocation:markForCodeGen: "noOfElm"  ATd: "noOfElm: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "- 1"  ATd: "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- OI:args:markForCodgen: "1" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- not ObjDesc:  "noOfElm - 1"  IS.isEmpty:  true 
 -- markItem: "elm := last.elm" Assign 
 -- Invocation:markForCodeGen: "elm" 
 -- ObjectInvocation:markForCodeGen: "elm"  ATd: "out elm: ref Object" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "last.elm" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "last.elm" 
 -- "last" false 
 -- "elm" true 
 -- 
 -- markItem: "last := last.pred" Assign 
 -- Invocation:markForCodeGen: "last" 
 -- ObjectInvocation:markForCodeGen: "last"  ATd: "last: ref Element" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "last.pred" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "last.pred" 
 -- "last" false 
 -- "pred" false 
 -- 
 -- markItem: "if (last =/= none) :then {   last.succ := none;:else ;   head := none;   --"removeNext:".print;   --idf.print;   --putint(noOfElm);   --newline	 }" ObjectGenera ... 
 -- OG:markForCodeGen: "if (last =/= none) :then {   last.succ := none;:else ;   head := none;   --"removeNext:".print;   --idf.print;   --putint(noOfElm);   --newline	 }" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (last =/= none) :then {   last.succ := none;:else ;   head := none;   --"removeNext:".print;   --idf.print;   --putint(noOfElm);   --newline	 }" 
 -- "if (last =/= none) :then {   last.succ := none;:else ;   head := none;   --"removeNext:".print;   --idf.print;   --putint(noOfElm);   --newline	 }" true 
 -- 
 -- OG:markSuper: "if (last =/= none) :then {   last.succ := none;:else ;   head := none;   --"removeNext:".print;   --idf.print;   --putint(noOfElm);   --newline	 }" 
 -- Invocation:markForCodeGen: "if (last =/= none) :then {   last.succ := none;:else ;   head := none;   --"removeNext:".print;   --idf.print;   --putint(noOfElm);   --newline ...}" 
 -- OG:markForCodeGen: "(last =/= none)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(last =/= none)" 
 -- "(last =/= none)" true 
 -- 
 -- OG:markSuper: "(last =/= none)" 
 -- Invocation:markForCodeGen: "(last =/= none)" 
 -- Invocation:markForCodeGen: "last =/= none" 
 -- BinaryExp:markForCodeGen: "last =/= none" 
 -- Invocation:markForCodeGen: "last" 
 -- ObjectInvocation:markForCodeGen: "last"  ATd: "last: ref Element" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "=/= none"  ATd: "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean}" 
 -- OI:args:markForCodgen: "none" 
 -- not ObjDesc:  "(last =/= none)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "last.succ := none" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "last.succ := none" 
 -- OG:Qalloc: "last.succ := none" qDescno:  170 
 -- ObjTmpStack:add: "last.succ := none" 
 -- items:markForCodeGen: "last.succ := none" 
 -- markItem: "last.succ := none" Assign 
 -- Invocation:markForCodeGen: "last.succ" 
 -- ObjectInvocation:markForCodeGen: "last"  ATd: "last: ref Element" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "succ"  ATd: "succ: ref Element" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "head := none{   --"removeNext:".print;   --idf.print;   --putint(noOfElm);   --newline	 }" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "head := none{   --"removeNext:".print;   --idf.print;   --putint(noOfElm);   --newline	 }" 
 -- OG:Qalloc: "head := none{   --"removeNext:".print;   --idf.print;   --putint(noOfElm);   --newline	 }" qDescno:  171 
 -- ObjTmpStack:add: "head := none{   --"removeNext:".print;   --idf.print;   --putint(noOfElm);   --newline	 }" 
 -- items:markForCodeGen: "head := none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- markItem: "head := none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 }" Assign 
 -- Invocation:markForCodeGen: "head" 
 -- ObjectInvocation:markForCodeGen: "head"  ATd: "head: ref Element" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "if (last =/= none) :then {   last.succ := none;:else ;   head := none;   --"removeNext:".print;   --idf.print;   --putint(noOfElm);   --newline	 }"  IS.isEm ... true 
 -- not ObjDesc:  "if (last =/= none) :then {   noOfElm := noOfElm - 1;   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;      last.succ := none;   :else ;  ...}"   ... true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Q.removeNext"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "SQS.removeNext"  IS.isEmpty:  true 
 -- markItem: "if (active =/= none) :then {   active.status := P_status.ACTIVE;   inScheduler := 0;   active.attach(50);   inScheduler := 1;   if (active.status = P_status.ACT ...}" O ... 
 -- OG:markForCodeGen: "if (active =/= none) :then {   active.status := P_status.ACTIVE;   inScheduler := 0;   active.attach(50);   inScheduler := 1;   if (active.status = P_s ...}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (active =/= none) :then {   active.status := P_status.ACTIVE;   inScheduler := 0;   active.attach(50);   inScheduler := 1;   if (active.status = P_status.ACTIVE) :then ...}" 
 -- "if (active =/= none) :then {   active.status := P_status.ACTIVE;   inScheduler := 0;   active.attach(50);   inScheduler := 1;   if (active.status = P_status.ACTIVE) :then ...}" true 
 -- 
 -- OG:markSuper: "if (active =/= none) :then {   active.status := P_status.ACTIVE;   inScheduler := 0;   active.attach(50);   inScheduler := 1;   if (active.status = P_status ...}" 
 -- Invocation:markForCodeGen: "if (active =/= none) :then {   active.status := P_status.ACTIVE;   inScheduler := 0;   active.attach(50);   inScheduler := 1;   if (active.stat ...}" 
 -- OG:markForCodeGen: "(active =/= none)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(active =/= none)" 
 -- "(active =/= none)" true 
 -- 
 -- OG:markSuper: "(active =/= none)" 
 -- Invocation:markForCodeGen: "(active =/= none)" 
 -- Invocation:markForCodeGen: "active =/= none" 
 -- BinaryExp:markForCodeGen: "active =/= none" 
 -- Invocation:markForCodeGen: "active" 
 -- ObjectInvocation:markForCodeGen: "active"  ATd: "active: ref ProcessType" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "=/= none"  ATd: "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean}" 
 -- OI:args:markForCodgen: "none" 
 -- not ObjDesc:  "(active =/= none)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "active.status := P_status.ACTIVE{   inScheduler := 0;   active.attach(50);   inScheduler := 1;   if (active.status = P_status.ACTIVE) :then ;      SQS. ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "active.status := P_status.ACTIVE{   inScheduler := 0;   active.attach(50);   inScheduler := 1;   if (active.status = P_status.ACTIVE) :then ;      SQS.insert(a ...}" 
 -- OG:Qalloc: "active.status := P_status.ACTIVE{   inScheduler := 0;   active.attach(50);   inScheduler := 1;   if (active.status = P_status.ACTIVE) :then ;      SQS.insert(a ...}" q ... 172 
 -- ObjTmpStack:add: "active.status := P_status.ACTIVE{   inScheduler := 0;   active.attach(50);   inScheduler := 1;   if (active.status = P_status.ACTIVE) :then ;      SQS.in ...}" 
 -- items:markForCodeGen: "active.status := P_status.ACTIVE{inScheduler := 0;active.attach(50);inScheduler := 1;if (active.status = P_status.ACTIVE) :then ;   SQS.insert(activ ...}" 
 -- markItem: "active.status := P_status.ACTIVE" Assign 
 -- Invocation:markForCodeGen: "active.status" 
 -- ObjectInvocation:markForCodeGen: "active"  ATd: "active: ref ProcessType" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "status"  ATd: "status: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "P_status.ACTIVE" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "P_status.ACTIVE" 
 -- "P_status" false 
 -- "ACTIVE" true 
 -- 
 -- markItem: "inScheduler := 0" Assign 
 -- Invocation:markForCodeGen: "inScheduler" 
 -- ObjectInvocation:markForCodeGen: "inScheduler"  ATd: "inScheduler: var Boolean" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "0" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "0" 
 -- "0" true 
 -- 
 -- OG:markSuper: "0" 
 -- Invocation:markForCodeGen: "0" 
 -- not ObjDesc:  "0"  IS.isEmpty:  true 
 -- markItem: "active.attach(50)" ObjectGenerator 
 -- markItem: "inScheduler := 1" Assign 
 -- Invocation:markForCodeGen: "inScheduler" 
 -- ObjectInvocation:markForCodeGen: "inScheduler"  ATd: "inScheduler: var Boolean" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- markItem: "if (active.status = P_status.ACTIVE) :then {   SQS.insert(active)}" ObjectGenerator 
 -- OG:markForCodeGen: "if (active.status = P_status.ACTIVE) :then {   SQS.insert(active)}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (active.status = P_status.ACTIVE) :then {   SQS.insert(active)}" 
 -- "if (active.status = P_status.ACTIVE) :then {   SQS.insert(active)}" true 
 -- 
 -- OG:markSuper: "if (active.status = P_status.ACTIVE) :then {   SQS.insert(active)}" 
 -- Invocation:markForCodeGen: "if (active.status = P_status.ACTIVE) :then {   SQS.insert(active)}" 
 -- OG:markForCodeGen: "(active.status = P_status.ACTIVE)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(active.status = P_status.ACTIVE)" 
 -- "(active.status = P_status.ACTIVE)" true 
 -- 
 -- OG:markSuper: "(active.status = P_status.ACTIVE)" 
 -- Invocation:markForCodeGen: "(active.status = P_status.ACTIVE)" 
 -- Invocation:markForCodeGen: "active.status = P_status.ACTIVE" 
 -- BinaryExp:markForCodeGen: "active.status = P_status.ACTIVE" 
 -- Invocation:markForCodeGen: "active.status" 
 -- ObjectInvocation:markForCodeGen: "active"  ATd: "active: ref ProcessType" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "status"  ATd: "status: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "= P_status.ACTIVE"  ATd: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OI:args:markForCodgen: "P_status.ACTIVE" 
 -- OG:markForCodeGen: "P_status.ACTIVE" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "P_status.ACTIVE" 
 -- "P_status" false 
 -- "ACTIVE" true 
 -- 
 -- not ObjDesc:  "(active.status = P_status.ACTIVE)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "SQS.insert(active)" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "SQS.insert(active)" 
 -- OG:Qalloc: "SQS.insert(active)" qDescno:  174 
 -- ObjTmpStack:add: "SQS.insert(active)" 
 -- items:markForCodeGen: "SQS.insert(active)" 
 -- markItem: "SQS.insert(active)" ObjectGenerator 
 -- OG:markForCodeGen: "SQS.insert(active)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "SQS.insert(active)" 
 -- "SQS" false 
 -- "insert(active)" false 
 -- 
 -- OG:markSuper: "SQS.insert(active)" 
 -- Invocation:markForCodeGen: "SQS.insert(active)" 
 -- ObjectInvocation:markForCodeGen: "SQS"  ATd: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;       ...}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "insert(active)"  ATd: "insert: entry{   in P: ref BasicProcess;   if (Q.has(P).not) :then ;      Q.insert(P)}" 
 -- OI:args:markForCodgen: "insert(active)" 
 -- OG:markForCodeGen: "active" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "active" 
 -- "active" false 
 -- 
 -- arg:   "active" 
 -- not ObjDesc:  "SQS.insert(active)"  IS.isEmpty:  true 
 -- not ObjDesc:  "if (active.status = P_status.ACTIVE) :then {   SQS.insert(active)}"  IS.isEmpty:  true 
 -- not ObjDesc:  "if (active =/= none) :then {   active.status := P_status.ACTIVE;   inScheduler := 0;   active.attach(50);   inScheduler := 1;   if (active.status = P_status ...}"   ... true 
 -- markItem: "if (SQS.isEmpty) :then {   if (SQS.hasWaiting) :then ;      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) :then ;      sleep(50);      sch.add;  ...}" O ... 
 -- OG:markForCodeGen: "if (SQS.isEmpty) :then {   if (SQS.hasWaiting) :then ;      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) :then ;      sleep(50);       ...}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (SQS.isEmpty) :then {   if (SQS.hasWaiting) :then ;      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) :then ;      sleep(50);      sch.add;      resta ...}" 
 -- "if (SQS.isEmpty) :then {   if (SQS.hasWaiting) :then ;      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) :then ;      sleep(50);      sch.add;      resta ...}" true 
 -- 
 -- OG:markSuper: "if (SQS.isEmpty) :then {   if (SQS.hasWaiting) :then ;      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) :then ;      sleep(50);      sch.a ...}" 
 -- Invocation:markForCodeGen: "if (SQS.isEmpty) :then {   if (SQS.hasWaiting) :then ;      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) :then ;      sleep(50 ...}" 
 -- OG:markForCodeGen: "(SQS.isEmpty)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "(SQS.isEmpty)" 
 -- "(SQS.isEmpty)" false 
 -- 
 -- OG:markSuper: "(SQS.isEmpty)" 
 -- Invocation:markForCodeGen: "(SQS.isEmpty)" 
 -- Invocation:markForCodeGen: "SQS.isEmpty" 
 -- ObjectInvocation:markForCodeGen: "SQS"  ATd: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;       ...}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "isEmpty"  ATd: "isEmpty: {   out B: var Boolean;   entry;      B := Q.isEmpty}" 
 -- Pattern:markForCodeGen: "isEmpty: {   out B: var Boolean;   entry;      B := Q.isEmpty}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "out B: var Boolean{   entry;      B := Q.isEmpty}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "out B: var Boolean{   entry;      B := Q.isEmpty}" 
 -- OG:Qalloc: "out B: var Boolean{   entry;      B := Q.isEmpty}" qDescno:  175 
 -- ObjTmpStack:add: "isEmpty" : "out B: var Boolean{   entry;      B := Q.isEmpty}" 
 -- items:markForCodeGen: "out B: var Boolean{entry;   B := Q.isEmpty}" 
 -- DataItem:markForCodeGen: "B" :descNo: 0 :OG.primNo: 4 
 -- OG:markForCodeGen: "Boolean" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Boolean" 
 -- "Boolean" true 
 -- 
 -- OG:markSuper: "Boolean" 
 -- Invocation:markForCodeGen: "Boolean" 
 -- ObjectInvocation:markForCodeGen: "Boolean"  ATd: "Boolean: value{   %id "Boolean";   %globals inSub;   %basic 4, 8;   %public;   _thisBasicValue: var Universal;   &&  : ;  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Boolean"  IS.isEmpty:  true 
 -- markItem: "entry{   B := Q.isEmpty}" ObjectGenerator 
 -- OG:markForCodeGen: "entry{   B := Q.isEmpty}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "entry" 
 -- "entry" false 
 -- 
 -- OG:markSuper: "entry" 
 -- Invocation:markForCodeGen: "entry" 
 -- ObjectInvocation:markForCodeGen: "entry"  ATd: "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free}" 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "entry{   B := Q.isEmpty}" 
 -- OG:Qalloc: "entry{   B := Q.isEmpty}" qDescno:  176 
 -- ObjTmpStack:add: "entry{   B := Q.isEmpty}" 
 -- items:markForCodeGen: "B := Q.isEmpty" 
 -- markItem: "B := Q.isEmpty" Assign 
 -- Invocation:markForCodeGen: "B" 
 -- ObjectInvocation:markForCodeGen: "B"  ATd: "out B: var Boolean" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "Q.isEmpty" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Q.isEmpty" 
 -- "Q" false 
 -- "isEmpty" false 
 -- 
 -- OG:markSuper: "Q.isEmpty" 
 -- Invocation:markForCodeGen: "Q.isEmpty" 
 -- ObjectInvocation:markForCodeGen: "Q"  ATd: "Q: obj ProcessQueue" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "isEmpty"  ATd: "isEmpty: {   out B: var Boolean;   B := head == none}" 
 -- Pattern:markForCodeGen: "isEmpty: {   out B: var Boolean;   B := head == none}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "out B: var Boolean{   B := head == none}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "out B: var Boolean{   B := head == none}" 
 -- OG:Qalloc: "out B: var Boolean{   B := head == none}" qDescno:  177 
 -- ObjTmpStack:add: "isEmpty" : "out B: var Boolean{   B := head == none}" 
 -- items:markForCodeGen: "out B: var Boolean{B := head == none}" 
 -- DataItem:markForCodeGen: "B" :descNo: 0 :OG.primNo: 4 
 -- OG:markForCodeGen: "Boolean" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Boolean" 
 -- "Boolean" true 
 -- 
 -- OG:markSuper: "Boolean" 
 -- Invocation:markForCodeGen: "Boolean" 
 -- ObjectInvocation:markForCodeGen: "Boolean"  ATd: "Boolean: value{   %id "Boolean";   %globals inSub;   %basic 4, 8;   %public;   _thisBasicValue: var Universal;   &&  : ;  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Boolean"  IS.isEmpty:  true 
 -- markItem: "B := head == none" Assign 
 -- Invocation:markForCodeGen: "B" 
 -- ObjectInvocation:markForCodeGen: "B"  ATd: "out B: var Boolean" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "head == none" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "head == none" 
 -- "head == none" true 
 -- 
 -- OG:markSuper: "head == none" 
 -- Invocation:markForCodeGen: "head == none" 
 -- BinaryExp:markForCodeGen: "head == none" 
 -- Invocation:markForCodeGen: "head" 
 -- ObjectInvocation:markForCodeGen: "head"  ATd: "head: ref Element" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "== none"  ATd: "==  : {   %basic 56;   in objx: ref Object;   out V: var boolean}" 
 -- OI:args:markForCodgen: "none" 
 -- not ObjDesc:  "head == none"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Q.isEmpty"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "(SQS.isEmpty)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "if (SQS.hasWaiting) :then {      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) :then ;      sleep(50);      sch.add;      restart(loop) ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "if (SQS.hasWaiting) :then {      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) :then ;      sleep(50);      sch.add;      restart(loop)}" 
 -- OG:Qalloc: "if (SQS.hasWaiting) :then {      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) :then ;      sleep(50);      sch.add;      restart(loop)}" qDesc ... 178 
 -- ObjTmpStack:add: "if (SQS.hasWaiting) :then {      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) :then ;      sleep(50);      sch.add;      restart(loop)}" 
 -- items:markForCodeGen: "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop);sch.dcr;if (sch.running) :then ;   sleep(50);   sch.add;   restart(loop)}" 
 -- markItem: "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop)}" ObjectGenerator 
 -- OG:markForCodeGen: "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop)}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop)}" 
 -- "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop)}" true 
 -- 
 -- OG:markSuper: "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop)}" 
 -- Invocation:markForCodeGen: "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop)}" 
 -- OG:markForCodeGen: "(SQS.hasWaiting)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "(SQS.hasWaiting)" 
 -- "(SQS.hasWaiting)" false 
 -- 
 -- OG:markSuper: "(SQS.hasWaiting)" 
 -- Invocation:markForCodeGen: "(SQS.hasWaiting)" 
 -- Invocation:markForCodeGen: "SQS.hasWaiting" 
 -- ObjectInvocation:markForCodeGen: "SQS"  ATd: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;       ...}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "hasWaiting"  ATd: "hasWaiting: {   out B: var boolean;   entry;      B := W > 0}" 
 -- Pattern:markForCodeGen: "hasWaiting: {   out B: var boolean;   entry;      B := W > 0}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "out B: var boolean{   entry;      B := W > 0}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "out B: var boolean{   entry;      B := W > 0}" 
 -- OG:Qalloc: "out B: var boolean{   entry;      B := W > 0}" qDescno:  179 
 -- ObjTmpStack:add: "hasWaiting" : "out B: var boolean{   entry;      B := W > 0}" 
 -- items:markForCodeGen: "out B: var boolean{entry;   B := W > 0}" 
 -- DataItem:markForCodeGen: "B" :descNo: 0 :OG.primNo: 4 
 -- OG:markForCodeGen: "boolean" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "boolean" 
 -- "boolean" true 
 -- 
 -- OG:markSuper: "boolean" 
 -- Invocation:markForCodeGen: "boolean" 
 -- ObjectInvocation:markForCodeGen: "boolean"  ATd: "Boolean: value{   %id "Boolean";   %globals inSub;   %basic 4, 8;   %public;   _thisBasicValue: var Universal;   &&  : ;  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "boolean"  IS.isEmpty:  true 
 -- markItem: "entry{   B := W > 0}" ObjectGenerator 
 -- OG:markForCodeGen: "entry{   B := W > 0}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "entry" 
 -- "entry" false 
 -- 
 -- OG:markSuper: "entry" 
 -- Invocation:markForCodeGen: "entry" 
 -- ObjectInvocation:markForCodeGen: "entry"  ATd: "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free}" 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "entry{   B := W > 0}" 
 -- OG:Qalloc: "entry{   B := W > 0}" qDescno:  180 
 -- ObjTmpStack:add: "entry{   B := W > 0}" 
 -- items:markForCodeGen: "B := W > 0" 
 -- markItem: "B := W > 0" Assign 
 -- Invocation:markForCodeGen: "B" 
 -- ObjectInvocation:markForCodeGen: "B"  ATd: "out B: var boolean" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "W > 0" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "W > 0" 
 -- "W > 0" true 
 -- 
 -- OG:markSuper: "W > 0" 
 -- Invocation:markForCodeGen: "W > 0" 
 -- BinaryExp:markForCodeGen: "W > 0" 
 -- Invocation:markForCodeGen: "W" 
 -- ObjectInvocation:markForCodeGen: "W"  ATd: "W: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "> 0"  ATd: ">  : {   %basic 53;   in V: var integer;   out B: var boolean}" 
 -- OI:args:markForCodgen: "0" 
 -- OG:markForCodeGen: "0" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "0" 
 -- "0" true 
 -- 
 -- OG:markSuper: "0" 
 -- Invocation:markForCodeGen: "0" 
 -- not ObjDesc:  "0"  IS.isEmpty:  true 
 -- not ObjDesc:  "W > 0"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "(SQS.hasWaiting)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "sleep(100){   restart(Loop)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "sleep(100){   restart(Loop)}" 
 -- OG:Qalloc: "sleep(100){   restart(Loop)}" qDescno:  181 
 -- ObjTmpStack:add: "sleep(100){   restart(Loop)}" 
 -- items:markForCodeGen: "sleep(100){restart(Loop)}" 
 -- markItem: "sleep(100)" ObjectGenerator 
 -- markItem: "restart(Loop)" ObjectGenerator 
 -- not ObjDesc:  "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop)}"  IS.isEmpty:  true 
 -- markItem: "sch.dcr" ObjectGenerator 
 -- OG:markForCodeGen: "sch.dcr" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "sch.dcr" 
 -- "sch" false 
 -- "dcr" false 
 -- 
 -- OG:markSuper: "sch.dcr" 
 -- Invocation:markForCodeGen: "sch.dcr" 
 -- ObjectInvocation:markForCodeGen: "sch"  ATd: "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   a ...}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "dcr"  ATd: "dcr: {   entry;      M := M - 1}" 
 -- Pattern:markForCodeGen: "dcr: {   entry;      M := M - 1}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "entry{      M := M - 1}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "entry{      M := M - 1}" 
 -- OG:Qalloc: "entry{      M := M - 1}" qDescno:  182 
 -- ObjTmpStack:add: "dcr" : "entry{      M := M - 1}" 
 -- items:markForCodeGen: "entry{   M := M - 1}" 
 -- markItem: "entry{   M := M - 1}" ObjectGenerator 
 -- OG:markForCodeGen: "entry{   M := M - 1}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "entry" 
 -- "entry" false 
 -- 
 -- OG:markSuper: "entry" 
 -- Invocation:markForCodeGen: "entry" 
 -- ObjectInvocation:markForCodeGen: "entry"  ATd: "entry: {   L.get;   inner(entry);   L.free}" 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "entry{   M := M - 1}" 
 -- OG:Qalloc: "entry{   M := M - 1}" qDescno:  183 
 -- ObjTmpStack:add: "entry{   M := M - 1}" 
 -- items:markForCodeGen: "M := M - 1" 
 -- markItem: "M := M - 1" Assign 
 -- Invocation:markForCodeGen: "M" 
 -- ObjectInvocation:markForCodeGen: "M"  ATd: "M: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "M - 1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "M - 1" 
 -- "M - 1" true 
 -- 
 -- OG:markSuper: "M - 1" 
 -- Invocation:markForCodeGen: "M - 1" 
 -- BinaryExp:markForCodeGen: "M - 1" 
 -- Invocation:markForCodeGen: "M" 
 -- ObjectInvocation:markForCodeGen: "M"  ATd: "M: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "- 1"  ATd: "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- OI:args:markForCodgen: "1" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- not ObjDesc:  "M - 1"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "sch.dcr"  IS.isEmpty:  true 
 -- markItem: "if (sch.running) :then {   sleep(50);   sch.add;   restart(loop)}" ObjectGenerator 
 -- OG:markForCodeGen: "if (sch.running) :then {   sleep(50);   sch.add;   restart(loop)}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (sch.running) :then {   sleep(50);   sch.add;   restart(loop)}" 
 -- "if (sch.running) :then {   sleep(50);   sch.add;   restart(loop)}" true 
 -- 
 -- OG:markSuper: "if (sch.running) :then {   sleep(50);   sch.add;   restart(loop)}" 
 -- Invocation:markForCodeGen: "if (sch.running) :then {   sleep(50);   sch.add;   restart(loop)}" 
 -- OG:markForCodeGen: "(sch.running)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "(sch.running)" 
 -- "(sch.running)" false 
 -- 
 -- OG:markSuper: "(sch.running)" 
 -- Invocation:markForCodeGen: "(sch.running)" 
 -- Invocation:markForCodeGen: "sch.running" 
 -- ObjectInvocation:markForCodeGen: "sch"  ATd: "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   a ...}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "running"  ATd: "running: {   out B: var Boolean;   entry;      B := M > 0}" 
 -- Pattern:markForCodeGen: "running: {   out B: var Boolean;   entry;      B := M > 0}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "out B: var Boolean{   entry;      B := M > 0}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "out B: var Boolean{   entry;      B := M > 0}" 
 -- OG:Qalloc: "out B: var Boolean{   entry;      B := M > 0}" qDescno:  184 
 -- ObjTmpStack:add: "running" : "out B: var Boolean{   entry;      B := M > 0}" 
 -- items:markForCodeGen: "out B: var Boolean{entry;   B := M > 0}" 
 -- DataItem:markForCodeGen: "B" :descNo: 0 :OG.primNo: 4 
 -- OG:markForCodeGen: "Boolean" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Boolean" 
 -- "Boolean" true 
 -- 
 -- OG:markSuper: "Boolean" 
 -- Invocation:markForCodeGen: "Boolean" 
 -- ObjectInvocation:markForCodeGen: "Boolean"  ATd: "Boolean: value{   %id "Boolean";   %globals inSub;   %basic 4, 8;   %public;   _thisBasicValue: var Universal;   &&  : ;  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Boolean"  IS.isEmpty:  true 
 -- markItem: "entry{   B := M > 0}" ObjectGenerator 
 -- OG:markForCodeGen: "entry{   B := M > 0}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "entry" 
 -- "entry" false 
 -- 
 -- OG:markSuper: "entry" 
 -- Invocation:markForCodeGen: "entry" 
 -- ObjectInvocation:markForCodeGen: "entry"  ATd: "entry: {   L.get;   inner(entry);   L.free}" 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "entry{   B := M > 0}" 
 -- OG:Qalloc: "entry{   B := M > 0}" qDescno:  185 
 -- ObjTmpStack:add: "entry{   B := M > 0}" 
 -- items:markForCodeGen: "B := M > 0" 
 -- markItem: "B := M > 0" Assign 
 -- Invocation:markForCodeGen: "B" 
 -- ObjectInvocation:markForCodeGen: "B"  ATd: "out B: var Boolean" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "M > 0" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "M > 0" 
 -- "M > 0" true 
 -- 
 -- OG:markSuper: "M > 0" 
 -- Invocation:markForCodeGen: "M > 0" 
 -- BinaryExp:markForCodeGen: "M > 0" 
 -- Invocation:markForCodeGen: "M" 
 -- ObjectInvocation:markForCodeGen: "M"  ATd: "M: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "> 0"  ATd: ">  : {   %basic 53;   in V: var integer;   out B: var boolean}" 
 -- OI:args:markForCodgen: "0" 
 -- OG:markForCodeGen: "0" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "0" 
 -- "0" true 
 -- 
 -- OG:markSuper: "0" 
 -- Invocation:markForCodeGen: "0" 
 -- not ObjDesc:  "0"  IS.isEmpty:  true 
 -- not ObjDesc:  "M > 0"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "(sch.running)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "sleep(50){   sch.add;   restart(loop)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "sleep(50){   sch.add;   restart(loop)}" 
 -- OG:Qalloc: "sleep(50){   sch.add;   restart(loop)}" qDescno:  186 
 -- ObjTmpStack:add: "sleep(50){   sch.add;   restart(loop)}" 
 -- items:markForCodeGen: "sleep(50){sch.add;restart(loop)}" 
 -- markItem: "sleep(50)" ObjectGenerator 
 -- markItem: "sch.add" ObjectGenerator 
 -- OG:markForCodeGen: "sch.add" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "sch.add" 
 -- "sch" false 
 -- "add" false 
 -- 
 -- OG:markSuper: "sch.add" 
 -- Invocation:markForCodeGen: "sch.add" 
 -- ObjectInvocation:markForCodeGen: "sch"  ATd: "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   a ...}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "add"  ATd: "add: {   entry;      M := M + 1}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "sch.add"  IS.isEmpty:  true 
 -- markItem: "restart(loop)" ObjectGenerator 
 -- not ObjDesc:  "if (sch.running) :then {   sleep(50);   sch.add;   restart(loop)}"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "restart(Loop)" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "restart(Loop)" 
 -- OG:Qalloc: "restart(Loop)" qDescno:  187 
 -- ObjTmpStack:add: "restart(Loop)" 
 -- items:markForCodeGen: "restart(Loop)" 
 -- markItem: "restart(Loop)" ObjectGenerator 
 -- not ObjDesc:  "if (SQS.isEmpty) :then {   if (SQS.hasWaiting) :then ;      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) :then ;      sleep(50);      sch.a ...}"   ... true 
 -- not ObjDesc:  "Scheduler"  IS.isEmpty:  true 
 -- markItem: "C1 := Core" Assign 
 -- Invocation:markForCodeGen: "C1" 
 -- ObjectInvocation:markForCodeGen: "C1"  ATd: "C1: ref Core" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "Core" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Core" 
 -- "Core" false 
 -- 
 -- OG:markSuper: "Core" 
 -- Invocation:markForCodeGen: "Core" 
 -- ObjectInvocation:markForCodeGen: "Core"  ATd: "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;  ...}" 
 -- Pattern:markForCodeGen: "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: obj ;      ...}" 
 -- items:markForCodeGen: "" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Core"  IS.isEmpty:  true 
 -- markItem: "fork(C1)" ObjectGenerator 
 -- markItem: "C2 := Core" Assign 
 -- Invocation:markForCodeGen: "C2" 
 -- ObjectInvocation:markForCodeGen: "C2"  ATd: "C2: ref Core" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "Core" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Core" 
 -- "Core" false 
 -- 
 -- OG:markSuper: "Core" 
 -- Invocation:markForCodeGen: "Core" 
 -- ObjectInvocation:markForCodeGen: "Core"  ATd: "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Core"  IS.isEmpty:  true 
 -- markItem: "fork(C2)" ObjectGenerator 
 -- markItem: "C3 := Core" Assign 
 -- Invocation:markForCodeGen: "C3" 
 -- ObjectInvocation:markForCodeGen: "C3"  ATd: "C3: ref Core" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "Core" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Core" 
 -- "Core" false 
 -- 
 -- OG:markSuper: "Core" 
 -- Invocation:markForCodeGen: "Core" 
 -- ObjectInvocation:markForCodeGen: "Core"  ATd: "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Core"  IS.isEmpty:  true 
 -- markItem: "fork(C3)" ObjectGenerator 
 -- markItem: "C4 := Core" Assign 
 -- Invocation:markForCodeGen: "C4" 
 -- ObjectInvocation:markForCodeGen: "C4"  ATd: "C4: ref Core{-- should be array         }" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "Core" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Core" 
 -- "Core" false 
 -- 
 -- OG:markSuper: "Core" 
 -- Invocation:markForCodeGen: "Core" 
 -- ObjectInvocation:markForCodeGen: "Core"  ATd: "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Core"  IS.isEmpty:  true 
 -- markItem: "fork(C4)" ObjectGenerator 
 -- markItem: "S := Scheduler" Assign 
 -- Invocation:markForCodeGen: "S" 
 -- ObjectInvocation:markForCodeGen: "S"  ATd: "S: ref Scheduler" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "Scheduler" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Scheduler" 
 -- "Scheduler" false 
 -- 
 -- OG:markSuper: "Scheduler" 
 -- Invocation:markForCodeGen: "Scheduler" 
 -- ObjectInvocation:markForCodeGen: "Scheduler"  ATd: "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Scheduler"  IS.isEmpty:  true 
 -- markItem: "C1.attach(S)" ObjectGenerator 
 -- OG:markForCodeGen: "C1.attach(S)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "C1.attach(S)" 
 -- "C1" false 
 -- "attach(S)" false 
 -- 
 -- OG:markSuper: "C1.attach(S)" 
 -- Invocation:markForCodeGen: "C1.attach(S)" 
 -- ObjectInvocation:markForCodeGen: "C1"  ATd: "C1: ref Core" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "attach(S)"  ATd: "attach: {   in M: ref Scheduler;   main := M}" 
 -- Pattern:markForCodeGen: "attach: {   in M: ref Scheduler;   main := M}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "in M: ref Scheduler{   main := M}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "in M: ref Scheduler{   main := M}" 
 -- OG:Qalloc: "in M: ref Scheduler{   main := M}" qDescno:  131 
 -- ObjTmpStack:add: "attach" : "in M: ref Scheduler{   main := M}" 
 -- items:markForCodeGen: "in M: ref Scheduler{main := M}" 
 -- DataItem:markForCodeGen: "M" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Scheduler" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Scheduler" 
 -- "Scheduler" false 
 -- 
 -- not ObjDesc:  "Scheduler"  IS.isEmpty:  true 
 -- markItem: "main := M" Assign 
 -- Invocation:markForCodeGen: "main" 
 -- ObjectInvocation:markForCodeGen: "main"  ATd: "main: ref SuperScheduler" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "M" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "M" 
 -- "M" false 
 -- 
 -- OI:args:markForCodgen: "attach(S)" 
 -- OG:markForCodeGen: "S" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "S" 
 -- "S" false 
 -- 
 -- arg:   "S" 
 -- not ObjDesc:  "C1.attach(S)"  IS.isEmpty:  true 
 -- markItem: "S := Scheduler" Assign 
 -- Invocation:markForCodeGen: "S" 
 -- ObjectInvocation:markForCodeGen: "S"  ATd: "S: ref Scheduler" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "Scheduler" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Scheduler" 
 -- "Scheduler" false 
 -- 
 -- OG:markSuper: "Scheduler" 
 -- Invocation:markForCodeGen: "Scheduler" 
 -- ObjectInvocation:markForCodeGen: "Scheduler"  ATd: "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Scheduler"  IS.isEmpty:  true 
 -- markItem: "C2.attach(S)" ObjectGenerator 
 -- OG:markForCodeGen: "C2.attach(S)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "C2.attach(S)" 
 -- "C2" false 
 -- "attach(S)" false 
 -- 
 -- OG:markSuper: "C2.attach(S)" 
 -- Invocation:markForCodeGen: "C2.attach(S)" 
 -- ObjectInvocation:markForCodeGen: "C2"  ATd: "C2: ref Core" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "attach(S)"  ATd: "attach: {   in M: ref Scheduler;   main := M}" 
 -- OI:args:markForCodgen: "attach(S)" 
 -- OG:markForCodeGen: "S" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "S" 
 -- "S" false 
 -- 
 -- arg:   "S" 
 -- not ObjDesc:  "C2.attach(S)"  IS.isEmpty:  true 
 -- markItem: "S := Scheduler" Assign 
 -- Invocation:markForCodeGen: "S" 
 -- ObjectInvocation:markForCodeGen: "S"  ATd: "S: ref Scheduler" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "Scheduler" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Scheduler" 
 -- "Scheduler" false 
 -- 
 -- OG:markSuper: "Scheduler" 
 -- Invocation:markForCodeGen: "Scheduler" 
 -- ObjectInvocation:markForCodeGen: "Scheduler"  ATd: "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Scheduler"  IS.isEmpty:  true 
 -- markItem: "C3.attach(S)" ObjectGenerator 
 -- OG:markForCodeGen: "C3.attach(S)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "C3.attach(S)" 
 -- "C3" false 
 -- "attach(S)" false 
 -- 
 -- OG:markSuper: "C3.attach(S)" 
 -- Invocation:markForCodeGen: "C3.attach(S)" 
 -- ObjectInvocation:markForCodeGen: "C3"  ATd: "C3: ref Core" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "attach(S)"  ATd: "attach: {   in M: ref Scheduler;   main := M}" 
 -- OI:args:markForCodgen: "attach(S)" 
 -- OG:markForCodeGen: "S" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "S" 
 -- "S" false 
 -- 
 -- arg:   "S" 
 -- not ObjDesc:  "C3.attach(S)"  IS.isEmpty:  true 
 -- markItem: "C4.attach(Scheduler)" ObjectGenerator 
 -- OG:markForCodeGen: "C4.attach(Scheduler)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "C4.attach(Scheduler)" 
 -- "C4" false 
 -- "attach(Scheduler)" false 
 -- 
 -- OG:markSuper: "C4.attach(Scheduler)" 
 -- Invocation:markForCodeGen: "C4.attach(Scheduler)" 
 -- ObjectInvocation:markForCodeGen: "C4"  ATd: "C4: ref Core{-- should be array         }" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "attach(Scheduler)"  ATd: "attach: {   in M: ref Scheduler;   main := M}" 
 -- OI:args:markForCodgen: "attach(Scheduler)" 
 -- OG:markForCodeGen: "Scheduler" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Scheduler" 
 -- "Scheduler" false 
 -- 
 -- OG:markSuper: "Scheduler" 
 -- Invocation:markForCodeGen: "Scheduler" 
 -- ObjectInvocation:markForCodeGen: "Scheduler"  ATd: "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Scheduler"  IS.isEmpty:  true 
 -- arg:   "Scheduler" 
 -- not ObjDesc:  "C4.attach(Scheduler)"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "cores.init"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "LIB.BasicSystemLib.BasicSystem{   %public;   MonitorProcess: BasicProcess;      %globals Monitor, MonitorProcess(""), immutable, console;      -- we need to fi ...}" 
 -- OG:Qalloc: "LIB.BasicSystemLib.BasicSystem{   %public;   MonitorProcess: BasicProcess;      %globals Monitor, MonitorProcess(""), immutable, console;      -- we need to fi ...}" q ... 0 
 -- OG:Qalloc:A:  "MonitorSystem"  super:  "LIB.BasicSystemLib.BasicSystem"  marked:  true "MonitorSystem: LIB.BasicSystemLib.BasicSystem{   %public;   MonitorProcess: BasicPr ...}" s ... L ... 
 -- Invocation:Qalloc: "LIB.BasicSystemLib.BasicSystem" 
 -- ObjectInvocation:Qalloc: "LIB" 
 -- name: "LIB" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "BasicSystemLib" 
 -- name: "BasicSystemLib" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "BasicSystem" 
 -- name: "BasicSystem" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  72 9 %public{BasicProcess: GeneralProcess;   mkActive::< ;      -- start and mkActive are identical and one may be elim ...} 
 -- OG:super:  "BasicSystem: {   %public;   BasicProcess: GeneralProcess;      mkActive::< ;         -- start and mkActive are identical and one may be eliminatedstatus := p_s ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "LIB.BasicSystemLib.BasicSystem{   %public;   MonitorProcess: BasicProcess;      %globals Monitor, MonitorProcess(""), immutable, console;      -- we need to find out how  ...}" 
 -- super:  "LIB.BasicSystemLib.BasicSystem" 
 -- E:  "BasicSystem" 
 -- OG:Qalloc:B: "MonitorSystem" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 188 IS.newDescNo: 188 objSize: 0 1: 1 "%public{MonitorProcess: BasicProcess;   %globals Monitor, MonitorProcess(""), immutable, console;   -- we ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 188 "%public{MonitorProcess: BasicProcess;   %globals Monitor, MonitorProcess(""), immutable, console;   -- we need to find out how to  ...}" 
 -- Items:Qalloc:super: "LIB.BasicSystemLib.BasicSystem" size: 9 "MonitorSystem" 
 -- super.isThisBlockLevel: false superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 10 originOff: 10 
 -- Items:Qalloc:objSize: 10  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 10  newDescNo: 0 "" 
 -- Pattern:Qalloc: MonitorProcess 
 -- Pattern:Qalloc:B: MonitorProcess 
 -- Pattern:Qalloc: ExtendedMonitorProcess 
 -- Pattern:Qalloc:B: ExtendedMonitorProcess 
 -- Pattern:Qalloc: Monitor 
 -- Pattern:Qalloc:B: Monitor 
 -- OG:Qalloc: "inner(MonitorSystem)" qDescno:  0 
 -- OG:Qalloc:A:  "inner"  super:  "inner(MonitorSystem)"  marked:  false "%public{MonitorProcess: BasicProcess;   %globals Monitor, MonitorProcess(""), immutable, console;    ...}" s ... i ... 
 -- Invocation:Qalloc: "inner(MonitorSystem)" 
 -- ObjectInvocation:Qalloc: "inner(MonitorSystem)" 
 -- name: "inner" 
 -- Arguments "inner(MonitorSystem)" 
 -- OG:Qalloc: "MonitorSystem" qDescno:  0 
 -- OG:Qalloc:A:  "MonitorSystem"  super:  "MonitorSystem"  marked:  false "inner(MonitorSystem)" super:  MonitorSystem 
 -- Invocation:Qalloc: "MonitorSystem" 
 -- ObjectInvocation:Qalloc: "MonitorSystem" 
 -- name: "MonitorSystem" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  188 10 %public{MonitorProcess: BasicProcess;   %globals Monitor, MonitorProcess(""), immutable, console;   -- we need t ...} 
 -- OG:super:  "MonitorSystem: LIB.BasicSystemLib.BasicSystem{   %public;   MonitorProcess: BasicProcess;      %globals Monitor, MonitorProcess(""), immutable, console;      - ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "MonitorSystem" 
 -- super:  "MonitorSystem" 
 -- E:  "MonitorSystem" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "MonitorSystem" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 %basic 101{in inner: ref Object} 
 -- OG:super:  "inner: {   %basic 101;   in inner: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(MonitorSystem)" 
 -- super:  "inner(MonitorSystem)" 
 -- E:  "inner(MonitorSystem)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(MonitorSystem)" 
 -- Items:Qalloc:END:objSize: 10  newDescNo: 188 "%public{MonitorProcess: BasicProcess;   %globals Monitor, MonitorProcess(""), immutable, console;   -- we need to find out ho ...}" 
 -- IS.newDescNo: 188 IS.objSize: 10 "%public{MonitorProcess: BasicProcess;   %globals Monitor, MonitorProcess(""), immutable, console;   -- we need to find out how to restric ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  188 "LIB.BasicSystemLib.BasicSystem{   %public;   MonitorProcess: BasicProcess;      %globals Monitor, MonitorProcess(""), immutable, console ...}" 
 -- ObjTmpStack:add: "MonitorSystem" : "LIB.BasicSystemLib.BasicSystem{   %public;   MonitorProcess: BasicProcess;      %globals Monitor, MonitorProcess(""), immutable, consol ...}" 
 -- items:markForCodeGen: "%public{MonitorProcess: BasicProcess;   %globals Monitor, MonitorProcess(""), immutable, console;   -- we need to find out how to restrict Process t ...}" 
 -- markItem: "%public" Property 
 -- markItem: "inner(MonitorSystem)" ObjectGenerator 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "LIB.MonitorSystemLib.MonitorSystem{   %requires MonitorSystemLib;   %include LIB.StringLib;   P1: obj MonitorProcess("PP1");      fac(V: var integer): ;        ...}" 
 -- OG:Qalloc: "LIB.MonitorSystemLib.MonitorSystem{   %requires MonitorSystemLib;   %include LIB.StringLib;   P1: obj MonitorProcess("PP1");      fac(V: var integer): ;        ...}" q ... 0 
 -- OG:Qalloc:A:  "MonitorDemo"  super:  "LIB.MonitorSystemLib.MonitorSystem"  marked:  true "MonitorDemo: obj LIB.MonitorSystemLib.MonitorSystem{   %requires MonitorSystemLib ...}" s ... L ... 
 -- Invocation:Qalloc: "LIB.MonitorSystemLib.MonitorSystem" 
 -- ObjectInvocation:Qalloc: "LIB" 
 -- name: "LIB" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "MonitorSystemLib" 
 -- name: "MonitorSystemLib" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "MonitorSystem" 
 -- name: "MonitorSystem" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  188 10 %public{MonitorProcess: BasicProcess;   %globals Monitor, MonitorProcess(""), immutable, console;   -- we need t ...} 
 -- OG:super:  "MonitorSystem: LIB.BasicSystemLib.BasicSystem{   %public;   MonitorProcess: BasicProcess;      %globals Monitor, MonitorProcess(""), immutable, console;      - ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "LIB.MonitorSystemLib.MonitorSystem{   %requires MonitorSystemLib;   %include LIB.StringLib;   P1: obj MonitorProcess("PP1");      fac(V: var integer): ;         out res:  ...}" 
 -- super:  "LIB.MonitorSystemLib.MonitorSystem" 
 -- E:  "MonitorSystem" 
 -- OG:Qalloc:B: "MonitorDemo" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 189 IS.newDescNo: 189 objSize: 0 1: 1 "%requires MonitorSystemLib{%include LIB.StringLib;P1: obj MonitorProcess("PP1");   fac(V: var integer): ; ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 189 "%requires MonitorSystemLib{%include LIB.StringLib;P1: obj MonitorProcess("PP1");   fac(V: var integer): ;      out res: var intege ...}" 
 -- Items:Qalloc:super: "LIB.MonitorSystemLib.MonitorSystem" size: 10 "MonitorDemo" 
 -- super.isThisBlockLevel: false superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 11 originOff: 11 
 -- dataitem:qalloc: "P1" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 12 "P1: obj MonitorProcess("PP1"){   fac(V: var integer): ;      out res: var integer;      if (V = 1) :then ;         res := 1;      :else ;         res := ...}" 
 -- OG:Qalloc: "MonitorProcess("PP1"){   fac(V: var integer): ;      out res: var integer;      if (V = 1) :then ;         res := 1;      :else ;         res := V * fac(V - 1) ...}" q ... 0 
 -- OG:Qalloc:A:  "P1"  super:  "MonitorProcess("PP1")"  marked:  false "P1: obj MonitorProcess("PP1"){   fac(V: var integer): ;      out res: var integer;      if (V = 1) :th ...}" s ... M ... 
 -- Invocation:Qalloc: "MonitorProcess("PP1")" 
 -- ObjectInvocation:Qalloc: "MonitorProcess("PP1")" 
 -- name: "MonitorProcess" 
 -- Arguments "MonitorProcess("PP1")" 
 -- OG:Qalloc: ""PP1"" qDescno:  0 
 -- OG:Qalloc:A:  "String"  super:  ""PP1""  marked:  false "MonitorProcess("PP1")" super:  "PP1" 
 -- Invocation:Qalloc: ""PP1"" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  10 0 %id "String pattern"{%OSDvisibility disguised;%basic 5;%public;length: ;   out V: var integer;   V := get[0] -- ac ...} 
 -- OG:super:  "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- actually an  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""PP1"" 
 -- super:  ""PP1"" 
 -- E:  ""PP1"" 
 -- OG:Qalloc:end: IS.newDescNo:  0 ""PP1"" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %globals Monitor, MonitorProcess(""), immutable, console{-- we need to find out how to restrict Process to have no; ...} 
 -- OG:Qalloc:SuperAlloc: "MonitorProcess: BasicProcess{   %globals Monitor, MonitorProcess(""), immutable, console;   -- we need to find out how to restrict Process to have n ...}" 
 -- OG:Qalloc: "BasicProcess{   %globals Monitor, MonitorProcess(""), immutable, console;   -- we need to find out how to restrict Process to have no;   -- visible interface.  ...}" q ... 0 
 -- OG:Qalloc:A:  "MonitorProcess"  super:  "BasicProcess"  marked:  false "MonitorProcess: BasicProcess{   %globals Monitor, MonitorProcess(""), immutable, console;   -- we n ...}" s ... B ... 
 -- Invocation:Qalloc: "BasicProcess" 
 -- ObjectInvocation:Qalloc: "BasicProcess" 
 -- name: "BasicProcess" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  83 4 mkActive::< {   -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;   SQS.inse ...} 
 -- OG:super:  "BasicProcess: GeneralProcess{   mkActive::< ;      -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;      SQS.insert(this ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "BasicProcess{   %globals Monitor, MonitorProcess(""), immutable, console;   -- we need to find out how to restrict Process to have no;   -- visible interface. Perhaps ret ...}" 
 -- super:  "BasicProcess" 
 -- E:  "BasicProcess" 
 -- OG:Qalloc:B: "MonitorProcess" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 190 IS.newDescNo: 190 objSize: 0 1: 1 "%globals Monitor, MonitorProcess(""), immutable, console{-- we need to find out how to restrict Process t ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 190 "%globals Monitor, MonitorProcess(""), immutable, console{-- we need to find out how to restrict Process to have no;-- visible inte ...}" 
 -- Items:Qalloc:super: "BasicProcess" size: 4 "MonitorProcess" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 4 originOff: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- Pattern:Qalloc: start 
 -- Pattern:Qalloc:B: start 
 -- OG:Qalloc: "inner(MonitorProcess)" qDescno:  0 
 -- OG:Qalloc:A:  "inner"  super:  "inner(MonitorProcess)"  marked:  false "%globals Monitor, MonitorProcess(""), immutable, console{-- we need to find out how to restrict Pro ...}" s ... i ... 
 -- Invocation:Qalloc: "inner(MonitorProcess)" 
 -- ObjectInvocation:Qalloc: "inner(MonitorProcess)" 
 -- name: "inner" 
 -- Arguments "inner(MonitorProcess)" 
 -- OG:Qalloc: "MonitorProcess" qDescno:  0 
 -- OG:Qalloc:A:  "MonitorProcess"  super:  "MonitorProcess"  marked:  false "inner(MonitorProcess)" super:  MonitorProcess 
 -- Invocation:Qalloc: "MonitorProcess" 
 -- ObjectInvocation:Qalloc: "MonitorProcess" 
 -- name: "MonitorProcess" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  190 4 %globals Monitor, MonitorProcess(""), immutable, console{-- we need to find out how to restrict Process to have n ...} 
 -- OG:super:  "MonitorProcess: BasicProcess{   %globals Monitor, MonitorProcess(""), immutable, console;   -- we need to find out how to restrict Process to have no;   -- vis ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "MonitorProcess" 
 -- super:  "MonitorProcess" 
 -- E:  "MonitorProcess" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "MonitorProcess" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 %basic 101{in inner: ref Object} 
 -- OG:super:  "inner: {   %basic 101;   in inner: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(MonitorProcess)" 
 -- super:  "inner(MonitorProcess)" 
 -- E:  "inner(MonitorProcess)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(MonitorProcess)" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 190 "%globals Monitor, MonitorProcess(""), immutable, console{-- we need to find out how to restrict Process to have no;-- visible  ...}" 
 -- IS.newDescNo: 190 IS.objSize: 4 "%globals Monitor, MonitorProcess(""), immutable, console{-- we need to find out how to restrict Process to have no;-- visible interface. P ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  190 "BasicProcess{   %globals Monitor, MonitorProcess(""), immutable, console;   -- we need to find out how to restrict Process to have no;   ...}" 
 -- OG:super:  "MonitorProcess: BasicProcess{   %globals Monitor, MonitorProcess(""), immutable, console;   -- we need to find out how to restrict Process to have no;   -- vis ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "MonitorProcess("PP1"){   fac(V: var integer): ;      out res: var integer;      if (V = 1) :then ;         res := 1;      :else ;         res := V * fac(V - 1);   myM.pri ...}" 
 -- super:  "MonitorProcess("PP1")" 
 -- E:  "MonitorProcess("PP1")" 
 -- OG:Qalloc:B: "P1" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 191 IS.newDescNo: 191 objSize: 0 1: 1 "fac(V: var integer): {   out res: var integer;   if (V = 1) :then ;      res := 1;   :else ;      res :=  ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 191 "fac(V: var integer): {   out res: var integer;   if (V = 1) :then ;      res := 1;   :else ;      res := V * fac(V - 1);myM.print( ...}" 
 -- Items:Qalloc:super: "MonitorProcess("PP1")" size: 4 "P1" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 4 originOff: 4 
 -- Pattern:Qalloc: fac 
 -- Pattern:Qalloc:B: fac 
 -- OG:Qalloc: "myM.print("P1 resumed\n")" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "myM.print("P1 resumed\n")"  marked:  false "fac(V: var integer): {   out res: var integer;   if (V = 1) :then ;      res := 1;   :else ;    ...}" s ... m ... 
 -- Invocation:Qalloc: "myM.print("P1 resumed\n")" 
 -- ObjectInvocation:Qalloc: "myM" 
 -- name: "myM" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "print("P1 resumed\n")" 
 -- name: "print" 
 -- Arguments "print("P1 resumed\n")" 
 -- OG:Qalloc: ""P1 resumed\n"" qDescno:  0 
 -- OG:Qalloc:A:  "String"  super:  ""P1 resumed\n""  marked:  false "print("P1 resumed\n")" super:  "P1 resumed\n" 
 -- Invocation:Qalloc: ""P1 resumed\n"" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  10 0 %id "String pattern"{%OSDvisibility disguised;%basic 5;%public;length: ;   out V: var integer;   V := get[0] -- ac ...} 
 -- OG:super:  "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- actually an  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""P1 resumed\n"" 
 -- super:  ""P1 resumed\n"" 
 -- E:  ""P1 resumed\n"" 
 -- OG:Qalloc:end: IS.newDescNo:  0 ""P1 resumed\n"" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 S.print 
 -- OG:Qalloc:SuperAlloc: "print(S: var String): entry{   S.print}" 
 -- OG:Qalloc: "entry{   S.print}" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "entry"  marked:  false "print(S: var String): entry{   S.print}" super:  entry 
 -- Invocation:Qalloc: "entry" 
 -- ObjectInvocation:Qalloc: "entry" 
 -- name: "entry" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %kind method{%arguments value, immutable;mutex.wait;_V := _V + 1;inner(entry);mutex.signal} 
 -- OG:Qalloc:SuperAlloc: "entry: {   %kind method;   %arguments value, immutable;   mutex.wait;   _V := _V + 1;   inner(entry);   mutex.signal}" 
 -- OG:Qalloc: "%kind method{   %arguments value, immutable;   mutex.wait;   _V := _V + 1;   inner(entry);   mutex.signal}" qDescno:  0 
 -- OG:Qalloc:A:  "entry"  super:  ""  marked:  false "entry: {   %kind method;   %arguments value, immutable;   mutex.wait;   _V := _V + 1;   inner(entry);   mutex.signal}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%kind method{   %arguments value, immutable;   mutex.wait;   _V := _V + 1;   inner(entry);   mutex.signal}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "entry" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 192 IS.newDescNo: 192 objSize: 0 1: 1 "%kind method{%arguments value, immutable;mutex.wait;_V := _V + 1;inner(entry);mutex.signal}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 192 "%kind method{%arguments value, immutable;mutex.wait;_V := _V + 1;inner(entry);mutex.signal}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- OG:Qalloc: "mutex.wait" qDescno:  0 
 -- OG:Qalloc:A:  "wait"  super:  "mutex.wait"  marked:  false "%kind method{%arguments value, immutable;mutex.wait;_V := _V + 1;inner(entry);mutex.signal}" super:  mutex.wait ... 
 -- Invocation:Qalloc: "mutex.wait" 
 -- ObjectInvocation:Qalloc: "mutex" 
 -- name: "mutex" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "wait" 
 -- name: "wait" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 theActive: ref GeneralProcess{M.get;cnt := cnt - 1;if (cnt < 0) :then ;   disable;   theActive := thisCore.main.act ...} 
 -- OG:Qalloc:SuperAlloc: "wait: {   theActive: ref GeneralProcess;   M.get;   cnt := cnt - 1;   if (cnt < 0) :then ;      disable;      theActive := thisCore.main.active;     ...}" 
 -- OG:Qalloc: "theActive: ref GeneralProcess{   M.get;   cnt := cnt - 1;   if (cnt < 0) :then ;      disable;      theActive := thisCore.main.active;      Q.insert(theActive) ...}" q ... 0 
 -- OG:Qalloc:A:  "wait"  super:  ""  marked:  false "wait: {   theActive: ref GeneralProcess;   M.get;   cnt := cnt - 1;   if (cnt < 0) :then ;      disable;      theActive : ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "theActive: ref GeneralProcess{   M.get;   cnt := cnt - 1;   if (cnt < 0) :then ;      disable;      theActive := thisCore.main.active;      Q.insert(theActive);      enab ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "wait" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 193 IS.newDescNo: 193 objSize: 0 1: 1 "theActive: ref GeneralProcess{M.get;cnt := cnt - 1;if (cnt < 0) :then ;   disable;   theActive := thisCor ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 193 "theActive: ref GeneralProcess{M.get;cnt := cnt - 1;if (cnt < 0) :then ;   disable;   theActive := thisCore.main.active;   Q.insert ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "theActive" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "theActive: ref GeneralProcess" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- OG:Qalloc: "M.get" qDescno:  0 
 -- OG:Qalloc:A:  "get"  super:  "M.get"  marked:  false "theActive: ref GeneralProcess{M.get;cnt := cnt - 1;if (cnt < 0) :then ;   disable;   theActive := thisCore.main.activ ...}" s ... M ... 
 -- Invocation:Qalloc: "M.get" 
 -- ObjectInvocation:Qalloc: "M" 
 -- name: "M" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "get" 
 -- name: "get" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  96 2 loop: obj {   res: var integer;   i: var integer;   --disable;   res := free_M.cmpAndSwap(1);   if (res = 1) :then ...} 
 -- OG:super:  "get: {   loop: obj ;      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);      if (res = 1) :then ;         --enablesl ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "M.get" 
 -- super:  "M.get" 
 -- E:  "get" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "M.get" 
 -- Invocation:Qalloc: "cnt" 
 -- ObjectInvocation:Qalloc: "cnt" 
 -- name: "cnt" 
 -- Arguments "" 
 -- OG:Qalloc: "cnt - 1" qDescno:  0 
 -- OG:Qalloc:A:  "-"  super:  "cnt - 1"  marked:  false "cnt := cnt - 1" super:  cnt - 1 
 -- Invocation:Qalloc: "cnt - 1" 
 -- BinaryExp:Qalloc: "cnt - 1" 
 -- Invocation:Qalloc: "cnt" 
 -- ObjectInvocation:Qalloc: "cnt" 
 -- name: "cnt" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "- 1" 
 -- name: "-" 
 -- Arguments "1" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "1" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  108 5 %basic 62{in V: var integer;out R: var integer} 
 -- OG:super:  "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "cnt - 1" 
 -- super:  "cnt - 1" 
 -- E:  "cnt - 1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "cnt - 1" 
 -- OG:Qalloc: "if (cnt < 0) :then {   disable;   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive.addWaiting -- sets status = WAITING ...}" q ... 0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (cnt < 0) :then {   disable;   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive.addWaiting  ...}"   ... false "t ..." s ... i ... 
 -- Invocation:Qalloc: "if (cnt < 0) :then {   disable;   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive.addWaiting -- sets status = ...}" 
 -- OG:Qalloc: "(cnt < 0)" qDescno:  0 
 -- OG:Qalloc:A:  "<"  super:  "(cnt < 0)"  marked:  false "if (cnt < 0) :then {   disable;   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   t ...}" s ... ( ... 
 -- Invocation:Qalloc: "(cnt < 0)" 
 -- Invocation:Qalloc: "cnt < 0" 
 -- BinaryExp:Qalloc: "cnt < 0" 
 -- Invocation:Qalloc: "cnt" 
 -- ObjectInvocation:Qalloc: "cnt" 
 -- name: "cnt" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "< 0" 
 -- name: "<" 
 -- Arguments "0" 
 -- OG:Qalloc: "0" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "0"  marked:  false "0" super:  0 
 -- Invocation:Qalloc: "0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "0" 
 -- super:  "0" 
 -- E:  "0" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  54 5 %basic 51{in V: var integer;out B: var boolean} 
 -- OG:super:  "<  : {   %basic 51;   in V: var integer;   out B: var boolean}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(cnt < 0)" 
 -- super:  "(cnt < 0)" 
 -- E:  "(cnt < 0)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(cnt < 0)" 
 -- OG:Qalloc: "disable{   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive.addWaiting -- sets status = WAITING;   theActive.suspend}" q ... 0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (cnt < 0) :then {   disable;   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "disable{   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive.addWaiting -- sets status = WAITING;   theActive.suspend}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 194 IS.newDescNo: 194 objSize: 0 1: 1 "disable{theActive := thisCore.main.active;Q.insert(theActive);enable;M.free;theActive.addWaiting -- sets  ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 194 "disable{theActive := thisCore.main.active;Q.insert(theActive);enable;M.free;theActive.addWaiting -- sets status = WAITING;theActiv ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: "disable" qDescno:  0 
 -- OG:Qalloc:A:  "disable"  super:  "disable"  marked:  false "disable{theActive := thisCore.main.active;Q.insert(theActive);enable;M.free;theActive.addWaiting -- sets status ...}" s ... d ... 
 -- Invocation:Qalloc: "disable" 
 -- ObjectInvocation:Qalloc: "disable" 
 -- name: "disable" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 11 
 -- OG:Qalloc:SuperAlloc: "disable: {   %basic 11}" 
 -- OG:Qalloc: "%basic 11" qDescno:  0 
 -- OG:Qalloc:A:  "disable"  super:  ""  marked:  false "disable: {   %basic 11}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 11" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "disable" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 195 IS.newDescNo: 195 objSize: 0 1: 1 "%basic 11" 
 -- Items:Qalloc:objSize: 0  newDescNo: 195 "%basic 11" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 195 "%basic 11" 
 -- IS.newDescNo: 195 IS.objSize: 1 "%basic 11" 
 -- OG:Qalloc:end: IS.newDescNo:  195 "%basic 11" 
 -- OG:super:  "disable: {   %basic 11}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "disable" 
 -- super:  "disable" 
 -- E:  "disable" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "disable" 
 -- Invocation:Qalloc: "theActive" 
 -- ObjectInvocation:Qalloc: "theActive" 
 -- name: "theActive" 
 -- Arguments "" 
 -- OG:Qalloc: "thisCore.main.active" qDescno:  0 
 -- OG:Qalloc:A:  "GeneralProcess"  super:  "thisCore.main.active"  marked:  false "theActive := thisCore.main.active" super:  thisCore.main.active 
 -- Invocation:Qalloc: "thisCore.main.active" 
 -- ObjectInvocation:Qalloc: "thisCore" 
 -- name: "thisCore" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "main" 
 -- name: "main" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "active" 
 -- name: "active" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  82 3 start:< {   inner(start);mkActive:< ;   inner(mkActive);addWaiting:< ;   --put('q')inner(addWaiting);   --put('R') ...} 
 -- OG:super:  "active: ref ProcessType" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "thisCore.main.active" 
 -- super:  "thisCore.main.active" 
 -- E:  "active" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "thisCore.main.active" 
 -- OG:Qalloc: "Q.insert(theActive)" qDescno:  0 
 -- OG:Qalloc:A:  "insert"  super:  "Q.insert(theActive)"  marked:  false "disable{theActive := thisCore.main.active;Q.insert(theActive);enable;M.free;theActive.addWaiting --  ...}" s ... Q ... 
 -- Invocation:Qalloc: "Q.insert(theActive)" 
 -- ObjectInvocation:Qalloc: "Q" 
 -- name: "Q" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "insert(theActive)" 
 -- name: "insert" 
 -- Arguments "insert(theActive)" 
 -- OG:Qalloc: "theActive" qDescno:  0 
 -- OG:Qalloc:A:  "GeneralProcess"  super:  "theActive"  marked:  false "insert(theActive)" super:  theActive 
 -- Invocation:Qalloc: "theActive" 
 -- ObjectInvocation:Qalloc: "theActive" 
 -- name: "theActive" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  82 3 start:< {   inner(start);mkActive:< ;   inner(mkActive);addWaiting:< ;   --put('q')inner(addWaiting);   --put('R') ...} 
 -- OG:super:  "theActive: ref GeneralProcess" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "theActive" 
 -- super:  "theActive" 
 -- E:  "theActive" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "theActive" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  142 4 in elm: ref Object{E: ref Element;b: var BOOLEAN;B := ELM =/= NONE;--if (has(elm)) :then;--    "insert:leave\n".p ...} 
 -- OG:super:  "insert: {   in elm: ref Object;   E: ref Element;   b: var BOOLEAN;   B := ELM =/= NONE;   --if (has(elm)) :then;   --    "insert:leave\n".print;   --    leave ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Q.insert(theActive)" 
 -- super:  "Q.insert(theActive)" 
 -- E:  "insert(theActive)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Q.insert(theActive)" 
 -- OG:Qalloc: "enable" qDescno:  0 
 -- OG:Qalloc:A:  "enable"  super:  "enable"  marked:  false "disable{theActive := thisCore.main.active;Q.insert(theActive);enable;M.free;theActive.addWaiting -- sets status = ...}" s ... e ... 
 -- Invocation:Qalloc: "enable" 
 -- ObjectInvocation:Qalloc: "enable" 
 -- name: "enable" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 12 
 -- OG:Qalloc:SuperAlloc: "enable: {   %basic 12}" 
 -- OG:Qalloc: "%basic 12" qDescno:  0 
 -- OG:Qalloc:A:  "enable"  super:  ""  marked:  false "enable: {   %basic 12}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 12" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "enable" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 196 IS.newDescNo: 196 objSize: 0 1: 1 "%basic 12" 
 -- Items:Qalloc:objSize: 0  newDescNo: 196 "%basic 12" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 196 "%basic 12" 
 -- IS.newDescNo: 196 IS.objSize: 1 "%basic 12" 
 -- OG:Qalloc:end: IS.newDescNo:  196 "%basic 12" 
 -- OG:super:  "enable: {   %basic 12}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "enable" 
 -- super:  "enable" 
 -- E:  "enable" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "enable" 
 -- OG:Qalloc: "M.free" qDescno:  0 
 -- OG:Qalloc:A:  "free"  super:  "M.free"  marked:  false "disable{theActive := thisCore.main.active;Q.insert(theActive);enable;M.free;theActive.addWaiting -- sets status = W ...}" s ... M ... 
 -- Invocation:Qalloc: "M.free" 
 -- ObjectInvocation:Qalloc: "M" 
 -- name: "M" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "free" 
 -- name: "free" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  109 1 free_M := 0 
 -- OG:super:  "free: {   free_M := 0}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "M.free" 
 -- super:  "M.free" 
 -- E:  "free" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "M.free" 
 -- OG:Qalloc: "theActive.addWaiting -- sets status = WAITING" qDescno:  0 
 -- OG:Qalloc:A:  "addWaiting"  super:  "theActive.addWaiting -- sets status = WAITING"  marked:  false "disable{theActive := thisCore.main.active;Q.insert(theActive);enable;M ...}" s ... t ... 
 -- Invocation:Qalloc: "theActive.addWaiting -- sets status = WAITING" 
 -- ObjectInvocation:Qalloc: "theActive" 
 -- name: "theActive" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "addWaiting -- sets status = WAITING" 
 -- name: "addWaiting" 
 -- Arguments "-- sets status = WAITING" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  134 1 --put('q')inner(addWaiting){--put('R')} 
 -- OG:super:  "addWaiting:< {   --put('q')inner(addWaiting);   --put('R')}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "theActive.addWaiting -- sets status = WAITING" 
 -- super:  "theActive.addWaiting -- sets status = WAITING" 
 -- E:  "addWaiting -- sets status = WAITING" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "theActive.addWaiting -- sets status = WAITING" 
 -- OG:Qalloc: "theActive.suspend" qDescno:  0 
 -- OG:Qalloc:A:  "suspend"  super:  "theActive.suspend"  marked:  false "disable{theActive := thisCore.main.active;Q.insert(theActive);enable;M.free;theActive.addWaiting -- s ...}" s ... t ... 
 -- Invocation:Qalloc: "theActive.suspend" 
 -- ObjectInvocation:Qalloc: "theActive" 
 -- name: "theActive" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "suspend" 
 -- name: "suspend" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  84 1 %basic 111 
 -- OG:super:  "suspend: {   %basic 111}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "theActive.suspend" 
 -- super:  "theActive.suspend" 
 -- E:  "suspend" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "theActive.suspend" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 194 "disable{theActive := thisCore.main.active;Q.insert(theActive);enable;M.free;theActive.addWaiting -- sets status = WAITING;theA ...}" 
 -- IS.newDescNo: 194 IS.objSize: 1 "disable{theActive := thisCore.main.active;Q.insert(theActive);enable;M.free;theActive.addWaiting -- sets status = WAITING;theActive.suspen ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  194 "disable{   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive.addWaiting -- sets status = WAITING ...}" 
 -- OG:Qalloc: "M.free" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (cnt < 0) :then {   disable;   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "M.free" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 197 IS.newDescNo: 197 objSize: 0 1: 1 "M.free" 
 -- Items:Qalloc:objSize: 0  newDescNo: 197 "M.free" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: "M.free" qDescno:  0 
 -- OG:Qalloc:A:  "free"  super:  "M.free"  marked:  false "M.free" super:  M.free 
 -- Invocation:Qalloc: "M.free" 
 -- ObjectInvocation:Qalloc: "M" 
 -- name: "M" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "free" 
 -- name: "free" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  109 1 free_M := 0 
 -- OG:super:  "free: {   free_M := 0}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "M.free" 
 -- super:  "M.free" 
 -- E:  "free" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "M.free" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 197 "M.free" 
 -- IS.newDescNo: 197 IS.objSize: 1 "M.free" 
 -- OG:Qalloc:end: IS.newDescNo:  197 "M.free" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (cnt < 0) :then {   disable;   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive.addWaiting -- sets status = WAITING;   theActi ...}" 
 -- super:  "if (cnt < 0) :then {   disable;   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive.addWaiting -- sets status = WAITING;   ...}" 
 -- E:  "if (cnt < 0) :then {   disable;   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive.addWaiting -- sets status = WAITING;   the ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (cnt < 0) :then {   disable;   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive.addWaiting --  ...}" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 193 "theActive: ref GeneralProcess{M.get;cnt := cnt - 1;if (cnt < 0) :then ;   disable;   theActive := thisCore.main.active;   Q.in ...}" 
 -- IS.newDescNo: 193 IS.objSize: 2 "theActive: ref GeneralProcess{M.get;cnt := cnt - 1;if (cnt < 0) :then ;   disable;   theActive := thisCore.main.active;   Q.insert(theActi ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  193 "theActive: ref GeneralProcess{   M.get;   cnt := cnt - 1;   if (cnt < 0) :then ;      disable;      theActive := thisCore.main.active;   ...}" 
 -- OG:super:  "wait: {   theActive: ref GeneralProcess;   M.get;   cnt := cnt - 1;   if (cnt < 0) :then ;      disable;      theActive := thisCore.main.active;      Q.insert( ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "mutex.wait" 
 -- super:  "mutex.wait" 
 -- E:  "wait" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "mutex.wait" 
 -- Invocation:Qalloc: "_V" 
 -- ObjectInvocation:Qalloc: "_V" 
 -- name: "_V" 
 -- Arguments "" 
 -- OG:Qalloc: "_V + 1" qDescno:  0 
 -- OG:Qalloc:A:  "+"  super:  "_V + 1"  marked:  false "_V := _V + 1" super:  _V + 1 
 -- Invocation:Qalloc: "_V + 1" 
 -- BinaryExp:Qalloc: "_V + 1" 
 -- Invocation:Qalloc: "_V" 
 -- ObjectInvocation:Qalloc: "_V" 
 -- name: "_V" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "+ 1" 
 -- name: "+" 
 -- Arguments "1" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "1" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  49 5 %basic 61{in V: var integer;out R: var integer} 
 -- OG:super:  "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "_V + 1" 
 -- super:  "_V + 1" 
 -- E:  "_V + 1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "_V + 1" 
 -- OG:Qalloc: "inner(entry)" qDescno:  0 
 -- OG:Qalloc:A:  "inner"  super:  "inner(entry)"  marked:  false "%kind method{%arguments value, immutable;mutex.wait;_V := _V + 1;inner(entry);mutex.signal}" super:  inner(e ... 
 -- Invocation:Qalloc: "inner(entry)" 
 -- ObjectInvocation:Qalloc: "inner(entry)" 
 -- name: "inner" 
 -- Arguments "inner(entry)" 
 -- OG:Qalloc: "entry" qDescno:  0 
 -- OG:Qalloc:A:  "entry"  super:  "entry"  marked:  false "inner(entry)" super:  entry 
 -- Invocation:Qalloc: "entry" 
 -- ObjectInvocation:Qalloc: "entry" 
 -- name: "entry" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  192 1 %kind method{%arguments value, immutable;mutex.wait;_V := _V + 1;inner(entry);mutex.signal} 
 -- OG:super:  "entry: {   %kind method;   %arguments value, immutable;   mutex.wait;   _V := _V + 1;   inner(entry);   mutex.signal}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "entry" 
 -- super:  "entry" 
 -- E:  "entry" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "entry" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 %basic 101{in inner: ref Object} 
 -- OG:super:  "inner: {   %basic 101;   in inner: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(entry)" 
 -- super:  "inner(entry)" 
 -- E:  "inner(entry)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(entry)" 
 -- OG:Qalloc: "mutex.signal" qDescno:  0 
 -- OG:Qalloc:A:  "signal"  super:  "mutex.signal"  marked:  false "%kind method{%arguments value, immutable;mutex.wait;_V := _V + 1;inner(entry);mutex.signal}" super:  mutex. ... 
 -- Invocation:Qalloc: "mutex.signal" 
 -- ObjectInvocation:Qalloc: "mutex" 
 -- name: "mutex" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "signal" 
 -- name: "signal" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 P: ref GeneralProcess{M.get;cnt := cnt + 1;if (cnt <= 0) :then ;   disable;   P := Q.removeNext;   P.mkActive;   -- ...} 
 -- OG:Qalloc:SuperAlloc: "signal: {   P: ref GeneralProcess;   M.get;   cnt := cnt + 1;   if (cnt <= 0) :then ;      disable;      P := Q.removeNext;      P.mkActive;      -- ...}" 
 -- OG:Qalloc: "P: ref GeneralProcess{   M.get;   cnt := cnt + 1;   if (cnt <= 0) :then ;      disable;      P := Q.removeNext;      P.mkActive;      --P.dcrWaiting -- SQS.dcr ...}" q ... 0 
 -- OG:Qalloc:A:  "signal"  super:  ""  marked:  false "signal: {   P: ref GeneralProcess;   M.get;   cnt := cnt + 1;   if (cnt <= 0) :then ;      disable;      P := Q.removeN ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "P: ref GeneralProcess{   M.get;   cnt := cnt + 1;   if (cnt <= 0) :then ;      disable;      P := Q.removeNext;      P.mkActive;      --P.dcrWaiting -- SQS.dcrWaiting;    ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "signal" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 198 IS.newDescNo: 198 objSize: 0 1: 1 "P: ref GeneralProcess{M.get;cnt := cnt + 1;if (cnt <= 0) :then ;   disable;   P := Q.removeNext;   P.mkAc ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 198 "P: ref GeneralProcess{M.get;cnt := cnt + 1;if (cnt <= 0) :then ;   disable;   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "P" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "P: ref GeneralProcess" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- OG:Qalloc: "M.get" qDescno:  0 
 -- OG:Qalloc:A:  "get"  super:  "M.get"  marked:  false "P: ref GeneralProcess{M.get;cnt := cnt + 1;if (cnt <= 0) :then ;   disable;   P := Q.removeNext;   P.mkActive;   --P. ...}" s ... M ... 
 -- Invocation:Qalloc: "M.get" 
 -- ObjectInvocation:Qalloc: "M" 
 -- name: "M" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "get" 
 -- name: "get" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  96 2 loop: obj {   res: var integer;   i: var integer;   --disable;   res := free_M.cmpAndSwap(1);   if (res = 1) :then ...} 
 -- OG:super:  "get: {   loop: obj ;      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);      if (res = 1) :then ;         --enablesl ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "M.get" 
 -- super:  "M.get" 
 -- E:  "get" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "M.get" 
 -- Invocation:Qalloc: "cnt" 
 -- ObjectInvocation:Qalloc: "cnt" 
 -- name: "cnt" 
 -- Arguments "" 
 -- OG:Qalloc: "cnt + 1" qDescno:  0 
 -- OG:Qalloc:A:  "+"  super:  "cnt + 1"  marked:  false "cnt := cnt + 1" super:  cnt + 1 
 -- Invocation:Qalloc: "cnt + 1" 
 -- BinaryExp:Qalloc: "cnt + 1" 
 -- Invocation:Qalloc: "cnt" 
 -- ObjectInvocation:Qalloc: "cnt" 
 -- name: "cnt" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "+ 1" 
 -- name: "+" 
 -- Arguments "1" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "1" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  49 5 %basic 61{in V: var integer;out R: var integer} 
 -- OG:super:  "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "cnt + 1" 
 -- super:  "cnt + 1" 
 -- E:  "cnt + 1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "cnt + 1" 
 -- OG:Qalloc: "if (cnt <= 0) :then {   disable;   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable}" qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (cnt <= 0) :then {   disable;   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable}"  marked:  false "P:  ..." s ... i ... 
 -- Invocation:Qalloc: "if (cnt <= 0) :then {   disable;   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable}" 
 -- OG:Qalloc: "(cnt <= 0)" qDescno:  0 
 -- OG:Qalloc:A:  "<="  super:  "(cnt <= 0)"  marked:  false "if (cnt <= 0) :then {   disable;   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable}" s ... ( ... 
 -- Invocation:Qalloc: "(cnt <= 0)" 
 -- Invocation:Qalloc: "cnt <= 0" 
 -- BinaryExp:Qalloc: "cnt <= 0" 
 -- Invocation:Qalloc: "cnt" 
 -- ObjectInvocation:Qalloc: "cnt" 
 -- name: "cnt" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "<= 0" 
 -- name: "<=" 
 -- Arguments "0" 
 -- OG:Qalloc: "0" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "0"  marked:  false "0" super:  0 
 -- Invocation:Qalloc: "0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "0" 
 -- super:  "0" 
 -- E:  "0" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  47 5 %basic 52{in Veq: var this(Value);out Beq: var boolean} 
 -- OG:super:  "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(cnt <= 0)" 
 -- super:  "(cnt <= 0)" 
 -- E:  "(cnt <= 0)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(cnt <= 0)" 
 -- OG:Qalloc: "disable{   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable}" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (cnt <= 0) :then {   disable;   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "disable{   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 199 IS.newDescNo: 199 objSize: 0 1: 1 "disable{P := Q.removeNext;P.mkActive;--P.dcrWaiting -- SQS.dcrWaiting;enable}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 199 "disable{P := Q.removeNext;P.mkActive;--P.dcrWaiting -- SQS.dcrWaiting;enable}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: "disable" qDescno:  0 
 -- OG:Qalloc:A:  "disable"  super:  "disable"  marked:  false "disable{P := Q.removeNext;P.mkActive;--P.dcrWaiting -- SQS.dcrWaiting;enable}" super:  disable 
 -- Invocation:Qalloc: "disable" 
 -- ObjectInvocation:Qalloc: "disable" 
 -- name: "disable" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  195 1 %basic 11 
 -- OG:super:  "disable: {   %basic 11}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "disable" 
 -- super:  "disable" 
 -- E:  "disable" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "disable" 
 -- Invocation:Qalloc: "P" 
 -- ObjectInvocation:Qalloc: "P" 
 -- name: "P" 
 -- Arguments "" 
 -- OG:Qalloc: "Q.removeNext" qDescno:  0 
 -- OG:Qalloc:A:  "removeNext"  super:  "Q.removeNext"  marked:  false "P := Q.removeNext" super:  Q.removeNext 
 -- Invocation:Qalloc: "Q.removeNext" 
 -- ObjectInvocation:Qalloc: "Q" 
 -- name: "Q" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "removeNext" 
 -- name: "removeNext" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  168 2 -- return last element in queue and remove it for queue      out elm: ref Object{if (last =/= none) :then ;   noO ...} 
 -- OG:super:  "removeNext: {   -- return last element in queue and remove it for queue      out elm: ref Object;   if (last =/= none) :then ;      noOfElm := noOfElm - 1;     ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Q.removeNext" 
 -- super:  "Q.removeNext" 
 -- E:  "removeNext" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Q.removeNext" 
 -- OG:Qalloc: "P.mkActive{--P.dcrWaiting -- SQS.dcrWaiting}" qDescno:  0 
 -- OG:Qalloc:A:  "mkActive"  super:  "P.mkActive{--P.dcrWaiting -- SQS.dcrWaiting}"  marked:  false "disable{P := Q.removeNext;P.mkActive;--P.dcrWaiting -- SQS.dcrWaiting;ena ...}" s ... P ... 
 -- Invocation:Qalloc: "P.mkActive{--P.dcrWaiting -- SQS.dcrWaiting}" 
 -- ObjectInvocation:Qalloc: "P" 
 -- name: "P" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "mkActive{--P.dcrWaiting -- SQS.dcrWaiting}" 
 -- name: "mkActive" 
 -- Arguments "--P.dcrWaiting -- SQS.dcrWaiting" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  133 1 inner(mkActive) 
 -- OG:super:  "mkActive:< {   inner(mkActive)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "P.mkActive{--P.dcrWaiting -- SQS.dcrWaiting}" 
 -- super:  "P.mkActive{--P.dcrWaiting -- SQS.dcrWaiting}" 
 -- E:  "mkActive{--P.dcrWaiting -- SQS.dcrWaiting}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "P.mkActive{--P.dcrWaiting -- SQS.dcrWaiting}" 
 -- OG:Qalloc: "enable" qDescno:  0 
 -- OG:Qalloc:A:  "enable"  super:  "enable"  marked:  false "disable{P := Q.removeNext;P.mkActive;--P.dcrWaiting -- SQS.dcrWaiting;enable}" super:  enable 
 -- Invocation:Qalloc: "enable" 
 -- ObjectInvocation:Qalloc: "enable" 
 -- name: "enable" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  196 1 %basic 12 
 -- OG:super:  "enable: {   %basic 12}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "enable" 
 -- super:  "enable" 
 -- E:  "enable" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "enable" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 199 "disable{P := Q.removeNext;P.mkActive;--P.dcrWaiting -- SQS.dcrWaiting;enable}" 
 -- IS.newDescNo: 199 IS.objSize: 1 "disable{P := Q.removeNext;P.mkActive;--P.dcrWaiting -- SQS.dcrWaiting;enable}" 
 -- OG:Qalloc:end: IS.newDescNo:  199 "disable{   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable}" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (cnt <= 0) :then {   disable;   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable}" 
 -- super:  "if (cnt <= 0) :then {   disable;   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable}" 
 -- E:  "if (cnt <= 0) :then {   disable;   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (cnt <= 0) :then {   disable;   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable}" 
 -- OG:Qalloc: "M.free" qDescno:  0 
 -- OG:Qalloc:A:  "free"  super:  "M.free"  marked:  false "P: ref GeneralProcess{M.get;cnt := cnt + 1;if (cnt <= 0) :then ;   disable;   P := Q.removeNext;   P.mkActive;   -- ...}" s ... M ... 
 -- Invocation:Qalloc: "M.free" 
 -- ObjectInvocation:Qalloc: "M" 
 -- name: "M" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "free" 
 -- name: "free" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  109 1 free_M := 0 
 -- OG:super:  "free: {   free_M := 0}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "M.free" 
 -- super:  "M.free" 
 -- E:  "free" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "M.free" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 198 "P: ref GeneralProcess{M.get;cnt := cnt + 1;if (cnt <= 0) :then ;   disable;   P := Q.removeNext;   P.mkActive;   --P.dcrWaitin ...}" 
 -- IS.newDescNo: 198 IS.objSize: 2 "P: ref GeneralProcess{M.get;cnt := cnt + 1;if (cnt <= 0) :then ;   disable;   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcr ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  198 "P: ref GeneralProcess{   M.get;   cnt := cnt + 1;   if (cnt <= 0) :then ;      disable;      P := Q.removeNext;      P.mkActive;      -- ...}" 
 -- OG:super:  "signal: {   P: ref GeneralProcess;   M.get;   cnt := cnt + 1;   if (cnt <= 0) :then ;      disable;      P := Q.removeNext;      P.mkActive;      --P.dcrWaitin ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "mutex.signal" 
 -- super:  "mutex.signal" 
 -- E:  "signal" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "mutex.signal" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 192 "%kind method{%arguments value, immutable;mutex.wait;_V := _V + 1;inner(entry);mutex.signal}" 
 -- IS.newDescNo: 192 IS.objSize: 1 "%kind method{%arguments value, immutable;mutex.wait;_V := _V + 1;inner(entry);mutex.signal}" 
 -- OG:Qalloc:end: IS.newDescNo:  192 "%kind method{   %arguments value, immutable;   mutex.wait;   _V := _V + 1;   inner(entry);   mutex.signal}" 
 -- OG:super:  "entry: {   %kind method;   %arguments value, immutable;   mutex.wait;   _V := _V + 1;   inner(entry);   mutex.signal}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "entry{   S.print}" 
 -- super:  "entry" 
 -- E:  "entry" 
 -- OG:Qalloc:B: "print" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 200 IS.newDescNo: 200 objSize: 0 1: 1 "S.print" 
 -- Items:Qalloc:objSize: 0  newDescNo: 200 "S.print" 
 -- Items:Qalloc:super: "entry" size: 1 "print" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "%$B "("{S: var String;%$E ")"}" 
 -- dataitem:qalloc: "S" isValue: true  isPrimitive: true  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "S: var String" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "%$B "("{S: var String;%$E ")"}" 
 -- OG:Qalloc: "S.print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "S.print"  marked:  false "S.print" super:  S.print 
 -- Invocation:Qalloc: "S.print" 
 -- ObjectInvocation:Qalloc: "S" 
 -- name: "S" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  103 1 gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);} 
 -- OG:super:  "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "S.print" 
 -- super:  "S.print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "S.print" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 200 "S.print" 
 -- IS.newDescNo: 200 IS.objSize: 2 "S.print" 
 -- OG:Qalloc:end: IS.newDescNo:  200 "entry{   S.print}" 
 -- OG:super:  "print(S: var String): entry{   S.print}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "myM.print("P1 resumed\n")" 
 -- super:  "myM.print("P1 resumed\n")" 
 -- E:  "print("P1 resumed\n")" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "myM.print("P1 resumed\n")" 
 -- OG:Qalloc: "for(1):to(5):repeat{   myM.putItem("Fac: "):value(inx):res(fac(inx));}" qDescno:  0 
 -- OG:Qalloc:A:  "for:to:repeat$0"  super:  "for(1):to(5):repeat{   myM.putItem("Fac: "):value(inx):res(fac(inx));}"  marked:  false "fac(V: var integer): {   out res: var in ...}" s ... f ... 
 -- Invocation:Qalloc: "for(1):to(5):repeat{   myM.putItem("Fac: "):value(inx):res(fac(inx));}" 
 -- ObjectInvocation:Qalloc: "for(1):to(5):repeat{   myM.putItem("Fac: "):value(inx):res(fac(inx));}" 
 -- name: "for:to:repeat" 
 -- Arguments "for(1):to(5):repeat{   myM.putItem("Fac: "):value(inx):res(fac(inx));}" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "for(1):to(5):repeat{   myM.putItem("Fac: "):value(inx):res(fac(inx));}" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- OG:Qalloc: "5" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "5"  marked:  false "for(1):to(5):repeat{   myM.putItem("Fac: "):value(inx):res(fac(inx));}" super:  5 
 -- Invocation:Qalloc: "5" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "5" 
 -- super:  "5" 
 -- E:  "5" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "5" 
 -- OG:Qalloc: "myM.putItem("Fac: "):value(inx):res(fac(inx))" qDescno:  0 
 -- OG:Qalloc:A:  "repeat$0"  super:  ""  marked:  false "for(1):to(5):repeat{   myM.putItem("Fac: "):value(inx):res(fac(inx));}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "myM.putItem("Fac: "):value(inx):res(fac(inx))" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "repeat$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 201 IS.newDescNo: 201 objSize: 0 1: 1 "myM.putItem("Fac: "):value(inx):res(fac(inx))" 
 -- Items:Qalloc:objSize: 0  newDescNo: 201 "myM.putItem("Fac: "):value(inx):res(fac(inx))" 
 -- Items:Qalloc:super: "" size: 1 "repeat$201" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- OG:Qalloc: "myM.putItem("Fac: "):value(inx):res(fac(inx))" qDescno:  0 
 -- OG:Qalloc:A:  "putItem:value:res"  super:  "myM.putItem("Fac: "):value(inx):res(fac(inx))"  marked:  false "myM.putItem("Fac: "):value(inx):res(fac(inx))" super:  myM.putI ... 
 -- Invocation:Qalloc: "myM.putItem("Fac: "):value(inx):res(fac(inx))" 
 -- ObjectInvocation:Qalloc: "myM" 
 -- name: "myM" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "putItem("Fac: "):value(inx):res(fac(inx))" 
 -- name: "putItem:value:res" 
 -- Arguments "putItem("Fac: "):value(inx):res(fac(inx))" 
 -- OG:Qalloc: ""Fac: "" qDescno:  0 
 -- OG:Qalloc:A:  "String"  super:  ""Fac: ""  marked:  false "putItem("Fac: "):value(inx):res(fac(inx))" super:  "Fac: " 
 -- Invocation:Qalloc: ""Fac: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  10 0 %id "String pattern"{%OSDvisibility disguised;%basic 5;%public;length: ;   out V: var integer;   V := get[0] -- ac ...} 
 -- OG:super:  "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- actually an  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""Fac: "" 
 -- super:  ""Fac: "" 
 -- E:  ""Fac: "" 
 -- OG:Qalloc:end: IS.newDescNo:  0 ""Fac: "" 
 -- OG:Qalloc: "inx" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "inx"  marked:  false "putItem("Fac: "):value(inx):res(fac(inx))" super:  inx 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "inx: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx" 
 -- super:  "inx" 
 -- E:  "inx" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx" 
 -- OG:Qalloc: "fac(inx)" qDescno:  0 
 -- OG:Qalloc:A:  "fac"  super:  "fac(inx)"  marked:  false "putItem("Fac: "):value(inx):res(fac(inx))" super:  fac(inx) 
 -- Invocation:Qalloc: "fac(inx)" 
 -- ObjectInvocation:Qalloc: "fac(inx)" 
 -- name: "fac" 
 -- Arguments "fac(inx)" 
 -- OG:Qalloc: "inx" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "inx"  marked:  false "fac(inx)" super:  inx 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "inx: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx" 
 -- super:  "inx" 
 -- E:  "inx" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 out res: var integer{if (V = 1) :then ;   res := 1;:else ;   res := V * fac(V - 1)} 
 -- OG:Qalloc:SuperAlloc: "fac(V: var integer): {   out res: var integer;   if (V = 1) :then ;      res := 1;   :else ;      res := V * fac(V - 1)}" 
 -- OG:Qalloc: "out res: var integer{   if (V = 1) :then ;      res := 1;   :else ;      res := V * fac(V - 1)}" qDescno:  0 
 -- OG:Qalloc:A:  "fac"  super:  ""  marked:  false "fac(V: var integer): {   out res: var integer;   if (V = 1) :then ;      res := 1;   :else ;      res := V * fac(V - 1)}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "out res: var integer{   if (V = 1) :then ;      res := 1;   :else ;      res := V * fac(V - 1)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "fac" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 202 IS.newDescNo: 202 objSize: 0 1: 1 "out res: var integer{if (V = 1) :then ;   res := 1;:else ;   res := V * fac(V - 1)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 202 "out res: var integer{if (V = 1) :then ;   res := 1;:else ;   res := V * fac(V - 1)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "%$B "("{V: var integer;%$E ")"}" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "%$B "("{V: var integer;%$E ")"}" 
 -- dataitem:qalloc: "res" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- OG:Qalloc: "if (V = 1) :then {   res := 1;:else ;   res := V * fac(V - 1)}" qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (V = 1) :then {   res := 1;:else ;   res := V * fac(V - 1)}"  marked:  false "out res: var integer{if (V = 1) :then ;   res := 1;:el ...}" s ... i ... 
 -- Invocation:Qalloc: "if (V = 1) :then {   res := 1;:else ;   res := V * fac(V - 1)}" 
 -- OG:Qalloc: "(V = 1)" qDescno:  0 
 -- OG:Qalloc:A:  "="  super:  "(V = 1)"  marked:  false "if (V = 1) :then {   res := 1;:else ;   res := V * fac(V - 1)}" super:  (V = 1) 
 -- Invocation:Qalloc: "(V = 1)" 
 -- Invocation:Qalloc: "V = 1" 
 -- BinaryExp:Qalloc: "V = 1" 
 -- Invocation:Qalloc: "V" 
 -- ObjectInvocation:Qalloc: "V" 
 -- name: "V" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "= 1" 
 -- name: "=" 
 -- Arguments "1" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "1" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  11 5 %basic 50{in Veq: var this(Value);out Beq: var boolean;inner(= )} 
 -- OG:super:  "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(V = 1)" 
 -- super:  "(V = 1)" 
 -- E:  "(V = 1)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(V = 1)" 
 -- OG:Qalloc: "res := 1" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (V = 1) :then {   res := 1;:else ;   res := V * fac(V - 1)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "res := 1" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 203 IS.newDescNo: 203 objSize: 0 1: 1 "res := 1" 
 -- Items:Qalloc:objSize: 0  newDescNo: 203 "res := 1" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "res" 
 -- ObjectInvocation:Qalloc: "res" 
 -- name: "res" 
 -- Arguments "" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "res := 1" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 203 "res := 1" 
 -- IS.newDescNo: 203 IS.objSize: 1 "res := 1" 
 -- OG:Qalloc:end: IS.newDescNo:  203 "res := 1" 
 -- OG:Qalloc: "res := V * fac(V - 1)" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (V = 1) :then {   res := 1;:else ;   res := V * fac(V - 1)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "res := V * fac(V - 1)" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 204 IS.newDescNo: 204 objSize: 0 1: 1 "res := V * fac(V - 1)" 
 -- Items:Qalloc:objSize: 0  newDescNo: 204 "res := V * fac(V - 1)" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "res" 
 -- ObjectInvocation:Qalloc: "res" 
 -- name: "res" 
 -- Arguments "" 
 -- OG:Qalloc: "V * fac(V - 1)" qDescno:  0 
 -- OG:Qalloc:A:  "*"  super:  "V * fac(V - 1)"  marked:  false "res := V * fac(V - 1)" super:  V * fac(V - 1) 
 -- Invocation:Qalloc: "V * fac(V - 1)" 
 -- BinaryExp:Qalloc: "V * fac(V - 1)" 
 -- Invocation:Qalloc: "V" 
 -- ObjectInvocation:Qalloc: "V" 
 -- name: "V" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "* fac(V - 1)" 
 -- name: "*" 
 -- Arguments "fac(V - 1)" 
 -- OG:Qalloc: "fac(V - 1)" qDescno:  0 
 -- OG:Qalloc:A:  "fac"  super:  "fac(V - 1)"  marked:  false "fac(V - 1)" super:  fac(V - 1) 
 -- Invocation:Qalloc: "fac(V - 1)" 
 -- ObjectInvocation:Qalloc: "fac(V - 1)" 
 -- name: "fac" 
 -- Arguments "fac(V - 1)" 
 -- OG:Qalloc: "V - 1" qDescno:  0 
 -- OG:Qalloc:A:  "-"  super:  "V - 1"  marked:  false "fac(V - 1)" super:  V - 1 
 -- Invocation:Qalloc: "V - 1" 
 -- BinaryExp:Qalloc: "V - 1" 
 -- Invocation:Qalloc: "V" 
 -- ObjectInvocation:Qalloc: "V" 
 -- name: "V" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "- 1" 
 -- name: "-" 
 -- Arguments "1" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "1" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  108 5 %basic 62{in V: var integer;out R: var integer} 
 -- OG:super:  "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "V - 1" 
 -- super:  "V - 1" 
 -- E:  "V - 1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "V - 1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  202 3 out res: var integer{if (V = 1) :then ;   res := 1;:else ;   res := V * fac(V - 1)} 
 -- OG:super:  "fac(V: var integer): {   out res: var integer;   if (V = 1) :then ;      res := 1;   :else ;      res := V * fac(V - 1)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "fac(V - 1)" 
 -- super:  "fac(V - 1)" 
 -- E:  "fac(V - 1)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "fac(V - 1)" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 66{in V: var integer;out R: var integer} 
 -- OG:Qalloc:SuperAlloc: "*  : {   %basic 66;   in V: var integer;   out R: var integer}" 
 -- OG:Qalloc: "%basic 66{   in V: var integer;   out R: var integer}" qDescno:  0 
 -- OG:Qalloc:A:  "*"  super:  ""  marked:  false "*  : {   %basic 66;   in V: var integer;   out R: var integer}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 66{   in V: var integer;   out R: var integer}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "*" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 205 IS.newDescNo: 205 objSize: 0 1: 1 "%basic 66{in V: var integer;out R: var integer}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 205 "%basic 66{in V: var integer;out R: var integer}" 
 -- Items:Qalloc:Super:C:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- dataitem:qalloc: "R" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 205 "%basic 66{in V: var integer;out R: var integer}" 
 -- IS.newDescNo: 205 IS.objSize: 5 "%basic 66{in V: var integer;out R: var integer}" 
 -- OG:Qalloc:end: IS.newDescNo:  205 "%basic 66{   in V: var integer;   out R: var integer}" 
 -- OG:super:  "*  : {   %basic 66;   in V: var integer;   out R: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "V * fac(V - 1)" 
 -- super:  "V * fac(V - 1)" 
 -- E:  "V * fac(V - 1)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "V * fac(V - 1)" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 204 "res := V * fac(V - 1)" 
 -- IS.newDescNo: 204 IS.objSize: 1 "res := V * fac(V - 1)" 
 -- OG:Qalloc:end: IS.newDescNo:  204 "res := V * fac(V - 1)" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (V = 1) :then {   res := 1;:else ;   res := V * fac(V - 1)}" 
 -- super:  "if (V = 1) :then {   res := 1;:else ;   res := V * fac(V - 1)}" 
 -- E:  "if (V = 1) :then {   res := 1;:else ;   res := V * fac(V - 1)}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (V = 1) :then {   res := 1;:else ;   res := V * fac(V - 1)}" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 202 "out res: var integer{if (V = 1) :then ;   res := 1;:else ;   res := V * fac(V - 1)}" 
 -- IS.newDescNo: 202 IS.objSize: 3 "out res: var integer{if (V = 1) :then ;   res := 1;:else ;   res := V * fac(V - 1)}" 
 -- OG:Qalloc:end: IS.newDescNo:  202 "out res: var integer{   if (V = 1) :then ;      res := 1;   :else ;      res := V * fac(V - 1)}" 
 -- OG:super:  "fac(V: var integer): {   out res: var integer;   if (V = 1) :then ;      res := 1;   :else ;      res := V * fac(V - 1)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "fac(inx)" 
 -- super:  "fac(inx)" 
 -- E:  "fac(inx)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "fac(inx)" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 put(10){put('<');msg.print;putint(V);" = ".print;putint(res);put('>')} 
 -- OG:Qalloc:SuperAlloc: "putItem(msg: var String):value(V: var integer):res(res: var integer): entry{   put(10);   put('<');   msg.print;   putint(V);   " = ".print;   putin ...}" 
 -- OG:Qalloc: "entry{   put(10);   put('<');   msg.print;   putint(V);   " = ".print;   putint(res);   put('>')}" qDescno:  0 
 -- OG:Qalloc:A:  "putItem:value:res"  super:  "entry"  marked:  false "putItem(msg: var String):value(V: var integer):res(res: var integer): entry{   put(10);   put('<');   m ...}" s ... e ... 
 -- Invocation:Qalloc: "entry" 
 -- ObjectInvocation:Qalloc: "entry" 
 -- name: "entry" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  192 1 %kind method{%arguments value, immutable;mutex.wait;_V := _V + 1;inner(entry);mutex.signal} 
 -- OG:super:  "entry: {   %kind method;   %arguments value, immutable;   mutex.wait;   _V := _V + 1;   inner(entry);   mutex.signal}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "entry{   put(10);   put('<');   msg.print;   putint(V);   " = ".print;   putint(res);   put('>')}" 
 -- super:  "entry" 
 -- E:  "entry" 
 -- OG:Qalloc:B: "putItem:value:res" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 206 IS.newDescNo: 206 objSize: 0 1: 1 "put(10){put('<');msg.print;putint(V);" = ".print;putint(res);put('>')}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 206 "put(10){put('<');msg.print;putint(V);" = ".print;putint(res);put('>')}" 
 -- Items:Qalloc:super: "entry" size: 1 "putItem:value:res" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "%$B "("{msg: var String;%$S "):value(";V: var integer;%$S "):res(";res: var integer;%$E ")"}" 
 -- dataitem:qalloc: "msg" isValue: true  isPrimitive: true  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "msg: var String" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "res" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "%$B "("{msg: var String;%$S "):value(";V: var integer;%$S "):res(";res: var integer;%$E ")"}" 
 -- OG:Qalloc: "put(10)" qDescno:  0 
 -- OG:Qalloc:A:  "put"  super:  "put(10)"  marked:  false "put(10){put('<');msg.print;putint(V);" = ".print;putint(res);put('>')}" super:  put(10) 
 -- Invocation:Qalloc: "put(10)" 
 -- ObjectInvocation:Qalloc: "put(10)" 
 -- name: "put" 
 -- Arguments "put(10)" 
 -- OG:Qalloc: "10" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "10"  marked:  false "put(10)" super:  10 
 -- Invocation:Qalloc: "10" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "10" 
 -- super:  "10" 
 -- E:  "10" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "10" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  105 1 %globals{%basic 2;in ch: val char} 
 -- OG:super:  "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "put(10)" 
 -- super:  "put(10)" 
 -- E:  "put(10)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "put(10)" 
 -- OG:Qalloc: "put('<')" qDescno:  0 
 -- OG:Qalloc:A:  "put"  super:  "put('<')"  marked:  false "put(10){put('<');msg.print;putint(V);" = ".print;putint(res);put('>')}" super:  put('<') 
 -- Invocation:Qalloc: "put('<')" 
 -- ObjectInvocation:Qalloc: "put('<')" 
 -- name: "put" 
 -- Arguments "put('<')" 
 -- OG:Qalloc: "'<'" qDescno:  0 
 -- OG:Qalloc:A:  "char"  super:  "'<'"  marked:  false "put('<')" super:  '<' 
 -- Invocation:Qalloc: "'<'" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  7 1 %id "char"{%globals;%basic 3, 16;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var char;   out ...} 
 -- OG:super:  "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;      out R: v ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "'<'" 
 -- super:  "'<'" 
 -- E:  "'<'" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "'<'" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  105 1 %globals{%basic 2;in ch: val char} 
 -- OG:super:  "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "put('<')" 
 -- super:  "put('<')" 
 -- E:  "put('<')" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "put('<')" 
 -- OG:Qalloc: "msg.print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "msg.print"  marked:  false "put(10){put('<');msg.print;putint(V);" = ".print;putint(res);put('>')}" super:  msg.print 
 -- Invocation:Qalloc: "msg.print" 
 -- ObjectInvocation:Qalloc: "msg" 
 -- name: "msg" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  103 1 gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);} 
 -- OG:super:  "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "msg.print" 
 -- super:  "msg.print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "msg.print" 
 -- OG:Qalloc: "putint(V)" qDescno:  0 
 -- OG:Qalloc:A:  "putint"  super:  "putint(V)"  marked:  false "put(10){put('<');msg.print;putint(V);" = ".print;putint(res);put('>')}" super:  putint(V) 
 -- Invocation:Qalloc: "putint(V)" 
 -- ObjectInvocation:Qalloc: "putint(V)" 
 -- name: "putint" 
 -- Arguments "putint(V)" 
 -- OG:Qalloc: "V" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "V"  marked:  false "putint(V)" super:  V 
 -- Invocation:Qalloc: "V" 
 -- ObjectInvocation:Qalloc: "V" 
 -- name: "V" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "V: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "V" 
 -- super:  "V" 
 -- E:  "V" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "V" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %globals{in V: var integer;D: obj Indexed(20,#integer);L: var integer;isNeg: var Boolean;isNeg := V < 0;if (isNeg)  ...} 
 -- OG:Qalloc:SuperAlloc: "putint: {   %globals;   in V: var integer;   D: obj Indexed(20,#integer);   L: var integer;   isNeg: var Boolean;   isNeg := V < 0;   if (isNeg) :th ...}" 
 -- OG:Qalloc: "%globals{   in V: var integer;   D: obj Indexed(20,#integer);   L: var integer;   isNeg: var Boolean;   isNeg := V < 0;   if (isNeg) :then ;      V := 0 - V;   ...}" q ... 0 
 -- OG:Qalloc:A:  "putint"  super:  ""  marked:  false "putint: {   %globals;   in V: var integer;   D: obj Indexed(20,#integer);   L: var integer;   isNeg: var Boolean;   isN ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%globals{   in V: var integer;   D: obj Indexed(20,#integer);   L: var integer;   isNeg: var Boolean;   isNeg := V < 0;   if (isNeg) :then ;      V := 0 - V;   loop: do ; ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "putint" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 207 IS.newDescNo: 207 objSize: 0 1: 1 "%globals{in V: var integer;D: obj Indexed(20,#integer);L: var integer;isNeg: var Boolean;isNeg := V < 0;i ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 207 "%globals{in V: var integer;D: obj Indexed(20,#integer);L: var integer;isNeg: var Boolean;isNeg := V < 0;if (isNeg) :then ;   V :=  ...}" 
 -- Items:Qalloc:Super:C:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "D" isValue: false  isPrimitive: true  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "D: obj Indexed(20,#integer)" 
 -- OG:Qalloc: "Indexed(20,#integer)" qDescno:  0 
 -- OG:Qalloc:A:  "D"  super:  "Indexed(20,#integer)"  marked:  false "D: obj Indexed(20,#integer)" super:  Indexed(20,#integer) 
 -- Invocation:Qalloc: "Indexed(20,#integer)" 
 -- ObjectInvocation:Qalloc: "Indexed(20,#integer)" 
 -- name: "Indexed" 
 -- Arguments "(20,#integer)" 
 -- OG:Qalloc: "20" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "20"  marked:  false "(20,#integer)" super:  20 
 -- Invocation:Qalloc: "20" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "20" 
 -- super:  "20" 
 -- E:  "20" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "20" 
 -- OG:Qalloc: "#integer" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "#integer"  marked:  false "(20,#integer)" super:  #integer 
 -- Invocation:Qalloc: "#integer" 
 -- ObjectInvocation:Qalloc: "#integer" 
 -- name: "#integer" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "#integer" 
 -- super:  "#integer" 
 -- E:  "#integer" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "#integer" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  86 1 %globals{%basic 114;%public;in range: var Integer;in elm:< Object;length: ;   out res: var integer;   res := get[0 ...} 
 -- OG:super:  "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];   put(V: ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "Indexed(20,#integer)" 
 -- super:  "Indexed(20,#integer)" 
 -- E:  "Indexed(20,#integer)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Indexed(20,#integer)" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- dataitem:qalloc: "L" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "isNeg" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- Invocation:Qalloc: "isNeg" 
 -- ObjectInvocation:Qalloc: "isNeg" 
 -- name: "isNeg" 
 -- Arguments "" 
 -- OG:Qalloc: "V < 0" qDescno:  0 
 -- OG:Qalloc:A:  "<"  super:  "V < 0"  marked:  false "isNeg := V < 0" super:  V < 0 
 -- Invocation:Qalloc: "V < 0" 
 -- BinaryExp:Qalloc: "V < 0" 
 -- Invocation:Qalloc: "V" 
 -- ObjectInvocation:Qalloc: "V" 
 -- name: "V" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "< 0" 
 -- name: "<" 
 -- Arguments "0" 
 -- OG:Qalloc: "0" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "0"  marked:  false "0" super:  0 
 -- Invocation:Qalloc: "0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "0" 
 -- super:  "0" 
 -- E:  "0" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  54 5 %basic 51{in V: var integer;out B: var boolean} 
 -- OG:super:  "<  : {   %basic 51;   in V: var integer;   out B: var boolean}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "V < 0" 
 -- super:  "V < 0" 
 -- E:  "V < 0" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "V < 0" 
 -- OG:Qalloc: "if (isNeg) :then {   V := 0 - V}" qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (isNeg) :then {   V := 0 - V}"  marked:  false "%globals{in V: var integer;D: obj Indexed(20,#integer);L: var integer;isNeg: var Boo ...}" s ... i ... 
 -- Invocation:Qalloc: "if (isNeg) :then {   V := 0 - V}" 
 -- OG:Qalloc: "(isNeg)" qDescno:  0 
 -- OG:Qalloc:A:  "Boolean"  super:  "(isNeg)"  marked:  false "if (isNeg) :then {   V := 0 - V}" super:  (isNeg) 
 -- Invocation:Qalloc: "(isNeg)" 
 -- Invocation:Qalloc: "isNeg" 
 -- ObjectInvocation:Qalloc: "isNeg" 
 -- name: "isNeg" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  45 1 %id "Boolean"{%globals inSub;%basic 4, 8;%public;_thisBasicValue: var Universal;&&  : ;   %basic 70;   in B: var b ...} 
 -- OG:super:  "isNeg: var Boolean" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(isNeg)" 
 -- super:  "(isNeg)" 
 -- E:  "(isNeg)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(isNeg)" 
 -- OG:Qalloc: "V := 0 - V" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (isNeg) :then {   V := 0 - V}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "V := 0 - V" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 208 IS.newDescNo: 208 objSize: 0 1: 1 "V := 0 - V" 
 -- Items:Qalloc:objSize: 0  newDescNo: 208 "V := 0 - V" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "V" 
 -- ObjectInvocation:Qalloc: "V" 
 -- name: "V" 
 -- Arguments "" 
 -- OG:Qalloc: "0 - V" qDescno:  0 
 -- OG:Qalloc:A:  "-"  super:  "0 - V"  marked:  false "V := 0 - V" super:  0 - V 
 -- Invocation:Qalloc: "0 - V" 
 -- BinaryExp:Qalloc: "0 - V" 
 -- Invocation:Qalloc: "0" 
 -- ObjectInvocation:Qalloc: "- V" 
 -- name: "-" 
 -- Arguments "V" 
 -- OG:Qalloc: "V" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "V"  marked:  false "V" super:  V 
 -- Invocation:Qalloc: "V" 
 -- ObjectInvocation:Qalloc: "V" 
 -- name: "V" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "in V: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "V" 
 -- super:  "V" 
 -- E:  "V" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "V" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  108 5 %basic 62{in V: var integer;out R: var integer} 
 -- OG:super:  "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "0 - V" 
 -- super:  "0 - V" 
 -- E:  "0 - V" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "0 - V" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 208 "V := 0 - V" 
 -- IS.newDescNo: 208 IS.objSize: 1 "V := 0 - V" 
 -- OG:Qalloc:end: IS.newDescNo:  208 "V := 0 - V" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (isNeg) :then {   V := 0 - V}" 
 -- super:  "if (isNeg) :then {   V := 0 - V}" 
 -- E:  "if (isNeg) :then {   V := 0 - V}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (isNeg) :then {   V := 0 - V}" 
 -- OG:Qalloc: "if (isNeg) :then {   put('-')}" qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (isNeg) :then {   put('-')}"  marked:  false "%globals{in V: var integer;D: obj Indexed(20,#integer);L: var integer;isNeg: var Boole ...}" s ... i ... 
 -- Invocation:Qalloc: "if (isNeg) :then {   put('-')}" 
 -- OG:Qalloc: "(isNeg)" qDescno:  0 
 -- OG:Qalloc:A:  "Boolean"  super:  "(isNeg)"  marked:  false "if (isNeg) :then {   put('-')}" super:  (isNeg) 
 -- Invocation:Qalloc: "(isNeg)" 
 -- Invocation:Qalloc: "isNeg" 
 -- ObjectInvocation:Qalloc: "isNeg" 
 -- name: "isNeg" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  45 1 %id "Boolean"{%globals inSub;%basic 4, 8;%public;_thisBasicValue: var Universal;&&  : ;   %basic 70;   in B: var b ...} 
 -- OG:super:  "isNeg: var Boolean" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(isNeg)" 
 -- super:  "(isNeg)" 
 -- E:  "(isNeg)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(isNeg)" 
 -- OG:Qalloc: "put('-')" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (isNeg) :then {   put('-')}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "put('-')" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 209 IS.newDescNo: 209 objSize: 0 1: 1 "put('-')" 
 -- Items:Qalloc:objSize: 0  newDescNo: 209 "put('-')" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: "put('-')" qDescno:  0 
 -- OG:Qalloc:A:  "put"  super:  "put('-')"  marked:  false "put('-')" super:  put('-') 
 -- Invocation:Qalloc: "put('-')" 
 -- ObjectInvocation:Qalloc: "put('-')" 
 -- name: "put" 
 -- Arguments "put('-')" 
 -- OG:Qalloc: "'-'" qDescno:  0 
 -- OG:Qalloc:A:  "char"  super:  "'-'"  marked:  false "put('-')" super:  '-' 
 -- Invocation:Qalloc: "'-'" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  7 1 %id "char"{%globals;%basic 3, 16;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var char;   out ...} 
 -- OG:super:  "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;      out R: v ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "'-'" 
 -- super:  "'-'" 
 -- E:  "'-'" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "'-'" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  105 1 %globals{%basic 2;in ch: val char} 
 -- OG:super:  "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "put('-')" 
 -- super:  "put('-')" 
 -- E:  "put('-')" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "put('-')" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 209 "put('-')" 
 -- IS.newDescNo: 209 IS.objSize: 1 "put('-')" 
 -- OG:Qalloc:end: IS.newDescNo:  209 "put('-')" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (isNeg) :then {   put('-')}" 
 -- super:  "if (isNeg) :then {   put('-')}" 
 -- E:  "if (isNeg) :then {   put('-')}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (isNeg) :then {   put('-')}" 
 -- OG:Qalloc: "for(1):to(L):repeat{   i: var integer;   i := L + 1 - inx;   put('0' + D.get[i]);}" qDescno:  0 
 -- OG:Qalloc:A:  "for:to:repeat$0"  super:  "for(1):to(L):repeat{   i: var integer;   i := L + 1 - inx;   put('0' + D.get[i]);}"  marked:  false "%globals{in V: var integer;D ...}" s ... f ... 
 -- Invocation:Qalloc: "for(1):to(L):repeat{   i: var integer;   i := L + 1 - inx;   put('0' + D.get[i]);}" 
 -- ObjectInvocation:Qalloc: "for(1):to(L):repeat{   i: var integer;   i := L + 1 - inx;   put('0' + D.get[i]);}" 
 -- name: "for:to:repeat" 
 -- Arguments "for(1):to(L):repeat{   i: var integer;   i := L + 1 - inx;   put('0' + D.get[i]);}" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "for(1):to(L):repeat{   i: var integer;   i := L + 1 - inx;   put('0' + D.get[i]);}" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- OG:Qalloc: "L" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "L"  marked:  false "for(1):to(L):repeat{   i: var integer;   i := L + 1 - inx;   put('0' + D.get[i]);}" super:  L 
 -- Invocation:Qalloc: "L" 
 -- ObjectInvocation:Qalloc: "L" 
 -- name: "L" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "L: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L" 
 -- super:  "L" 
 -- E:  "L" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L" 
 -- OG:Qalloc: "i: var integer{   i := L + 1 - inx;   put('0' + D.get[i])}" qDescno:  0 
 -- OG:Qalloc:A:  "repeat$0"  super:  ""  marked:  false "for(1):to(L):repeat{   i: var integer;   i := L + 1 - inx;   put('0' + D.get[i]);}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "i: var integer{   i := L + 1 - inx;   put('0' + D.get[i])}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "repeat$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 210 IS.newDescNo: 210 objSize: 0 1: 1 "i: var integer{i := L + 1 - inx;put('0' + D.get[i])}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 210 "i: var integer{i := L + 1 - inx;put('0' + D.get[i])}" 
 -- Items:Qalloc:super: "" size: 1 "repeat$210" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- dataitem:qalloc: "i" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Invocation:Qalloc: "i" 
 -- ObjectInvocation:Qalloc: "i" 
 -- name: "i" 
 -- Arguments "" 
 -- OG:Qalloc: "L + 1 - inx" qDescno:  0 
 -- OG:Qalloc:A:  "-"  super:  "L + 1 - inx"  marked:  false "i := L + 1 - inx" super:  L + 1 - inx 
 -- Invocation:Qalloc: "L + 1 - inx" 
 -- BinaryExp:Qalloc: "L + 1 - inx" 
 -- BinaryExp:Qalloc: "L + 1" 
 -- Invocation:Qalloc: "L" 
 -- ObjectInvocation:Qalloc: "L" 
 -- name: "L" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "+ 1" 
 -- name: "+" 
 -- Arguments "1" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "1" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- ObjectInvocation:Qalloc: "- inx" 
 -- name: "-" 
 -- Arguments "inx" 
 -- OG:Qalloc: "inx" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "inx"  marked:  false "inx" super:  inx 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "inx: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx" 
 -- super:  "inx" 
 -- E:  "inx" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  108 5 %basic 62{in V: var integer;out R: var integer} 
 -- OG:super:  "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L + 1 - inx" 
 -- super:  "L + 1 - inx" 
 -- E:  "L + 1 - inx" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L + 1 - inx" 
 -- OG:Qalloc: "put('0' + D.get[i])" qDescno:  0 
 -- OG:Qalloc:A:  "put"  super:  "put('0' + D.get[i])"  marked:  false "i: var integer{i := L + 1 - inx;put('0' + D.get[i])}" super:  put('0' + D.get[i]) 
 -- Invocation:Qalloc: "put('0' + D.get[i])" 
 -- ObjectInvocation:Qalloc: "put('0' + D.get[i])" 
 -- name: "put" 
 -- Arguments "put('0' + D.get[i])" 
 -- OG:Qalloc: "'0' + D.get[i]" qDescno:  0 
 -- OG:Qalloc:A:  "+"  super:  "'0' + D.get[i]"  marked:  false "put('0' + D.get[i])" super:  '0' + D.get[i] 
 -- Invocation:Qalloc: "'0' + D.get[i]" 
 -- BinaryExp:Qalloc: "'0' + D.get[i]" 
 -- Invocation:Qalloc: "'0'" 
 -- ObjectInvocation:Qalloc: "+ D.get[i]" 
 -- name: "+" 
 -- Arguments "D.get[i]" 
 -- OG:Qalloc: "D.get[i]" qDescno:  0 
 -- OG:Qalloc:A:  "get"  super:  "D.get[i]"  marked:  false "D.get[i]" super:  D.get[i] 
 -- Invocation:Qalloc: "D.get[i]" 
 -- ObjectInvocation:Qalloc: "D" 
 -- name: "D" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "get[i]" 
 -- name: "get" 
 -- Arguments "get[i]" 
 -- OG:Qalloc: "i" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "i"  marked:  false "get[i]" super:  i 
 -- Invocation:Qalloc: "i" 
 -- ObjectInvocation:Qalloc: "i" 
 -- name: "i" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "i: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "i" 
 -- super:  "i" 
 -- E:  "i" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "i" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 116{out V: var integer} 
 -- OG:Qalloc:SuperAlloc: "get[inx: var integer]: {   %basic 116;   out V: var integer}" 
 -- OG:Qalloc: "%basic 116{   out V: var integer}" qDescno:  0 
 -- OG:Qalloc:A:  "get"  super:  ""  marked:  false "get[inx: var integer]: {   %basic 116;   out V: var integer}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 116{   out V: var integer}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "get" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 211 IS.newDescNo: 211 objSize: 0 1: 1 "%basic 116{out V: var integer}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 211 "%basic 116{out V: var integer}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "%$B "["{inx: var integer;%$E "]"}" 
 -- dataitem:qalloc: "inx" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "%$B "["{inx: var integer;%$E "]"}" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 211 "%basic 116{out V: var integer}" 
 -- IS.newDescNo: 211 IS.objSize: 3 "%basic 116{out V: var integer}" 
 -- OG:Qalloc:end: IS.newDescNo:  211 "%basic 116{   out V: var integer}" 
 -- OG:super:  "get[inx: var integer]: {   %basic 116;   out V: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "D.get[i]" 
 -- super:  "D.get[i]" 
 -- E:  "get[i]" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "D.get[i]" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 61{in V: var char;out R: var char} 
 -- OG:Qalloc:SuperAlloc: "+  : {   %basic 61;   in V: var char;   out R: var char}" 
 -- OG:Qalloc: "%basic 61{   in V: var char;   out R: var char}" qDescno:  0 
 -- OG:Qalloc:A:  "+"  super:  ""  marked:  false "+  : {   %basic 61;   in V: var char;   out R: var char}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 61{   in V: var char;   out R: var char}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "+" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 212 IS.newDescNo: 212 objSize: 0 1: 1 "%basic 61{in V: var char;out R: var char}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 212 "%basic 61{in V: var char;out R: var char}" 
 -- Items:Qalloc:Super:C:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- dataitem:qalloc: "R" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 212 "%basic 61{in V: var char;out R: var char}" 
 -- IS.newDescNo: 212 IS.objSize: 5 "%basic 61{in V: var char;out R: var char}" 
 -- OG:Qalloc:end: IS.newDescNo:  212 "%basic 61{   in V: var char;   out R: var char}" 
 -- OG:super:  "+  : {   %basic 61;   in V: var char;   out R: var char}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "'0' + D.get[i]" 
 -- super:  "'0' + D.get[i]" 
 -- E:  "'0' + D.get[i]" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "'0' + D.get[i]" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  105 1 %globals{%basic 2;in ch: val char} 
 -- OG:super:  "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "put('0' + D.get[i])" 
 -- super:  "put('0' + D.get[i])" 
 -- E:  "put('0' + D.get[i])" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "put('0' + D.get[i])" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 210 "i: var integer{i := L + 1 - inx;put('0' + D.get[i])}" 
 -- IS.newDescNo: 210 IS.objSize: 2 "i: var integer{i := L + 1 - inx;put('0' + D.get[i])}" 
 -- OG:Qalloc:end: IS.newDescNo:  210 "i: var integer{   i := L + 1 - inx;   put('0' + D.get[i])}" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  28 3 %OSDvisibility skipInternal{%globals inSub;inx: var integer;inx := first;_doIt: do ;   if (inx <= last) :then ;    ...} 
 -- OG:super:  "for(first: var integer):to(last: var integer):repeat{repeat:< object}: {   %OSDvisibility skipInternal;   %globals inSub;   inx: var integer;   inx := first;   ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "for(1):to(L):repeat{   i: var integer;   i := L + 1 - inx;   put('0' + D.get[i]);}" 
 -- super:  "for(1):to(L):repeat{   i: var integer;   i := L + 1 - inx;   put('0' + D.get[i]);}" 
 -- E:  "for(1):to(L):repeat{   i: var integer;   i := L + 1 - inx;   put('0' + D.get[i]);}" 
 -- OG:Qalloc:B: "for:to:repeat$0" newDescNo: 0 objSize: 3 
 -- OG:isObjectDesc:NewDescNo: 213 IS.newDescNo: 213 objSize: 3 1: 1 "" 
 -- Items:Qalloc:objSize: 0  newDescNo: 213 "" 
 -- Items:Qalloc:super: "for(1):to(L):repeat{   i: var integer;   i := L + 1 - inx;   put('0' + D.get[i]);}" size: 3 "for:to:repeat$213" 
 -- super.isThisBlockLevel: false superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 4 originOff: 4 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 213 "" 
 -- IS.newDescNo: 213 IS.objSize: 3 "" 
 -- OG:Qalloc:end: IS.newDescNo:  213 "for(1):to(L):repeat{   i: var integer;   i := L + 1 - inx;   put('0' + D.get[i]);}" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 207 "%globals{in V: var integer;D: obj Indexed(20,#integer);L: var integer;isNeg: var Boolean;isNeg := V < 0;if (isNeg) :then ;   V ...}" 
 -- IS.newDescNo: 207 IS.objSize: 4 "%globals{in V: var integer;D: obj Indexed(20,#integer);L: var integer;isNeg: var Boolean;isNeg := V < 0;if (isNeg) :then ;   V := 0 - V;lo ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  207 "%globals{   in V: var integer;   D: obj Indexed(20,#integer);   L: var integer;   isNeg: var Boolean;   isNeg := V < 0;   if (isNeg) :th ...}" 
 -- OG:super:  "putint: {   %globals;   in V: var integer;   D: obj Indexed(20,#integer);   L: var integer;   isNeg: var Boolean;   isNeg := V < 0;   if (isNeg) :then ;      V ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "putint(V)" 
 -- super:  "putint(V)" 
 -- E:  "putint(V)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "putint(V)" 
 -- OG:Qalloc: "" = ".print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "" = ".print"  marked:  false "put(10){put('<');msg.print;putint(V);" = ".print;putint(res);put('>')}" super:  " = ".print 
 -- Invocation:Qalloc: "" = ".print" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  103 1 gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);} 
 -- OG:super:  "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "" = ".print" 
 -- super:  "" = ".print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "" = ".print" 
 -- OG:Qalloc: "putint(res)" qDescno:  0 
 -- OG:Qalloc:A:  "putint"  super:  "putint(res)"  marked:  false "put(10){put('<');msg.print;putint(V);" = ".print;putint(res);put('>')}" super:  putint(res) 
 -- Invocation:Qalloc: "putint(res)" 
 -- ObjectInvocation:Qalloc: "putint(res)" 
 -- name: "putint" 
 -- Arguments "putint(res)" 
 -- OG:Qalloc: "res" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "res"  marked:  false "putint(res)" super:  res 
 -- Invocation:Qalloc: "res" 
 -- ObjectInvocation:Qalloc: "res" 
 -- name: "res" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "res: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "res" 
 -- super:  "res" 
 -- E:  "res" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "res" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  207 4 %globals{in V: var integer;D: obj Indexed(20,#integer);L: var integer;isNeg: var Boolean;isNeg := V < 0;if (isNeg ...} 
 -- OG:super:  "putint: {   %globals;   in V: var integer;   D: obj Indexed(20,#integer);   L: var integer;   isNeg: var Boolean;   isNeg := V < 0;   if (isNeg) :then ;      V ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "putint(res)" 
 -- super:  "putint(res)" 
 -- E:  "putint(res)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "putint(res)" 
 -- OG:Qalloc: "put('>')" qDescno:  0 
 -- OG:Qalloc:A:  "put"  super:  "put('>')"  marked:  false "put(10){put('<');msg.print;putint(V);" = ".print;putint(res);put('>')}" super:  put('>') 
 -- Invocation:Qalloc: "put('>')" 
 -- ObjectInvocation:Qalloc: "put('>')" 
 -- name: "put" 
 -- Arguments "put('>')" 
 -- OG:Qalloc: "'>'" qDescno:  0 
 -- OG:Qalloc:A:  "char"  super:  "'>'"  marked:  false "put('>')" super:  '>' 
 -- Invocation:Qalloc: "'>'" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  7 1 %id "char"{%globals;%basic 3, 16;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var char;   out ...} 
 -- OG:super:  "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;      out R: v ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "'>'" 
 -- super:  "'>'" 
 -- E:  "'>'" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "'>'" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  105 1 %globals{%basic 2;in ch: val char} 
 -- OG:super:  "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "put('>')" 
 -- super:  "put('>')" 
 -- E:  "put('>')" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "put('>')" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 206 "put(10){put('<');msg.print;putint(V);" = ".print;putint(res);put('>')}" 
 -- IS.newDescNo: 206 IS.objSize: 4 "put(10){put('<');msg.print;putint(V);" = ".print;putint(res);put('>')}" 
 -- OG:Qalloc:end: IS.newDescNo:  206 "entry{   put(10);   put('<');   msg.print;   putint(V);   " = ".print;   putint(res);   put('>')}" 
 -- OG:super:  "putItem(msg: var String):value(V: var integer):res(res: var integer): entry{   put(10);   put('<');   msg.print;   putint(V);   " = ".print;   putint(res);   p ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "myM.putItem("Fac: "):value(inx):res(fac(inx))" 
 -- super:  "myM.putItem("Fac: "):value(inx):res(fac(inx))" 
 -- E:  "putItem("Fac: "):value(inx):res(fac(inx))" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "myM.putItem("Fac: "):value(inx):res(fac(inx))" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 201 "myM.putItem("Fac: "):value(inx):res(fac(inx))" 
 -- IS.newDescNo: 201 IS.objSize: 1 "myM.putItem("Fac: "):value(inx):res(fac(inx))" 
 -- OG:Qalloc:end: IS.newDescNo:  201 "myM.putItem("Fac: "):value(inx):res(fac(inx))" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  28 3 %OSDvisibility skipInternal{%globals inSub;inx: var integer;inx := first;_doIt: do ;   if (inx <= last) :then ;    ...} 
 -- OG:super:  "for(first: var integer):to(last: var integer):repeat{repeat:< object}: {   %OSDvisibility skipInternal;   %globals inSub;   inx: var integer;   inx := first;   ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "for(1):to(5):repeat{   myM.putItem("Fac: "):value(inx):res(fac(inx));}" 
 -- super:  "for(1):to(5):repeat{   myM.putItem("Fac: "):value(inx):res(fac(inx));}" 
 -- E:  "for(1):to(5):repeat{   myM.putItem("Fac: "):value(inx):res(fac(inx));}" 
 -- OG:Qalloc:B: "for:to:repeat$0" newDescNo: 0 objSize: 3 
 -- OG:isObjectDesc:NewDescNo: 214 IS.newDescNo: 214 objSize: 3 1: 1 "" 
 -- Items:Qalloc:objSize: 0  newDescNo: 214 "" 
 -- Items:Qalloc:super: "for(1):to(5):repeat{   myM.putItem("Fac: "):value(inx):res(fac(inx));}" size: 3 "for:to:repeat$214" 
 -- super.isThisBlockLevel: false superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 4 originOff: 4 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 214 "" 
 -- IS.newDescNo: 214 IS.objSize: 3 "" 
 -- OG:Qalloc:end: IS.newDescNo:  214 "for(1):to(5):repeat{   myM.putItem("Fac: "):value(inx):res(fac(inx));}" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 191 "fac(V: var integer): {   out res: var integer;   if (V = 1) :then ;      res := 1;   :else ;      res := V * fac(V - 1);myM.pr ...}" 
 -- IS.newDescNo: 191 IS.objSize: 4 "fac(V: var integer): {   out res: var integer;   if (V = 1) :then ;      res := 1;   :else ;      res := V * fac(V - 1);myM.print("P1 resu ..."}" 
 -- OG:Qalloc:end: IS.newDescNo:  191 "MonitorProcess("PP1"){   fac(V: var integer): ;      out res: var integer;      if (V = 1) :then ;         res := 1;      :else ;        ...}" 
 -- Items:Qalloc:objSize: 12  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 12  newDescNo: 0 "" 
 -- dataitem:qalloc: "myM" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 13 "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var integer): entry;      put(1 ...}" 
 -- OG:Qalloc: "Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var integer): entry;      put(10);      put('<' ...}" q ... 0 
 -- OG:Qalloc:A:  "myM"  super:  "Monitor"  marked:  false "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res ...}" s ... M ... 
 -- Invocation:Qalloc: "Monitor" 
 -- ObjectInvocation:Qalloc: "Monitor" 
 -- name: "Monitor" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %globals P_status, SQS, BasicSystemLib, Monitor, console, immutable, #MonitorProcess{%interface entry;mutex: obj Ba ...} 
 -- OG:Qalloc:SuperAlloc: "Monitor: {   %globals P_status, SQS, BasicSystemLib, Monitor, console, immutable, #MonitorProcess;   %interface entry;   mutex: obj BasicSystemLib.S ...}" 
 -- OG:Qalloc: "%globals P_status, SQS, BasicSystemLib, Monitor, console, immutable, #MonitorProcess{   %interface entry;   mutex: obj BasicSystemLib.SemaphoreLib.Semaphore(1) ...}" q ... 0 
 -- OG:Qalloc:A:  "Monitor"  super:  ""  marked:  false "Monitor: {   %globals P_status, SQS, BasicSystemLib, Monitor, console, immutable, #MonitorProcess;   %interface entry; ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%globals P_status, SQS, BasicSystemLib, Monitor, console, immutable, #MonitorProcess{   %interface entry;   mutex: obj BasicSystemLib.SemaphoreLib.Semaphore(1);   _V: var ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "Monitor" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 215 IS.newDescNo: 215 objSize: 0 1: 1 "%globals P_status, SQS, BasicSystemLib, Monitor, console, immutable, #MonitorProcess{%interface entry;mut ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 215 "%globals P_status, SQS, BasicSystemLib, Monitor, console, immutable, #MonitorProcess{%interface entry;mutex: obj BasicSystemLib.Se ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "mutex" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "mutex: obj BasicSystemLib.SemaphoreLib.Semaphore(1)" 
 -- OG:Qalloc: "BasicSystemLib.SemaphoreLib.Semaphore(1)" qDescno:  0 
 -- OG:Qalloc:A:  "Semaphore"  super:  "BasicSystemLib.SemaphoreLib.Semaphore(1)"  marked:  false "mutex: obj BasicSystemLib.SemaphoreLib.Semaphore(1)" super:  BasicSystemLib. ... 
 -- Invocation:Qalloc: "BasicSystemLib.SemaphoreLib.Semaphore(1)" 
 -- ObjectInvocation:Qalloc: "BasicSystemLib" 
 -- name: "BasicSystemLib" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "SemaphoreLib" 
 -- name: "SemaphoreLib" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "Semaphore(1)" 
 -- name: "Semaphore" 
 -- Arguments "Semaphore(1)" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "Semaphore(1)" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 -- Implementation of a counting semaphores{-- cnt is the initial value of the semaphore;-- requires: cnt > 0%global ...} 
 -- OG:Qalloc:SuperAlloc: "Semaphore(cnt: var integer): {   -- Implementation of a counting semaphores;   -- cnt is the initial value of the semaphore;   -- requires: cnt > 0% ...}" 
 -- OG:Qalloc: "-- Implementation of a counting semaphores{   -- cnt is the initial value of the semaphore;   -- requires: cnt > 0%globals;   %public;   wait: ;      theActive ...}" q ... 0 
 -- OG:Qalloc:A:  "Semaphore"  super:  ""  marked:  false "Semaphore(cnt: var integer): {   -- Implementation of a counting semaphores;   -- cnt is the initial value of the se ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "-- Implementation of a counting semaphores{   -- cnt is the initial value of the semaphore;   -- requires: cnt > 0%globals;   %public;   wait: ;      theActive: ref Gener ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "Semaphore" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 216 IS.newDescNo: 216 objSize: 0 1: 1 "-- Implementation of a counting semaphores{-- cnt is the initial value of the semaphore;-- requires: cnt  ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 216 "-- Implementation of a counting semaphores{-- cnt is the initial value of the semaphore;-- requires: cnt > 0%globals;%public;wait: ...}" 
 -- Items:Qalloc:Super:C:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 "%$B "("{cnt: var integer;%$E ")"}" 
 -- dataitem:qalloc: "cnt" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "%$B "("{cnt: var integer;%$E ")"}" 
 -- Pattern:Qalloc: wait 
 -- Pattern:Qalloc:B: wait 
 -- Pattern:Qalloc: signal 
 -- Pattern:Qalloc:B: signal 
 -- dataitem:qalloc: "M" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "M: obj Lock("M:Lock")" 
 -- OG:Qalloc: "Lock("M:Lock")" qDescno:  0 
 -- OG:Qalloc:A:  "Lock"  super:  "Lock("M:Lock")"  marked:  false "M: obj Lock("M:Lock")" super:  Lock("M:Lock") 
 -- Invocation:Qalloc: "Lock("M:Lock")" 
 -- ObjectInvocation:Qalloc: "Lock("M:Lock")" 
 -- name: "Lock" 
 -- Arguments "Lock("M:Lock")" 
 -- OG:Qalloc: ""M:Lock"" qDescno:  0 
 -- OG:Qalloc:A:  "String"  super:  ""M:Lock""  marked:  false "Lock("M:Lock")" super:  "M:Lock" 
 -- Invocation:Qalloc: ""M:Lock"" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  10 0 %id "String pattern"{%OSDvisibility disguised;%basic 5;%public;length: ;   out V: var integer;   V := get[0] -- ac ...} 
 -- OG:super:  "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- actually an  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""M:Lock"" 
 -- super:  ""M:Lock"" 
 -- E:  ""M:Lock"" 
 -- OG:Qalloc:end: IS.newDescNo:  0 ""M:Lock"" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  76 2 %globals{%Public;in id: var String;%private;free_M: var integer;%public;init: ;   free_M := 0;get: ;   loop: obj ; ...} 
 -- OG:super:  "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ;         ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Lock("M:Lock")" 
 -- super:  "Lock("M:Lock")" 
 -- E:  "Lock("M:Lock")" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Lock("M:Lock")" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- dataitem:qalloc: "Q" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 3 "Q: obj LIB.Collections.QueueLib.Queue" 
 -- OG:Qalloc: "LIB.Collections.QueueLib.Queue" qDescno:  0 
 -- OG:Qalloc:A:  "Queue"  super:  "LIB.Collections.QueueLib.Queue"  marked:  false "Q: obj LIB.Collections.QueueLib.Queue" super:  LIB.Collections.QueueLib.Queue 
 -- Invocation:Qalloc: "LIB.Collections.QueueLib.Queue" 
 -- ObjectInvocation:Qalloc: "LIB" 
 -- name: "LIB" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "Collections" 
 -- name: "Collections" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "QueueLib" 
 -- name: "QueueLib" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "Queue" 
 -- name: "Queue" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  78 5 %globals{idf: var LIB.StringLib.String;idc: var integer;noOfElm: var integer;Element: ;   in elm: ref Object;   ou ...} 
 -- OG:super:  "Queue: {   %globals;   idf: var LIB.StringLib.String;   idc: var integer;   noOfElm: var integer;   Element: ;      in elm: ref Object;      out res: ref Eleme ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "LIB.Collections.QueueLib.Queue" 
 -- super:  "LIB.Collections.QueueLib.Queue" 
 -- E:  "Queue" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "LIB.Collections.QueueLib.Queue" 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- Invocation:Qalloc: "Q.idf" 
 -- ObjectInvocation:Qalloc: "Q" 
 -- name: "Q" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "idf" 
 -- name: "idf" 
 -- Arguments "" 
 -- OG:Qalloc: ""Sem:"" qDescno:  0 
 -- OG:Qalloc:A:  "String"  super:  ""Sem:""  marked:  false "Q.idf := "Sem:"" super:  "Sem:" 
 -- Invocation:Qalloc: ""Sem:"" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  10 0 %id "String pattern"{%OSDvisibility disguised;%basic 5;%public;length: ;   out V: var integer;   V := get[0] -- ac ...} 
 -- OG:super:  "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- actually an  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""Sem:"" 
 -- super:  ""Sem:"" 
 -- E:  ""Sem:"" 
 -- OG:Qalloc:end: IS.newDescNo:  0 ""Sem:"" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 216 "-- Implementation of a counting semaphores{-- cnt is the initial value of the semaphore;-- requires: cnt > 0%globals;%public;w ...}" 
 -- IS.newDescNo: 216 IS.objSize: 3 "-- Implementation of a counting semaphores{-- cnt is the initial value of the semaphore;-- requires: cnt > 0%globals;%public;wait: ;   the ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  216 "-- Implementation of a counting semaphores{   -- cnt is the initial value of the semaphore;   -- requires: cnt > 0%globals;   %public;   ...}" 
 -- OG:super:  "Semaphore(cnt: var integer): {   -- Implementation of a counting semaphores;   -- cnt is the initial value of the semaphore;   -- requires: cnt > 0%globals;    ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "BasicSystemLib.SemaphoreLib.Semaphore(1)" 
 -- super:  "BasicSystemLib.SemaphoreLib.Semaphore(1)" 
 -- E:  "Semaphore(1)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "BasicSystemLib.SemaphoreLib.Semaphore(1)" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- dataitem:qalloc: "_V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- Pattern:Qalloc: init 
 -- Pattern:Qalloc:B: init 
 -- Pattern:Qalloc: entry 
 -- Pattern:Qalloc:B: entry 
 -- Pattern:Qalloc: wait 
 -- Pattern:Qalloc:B: wait 
 -- OG:Qalloc: "inner(Monitor)" qDescno:  0 
 -- OG:Qalloc:A:  "inner"  super:  "inner(Monitor)"  marked:  false "%globals P_status, SQS, BasicSystemLib, Monitor, console, immutable, #MonitorProcess{%interface entry;mute ...}" s ... i ... 
 -- Invocation:Qalloc: "inner(Monitor)" 
 -- ObjectInvocation:Qalloc: "inner(Monitor)" 
 -- name: "inner" 
 -- Arguments "inner(Monitor)" 
 -- OG:Qalloc: "Monitor" qDescno:  0 
 -- OG:Qalloc:A:  "Monitor"  super:  "Monitor"  marked:  false "inner(Monitor)" super:  Monitor 
 -- Invocation:Qalloc: "Monitor" 
 -- ObjectInvocation:Qalloc: "Monitor" 
 -- name: "Monitor" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  215 3 %globals P_status, SQS, BasicSystemLib, Monitor, console, immutable, #MonitorProcess{%interface entry;mutex: obj  ...} 
 -- OG:super:  "Monitor: {   %globals P_status, SQS, BasicSystemLib, Monitor, console, immutable, #MonitorProcess;   %interface entry;   mutex: obj BasicSystemLib.SemaphoreLib ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Monitor" 
 -- super:  "Monitor" 
 -- E:  "Monitor" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Monitor" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 %basic 101{in inner: ref Object} 
 -- OG:super:  "inner: {   %basic 101;   in inner: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(Monitor)" 
 -- super:  "inner(Monitor)" 
 -- E:  "inner(Monitor)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(Monitor)" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 215 "%globals P_status, SQS, BasicSystemLib, Monitor, console, immutable, #MonitorProcess{%interface entry;mutex: obj BasicSystemLi ...}" 
 -- IS.newDescNo: 215 IS.objSize: 3 "%globals P_status, SQS, BasicSystemLib, Monitor, console, immutable, #MonitorProcess{%interface entry;mutex: obj BasicSystemLib.SemaphoreL ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  215 "%globals P_status, SQS, BasicSystemLib, Monitor, console, immutable, #MonitorProcess{   %interface entry;   mutex: obj BasicSystemLib.Se ...}" 
 -- OG:super:  "Monitor: {   %globals P_status, SQS, BasicSystemLib, Monitor, console, immutable, #MonitorProcess;   %interface entry;   mutex: obj BasicSystemLib.SemaphoreLib ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var integer): entry;      put(10);      put('<');      msg ...}" 
 -- super:  "Monitor" 
 -- E:  "Monitor" 
 -- OG:Qalloc:B: "myM" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 217 IS.newDescNo: 217 objSize: 0 1: 1 "print(S: var String): entry{   S.print;putItem(msg: var String):value(V: var integer):res(res: var intege ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 217 "print(S: var String): entry{   S.print;putItem(msg: var String):value(V: var integer):res(res: var integer): entry;   put(10);   p ...}" 
 -- Items:Qalloc:super: "Monitor" size: 3 "myM" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 3 originOff: 1 
 -- Pattern:Qalloc: print 
 -- Pattern:Qalloc:B: print 
 -- Pattern:Qalloc: putItem:value:res 
 -- Pattern:Qalloc:B: putItem:value:res 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 217 "print(S: var String): entry{   S.print;putItem(msg: var String):value(V: var integer):res(res: var integer): entry;   put(10); ...}" 
 -- IS.newDescNo: 217 IS.objSize: 3 "print(S: var String): entry{   S.print;putItem(msg: var String):value(V: var integer):res(res: var integer): entry;   put(10);   put('<'); ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  217 "Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var integer): entry;     ...}" 
 -- Items:Qalloc:objSize: 13  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 13  newDescNo: 0 "" 
 -- dataitem:qalloc: "P2" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 14 "P2: obj MonitorProcess("PP2"){   sum(V: var integer): ;      out res: var integer;      for(1):to(10):repeat;         res := res + V;      ;   myM.print ...}" 
 -- OG:Qalloc: "MonitorProcess("PP2"){   sum(V: var integer): ;      out res: var integer;      for(1):to(10):repeat;         res := res + V;      ;   myM.print("P2 resumed\n" ...}" q ... 0 
 -- OG:Qalloc:A:  "P2"  super:  "MonitorProcess("PP2")"  marked:  false "P2: obj MonitorProcess("PP2"){   sum(V: var integer): ;      out res: var integer;      for(1):to(10): ...}" s ... M ... 
 -- Invocation:Qalloc: "MonitorProcess("PP2")" 
 -- ObjectInvocation:Qalloc: "MonitorProcess("PP2")" 
 -- name: "MonitorProcess" 
 -- Arguments "MonitorProcess("PP2")" 
 -- OG:Qalloc: ""PP2"" qDescno:  0 
 -- OG:Qalloc:A:  "String"  super:  ""PP2""  marked:  false "MonitorProcess("PP2")" super:  "PP2" 
 -- Invocation:Qalloc: ""PP2"" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  10 0 %id "String pattern"{%OSDvisibility disguised;%basic 5;%public;length: ;   out V: var integer;   V := get[0] -- ac ...} 
 -- OG:super:  "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- actually an  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""PP2"" 
 -- super:  ""PP2"" 
 -- E:  ""PP2"" 
 -- OG:Qalloc:end: IS.newDescNo:  0 ""PP2"" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  190 4 %globals Monitor, MonitorProcess(""), immutable, console{-- we need to find out how to restrict Process to have n ...} 
 -- OG:super:  "MonitorProcess: BasicProcess{   %globals Monitor, MonitorProcess(""), immutable, console;   -- we need to find out how to restrict Process to have no;   -- vis ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "MonitorProcess("PP2"){   sum(V: var integer): ;      out res: var integer;      for(1):to(10):repeat;         res := res + V;      ;   myM.print("P2 resumed\n");   for(1) ...}" 
 -- super:  "MonitorProcess("PP2")" 
 -- E:  "MonitorProcess("PP2")" 
 -- OG:Qalloc:B: "P2" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 218 IS.newDescNo: 218 objSize: 0 1: 1 "sum(V: var integer): {   out res: var integer;   for(1):to(10):repeat;      res := res + V;   ;myM.print( ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 218 "sum(V: var integer): {   out res: var integer;   for(1):to(10):repeat;      res := res + V;   ;myM.print("P2 resumed\n");for(1):to ...}" 
 -- Items:Qalloc:super: "MonitorProcess("PP2")" size: 4 "P2" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 4 originOff: 4 
 -- Pattern:Qalloc: sum 
 -- Pattern:Qalloc:B: sum 
 -- OG:Qalloc: "myM.print("P2 resumed\n")" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "myM.print("P2 resumed\n")"  marked:  false "sum(V: var integer): {   out res: var integer;   for(1):to(10):repeat;      res := res + V;   ; ...}" s ... m ... 
 -- Invocation:Qalloc: "myM.print("P2 resumed\n")" 
 -- ObjectInvocation:Qalloc: "myM" 
 -- name: "myM" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "print("P2 resumed\n")" 
 -- name: "print" 
 -- Arguments "print("P2 resumed\n")" 
 -- OG:Qalloc: ""P2 resumed\n"" qDescno:  0 
 -- OG:Qalloc:A:  "String"  super:  ""P2 resumed\n""  marked:  false "print("P2 resumed\n")" super:  "P2 resumed\n" 
 -- Invocation:Qalloc: ""P2 resumed\n"" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  10 0 %id "String pattern"{%OSDvisibility disguised;%basic 5;%public;length: ;   out V: var integer;   V := get[0] -- ac ...} 
 -- OG:super:  "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- actually an  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""P2 resumed\n"" 
 -- super:  ""P2 resumed\n"" 
 -- E:  ""P2 resumed\n"" 
 -- OG:Qalloc:end: IS.newDescNo:  0 ""P2 resumed\n"" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  200 2 S.print 
 -- OG:super:  "print(S: var String): entry{   S.print}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "myM.print("P2 resumed\n")" 
 -- super:  "myM.print("P2 resumed\n")" 
 -- E:  "print("P2 resumed\n")" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "myM.print("P2 resumed\n")" 
 -- OG:Qalloc: "for(1):to(6):repeat{   myM.putItem("Sum: "):value(inx):res(sum(inx));}" qDescno:  0 
 -- OG:Qalloc:A:  "for:to:repeat$0"  super:  "for(1):to(6):repeat{   myM.putItem("Sum: "):value(inx):res(sum(inx));}"  marked:  false "sum(V: var integer): {   out res: var in ...}" s ... f ... 
 -- Invocation:Qalloc: "for(1):to(6):repeat{   myM.putItem("Sum: "):value(inx):res(sum(inx));}" 
 -- ObjectInvocation:Qalloc: "for(1):to(6):repeat{   myM.putItem("Sum: "):value(inx):res(sum(inx));}" 
 -- name: "for:to:repeat" 
 -- Arguments "for(1):to(6):repeat{   myM.putItem("Sum: "):value(inx):res(sum(inx));}" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "for(1):to(6):repeat{   myM.putItem("Sum: "):value(inx):res(sum(inx));}" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- OG:Qalloc: "6" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "6"  marked:  false "for(1):to(6):repeat{   myM.putItem("Sum: "):value(inx):res(sum(inx));}" super:  6 
 -- Invocation:Qalloc: "6" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "6" 
 -- super:  "6" 
 -- E:  "6" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "6" 
 -- OG:Qalloc: "myM.putItem("Sum: "):value(inx):res(sum(inx))" qDescno:  0 
 -- OG:Qalloc:A:  "repeat$0"  super:  ""  marked:  false "for(1):to(6):repeat{   myM.putItem("Sum: "):value(inx):res(sum(inx));}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "myM.putItem("Sum: "):value(inx):res(sum(inx))" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "repeat$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 219 IS.newDescNo: 219 objSize: 0 1: 1 "myM.putItem("Sum: "):value(inx):res(sum(inx))" 
 -- Items:Qalloc:objSize: 0  newDescNo: 219 "myM.putItem("Sum: "):value(inx):res(sum(inx))" 
 -- Items:Qalloc:super: "" size: 1 "repeat$219" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- OG:Qalloc: "myM.putItem("Sum: "):value(inx):res(sum(inx))" qDescno:  0 
 -- OG:Qalloc:A:  "putItem:value:res"  super:  "myM.putItem("Sum: "):value(inx):res(sum(inx))"  marked:  false "myM.putItem("Sum: "):value(inx):res(sum(inx))" super:  myM.putI ... 
 -- Invocation:Qalloc: "myM.putItem("Sum: "):value(inx):res(sum(inx))" 
 -- ObjectInvocation:Qalloc: "myM" 
 -- name: "myM" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "putItem("Sum: "):value(inx):res(sum(inx))" 
 -- name: "putItem:value:res" 
 -- Arguments "putItem("Sum: "):value(inx):res(sum(inx))" 
 -- OG:Qalloc: ""Sum: "" qDescno:  0 
 -- OG:Qalloc:A:  "String"  super:  ""Sum: ""  marked:  false "putItem("Sum: "):value(inx):res(sum(inx))" super:  "Sum: " 
 -- Invocation:Qalloc: ""Sum: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  10 0 %id "String pattern"{%OSDvisibility disguised;%basic 5;%public;length: ;   out V: var integer;   V := get[0] -- ac ...} 
 -- OG:super:  "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- actually an  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""Sum: "" 
 -- super:  ""Sum: "" 
 -- E:  ""Sum: "" 
 -- OG:Qalloc:end: IS.newDescNo:  0 ""Sum: "" 
 -- OG:Qalloc: "inx" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "inx"  marked:  false "putItem("Sum: "):value(inx):res(sum(inx))" super:  inx 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "inx: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx" 
 -- super:  "inx" 
 -- E:  "inx" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx" 
 -- OG:Qalloc: "sum(inx)" qDescno:  0 
 -- OG:Qalloc:A:  "sum"  super:  "sum(inx)"  marked:  false "putItem("Sum: "):value(inx):res(sum(inx))" super:  sum(inx) 
 -- Invocation:Qalloc: "sum(inx)" 
 -- ObjectInvocation:Qalloc: "sum(inx)" 
 -- name: "sum" 
 -- Arguments "sum(inx)" 
 -- OG:Qalloc: "inx" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "inx"  marked:  false "sum(inx)" super:  inx 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "inx: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx" 
 -- super:  "inx" 
 -- E:  "inx" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 out res: var integer{for(1):to(10):repeat;   res := res + V;} 
 -- OG:Qalloc:SuperAlloc: "sum(V: var integer): {   out res: var integer;   for(1):to(10):repeat;      res := res + V;   }" 
 -- OG:Qalloc: "out res: var integer{   for(1):to(10):repeat;      res := res + V;   }" qDescno:  0 
 -- OG:Qalloc:A:  "sum"  super:  ""  marked:  false "sum(V: var integer): {   out res: var integer;   for(1):to(10):repeat;      res := res + V;   }" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "out res: var integer{   for(1):to(10):repeat;      res := res + V;   }" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "sum" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 220 IS.newDescNo: 220 objSize: 0 1: 1 "out res: var integer{for(1):to(10):repeat;   res := res + V;}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 220 "out res: var integer{for(1):to(10):repeat;   res := res + V;}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "%$B "("{V: var integer;%$E ")"}" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "%$B "("{V: var integer;%$E ")"}" 
 -- dataitem:qalloc: "res" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- OG:Qalloc: "for(1):to(10):repeat{   res := res + V;}" qDescno:  0 
 -- OG:Qalloc:A:  "for:to:repeat$0"  super:  "for(1):to(10):repeat{   res := res + V;}"  marked:  false "out res: var integer{for(1):to(10):repeat;   res := res + V;}" super:  ... f ... 
 -- Invocation:Qalloc: "for(1):to(10):repeat{   res := res + V;}" 
 -- ObjectInvocation:Qalloc: "for(1):to(10):repeat{   res := res + V;}" 
 -- name: "for:to:repeat" 
 -- Arguments "for(1):to(10):repeat{   res := res + V;}" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "for(1):to(10):repeat{   res := res + V;}" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- OG:Qalloc: "10" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "10"  marked:  false "for(1):to(10):repeat{   res := res + V;}" super:  10 
 -- Invocation:Qalloc: "10" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "10" 
 -- super:  "10" 
 -- E:  "10" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "10" 
 -- OG:Qalloc: "res := res + V" qDescno:  0 
 -- OG:Qalloc:A:  "repeat$0"  super:  ""  marked:  false "for(1):to(10):repeat{   res := res + V;}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "res := res + V" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "repeat$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 221 IS.newDescNo: 221 objSize: 0 1: 1 "res := res + V" 
 -- Items:Qalloc:objSize: 0  newDescNo: 221 "res := res + V" 
 -- Items:Qalloc:super: "" size: 1 "repeat$221" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "res" 
 -- ObjectInvocation:Qalloc: "res" 
 -- name: "res" 
 -- Arguments "" 
 -- OG:Qalloc: "res + V" qDescno:  0 
 -- OG:Qalloc:A:  "+"  super:  "res + V"  marked:  false "res := res + V" super:  res + V 
 -- Invocation:Qalloc: "res + V" 
 -- BinaryExp:Qalloc: "res + V" 
 -- Invocation:Qalloc: "res" 
 -- ObjectInvocation:Qalloc: "res" 
 -- name: "res" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "+ V" 
 -- name: "+" 
 -- Arguments "V" 
 -- OG:Qalloc: "V" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "V"  marked:  false "V" super:  V 
 -- Invocation:Qalloc: "V" 
 -- ObjectInvocation:Qalloc: "V" 
 -- name: "V" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "V: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "V" 
 -- super:  "V" 
 -- E:  "V" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "V" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  49 5 %basic 61{in V: var integer;out R: var integer} 
 -- OG:super:  "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "res + V" 
 -- super:  "res + V" 
 -- E:  "res + V" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "res + V" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 221 "res := res + V" 
 -- IS.newDescNo: 221 IS.objSize: 1 "res := res + V" 
 -- OG:Qalloc:end: IS.newDescNo:  221 "res := res + V" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  28 3 %OSDvisibility skipInternal{%globals inSub;inx: var integer;inx := first;_doIt: do ;   if (inx <= last) :then ;    ...} 
 -- OG:super:  "for(first: var integer):to(last: var integer):repeat{repeat:< object}: {   %OSDvisibility skipInternal;   %globals inSub;   inx: var integer;   inx := first;   ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "for(1):to(10):repeat{   res := res + V;}" 
 -- super:  "for(1):to(10):repeat{   res := res + V;}" 
 -- E:  "for(1):to(10):repeat{   res := res + V;}" 
 -- OG:Qalloc:B: "for:to:repeat$0" newDescNo: 0 objSize: 3 
 -- OG:isObjectDesc:NewDescNo: 222 IS.newDescNo: 222 objSize: 3 1: 1 "" 
 -- Items:Qalloc:objSize: 0  newDescNo: 222 "" 
 -- Items:Qalloc:super: "for(1):to(10):repeat{   res := res + V;}" size: 3 "for:to:repeat$222" 
 -- super.isThisBlockLevel: false superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 4 originOff: 4 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 222 "" 
 -- IS.newDescNo: 222 IS.objSize: 3 "" 
 -- OG:Qalloc:end: IS.newDescNo:  222 "for(1):to(10):repeat{   res := res + V;}" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 220 "out res: var integer{for(1):to(10):repeat;   res := res + V;}" 
 -- IS.newDescNo: 220 IS.objSize: 3 "out res: var integer{for(1):to(10):repeat;   res := res + V;}" 
 -- OG:Qalloc:end: IS.newDescNo:  220 "out res: var integer{   for(1):to(10):repeat;      res := res + V;   }" 
 -- OG:super:  "sum(V: var integer): {   out res: var integer;   for(1):to(10):repeat;      res := res + V;   }" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "sum(inx)" 
 -- super:  "sum(inx)" 
 -- E:  "sum(inx)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "sum(inx)" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  206 4 put(10){put('<');msg.print;putint(V);" = ".print;putint(res);put('>')} 
 -- OG:super:  "putItem(msg: var String):value(V: var integer):res(res: var integer): entry{   put(10);   put('<');   msg.print;   putint(V);   " = ".print;   putint(res);   p ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "myM.putItem("Sum: "):value(inx):res(sum(inx))" 
 -- super:  "myM.putItem("Sum: "):value(inx):res(sum(inx))" 
 -- E:  "putItem("Sum: "):value(inx):res(sum(inx))" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "myM.putItem("Sum: "):value(inx):res(sum(inx))" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 219 "myM.putItem("Sum: "):value(inx):res(sum(inx))" 
 -- IS.newDescNo: 219 IS.objSize: 1 "myM.putItem("Sum: "):value(inx):res(sum(inx))" 
 -- OG:Qalloc:end: IS.newDescNo:  219 "myM.putItem("Sum: "):value(inx):res(sum(inx))" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  28 3 %OSDvisibility skipInternal{%globals inSub;inx: var integer;inx := first;_doIt: do ;   if (inx <= last) :then ;    ...} 
 -- OG:super:  "for(first: var integer):to(last: var integer):repeat{repeat:< object}: {   %OSDvisibility skipInternal;   %globals inSub;   inx: var integer;   inx := first;   ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "for(1):to(6):repeat{   myM.putItem("Sum: "):value(inx):res(sum(inx));}" 
 -- super:  "for(1):to(6):repeat{   myM.putItem("Sum: "):value(inx):res(sum(inx));}" 
 -- E:  "for(1):to(6):repeat{   myM.putItem("Sum: "):value(inx):res(sum(inx));}" 
 -- OG:Qalloc:B: "for:to:repeat$0" newDescNo: 0 objSize: 3 
 -- OG:isObjectDesc:NewDescNo: 223 IS.newDescNo: 223 objSize: 3 1: 1 "" 
 -- Items:Qalloc:objSize: 0  newDescNo: 223 "" 
 -- Items:Qalloc:super: "for(1):to(6):repeat{   myM.putItem("Sum: "):value(inx):res(sum(inx));}" size: 3 "for:to:repeat$223" 
 -- super.isThisBlockLevel: false superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 4 originOff: 4 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 223 "" 
 -- IS.newDescNo: 223 IS.objSize: 3 "" 
 -- OG:Qalloc:end: IS.newDescNo:  223 "for(1):to(6):repeat{   myM.putItem("Sum: "):value(inx):res(sum(inx));}" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 218 "sum(V: var integer): {   out res: var integer;   for(1):to(10):repeat;      res := res + V;   ;myM.print("P2 resumed\n");for(1 ...}" 
 -- IS.newDescNo: 218 IS.objSize: 4 "sum(V: var integer): {   out res: var integer;   for(1):to(10):repeat;      res := res + V;   ;myM.print("P2 resumed\n");for(1):to(6):repe ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  218 "MonitorProcess("PP2"){   sum(V: var integer): ;      out res: var integer;      for(1):to(10):repeat;         res := res + V;      ;   m ...}" 
 -- Items:Qalloc:objSize: 14  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 14  newDescNo: 0 "" 
 -- OG:Qalloc: "myM.init" qDescno:  0 
 -- OG:Qalloc:A:  "init"  super:  "myM.init"  marked:  false "%requires MonitorSystemLib{%include LIB.StringLib;P1: obj MonitorProcess("PP1");   fac(V: var integer): ;      ou ...}" s ... m ... 
 -- Invocation:Qalloc: "myM.init" 
 -- ObjectInvocation:Qalloc: "myM" 
 -- name: "myM" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "init" 
 -- name: "init" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 "Monitor:init\n".print{inner(init)} 
 -- OG:Qalloc:SuperAlloc: "init:< entry{   "Monitor:init\n".print;   inner(init)}" 
 -- OG:Qalloc: "entry{   "Monitor:init\n".print;   inner(init)}" qDescno:  0 
 -- OG:Qalloc:A:  "init"  super:  "entry"  marked:  false "init:< entry{   "Monitor:init\n".print;   inner(init)}" super:  entry 
 -- Invocation:Qalloc: "entry" 
 -- ObjectInvocation:Qalloc: "entry" 
 -- name: "entry" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  192 1 %kind method{%arguments value, immutable;mutex.wait;_V := _V + 1;inner(entry);mutex.signal} 
 -- OG:super:  "entry: {   %kind method;   %arguments value, immutable;   mutex.wait;   _V := _V + 1;   inner(entry);   mutex.signal}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "entry{   "Monitor:init\n".print;   inner(init)}" 
 -- super:  "entry" 
 -- E:  "entry" 
 -- OG:Qalloc:B: "init" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 224 IS.newDescNo: 224 objSize: 0 1: 1 ""Monitor:init\n".print{inner(init)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 224 ""Monitor:init\n".print{inner(init)}" 
 -- Items:Qalloc:super: "entry" size: 1 "init" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- OG:Qalloc: ""Monitor:init\n".print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  ""Monitor:init\n".print"  marked:  false ""Monitor:init\n".print{inner(init)}" super:  "Monitor:init\n".print 
 -- Invocation:Qalloc: ""Monitor:init\n".print" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  103 1 gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);} 
 -- OG:super:  "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""Monitor:init\n".print" 
 -- super:  ""Monitor:init\n".print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 ""Monitor:init\n".print" 
 -- OG:Qalloc: "inner(init)" qDescno:  0 
 -- OG:Qalloc:A:  "inner"  super:  "inner(init)"  marked:  false ""Monitor:init\n".print{inner(init)}" super:  inner(init) 
 -- Invocation:Qalloc: "inner(init)" 
 -- ObjectInvocation:Qalloc: "inner(init)" 
 -- name: "inner" 
 -- Arguments "inner(init)" 
 -- OG:Qalloc: "init" qDescno:  0 
 -- OG:Qalloc:A:  "init"  super:  "init"  marked:  false "inner(init)" super:  init 
 -- Invocation:Qalloc: "init" 
 -- ObjectInvocation:Qalloc: "init" 
 -- name: "init" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  224 1 "Monitor:init\n".print{inner(init)} 
 -- OG:super:  "init:< entry{   "Monitor:init\n".print;   inner(init)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "init" 
 -- super:  "init" 
 -- E:  "init" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "init" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 %basic 101{in inner: ref Object} 
 -- OG:super:  "inner: {   %basic 101;   in inner: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(init)" 
 -- super:  "inner(init)" 
 -- E:  "inner(init)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(init)" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 224 ""Monitor:init\n".print{inner(init)}" 
 -- IS.newDescNo: 224 IS.objSize: 1 ""Monitor:init\n".print{inner(init)}" 
 -- OG:Qalloc:end: IS.newDescNo:  224 "entry{   "Monitor:init\n".print;   inner(init)}" 
 -- OG:super:  "init:< entry{   "Monitor:init\n".print;   inner(init)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "myM.init" 
 -- super:  "myM.init" 
 -- E:  "init" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "myM.init" 
 -- OG:Qalloc: "P1.start" qDescno:  0 
 -- OG:Qalloc:A:  "start"  super:  "P1.start"  marked:  false "%requires MonitorSystemLib{%include LIB.StringLib;P1: obj MonitorProcess("PP1");   fac(V: var integer): ;      o ...}" s ... P ... 
 -- Invocation:Qalloc: "P1.start" 
 -- ObjectInvocation:Qalloc: "P1" 
 -- name: "P1" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "start" 
 -- name: "start" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 --P: ref Process{--P := this(MonitorProcess);--("starting: " + id + "\n").print;--SQS.insert(P)} 
 -- OG:Qalloc:SuperAlloc: "start:: {   --P: ref Process;   --P := this(MonitorProcess);   --("starting: " + id + "\n").print;   --SQS.insert(P)}" 
 -- OG:Qalloc: "--P: ref Process{   --P := this(MonitorProcess);   --("starting: " + id + "\n").print;   --SQS.insert(P)}" qDescno:  0 
 -- OG:Qalloc:A:  "start"  super:  ""  marked:  false "start:: {   --P: ref Process;   --P := this(MonitorProcess);   --("starting: " + id + "\n").print;   --SQS.insert(P)}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  160 1 status := p_status.ACTIVE{SQS.insert(this(BasicProcess));inner(start)} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "--P: ref Process{   --P := this(MonitorProcess);   --("starting: " + id + "\n").print;   --SQS.insert(P)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "start" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 225 IS.newDescNo: 225 objSize: 0 1: 1 "--P: ref Process{--P := this(MonitorProcess);--("starting: " + id + "\n").print;--SQS.insert(P)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 225 "--P: ref Process{--P := this(MonitorProcess);--("starting: " + id + "\n").print;--SQS.insert(P)}" 
 -- Items:Qalloc:super: "" size: 1 "start" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 225 "--P: ref Process{--P := this(MonitorProcess);--("starting: " + id + "\n").print;--SQS.insert(P)}" 
 -- IS.newDescNo: 225 IS.objSize: 1 "--P: ref Process{--P := this(MonitorProcess);--("starting: " + id + "\n").print;--SQS.insert(P)}" 
 -- OG:Qalloc:end: IS.newDescNo:  225 "--P: ref Process{   --P := this(MonitorProcess);   --("starting: " + id + "\n").print;   --SQS.insert(P)}" 
 -- OG:super:  "start:: {   --P: ref Process;   --P := this(MonitorProcess);   --("starting: " + id + "\n").print;   --SQS.insert(P)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "P1.start" 
 -- super:  "P1.start" 
 -- E:  "start" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "P1.start" 
 -- OG:Qalloc: "P2.start" qDescno:  0 
 -- OG:Qalloc:A:  "start"  super:  "P2.start"  marked:  false "%requires MonitorSystemLib{%include LIB.StringLib;P1: obj MonitorProcess("PP1");   fac(V: var integer): ;      o ...}" s ... P ... 
 -- Invocation:Qalloc: "P2.start" 
 -- ObjectInvocation:Qalloc: "P2" 
 -- name: "P2" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "start" 
 -- name: "start" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  225 1 --P: ref Process{--P := this(MonitorProcess);--("starting: " + id + "\n").print;--SQS.insert(P)} 
 -- OG:super:  "start:: {   --P: ref Process;   --P := this(MonitorProcess);   --("starting: " + id + "\n").print;   --SQS.insert(P)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "P2.start" 
 -- super:  "P2.start" 
 -- E:  "start" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "P2.start" 
 -- Items:Qalloc:END:objSize: 14  newDescNo: 189 "%requires MonitorSystemLib{%include LIB.StringLib;P1: obj MonitorProcess("PP1");   fac(V: var integer): ;      out res: var i ...}" 
 -- IS.newDescNo: 189 IS.objSize: 14 "%requires MonitorSystemLib{%include LIB.StringLib;P1: obj MonitorProcess("PP1");   fac(V: var integer): ;      out res: var integer;      ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  189 "LIB.MonitorSystemLib.MonitorSystem{   %requires MonitorSystemLib;   %include LIB.StringLib;   P1: obj MonitorProcess("PP1");      fac(V: ...}" 
 -- ObjTmpStack:add: "MonitorDemo" : "LIB.MonitorSystemLib.MonitorSystem{   %requires MonitorSystemLib;   %include LIB.StringLib;   P1: obj MonitorProcess("PP1");      fac(V:  ...}" 
 -- items:markForCodeGen: "%requires MonitorSystemLib{%include LIB.StringLib;P1: obj MonitorProcess("PP1");   fac(V: var integer): ;      out res: var integer;      if (V = 1) ...}" 
 -- markItem: "%requires MonitorSystemLib" Property 
 -- markItem: "%include LIB.StringLib" Property 
 -- DataItem:markForCodeGen: "P1" :descNo: 191 :OG.primNo: 0 
 -- OG:markForCodeGen: "MonitorProcess("PP1"){   fac(V: var integer): ;      out res: var integer;      if (V = 1) :then ;         res := 1;      :else ;         res := V * fa ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "MonitorProcess("PP1")" 
 -- "MonitorProcess("PP1")" false 
 -- 
 -- OG:markSuper: "MonitorProcess("PP1")" 
 -- Invocation:markForCodeGen: "MonitorProcess("PP1")" 
 -- ObjectInvocation:markForCodeGen: "MonitorProcess("PP1")"  ATd: "MonitorProcess: BasicProcess{   %globals Monitor, MonitorProcess(""), immutable, console;   -- we need to f ...}" 
 -- Pattern:markForCodeGen: "MonitorProcess: BasicProcess{   %globals Monitor, MonitorProcess(""), immutable, console;   -- we need to find out how to restrict Process to have ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "BasicProcess{   %globals Monitor, MonitorProcess(""), immutable, console;   -- we need to find out how to restrict Process to have no;   -- visible int ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "BasicProcess" 
 -- "BasicProcess" false 
 -- 
 -- OG:markSuper: "BasicProcess" 
 -- Invocation:markForCodeGen: "BasicProcess" 
 -- ObjectInvocation:markForCodeGen: "BasicProcess"  ATd: "BasicProcess: GeneralProcess{   mkActive::< ;      -- start and mkActive are identical and one may be eliminatedstat ...}" 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "BasicProcess{   %globals Monitor, MonitorProcess(""), immutable, console;   -- we need to find out how to restrict Process to have no;   -- visible interface.  ...}" 
 -- OG:Qalloc: "BasicProcess{   %globals Monitor, MonitorProcess(""), immutable, console;   -- we need to find out how to restrict Process to have no;   -- visible interface.  ...}" q ... 190 
 -- ObjTmpStack:add: "MonitorProcess" : "BasicProcess{   %globals Monitor, MonitorProcess(""), immutable, console;   -- we need to find out how to restrict Process to have no; ...}" 
 -- items:markForCodeGen: "%globals Monitor, MonitorProcess(""), immutable, console{-- we need to find out how to restrict Process to have no;-- visible interface. Perhaps ret ...}" 
 -- markItem: "%globals Monitor, MonitorProcess(""), immutable, console{-- we need to find out how to restrict Process to have no;-- visible interface. Perhaps rethink the use ...}" P ... 
 -- markItem: "%public" Property 
 -- Pattern:markForCodeGen: "start:: {   --P: ref Process;   --P := this(MonitorProcess);   --("starting: " + id + "\n").print;   --SQS.insert(P)}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "--P: ref Process{   --P := this(MonitorProcess);   --("starting: " + id + "\n").print;   --SQS.insert(P)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "--P: ref Process{   --P := this(MonitorProcess);   --("starting: " + id + "\n").print;   --SQS.insert(P)}" 
 -- OG:Qalloc: "--P: ref Process{   --P := this(MonitorProcess);   --("starting: " + id + "\n").print;   --SQS.insert(P)}" qDescno:  225 
 -- ObjTmpStack:add: "start" : "--P: ref Process{   --P := this(MonitorProcess);   --("starting: " + id + "\n").print;   --SQS.insert(P)}" 
 -- items:markForCodeGen: "--P: ref Process{--P := this(MonitorProcess);--("starting: " + id + "\n").print;--SQS.insert(P)}" 
 -- markItem: "inner(MonitorProcess)" ObjectGenerator 
 -- OI:args:markForCodgen: "MonitorProcess("PP1")" 
 -- OG:markForCodeGen: ""PP1"" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- ""PP1"" 
 -- ""PP1"" true 
 -- 
 -- OG:markSuper: ""PP1"" 
 -- Invocation:markForCodeGen: ""PP1"" 
 -- not ObjDesc:  ""PP1""  IS.isEmpty:  true 
 -- arg:   ""PP1"" 
 -- OG:markIS: "MonitorProcess("PP1"){   fac(V: var integer): ;      out res: var integer;      if (V = 1) :then ;         res := 1;      :else ;         res := V * fac(V - 1) ...}" 
 -- OG:Qalloc: "MonitorProcess("PP1"){   fac(V: var integer): ;      out res: var integer;      if (V = 1) :then ;         res := 1;      :else ;         res := V * fac(V - 1) ...}" q ... 191 
 -- ObjTmpStack:add: "P1" : "MonitorProcess("PP1"){   fac(V: var integer): ;      out res: var integer;      if (V = 1) :then ;         res := 1;      :else ;         res := V ...}" 
 -- items:markForCodeGen: "fac(V: var integer): {   out res: var integer;   if (V = 1) :then ;      res := 1;   :else ;      res := V * fac(V - 1);myM.print("P1 resumed\n");fo ...}" 
 -- markItem: "myM.print("P1 resumed\n")" ObjectGenerator 
 -- OG:markForCodeGen: "myM.print("P1 resumed\n")" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "myM.print("P1 resumed\n")" 
 -- "myM" false 
 -- "print("P1 resumed\n")" false 
 -- 
 -- OG:markSuper: "myM.print("P1 resumed\n")" 
 -- Invocation:markForCodeGen: "myM.print("P1 resumed\n")" 
 -- ObjectInvocation:markForCodeGen: "myM"  ATd: "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var  ...}" 
 -- DataItem:markForCodeGen: "myM" :descNo: 217 :OG.primNo: 0 
 -- OG:markForCodeGen: "Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var integer): entry;      put(10);      ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Monitor" 
 -- "Monitor" false 
 -- 
 -- OG:markSuper: "Monitor" 
 -- Invocation:markForCodeGen: "Monitor" 
 -- ObjectInvocation:markForCodeGen: "Monitor"  ATd: "Monitor: {   %globals P_status, SQS, BasicSystemLib, Monitor, console, immutable, #MonitorProcess;   %interface entry;    ...}" 
 -- Pattern:markForCodeGen: "Monitor: {   %globals P_status, SQS, BasicSystemLib, Monitor, console, immutable, #MonitorProcess;   %interface entry;   mutex: obj BasicSystemLib ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "%globals P_status, SQS, BasicSystemLib, Monitor, console, immutable, #MonitorProcess{   %interface entry;   mutex: obj BasicSystemLib.SemaphoreLib.Sema ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%globals P_status, SQS, BasicSystemLib, Monitor, console, immutable, #MonitorProcess{   %interface entry;   mutex: obj BasicSystemLib.SemaphoreLib.Semaphore(1) ...}" 
 -- OG:Qalloc: "%globals P_status, SQS, BasicSystemLib, Monitor, console, immutable, #MonitorProcess{   %interface entry;   mutex: obj BasicSystemLib.SemaphoreLib.Semaphore(1) ...}" q ... 215 
 -- ObjTmpStack:add: "Monitor" : "%globals P_status, SQS, BasicSystemLib, Monitor, console, immutable, #MonitorProcess{   %interface entry;   mutex: obj BasicSystemLib.Semapho ...}" 
 -- items:markForCodeGen: "%globals P_status, SQS, BasicSystemLib, Monitor, console, immutable, #MonitorProcess{%interface entry;mutex: obj BasicSystemLib.SemaphoreLib.Semapho ...}" 
 -- markItem: "%globals P_status, SQS, BasicSystemLib, Monitor, console, immutable, #MonitorProcess" Property 
 -- markItem: "%interface entry" Property 
 -- DataItem:markForCodeGen: "mutex" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "BasicSystemLib.SemaphoreLib.Semaphore(1)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "BasicSystemLib.SemaphoreLib.Semaphore(1)" 
 -- "BasicSystemLib" false 
 -- "SemaphoreLib" false 
 -- "Semaphore(1)" false 
 -- 
 -- OG:markSuper: "BasicSystemLib.SemaphoreLib.Semaphore(1)" 
 -- Invocation:markForCodeGen: "BasicSystemLib.SemaphoreLib.Semaphore(1)" 
 -- ObjectInvocation:markForCodeGen: "BasicSystemLib"  ATd: "--BasicSystemLib{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "SemaphoreLib"  ATd: "--SemaphoreLib{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "Semaphore(1)"  ATd: "Semaphore(cnt: var integer): {   -- Implementation of a counting semaphores;   -- cnt is the initial value of the se ...}" 
 -- Pattern:markForCodeGen: "Semaphore(cnt: var integer): {   -- Implementation of a counting semaphores;   -- cnt is the initial value of the semaphore;   -- requires: cnt >  ...}" 
 -- items:markForCodeGen: "%$B "("{cnt: var integer;%$E ")"}" 
 -- markItem: "%$B "("" Property 
 -- DataItem:markForCodeGen: "cnt" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- markItem: "%$E ")"" Property 
 -- OG:markForCodeGen: "-- Implementation of a counting semaphores{   -- cnt is the initial value of the semaphore;   -- requires: cnt > 0%globals;   %public;   wait: ;      t ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "-- Implementation of a counting semaphores{   -- cnt is the initial value of the semaphore;   -- requires: cnt > 0%globals;   %public;   wait: ;      theActive ...}" 
 -- OG:Qalloc: "-- Implementation of a counting semaphores{   -- cnt is the initial value of the semaphore;   -- requires: cnt > 0%globals;   %public;   wait: ;      theActive ...}" q ... 216 
 -- ObjTmpStack:add: "Semaphore(cnt: var integer)" : "-- Implementation of a counting semaphores{   -- cnt is the initial value of the semaphore;   -- requires: cnt > 0%global ...}" 
 -- items:markForCodeGen: "-- Implementation of a counting semaphores{-- cnt is the initial value of the semaphore;-- requires: cnt > 0%globals;%public;wait: ;   theActive: re ...}" 
 -- markItem: "%globals" Property 
 -- markItem: "%public" Property 
 -- markItem: "%private" Property 
 -- DataItem:markForCodeGen: "M" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Lock("M:Lock")" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Lock("M:Lock")" 
 -- "Lock("M:Lock")" false 
 -- 
 -- OG:markSuper: "Lock("M:Lock")" 
 -- Invocation:markForCodeGen: "Lock("M:Lock")" 
 -- ObjectInvocation:markForCodeGen: "Lock("M:Lock")"  ATd: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      f ...}" 
 -- OI:args:markForCodgen: "Lock("M:Lock")" 
 -- OG:markForCodeGen: ""M:Lock"" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- ""M:Lock"" 
 -- ""M:Lock"" true 
 -- 
 -- OG:markSuper: ""M:Lock"" 
 -- Invocation:markForCodeGen: ""M:Lock"" 
 -- not ObjDesc:  ""M:Lock""  IS.isEmpty:  true 
 -- arg:   ""M:Lock"" 
 -- not ObjDesc:  "Lock("M:Lock")"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "Q" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "LIB.Collections.QueueLib.Queue" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "LIB.Collections.QueueLib.Queue" 
 -- "LIB" false 
 -- "Collections" false 
 -- "QueueLib" false 
 -- "Queue" false 
 -- 
 -- OG:markSuper: "LIB.Collections.QueueLib.Queue" 
 -- Invocation:markForCodeGen: "LIB.Collections.QueueLib.Queue" 
 -- ObjectInvocation:markForCodeGen: "LIB"  ATd: "--LIB{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "Collections"  ATd: "--Collections{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "QueueLib"  ATd: "--QueueLib{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "Queue"  ATd: "Queue: {   %globals;   idf: var LIB.StringLib.String;   idc: var integer;   noOfElm: var integer;   Element: ;      in elm: ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "LIB.Collections.QueueLib.Queue"  IS.isEmpty:  true 
 -- markItem: "Q.idf := "Sem:"" Assign 
 -- Invocation:markForCodeGen: "Q.idf" 
 -- ObjectInvocation:markForCodeGen: "Q"  ATd: "Q: obj LIB.Collections.QueueLib.Queue" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "idf"  ATd: "idf: var LIB.StringLib.String" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: ""Sem:"" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- ""Sem:"" 
 -- ""Sem:"" true 
 -- 
 -- OG:markSuper: ""Sem:"" 
 -- Invocation:markForCodeGen: ""Sem:"" 
 -- not ObjDesc:  ""Sem:""  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "Semaphore(1)" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- arg:   "1" 
 -- not ObjDesc:  "BasicSystemLib.SemaphoreLib.Semaphore(1)"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "_V" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- markItem: "%public" Property 
 -- Pattern:markForCodeGen: "init:< entry{   "Monitor:init\n".print;   inner(init)}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "entry{   "Monitor:init\n".print;   inner(init)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "entry" 
 -- "entry" false 
 -- 
 -- OG:markSuper: "entry" 
 -- Invocation:markForCodeGen: "entry" 
 -- ObjectInvocation:markForCodeGen: "entry"  ATd: "entry: {   %kind method;   %arguments value, immutable;   mutex.wait;   _V := _V + 1;   inner(entry);   mutex.signal}" 
 -- Pattern:markForCodeGen: "entry: {   %kind method;   %arguments value, immutable;   mutex.wait;   _V := _V + 1;   inner(entry);   mutex.signal}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "%kind method{   %arguments value, immutable;   mutex.wait;   _V := _V + 1;   inner(entry);   mutex.signal}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%kind method{   %arguments value, immutable;   mutex.wait;   _V := _V + 1;   inner(entry);   mutex.signal}" 
 -- OG:Qalloc: "%kind method{   %arguments value, immutable;   mutex.wait;   _V := _V + 1;   inner(entry);   mutex.signal}" qDescno:  192 
 -- ObjTmpStack:add: "entry" : "%kind method{   %arguments value, immutable;   mutex.wait;   _V := _V + 1;   inner(entry);   mutex.signal}" 
 -- items:markForCodeGen: "%kind method{%arguments value, immutable;mutex.wait;_V := _V + 1;inner(entry);mutex.signal}" 
 -- markItem: "%kind method" Property 
 -- markItem: "%arguments value, immutable" Property 
 -- markItem: "mutex.wait" ObjectGenerator 
 -- OG:markForCodeGen: "mutex.wait" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "mutex.wait" 
 -- "mutex" false 
 -- "wait" false 
 -- 
 -- OG:markSuper: "mutex.wait" 
 -- Invocation:markForCodeGen: "mutex.wait" 
 -- ObjectInvocation:markForCodeGen: "mutex"  ATd: "mutex: obj BasicSystemLib.SemaphoreLib.Semaphore(1)" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "wait"  ATd: "wait: {   theActive: ref GeneralProcess;   M.get;   cnt := cnt - 1;   if (cnt < 0) :then ;      disable;      theActive := t ...}" 
 -- Pattern:markForCodeGen: "wait: {   theActive: ref GeneralProcess;   M.get;   cnt := cnt - 1;   if (cnt < 0) :then ;      disable;      theActive := thisCore.main.active;   ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "theActive: ref GeneralProcess{   M.get;   cnt := cnt - 1;   if (cnt < 0) :then ;      disable;      theActive := thisCore.main.active;      Q.insert(th ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "theActive: ref GeneralProcess{   M.get;   cnt := cnt - 1;   if (cnt < 0) :then ;      disable;      theActive := thisCore.main.active;      Q.insert(theActive) ...}" 
 -- OG:Qalloc: "theActive: ref GeneralProcess{   M.get;   cnt := cnt - 1;   if (cnt < 0) :then ;      disable;      theActive := thisCore.main.active;      Q.insert(theActive) ...}" q ... 193 
 -- ObjTmpStack:add: "wait" : "theActive: ref GeneralProcess{   M.get;   cnt := cnt - 1;   if (cnt < 0) :then ;      disable;      theActive := thisCore.main.active;      Q.in ...}" 
 -- items:markForCodeGen: "theActive: ref GeneralProcess{M.get;cnt := cnt - 1;if (cnt < 0) :then ;   disable;   theActive := thisCore.main.active;   Q.insert(theActive);   ena ...}" 
 -- DataItem:markForCodeGen: "theActive" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "GeneralProcess" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "GeneralProcess" 
 -- "GeneralProcess" false 
 -- 
 -- not ObjDesc:  "GeneralProcess"  IS.isEmpty:  true 
 -- markItem: "M.get" ObjectGenerator 
 -- OG:markForCodeGen: "M.get" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "M.get" 
 -- "M" false 
 -- "get" false 
 -- 
 -- OG:markSuper: "M.get" 
 -- Invocation:markForCodeGen: "M.get" 
 -- ObjectInvocation:markForCodeGen: "M"  ATd: "M: obj Lock("M:Lock")" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "get"  ATd: "get: {   loop: obj ;      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);      if (r ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "M.get"  IS.isEmpty:  true 
 -- markItem: "cnt := cnt - 1" Assign 
 -- Invocation:markForCodeGen: "cnt" 
 -- ObjectInvocation:markForCodeGen: "cnt"  ATd: "cnt: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "cnt - 1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "cnt - 1" 
 -- "cnt - 1" true 
 -- 
 -- OG:markSuper: "cnt - 1" 
 -- Invocation:markForCodeGen: "cnt - 1" 
 -- BinaryExp:markForCodeGen: "cnt - 1" 
 -- Invocation:markForCodeGen: "cnt" 
 -- ObjectInvocation:markForCodeGen: "cnt"  ATd: "cnt: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "- 1"  ATd: "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- OI:args:markForCodgen: "1" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- not ObjDesc:  "cnt - 1"  IS.isEmpty:  true 
 -- markItem: "if (cnt < 0) :then {   disable;   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive.addWaiting -- sets status = WAITING; ...}" O ... 
 -- OG:markForCodeGen: "if (cnt < 0) :then {   disable;   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive.addWaiting -- sets status = ...}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (cnt < 0) :then {   disable;   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive.addWaiting -- sets status = WAITING;   theActi ...}" 
 -- "if (cnt < 0) :then {   disable;   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive.addWaiting -- sets status = WAITING;   theActi ...}" true 
 -- 
 -- OG:markSuper: "if (cnt < 0) :then {   disable;   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive.addWaiting -- sets status = WAIT ...}" 
 -- Invocation:markForCodeGen: "if (cnt < 0) :then {   disable;   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive.addWaiting -- sets  ...}" 
 -- OG:markForCodeGen: "(cnt < 0)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(cnt < 0)" 
 -- "(cnt < 0)" true 
 -- 
 -- OG:markSuper: "(cnt < 0)" 
 -- Invocation:markForCodeGen: "(cnt < 0)" 
 -- Invocation:markForCodeGen: "cnt < 0" 
 -- BinaryExp:markForCodeGen: "cnt < 0" 
 -- Invocation:markForCodeGen: "cnt" 
 -- ObjectInvocation:markForCodeGen: "cnt"  ATd: "cnt: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "< 0"  ATd: "<  : {   %basic 51;   in V: var integer;   out B: var boolean}" 
 -- OI:args:markForCodgen: "0" 
 -- OG:markForCodeGen: "0" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "0" 
 -- "0" true 
 -- 
 -- OG:markSuper: "0" 
 -- Invocation:markForCodeGen: "0" 
 -- not ObjDesc:  "0"  IS.isEmpty:  true 
 -- not ObjDesc:  "(cnt < 0)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "disable{   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive.addWaiting -- sets status = WAITING;   theActive.s ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "disable{   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive.addWaiting -- sets status = WAITING;   theActive.suspend}" 
 -- OG:Qalloc: "disable{   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive.addWaiting -- sets status = WAITING;   theActive.suspend}" q ... 194 
 -- ObjTmpStack:add: "disable{   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive.addWaiting -- sets status = WAITING;   theActive.sus ...}" 
 -- items:markForCodeGen: "disable{theActive := thisCore.main.active;Q.insert(theActive);enable;M.free;theActive.addWaiting -- sets status = WAITING;theActive.suspend}" 
 -- markItem: "disable" ObjectGenerator 
 -- markItem: "theActive := thisCore.main.active" Assign 
 -- Invocation:markForCodeGen: "theActive" 
 -- ObjectInvocation:markForCodeGen: "theActive"  ATd: "theActive: ref GeneralProcess" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "thisCore.main.active" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "thisCore.main.active" 
 -- "thisCore" true 
 -- "main" false 
 -- "active" false 
 -- 
 -- markItem: "Q.insert(theActive)" ObjectGenerator 
 -- OG:markForCodeGen: "Q.insert(theActive)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Q.insert(theActive)" 
 -- "Q" false 
 -- "insert(theActive)" false 
 -- 
 -- OG:markSuper: "Q.insert(theActive)" 
 -- Invocation:markForCodeGen: "Q.insert(theActive)" 
 -- ObjectInvocation:markForCodeGen: "Q"  ATd: "Q: obj LIB.Collections.QueueLib.Queue" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "insert(theActive)"  ATd: "insert: {   in elm: ref Object;   E: ref Element;   b: var BOOLEAN;   B := ELM =/= NONE;   --if (has(elm)) :the ...}" 
 -- OI:args:markForCodgen: "insert(theActive)" 
 -- OG:markForCodeGen: "theActive" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "theActive" 
 -- "theActive" false 
 -- 
 -- arg:   "theActive" 
 -- not ObjDesc:  "Q.insert(theActive)"  IS.isEmpty:  true 
 -- markItem: "enable" ObjectGenerator 
 -- markItem: "M.free" ObjectGenerator 
 -- OG:markForCodeGen: "M.free" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "M.free" 
 -- "M" false 
 -- "free" false 
 -- 
 -- OG:markSuper: "M.free" 
 -- Invocation:markForCodeGen: "M.free" 
 -- ObjectInvocation:markForCodeGen: "M"  ATd: "M: obj Lock("M:Lock")" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "free"  ATd: "free: {   free_M := 0}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "M.free"  IS.isEmpty:  true 
 -- markItem: "theActive.addWaiting -- sets status = WAITING" ObjectGenerator 
 -- OG:markForCodeGen: "theActive.addWaiting -- sets status = WAITING" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "theActive.addWaiting -- sets status = WAITING" 
 -- "theActive" false 
 -- "addWaiting -- sets status = WAITING" false 
 -- 
 -- OG:markSuper: "theActive.addWaiting -- sets status = WAITING" 
 -- Invocation:markForCodeGen: "theActive.addWaiting -- sets status = WAITING" 
 -- ObjectInvocation:markForCodeGen: "theActive"  ATd: "theActive: ref GeneralProcess" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "addWaiting -- sets status = WAITING"  ATd: "addWaiting:< {   --put('q')inner(addWaiting);   --put('R')}" 
 -- OI:args:markForCodgen: "-- sets status = WAITING" 
 -- not ObjDesc:  "theActive.addWaiting -- sets status = WAITING"  IS.isEmpty:  true 
 -- markItem: "theActive.suspend" ObjectGenerator 
 -- OG:markForCodeGen: "M.free" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "M.free" 
 -- OG:Qalloc: "M.free" qDescno:  197 
 -- ObjTmpStack:add: "M.free" 
 -- items:markForCodeGen: "M.free" 
 -- markItem: "M.free" ObjectGenerator 
 -- OG:markForCodeGen: "M.free" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "M.free" 
 -- "M" false 
 -- "free" false 
 -- 
 -- OG:markSuper: "M.free" 
 -- Invocation:markForCodeGen: "M.free" 
 -- ObjectInvocation:markForCodeGen: "M"  ATd: "M: obj Lock("M:Lock")" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "free"  ATd: "free: {   free_M := 0}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "M.free"  IS.isEmpty:  true 
 -- not ObjDesc:  "if (cnt < 0) :then {   disable;   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive.addWaiting -- sets status = WAIT ...}"   ... true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "mutex.wait"  IS.isEmpty:  true 
 -- markItem: "_V := _V + 1" Assign 
 -- Invocation:markForCodeGen: "_V" 
 -- ObjectInvocation:markForCodeGen: "_V"  ATd: "_V: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "_V + 1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "_V + 1" 
 -- "_V + 1" true 
 -- 
 -- OG:markSuper: "_V + 1" 
 -- Invocation:markForCodeGen: "_V + 1" 
 -- BinaryExp:markForCodeGen: "_V + 1" 
 -- Invocation:markForCodeGen: "_V" 
 -- ObjectInvocation:markForCodeGen: "_V"  ATd: "_V: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "+ 1"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OI:args:markForCodgen: "1" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- not ObjDesc:  "_V + 1"  IS.isEmpty:  true 
 -- markItem: "inner(entry)" ObjectGenerator 
 -- markItem: "mutex.signal" ObjectGenerator 
 -- OG:markForCodeGen: "mutex.signal" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "mutex.signal" 
 -- "mutex" false 
 -- "signal" false 
 -- 
 -- OG:markSuper: "mutex.signal" 
 -- Invocation:markForCodeGen: "mutex.signal" 
 -- ObjectInvocation:markForCodeGen: "mutex"  ATd: "mutex: obj BasicSystemLib.SemaphoreLib.Semaphore(1)" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "signal"  ATd: "signal: {   P: ref GeneralProcess;   M.get;   cnt := cnt + 1;   if (cnt <= 0) :then ;      disable;      P := Q.removeNext ...}" 
 -- Pattern:markForCodeGen: "signal: {   P: ref GeneralProcess;   M.get;   cnt := cnt + 1;   if (cnt <= 0) :then ;      disable;      P := Q.removeNext;      P.mkActive;       ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "P: ref GeneralProcess{   M.get;   cnt := cnt + 1;   if (cnt <= 0) :then ;      disable;      P := Q.removeNext;      P.mkActive;      --P.dcrWaiting -- ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "P: ref GeneralProcess{   M.get;   cnt := cnt + 1;   if (cnt <= 0) :then ;      disable;      P := Q.removeNext;      P.mkActive;      --P.dcrWaiting -- SQS.dcr ...}" 
 -- OG:Qalloc: "P: ref GeneralProcess{   M.get;   cnt := cnt + 1;   if (cnt <= 0) :then ;      disable;      P := Q.removeNext;      P.mkActive;      --P.dcrWaiting -- SQS.dcr ...}" q ... 198 
 -- ObjTmpStack:add: "signal" : "P: ref GeneralProcess{   M.get;   cnt := cnt + 1;   if (cnt <= 0) :then ;      disable;      P := Q.removeNext;      P.mkActive;      --P.dcrW ...}" 
 -- items:markForCodeGen: "P: ref GeneralProcess{M.get;cnt := cnt + 1;if (cnt <= 0) :then ;   disable;   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   ...}" 
 -- DataItem:markForCodeGen: "P" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "GeneralProcess" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "GeneralProcess" 
 -- "GeneralProcess" false 
 -- 
 -- not ObjDesc:  "GeneralProcess"  IS.isEmpty:  true 
 -- markItem: "M.get" ObjectGenerator 
 -- OG:markForCodeGen: "M.get" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "M.get" 
 -- "M" false 
 -- "get" false 
 -- 
 -- OG:markSuper: "M.get" 
 -- Invocation:markForCodeGen: "M.get" 
 -- ObjectInvocation:markForCodeGen: "M"  ATd: "M: obj Lock("M:Lock")" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "get"  ATd: "get: {   loop: obj ;      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);      if (r ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "M.get"  IS.isEmpty:  true 
 -- markItem: "cnt := cnt + 1" Assign 
 -- Invocation:markForCodeGen: "cnt" 
 -- ObjectInvocation:markForCodeGen: "cnt"  ATd: "cnt: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "cnt + 1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "cnt + 1" 
 -- "cnt + 1" true 
 -- 
 -- OG:markSuper: "cnt + 1" 
 -- Invocation:markForCodeGen: "cnt + 1" 
 -- BinaryExp:markForCodeGen: "cnt + 1" 
 -- Invocation:markForCodeGen: "cnt" 
 -- ObjectInvocation:markForCodeGen: "cnt"  ATd: "cnt: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "+ 1"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OI:args:markForCodgen: "1" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- not ObjDesc:  "cnt + 1"  IS.isEmpty:  true 
 -- markItem: "if (cnt <= 0) :then {   disable;   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable}" ObjectGenerator 
 -- OG:markForCodeGen: "if (cnt <= 0) :then {   disable;   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (cnt <= 0) :then {   disable;   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable}" 
 -- "if (cnt <= 0) :then {   disable;   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable}" true 
 -- 
 -- OG:markSuper: "if (cnt <= 0) :then {   disable;   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable}" 
 -- Invocation:markForCodeGen: "if (cnt <= 0) :then {   disable;   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable}" 
 -- OG:markForCodeGen: "(cnt <= 0)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(cnt <= 0)" 
 -- "(cnt <= 0)" true 
 -- 
 -- OG:markSuper: "(cnt <= 0)" 
 -- Invocation:markForCodeGen: "(cnt <= 0)" 
 -- Invocation:markForCodeGen: "cnt <= 0" 
 -- BinaryExp:markForCodeGen: "cnt <= 0" 
 -- Invocation:markForCodeGen: "cnt" 
 -- ObjectInvocation:markForCodeGen: "cnt"  ATd: "cnt: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "<= 0"  ATd: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- OI:args:markForCodgen: "0" 
 -- OG:markForCodeGen: "0" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "0" 
 -- "0" true 
 -- 
 -- OG:markSuper: "0" 
 -- Invocation:markForCodeGen: "0" 
 -- not ObjDesc:  "0"  IS.isEmpty:  true 
 -- not ObjDesc:  "(cnt <= 0)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "disable{   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "disable{   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable}" 
 -- OG:Qalloc: "disable{   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable}" qDescno:  199 
 -- ObjTmpStack:add: "disable{   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable}" 
 -- items:markForCodeGen: "disable{P := Q.removeNext;P.mkActive;--P.dcrWaiting -- SQS.dcrWaiting;enable}" 
 -- markItem: "disable" ObjectGenerator 
 -- markItem: "P := Q.removeNext" Assign 
 -- Invocation:markForCodeGen: "P" 
 -- ObjectInvocation:markForCodeGen: "P"  ATd: "P: ref GeneralProcess" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "Q.removeNext" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Q.removeNext" 
 -- "Q" false 
 -- "removeNext" false 
 -- 
 -- OG:markSuper: "Q.removeNext" 
 -- Invocation:markForCodeGen: "Q.removeNext" 
 -- ObjectInvocation:markForCodeGen: "Q"  ATd: "Q: obj LIB.Collections.QueueLib.Queue" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "removeNext"  ATd: "removeNext: {   -- return last element in queue and remove it for queue      out elm: ref Object;   if (last =/= none) ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Q.removeNext"  IS.isEmpty:  true 
 -- markItem: "P.mkActive{--P.dcrWaiting -- SQS.dcrWaiting}" ObjectGenerator 
 -- OG:markForCodeGen: "P.mkActive{--P.dcrWaiting -- SQS.dcrWaiting}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "P.mkActive{--P.dcrWaiting -- SQS.dcrWaiting}" 
 -- "P" false 
 -- "mkActive{--P.dcrWaiting -- SQS.dcrWaiting}" false 
 -- 
 -- OG:markSuper: "P.mkActive{--P.dcrWaiting -- SQS.dcrWaiting}" 
 -- Invocation:markForCodeGen: "P.mkActive{--P.dcrWaiting -- SQS.dcrWaiting}" 
 -- ObjectInvocation:markForCodeGen: "P"  ATd: "P: ref GeneralProcess" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "mkActive{--P.dcrWaiting -- SQS.dcrWaiting}"  ATd: "mkActive:< {   inner(mkActive)}" 
 -- OI:args:markForCodgen: "--P.dcrWaiting -- SQS.dcrWaiting" 
 -- not ObjDesc:  "P.mkActive{--P.dcrWaiting -- SQS.dcrWaiting}"  IS.isEmpty:  true 
 -- markItem: "enable" ObjectGenerator 
 -- not ObjDesc:  "if (cnt <= 0) :then {   disable;   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable}"  IS.isEmpty:  true 
 -- markItem: "M.free" ObjectGenerator 
 -- OG:markForCodeGen: "M.free" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "M.free" 
 -- "M" false 
 -- "free" false 
 -- 
 -- OG:markSuper: "M.free" 
 -- Invocation:markForCodeGen: "M.free" 
 -- ObjectInvocation:markForCodeGen: "M"  ATd: "M: obj Lock("M:Lock")" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "free"  ATd: "free: {   free_M := 0}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "M.free"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "mutex.signal"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "entry{   "Monitor:init\n".print;   inner(init)}" 
 -- OG:Qalloc: "entry{   "Monitor:init\n".print;   inner(init)}" qDescno:  224 
 -- ObjTmpStack:add: "init" : "entry{   "Monitor:init\n".print;   inner(init)}" 
 -- items:markForCodeGen: ""Monitor:init\n".print{inner(init)}" 
 -- markItem: ""Monitor:init\n".print" ObjectGenerator 
 -- OG:markForCodeGen: ""Monitor:init\n".print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- ""Monitor:init\n".print" 
 -- ""Monitor:init\n"" true 
 -- "print" false 
 -- 
 -- OG:markSuper: ""Monitor:init\n".print" 
 -- Invocation:markForCodeGen: ""Monitor:init\n".print" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  ""Monitor:init\n".print"  IS.isEmpty:  true 
 -- markItem: "inner(init)" ObjectGenerator 
 -- markItem: "inner(Monitor)" ObjectGenerator 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var integer): entry;      put(10);      put('<' ...}" 
 -- OG:Qalloc: "Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var integer): entry;      put(10);      put('<' ...}" q ... 217 
 -- ObjTmpStack:add: "myM" : "Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var integer): entry;      put(10) ...}" 
 -- items:markForCodeGen: "print(S: var String): entry{   S.print;putItem(msg: var String):value(V: var integer):res(res: var integer): entry;   put(10);   put('<');   msg.pri ...}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "print("P1 resumed\n")"  ATd: "print(S: var String): entry{   S.print}" 
 -- Pattern:markForCodeGen: "print(S: var String): entry{   S.print}" 
 -- items:markForCodeGen: "%$B "("{S: var String;%$E ")"}" 
 -- markItem: "%$B "("" Property 
 -- DataItem:markForCodeGen: "S" :descNo: 0 :OG.primNo: 5 
 -- OG:markForCodeGen: "String" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "String" 
 -- "String" true 
 -- 
 -- OG:markSuper: "String" 
 -- Invocation:markForCodeGen: "String" 
 -- ObjectInvocation:markForCodeGen: "String"  ATd: "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var inte ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "String"  IS.isEmpty:  true 
 -- markItem: "%$E ")"" Property 
 -- OG:markForCodeGen: "entry{   S.print}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "entry" 
 -- "entry" false 
 -- 
 -- OG:markSuper: "entry" 
 -- Invocation:markForCodeGen: "entry" 
 -- ObjectInvocation:markForCodeGen: "entry"  ATd: "entry: {   %kind method;   %arguments value, immutable;   mutex.wait;   _V := _V + 1;   inner(entry);   mutex.signal}" 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "entry{   S.print}" 
 -- OG:Qalloc: "entry{   S.print}" qDescno:  200 
 -- ObjTmpStack:add: "print(S: var String)" : "entry{   S.print}" 
 -- items:markForCodeGen: "S.print" 
 -- markItem: "S.print" ObjectGenerator 
 -- OG:markForCodeGen: "S.print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "S.print" 
 -- "S" true 
 -- "print" false 
 -- 
 -- OG:markSuper: "S.print" 
 -- Invocation:markForCodeGen: "S.print" 
 -- ObjectInvocation:markForCodeGen: "S"  ATd: "S: var String" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "S.print"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "print("P1 resumed\n")" 
 -- OG:markForCodeGen: ""P1 resumed\n"" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- ""P1 resumed\n"" 
 -- ""P1 resumed\n"" true 
 -- 
 -- OG:markSuper: ""P1 resumed\n"" 
 -- Invocation:markForCodeGen: ""P1 resumed\n"" 
 -- not ObjDesc:  ""P1 resumed\n""  IS.isEmpty:  true 
 -- arg:   ""P1 resumed\n"" 
 -- not ObjDesc:  "myM.print("P1 resumed\n")"  IS.isEmpty:  true 
 -- markItem: "for(1):to(5):repeat{   myM.putItem("Fac: "):value(inx):res(fac(inx));}" ObjectGenerator 
 -- OG:markForCodeGen: "for(1):to(5):repeat{   myM.putItem("Fac: "):value(inx):res(fac(inx));}" 
 -- isObjectDesc: true  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "for(1):to(5):repeat{   myM.putItem("Fac: "):value(inx):res(fac(inx));}" 
 -- "for(1):to(5):repeat{   myM.putItem("Fac: "):value(inx):res(fac(inx));}" false 
 -- 
 -- OG:markSuper: "for(1):to(5):repeat{   myM.putItem("Fac: "):value(inx):res(fac(inx));}" 
 -- Invocation:markForCodeGen: "for(1):to(5):repeat{   myM.putItem("Fac: "):value(inx):res(fac(inx));}" 
 -- ObjectInvocation:markForCodeGen: "for(1):to(5):repeat{   myM.putItem("Fac: "):value(inx):res(fac(inx));}"  ATd: "for(first: var integer):to(last: var integer):repeat{repea ..." 
 -- OI:args:markForCodgen: "for(1):to(5):repeat{   myM.putItem("Fac: "):value(inx):res(fac(inx));}" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "5" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "5" 
 -- "5" true 
 -- 
 -- OG:markSuper: "5" 
 -- Invocation:markForCodeGen: "5" 
 -- not ObjDesc:  "5"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "myM.putItem("Fac: "):value(inx):res(fac(inx))" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "myM.putItem("Fac: "):value(inx):res(fac(inx))" 
 -- OG:Qalloc: "myM.putItem("Fac: "):value(inx):res(fac(inx))" qDescno:  201 
 -- ObjTmpStack:add: "myM.putItem("Fac: "):value(inx):res(fac(inx))" 
 -- items:markForCodeGen: "myM.putItem("Fac: "):value(inx):res(fac(inx))" 
 -- markItem: "myM.putItem("Fac: "):value(inx):res(fac(inx))" ObjectGenerator 
 -- OG:markForCodeGen: "myM.putItem("Fac: "):value(inx):res(fac(inx))" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "myM.putItem("Fac: "):value(inx):res(fac(inx))" 
 -- "myM" false 
 -- "putItem("Fac: "):value(inx):res(fac(inx))" false 
 -- 
 -- OG:markSuper: "myM.putItem("Fac: "):value(inx):res(fac(inx))" 
 -- Invocation:markForCodeGen: "myM.putItem("Fac: "):value(inx):res(fac(inx))" 
 -- ObjectInvocation:markForCodeGen: "myM"  ATd: "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var  ...}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "putItem("Fac: "):value(inx):res(fac(inx))"  ATd: "putItem(msg: var String):value(V: var integer):res(res: var integer): entry{   put(10); ...}" 
 -- Pattern:markForCodeGen: "putItem(msg: var String):value(V: var integer):res(res: var integer): entry{   put(10);   put('<');   msg.print;   putint(V);   " = ".print;   put ...}" 
 -- items:markForCodeGen: "%$B "("{msg: var String;%$S "):value(";V: var integer;%$S "):res(";res: var integer;%$E ")"}" 
 -- markItem: "%$B "("" Property 
 -- DataItem:markForCodeGen: "msg" :descNo: 0 :OG.primNo: 5 
 -- OG:markForCodeGen: "String" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "String" 
 -- "String" true 
 -- 
 -- OG:markSuper: "String" 
 -- Invocation:markForCodeGen: "String" 
 -- ObjectInvocation:markForCodeGen: "String"  ATd: "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var inte ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "String"  IS.isEmpty:  true 
 -- markItem: "%$S "):value("" Property 
 -- DataItem:markForCodeGen: "V" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- markItem: "%$S "):res("" Property 
 -- DataItem:markForCodeGen: "res" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- markItem: "%$E ")"" Property 
 -- OG:markForCodeGen: "entry{   put(10);   put('<');   msg.print;   putint(V);   " = ".print;   putint(res);   put('>')}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "entry" 
 -- "entry" false 
 -- 
 -- OG:markSuper: "entry" 
 -- Invocation:markForCodeGen: "entry" 
 -- ObjectInvocation:markForCodeGen: "entry"  ATd: "entry: {   %kind method;   %arguments value, immutable;   mutex.wait;   _V := _V + 1;   inner(entry);   mutex.signal}" 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "entry{   put(10);   put('<');   msg.print;   putint(V);   " = ".print;   putint(res);   put('>')}" 
 -- OG:Qalloc: "entry{   put(10);   put('<');   msg.print;   putint(V);   " = ".print;   putint(res);   put('>')}" qDescno:  206 
 -- ObjTmpStack:add: "putItem(msg: var String):value(V: var integer):res(res: var integer)" : "entry{   put(10);   put('<');   msg.print;   putint(V);   " = ".print;   putint( ...}" 
 -- items:markForCodeGen: "put(10){put('<');msg.print;putint(V);" = ".print;putint(res);put('>')}" 
 -- markItem: "put(10)" ObjectGenerator 
 -- OG:markForCodeGen: "put(10)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "put(10)" 
 -- "put(10)" true 
 -- 
 -- OG:markSuper: "put(10)" 
 -- Invocation:markForCodeGen: "put(10)" 
 -- ObjectInvocation:markForCodeGen: "put(10)"  ATd: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OI:args:markForCodgen: "put(10)" 
 -- OG:markForCodeGen: "10" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "10" 
 -- "10" true 
 -- 
 -- OG:markSuper: "10" 
 -- Invocation:markForCodeGen: "10" 
 -- not ObjDesc:  "10"  IS.isEmpty:  true 
 -- arg:   "10" 
 -- not ObjDesc:  "put(10)"  IS.isEmpty:  true 
 -- markItem: "put('<')" ObjectGenerator 
 -- OG:markForCodeGen: "put('<')" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "put('<')" 
 -- "put('<')" true 
 -- 
 -- OG:markSuper: "put('<')" 
 -- Invocation:markForCodeGen: "put('<')" 
 -- ObjectInvocation:markForCodeGen: "put('<')"  ATd: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OI:args:markForCodgen: "put('<')" 
 -- OG:markForCodeGen: "'<'" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "'<'" 
 -- "'<'" true 
 -- 
 -- OG:markSuper: "'<'" 
 -- Invocation:markForCodeGen: "'<'" 
 -- not ObjDesc:  "'<'"  IS.isEmpty:  true 
 -- arg:   "'<'" 
 -- not ObjDesc:  "put('<')"  IS.isEmpty:  true 
 -- markItem: "msg.print" ObjectGenerator 
 -- OG:markForCodeGen: "msg.print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "msg.print" 
 -- "msg" true 
 -- "print" false 
 -- 
 -- OG:markSuper: "msg.print" 
 -- Invocation:markForCodeGen: "msg.print" 
 -- ObjectInvocation:markForCodeGen: "msg"  ATd: "msg: var String" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "msg.print"  IS.isEmpty:  true 
 -- markItem: "putint(V)" ObjectGenerator 
 -- OG:markForCodeGen: "putint(V)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "putint(V)" 
 -- "putint(V)" false 
 -- 
 -- OG:markSuper: "putint(V)" 
 -- Invocation:markForCodeGen: "putint(V)" 
 -- ObjectInvocation:markForCodeGen: "putint(V)"  ATd: "putint: {   %globals;   in V: var integer;   D: obj Indexed(20,#integer);   L: var integer;   isNeg: var Boolean;   isN ...}" 
 -- Pattern:markForCodeGen: "putint: {   %globals;   in V: var integer;   D: obj Indexed(20,#integer);   L: var integer;   isNeg: var Boolean;   isNeg := V < 0;   if (isNeg) : ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "%globals{   in V: var integer;   D: obj Indexed(20,#integer);   L: var integer;   isNeg: var Boolean;   isNeg := V < 0;   if (isNeg) :then ;      V :=  ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%globals{   in V: var integer;   D: obj Indexed(20,#integer);   L: var integer;   isNeg: var Boolean;   isNeg := V < 0;   if (isNeg) :then ;      V := 0 - V;   ...}" 
 -- OG:Qalloc: "%globals{   in V: var integer;   D: obj Indexed(20,#integer);   L: var integer;   isNeg: var Boolean;   isNeg := V < 0;   if (isNeg) :then ;      V := 0 - V;   ...}" q ... 207 
 -- ObjTmpStack:add: "putint" : "%globals{   in V: var integer;   D: obj Indexed(20,#integer);   L: var integer;   isNeg: var Boolean;   isNeg := V < 0;   if (isNeg) :then ;   ...}" 
 -- items:markForCodeGen: "%globals{in V: var integer;D: obj Indexed(20,#integer);L: var integer;isNeg: var Boolean;isNeg := V < 0;if (isNeg) :then ;   V := 0 - V;loop: do ;   ...}" 
 -- markItem: "%globals" Property 
 -- DataItem:markForCodeGen: "V" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "D" :descNo: 0 :OG.primNo: 114 
 -- OG:markForCodeGen: "Indexed(20,#integer)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Indexed(20,#integer)" 
 -- "Indexed(20,#integer)" true 
 -- 
 -- OG:markSuper: "Indexed(20,#integer)" 
 -- Invocation:markForCodeGen: "Indexed(20,#integer)" 
 -- ObjectInvocation:markForCodeGen: "Indexed(20,#integer)"  ATd: "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      ...}" 
 -- OI:args:markForCodgen: "(20,#integer)" 
 -- OG:markForCodeGen: "20" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "20" 
 -- "20" true 
 -- 
 -- OG:markSuper: "20" 
 -- Invocation:markForCodeGen: "20" 
 -- not ObjDesc:  "20"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "#integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "#integer" 
 -- "#integer" true 
 -- 
 -- OG:markSuper: "#integer" 
 -- Invocation:markForCodeGen: "#integer" 
 -- ObjectInvocation:markForCodeGen: "#integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %b ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "#integer"  IS.isEmpty:  true 
 -- arg:   "20" 
 -- arg:   "#integer" 
 -- not ObjDesc:  "Indexed(20,#integer)"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "L" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "isNeg" :descNo: 0 :OG.primNo: 4 
 -- OG:markForCodeGen: "Boolean" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Boolean" 
 -- "Boolean" true 
 -- 
 -- OG:markSuper: "Boolean" 
 -- Invocation:markForCodeGen: "Boolean" 
 -- ObjectInvocation:markForCodeGen: "Boolean"  ATd: "Boolean: value{   %id "Boolean";   %globals inSub;   %basic 4, 8;   %public;   _thisBasicValue: var Universal;   &&  : ;  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Boolean"  IS.isEmpty:  true 
 -- markItem: "isNeg := V < 0" Assign 
 -- Invocation:markForCodeGen: "isNeg" 
 -- ObjectInvocation:markForCodeGen: "isNeg"  ATd: "isNeg: var Boolean" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "V < 0" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "V < 0" 
 -- "V < 0" true 
 -- 
 -- OG:markSuper: "V < 0" 
 -- Invocation:markForCodeGen: "V < 0" 
 -- BinaryExp:markForCodeGen: "V < 0" 
 -- Invocation:markForCodeGen: "V" 
 -- ObjectInvocation:markForCodeGen: "V"  ATd: "in V: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "< 0"  ATd: "<  : {   %basic 51;   in V: var integer;   out B: var boolean}" 
 -- OI:args:markForCodgen: "0" 
 -- OG:markForCodeGen: "0" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "0" 
 -- "0" true 
 -- 
 -- OG:markSuper: "0" 
 -- Invocation:markForCodeGen: "0" 
 -- not ObjDesc:  "0"  IS.isEmpty:  true 
 -- not ObjDesc:  "V < 0"  IS.isEmpty:  true 
 -- markItem: "if (isNeg) :then {   V := 0 - V}" ObjectGenerator 
 -- OG:markForCodeGen: "if (isNeg) :then {   V := 0 - V}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (isNeg) :then {   V := 0 - V}" 
 -- "if (isNeg) :then {   V := 0 - V}" true 
 -- 
 -- OG:markSuper: "if (isNeg) :then {   V := 0 - V}" 
 -- Invocation:markForCodeGen: "if (isNeg) :then {   V := 0 - V}" 
 -- OG:markForCodeGen: "(isNeg)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(isNeg)" 
 -- "(isNeg)" true 
 -- 
 -- OG:markForCodeGen: "V := 0 - V" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "V := 0 - V" 
 -- OG:Qalloc: "V := 0 - V" qDescno:  208 
 -- ObjTmpStack:add: "V := 0 - V" 
 -- items:markForCodeGen: "V := 0 - V" 
 -- markItem: "V := 0 - V" Assign 
 -- Invocation:markForCodeGen: "V" 
 -- ObjectInvocation:markForCodeGen: "V"  ATd: "in V: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "0 - V" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "0 - V" 
 -- "0 - V" true 
 -- 
 -- OG:markSuper: "0 - V" 
 -- Invocation:markForCodeGen: "0 - V" 
 -- BinaryExp:markForCodeGen: "0 - V" 
 -- Invocation:markForCodeGen: "0" 
 -- ObjectInvocation:markForCodeGen: "- V"  ATd: "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- OI:args:markForCodgen: "V" 
 -- OG:markForCodeGen: "V" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "V" 
 -- "V" true 
 -- 
 -- not ObjDesc:  "0 - V"  IS.isEmpty:  true 
 -- not ObjDesc:  "if (isNeg) :then {   V := 0 - V}"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "L := L + 1{   D.put(V /% 10):at[L];   V := V // 10;   if (V > 0) :then ;      restart(loop)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "L := L + 1{   D.put(V /% 10):at[L];   V := V // 10;   if (V > 0) :then ;      restart(loop)}" 
 -- OG:Qalloc: "L := L + 1{   D.put(V /% 10):at[L];   V := V // 10;   if (V > 0) :then ;      restart(loop)}" qDescno:  0 
 -- OG:Qalloc:A:  "loop"  super:  ""  marked:  true "loop: do {   L := L + 1;   D.put(V /% 10):at[L];   V := V // 10;   if (V > 0) :then ;      restart(loop)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L := L + 1{   D.put(V /% 10):at[L];   V := V // 10;   if (V > 0) :then ;      restart(loop)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "loop" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 226 IS.newDescNo: 226 objSize: 0 1: 1 "L := L + 1{D.put(V /% 10):at[L];V := V // 10;if (V > 0) :then ;   restart(loop)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 226 "L := L + 1{D.put(V /% 10):at[L];V := V // 10;if (V > 0) :then ;   restart(loop)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "L" 
 -- ObjectInvocation:Qalloc: "L" 
 -- name: "L" 
 -- Arguments "" 
 -- OG:Qalloc: "L + 1" qDescno:  0 
 -- OG:Qalloc:A:  "+"  super:  "L + 1"  marked:  false "L := L + 1" super:  L + 1 
 -- Invocation:Qalloc: "L + 1" 
 -- BinaryExp:Qalloc: "L + 1" 
 -- Invocation:Qalloc: "L" 
 -- ObjectInvocation:Qalloc: "L" 
 -- name: "L" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "+ 1" 
 -- name: "+" 
 -- Arguments "1" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "1" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  49 5 %basic 61{in V: var integer;out R: var integer} 
 -- OG:super:  "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L + 1" 
 -- super:  "L + 1" 
 -- E:  "L + 1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L + 1" 
 -- OG:Qalloc: "D.put(V /% 10):at[L]" qDescno:  0 
 -- OG:Qalloc:A:  "put:at"  super:  "D.put(V /% 10):at[L]"  marked:  false "L := L + 1{D.put(V /% 10):at[L];V := V // 10;if (V > 0) :then ;   restart(loop)}" super:  D.put(V / ... 
 -- Invocation:Qalloc: "D.put(V /% 10):at[L]" 
 -- ObjectInvocation:Qalloc: "D" 
 -- name: "D" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "put(V /% 10):at[L]" 
 -- name: "put:at" 
 -- Arguments "put(V /% 10):at[L]" 
 -- OG:Qalloc: "V /% 10" qDescno:  0 
 -- OG:Qalloc:A:  "/%"  super:  "V /% 10"  marked:  false "put(V /% 10):at[L]" super:  V /% 10 
 -- Invocation:Qalloc: "V /% 10" 
 -- BinaryExp:Qalloc: "V /% 10" 
 -- Invocation:Qalloc: "V" 
 -- ObjectInvocation:Qalloc: "V" 
 -- name: "V" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "/% 10" 
 -- name: "/%" 
 -- Arguments "10" 
 -- OG:Qalloc: "10" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "10"  marked:  false "10" super:  10 
 -- Invocation:Qalloc: "10" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "10" 
 -- super:  "10" 
 -- E:  "10" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "10" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 69{in V: var integer;out R: var integer} 
 -- OG:Qalloc:SuperAlloc: "/%  : {   %basic 69;   in V: var integer;   out R: var integer}" 
 -- OG:Qalloc: "%basic 69{   in V: var integer;   out R: var integer}" qDescno:  0 
 -- OG:Qalloc:A:  "/%"  super:  ""  marked:  false "/%  : {   %basic 69;   in V: var integer;   out R: var integer}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 69{   in V: var integer;   out R: var integer}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "/%" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 227 IS.newDescNo: 227 objSize: 0 1: 1 "%basic 69{in V: var integer;out R: var integer}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 227 "%basic 69{in V: var integer;out R: var integer}" 
 -- Items:Qalloc:Super:C:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- dataitem:qalloc: "R" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 227 "%basic 69{in V: var integer;out R: var integer}" 
 -- IS.newDescNo: 227 IS.objSize: 5 "%basic 69{in V: var integer;out R: var integer}" 
 -- OG:Qalloc:end: IS.newDescNo:  227 "%basic 69{   in V: var integer;   out R: var integer}" 
 -- OG:super:  "/%  : {   %basic 69;   in V: var integer;   out R: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "V /% 10" 
 -- super:  "V /% 10" 
 -- E:  "V /% 10" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "V /% 10" 
 -- OG:Qalloc: "L" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "L"  marked:  false "put(V /% 10):at[L]" super:  L 
 -- Invocation:Qalloc: "L" 
 -- ObjectInvocation:Qalloc: "L" 
 -- name: "L" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "L: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L" 
 -- super:  "L" 
 -- E:  "L" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  93 3 %basic 115 
 -- OG:super:  "put(V: var integer):at[inx: var integer]: {   %basic 115}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "D.put(V /% 10):at[L]" 
 -- super:  "D.put(V /% 10):at[L]" 
 -- E:  "put(V /% 10):at[L]" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "D.put(V /% 10):at[L]" 
 -- Invocation:Qalloc: "V" 
 -- ObjectInvocation:Qalloc: "V" 
 -- name: "V" 
 -- Arguments "" 
 -- OG:Qalloc: "V // 10" qDescno:  0 
 -- OG:Qalloc:A:  "//"  super:  "V // 10"  marked:  false "V := V // 10" super:  V // 10 
 -- Invocation:Qalloc: "V // 10" 
 -- BinaryExp:Qalloc: "V // 10" 
 -- Invocation:Qalloc: "V" 
 -- ObjectInvocation:Qalloc: "V" 
 -- name: "V" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "// 10" 
 -- name: "//" 
 -- Arguments "10" 
 -- OG:Qalloc: "10" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "10"  marked:  false "10" super:  10 
 -- Invocation:Qalloc: "10" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "10" 
 -- super:  "10" 
 -- E:  "10" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "10" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 68{in V: var integer;out B: var integer} 
 -- OG:Qalloc:SuperAlloc: "//  : {   %basic 68;   in V: var integer;   out B: var integer}" 
 -- OG:Qalloc: "%basic 68{   in V: var integer;   out B: var integer}" qDescno:  0 
 -- OG:Qalloc:A:  "//"  super:  ""  marked:  false "//  : {   %basic 68;   in V: var integer;   out B: var integer}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 68{   in V: var integer;   out B: var integer}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "//" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 228 IS.newDescNo: 228 objSize: 0 1: 1 "%basic 68{in V: var integer;out B: var integer}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 228 "%basic 68{in V: var integer;out B: var integer}" 
 -- Items:Qalloc:Super:C:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- dataitem:qalloc: "B" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 228 "%basic 68{in V: var integer;out B: var integer}" 
 -- IS.newDescNo: 228 IS.objSize: 5 "%basic 68{in V: var integer;out B: var integer}" 
 -- OG:Qalloc:end: IS.newDescNo:  228 "%basic 68{   in V: var integer;   out B: var integer}" 
 -- OG:super:  "//  : {   %basic 68;   in V: var integer;   out B: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "V // 10" 
 -- super:  "V // 10" 
 -- E:  "V // 10" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "V // 10" 
 -- OG:Qalloc: "if (V > 0) :then {   restart(loop)}" qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (V > 0) :then {   restart(loop)}"  marked:  false "L := L + 1{D.put(V /% 10):at[L];V := V // 10;if (V > 0) :then ;   restart(loop)}" s ... i ... 
 -- Invocation:Qalloc: "if (V > 0) :then {   restart(loop)}" 
 -- OG:Qalloc: "(V > 0)" qDescno:  0 
 -- OG:Qalloc:A:  ">"  super:  "(V > 0)"  marked:  false "if (V > 0) :then {   restart(loop)}" super:  (V > 0) 
 -- Invocation:Qalloc: "(V > 0)" 
 -- Invocation:Qalloc: "V > 0" 
 -- BinaryExp:Qalloc: "V > 0" 
 -- Invocation:Qalloc: "V" 
 -- ObjectInvocation:Qalloc: "V" 
 -- name: "V" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "> 0" 
 -- name: ">" 
 -- Arguments "0" 
 -- OG:Qalloc: "0" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "0"  marked:  false "0" super:  0 
 -- Invocation:Qalloc: "0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "0" 
 -- super:  "0" 
 -- E:  "0" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  101 5 %basic 53{in V: var integer;out B: var boolean} 
 -- OG:super:  ">  : {   %basic 53;   in V: var integer;   out B: var boolean}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(V > 0)" 
 -- super:  "(V > 0)" 
 -- E:  "(V > 0)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(V > 0)" 
 -- OG:Qalloc: "restart(loop)" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (V > 0) :then {   restart(loop)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "restart(loop)" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 229 IS.newDescNo: 229 objSize: 0 1: 1 "restart(loop)" 
 -- Items:Qalloc:objSize: 0  newDescNo: 229 "restart(loop)" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: "restart(loop)" qDescno:  0 
 -- OG:Qalloc:A:  "restart"  super:  "restart(loop)"  marked:  false "restart(loop)" super:  restart(loop) 
 -- Invocation:Qalloc: "restart(loop)" 
 -- ObjectInvocation:Qalloc: "restart(loop)" 
 -- name: "restart" 
 -- Arguments "restart(loop)" 
 -- OG:Qalloc: "loop" qDescno:  0 
 -- OG:Qalloc:A:  "loop"  super:  "loop"  marked:  false "restart(loop)" super:  loop 
 -- Invocation:Qalloc: "loop" 
 -- ObjectInvocation:Qalloc: "loop" 
 -- name: "loop" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  226 1 L := L + 1{D.put(V /% 10):at[L];V := V // 10;if (V > 0) :then ;   restart(loop)} 
 -- OG:super:  "loop: do {   L := L + 1;   D.put(V /% 10):at[L];   V := V // 10;   if (V > 0) :then ;      restart(loop)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "loop" 
 -- super:  "loop" 
 -- E:  "loop" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "loop" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  50 2 %basic 102 
 -- OG:super:  "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "restart(loop)" 
 -- super:  "restart(loop)" 
 -- E:  "restart(loop)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "restart(loop)" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 229 "restart(loop)" 
 -- IS.newDescNo: 229 IS.objSize: 1 "restart(loop)" 
 -- OG:Qalloc:end: IS.newDescNo:  229 "restart(loop)" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (V > 0) :then {   restart(loop)}" 
 -- super:  "if (V > 0) :then {   restart(loop)}" 
 -- E:  "if (V > 0) :then {   restart(loop)}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (V > 0) :then {   restart(loop)}" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 226 "L := L + 1{D.put(V /% 10):at[L];V := V // 10;if (V > 0) :then ;   restart(loop)}" 
 -- IS.newDescNo: 226 IS.objSize: 1 "L := L + 1{D.put(V /% 10):at[L];V := V // 10;if (V > 0) :then ;   restart(loop)}" 
 -- OG:Qalloc:end: IS.newDescNo:  226 "L := L + 1{   D.put(V /% 10):at[L];   V := V // 10;   if (V > 0) :then ;      restart(loop)}" 
 -- ObjTmpStack:add: "loop" : "L := L + 1{   D.put(V /% 10):at[L];   V := V // 10;   if (V > 0) :then ;      restart(loop)}" 
 -- items:markForCodeGen: "L := L + 1{D.put(V /% 10):at[L];V := V // 10;if (V > 0) :then ;   restart(loop)}" 
 -- markItem: "L := L + 1" Assign 
 -- Invocation:markForCodeGen: "L" 
 -- ObjectInvocation:markForCodeGen: "L"  ATd: "L: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "L + 1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "L + 1" 
 -- "L + 1" true 
 -- 
 -- OG:markSuper: "L + 1" 
 -- Invocation:markForCodeGen: "L + 1" 
 -- BinaryExp:markForCodeGen: "L + 1" 
 -- Invocation:markForCodeGen: "L" 
 -- ObjectInvocation:markForCodeGen: "L"  ATd: "L: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "+ 1"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OI:args:markForCodgen: "1" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- not ObjDesc:  "L + 1"  IS.isEmpty:  true 
 -- markItem: "D.put(V /% 10):at[L]" ObjectGenerator 
 -- markItem: "V := V // 10" Assign 
 -- Invocation:markForCodeGen: "V" 
 -- ObjectInvocation:markForCodeGen: "V"  ATd: "in V: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "V // 10" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "V // 10" 
 -- "V // 10" true 
 -- 
 -- OG:markSuper: "V // 10" 
 -- Invocation:markForCodeGen: "V // 10" 
 -- BinaryExp:markForCodeGen: "V // 10" 
 -- Invocation:markForCodeGen: "V" 
 -- ObjectInvocation:markForCodeGen: "V"  ATd: "in V: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "// 10"  ATd: "//  : {   %basic 68;   in V: var integer;   out B: var integer}" 
 -- Pattern:markForCodeGen: "//  : {   %basic 68;   in V: var integer;   out B: var integer}" 
 -- items:markForCodeGen: "" 
 -- OI:args:markForCodgen: "10" 
 -- OG:markForCodeGen: "10" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "10" 
 -- "10" true 
 -- 
 -- OG:markSuper: "10" 
 -- Invocation:markForCodeGen: "10" 
 -- not ObjDesc:  "10"  IS.isEmpty:  true 
 -- not ObjDesc:  "V // 10"  IS.isEmpty:  true 
 -- markItem: "if (V > 0) :then {   restart(loop)}" ObjectGenerator 
 -- OG:markForCodeGen: "if (V > 0) :then {   restart(loop)}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (V > 0) :then {   restart(loop)}" 
 -- "if (V > 0) :then {   restart(loop)}" true 
 -- 
 -- OG:markSuper: "if (V > 0) :then {   restart(loop)}" 
 -- Invocation:markForCodeGen: "if (V > 0) :then {   restart(loop)}" 
 -- OG:markForCodeGen: "(V > 0)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(V > 0)" 
 -- "(V > 0)" true 
 -- 
 -- OG:markSuper: "(V > 0)" 
 -- Invocation:markForCodeGen: "(V > 0)" 
 -- Invocation:markForCodeGen: "V > 0" 
 -- BinaryExp:markForCodeGen: "V > 0" 
 -- Invocation:markForCodeGen: "V" 
 -- ObjectInvocation:markForCodeGen: "V"  ATd: "in V: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "> 0"  ATd: ">  : {   %basic 53;   in V: var integer;   out B: var boolean}" 
 -- OI:args:markForCodgen: "0" 
 -- OG:markForCodeGen: "0" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "0" 
 -- "0" true 
 -- 
 -- OG:markSuper: "0" 
 -- Invocation:markForCodeGen: "0" 
 -- not ObjDesc:  "0"  IS.isEmpty:  true 
 -- not ObjDesc:  "(V > 0)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "restart(loop)" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "restart(loop)" 
 -- OG:Qalloc: "restart(loop)" qDescno:  229 
 -- ObjTmpStack:add: "restart(loop)" 
 -- items:markForCodeGen: "restart(loop)" 
 -- markItem: "restart(loop)" ObjectGenerator 
 -- not ObjDesc:  "if (V > 0) :then {   restart(loop)}"  IS.isEmpty:  true 
 -- markItem: "if (isNeg) :then {   put('-')}" ObjectGenerator 
 -- OG:markForCodeGen: "if (isNeg) :then {   put('-')}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (isNeg) :then {   put('-')}" 
 -- "if (isNeg) :then {   put('-')}" true 
 -- 
 -- OG:markSuper: "if (isNeg) :then {   put('-')}" 
 -- Invocation:markForCodeGen: "if (isNeg) :then {   put('-')}" 
 -- OG:markForCodeGen: "(isNeg)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(isNeg)" 
 -- "(isNeg)" true 
 -- 
 -- OG:markForCodeGen: "put('-')" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "put('-')" 
 -- OG:Qalloc: "put('-')" qDescno:  209 
 -- ObjTmpStack:add: "put('-')" 
 -- items:markForCodeGen: "put('-')" 
 -- markItem: "put('-')" ObjectGenerator 
 -- OG:markForCodeGen: "put('-')" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "put('-')" 
 -- "put('-')" true 
 -- 
 -- OG:markSuper: "put('-')" 
 -- Invocation:markForCodeGen: "put('-')" 
 -- ObjectInvocation:markForCodeGen: "put('-')"  ATd: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OI:args:markForCodgen: "put('-')" 
 -- OG:markForCodeGen: "'-'" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "'-'" 
 -- "'-'" true 
 -- 
 -- OG:markSuper: "'-'" 
 -- Invocation:markForCodeGen: "'-'" 
 -- not ObjDesc:  "'-'"  IS.isEmpty:  true 
 -- arg:   "'-'" 
 -- not ObjDesc:  "put('-')"  IS.isEmpty:  true 
 -- not ObjDesc:  "if (isNeg) :then {   put('-')}"  IS.isEmpty:  true 
 -- markItem: "for(1):to(L):repeat{   i: var integer;   i := L + 1 - inx;   put('0' + D.get[i]);}" ObjectGenerator 
 -- OG:markForCodeGen: "for(1):to(L):repeat{   i: var integer;   i := L + 1 - inx;   put('0' + D.get[i]);}" 
 -- isObjectDesc: true  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "for(1):to(L):repeat{   i: var integer;   i := L + 1 - inx;   put('0' + D.get[i]);}" 
 -- "for(1):to(L):repeat{   i: var integer;   i := L + 1 - inx;   put('0' + D.get[i]);}" false 
 -- 
 -- OG:markSuper: "for(1):to(L):repeat{   i: var integer;   i := L + 1 - inx;   put('0' + D.get[i]);}" 
 -- Invocation:markForCodeGen: "for(1):to(L):repeat{   i: var integer;   i := L + 1 - inx;   put('0' + D.get[i]);}" 
 -- ObjectInvocation:markForCodeGen: "for(1):to(L):repeat{   i: var integer;   i := L + 1 - inx;   put('0' + D.get[i]);}"  ATd: "for(first: var integer):to(last: var integer): ..." 
 -- OI:args:markForCodgen: "for(1):to(L):repeat{   i: var integer;   i := L + 1 - inx;   put('0' + D.get[i]);}" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "L" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "L" 
 -- "L" true 
 -- 
 -- OG:markForCodeGen: "i: var integer{   i := L + 1 - inx;   put('0' + D.get[i])}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "i: var integer{   i := L + 1 - inx;   put('0' + D.get[i])}" 
 -- OG:Qalloc: "i: var integer{   i := L + 1 - inx;   put('0' + D.get[i])}" qDescno:  210 
 -- ObjTmpStack:add: "i: var integer{   i := L + 1 - inx;   put('0' + D.get[i])}" 
 -- items:markForCodeGen: "i: var integer{i := L + 1 - inx;put('0' + D.get[i])}" 
 -- DataItem:markForCodeGen: "i" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- markItem: "i := L + 1 - inx" Assign 
 -- Invocation:markForCodeGen: "i" 
 -- ObjectInvocation:markForCodeGen: "i"  ATd: "i: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "L + 1 - inx" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "L + 1 - inx" 
 -- "L + 1 - inx" true 
 -- 
 -- OG:markSuper: "L + 1 - inx" 
 -- Invocation:markForCodeGen: "L + 1 - inx" 
 -- BinaryExp:markForCodeGen: "L + 1 - inx" 
 -- BinaryExp:markForCodeGen: "L + 1" 
 -- Invocation:markForCodeGen: "L" 
 -- ObjectInvocation:markForCodeGen: "L"  ATd: "L: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "+ 1"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OI:args:markForCodgen: "1" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- ObjectInvocation:markForCodeGen: "- inx"  ATd: "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- OI:args:markForCodgen: "inx" 
 -- OG:markForCodeGen: "inx" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "inx" 
 -- "inx" true 
 -- 
 -- not ObjDesc:  "L + 1 - inx"  IS.isEmpty:  true 
 -- markItem: "put('0' + D.get[i])" ObjectGenerator 
 -- OG:markForCodeGen: "put('0' + D.get[i])" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "put('0' + D.get[i])" 
 -- "put('0' + D.get[i])" true 
 -- 
 -- OG:markSuper: "put('0' + D.get[i])" 
 -- Invocation:markForCodeGen: "put('0' + D.get[i])" 
 -- ObjectInvocation:markForCodeGen: "put('0' + D.get[i])"  ATd: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OI:args:markForCodgen: "put('0' + D.get[i])" 
 -- OG:markForCodeGen: "'0' + D.get[i]" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "'0' + D.get[i]" 
 -- "'0' + D.get[i]" true 
 -- 
 -- OG:markSuper: "'0' + D.get[i]" 
 -- Invocation:markForCodeGen: "'0' + D.get[i]" 
 -- BinaryExp:markForCodeGen: "'0' + D.get[i]" 
 -- Invocation:markForCodeGen: "'0'" 
 -- ObjectInvocation:markForCodeGen: "+ D.get[i]"  ATd: "+  : {   %basic 61;   in V: var char;   out R: var char}" 
 -- Pattern:markForCodeGen: "+  : {   %basic 61;   in V: var char;   out R: var char}" 
 -- items:markForCodeGen: "" 
 -- OI:args:markForCodgen: "D.get[i]" 
 -- not ObjDesc:  "'0' + D.get[i]"  IS.isEmpty:  true 
 -- arg:   "'0' + D.get[i]" 
 -- not ObjDesc:  "put('0' + D.get[i])"  IS.isEmpty:  true 
 -- arg:   "1" 
 -- arg:   "L" 
 -- arg:   "i: var integer{   i := L + 1 - inx;   put('0' + D.get[i])}" 
 -- OG:markIS: "for(1):to(L):repeat{   i: var integer;   i := L + 1 - inx;   put('0' + D.get[i]);}" 
 -- OG:Qalloc: "for(1):to(L):repeat{   i: var integer;   i := L + 1 - inx;   put('0' + D.get[i]);}" qDescno:  213 
 -- ObjTmpStack:add: "for(1):to(L):repeat{   i: var integer;   i := L + 1 - inx;   put('0' + D.get[i]);}" 
 -- items:markForCodeGen: "" 
 -- OI:args:markForCodgen: "putint(V)" 
 -- OG:markForCodeGen: "V" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "V" 
 -- "V" true 
 -- 
 -- arg:   "V" 
 -- not ObjDesc:  "putint(V)"  IS.isEmpty:  true 
 -- markItem: "" = ".print" ObjectGenerator 
 -- OG:markForCodeGen: "" = ".print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" = ".print" 
 -- "" = "" true 
 -- "print" false 
 -- 
 -- OG:markSuper: "" = ".print" 
 -- Invocation:markForCodeGen: "" = ".print" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "" = ".print"  IS.isEmpty:  true 
 -- markItem: "putint(res)" ObjectGenerator 
 -- OG:markForCodeGen: "putint(res)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "putint(res)" 
 -- "putint(res)" false 
 -- 
 -- OG:markSuper: "putint(res)" 
 -- Invocation:markForCodeGen: "putint(res)" 
 -- ObjectInvocation:markForCodeGen: "putint(res)"  ATd: "putint: {   %globals;   in V: var integer;   D: obj Indexed(20,#integer);   L: var integer;   isNeg: var Boolean;   i ...}" 
 -- OI:args:markForCodgen: "putint(res)" 
 -- OG:markForCodeGen: "res" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "res" 
 -- "res" true 
 -- 
 -- arg:   "res" 
 -- not ObjDesc:  "putint(res)"  IS.isEmpty:  true 
 -- markItem: "put('>')" ObjectGenerator 
 -- OG:markForCodeGen: "put('>')" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "put('>')" 
 -- "put('>')" true 
 -- 
 -- OG:markSuper: "put('>')" 
 -- Invocation:markForCodeGen: "put('>')" 
 -- ObjectInvocation:markForCodeGen: "put('>')"  ATd: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OI:args:markForCodgen: "put('>')" 
 -- OG:markForCodeGen: "'>'" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "'>'" 
 -- "'>'" true 
 -- 
 -- OG:markSuper: "'>'" 
 -- Invocation:markForCodeGen: "'>'" 
 -- not ObjDesc:  "'>'"  IS.isEmpty:  true 
 -- arg:   "'>'" 
 -- not ObjDesc:  "put('>')"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "putItem("Fac: "):value(inx):res(fac(inx))" 
 -- OG:markForCodeGen: ""Fac: "" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- ""Fac: "" 
 -- ""Fac: "" true 
 -- 
 -- OG:markSuper: ""Fac: "" 
 -- Invocation:markForCodeGen: ""Fac: "" 
 -- not ObjDesc:  ""Fac: ""  IS.isEmpty:  true 
 -- OG:markForCodeGen: "inx" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "inx" 
 -- "inx" true 
 -- 
 -- OG:markForCodeGen: "fac(inx)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "fac(inx)" 
 -- "fac(inx)" false 
 -- 
 -- OG:markSuper: "fac(inx)" 
 -- Invocation:markForCodeGen: "fac(inx)" 
 -- ObjectInvocation:markForCodeGen: "fac(inx)"  ATd: "fac(V: var integer): {   out res: var integer;   if (V = 1) :then ;      res := 1;   :else ;      res := V * fac(V - 1)}" 
 -- Pattern:markForCodeGen: "fac(V: var integer): {   out res: var integer;   if (V = 1) :then ;      res := 1;   :else ;      res := V * fac(V - 1)}" 
 -- items:markForCodeGen: "%$B "("{V: var integer;%$E ")"}" 
 -- markItem: "%$B "("" Property 
 -- DataItem:markForCodeGen: "V" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- markItem: "%$E ")"" Property 
 -- OG:markForCodeGen: "out res: var integer{   if (V = 1) :then ;      res := 1;   :else ;      res := V * fac(V - 1)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "out res: var integer{   if (V = 1) :then ;      res := 1;   :else ;      res := V * fac(V - 1)}" 
 -- OG:Qalloc: "out res: var integer{   if (V = 1) :then ;      res := 1;   :else ;      res := V * fac(V - 1)}" qDescno:  202 
 -- ObjTmpStack:add: "fac(V: var integer)" : "out res: var integer{   if (V = 1) :then ;      res := 1;   :else ;      res := V * fac(V - 1)}" 
 -- items:markForCodeGen: "out res: var integer{if (V = 1) :then ;   res := 1;:else ;   res := V * fac(V - 1)}" 
 -- DataItem:markForCodeGen: "res" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- markItem: "if (V = 1) :then {   res := 1;:else ;   res := V * fac(V - 1)}" ObjectGenerator 
 -- OG:markForCodeGen: "if (V = 1) :then {   res := 1;:else ;   res := V * fac(V - 1)}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (V = 1) :then {   res := 1;:else ;   res := V * fac(V - 1)}" 
 -- "if (V = 1) :then {   res := 1;:else ;   res := V * fac(V - 1)}" true 
 -- 
 -- OG:markSuper: "if (V = 1) :then {   res := 1;:else ;   res := V * fac(V - 1)}" 
 -- Invocation:markForCodeGen: "if (V = 1) :then {   res := 1;:else ;   res := V * fac(V - 1)}" 
 -- OG:markForCodeGen: "(V = 1)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(V = 1)" 
 -- "(V = 1)" true 
 -- 
 -- OG:markSuper: "(V = 1)" 
 -- Invocation:markForCodeGen: "(V = 1)" 
 -- Invocation:markForCodeGen: "V = 1" 
 -- BinaryExp:markForCodeGen: "V = 1" 
 -- Invocation:markForCodeGen: "V" 
 -- ObjectInvocation:markForCodeGen: "V"  ATd: "V: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "= 1"  ATd: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OI:args:markForCodgen: "1" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- not ObjDesc:  "(V = 1)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "res := 1" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "res := 1" 
 -- OG:Qalloc: "res := 1" qDescno:  203 
 -- ObjTmpStack:add: "res := 1" 
 -- items:markForCodeGen: "res := 1" 
 -- markItem: "res := 1" Assign 
 -- Invocation:markForCodeGen: "res" 
 -- ObjectInvocation:markForCodeGen: "res"  ATd: "out res: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "res := V * fac(V - 1)" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "res := V * fac(V - 1)" 
 -- OG:Qalloc: "res := V * fac(V - 1)" qDescno:  204 
 -- ObjTmpStack:add: "res := V * fac(V - 1)" 
 -- items:markForCodeGen: "res := V * fac(V - 1)" 
 -- markItem: "res := V * fac(V - 1)" Assign 
 -- Invocation:markForCodeGen: "res" 
 -- ObjectInvocation:markForCodeGen: "res"  ATd: "out res: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "V * fac(V - 1)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "V * fac(V - 1)" 
 -- "V * fac(V - 1)" true 
 -- 
 -- OG:markSuper: "V * fac(V - 1)" 
 -- Invocation:markForCodeGen: "V * fac(V - 1)" 
 -- BinaryExp:markForCodeGen: "V * fac(V - 1)" 
 -- Invocation:markForCodeGen: "V" 
 -- ObjectInvocation:markForCodeGen: "V"  ATd: "V: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "* fac(V - 1)"  ATd: "*  : {   %basic 66;   in V: var integer;   out R: var integer}" 
 -- Pattern:markForCodeGen: "*  : {   %basic 66;   in V: var integer;   out R: var integer}" 
 -- items:markForCodeGen: "" 
 -- OI:args:markForCodgen: "fac(V - 1)" 
 -- OG:markForCodeGen: "fac(V - 1)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "fac(V - 1)" 
 -- "fac(V - 1)" false 
 -- 
 -- OG:markSuper: "fac(V - 1)" 
 -- Invocation:markForCodeGen: "fac(V - 1)" 
 -- ObjectInvocation:markForCodeGen: "fac(V - 1)"  ATd: "fac(V: var integer): {   out res: var integer;   if (V = 1) :then ;      res := 1;   :else ;      res := V * fac(V - 1 ...}" 
 -- Pattern:markForCodeGen: "fac(V: var integer): {   out res: var integer;   if (V = 1) :then ;      res := 1;   :else ;      res := V * fac(V - 1)}" 
 -- OI:args:markForCodgen: "fac(V - 1)" 
 -- OG:markForCodeGen: "V - 1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "V - 1" 
 -- "V - 1" true 
 -- 
 -- OG:markSuper: "V - 1" 
 -- Invocation:markForCodeGen: "V - 1" 
 -- BinaryExp:markForCodeGen: "V - 1" 
 -- Invocation:markForCodeGen: "V" 
 -- ObjectInvocation:markForCodeGen: "V"  ATd: "V: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "- 1"  ATd: "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- OI:args:markForCodgen: "1" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- not ObjDesc:  "V - 1"  IS.isEmpty:  true 
 -- arg:   "V - 1" 
 -- not ObjDesc:  "fac(V - 1)"  IS.isEmpty:  true 
 -- not ObjDesc:  "V * fac(V - 1)"  IS.isEmpty:  true 
 -- not ObjDesc:  "if (V = 1) :then {   res := 1;:else ;   res := V * fac(V - 1)}"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "fac(inx)" 
 -- OG:markForCodeGen: "inx" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "inx" 
 -- "inx" true 
 -- 
 -- arg:   "inx" 
 -- not ObjDesc:  "fac(inx)"  IS.isEmpty:  true 
 -- arg:   ""Fac: "" 
 -- arg:   "inx" 
 -- arg:   "fac(inx)" 
 -- not ObjDesc:  "myM.putItem("Fac: "):value(inx):res(fac(inx))"  IS.isEmpty:  true 
 -- arg:   "1" 
 -- arg:   "5" 
 -- arg:   "myM.putItem("Fac: "):value(inx):res(fac(inx))" 
 -- OG:markIS: "for(1):to(5):repeat{   myM.putItem("Fac: "):value(inx):res(fac(inx));}" 
 -- OG:Qalloc: "for(1):to(5):repeat{   myM.putItem("Fac: "):value(inx):res(fac(inx));}" qDescno:  214 
 -- ObjTmpStack:add: "for(1):to(5):repeat{   myM.putItem("Fac: "):value(inx):res(fac(inx));}" 
 -- items:markForCodeGen: "" 
 -- DataItem:markForCodeGen: "P2" :descNo: 218 :OG.primNo: 0 
 -- OG:markForCodeGen: "MonitorProcess("PP2"){   sum(V: var integer): ;      out res: var integer;      for(1):to(10):repeat;         res := res + V;      ;   myM.print("P2 re ..."}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "MonitorProcess("PP2")" 
 -- "MonitorProcess("PP2")" false 
 -- 
 -- OG:markSuper: "MonitorProcess("PP2")" 
 -- Invocation:markForCodeGen: "MonitorProcess("PP2")" 
 -- ObjectInvocation:markForCodeGen: "MonitorProcess("PP2")"  ATd: "MonitorProcess: BasicProcess{   %globals Monitor, MonitorProcess(""), immutable, console;   -- we need to f ...}" 
 -- OI:args:markForCodgen: "MonitorProcess("PP2")" 
 -- OG:markForCodeGen: ""PP2"" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- ""PP2"" 
 -- ""PP2"" true 
 -- 
 -- OG:markSuper: ""PP2"" 
 -- Invocation:markForCodeGen: ""PP2"" 
 -- not ObjDesc:  ""PP2""  IS.isEmpty:  true 
 -- arg:   ""PP2"" 
 -- OG:markIS: "MonitorProcess("PP2"){   sum(V: var integer): ;      out res: var integer;      for(1):to(10):repeat;         res := res + V;      ;   myM.print("P2 resumed\n" ...}" 
 -- OG:Qalloc: "MonitorProcess("PP2"){   sum(V: var integer): ;      out res: var integer;      for(1):to(10):repeat;         res := res + V;      ;   myM.print("P2 resumed\n" ...}" q ... 218 
 -- ObjTmpStack:add: "P2" : "MonitorProcess("PP2"){   sum(V: var integer): ;      out res: var integer;      for(1):to(10):repeat;         res := res + V;      ;   myM.print(" ..."}" 
 -- items:markForCodeGen: "sum(V: var integer): {   out res: var integer;   for(1):to(10):repeat;      res := res + V;   ;myM.print("P2 resumed\n");for(1):to(6):repeat;   myM. ...}" 
 -- markItem: "myM.print("P2 resumed\n")" ObjectGenerator 
 -- OG:markForCodeGen: "myM.print("P2 resumed\n")" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "myM.print("P2 resumed\n")" 
 -- "myM" false 
 -- "print("P2 resumed\n")" false 
 -- 
 -- OG:markSuper: "myM.print("P2 resumed\n")" 
 -- Invocation:markForCodeGen: "myM.print("P2 resumed\n")" 
 -- ObjectInvocation:markForCodeGen: "myM"  ATd: "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var  ...}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "print("P2 resumed\n")"  ATd: "print(S: var String): entry{   S.print}" 
 -- OI:args:markForCodgen: "print("P2 resumed\n")" 
 -- OG:markForCodeGen: ""P2 resumed\n"" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- ""P2 resumed\n"" 
 -- ""P2 resumed\n"" true 
 -- 
 -- OG:markSuper: ""P2 resumed\n"" 
 -- Invocation:markForCodeGen: ""P2 resumed\n"" 
 -- not ObjDesc:  ""P2 resumed\n""  IS.isEmpty:  true 
 -- arg:   ""P2 resumed\n"" 
 -- not ObjDesc:  "myM.print("P2 resumed\n")"  IS.isEmpty:  true 
 -- markItem: "for(1):to(6):repeat{   myM.putItem("Sum: "):value(inx):res(sum(inx));}" ObjectGenerator 
 -- OG:markForCodeGen: "for(1):to(6):repeat{   myM.putItem("Sum: "):value(inx):res(sum(inx));}" 
 -- isObjectDesc: true  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "for(1):to(6):repeat{   myM.putItem("Sum: "):value(inx):res(sum(inx));}" 
 -- "for(1):to(6):repeat{   myM.putItem("Sum: "):value(inx):res(sum(inx));}" false 
 -- 
 -- OG:markSuper: "for(1):to(6):repeat{   myM.putItem("Sum: "):value(inx):res(sum(inx));}" 
 -- Invocation:markForCodeGen: "for(1):to(6):repeat{   myM.putItem("Sum: "):value(inx):res(sum(inx));}" 
 -- ObjectInvocation:markForCodeGen: "for(1):to(6):repeat{   myM.putItem("Sum: "):value(inx):res(sum(inx));}"  ATd: "for(first: var integer):to(last: var integer):repeat{repea ..." 
 -- OI:args:markForCodgen: "for(1):to(6):repeat{   myM.putItem("Sum: "):value(inx):res(sum(inx));}" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "6" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "6" 
 -- "6" true 
 -- 
 -- OG:markSuper: "6" 
 -- Invocation:markForCodeGen: "6" 
 -- not ObjDesc:  "6"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "myM.putItem("Sum: "):value(inx):res(sum(inx))" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "myM.putItem("Sum: "):value(inx):res(sum(inx))" 
 -- OG:Qalloc: "myM.putItem("Sum: "):value(inx):res(sum(inx))" qDescno:  219 
 -- ObjTmpStack:add: "myM.putItem("Sum: "):value(inx):res(sum(inx))" 
 -- items:markForCodeGen: "myM.putItem("Sum: "):value(inx):res(sum(inx))" 
 -- markItem: "myM.putItem("Sum: "):value(inx):res(sum(inx))" ObjectGenerator 
 -- OG:markForCodeGen: "myM.putItem("Sum: "):value(inx):res(sum(inx))" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "myM.putItem("Sum: "):value(inx):res(sum(inx))" 
 -- "myM" false 
 -- "putItem("Sum: "):value(inx):res(sum(inx))" false 
 -- 
 -- OG:markSuper: "myM.putItem("Sum: "):value(inx):res(sum(inx))" 
 -- Invocation:markForCodeGen: "myM.putItem("Sum: "):value(inx):res(sum(inx))" 
 -- ObjectInvocation:markForCodeGen: "myM"  ATd: "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var  ...}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "putItem("Sum: "):value(inx):res(sum(inx))"  ATd: "putItem(msg: var String):value(V: var integer):res(res: var integer): entry{   put(10); ...}" 
 -- OI:args:markForCodgen: "putItem("Sum: "):value(inx):res(sum(inx))" 
 -- OG:markForCodeGen: ""Sum: "" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- ""Sum: "" 
 -- ""Sum: "" true 
 -- 
 -- OG:markSuper: ""Sum: "" 
 -- Invocation:markForCodeGen: ""Sum: "" 
 -- not ObjDesc:  ""Sum: ""  IS.isEmpty:  true 
 -- OG:markForCodeGen: "inx" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "inx" 
 -- "inx" true 
 -- 
 -- OG:markForCodeGen: "sum(inx)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "sum(inx)" 
 -- "sum(inx)" false 
 -- 
 -- OG:markSuper: "sum(inx)" 
 -- Invocation:markForCodeGen: "sum(inx)" 
 -- ObjectInvocation:markForCodeGen: "sum(inx)"  ATd: "sum(V: var integer): {   out res: var integer;   for(1):to(10):repeat;      res := res + V;   }" 
 -- Pattern:markForCodeGen: "sum(V: var integer): {   out res: var integer;   for(1):to(10):repeat;      res := res + V;   }" 
 -- items:markForCodeGen: "%$B "("{V: var integer;%$E ")"}" 
 -- markItem: "%$B "("" Property 
 -- DataItem:markForCodeGen: "V" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- markItem: "%$E ")"" Property 
 -- OG:markForCodeGen: "out res: var integer{   for(1):to(10):repeat;      res := res + V;   }" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "out res: var integer{   for(1):to(10):repeat;      res := res + V;   }" 
 -- OG:Qalloc: "out res: var integer{   for(1):to(10):repeat;      res := res + V;   }" qDescno:  220 
 -- ObjTmpStack:add: "sum(V: var integer)" : "out res: var integer{   for(1):to(10):repeat;      res := res + V;   }" 
 -- items:markForCodeGen: "out res: var integer{for(1):to(10):repeat;   res := res + V;}" 
 -- DataItem:markForCodeGen: "res" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- markItem: "for(1):to(10):repeat{   res := res + V;}" ObjectGenerator 
 -- OG:markForCodeGen: "for(1):to(10):repeat{   res := res + V;}" 
 -- isObjectDesc: true  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "for(1):to(10):repeat{   res := res + V;}" 
 -- "for(1):to(10):repeat{   res := res + V;}" false 
 -- 
 -- OG:markSuper: "for(1):to(10):repeat{   res := res + V;}" 
 -- Invocation:markForCodeGen: "for(1):to(10):repeat{   res := res + V;}" 
 -- ObjectInvocation:markForCodeGen: "for(1):to(10):repeat{   res := res + V;}"  ATd: "for(first: var integer):to(last: var integer):repeat{repeat:< object}: {   %OSDvisibilit ...}" 
 -- OI:args:markForCodgen: "for(1):to(10):repeat{   res := res + V;}" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "10" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "10" 
 -- "10" true 
 -- 
 -- OG:markSuper: "10" 
 -- Invocation:markForCodeGen: "10" 
 -- not ObjDesc:  "10"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "res := res + V" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "res := res + V" 
 -- OG:Qalloc: "res := res + V" qDescno:  221 
 -- ObjTmpStack:add: "res := res + V" 
 -- items:markForCodeGen: "res := res + V" 
 -- markItem: "res := res + V" Assign 
 -- Invocation:markForCodeGen: "res" 
 -- ObjectInvocation:markForCodeGen: "res"  ATd: "out res: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "res + V" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "res + V" 
 -- "res + V" true 
 -- 
 -- OG:markSuper: "res + V" 
 -- Invocation:markForCodeGen: "res + V" 
 -- BinaryExp:markForCodeGen: "res + V" 
 -- Invocation:markForCodeGen: "res" 
 -- ObjectInvocation:markForCodeGen: "res"  ATd: "out res: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "+ V"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OI:args:markForCodgen: "V" 
 -- OG:markForCodeGen: "V" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "V" 
 -- "V" true 
 -- 
 -- not ObjDesc:  "res + V"  IS.isEmpty:  true 
 -- arg:   "1" 
 -- arg:   "10" 
 -- arg:   "res := res + V" 
 -- OG:markIS: "for(1):to(10):repeat{   res := res + V;}" 
 -- OG:Qalloc: "for(1):to(10):repeat{   res := res + V;}" qDescno:  222 
 -- ObjTmpStack:add: "for(1):to(10):repeat{   res := res + V;}" 
 -- items:markForCodeGen: "" 
 -- OI:args:markForCodgen: "sum(inx)" 
 -- OG:markForCodeGen: "inx" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "inx" 
 -- "inx" true 
 -- 
 -- arg:   "inx" 
 -- not ObjDesc:  "sum(inx)"  IS.isEmpty:  true 
 -- arg:   ""Sum: "" 
 -- arg:   "inx" 
 -- arg:   "sum(inx)" 
 -- not ObjDesc:  "myM.putItem("Sum: "):value(inx):res(sum(inx))"  IS.isEmpty:  true 
 -- arg:   "1" 
 -- arg:   "6" 
 -- arg:   "myM.putItem("Sum: "):value(inx):res(sum(inx))" 
 -- OG:markIS: "for(1):to(6):repeat{   myM.putItem("Sum: "):value(inx):res(sum(inx));}" 
 -- OG:Qalloc: "for(1):to(6):repeat{   myM.putItem("Sum: "):value(inx):res(sum(inx));}" qDescno:  223 
 -- ObjTmpStack:add: "for(1):to(6):repeat{   myM.putItem("Sum: "):value(inx):res(sum(inx));}" 
 -- items:markForCodeGen: "" 
 -- markItem: "myM.init" ObjectGenerator 
 -- OG:markForCodeGen: "myM.init" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "myM.init" 
 -- "myM" false 
 -- "init" false 
 -- 
 -- OG:markSuper: "myM.init" 
 -- Invocation:markForCodeGen: "myM.init" 
 -- ObjectInvocation:markForCodeGen: "myM"  ATd: "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var  ...}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "init"  ATd: "init:< entry{   "Monitor:init\n".print;   inner(init)}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "myM.init"  IS.isEmpty:  true 
 -- markItem: "P1.start" ObjectGenerator 
 -- OG:markForCodeGen: "P1.start" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "P1.start" 
 -- "P1" false 
 -- "start" false 
 -- 
 -- OG:markSuper: "P1.start" 
 -- Invocation:markForCodeGen: "P1.start" 
 -- ObjectInvocation:markForCodeGen: "P1"  ATd: "P1: obj MonitorProcess("PP1"){   fac(V: var integer): ;      out res: var integer;      if (V = 1) :then ;         res := 1;   ...}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "start"  ATd: "start:: {   --P: ref Process;   --P := this(MonitorProcess);   --("starting: " + id + "\n").print;   --SQS.insert(P)}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "P1.start"  IS.isEmpty:  true 
 -- markItem: "P2.start" ObjectGenerator 
 -- OG:markForCodeGen: "P2.start" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "P2.start" 
 -- "P2" false 
 -- "start" false 
 -- 
 -- OG:markSuper: "P2.start" 
 -- Invocation:markForCodeGen: "P2.start" 
 -- ObjectInvocation:markForCodeGen: "P2"  ATd: "P2: obj MonitorProcess("PP2"){   sum(V: var integer): ;      out res: var integer;      for(1):to(10):repeat;         res := r ...}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "start"  ATd: "start:: {   --P: ref Process;   --P := this(MonitorProcess);   --("starting: " + id + "\n").print;   --SQS.insert(P)}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "P2.start"  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basi ...}" 
 -- items:markForCodeGen: "" 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 1 
 -- Items:GenClass: BETAworld descNo: 1 isValue: false 
 -- Items:GenClass: BETAworld descNo: 21 isValue: false 

 CLASS BETAworld 21 1 BETA 2
 -- Store itemArgs: %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57;   in objx: ref Object;   out V: var boo ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- $Property:gen: "%ID Object"  
 -- $Property:gen: "%basic 64"  
 -- $Property:gen: "%public"  
 -- $pattern:gen: "X_asString:<  -- does not wokr, problem with virtual in Object{   out S: var LIB.StringLib.String;   inner(X_asString)" } 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%ID Object" 
 -- $Property:gen: "%ID Object"  
 -- genclass:stmt: "%basic 64" 
 -- $Property:gen: "%basic 64"  
 -- genclass:stmt: "%public" 
 -- $Property:gen: "%public"  
 -- genclass:stmt: "inner(Object)" 
 -- $ObjectGenerator:gen: "inner(Object)" >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inner(Object)" 
 -- OG:before:super.gen: "inner(Object)" 
 -- $Invocation:gen: "inner(Object)" >useRtnV:"False"superAdj: 0 descNo: 12 
 -- INV:gen: "inner(Object)" 
 -- isConstant: "Invocation" "inner(Object)" 
 -- needorigin: "inner(Object)" 
 -- needOrigin:E: "inner(Object)"  E.ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- doNeedOrigin:Ex: "inner(Object)" 
 -- computeAdr:superAdj: 0 "inner(Object)" 
 -- computeAdr: 1 :rec: "none"  E: "inner(Object)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "inner(Object)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "inner(Object)" >on:1 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "inner(Object)" >ATd.off:0 (isPtn):on:1:superAdj:0"inner: {   %basic 101;   in inner: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal:F  ...} 
 -- $pattern:getAdr: "inner: {   %basic 101;   in inner: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inner(Object)"  ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:- 
 -- computeAdr:isLast:E:  "inner(Object)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:- 
 -- rec:  "inner(Object)" E:  "inner(Object)" 
 -- INV:gen:E.loadArgs "inner(Object)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "inner(Object)" >staticOff:0 "inner: {   %basic 101;   in inner: ref Object" superAdj:0arg:"Object"} 
 -- $pattern:loadArgs: "inner: {   %basic 101;   in inner: ref Object" >E:"inner(Object)":descNo:12} 
 -- INV:gen:after:E.loadArgs "inner(Object)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(Object)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(O ..." 
 -- $ObjectInvocation_KeyWord:invoke: "inner(Object)" >rec:"inner(Object)" ATd:"pattern" E:"inner(Object)" E.ATd:"inner" unique:"False" 
 -- OI:invoke: "inner(Object)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:inner(Object) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:inner(Object) 
 -- OI:invoke:B: "inner(Object)" E: "inner(Object)"  rec: "inner(Object)"  useRtnV: false "inner: {   %basic 101;   in inner: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- $pattern:invoke: "inner: {   %basic 101;   in inner: ref Object" E: "inner(Object)" useRTNv: "False"} 
 -- ptn:invoke: "inner" E: "inner(Object)" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:inner(Object) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:inner(Object) 
 -- 
 -- OI:invoke:C: inner(Object) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:inner(Object) 
 L2:
 -- pushReturn:  "BETAworld" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- vdtAdd: inx=2 descInx=21 vDescInx=0 vdtTop: 2 
 -- vdtAdd: inx=1 descInx=21 vDescInx=32 vdtTop: 2 

 CLASS BETAworld 1 1 Object 21
 -- Store itemArgs: %id "BETAworld"{%modules BETA, LIB, LIB.StringLib, LIB.BasicIo;error: ;   %basic 999;--BETA;--DK;--LIB;--OOPM;--Sequential;--no;--workspace;} 
 -- Store:Origin: 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=1 vDescInx=1 vdtTop: 1 
 pushThis 
 saveBETAworld
 mvStack 
 -- $Property:gen: "%id "BETAworld""  
 -- $Property:gen: "%modules BETA, LIB, LIB.StringLib, LIB.BasicIo"  
 -- $obj:gen: "BETA: obj {   %ID BETA;   %OSDvisibility disguised;   %module LIB, LIB.StringLib;   %public;   Object: ;      %ID Object;      %basic 64;      %public;      ==  ..."} 
 -- $ObjectGenerator:gen: "%ID BETA{   %OSDvisibility disguised;   %module LIB, LIB.StringLib;   %public;   Object: ;      %ID Object;      %basic 64;      %public;      ==  : ..."} 
 -- OG:gen: "%ID BETA{   %OSDvisibility disguised;   %module LIB, LIB.StringLib;   %public;   Object: ;      %ID Object;      %basic 64;      %public;      ==  : ;         %ba ...}" 
 pushThis 
 -- before objTmpStack:add:  2   "BETA" 
 invoke BETA 2 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $obj:gen: "LIB: obj {   %id "LIB";   %module BETA;   %Include BETA;   x_dummy_LIB: var integer;   --AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--Coll ..."} 
 -- $ObjectGenerator:gen: "%id "LIB"{   %module BETA;   %Include BETA;   x_dummy_LIB: var integer;   --AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--Colle ..."} 
 -- OG:gen: "%id "LIB"{   %module BETA;   %Include BETA;   x_dummy_LIB: var integer;   --AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--Collections;--Compi ...}" 
 pushThis 
 -- before objTmpStack:add:  33   "LIB" 
 invoke LIB 33 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- Module:genMI:  "workspace" 
 -- $ModuleItem:gen: "--BETA{" } 
 -- ModuleItem:gen BETA 
 -- $obj:gen: "BETA: obj {   %ID BETA;   %OSDvisibility disguised;   %module LIB, LIB.StringLib;   %public;   Object: ;      %ID Object;      %basic 64;      %public;      ==  ..."} 
 -- $ModuleItem:gen: "--DK{" } 
 -- $ModuleItem:gen: "--LIB{" } 
 -- ModuleItem:gen LIB 
 -- $obj:gen: "LIB: obj {   %id "LIB";   %module BETA;   %Include BETA;   x_dummy_LIB: var integer;   --AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--Coll ..."} 
 -- $ModuleItem:gen: "--OOPM{" } 
 -- $ModuleItem:gen: "--Sequential{" } 
 -- $ModuleItem:gen: "--no{" } 
 -- $ModuleItem:gen: "--workspace{" } 
 -- ModuleItem:gen workspace 
 -- $obj:gen: "workspace: obj {   %id "workspace";   %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib;   %domain_boundary;   --AbstractEx;--AccessEx;--ApplyPred; ..."} 
 -- $ObjectGenerator:gen: "%id "workspace"{   %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib;   %domain_boundary;   --AbstractEx;--AccessEx;--ApplyPred;--Ardui ..."} 
 -- OG:gen: "%id "workspace"{   %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib;   %domain_boundary;   --AbstractEx;--AccessEx;--ApplyPred;--ArduinoEx;--ArmBasi ...}" 
 pushThis 
 -- before objTmpStack:add:  70   "workspace" 
 invoke workspace 70 4 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%id "BETAworld"" 
 -- $Property:gen: "%id "BETAworld""  
 -- genclass:stmt: "%modules BETA, LIB, LIB.StringLib, LIB.BasicIo" 
 -- $Property:gen: "%modules BETA, LIB, LIB.StringLib, LIB.BasicIo"  
 L2:
 -- pushReturn:  "BETAworld" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 2 
 -- Items:GenClass: BETA descNo: 2 isValue: false 
 -- Items:GenClass: BETA descNo: 21 isValue: false 

 CLASS BETA 2 1 BETAworld 1
 -- Store itemArgs: %ID BETA{%OSDvisibility disguised;%module LIB, LIB.StringLib;%public;Object: ;   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=2 vDescInx=2 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%ID BETA"  
 -- $Property:gen: "%OSDvisibility disguised"  
 -- $Property:gen: "%module LIB, LIB.StringLib"  
 -- $Property:gen: "%public"  
 -- $obj:gen: "ascii: obj {   asciiFoo: ;      msg1:  -- obj;         _put('F');         asciiBar.msg2;   asciiBar:  -- obj;      msg2: ;         _put('B');   nl: val 10;   cr ..."} 
 -- DI:gen: "ascii: obj {   asciiFoo: ;      msg1:  -- obj;         _put('F');         asciiBar.msg2;   asciiBar:  -- obj;      msg2: ;         _put('B');   nl: val 10;   cr:  ...}" D ... true : ... false : ... 0 
 -- DI:add:BP4:  ascii 
 -- $ObjectGenerator:gen: "asciiFoo: {      msg1:  -- obj;         _put('F');         asciiBar.msg2;   asciiBar:  -- obj;      msg2: ;         _put('B');   nl: val 10;   cr: v ..."} 
 -- OG:gen: "asciiFoo: {      msg1:  -- obj;         _put('F');         asciiBar.msg2;   asciiBar:  -- obj;      msg2: ;         _put('B');   nl: val 10;   cr: val 13;   null: ...}" 
 pushThis 
 -- before objTmpStack:add:  3   "ascii" 
 invoke ascii 3 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ref:gen: "console: ref ConsoleIF"  
 -- DI:gen: "console: ref ConsoleIF" DI:isConst: false :isBasicValue: false :primNo: 0 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%ID BETA" 
 -- $Property:gen: "%ID BETA"  
 -- genclass:stmt: "%OSDvisibility disguised" 
 -- $Property:gen: "%OSDvisibility disguised"  
 -- genclass:stmt: "%module LIB, LIB.StringLib" 
 -- $Property:gen: "%module LIB, LIB.StringLib"  
 -- genclass:stmt: "%public" 
 -- $Property:gen: "%public"  
 L2:
 -- pushReturn:  "BETA" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:2 objSize:3 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 3 
 -- Items:GenClass: ascii descNo: 3 isValue: false 
 -- Items:GenClass: ascii descNo: 21 isValue: false 

 CLASS ascii 3 1 BETA 2
 -- Store itemArgs: asciiFoo: {   msg1:  -- obj;      _put('F');      asciiBar.msg2;asciiBar:  -- obj;   msg2: ;      _put('B');nl: val 10;cr: val 13;null: val 0;newline: var  ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=3 vDescInx=3 vdtTop: 1 
 mvStack 
 -- $val:gen: "nl: val 10"  
 -- DI:gen: "nl: val 10" DI:isConst: true :isBasicValue: true :primNo: 1 
 -- DI:add:BP2:  nl 
 -- $ObjectGenerator:gen: "10" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "10" 
 -- OG:before:super.gen: "10" 
 -- $Invocation:gen: "10" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "10" 
 -- isConstant: "Invocation" "10" 
 -- needorigin: "10" 
 -- needOrigin:E: "10"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "10" E:  "10" 
 -- INV:gen:E.loadArgs "10" 
 -- $ConstLiteral:loadArgs: "10"  
 -- INV:gen:after:E.loadArgs "10" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "10" 
 -- $ConstLiteral:invoke: "10"  
 pushc 10
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- dataItem:store:basicValue: off: 1  NewOff: 2 
 pushThis 
 storeg nl 2
 -- $val:gen: "cr: val 13"  
 -- DI:gen: "cr: val 13" DI:isConst: true :isBasicValue: true :primNo: 1 
 -- DI:add:BP2:  cr 
 -- $ObjectGenerator:gen: "13" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "13" 
 -- OG:before:super.gen: "13" 
 -- $Invocation:gen: "13" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "13" 
 -- isConstant: "Invocation" "13" 
 -- needorigin: "13" 
 -- needOrigin:E: "13"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "13" E:  "13" 
 -- INV:gen:E.loadArgs "13" 
 -- $ConstLiteral:loadArgs: "13"  
 -- INV:gen:after:E.loadArgs "13" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "13" 
 -- $ConstLiteral:invoke: "13"  
 pushc 13
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- dataItem:store:basicValue: off: 2  NewOff: 3 
 pushThis 
 storeg cr 3
 -- $val:gen: "null: val 0"  
 -- DI:gen: "null: val 0" DI:isConst: true :isBasicValue: true :primNo: 1 
 -- DI:add:BP2:  null 
 -- $ObjectGenerator:gen: "0" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "0" 
 -- OG:before:super.gen: "0" 
 -- $Invocation:gen: "0" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "0" 
 -- isConstant: "Invocation" "0" 
 -- needorigin: "0" 
 -- needOrigin:E: "0"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "0" E:  "0" 
 -- INV:gen:E.loadArgs "0" 
 -- $ConstLiteral:loadArgs: "0"  
 -- INV:gen:after:E.loadArgs "0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0" 
 -- $ConstLiteral:invoke: "0"  
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- dataItem:store:basicValue: off: 3  NewOff: 4 
 pushThis 
 storeg null 4
 -- $var:gen: "newline: var char"  
 -- DI:gen: "newline: var char" DI:isConst: false :isBasicValue: true :primNo: 3 
 -- DI:add:BP1:  newline 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "newline := nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" 
 -- $Assign:gen: "newline := nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1" } 
 -- assign: "newline := nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" 
 -- computeAdr:superAdj: 0 "newline" 
 -- computeAdr: 1 :rec: "none"  E: "newline" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "newline"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "newline" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "newline" >ATd.off:5:on:0:superAdj:0"newline: var char":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValu ... 
 -- $var:getAdr: "newline: var char" >newOff:5,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F or ... 
 -- DI:OG: char 
 -- before:floatTest:  "newline: var char" ObjectGenerator 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"newline":rec:- 
 -- After:U*U: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"newline":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"newline":rec:- 
 -- computeAdr:isLast:E:  "newline" 
 -- AssignmentStatement:gen: "newline := nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" right.label: "ObjectGenerator" "nl -- Win:<cr><lf>, Uni ..." 
 -- $ObjectGenerator:gen: "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" 
 -- OG:before:super.gen: "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" 
 -- $Invocation:gen: "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1" >useRtnV:"True"superAdj: 0} 
 -- INV:gen: "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" 
 -- isConstant: "Invocation" "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" 
 -- const literal:  10   ConstLiteral 
 pushc 10
 -- OG:gen:end: 
 -- rec: "newline" dstE: "newline" dstE.ATd: "newline: var char" useRtn: false :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"newli ..." 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" 
 -- isArgOfAssignI2IwithUniValArg "newline := nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" arg: "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cyg ..." O ... 
 -- arg.super.arg: "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" ObjectInvocation_Unary 
 -- dstDI: "newline: var char" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"newline":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg ascii$3 5
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  "ascii" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 4 
 -- Items:GenClass: Value descNo: 4 isValue: true 
 -- Items:GenClass: Value descNo: 21 isValue: true 

 CLASS Value 4 0 BETA 2 isValueObj
 -- Store itemArgs: %ID Value{%globals;%basic 21;%public;=  :< ;   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= );<=  :< ;   %basic 52;   in Veq: va ...} 
 -- vdtAdd: inx=1 descInx=4 vDescInx=4 vdtTop: 1 
 -- $Property:gen: "%ID Value"  
 -- $Property:gen: "%globals"  
 -- $Property:gen: "%basic 21"  
 -- $Property:gen: "%public"  
 -- $pattern:gen: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )" } 
 -- $pattern:gen: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean" } 
DO:
 L1:
 -- genclass:stmt: "%ID Value" 
 -- $Property:gen: "%ID Value"  
 -- genclass:stmt: "%globals" 
 -- $Property:gen: "%globals"  
 -- genclass:stmt: "%basic 21" 
 -- $Property:gen: "%basic 21"  
 -- genclass:stmt: "%public" 
 -- $Property:gen: "%public"  
 L2:
 -- pushReturn:  "Value" 
 rtnV
 rtn(D)
 END OSDV:0 objSize:0 isIndexed:0
 -- vdtAdd: inx=2 descInx=4 vDescInx=11 vdtTop: 2 
 -- vdtAdd: inx=3 descInx=4 vDescInx=47 vdtTop: 3 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 5 
 -- Items:GenClass: integer descNo: 5 isValue: true 
 -- Items:GenClass: integer descNo: 4 isValue: true 
 -- Items:GenClass: Value descNo: 21 isValue: true 

 CLASS integer 5 0 BETA 2 isValueObj
 -- Store itemArgs: %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   out R: var integer;-  : ;   %basic 62;  ...} 
 -- vdtAdd: inx=1 descInx=5 vDescInx=5 vdtTop: 1 
 -- $Property:gen: "%ID integer"  
 -- $Property:gen: "%basic 1, 32"  
 -- $Property:gen: "%globals"  
 -- $Property:gen: "%public"  
 -- $var:gen: "_thisBasicValue: var Universal"  
 -- DI:gen: "_thisBasicValue: var Universal" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  _thisBasicValue 
DO:
 L1:
 -- genclass:stmt: "%ID integer" 
 -- $Property:gen: "%ID integer"  
 -- genclass:stmt: "%basic 1, 32" 
 -- $Property:gen: "%basic 1, 32"  
 -- genclass:stmt: "%globals" 
 -- $Property:gen: "%globals"  
 -- genclass:stmt: "%public" 
 -- $Property:gen: "%public"  
 L2:
 -- pushReturn:  "integer" 
 rtnV
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 6 
 -- Items:GenClass: universal descNo: 6 isValue: true 
 -- Items:GenClass: universal descNo: 4 isValue: true 
 -- Items:GenClass: Value descNo: 21 isValue: true 

 CLASS universal 6 0 BETA 2 isValueObj
 -- Store itemArgs: %ID universal{%basic 1, 32;%globals;+  : ;   %basic 61;   in V: var integer;   out R: var integer;-  : ;   %basic 62;   in V: var integer;   out R: var int ...} 
 -- vdtAdd: inx=1 descInx=6 vDescInx=6 vdtTop: 1 
 -- $Property:gen: "%ID universal"  
 -- $Property:gen: "%basic 1, 32"  
 -- $Property:gen: "%globals"  
DO:
 L1:
 -- genclass:stmt: "%ID universal" 
 -- $Property:gen: "%ID universal"  
 -- genclass:stmt: "%basic 1, 32" 
 -- $Property:gen: "%basic 1, 32"  
 -- genclass:stmt: "%globals" 
 -- $Property:gen: "%globals"  
 L2:
 -- pushReturn:  "universal" 
 rtnV
 rtn(D)
 END OSDV:0 objSize:0 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 7 
 -- Items:GenClass: char descNo: 7 isValue: true 
 -- Items:GenClass: char descNo: 4 isValue: true 
 -- Items:GenClass: Value descNo: 21 isValue: true 

 CLASS char 7 0 BETA 2 isValueObj
 -- Store itemArgs: %id "char"{%globals;%basic 3, 16;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var char;   out R: var char;-  : ;   %basic 62;   in V: ...} 
 -- vdtAdd: inx=1 descInx=7 vDescInx=7 vdtTop: 1 
 -- $Property:gen: "%id "char""  
 -- $Property:gen: "%globals"  
 -- $Property:gen: "%basic 3, 16"  
 -- $Property:gen: "%public"  
 -- $var:gen: "_thisBasicValue: var Universal"  
 -- DI:gen: "_thisBasicValue: var Universal" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  _thisBasicValue 
DO:
 L1:
 -- genclass:stmt: "%id "char"" 
 -- $Property:gen: "%id "char""  
 -- genclass:stmt: "%globals" 
 -- $Property:gen: "%globals"  
 -- genclass:stmt: "%basic 3, 16" 
 -- $Property:gen: "%basic 3, 16"  
 -- genclass:stmt: "%public" 
 -- $Property:gen: "%public"  
 L2:
 -- pushReturn:  "char" 
 rtnV
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 8 
 -- Items:GenClass: ConsoleIF descNo: 8 isValue: false 
 -- Items:GenClass: ConsoleIF descNo: 21 isValue: false 

 CLASS ConsoleIF 8 1 BETA 2
 -- Store itemArgs: put:< {   ...;puttext(T: var LIB.StringLib.String):< ;   inner(puttext);putint(V: var Integer):< ;   inner(putint)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=8 vDescInx=8 vdtTop: 1 
 mvStack 
 -- $pattern:gen: "put:< {   ..." } 
 -- $pattern:gen: "puttext(T: var LIB.StringLib.String):< {   inner(puttext)" } 
 -- $pattern:gen: "putint(V: var Integer):< {   inner(putint)" } 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 -- pushReturn:  "ConsoleIF" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- vdtAdd: inx=2 descInx=8 vDescInx=9 vdtTop: 2 
 -- vdtAdd: inx=3 descInx=8 vDescInx=68 vdtTop: 3 
 -- vdtAdd: inx=4 descInx=8 vDescInx=69 vdtTop: 4 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 9 
 -- Items:GenClass: put descNo: 9 isValue: false 
 -- Items:GenClass: put descNo: 21 isValue: false 

 CLASS put 9 1 ConsoleIF 8
 -- Store itemArgs: ... 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=9 vDescInx=9 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "..." 
 -- $Dots:gen: "..."  
 L2:
 -- pushReturn:  "put" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 10 
 -- Items:GenClass: String descNo: 10 isValue: false 
 -- Items:GenClass: String descNo: 4 isValue: false 
 -- Items:GenClass: Value descNo: 21 isValue: true 

 CLASS String 10 0 StringLib 44
 -- Store itemArgs: %id "String pattern"{%OSDvisibility disguised;%basic 5;%public;length: ;   out V: var integer;   V := get[0] -- actually an index error, accessing length;g ...} 
 allocEventQ
 -- vdtAdd: inx=1 descInx=10 vDescInx=10 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%id "String pattern""  
 -- $Property:gen: "%OSDvisibility disguised"  
 -- $Property:gen: "%basic 5"  
 -- $Property:gen: "%public"  
 -- $pattern:gen: "=  :: {   loop: do ;      c1: var char;      c2: var char;      L: var integer;      L := length;      if (L <> Veq.length) :then ;         leave(loop);     ..."} 
 -- $pattern:gen: "<=  :: {   loop: obj ;      -- "Hello"  <= "World" since H <= W;      -- "Qweabc" <= "Qwevwxy" since a <= e;      -- "Qweayc" <= "Qwexby";      -- "Qwe"     ..."} 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%id "String pattern"" 
 -- $Property:gen: "%id "String pattern""  
 -- genclass:stmt: "%OSDvisibility disguised" 
 -- $Property:gen: "%OSDvisibility disguised"  
 -- genclass:stmt: "%basic 5" 
 -- $Property:gen: "%basic 5"  
 -- genclass:stmt: "%public" 
 -- $Property:gen: "%public"  
 L2:
 -- pushReturn:  "String" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:2 objSize:0 isIndexed:1
 -- vdtAdd: inx=2 descInx=10 vDescInx=13 vdtTop: 2 
 -- vdtAdd: inx=3 descInx=10 vDescInx=52 vdtTop: 3 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 13 
 -- Items:GenClass: = descNo: 13 isValue: false 
 -- Items:GenClass: = descNo: 11 isValue: false 
 -- Items:GenClass: = descNo: 21 isValue: false 
 -- got:sub:vEq:  50  isValueObj:  false 5 
 -- OG:reAlloc: descNo: 0 21 "%basic 50{   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OG:reAlloc: descNo: 0 0 "%ID Object{   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic 57;      i ...}" 
 -- Pattern:Qalloc: == 
 -- Pattern:Qalloc: =/= 
 -- Pattern:Qalloc: suspend 
 -- Pattern:Qalloc: attach 
 -- Pattern:Qalloc: call 
 -- Pattern:Qalloc: resume 
 -- Pattern:Qalloc: onResume 
 -- Pattern:Qalloc: onSuspend 
 -- Pattern:Qalloc: dumpObj 
 -- Pattern:Qalloc: X_asString 
 -- Pattern:Qalloc:B: X_asString 
 -- dataitem:qalloc: "Veq" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: false 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- dataitem:qalloc: "Beq" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 

 CLASS = 11 1 Value 4
 -- Store itemArgs: %basic 50{in Veq: var this(Value);out Beq: var boolean;inner(= )} 
 -- in Veq: var this(Value) true 18 
 -- DI:store: "Veq" 
 jmpFalse  L3
 pushThis 
 -- vassign:B: Veq off: 4 size: 2 mode: 0 
 vassign  4 2 0
 jmp L4
 L3:
 invokeVal  Veq 31 3
 L4:
 -- Store:Origin: 21 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 allocEventQ
 -- vdtAdd: inx=1 descInx=11 vDescInx=11 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%basic 50"  
 -- $var:gen: "in Veq: var this(Value)"  
 -- DI:gen: "in Veq: var this(Value)" DI:isConst: false :isBasicValue: false :primNo: 18 
 -- DI:add:BP4:  Veq 
 -- inArg: in Veq: var this(Value) 
 -- $var:gen: "out Beq: var boolean"  
 -- DI:gen: "out Beq: var boolean" DI:isConst: false :isBasicValue: true :primNo: 4 
 -- DI:add:BP1:  Beq 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%basic 50" 
 -- $Property:gen: "%basic 50"  
 -- genclass:stmt: "inner(= )" 
 -- $ObjectGenerator:gen: "inner(= )" >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inner(= )" 
 -- OG:before:super.gen: "inner(= )" 
 -- $Invocation:gen: "inner(= )" >useRtnV:"False"superAdj: 0 descNo: 12 
 -- INV:gen: "inner(= )" 
 -- isConstant: "Invocation" "inner(= )" 
 -- needorigin: "inner(= )" 
 -- needOrigin:E: "inner(= )"  E.ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- doNeedOrigin:Ex: "inner(= )" 
 -- computeAdr:superAdj: 0 "inner(= )" 
 -- computeAdr: 1 :rec: "none"  E: "inner(= )" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "inner(= )"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "inner(= )" >on:2 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "inner(= )" >ATd.off:0 (isPtn):on:2:superAdj:0"inner: {   %basic 101;   in inner: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal:F supe ...} 
 -- $pattern:getAdr: "inner: {   %basic 101;   in inner: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inner(= )"  ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:- 
 -- computeAdr:isLast:E:  "inner(= )" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:- 
 -- rec:  "inner(= )" E:  "inner(= )" 
 -- INV:gen:E.loadArgs "inner(= )" 
 -- $ObjectInvocation_KeyWord:loadArgs: "inner(= )" >staticOff:0 "inner: {   %basic 101;   in inner: ref Object" superAdj:0arg:"= "} 
 -- $pattern:loadArgs: "inner: {   %basic 101;   in inner: ref Object" >E:"inner(= )":descNo:12} 
 -- INV:gen:after:E.loadArgs "inner(= )" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(= )" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )": ... 
 -- $ObjectInvocation_KeyWord:invoke: "inner(= )" >rec:"inner(= )" ATd:"pattern" E:"inner(= )" E.ATd:"inner" unique:"False" 
 -- OI:invoke: "inner(= )" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:inner(= ) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:inner(= ) 
 -- OI:invoke:B: "inner(= )" E: "inner(= )"  rec: "inner(= )"  useRtnV: false "inner: {   %basic 101;   in inner: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- $pattern:invoke: "inner: {   %basic 101;   in inner: ref Object" E: "inner(= )" useRTNv: "False"} 
 -- ptn:invoke: "inner" E: "inner(= )" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:inner(= ) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:inner(= ) 
 -- 
 -- OI:invoke:C: inner(= ) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:inner(= ) 
 L2:
 -- pushReturn:  "=" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0
 -- vdtAdd: inx=2 descInx=11 vDescInx=0 vdtTop: 2 
 -- got:sub:vEq:  50  isValueObj:  false 5 
 -- OG:reAlloc: descNo: 0 5 "loop: do {      c1: var char;      c2: var char;      L: var integer;      L := length;      if (L <> Veq.length) :then ;         leave(loop);     ...}" 
 -- OG:reAlloc:String: 
 -- currentDcl:this: 
 -- reAllocatedOff: "Veq" 2 
 -- dataitem:qalloc: "Beq" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- reAllocatedOff: "Beq" 3 
 -- reAllocatedOff: "loop" 0 

 CLASS = 13 1 String 10
 -- vdtTableCopy: I:1:11 I:2:0
 -- vdtAdd: inx=2 descInx=13 vDescInx=13 vdtTop: 2 
 -- Store itemArgs: loop: do {   c1: var char;   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);   beq := true;   for(1):to(len ...} 
 -- Store:Origin: 5 
 rShiftUp  1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- super =
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 -- handleSuperArgs:E: "" theIS: "loop: do {   c1: var char;   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);   beq := true;   ...}" 
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs: ""  
 rShiftDown  1
 -- hArgOrg:super: = 
 -- Store itemArgs: loop: do {   c1: var char;   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);   beq := true;   for(1):to(len ...} 
 -- in Veq: var this(Value) true 18 
 pushThis 
 rstoreg  Veq 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- Store:Origin: 5 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=13 vDescInx=11 vdtTop: 2 
 mvStack 
 -- $Property:gen: "%basic 50"  
 -- $var:gen: "in Veq: var this(Value)"  
 -- DI:gen: "in Veq: var this(Value)" DI:isConst: false :isBasicValue: false :primNo: 18 
 -- DI:add:BP4:  Veq 
 -- inArg: in Veq: var this(Value) 
 -- $var:gen: "out Beq: var boolean"  
 -- DI:gen: "out Beq: var boolean" DI:isConst: false :isBasicValue: true :primNo: 4 
 -- DI:add:BP1:  Beq 
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "loop: do {   c1: var char;   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);   beq := true;   for(1):to(len ...}" 
 -- $do:gen: "loop: do {   c1: var char;   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);   beq := true;   for(1):to(length):r ..."} 
 -- $ObjectGenerator:gen: "c1: var char{   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);   beq := true;   for(1):to(length):r ..."} 
 -- OG:gen: "c1: var char{   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);   beq := true;   for(1):to(length):repeat;      c1 ...}" 
 pushThis 
 -- before objTmpStack:add:  14   "loop" 
 invoke loop 14 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 -- pushReturn:  "=" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 14 
 -- Items:GenClass: loop descNo: 14 isValue: false 
 -- Items:GenClass: loop descNo: 21 isValue: false 

 CLASS loop 14 1 = 13
 -- Store itemArgs: c1: var char{c2: var char;L: var integer;L := length;if (L <> Veq.length) :then ;   leave(loop);beq := true;for(1):to(length):repeat;   c1 := get[inx];   c ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=14 vDescInx=14 vdtTop: 1 
 mvStack 
 -- $var:gen: "c1: var char"  
 -- DI:gen: "c1: var char" DI:isConst: false :isBasicValue: true :primNo: 3 
 -- DI:add:BP1:  c1 
 -- $var:gen: "c2: var char"  
 -- DI:gen: "c2: var char" DI:isConst: false :isBasicValue: true :primNo: 3 
 -- DI:add:BP1:  c2 
 -- $var:gen: "L: var integer"  
 -- DI:gen: "L: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  L 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "L := length" 
 -- $Assign:gen: "L := length"  
 -- assign: "L := length" 
 -- computeAdr:superAdj: 0 "L" 
 -- computeAdr: 1 :rec: "none"  E: "L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L" >ATd.off:4:on:0:superAdj:0"L: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "L: var integer" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L: var integer" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdr:isLast:E:  "L" 
 -- AssignmentStatement:gen: "L := length" right.label: "ObjectGenerator" "length" 
 -- $ObjectGenerator:gen: "length" >OGid:"length" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "length" 
 -- OG:before:super.gen: "length" 
 -- $Invocation:gen: "length" >useRtnV:"True"superAdj: 0 descNo: 15 
 -- INV:gen: "length" 
 -- isConstant: "Invocation" "length" 
 -- needorigin: "length" 
 -- needOrigin:E: "length"  E.ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- doNeedOrigin:Ex: "length" 
 -- computeAdr:superAdj: 0 "length" 
 -- computeAdr: 1 :rec: "none"  E: "length" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "length"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "length" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 2 isValueObj: false 
 -- origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- items:goOrigin:encOG: "=" on: 1 isValueObj: false 
 -- origin: String origin:isValueObj: false 
 rpushg =$13 1
 -- $ObjectInvocation_Unary:getAdr: "length" >ATd.off:0 (isPtn):on:2:superAdj:0"length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length":Adr ...} 
 -- $pattern:getAdr: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "length"  ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- computeAdr:isLast:E:  "length" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- rec:  "length" E:  "length" 
 -- INV:gen:E.loadArgs "length" 
 -- $ObjectInvocation_Unary:loadArgs: "length" >staticOff:0 "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" superAdj:0} 
 -- $pattern:loadArgs: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" >E:"length":descNo:15} 
 -- ptn:loadArgs:E "length" 
 -- {(ObjectInvocation_Unary; (name: "length"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "length" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- $ObjectInvocation_Unary:invoke: "length" >rec:"length" ATd:"pattern" E:"length" E.ATd:"length" unique:"False" 
 -- OI:invoke: "length" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:B: "length" E: "length"  rec: "length"  useRtnV: true "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- $pattern:invoke: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" E: "length" useRTNv: "True"} 
 -- ptn:invoke: "length" E: "length" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:C: length :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- rec: "L" dstE: "L" dstE.ATd: "L: var integer" useRtn: false :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "length" 
 -- isArgOfAssignI2IwithUniValArg "L := length" arg: "length" ObjectGenerator 
 -- arg.super.arg: "length" ObjectInvocation_Unary 
 -- dstDI: "L: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg loop$14 4
 -- assign:adr.store:B: 
 -- genclass:stmt: "if (L <> Veq.length) :then {   leave(loop)}" 
 -- $ObjectGenerator:gen: "if (L <> Veq.length) :then {   leave(loop)" >OGid:"if:then$0" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "if (L <> Veq.length) :then {   leave(loop)}" 
 -- OG:before:super.gen: "if (L <> Veq.length) :then {   leave(loop)}" 
 -- $Invocation:gen: "if (L <> Veq.length) :then {   leave(loop)" >useRtnV:"False"superAdj: 0} 
 -- INV:gen: "if (L <> Veq.length) :then {   leave(loop)}" 
 -- isConstant: "Invocation" "if (L <> Veq.length) :then {   leave(loop)}" 
 -- needorigin: "if (L <> Veq.length) :then {   leave(loop)}" 
 -- needOrigin:E: "if (L <> Veq.length) :then {   leave(loop)}"  E.ATd: "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globa ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (L <> Veq.length) :then {   leave(loop)}" E:  "if (L <> Veq.length) :then {   leave(loop)}" 
 -- INV:gen:E.loadArgs "if (L <> Veq.length) :then {   leave(loop)}" 
 -- $IfThen:loadArgs: "if (L <> Veq.length) :then {   leave(loop)" } 
 -- INV:gen:after:E.loadArgs "if (L <> Veq.length) :then {   leave(loop)}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (L <> Veq.length) :then {   leave(loop)}" 
 -- $IfThen:invoke: "if (L <> Veq.length) :then {   leave(loop)" } 
 -- $IfThen:gen: "if (L <> Veq.length) :then {   leave(loop)" } 
 -- $ObjectGenerator:gen: "(L <> Veq.length)" >OGid:"<>" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(L <> Veq.length)" 
 -- OG:before:super.gen: "(L <> Veq.length)" 
 -- $Invocation:gen: "(L <> Veq.length)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(L <> Veq.length)" 
 -- isConstant: "Invocation" "(L <> Veq.length)" 
 -- needorigin: "(L <> Veq.length)" 
 -- needOrigin:E: "(L <> Veq.length)"  E.ATd: "<>  : {   %basic 55;   in V: var integer;   out B: var boolean}" 
 -- doNeedOrigin:Ex: "(L <> Veq.length)" 
 -- computeAdr:superAdj: 0 "(L <> Veq.length)" 
 -- computeAdr: 1 :rec: "none"  E: "(L <> Veq.length)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(L <> Veq.length)"  
 -- $BracketedExp:loadOrigin: "(L <> Veq.length)"  
 -- computeAdr:superAdj: 0 "L <> Veq.length" 
 -- computeAdr: 1 :rec: "none"  E: "L <> Veq.length" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "L <> Veq.length"  
 -- $BinOp:loadOrigin: "L <> Veq.length"  
 -- BinaryExp:loadOrigin:empty: "L <> Veq.length" superAdj: 0 
 -- $BinOp:getAdr: "L <> Veq.length"  
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "L <> Veq.length" 
 -- BE:loadOrigin:E: L <> Veq.length 
 -- $BinOp:getAdr: "L <> Veq.length"  
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "L <> Veq.length" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "L <> Veq.length" E:  "L <> Veq.length" 
 -- INV:gen:E.loadArgs "L <> Veq.length" 
 -- $BinOp:loadArgs: "L <> Veq.length"  
 -- BinaryExp:loadArgs: "L <> Veq.length" superAdj: 0 
 -- $Invocation:gen: "L" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L" 
 -- isConstant: "Invocation" "L" 
 -- notConst: L L: var integer 
 -- needorigin: "L" 
 -- needOrigin:E: "L"  E.ATd: "L: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L" 
 -- computeAdr: 1 :rec: "none"  E: "L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L" >ATd.off:4:on:0:superAdj:0"L: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "L: var integer" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L: var integer" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdr:isLast:E:  "L" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- rec:  "L" E:  "L" 
 -- INV:gen:E.loadArgs "L" 
 -- $ObjectInvocation_Unary:loadArgs: "L" >staticOff:0 "L: var integer" superAdj:0 
 -- $var:loadArgs: "L: var integer" >E:"L" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "L" 
 -- {(ObjectInvocation_Unary; (name: "L"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L" >rec:"L" ATd:"var" isValueObj E:"L" E.ATd:"L" unique:"False" 
 -- OI:invoke: "L" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "L" E: "L"  rec: "L"  useRtnV: true "L: var integer" 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- $var:invoke: "L: var integer" E: "L">newOff:4 useRTNv: "True" 
 -- DI:invoke: "L: var integer" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- isCompositeValueObj: false E: "L" "L: var integer" true 
 -- E.ATd.isValueObj: false rec: "L" 
 pushg 4 loop$14
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- OI:invoke:C: L :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- left:#I "L <> Veq.length" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- $pattern:loadArgs: "<>  : {   %basic 55;   in V: var integer;   out B: var boolean" >E:"<> Veq.length":descNo:17} 
 -- ptn:loadArgs:E "<> Veq.length" 
 -- {(ObjectInvocation_Binary; (name: "<>"); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "Veq");     (Arguments));    (ObjectInvocatio ...} 
 -- args: "Veq.length" 
 -- E: "ObjectGenerator" Veq.length 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "<> Veq.length" "ObjectInvocation_Binary" ActArg:  "Veq.length" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "<> Veq.length"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "Veq.length" >OGid:"length" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "Veq.length" 
 -- OG:before:super.gen: "Veq.length" 
 -- $Invocation:gen: "Veq.length" >useRtnV:"True"superAdj: 0 descNo: 15 
 -- INV:gen: "Veq.length" 
 -- isConstant: "Invocation" "Veq.length" 
 -- notConst: Veq in Veq: var this(Value) 
 -- needorigin: "Veq.length" 
 -- needOrigin:E: "length"  E.ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- doNeedOrigin:Ex: "length" 
 -- computeAdr:superAdj: 0 "Veq.length" 
 -- computeAdr: 1 :rec: "none"  E: "Veq" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Veq"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Veq" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- $ObjectInvocation_Unary:getAdr: "Veq" >ATd.off:2:on:1:superAdj:0"in Veq: var this(Value)":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVa ... 
 -- PING:String 0 c1: var char{   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);   beq := true;   for(1):to(length):repeat;    ...} 
 -- BOBS:ATd: "in Veq: var this(Value)" 
 -- String:vEq:  "Veq" off:  2 ATd: "in Veq: var this(Value)" 
 -- E.on: 1 
 -- beforeIsValueObj:E: "Veq"  ATd: "in Veq: var this(Value)" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "Veq"  E: "length" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "length" >ATd.off:0 (isPtn):on:0:superAdj:0"length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length":Adr ...} 
 -- $pattern:getAdr: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "Veq" >staticOff:0 "in Veq: var this(Value)" superAdj:0 
 -- $var:loadArgs: "in Veq: var this(Value)" >E:"Veq" 
 -- $pattern:loadArgs: "this: {   %basic 18;   in this: ref Object" >E:"Veq":descNo:31} 
 -- $ObjectInvocation_Unary:invoke: "Veq" >rec:"Veq" ATd:"var" isValueObj E:"length" E.ATd:"length" unique:"False" 
 -- OI:invoke: "Veq" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:B: "Veq" E: "length"  rec: "Veq"  useRtnV: true "in Veq: var this(Value)" 
 -- OI:invoke:before:ATdx.invoke: var Veq 
 -- $var:invoke: "in Veq: var this(Value)" E: "length">newOff:2 useRTNv: "True" 
 -- DI:invoke: "in Veq: var this(Value)" 
 -- isValueObj:isAdr: true objSize: 2  rec "Veq" ,E: "length" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 rpushg loop$14 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- 
 -- OI:invoke:C: Veq :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "Veq" E: "length" 
 -- computeAdr:isLast:E:  "length" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- rec:  "Veq" E:  "length" 
 -- INV:gen:E.loadArgs "length" 
 -- $ObjectInvocation_Unary:loadArgs: "length" >staticOff:0 "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" superAdj:0} 
 -- $pattern:loadArgs: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" >E:"length":descNo:15} 
 -- ptn:loadArgs:E "length" 
 -- {(ObjectInvocation_Unary; (name: "length"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "length" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- $ObjectInvocation_Unary:invoke: "length" >rec:"Veq" ATd:"pattern" E:"length" E.ATd:"length" unique:"False" 
 -- OI:invoke: "length" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:B: "length" E: "length"  rec: "Veq"  useRtnV: true "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- $pattern:invoke: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" E: "length" useRTNv: "True"} 
 -- ptn:invoke: "length" E: "length" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 3 vTopMax: 3 rTop: -3 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:C: length :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "Veq.length" :isBasicVal: true 
 -- case:B: Veq.length ObjectGenerator 1 0 0 false false 
 -- end:loadArgs:NonVirt: "<> Veq.length" 
 -- BinaryExp:loadArgs:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:after:E.loadArgs "L <> Veq.length" 
 -- OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L <> Veq.length" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- $BinOp:invoke: "L <> Veq.length"  
 -- BinaryExp:invoke: "L" rec: "L <> Veq.length" 
 -- M: "<> Veq.length" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- $ObjectInvocation_Binary:invoke: "<> Veq.length" >rec:"L" ATd:"pattern" E:"<> Veq.length" E.ATd:"<>  " unique:"False" 
 -- OI:invoke: "<> Veq.length" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- origin:isValueObj "integer" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "<> Veq.length" E: "<> Veq.length"  rec: "L"  useRtnV: true "<>  : {   %basic 55;   in V: var integer;   out B: var boolean}" 
 -- OI:invoke:before:ATdx.invoke: pattern <>   
 -- $pattern:invoke: "<>  : {   %basic 55;   in V: var integer;   out B: var boolean" E: "<> Veq.length" useRTNv: "True"} 
 -- ptn:invoke: "<>  " E: "<> Veq.length" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "L" E: "<> Veq.length" 
 -- arg:other 
 ne
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<> Veq.length":rec:L 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<> Veq.length":rec:L 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: <> Veq.length :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: "leave(loop)" >OGid:"$18" singular! staticOff=0 descNo=18 superAdj=0 
 -- OG:gen: "leave(loop)" 
 pushThis 
 -- before objTmpStack:add:  18   "$18" 
 invoke $18 18 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 3 vTopMax: 3 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "beq := true" 
 -- $Assign:gen: "beq := true"  
 -- assign: "beq := true" 
 -- computeAdr:superAdj: 0 "beq" 
 -- computeAdr: 1 :rec: "none"  E: "beq" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "beq"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "beq" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- $ObjectInvocation_Unary:getAdr: "beq" >ATd.off:3:on:1:superAdj:0"out Beq: var boolean":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ... 
 -- $var:getAdr: "out Beq: var boolean" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: boolean 
 -- before:floatTest:  "out Beq: var boolean" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"beq":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"beq":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "beq"  ATd: "out Beq: var boolean" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"beq":rec:- 
 -- computeAdr:isLast:E:  "beq" 
 -- AssignmentStatement:gen: "beq := true" right.label: "ObjectGenerator" "true" 
 -- $ObjectGenerator:gen: "true" >OGid:"True" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "true" 
 -- OG:before:super.gen: "true" 
 -- $Invocation:gen: "true" >useRtnV:"True"superAdj: 0 descNo: 23 
 -- INV:gen: "true" 
 -- isConstant: "Invocation" "true" 
 -- needorigin: "true" 
 -- needOrigin:E: "true"  E.ATd: "True: {   %globals;   out B: var boolean;   B := 1}" 
 -- Ex:loadOrign:no:loadOrigin:  "%globals{   out B: var boolean;   B := 1}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "true" E:  "true" 
 -- INV:gen:E.loadArgs "true" 
 -- $ObjectInvocation_Unary:loadArgs: "true" >staticOff:0 "True: {   %globals;   out B: var boolean;   B := 1" superAdj:0} 
 -- $pattern:loadArgs: "True: {   %globals;   out B: var boolean;   B := 1" >E:"true":descNo:23} 
 -- ptn:loadArgs:E "true" 
 -- {(ObjectInvocation_Unary; (name: "true"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "true" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "true" 
 -- $ObjectInvocation_Unary:invoke: "true" >rec:"true" ATd:"pattern" E:"true" E.ATd:"True" unique:"False" 
 -- OI:invoke: "true" 
 -- 
 -- OI:invoke:B: "true" E: "true"  rec: "true"  useRtnV: true "True: {   %globals;   out B: var boolean;   B := 1}" 
 -- OI:invoke:before:ATdx.invoke: pattern True 
 -- $pattern:invoke: "True: {   %globals;   out B: var boolean;   B := 1" E: "true" useRTNv: "True"} 
 -- ptn:invoke: "True" E: "true" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke True 23 0 0
 -- global:pushOut: B off: 1 
 pushg 1 
 -- stack: rpop : vTop: 3 vTopMax: 3 rTop: -5 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 4 vTopMax: 4 rTop: -5 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 1 
 -- GeneralPTN:invoke:after:callInvoke: 1 
 -- OI:invoke:V: adrx: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: true :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "beq" dstE: "beq" dstE.ATd: "out Beq: var boolean" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"beq":rec:- ... 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right: "true" 
 -- isArgOfAssignI2IwithUniValArg "beq := true" arg: "true" ObjectGenerator 
 -- arg.super.arg: "true" ObjectInvocation_Unary 
 -- dstDI: "out Beq: var boolean" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"beq":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg =$13 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- $ObjectGenerator:gen: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);" >OGid:"for:to:repeat ..."} 
 -- OG:gen: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 pushThis 
 -- before objTmpStack:add:  30   "for:to:repeat$30" 
 invoke for:to:repeat$30 30 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 4 vTopMax: 4 rTop: -6 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 -- pushReturn:  "loop" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 15 
 -- Items:GenClass: length descNo: 15 isValue: false 
 -- Items:GenClass: length descNo: 21 isValue: false 

 CLASS length 15 1 String 10
 -- Store itemArgs: out V: var integer{V := get[0] -- actually an index error, accessing length} 
 -- Store:Origin: 5 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=15 vDescInx=15 vdtTop: 1 
 mvStack 
 -- $var:gen: "out V: var integer"  
 -- DI:gen: "out V: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  V 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "V := get[0] -- actually an index error, accessing length" 
 -- $Assign:gen: "V := get[0] -- actually an index error, accessing length"  
 -- assign: "V := get[0] -- actually an index error, accessing length" 
 -- computeAdr:superAdj: 0 "V" 
 -- computeAdr: 1 :rec: "none"  E: "V" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "V"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "V" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "V" >ATd.off:2:on:0:superAdj:0"out V: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- PING:String 0 out V: var integer{   V := get[0] -- actually an index error, accessing length} 
 -- $var:getAdr: "out V: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F o ... 
 -- DI:OG: integer 
 -- before:floatTest:  "out V: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- computeAdr:isLast:E:  "V" 
 -- AssignmentStatement:gen: "V := get[0] -- actually an index error, accessing length" right.label: "ObjectGenerator" "get[0] -- actually an index error, accessing length" 
 -- $ObjectGenerator:gen: "get[0] -- actually an index error, accessing length" >OGid:"get" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "get[0] -- actually an index error, accessing length" 
 -- OG:before:super.gen: "get[0] -- actually an index error, accessing length" 
 -- $Invocation:gen: "get[0] -- actually an index error, accessing length" >useRtnV:"True"superAdj: 0 descNo: 16 
 -- INV:gen: "get[0] -- actually an index error, accessing length" 
 -- isConstant: "Invocation" "get[0] -- actually an index error, accessing length" 
 -- needorigin: "get[0] -- actually an index error, accessing length" 
 -- needOrigin:E: "get[0] -- actually an index error, accessing length"  E.ATd: "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- doNeedOrigin:Ex: "get[0] -- actually an index error, accessing length" 
 -- computeAdr:superAdj: 0 "get[0] -- actually an index error, accessing length" 
 -- computeAdr: 1 :rec: "none"  E: "get[0] -- actually an index error, accessing length" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "get[0] -- actually an index error, accessing length"  
 pushThis 
 -- $ObjectInvocation_KeyWord:loadOrigin: "get[0] -- actually an index error, accessing length" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "length" on: 1 isValueObj: false 
 -- origin: String origin:isValueObj: false 
 rpushg length$15 1
 -- $ObjectInvocation_KeyWord:getAdr: "get[0] -- actually an index error, accessing length" >ATd.off:0 (isPtn):on:1:superAdj:0"get[inx: var integer]: {   %basic 117;   out ch: ..."} 
 -- PING:String 0 out V: var integer{   V := get[0] -- actually an index error, accessing length} 
 -- $pattern:getAdr: "get[inx: var integer]: {   %basic 117;   out ch: var char" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, accessing length":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "get[0] -- actually an index error, accessing length"  ATd: "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, accessing length":rec:- 
 -- computeAdr:isLast:E:  "get[0] -- actually an index error, accessing length" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, accessing len ..." 
 -- rec:  "get[0] -- actually an index error, accessing length" E:  "get[0] -- actually an index error, accessing length" 
 -- INV:gen:E.loadArgs "get[0] -- actually an index error, accessing length" 
 -- $ObjectInvocation_KeyWord:loadArgs: "get[0] -- actually an index error, accessing length" >staticOff:0 "get[inx: var integer]: {   %basic 117;   out ch: var char" superAdj ...} 
 -- $pattern:loadArgs: "get[inx: var integer]: {   %basic 117;   out ch: var char" >E:"get[0] -- actually an index error, accessing length":descNo:16} 
 -- ptn:loadArgs:E "get[0] -- actually an index error, accessing length" 
 -- {(ObjectInvocation_KeyWord --24> actually an index error, accessing length; (name: "get"); (Arguments;  (name: "get");  (name: "[");  (ObjectGenerator;   (Invocation;    ( ...} 
 -- args: "get[0]" 
 -- E: "ObjectGenerator" 0 
 -- E.arg: "var" inx: var integer 
 -- NonVirt: "get[0] -- actually an index error, accessing length" "ObjectInvocation_KeyWord" ActArg:  "0" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[0] -- actually an index error, accessing length"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "0" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "0" 
 -- OG:before:super.gen: "0" 
 -- $Invocation:gen: "0" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "0" 
 -- isConstant: "Invocation" "0" 
 -- needorigin: "0" 
 -- needOrigin:E: "0"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "0" E:  "0" 
 -- INV:gen:E.loadArgs "0" 
 -- $ConstLiteral:loadArgs: "0"  
 -- INV:gen:after:E.loadArgs "0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0" 
 -- $ConstLiteral:invoke: "0"  
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "inx: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "0" :isBasicVal: true 
 -- case:B: 0 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "get[0] -- actually an index error, accessing length" 
 -- INV:gen:after:E.loadArgs "get[0] -- actually an index error, accessing length" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[0] -- actually an index error, accessing length" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F ... 
 -- $ObjectInvocation_KeyWord:invoke: "get[0] -- actually an index error, accessing length" >rec:"get[0] -- actually an index error, accessing length" ATd:"pattern" E:"get[0]  ..." 
 -- OI:invoke: "get[0] -- actually an index error, accessing length" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, accessing length":rec:get[0] -- actually an i ... 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, accessing length":rec:get[0] -- actually an i ... 
 -- OI:invoke:B: "get[0] -- actually an index error, accessing length" E: "get[0] -- actually an index error, accessing length"  rec: "get[0] -- actually an index error, acces ..."   ... true "g ..." 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- $pattern:invoke: "get[inx: var integer]: {   %basic 117;   out ch: var char" E: "get[0] -- actually an index error, accessing length" useRTNv: "True"} 
 -- ptn:invoke: "get[inx: var integer]" E: "get[0] -- actually an index error, accessing length" ptnKind: 0 useRtnV: true 
 xpushg  inx 1 0 1
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, accessing length":rec:get[0 ... 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, accessing length":rec:get[0 ... 
 -- 
 -- OI:invoke:C: get[0] -- actually an index error, accessing length :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, accessing length":rec:get[0] -- a ... 
 -- rec: "V" dstE: "V" dstE.ATd: "out V: var integer" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right: "get[0] -- actually an index error, accessing length" 
 -- isArgOfAssignI2IwithUniValArg "V := get[0] -- actually an index error, accessing length" arg: "get[0] -- actually an index error, accessing length" ObjectGenerator 
 -- arg.super.arg: "get[0] -- actually an index error, accessing length" ObjectInvocation_KeyWord 
 -- dstDI: "out V: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg length$15 2
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  "length" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 31 
 -- Items:GenClass: this descNo: 31 isValue: false 
 -- Items:GenClass: this descNo: 21 isValue: false 

 CLASS this 31 1 BETA 2
 -- Store itemArgs: %basic 18{in this: ref Object} 
 -- in this: ref Object true 64 
 -- DI:store: "this" 
 pushThis 
 rstoreg  this 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=31 vDescInx=31 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%basic 18"  
 -- $ref:gen: "in this: ref Object"  
 -- DI:gen: "in this: ref Object" DI:isConst: false :isBasicValue: false :primNo: 64 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%basic 18" 
 -- $Property:gen: "%basic 18"  
 L2:
 -- pushReturn:  "this" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 32 
 -- Items:GenClass: X_asString descNo: 32 isValue: false 
 -- Items:GenClass: X_asString descNo: 21 isValue: false 

 CLASS X_asString 32 1 Object 21
 -- Store itemArgs: out S: var LIB.StringLib.String{inner(X_asString)} 
 -- Store:Origin: 64 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=32 vDescInx=32 vdtTop: 1 
 mvStack 
 -- $var:gen: "out S: var LIB.StringLib.String"  
 -- DI:gen: "out S: var LIB.StringLib.String" DI:isConst: false :isBasicValue: false :primNo: 5 
 -- StringVar "out S: var LIB.StringLib.String" 
 pushText ""
 pushThis 
 rstoreg  S 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 1 V: R: 
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "inner(X_asString)" 
 -- $ObjectGenerator:gen: "inner(X_asString)" >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inner(X_asString)" 
 -- OG:before:super.gen: "inner(X_asString)" 
 -- $Invocation:gen: "inner(X_asString)" >useRtnV:"False"superAdj: 0 descNo: 12 
 -- INV:gen: "inner(X_asString)" 
 -- isConstant: "Invocation" "inner(X_asString)" 
 -- needorigin: "inner(X_asString)" 
 -- needOrigin:E: "inner(X_asString)"  E.ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- doNeedOrigin:Ex: "inner(X_asString)" 
 -- computeAdr:superAdj: 0 "inner(X_asString)" 
 -- computeAdr: 1 :rec: "none"  E: "inner(X_asString)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "inner(X_asString)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "inner(X_asString)" >on:2 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "inner(X_asString)" >ATd.off:0 (isPtn):on:2:superAdj:0"inner: {   %basic 101;   in inner: ref Object":Adr:off:0 size:0 isFloat:F isUnitVa ...} 
 -- $pattern:getAdr: "inner: {   %basic 101;   in inner: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inner(X_asString)"  ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:- 
 -- computeAdr:isLast:E:  "inner(X_asString)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:- 
 -- rec:  "inner(X_asString)" E:  "inner(X_asString)" 
 -- INV:gen:E.loadArgs "inner(X_asString)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "inner(X_asString)" >staticOff:0 "inner: {   %basic 101;   in inner: ref Object" superAdj:0arg:"X_asString"} 
 -- $pattern:loadArgs: "inner: {   %basic 101;   in inner: ref Object" >E:"inner(X_asString)":descNo:12} 
 -- INV:gen:after:E.loadArgs "inner(X_asString)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(X_asString)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inn ..." 
 -- $ObjectInvocation_KeyWord:invoke: "inner(X_asString)" >rec:"inner(X_asString)" ATd:"pattern" E:"inner(X_asString)" E.ATd:"inner" unique:"False" 
 -- OI:invoke: "inner(X_asString)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:inner(X_asString) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:inner(X_asString) 
 -- OI:invoke:B: "inner(X_asString)" E: "inner(X_asString)"  rec: "inner(X_asString)"  useRtnV: false "inner: {   %basic 101;   in inner: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- $pattern:invoke: "inner: {   %basic 101;   in inner: ref Object" E: "inner(X_asString)" useRTNv: "False"} 
 -- ptn:invoke: "inner" E: "inner(X_asString)" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:inner(X_asString) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:inner(X_asString) 
 -- 
 -- OI:invoke:C: inner(X_asString) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:inner(X_asString) 
 L2:
 -- pushReturn:  "X_asString" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- vdtAdd: inx=2 descInx=32 vDescInx=0 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 33 
 -- Items:GenClass: LIB descNo: 33 isValue: false 
 -- Items:GenClass: LIB descNo: 21 isValue: false 

 CLASS LIB 33 1 BETAworld 1
 -- Store itemArgs: %id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--Collections;--Compiler;- ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=33 vDescInx=33 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%id "LIB""  
 -- $Property:gen: "%module BETA"  
 -- Module:genMI:  "BasicIO" 
 -- $obj:gen: "BasicIO: obj {   %module LIB.StringLib;   %Public;   Lock: ;      dummy: var integer;      %Public;      M: var integer;      init: ;         M := 0;      get:  ..."} 
 -- $ObjectGenerator:gen: "%module LIB.StringLib{   %Public;   Lock: ;      dummy: var integer;      %Public;      M: var integer;      init: ;         M := 0;      get: ;     ..."} 
 -- OG:gen: "%module LIB.StringLib{   %Public;   Lock: ;      dummy: var integer;      %Public;      M: var integer;      init: ;         M := 0;      get: ;         res: var  ...}" 
 pushThis 
 -- before objTmpStack:add:  34   "BasicIO" 
 invoke BasicIO 34 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- Module:genMI:  "BasicSystemLib" 
 -- $obj:gen: "BasicSystemLib: obj {   %module Collections, LIB.StringLib, LIB.Collections.QueueLib;   %include Collections, LIB.StringLib;   %public;   Lock: ;      %globals; ..."} 
 -- $ObjectGenerator:gen: "%module Collections, LIB.StringLib, LIB.Collections.QueueLib{   %include Collections, LIB.StringLib;   %public;   Lock: ;      %globals;      %Publi ..."} 
 -- OG:gen: "%module Collections, LIB.StringLib, LIB.Collections.QueueLib{   %include Collections, LIB.StringLib;   %public;   Lock: ;      %globals;      %Public;      in id: ...}" 
 pushThis 
 -- before objTmpStack:add:  38   "BasicSystemLib" 
 invoke BasicSystemLib 38 4 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- Module:genMI:  "Collections" 
 -- $obj:gen: "Collections: obj {   %visible StringLib;   Collection: ;      %id "Collection";      %globals;      in elm:< Object;      insert:< ;         in e: ref elm;      ..."} 
 -- $ObjectGenerator:gen: "%visible StringLib{   Collection: ;      %id "Collection";      %globals;      in elm:< Object;      insert:< ;         in e: ref elm;         inner ..."} 
 -- OG:gen: "%visible StringLib{   Collection: ;      %id "Collection";      %globals;      in elm:< Object;      insert:< ;         in e: ref elm;         inner(insert);      ...}" 
 pushThis 
 -- before objTmpStack:add:  40   "Collections" 
 invoke Collections 40 5 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- Module:genMI:  "Dimensions" 
 -- $obj:gen: "Dimensions: obj {   %domain_boundary;   %public;   Dimension: ;      %dimension "-top-";      %public;      PrimaryUnit:< Unit;      Unit: Value;         %unit  ..."} 
 -- $ObjectGenerator:gen: "%domain_boundary{   %public;   Dimension: ;      %dimension "-top-";      %public;      PrimaryUnit:< Unit;      Unit: Value;         %unit "U", 1;  ..."} 
 -- OG:gen: "%domain_boundary{   %public;   Dimension: ;      %dimension "-top-";      %public;      PrimaryUnit:< Unit;      Unit: Value;         %unit "U", 1;         %publi ...}" 
 pushThis 
 -- before objTmpStack:add:  42   "Dimensions" 
 invoke Dimensions 42 6 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- Module:genMI:  "MonitorSystemLib" 
 -- $obj:gen: "MonitorSystemLib: obj {   %domain_boundary;   %visible LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib;   %module LIB.BasicSystemLib, LIB.BasicSystemLib.Sem ..."} 
 -- $ObjectGenerator:gen: "%domain_boundary{   %visible LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib;   %module LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib;   % ..."} 
 -- OG:gen: "%domain_boundary{   %visible LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib;   %module LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib;   %public;   Moni ...}" 
 pushThis 
 -- before objTmpStack:add:  43   "MonitorSystemLib" 
 invoke MonitorSystemLib 43 7 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -5 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- Module:genMI:  "StringLib" 
 -- $obj:gen: "StringLib: obj {   %id "String module";   %module LIB;   %public;   String: Value;      %id "String pattern";      %OSDvisibility disguised;      %basic 5;      ..."} 
 -- $ObjectGenerator:gen: "%id "String module"{   %module LIB;   %public;   String: Value;      %id "String pattern";      %OSDvisibility disguised;      %basic 5;      %publi ..."} 
 -- OG:gen: "%id "String module"{   %module LIB;   %public;   String: Value;      %id "String pattern";      %OSDvisibility disguised;      %basic 5;      %public;      length ...}" 
 pushThis 
 -- before objTmpStack:add:  44   "StringLib" 
 invoke StringLib 44 8 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -6 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $Property:gen: "%Include BETA"  
 -- $var:gen: "x_dummy_LIB: var integer"  
 -- DI:gen: "x_dummy_LIB: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  x_dummy_LIB 
 -- $ModuleItem:gen: "--AgentSystem{" } 
 -- $ModuleItem:gen: "--Associations{" } 
 -- $ModuleItem:gen: "--BasicIO{" } 
 -- ModuleItem:gen BasicIO 
 -- $obj:gen: "BasicIO: obj {   %module LIB.StringLib;   %Public;   Lock: ;      dummy: var integer;      %Public;      M: var integer;      init: ;         M := 0;      get:  ..."} 
 -- $ModuleItem:gen: "--BasicSystemLib{" } 
 -- ModuleItem:gen BasicSystemLib 
 -- $obj:gen: "BasicSystemLib: obj {   %module Collections, LIB.StringLib, LIB.Collections.QueueLib;   %include Collections, LIB.StringLib;   %public;   Lock: ;      %globals; ..."} 
 -- $ModuleItem:gen: "--COsystem{" } 
 -- $ModuleItem:gen: "--Collections{" } 
 -- ModuleItem:gen Collections 
 -- $obj:gen: "Collections: obj {   %visible StringLib;   Collection: ;      %id "Collection";      %globals;      in elm:< Object;      insert:< ;         in e: ref elm;      ..."} 
 -- $ModuleItem:gen: "--Compiler{" } 
 -- $ModuleItem:gen: "--Complex{" } 
 -- $ModuleItem:gen: "--DateTimeLib{" } 
 -- $ModuleItem:gen: "--Dimensions{" } 
 -- ModuleItem:gen Dimensions 
 -- $obj:gen: "Dimensions: obj {   %domain_boundary;   %public;   Dimension: ;      %dimension "-top-";      %public;      PrimaryUnit:< Unit;      Unit: Value;         %unit  ..."} 
 -- $ModuleItem:gen: "--EMC2array{" } 
 -- $ModuleItem:gen: "--Embedded{" } 
 -- $ModuleItem:gen: "--FileSys{" } 
 -- $ModuleItem:gen: "--ForkJoinSystem{" } 
 -- $ModuleItem:gen: "--MetaSystem{" } 
 -- $ModuleItem:gen: "--MonitorSystemLib{" } 
 -- ModuleItem:gen MonitorSystemLib 
 -- $obj:gen: "MonitorSystemLib: obj {   %domain_boundary;   %visible LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib;   %module LIB.BasicSystemLib, LIB.BasicSystemLib.Sem ..."} 
 -- $ModuleItem:gen: "--NonBlockingIO{" } 
 -- $ModuleItem:gen: "--RandomNumberGeneratorLib{" } 
 -- $ModuleItem:gen: "--SimpleConcurrentProcesses{" } 
 -- $ModuleItem:gen: "--Socket{" } 
 -- $ModuleItem:gen: "--SocketSystem{" } 
 -- $ModuleItem:gen: "--StringLib{" } 
 -- ModuleItem:gen StringLib 
 -- $obj:gen: "StringLib: obj {   %id "String module";   %module LIB;   %public;   String: Value;      %id "String pattern";      %OSDvisibility disguised;      %basic 5;      ..."} 
 -- $ModuleItem:gen: "--Xarray{" } 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%id "LIB"" 
 -- $Property:gen: "%id "LIB""  
 -- genclass:stmt: "%module BETA" 
 -- $Property:gen: "%module BETA"  
 -- genclass:stmt: "%Include BETA" 
 -- $Property:gen: "%Include BETA"  
 L2:
 -- pushReturn:  "LIB" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:8 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 34 
 -- Items:GenClass: BasicIO descNo: 34 isValue: false 
 -- Items:GenClass: BasicIO descNo: 21 isValue: false 

 CLASS BasicIO 34 1 LIB 33
 -- Store itemArgs: %module LIB.StringLib{%Public;Lock: ;   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop:  ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=34 vDescInx=34 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%module LIB.StringLib"  
 -- $Property:gen: "%Public"  
 -- $obj:gen: "keyboard: obj {   %Public;   readLine: ;      out M: var LIB.StringLib.String;      inx: var integer;      msg: obj Indexed(30,integer);      read: obj ;        ..."} 
 -- DI:gen: "keyboard: obj {   %Public;   readLine: ;      out M: var LIB.StringLib.String;      inx: var integer;      msg: obj Indexed(30,integer);      read: obj ;          ...}" D ... true : ... false : ... 0 
 -- DI:add:BP4:  keyboard 
 -- $ObjectGenerator:gen: "%Public{   readLine: ;      out M: var LIB.StringLib.String;      inx: var integer;      msg: obj Indexed(30,integer);      read: obj ;         ch:  ..."} 
 -- OG:gen: "%Public{   readLine: ;      out M: var LIB.StringLib.String;      inx: var integer;      msg: obj Indexed(30,integer);      read: obj ;         ch: var Char;      ...}" 
 pushThis 
 -- before objTmpStack:add:  35   "keyboard" 
 invoke keyboard 35 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $obj:gen: "screen: obj {   L: obj Lock;   %Public;   init: ;      L.get;      L.init;      L.free;   display: ;      L.get;      inner;      L.free" } 
 -- DI:gen: "screen: obj {   L: obj Lock;   %Public;   init: ;      L.get;      L.init;      L.free;   display: ;      L.get;      inner;      L.free}" DI:isConst: true :isBas ... false : ... 0 
 -- DI:add:BP4:  screen 
 -- $ObjectGenerator:gen: "L: obj Lock{   %Public;   init: ;      L.get;      L.init;      L.free;   display: ;      L.get;      inner;      L.free" >OGid:"screen" singular! s ...} 
 -- OG:gen: "L: obj Lock{   %Public;   init: ;      L.get;      L.init;      L.free;   display: ;      L.get;      inner;      L.free}" 
 pushThis 
 -- before objTmpStack:add:  36   "screen" 
 invoke screen 36 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%module LIB.StringLib" 
 -- $Property:gen: "%module LIB.StringLib"  
 -- genclass:stmt: "%Public" 
 -- $Property:gen: "%Public"  
 L2:
 -- pushReturn:  "BasicIO" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 35 
 -- Items:GenClass: keyboard descNo: 35 isValue: false 
 -- Items:GenClass: keyboard descNo: 21 isValue: false 

 CLASS keyboard 35 1 BasicIO 34
 -- Store itemArgs: %Public{readLine: ;   out M: var LIB.StringLib.String;   inx: var integer;   msg: obj Indexed(30,integer);   read: obj ;      ch: var Char;      ch := _iGe ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=35 vDescInx=35 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%Public"  
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%Public" 
 -- $Property:gen: "%Public"  
 L2:
 -- pushReturn:  "keyboard" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 36 
 -- Items:GenClass: screen descNo: 36 isValue: false 
 -- Items:GenClass: screen descNo: 21 isValue: false 

 CLASS screen 36 1 BasicIO 34
 -- Store itemArgs: L: obj Lock{%Public;init: ;   L.get;   L.init;   L.free;display: ;   L.get;   inner;   L.free} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=36 vDescInx=36 vdtTop: 1 
 mvStack 
 -- $obj:gen: "L: obj Lock"  
 -- DI:gen: "L: obj Lock" DI:isConst: true :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  L 
 -- $ObjectGenerator:gen: "Lock" >OGid:"Lock" IS.isempty! staticOff=2 descNo=0 superAdj=0 
 -- OG:gen: "Lock" 
 -- OG:before:super.gen: "Lock" 
 -- $Invocation:gen: "Lock" >useRtnV:"False"superAdj: 0 descNo: 37 
 -- INV:gen: "Lock" 
 -- isConstant: "Invocation" "Lock" 
 -- needorigin: "Lock" 
 -- needOrigin:E: "Lock"  E.ATd: "Lock: {   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;         di ...}" 
 -- doNeedOrigin:Ex: "Lock" 
 -- computeAdr:superAdj: 0 "Lock" 
 -- computeAdr: 1 :rec: "none"  E: "Lock" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Lock"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Lock" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "screen" on: 1 isValueObj: false 
 -- origin: BasicIO origin:isValueObj: false 
 rpushg screen$36 1
 -- $ObjectInvocation_Unary:getAdr: "Lock" >ATd.off:0 (isPtn):on:1:superAdj:0"Lock: {   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      r ..."} 
 -- $pattern:getAdr: "Lock: {   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;         disable;       ..."} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "Lock"  ATd: "Lock: {   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;        ...}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:- 
 -- computeAdr:isLast:E:  "Lock" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:- 
 -- rec:  "Lock" E:  "Lock" 
 -- INV:gen:E.loadArgs "Lock" 
 -- $ObjectInvocation_Unary:loadArgs: "Lock" >staticOff:0 "Lock: {   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;    ..."} 
 -- $pattern:loadArgs: "Lock: {   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;         disable;     ..."} 
 -- ptn:loadArgs:E "Lock" 
 -- {(ObjectInvocation_Unary; (name: "Lock"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "Lock" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "Lock" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:- 
 -- $ObjectInvocation_Unary:invoke: "Lock" >rec:"Lock" ATd:"pattern" E:"Lock" E.ATd:"Lock" unique:"False" 
 -- OI:invoke: "Lock" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:Lock 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:Lock 
 -- OI:invoke:B: "Lock" E: "Lock"  rec: "Lock"  useRtnV: false "Lock: {   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var intege ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Lock 
 -- $pattern:invoke: "Lock: {   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;         disable;       ..."} 
 -- ptn:invoke: "Lock" E: "Lock" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 2 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:Lock 
 invoke Lock 37 2 1
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:Lock 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:Lock 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: Lock :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:Lock 
 -- $Property:gen: "%Public"  
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%Public" 
 -- $Property:gen: "%Public"  
 L2:
 -- pushReturn:  "screen" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 37 
 -- Items:GenClass: Lock descNo: 37 isValue: false 
 -- Items:GenClass: Lock descNo: 21 isValue: false 

 CLASS Lock 37 1 BasicIO 34
 -- Store itemArgs: dummy: var integer{%Public;M: var integer;init: ;   M := 0;get: ;   res: var integer;   loop: obj ;      disable;      res := 17;      res := M.cmpAndSwap( ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=37 vDescInx=37 vdtTop: 1 
 mvStack 
 -- $var:gen: "dummy: var integer"  
 -- DI:gen: "dummy: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  dummy 
 -- $Property:gen: "%Public"  
 -- $var:gen: "M: var integer"  
 -- DI:gen: "M: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  M 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%Public" 
 -- $Property:gen: "%Public"  
 L2:
 -- pushReturn:  "Lock" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 38 
 -- Items:GenClass: BasicSystemLib descNo: 38 isValue: false 
 -- Items:GenClass: BasicSystemLib descNo: 21 isValue: false 

 CLASS BasicSystemLib 38 1 LIB 33
 -- Store itemArgs: %module Collections, LIB.StringLib, LIB.Collections.QueueLib{%include Collections, LIB.StringLib;%public;Lock: ;   %globals;   %Public;   in id: var String ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=38 vDescInx=38 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%module Collections, LIB.StringLib, LIB.Collections.QueueLib"  
 -- Module:genMI:  "SemaphoreLib" 
 -- $obj:gen: "SemaphoreLib: obj {   -- Issues when setting status to WAITING in wait;;   -- preemptive suspend may happen before cooperative suspend after addWaiting;   -- we ..."} 
 -- $ObjectGenerator:gen: "-- Issues when setting status to WAITING in wait;{   -- preemptive suspend may happen before cooperative suspend after addWaiting;   -- we need to c ..."} 
 -- OG:gen: "-- Issues when setting status to WAITING in wait;{   -- preemptive suspend may happen before cooperative suspend after addWaiting;   -- we need to consider if thi ...}" 
 pushThis 
 -- before objTmpStack:add:  39   "SemaphoreLib" 
 invoke SemaphoreLib 39 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $Property:gen: "%include Collections, LIB.StringLib"  
 -- $Property:gen: "%public"  
 -- $ModuleItem:gen: "--SemaphoreLib{" } 
 -- ModuleItem:gen SemaphoreLib 
 -- $obj:gen: "SemaphoreLib: obj {   -- Issues when setting status to WAITING in wait;;   -- preemptive suspend may happen before cooperative suspend after addWaiting;   -- we ..."} 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%module Collections, LIB.StringLib, LIB.Collections.QueueLib" 
 -- $Property:gen: "%module Collections, LIB.StringLib, LIB.Collections.QueueLib"  
 -- genclass:stmt: "%include Collections, LIB.StringLib" 
 -- $Property:gen: "%include Collections, LIB.StringLib"  
 -- genclass:stmt: "%public" 
 -- $Property:gen: "%public"  
 L2:
 -- pushReturn:  "BasicSystemLib" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 39 
 -- Items:GenClass: SemaphoreLib descNo: 39 isValue: false 
 -- Items:GenClass: SemaphoreLib descNo: 21 isValue: false 

 CLASS SemaphoreLib 39 1 BasicSystemLib 38
 -- Store itemArgs: -- Issues when setting status to WAITING in wait;{-- preemptive suspend may happen before cooperative suspend after addWaiting;-- we need to consider if th ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=39 vDescInx=39 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 -- pushReturn:  "SemaphoreLib" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 40 
 -- Items:GenClass: Collections descNo: 40 isValue: false 
 -- Items:GenClass: Collections descNo: 21 isValue: false 

 CLASS Collections 40 1 LIB 33
 -- Store itemArgs: %visible StringLib{Collection: ;   %id "Collection";   %globals;   in elm:< Object;   insert:< ;      in e: ref elm;      inner(insert);   has:< ;      in  ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=40 vDescInx=40 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%visible StringLib"  
 -- Module:genMI:  "QueueLib" 
 -- $obj:gen: "QueueLib: obj {   -- defines a first-in first-out queue%Public;   Queue: ;      %globals;      idf: var LIB.StringLib.String;      idc: var integer;      noOfEl ..."} 
 -- $ObjectGenerator:gen: "-- defines a first-in first-out queue%Public{   Queue: ;      %globals;      idf: var LIB.StringLib.String;      idc: var integer;      noOfElm: var ..."} 
 -- OG:gen: "-- defines a first-in first-out queue%Public{   Queue: ;      %globals;      idf: var LIB.StringLib.String;      idc: var integer;      noOfElm: var integer;      ...}" 
 pushThis 
 -- before objTmpStack:add:  41   "QueueLib" 
 invoke QueueLib 41 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ModuleItem:gen: "--BoundedBufferLib{" } 
 -- $ModuleItem:gen: "--List{" } 
 -- $ModuleItem:gen: "--MapLib{" } 
 -- $ModuleItem:gen: "--OrderedList{" } 
 -- $ModuleItem:gen: "--QueueLib{" } 
 -- ModuleItem:gen QueueLib 
 -- $obj:gen: "QueueLib: obj {   -- defines a first-in first-out queue%Public;   Queue: ;      %globals;      idf: var LIB.StringLib.String;      idc: var integer;      noOfEl ..."} 
 -- $ModuleItem:gen: "--SetLib{" } 
 -- $ModuleItem:gen: "--SimpleList{" } 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%visible StringLib" 
 -- $Property:gen: "%visible StringLib"  
 L2:
 -- pushReturn:  "Collections" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 41 
 -- Items:GenClass: QueueLib descNo: 41 isValue: false 
 -- Items:GenClass: QueueLib descNo: 21 isValue: false 

 CLASS QueueLib 41 1 Collections 40
 -- Store itemArgs: -- defines a first-in first-out queue%Public{Queue: ;   %globals;   idf: var LIB.StringLib.String;   idc: var integer;   noOfElm: var integer;   Element: ; ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=41 vDescInx=41 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%Public"  
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%Public" 
 -- $Property:gen: "%Public"  
 L2:
 -- pushReturn:  "QueueLib" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 42 
 -- Items:GenClass: Dimensions descNo: 42 isValue: false 
 -- Items:GenClass: Dimensions descNo: 21 isValue: false 

 CLASS Dimensions 42 1 LIB 33
 -- Store itemArgs: %domain_boundary{%public;Dimension: ;   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public;      magnitude ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=42 vDescInx=42 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%domain_boundary"  
 -- $Property:gen: "%public"  
 -- $ModuleItem:gen: "--Acceleration{" } 
 -- $ModuleItem:gen: "--AmountOfSubstance{" } 
 -- $ModuleItem:gen: "--AngularAcceleration{" } 
 -- $ModuleItem:gen: "--Area{" } 
 -- $ModuleItem:gen: "--Currency{" } 
 -- $ModuleItem:gen: "--Density{" } 
 -- $ModuleItem:gen: "--ElectricCurrent{" } 
 -- $ModuleItem:gen: "--ElectricFrequency{" } 
 -- $ModuleItem:gen: "--ElectricPower{" } 
 -- $ModuleItem:gen: "--ElectricVoltage{" } 
 -- $ModuleItem:gen: "--Energy{" } 
 -- $ModuleItem:gen: "--Force{" } 
 -- $ModuleItem:gen: "--Length{" } 
 -- $ModuleItem:gen: "--LuminousIntensity{" } 
 -- $ModuleItem:gen: "--MagneticFluxDensity{" } 
 -- $ModuleItem:gen: "--Mass{" } 
 -- $ModuleItem:gen: "--MassFlowRate{" } 
 -- $ModuleItem:gen: "--MeterPowerN{" } 
 -- $ModuleItem:gen: "--RadioNuclide{" } 
 -- $ModuleItem:gen: "--Temperature{" } 
 -- $ModuleItem:gen: "--ThermodynamicTemperature{" } 
 -- $ModuleItem:gen: "--Time{" } 
 -- $ModuleItem:gen: "--Velocity{" } 
 -- $ModuleItem:gen: "--Volume{" } 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%domain_boundary" 
 -- $Property:gen: "%domain_boundary"  
 -- genclass:stmt: "%public" 
 -- $Property:gen: "%public"  
 L2:
 -- pushReturn:  "Dimensions" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 43 
 -- Items:GenClass: MonitorSystemLib descNo: 43 isValue: false 
 -- Items:GenClass: MonitorSystemLib descNo: 21 isValue: false 

 CLASS MonitorSystemLib 43 1 LIB 33
 -- Store itemArgs: %domain_boundary{%visible LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib;%module LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib;%public;MonitorSy ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=43 vDescInx=43 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%domain_boundary"  
 -- $Property:gen: "%visible LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib"  
 -- $Property:gen: "%module LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib"  
 -- $Property:gen: "%public"  
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%domain_boundary" 
 -- $Property:gen: "%domain_boundary"  
 -- genclass:stmt: "%visible LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib" 
 -- $Property:gen: "%visible LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib"  
 -- genclass:stmt: "%module LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib" 
 -- $Property:gen: "%module LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib"  
 -- genclass:stmt: "%public" 
 -- $Property:gen: "%public"  
 L2:
 -- pushReturn:  "MonitorSystemLib" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 44 
 -- Items:GenClass: StringLib descNo: 44 isValue: false 
 -- Items:GenClass: StringLib descNo: 21 isValue: false 

 CLASS StringLib 44 1 LIB 33
 -- Store itemArgs: %id "String module"{%module LIB;%public;String: Value;   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: v ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=44 vDescInx=44 vdtTop: 1 
 saveStringOrigin
 mvStack 
 -- $Property:gen: "%id "String module""  
 -- $Property:gen: "%module LIB"  
 -- $Property:gen: "%public"  
 -- $pattern:gen: "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- actually  ..."} 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%id "String module"" 
 -- $Property:gen: "%id "String module""  
 -- genclass:stmt: "%module LIB" 
 -- $Property:gen: "%module LIB"  
 -- genclass:stmt: "%public" 
 -- $Property:gen: "%public"  
 L2:
 -- pushReturn:  "StringLib" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 18 
 -- Items:GenClass: $18 descNo: 18 isValue: false 
 -- Items:GenClass: $18 descNo: 21 isValue: false 

 CLASS $18 18 1 loop 14
 -- Store itemArgs: leave(loop) 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=18 vDescInx=18 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "leave(loop)" 
 -- $ObjectGenerator:gen: "leave(loop)" >OGid:"leave" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "leave(loop)" 
 -- OG:before:super.gen: "leave(loop)" 
 -- $Invocation:gen: "leave(loop)" >useRtnV:"False"superAdj: 0 descNo: 19 
 -- INV:gen: "leave(loop)" 
 -- isConstant: "Invocation" "leave(loop)" 
 -- needorigin: "leave(loop)" 
 -- needOrigin:E: "leave(loop)"  E.ATd: "leave(V: var integer): {   %basic 103}" 
 -- doNeedOrigin:Ex: "leave(loop)" 
 -- computeAdr:superAdj: 0 "leave(loop)" 
 -- computeAdr: 1 :rec: "none"  E: "leave(loop)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "leave(loop)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "leave(loop)" >on:5 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "leave(loop)" >ATd.off:0 (isPtn):on:5:superAdj:0"leave(V: var integer): {   %basic 103":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 ...} 
 -- $pattern:getAdr: "leave(V: var integer): {   %basic 103" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:- 
 -- E.on: 5 
 -- beforeIsValueObj:E: "leave(loop)"  ATd: "leave(V: var integer): {   %basic 103}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:- 
 -- computeAdr:isLast:E:  "leave(loop)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:- 
 -- rec:  "leave(loop)" E:  "leave(loop)" 
 -- INV:gen:E.loadArgs "leave(loop)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "leave(loop)" >staticOff:0 "leave(V: var integer): {   %basic 103" superAdj:0arg:"loop"} 
 -- $pattern:loadArgs: "leave(V: var integer): {   %basic 103" >E:"leave(loop)":descNo:19} 
 -- INV:gen:after:E.loadArgs "leave(loop)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "leave(loop)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loo ..." 
 -- $ObjectInvocation_KeyWord:invoke: "leave(loop)" >rec:"leave(loop)" ATd:"pattern" E:"leave(loop)" E.ATd:"leave(V: var integer)" unique:"False" 
 -- OI:invoke: "leave(loop)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- OI:invoke:B: "leave(loop)" E: "leave(loop)"  rec: "leave(loop)"  useRtnV: false "leave(V: var integer): {   %basic 103}" 
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- $pattern:invoke: "leave(V: var integer): {   %basic 103" E: "leave(loop)" useRTNv: "False"} 
 -- ptn:invoke: "leave(V: var integer)" E: "leave(loop)" ptnKind: 0 useRtnV: false 
 break  1 2 14 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- 
 -- OI:invoke:C: leave(loop) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 20 
 -- Items:GenClass: if:then descNo: 20 isValue: false 
 -- Items:GenClass: if:then descNo: 21 isValue: false 

 CLASS if:then 20 0 BETA 2
 -- Store itemArgs: %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- cond: var boolean true 4 
 -- DI:store: "cond" 
 pushThis 
 storeg Boolean$45 1
 allocEventQ
 -- vdtAdd: inx=1 descInx=20 vDescInx=20 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%OSDvisibility skipInternal"  
 -- $Property:gen: "%basic 100"  
 -- $Property:gen: "%globals inSub"  
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%OSDvisibility skipInternal" 
 -- $Property:gen: "%OSDvisibility skipInternal"  
 -- genclass:stmt: "%basic 100" 
 -- $Property:gen: "%basic 100"  
 -- genclass:stmt: "%globals inSub" 
 -- $Property:gen: "%globals inSub"  
 L2:
 -- pushReturn:  "if:then" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:1 objSize:1 isIndexed:0
 -- vdtAdd: inx=2 descInx=20 vDescInx=22 vdtTop: 2 

 CLASS thenPart#22 22 0 if:then$20 20 isVstub
 -- Load origin:OG.isVirtualArg: false 
 -- OG.super.on/descNo: 1 21 
 invoke Object 21 0 1
 pushThis 
 rstoreg   2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:1 objSize:3 isIndexed:0
 -- vdt:a:dNo: 22  newDescNo:  20 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 45 
 -- Items:GenClass: Boolean descNo: 45 isValue: true 
 -- Items:GenClass: Boolean descNo: 4 isValue: true 
 -- Items:GenClass: Value descNo: 21 isValue: true 

 CLASS Boolean 45 0 BETA 2 isValueObj
 -- Store itemArgs: %id "Boolean"{%globals inSub;%basic 4, 8;%public;_thisBasicValue: var Universal;&&  : ;   %basic 70;   in B: var boolean;   out R: var boolean;||  : ;   %b ...} 
 -- vdtAdd: inx=1 descInx=45 vDescInx=45 vdtTop: 1 
 -- $Property:gen: "%id "Boolean""  
 -- $Property:gen: "%globals inSub"  
 -- $Property:gen: "%basic 4, 8"  
 -- $Property:gen: "%public"  
 -- $var:gen: "_thisBasicValue: var Universal"  
 -- DI:gen: "_thisBasicValue: var Universal" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  _thisBasicValue 
DO:
 L1:
 -- genclass:stmt: "%id "Boolean"" 
 -- $Property:gen: "%id "Boolean""  
 -- genclass:stmt: "%globals inSub" 
 -- $Property:gen: "%globals inSub"  
 -- genclass:stmt: "%basic 4, 8" 
 -- $Property:gen: "%basic 4, 8"  
 -- genclass:stmt: "%public" 
 -- $Property:gen: "%public"  
 L2:
 -- pushReturn:  "Boolean" 
 rtnV
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 23 
 -- Items:GenClass: True descNo: 23 isValue: false 
 -- Items:GenClass: True descNo: 21 isValue: false 

 CLASS True 23 0 BETA 2
 -- Store itemArgs: %globals{out B: var boolean;B := 1} 
 allocEventQ
 -- vdtAdd: inx=1 descInx=23 vDescInx=23 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%globals"  
 -- $var:gen: "out B: var boolean"  
 -- DI:gen: "out B: var boolean" DI:isConst: false :isBasicValue: true :primNo: 4 
 -- DI:add:BP1:  B 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%globals" 
 -- $Property:gen: "%globals"  
 -- genclass:stmt: "B := 1" 
 -- $Assign:gen: "B := 1"  
 -- assign: "B := 1" 
 -- computeAdr:superAdj: 0 "B" 
 -- computeAdr: 1 :rec: "none"  E: "B" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "B"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "B" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "B" >ATd.off:1:on:0:superAdj:0"out B: var boolean":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "out B: var boolean" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F o ... 
 -- DI:OG: boolean 
 -- before:floatTest:  "out B: var boolean" ObjectGenerator 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- After:U*U: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- computeAdr:isLast:E:  "B" 
 -- AssignmentStatement:gen: "B := 1" right.label: "ObjectGenerator" "1" 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "B" dstE: "B" dstE.ATd: "out B: var boolean" useRtn: false :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "1" 
 -- isArgOfAssignI2IwithUniValArg "B := 1" arg: "1" ObjectGenerator 
 -- arg.super.arg: "1" ConstLiteral 
 -- dstDI: "out B: var boolean" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg True$23 1
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  "True" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 28 
 -- Items:GenClass: for:to:repeat descNo: 28 isValue: false 
 -- Items:GenClass: for:to:repeat descNo: 21 isValue: false 

 CLASS for:to:repeat 28 0 BETA 2
 -- Store itemArgs: %OSDvisibility skipInternal{%globals inSub;inx: var integer;inx := first;_doIt: do ;   if (inx <= last) :then ;      repeat;      inx := inx + 1;      rest ...} 
 -- last: var integer true 1 
 -- DI:store: "last" 
 pushThis 
 storeg integer$5 2
 -- first: var integer true 1 
 -- DI:store: "first" 
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- vdtAdd: inx=1 descInx=28 vDescInx=28 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%OSDvisibility skipInternal"  
 -- $Property:gen: "%globals inSub"  
 -- $var:gen: "inx: var integer"  
 -- DI:gen: "inx: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  inx 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%OSDvisibility skipInternal" 
 -- $Property:gen: "%OSDvisibility skipInternal"  
 -- genclass:stmt: "%globals inSub" 
 -- $Property:gen: "%globals inSub"  
 -- genclass:stmt: "inx := first" 
 -- $Assign:gen: "inx := first"  
 -- assign: "inx := first" 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:3:on:0:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- AssignmentStatement:gen: "inx := first" right.label: "ObjectGenerator" "first" 
 -- $ObjectGenerator:gen: "first" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "first" 
 -- OG:before:super.gen: "first" 
 -- $Invocation:gen: "first" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "first" 
 -- isConstant: "Invocation" "first" 
 -- notConst: first first: var integer 
 -- needorigin: "first" 
 -- needOrigin:E: "first"  E.ATd: "first: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "first" 
 -- computeAdr: 1 :rec: "none"  E: "first" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "first"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "first" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "first" >ATd.off:1:on:0:superAdj:0"first: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ... 
 -- $var:getAdr: "first: var integer" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F o ... 
 -- DI:OG: integer 
 -- before:floatTest:  "first: var integer" ObjectGenerator 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:- 
 -- After:U*U: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:- 
 -- computeAdr:isLast:E:  "first" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:- 
 -- rec:  "first" E:  "first" 
 -- INV:gen:E.loadArgs "first" 
 -- $ObjectInvocation_Unary:loadArgs: "first" >staticOff:0 "first: var integer" superAdj:0 
 -- $var:loadArgs: "first: var integer" >E:"first" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "first" 
 -- {(ObjectInvocation_Unary; (name: "first"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "first" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "first" :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:- 
 -- $ObjectInvocation_Unary:invoke: "first" >rec:"first" ATd:"var" isValueObj E:"first" E.ATd:"first" unique:"False" 
 -- OI:invoke: "first" 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:first 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:first 
 -- OI:invoke:B: "first" E: "first"  rec: "first"  useRtnV: true "first: var integer" 
 -- OI:invoke:before:ATdx.invoke: var first 
 -- $var:invoke: "first: var integer" E: "first">newOff:1 useRTNv: "True" 
 -- DI:invoke: "first: var integer" 
 -- load: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:first 
 -- isCompositeValueObj: false E: "first" "first: var integer" true 
 -- E.ATd.isValueObj: false rec: "first" 
 pushg 1 for:to:repeat$28
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:first 
 -- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:first 
 -- 
 -- OI:invoke:C: first :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 1 
 -- OG:gen:end: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:first 
 -- rec: "inx" dstE: "inx" dstE.ATd: "inx: var integer" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "first" 
 -- isArgOfAssignI2IwithUniValArg "inx := first" arg: "first" ObjectGenerator 
 -- arg.super.arg: "first" ObjectInvocation_Unary 
 -- dstDI: "inx: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg for:to:repeat$28 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "_doIt: do {   if (inx <= last) :then ;      repeat;      inx := inx + 1;      restart(_doIt);   :else ;      inx := inx}" 
 -- $do:gen: "_doIt: do {   if (inx <= last) :then ;      repeat;      inx := inx + 1;      restart(_doIt);   :else ;      inx := inx" } 
 -- $ObjectGenerator:gen: "if (inx <= last) :then {      repeat;      inx := inx + 1;      restart(_doIt);   :else ;      inx := inx" >OGid:"_doIt" singular! staticOff=0 descN ...} 
 -- OG:gen: "if (inx <= last) :then {      repeat;      inx := inx + 1;      restart(_doIt);   :else ;      inx := inx}" 
 pushThis 
 -- before objTmpStack:add:  46   "_doIt" 
 invoke _doIt 46 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 -- pushReturn:  "for:to:repeat" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:1 objSize:3 isIndexed:0
 -- vdtAdd: inx=2 descInx=28 vDescInx=29 vdtTop: 2 

 CLASS repeat#29 29 0 for:to:repeat$28 28 isVstub
 -- Load origin:OG.isVirtualArg: false 
 -- OG.super.on/descNo: 1 21 
 invoke Object 21 0 1
 pushThis 
 rstoreg   2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:1 objSize:3 isIndexed:0
 -- vdt:a:dNo: 29  newDescNo:  28 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 46 
 -- Items:GenClass: _doIt descNo: 46 isValue: false 
 -- Items:GenClass: _doIt descNo: 21 isValue: false 

 CLASS _doIt 46 1 for:to:repeat 28
 -- Store itemArgs: if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=46 vDescInx=46 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- $ObjectGenerator:gen: "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx" >OGid:"if:then$0" IS.isempty! staticOff=0 descNo=0 super ...} 
 -- OG:gen: "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- OG:before:super.gen: "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- $Invocation:gen: "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx" >useRtnV:"False"superAdj: 0} 
 -- INV:gen: "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- isConstant: "Invocation" "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- needorigin: "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- needOrigin:E: "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}"  E.ATd: "if(cond: var boolean):then{thenPart:< object}: {   %OS ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" E:  "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_do ...}" 
 -- INV:gen:E.loadArgs "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- $IfThenElse:loadArgs: "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx" } 
 -- INV:gen:after:E.loadArgs "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThenElse "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- $IfThenElse:invoke: "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx" } 
 -- $IfThenElse:gen: "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx" } 
 -- $ObjectGenerator:gen: "(inx <= last)" >OGid:"<=" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(inx <= last)" 
 -- OG:before:super.gen: "(inx <= last)" 
 -- $Invocation:gen: "(inx <= last)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(inx <= last)" 
 -- isConstant: "Invocation" "(inx <= last)" 
 -- needorigin: "(inx <= last)" 
 -- needOrigin:E: "(inx <= last)"  E.ATd: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- doNeedOrigin:Ex: "(inx <= last)" 
 -- computeAdr:superAdj: 0 "(inx <= last)" 
 -- computeAdr: 1 :rec: "none"  E: "(inx <= last)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(inx <= last)"  
 -- $BracketedExp:loadOrigin: "(inx <= last)"  
 -- computeAdr:superAdj: 0 "inx <= last" 
 -- computeAdr: 1 :rec: "none"  E: "inx <= last" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "inx <= last"  
 -- $BinOp:loadOrigin: "inx <= last"  
 -- BinaryExp:loadOrigin:empty: "inx <= last" superAdj: 0 
 -- $BinOp:getAdr: "inx <= last"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx <= last"  ATd: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "inx <= last" 
 -- BE:loadOrigin:E: inx <= last 
 -- $BinOp:getAdr: "inx <= last"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx <= last"  ATd: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "inx <= last" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "inx <= last" E:  "inx <= last" 
 -- INV:gen:E.loadArgs "inx <= last" 
 -- $BinOp:loadArgs: "inx <= last"  
 -- BinaryExp:loadArgs: "inx <= last" superAdj: 0 
 -- $Invocation:gen: "inx" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "inx" 
 -- isConstant: "Invocation" "inx" 
 -- notConst: inx inx: var integer 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "_doIt" on: 1 isValueObj: false 
 -- origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$46 1
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:3:on:1:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- $ObjectInvocation_Unary:loadArgs: "inx" >staticOff:0 "inx: var integer" superAdj:0 
 -- $var:loadArgs: "inx: var integer" >E:"inx" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "inx" 
 -- {(ObjectInvocation_Unary; (name: "inx"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: "inx" >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:"inx" unique:"False" 
 -- OI:invoke: "inx" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx" E: "inx"  rec: "inx"  useRtnV: true "inx: var integer" 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: "inx: var integer" E: "inx">newOff:3 useRTNv: "True" 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- isCompositeValueObj: false E: "inx" "inx: var integer" true 
 -- E.ATd.isValueObj: false rec: "inx" 
 pushg 3 for:to:repeat$28
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:C: inx :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- left:#I "inx <= last" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- $pattern:loadArgs: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean" >E:"<= last":descNo:47} 
 -- ptn:loadArgs:E "<= last" 
 -- {(ObjectInvocation_Binary; (name: "<="); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "last");     (Arguments)));   (Items descNo:  ...} 
 -- args: "last" 
 -- E: "ObjectGenerator" last 
 -- E.arg: "var" in Veq: var this(Value) 
 -- NonVirt: "<= last" "ObjectInvocation_Binary" ActArg:  "last" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "<= last"  isCompositeValueObj: true 
 -- $ObjectGenerator:gen: "last" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "last" 
 -- OG:before:super.gen: "last" 
 -- $Invocation:gen: "last" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "last" 
 -- isConstant: "Invocation" "last" 
 -- notConst: last last: var integer 
 -- needorigin: "last" 
 -- needOrigin:E: "last"  E.ATd: "last: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "last" 
 -- computeAdr: 1 :rec: "none"  E: "last" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "last"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "last" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "_doIt" on: 1 isValueObj: false 
 -- origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$46 1
 -- $ObjectInvocation_Unary:getAdr: "last" >ATd.off:2:on:1:superAdj:0"last: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F ... 
 -- $var:getAdr: "last: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F or ... 
 -- DI:OG: integer 
 -- before:floatTest:  "last: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "last"  ATd: "last: var integer" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:- 
 -- computeAdr:isLast:E:  "last" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:- 
 -- rec:  "last" E:  "last" 
 -- INV:gen:E.loadArgs "last" 
 -- $ObjectInvocation_Unary:loadArgs: "last" >staticOff:0 "last: var integer" superAdj:0 
 -- $var:loadArgs: "last: var integer" >E:"last" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "last" 
 -- {(ObjectInvocation_Unary; (name: "last"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "last" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "last" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:- 
 -- $ObjectInvocation_Unary:invoke: "last" >rec:"last" ATd:"var" isValueObj E:"last" E.ATd:"last" unique:"False" 
 -- OI:invoke: "last" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:last 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:last 
 -- OI:invoke:B: "last" E: "last"  rec: "last"  useRtnV: true "last: var integer" 
 -- OI:invoke:before:ATdx.invoke: var last 
 -- $var:invoke: "last: var integer" E: "last">newOff:2 useRTNv: "True" 
 -- DI:invoke: "last: var integer" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:last 
 -- isCompositeValueObj: false E: "last" "last: var integer" true 
 -- E.ATd.isValueObj: false rec: "last" 
 pushg 2 for:to:repeat$28
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:last 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:last 
 -- 
 -- OI:invoke:C: last :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:last 
 -- vEq: 
 -- end:loadArgs:NonVirt: "<= last" 
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:after:E.loadArgs "inx <= last" 
 -- OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- IV:E.invoke:useRtnVal: true E: BinOp "inx <= last" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- $BinOp:invoke: "inx <= last"  
 -- BinaryExp:invoke: "inx" rec: "inx <= last" 
 -- M: "<= last" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- $ObjectInvocation_Binary:invoke: "<= last" >rec:"inx" ATd:"pattern" E:"<= last" E.ATd:"<=  " unique:"False" 
 -- OI:invoke: "<= last" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- origin:isValueObj "Value" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "<= last" E: "<= last"  rec: "inx"  useRtnV: true "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- OI:invoke:before:ATdx.invoke: pattern <=   
 -- $pattern:invoke: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean" E: "<= last" useRTNv: "True"} 
 -- ptn:invoke: "<=  " E: "<= last" ptnKind: 1 useRtnV: true 
 -- rec: "inx" "Invocation" OGx.label: "ObjectGenerator" OGx: integer 
 -- rec.ATd: "inx: var integer" 
 -- bobs: 1 OGx: integer 
 le
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<= last":rec:inx 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<= last":rec:inx 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: <= last :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: "repeat{   inx := inx + 1;   restart(_doIt)" >OGid:"$48" singular! staticOff=0 descNo=48 superAdj=0} 
 -- OG:gen: "repeat{   inx := inx + 1;   restart(_doIt)}" 
 pushThis 
 -- before objTmpStack:add:  48   "$48" 
 invoke $48 48 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L5
 L4:
 -- $ObjectGenerator:gen: "inx := inx" >OGid:"$51" singular! staticOff=0 descNo=51 superAdj=0 
 -- OG:gen: "inx := inx" 
 pushThis 
 -- before objTmpStack:add:  51   "$51" 
 invoke $51 51 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L5:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 -- pushReturn:  "_doIt" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 48 
 -- Items:GenClass: $48 descNo: 48 isValue: false 
 -- Items:GenClass: $48 descNo: 21 isValue: false 

 CLASS $48 48 1 _doIt 46
 -- Store itemArgs: repeat{inx := inx + 1;restart(_doIt)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=48 vDescInx=48 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "repeat" 
 -- $ObjectGenerator:gen: "repeat" >OGid:"Object" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "repeat" 
 -- OG:before:super.gen: "repeat" 
 -- $Invocation:gen: "repeat" >useRtnV:"False"superAdj: 0 descNo: 0 
 -- INV:gen: "repeat" 
 -- isConstant: "Invocation" "repeat" 
 -- needorigin: "repeat" 
 -- needOrigin:E: "repeat"  E.ATd: "repeat:< object" 
 -- doNeedOrigin:Ex: "repeat" 
 -- computeAdr:superAdj: 0 "repeat" 
 -- computeAdr: 1 :rec: "none"  E: "repeat" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "repeat"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "repeat" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$48" on: 2 isValueObj: false 
 -- origin: _doIt origin:isValueObj: false 
 rpushg $48$48 1
 -- items:goOrigin:encOG: "_doIt" on: 1 isValueObj: false 
 -- origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$46 1
 -- $ObjectInvocation_Unary:getAdr: "repeat" >ATd.off:0 (isPtn):on:2:superAdj:0"repeat:< object":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- $pattern:getAdr: "repeat:< object"  
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "repeat"  ATd: "repeat:< object" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:- 
 -- computeAdr:isLast:E:  "repeat" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:- 
 -- rec:  "repeat" E:  "repeat" 
 -- INV:gen:E.loadArgs "repeat" 
 -- $ObjectInvocation_Unary:loadArgs: "repeat" >staticOff:0 "repeat:< object" superAdj:0 
 -- $pattern:loadArgs: "repeat:< object" >E:"repeat":descNo:0 
 -- ptn:loadArgs:E "repeat" 
 -- {(ObjectInvocation_Unary; (name: "repeat"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "repeat" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "repeat" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:- 
 -- $ObjectInvocation_Unary:invoke: "repeat" >rec:"repeat" ATd:"pattern" E:"repeat" E.ATd:"repeat" unique:"False" 
 -- OI:invoke: "repeat" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:repeat 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:repeat 
 -- OI:invoke:B: "repeat" E: "repeat"  rec: "repeat"  useRtnV: false "repeat:< object" 
 -- OI:invoke:before:ATdx.invoke: pattern repeat 
 -- $pattern:invoke: "repeat:< object" E: "repeat" useRTNv: "False" 
 -- ptn:invoke: "repeat" E: "repeat" ptnKind: 1 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 1 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:repeat 
 -- isPtn 
 -- isStatic: false rec: "repeat" 
 invokev 2 0 repeat$29$29 0
 -- GeneralPTN:invoke:after:pushOut: 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:repeat 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:repeat 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: repeat :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:repeat 
 -- genclass:stmt: "inx := inx + 1" 
 -- $Assign:gen: "inx := inx + 1"  
 -- assign: "inx := inx + 1" 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$48" on: 2 isValueObj: false 
 -- origin: _doIt origin:isValueObj: false 
 rpushg $48$48 1
 -- items:goOrigin:encOG: "_doIt" on: 1 isValueObj: false 
 -- origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$46 1
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:3:on:2:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- AssignmentStatement:gen: "inx := inx + 1" right.label: "ObjectGenerator" "inx + 1" 
 -- $ObjectGenerator:gen: "inx + 1" >OGid:"+" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inx + 1" 
 -- OG:before:super.gen: "inx + 1" 
 -- $Invocation:gen: "inx + 1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "inx + 1" 
 -- isConstant: "Invocation" "inx + 1" 
 -- needorigin: "inx + 1" 
 -- needOrigin:E: "inx + 1"  E.ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- doNeedOrigin:Ex: "inx + 1" 
 -- computeAdr:superAdj: 0 "inx + 1" 
 -- computeAdr: 1 :rec: "none"  E: "inx + 1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "inx + 1"  
 -- $BinOp:loadOrigin: "inx + 1"  
 -- BinaryExp:loadOrigin:empty: "inx + 1" superAdj: 0 
 -- $BinOp:getAdr: "inx + 1"  
 -- E.on: 2 
 -- beforeIsValueObj:E: "inx + 1"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "inx + 1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "inx + 1" E:  "inx + 1" 
 -- INV:gen:E.loadArgs "inx + 1" 
 -- $BinOp:loadArgs: "inx + 1"  
 -- BinaryExp:loadArgs: "inx + 1" superAdj: 0 
 -- $Invocation:gen: "inx" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "inx" 
 -- isConstant: "Invocation" "inx" 
 -- notConst: inx inx: var integer 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$48" on: 2 isValueObj: false 
 -- origin: _doIt origin:isValueObj: false 
 rpushg $48$48 1
 -- items:goOrigin:encOG: "_doIt" on: 1 isValueObj: false 
 -- origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$46 1
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:3:on:2:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- $ObjectInvocation_Unary:loadArgs: "inx" >staticOff:0 "inx: var integer" superAdj:0 
 -- $var:loadArgs: "inx: var integer" >E:"inx" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "inx" 
 -- {(ObjectInvocation_Unary; (name: "inx"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: "inx" >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:"inx" unique:"False" 
 -- OI:invoke: "inx" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx" E: "inx"  rec: "inx"  useRtnV: true "inx: var integer" 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: "inx: var integer" E: "inx">newOff:3 useRTNv: "True" 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- isCompositeValueObj: false E: "inx" "inx: var integer" true 
 -- E.ATd.isValueObj: false rec: "inx" 
 pushg 3 for:to:repeat$28
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:C: inx :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- left:#I "inx + 1" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- $pattern:loadArgs: "+  : {   %basic 61;   in V: var integer;   out R: var integer" >E:"+ 1":descNo:49} 
 -- ptn:loadArgs:E "+ 1" 
 -- {(ObjectInvocation_Binary; (name: "+"); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 1));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "1" 
 -- E: "ObjectGenerator" 1 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "+ 1" "ObjectInvocation_Binary" ActArg:  "1" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ 1"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "1" :isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "+ 1" 
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:after:E.loadArgs "inx + 1" 
 -- OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- IV:E.invoke:useRtnVal: true E: BinOp "inx + 1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- $BinOp:invoke: "inx + 1"  
 -- BinaryExp:invoke: "inx" rec: "inx + 1" 
 -- M: "+ 1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- $ObjectInvocation_Binary:invoke: "+ 1" >rec:"inx" ATd:"pattern" E:"+ 1" E.ATd:"+  " unique:"False" 
 -- OI:invoke: "+ 1" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- origin:isValueObj "integer" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "+ 1" E: "+ 1"  rec: "inx"  useRtnV: true "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- $pattern:invoke: "+  : {   %basic 61;   in V: var integer;   out R: var integer" E: "+ 1" useRTNv: "True"} 
 -- ptn:invoke: "+  " E: "+ 1" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "inx" E: "+ 1" 
 -- arg:integer 
 plus
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:inx 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:inx 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: + 1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "inx" dstE: "inx" dstE.ATd: "inx: var integer" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "inx + 1" 
 -- isArgOfAssignI2IwithUniValArg "inx := inx + 1" arg: "inx + 1" ObjectGenerator 
 -- arg.super.arg: "inx + 1" BinOp 
 -- recx:BinaryExp:recx: "inx + 1" 
 -- M: "+ 1" label: "ObjectInvocation_Binary" M.ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- checkInt2IntWithUnitArg:rec: "inx" E: "+ 1" 
 -- arg:integer 
 -- M:arg: "1" ObjectGenerator false 
 -- dstDI: "inx: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg for:to:repeat$28 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "restart(_doIt)" 
 -- $ObjectGenerator:gen: "restart(_doIt)" >OGid:"restart" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "restart(_doIt)" 
 -- OG:before:super.gen: "restart(_doIt)" 
 -- $Invocation:gen: "restart(_doIt)" >useRtnV:"False"superAdj: 0 descNo: 50 
 -- INV:gen: "restart(_doIt)" 
 -- isConstant: "Invocation" "restart(_doIt)" 
 -- needorigin: "restart(_doIt)" 
 -- needOrigin:E: "restart(_doIt)"  E.ATd: "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- doNeedOrigin:Ex: "restart(_doIt)" 
 -- computeAdr:superAdj: 0 "restart(_doIt)" 
 -- computeAdr: 1 :rec: "none"  E: "restart(_doIt)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "restart(_doIt)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "restart(_doIt)" >on:3 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "restart(_doIt)" >ATd.off:0 (isPtn):on:3:superAdj:0"restart(V: var integer):  -- odd parameter type!{   %basic 102":Adr:off:0 size:0 isFl ...} 
 -- $pattern:getAdr: "restart(V: var integer):  -- odd parameter type!{   %basic 102" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:- 
 -- E.on: 3 
 -- beforeIsValueObj:E: "restart(_doIt)"  ATd: "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:- 
 -- computeAdr:isLast:E:  "restart(_doIt)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:- 
 -- rec:  "restart(_doIt)" E:  "restart(_doIt)" 
 -- INV:gen:E.loadArgs "restart(_doIt)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "restart(_doIt)" >staticOff:0 "restart(V: var integer):  -- odd parameter type!{   %basic 102" superAdj:0arg:"_doIt"} 
 -- $pattern:loadArgs: "restart(V: var integer):  -- odd parameter type!{   %basic 102" >E:"restart(_doIt)":descNo:50} 
 -- INV:gen:after:E.loadArgs "restart(_doIt)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "restart(_doIt)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restar ..." 
 -- $ObjectInvocation_KeyWord:invoke: "restart(_doIt)" >rec:"restart(_doIt)" ATd:"pattern" E:"restart(_doIt)" E.ATd:"restart(V: var integer)" unique:"False" 
 -- OI:invoke: "restart(_doIt)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:restart(_doIt) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:restart(_doIt) 
 -- OI:invoke:B: "restart(_doIt)" E: "restart(_doIt)"  rec: "restart(_doIt)"  useRtnV: false "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- OI:invoke:before:ATdx.invoke: pattern restart(V: var integer) 
 -- $pattern:invoke: "restart(V: var integer):  -- odd parameter type!{   %basic 102" E: "restart(_doIt)" useRTNv: "False"} 
 -- ptn:invoke: "restart(V: var integer)" E: "restart(_doIt)" ptnKind: 0 useRtnV: false 
 break  1 1 46 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:restart(_doIt) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:restart(_doIt) 
 -- 
 -- OI:invoke:C: restart(_doIt) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:restart(_doIt) 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 51 
 -- Items:GenClass: $51 descNo: 51 isValue: false 
 -- Items:GenClass: $51 descNo: 21 isValue: false 

 CLASS $51 51 1 _doIt 46
 -- Store itemArgs: inx := inx 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=51 vDescInx=51 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "inx := inx" 
 -- $Assign:gen: "inx := inx"  
 -- assign: "inx := inx" 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$51" on: 2 isValueObj: false 
 -- origin: _doIt origin:isValueObj: false 
 rpushg $51$51 1
 -- items:goOrigin:encOG: "_doIt" on: 1 isValueObj: false 
 -- origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$46 1
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:3:on:2:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- AssignmentStatement:gen: "inx := inx" right.label: "ObjectGenerator" "inx" 
 -- $ObjectGenerator:gen: "inx" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inx" 
 -- OG:before:super.gen: "inx" 
 -- $Invocation:gen: "inx" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "inx" 
 -- isConstant: "Invocation" "inx" 
 -- notConst: inx inx: var integer 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$51" on: 2 isValueObj: false 
 -- origin: _doIt origin:isValueObj: false 
 rpushg $51$51 1
 -- items:goOrigin:encOG: "_doIt" on: 1 isValueObj: false 
 -- origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$46 1
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:3:on:2:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- $ObjectInvocation_Unary:loadArgs: "inx" >staticOff:0 "inx: var integer" superAdj:0 
 -- $var:loadArgs: "inx: var integer" >E:"inx" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "inx" 
 -- {(ObjectInvocation_Unary; (name: "inx"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: "inx" >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:"inx" unique:"False" 
 -- OI:invoke: "inx" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx" E: "inx"  rec: "inx"  useRtnV: true "inx: var integer" 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: "inx: var integer" E: "inx">newOff:3 useRTNv: "True" 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- isCompositeValueObj: false E: "inx" "inx: var integer" true 
 -- E.ATd.isValueObj: false rec: "inx" 
 pushg 3 for:to:repeat$28
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:C: inx :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- rec: "inx" dstE: "inx" dstE.ATd: "inx: var integer" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "inx" 
 -- isArgOfAssignI2IwithUniValArg "inx := inx" arg: "inx" ObjectGenerator 
 -- arg.super.arg: "inx" ObjectInvocation_Unary 
 -- dstDI: "inx: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg for:to:repeat$28 3
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 24 
 -- Items:GenClass: repeat$24 descNo: 24 isValue: false 
 -- Items:GenClass: repeat$24 descNo: 21 isValue: false 

 CLASS repeat$24 24 1 for:to:repeat$30 30
 -- Store itemArgs: c1 := get[inx]{c2 := Veq.get[inx];if (c1 <> c2) :then ;   Beq := false;   leave(loop)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=24 vDescInx=24 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "c1 := get[inx]" 
 -- $Assign:gen: "c1 := get[inx]"  
 -- assign: "c1 := get[inx]" 
 -- computeAdr:superAdj: 0 "c1" 
 -- computeAdr: 1 :rec: "none"  E: "c1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "c1"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "c1" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$24" on: 2 isValueObj: false 
 -- origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30" on: 1 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- $ObjectInvocation_Unary:getAdr: "c1" >ATd.off:2:on:2:superAdj:0"c1: var char":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"non ..." 
 -- $var:getAdr: "c1: var char" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- DI:OG: char 
 -- before:floatTest:  "c1: var char" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "c1"  ATd: "c1: var char" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- computeAdr:isLast:E:  "c1" 
 -- AssignmentStatement:gen: "c1 := get[inx]" right.label: "ObjectGenerator" "get[inx]" 
 -- $ObjectGenerator:gen: "get[inx]" >OGid:"get" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "get[inx]" 
 -- OG:before:super.gen: "get[inx]" 
 -- $Invocation:gen: "get[inx]" >useRtnV:"True"superAdj: 0 descNo: 16 
 -- INV:gen: "get[inx]" 
 -- isConstant: "Invocation" "get[inx]" 
 -- needorigin: "get[inx]" 
 -- needOrigin:E: "get[inx]"  E.ATd: "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- doNeedOrigin:Ex: "get[inx]" 
 -- computeAdr:superAdj: 0 "get[inx]" 
 -- computeAdr: 1 :rec: "none"  E: "get[inx]" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "get[inx]"  
 pushThis 
 -- $ObjectInvocation_KeyWord:loadOrigin: "get[inx]" >on:4 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$24" on: 4 isValueObj: false 
 -- origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30" on: 3 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- items:goOrigin:encOG: "loop" on: 2 isValueObj: false 
 -- origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- items:goOrigin:encOG: "=" on: 1 isValueObj: false 
 -- origin: String origin:isValueObj: false 
 rpushg =$13 1
 -- $ObjectInvocation_KeyWord:getAdr: "get[inx]" >ATd.off:0 (isPtn):on:4:superAdj:0"get[inx: var integer]: {   %basic 117;   out ch: var char":Adr:off:0 size:0 isFloat:F isUni ...} 
 -- $pattern:getAdr: "get[inx: var integer]: {   %basic 117;   out ch: var char" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "get[inx]"  ATd: "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- computeAdr:isLast:E:  "get[inx]" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- rec:  "get[inx]" E:  "get[inx]" 
 -- INV:gen:E.loadArgs "get[inx]" 
 -- $ObjectInvocation_KeyWord:loadArgs: "get[inx]" >staticOff:0 "get[inx: var integer]: {   %basic 117;   out ch: var char" superAdj:0arg:"inx"} 
 -- $pattern:loadArgs: "get[inx: var integer]: {   %basic 117;   out ch: var char" >E:"get[inx]":descNo:16} 
 -- ptn:loadArgs:E "get[inx]" 
 -- {(ObjectInvocation_KeyWord; (name: "get"); (Arguments;  (name: "get");  (name: "[");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "inx");     ( ...} 
 -- args: "get[inx]" 
 -- E: "ObjectGenerator" inx 
 -- E.arg: "var" inx: var integer 
 -- NonVirt: "get[inx]" "ObjectInvocation_KeyWord" ActArg:  "inx" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx]"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "inx" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inx" 
 -- OG:before:super.gen: "inx" 
 -- $Invocation:gen: "inx" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "inx" 
 -- isConstant: "Invocation" "inx" 
 -- notConst: inx inx: var integer 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$24" on: 1 isValueObj: false 
 -- origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:3:on:1:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- $ObjectInvocation_Unary:loadArgs: "inx" >staticOff:0 "inx: var integer" superAdj:0 
 -- $var:loadArgs: "inx: var integer" >E:"inx" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "inx" 
 -- {(ObjectInvocation_Unary; (name: "inx"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: "inx" >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:"inx" unique:"False" 
 -- OI:invoke: "inx" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx" E: "inx"  rec: "inx"  useRtnV: true "inx: var integer" 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: "inx: var integer" E: "inx">newOff:3 useRTNv: "True" 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- isCompositeValueObj: false E: "inx" "inx: var integer" true 
 -- E.ATd.isValueObj: false rec: "inx" 
 pushg 3 for:to:repeat$30$30
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:C: inx :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- formalArg:isPtn: "inx: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "inx" :isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "get[inx]" 
 -- INV:gen:after:E.loadArgs "get[inx]" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx]" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec ... 
 -- $ObjectInvocation_KeyWord:invoke: "get[inx]" >rec:"get[inx]" ATd:"pattern" E:"get[inx]" E.ATd:"get[inx: var integer]" unique:"False" 
 -- OI:invoke: "get[inx]" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- OI:invoke:B: "get[inx]" E: "get[inx]"  rec: "get[inx]"  useRtnV: true "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- $pattern:invoke: "get[inx: var integer]: {   %basic 117;   out ch: var char" E: "get[inx]" useRTNv: "True"} 
 -- ptn:invoke: "get[inx: var integer]" E: "get[inx]" ptnKind: 0 useRtnV: true 
 xpushg  inx 1 0 1
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpop : vTop: 0 vTopMax: 1 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- 
 -- OI:invoke:C: get[inx] :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- rec: "c1" dstE: "c1" dstE.ATd: "c1: var char" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right: "get[inx]" 
 -- isArgOfAssignI2IwithUniValArg "c1 := get[inx]" arg: "get[inx]" ObjectGenerator 
 -- arg.super.arg: "get[inx]" ObjectInvocation_KeyWord 
 -- dstDI: "c1: var char" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg loop$14 2
 -- assign:adr.store:B: 
 -- genclass:stmt: "c2 := Veq.get[inx]" 
 -- $Assign:gen: "c2 := Veq.get[inx]"  
 -- assign: "c2 := Veq.get[inx]" 
 -- computeAdr:superAdj: 0 "c2" 
 -- computeAdr: 1 :rec: "none"  E: "c2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "c2"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "c2" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$24" on: 2 isValueObj: false 
 -- origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30" on: 1 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- $ObjectInvocation_Unary:getAdr: "c2" >ATd.off:3:on:2:superAdj:0"c2: var char":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"non ..." 
 -- $var:getAdr: "c2: var char" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- DI:OG: char 
 -- before:floatTest:  "c2: var char" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "c2"  ATd: "c2: var char" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- computeAdr:isLast:E:  "c2" 
 -- AssignmentStatement:gen: "c2 := Veq.get[inx]" right.label: "ObjectGenerator" "Veq.get[inx]" 
 -- $ObjectGenerator:gen: "Veq.get[inx]" >OGid:"get" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "Veq.get[inx]" 
 -- OG:before:super.gen: "Veq.get[inx]" 
 -- $Invocation:gen: "Veq.get[inx]" >useRtnV:"True"superAdj: 0 descNo: 16 
 -- INV:gen: "Veq.get[inx]" 
 -- isConstant: "Invocation" "Veq.get[inx]" 
 -- notConst: Veq in Veq: var this(Value) 
 -- needorigin: "Veq.get[inx]" 
 -- needOrigin:E: "get[inx]"  E.ATd: "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- doNeedOrigin:Ex: "get[inx]" 
 -- computeAdr:superAdj: 0 "Veq.get[inx]" 
 -- computeAdr: 1 :rec: "none"  E: "Veq" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Veq"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Veq" >on:3 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$24" on: 3 isValueObj: false 
 -- origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30" on: 2 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- $ObjectInvocation_Unary:getAdr: "Veq" >ATd.off:2:on:3:superAdj:0"in Veq: var this(Value)":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVa ... 
 -- PING:String 0 c1 := get[inx]{   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop)} 
 -- BOBS:ATd: "in Veq: var this(Value)" 
 -- String:vEq:  "Veq" off:  2 ATd: "in Veq: var this(Value)" 
 -- E.on: 3 
 -- beforeIsValueObj:E: "Veq"  ATd: "in Veq: var this(Value)" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "Veq"  E: "get[inx]" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:getAdr: "get[inx]" >ATd.off:0 (isPtn):on:0:superAdj:0"get[inx: var integer]: {   %basic 117;   out ch: var char":Adr:off:2 size:0 isFloat:F isUni ...} 
 -- $pattern:getAdr: "get[inx: var integer]: {   %basic 117;   out ch: var char" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "Veq" >staticOff:0 "in Veq: var this(Value)" superAdj:0 
 -- $var:loadArgs: "in Veq: var this(Value)" >E:"Veq" 
 -- $pattern:loadArgs: "this: {   %basic 18;   in this: ref Object" >E:"Veq":descNo:31} 
 -- $ObjectInvocation_Unary:invoke: "Veq" >rec:"Veq" ATd:"var" isValueObj E:"get[inx]" E.ATd:"get[inx: var integer]" unique:"False" 
 -- OI:invoke: "Veq" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- OI:invoke:B: "Veq" E: "get[inx]"  rec: "Veq"  useRtnV: true "in Veq: var this(Value)" 
 -- OI:invoke:before:ATdx.invoke: var Veq 
 -- $var:invoke: "in Veq: var this(Value)" E: "get[inx]">newOff:2 useRTNv: "True" 
 -- DI:invoke: "in Veq: var this(Value)" 
 -- isValueObj:isAdr: true objSize: 2  rec "Veq" ,E: "get[inx]" "ObjectInvocation_KeyWord" E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 rpushg repeat$24$24 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- 
 -- OI:invoke:C: Veq :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "Veq" E: "get[inx]" 
 -- arg:other 
 -- computeAdr:isLast:E:  "get[inx]" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- rec:  "Veq" E:  "get[inx]" 
 -- INV:gen:E.loadArgs "get[inx]" 
 -- $ObjectInvocation_KeyWord:loadArgs: "get[inx]" >staticOff:0 "get[inx: var integer]: {   %basic 117;   out ch: var char" superAdj:0arg:"inx"} 
 -- $pattern:loadArgs: "get[inx: var integer]: {   %basic 117;   out ch: var char" >E:"get[inx]":descNo:16} 
 -- ptn:loadArgs:E "get[inx]" 
 -- {(ObjectInvocation_KeyWord; (name: "get"); (Arguments;  (name: "get");  (name: "[");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "inx");     ( ...} 
 -- args: "get[inx]" 
 -- E: "ObjectGenerator" inx 
 -- E.arg: "var" inx: var integer 
 -- NonVirt: "get[inx]" "ObjectInvocation_KeyWord" ActArg:  "inx" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx]"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "inx" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inx" 
 -- OG:before:super.gen: "inx" 
 -- $Invocation:gen: "inx" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "inx" 
 -- isConstant: "Invocation" "inx" 
 -- notConst: inx inx: var integer 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$24" on: 1 isValueObj: false 
 -- origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:3:on:1:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- $ObjectInvocation_Unary:loadArgs: "inx" >staticOff:0 "inx: var integer" superAdj:0 
 -- $var:loadArgs: "inx: var integer" >E:"inx" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "inx" 
 -- {(ObjectInvocation_Unary; (name: "inx"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: "inx" >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:"inx" unique:"False" 
 -- OI:invoke: "inx" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx" E: "inx"  rec: "inx"  useRtnV: true "inx: var integer" 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: "inx: var integer" E: "inx">newOff:3 useRTNv: "True" 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- isCompositeValueObj: false E: "inx" "inx: var integer" true 
 -- E.ATd.isValueObj: false rec: "inx" 
 pushg 3 for:to:repeat$30$30
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -3 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:C: inx :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- formalArg:isPtn: "inx: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "inx" :isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "get[inx]" 
 -- INV:gen:after:E.loadArgs "get[inx]" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx]" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec ... 
 -- $ObjectInvocation_KeyWord:invoke: "get[inx]" >rec:"Veq" ATd:"pattern" E:"get[inx]" E.ATd:"get[inx: var integer]" unique:"False" 
 -- OI:invoke: "get[inx]" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- OI:invoke:B: "get[inx]" E: "get[inx]"  rec: "Veq"  useRtnV: true "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- $pattern:invoke: "get[inx: var integer]: {   %basic 117;   out ch: var char" E: "get[inx]" useRTNv: "True"} 
 -- ptn:invoke: "get[inx: var integer]" E: "get[inx]" ptnKind: 0 useRtnV: true 
 xpushg  inx 1 0 1
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -4 rTopMax: 0 V: 0 R: 
 -- stack: vpop : vTop: 1 vTopMax: 2 rTop: -4 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- 
 -- OI:invoke:C: get[inx] :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- rec: "c2" dstE: "c2" dstE.ATd: "c2: var char" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right: "Veq.get[inx]" 
 -- isArgOfAssignI2IwithUniValArg "c2 := Veq.get[inx]" arg: "Veq.get[inx]" ObjectGenerator 
 -- arg.super.arg: "Veq" ObjectInvocation_Unary 
 -- arg.super.arg: "get[inx]" ObjectInvocation_KeyWord 
 -- recx: "Veq" argx: "get[inx]" 
 -- checkInt2IntWithUnitArg:rec: "Veq" E: "get[inx]" 
 -- arg:other 
 -- dstDI: "c2: var char" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg loop$14 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- $ObjectGenerator:gen: "if (c1 <> c2) :then {   Beq := false;   leave(loop)" >OGid:"if:then$0" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- OG:before:super.gen: "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- $Invocation:gen: "if (c1 <> c2) :then {   Beq := false;   leave(loop)" >useRtnV:"False"superAdj: 0} 
 -- INV:gen: "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- isConstant: "Invocation" "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- needorigin: "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- needOrigin:E: "if (c1 <> c2) :then {   Beq := false;   leave(loop)}"  E.ATd: "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100; ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" E:  "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- INV:gen:E.loadArgs "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- $IfThen:loadArgs: "if (c1 <> c2) :then {   Beq := false;   leave(loop)" } 
 -- INV:gen:after:E.loadArgs "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- $IfThen:invoke: "if (c1 <> c2) :then {   Beq := false;   leave(loop)" } 
 -- $IfThen:gen: "if (c1 <> c2) :then {   Beq := false;   leave(loop)" } 
 -- $ObjectGenerator:gen: "(c1 <> c2)" >OGid:"<>" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(c1 <> c2)" 
 -- OG:before:super.gen: "(c1 <> c2)" 
 -- $Invocation:gen: "(c1 <> c2)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(c1 <> c2)" 
 -- isConstant: "Invocation" "(c1 <> c2)" 
 -- needorigin: "(c1 <> c2)" 
 -- needOrigin:E: "(c1 <> c2)"  E.ATd: "<>  : {   %basic 55;   in V: var char;   out B: var boolean}" 
 -- doNeedOrigin:Ex: "(c1 <> c2)" 
 -- computeAdr:superAdj: 0 "(c1 <> c2)" 
 -- computeAdr: 1 :rec: "none"  E: "(c1 <> c2)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(c1 <> c2)"  
 -- $BracketedExp:loadOrigin: "(c1 <> c2)"  
 -- computeAdr:superAdj: 0 "c1 <> c2" 
 -- computeAdr: 1 :rec: "none"  E: "c1 <> c2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "c1 <> c2"  
 -- $BinOp:loadOrigin: "c1 <> c2"  
 -- BinaryExp:loadOrigin:empty: "c1 <> c2" superAdj: 0 
 -- $BinOp:getAdr: "c1 <> c2"  
 -- E.on: 2 
 -- beforeIsValueObj:E: "c1 <> c2"  ATd: "<>  : {   %basic 55;   in V: var char;   out B: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "c1 <> c2" 
 -- BE:loadOrigin:E: c1 <> c2 
 -- $BinOp:getAdr: "c1 <> c2"  
 -- E.on: 2 
 -- beforeIsValueObj:E: "c1 <> c2"  ATd: "<>  : {   %basic 55;   in V: var char;   out B: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "c1 <> c2" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "c1 <> c2" E:  "c1 <> c2" 
 -- INV:gen:E.loadArgs "c1 <> c2" 
 -- $BinOp:loadArgs: "c1 <> c2"  
 -- BinaryExp:loadArgs: "c1 <> c2" superAdj: 0 
 -- $Invocation:gen: "c1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "c1" 
 -- isConstant: "Invocation" "c1" 
 -- notConst: c1 c1: var char 
 -- needorigin: "c1" 
 -- needOrigin:E: "c1"  E.ATd: "c1: var char" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "c1" 
 -- computeAdr: 1 :rec: "none"  E: "c1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "c1"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "c1" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$24" on: 2 isValueObj: false 
 -- origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30" on: 1 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- $ObjectInvocation_Unary:getAdr: "c1" >ATd.off:2:on:2:superAdj:0"c1: var char":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"non ..." 
 -- $var:getAdr: "c1: var char" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- DI:OG: char 
 -- before:floatTest:  "c1: var char" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "c1"  ATd: "c1: var char" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- computeAdr:isLast:E:  "c1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- rec:  "c1" E:  "c1" 
 -- INV:gen:E.loadArgs "c1" 
 -- $ObjectInvocation_Unary:loadArgs: "c1" >staticOff:0 "c1: var char" superAdj:0 
 -- $var:loadArgs: "c1: var char" >E:"c1" 
 -- $pattern:loadArgs: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;       ..."} 
 -- ptn:loadArgs:E "c1" 
 -- {(ObjectInvocation_Unary; (name: "c1"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "c1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c1" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- $ObjectInvocation_Unary:invoke: "c1" >rec:"c1" ATd:"var" isValueObj E:"c1" E.ATd:"c1" unique:"False" 
 -- OI:invoke: "c1" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:B: "c1" E: "c1"  rec: "c1"  useRtnV: true "c1: var char" 
 -- OI:invoke:before:ATdx.invoke: var c1 
 -- $var:invoke: "c1: var char" E: "c1">newOff:2 useRTNv: "True" 
 -- DI:invoke: "c1: var char" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- isCompositeValueObj: false E: "c1" "c1: var char" true 
 -- E.ATd.isValueObj: false rec: "c1" 
 pushg 2 loop$14
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -5 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 3 vTopMax: 3 rTop: -5 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- 
 -- OI:invoke:C: c1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- $pattern:loadArgs: "<>  : {   %basic 55;   in V: var char;   out B: var boolean" >E:"<> c2":descNo:25} 
 -- ptn:loadArgs:E "<> c2" 
 -- {(ObjectInvocation_Binary; (name: "<>"); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "c2");     (Arguments)));   (Items descNo: 0  ...} 
 -- args: "c2" 
 -- E: "ObjectGenerator" c2 
 -- E.arg: "var" in V: var char 
 -- NonVirt: "<> c2" "ObjectInvocation_Binary" ActArg:  "c2" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "<> c2"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "c2" >OGid:"char" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "c2" 
 -- OG:before:super.gen: "c2" 
 -- $Invocation:gen: "c2" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "c2" 
 -- isConstant: "Invocation" "c2" 
 -- notConst: c2 c2: var char 
 -- needorigin: "c2" 
 -- needOrigin:E: "c2"  E.ATd: "c2: var char" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "c2" 
 -- computeAdr: 1 :rec: "none"  E: "c2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "c2"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "c2" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$24" on: 2 isValueObj: false 
 -- origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30" on: 1 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- $ObjectInvocation_Unary:getAdr: "c2" >ATd.off:3:on:2:superAdj:0"c2: var char":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"non ..." 
 -- $var:getAdr: "c2: var char" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- DI:OG: char 
 -- before:floatTest:  "c2: var char" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "c2"  ATd: "c2: var char" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- computeAdr:isLast:E:  "c2" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- rec:  "c2" E:  "c2" 
 -- INV:gen:E.loadArgs "c2" 
 -- $ObjectInvocation_Unary:loadArgs: "c2" >staticOff:0 "c2: var char" superAdj:0 
 -- $var:loadArgs: "c2: var char" >E:"c2" 
 -- $pattern:loadArgs: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;       ..."} 
 -- ptn:loadArgs:E "c2" 
 -- {(ObjectInvocation_Unary; (name: "c2"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "c2" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- $ObjectInvocation_Unary:invoke: "c2" >rec:"c2" ATd:"var" isValueObj E:"c2" E.ATd:"c2" unique:"False" 
 -- OI:invoke: "c2" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- OI:invoke:B: "c2" E: "c2"  rec: "c2"  useRtnV: true "c2: var char" 
 -- OI:invoke:before:ATdx.invoke: var c2 
 -- $var:invoke: "c2: var char" E: "c2">newOff:3 useRTNv: "True" 
 -- DI:invoke: "c2: var char" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- isCompositeValueObj: false E: "c2" "c2: var char" true 
 -- E.ATd.isValueObj: false rec: "c2" 
 pushg 3 loop$14
 -- stack: rpop : vTop: 3 vTopMax: 3 rTop: -6 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 4 vTopMax: 4 rTop: -6 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- 
 -- OI:invoke:C: c2 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- formalArg:isPtn: "in V: var char" :isBasicVal: true :valueObj: true 
 -- :actArg: "c2" :isBasicVal: true 
 -- case:B: c2 ObjectGenerator 3 0 3 false false 
 -- end:loadArgs:NonVirt: "<> c2" 
 -- BinaryExp:loadArgs:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:after:E.loadArgs "c1 <> c2" 
 -- OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "c1 <> c2" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- $BinOp:invoke: "c1 <> c2"  
 -- BinaryExp:invoke: "c1" rec: "c1 <> c2" 
 -- M: "<> c2" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- $ObjectInvocation_Binary:invoke: "<> c2" >rec:"c1" ATd:"pattern" E:"<> c2" E.ATd:"<>  " unique:"False" 
 -- OI:invoke: "<> c2" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- origin:isValueObj "char" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:B: "<> c2" E: "<> c2"  rec: "c1"  useRtnV: true "<>  : {   %basic 55;   in V: var char;   out B: var boolean}" 
 -- OI:invoke:before:ATdx.invoke: pattern <>   
 -- $pattern:invoke: "<>  : {   %basic 55;   in V: var char;   out B: var boolean" E: "<> c2" useRTNv: "True"} 
 -- ptn:invoke: "<>  " E: "<> c2" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "c1" E: "<> c2" 
 -- arg:other 
 ne
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<> c2":rec:c1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<> c2":rec:c1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: <> c2 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: "Beq := false{   leave(loop)" >OGid:"$26" singular! staticOff=0 descNo=26 superAdj=0} 
 -- OG:gen: "Beq := false{   leave(loop)}" 
 pushThis 
 -- before objTmpStack:add:  26   "$26" 
 invoke $26 26 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 4 vTopMax: 4 rTop: -7 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 26 
 -- Items:GenClass: $26 descNo: 26 isValue: false 
 -- Items:GenClass: $26 descNo: 21 isValue: false 

 CLASS $26 26 1 repeat$24 24
 -- Store itemArgs: Beq := false{leave(loop)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=26 vDescInx=26 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "Beq := false" 
 -- $Assign:gen: "Beq := false"  
 -- assign: "Beq := false" 
 -- computeAdr:superAdj: 0 "Beq" 
 -- computeAdr: 1 :rec: "none"  E: "Beq" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Beq"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Beq" >on:4 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$26" on: 4 isValueObj: false 
 -- origin: repeat$24 origin:isValueObj: false 
 rpushg $26$26 1
 -- items:goOrigin:encOG: "repeat$24" on: 3 isValueObj: false 
 -- origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30" on: 2 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- $ObjectInvocation_Unary:getAdr: "Beq" >ATd.off:3:on:4:superAdj:0"out Beq: var boolean":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ... 
 -- $var:getAdr: "out Beq: var boolean" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: boolean 
 -- before:floatTest:  "out Beq: var boolean" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "Beq"  ATd: "out Beq: var boolean" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- computeAdr:isLast:E:  "Beq" 
 -- AssignmentStatement:gen: "Beq := false" right.label: "ObjectGenerator" "false" 
 -- $ObjectGenerator:gen: "false" >OGid:"False" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "false" 
 -- OG:before:super.gen: "false" 
 -- $Invocation:gen: "false" >useRtnV:"True"superAdj: 0 descNo: 27 
 -- INV:gen: "false" 
 -- isConstant: "Invocation" "false" 
 -- needorigin: "false" 
 -- needOrigin:E: "false"  E.ATd: "False: {   %globals;   out B: var boolean;   B := 0}" 
 -- Ex:loadOrign:no:loadOrigin:  "%globals{   out B: var boolean;   B := 0}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "false" E:  "false" 
 -- INV:gen:E.loadArgs "false" 
 -- $ObjectInvocation_Unary:loadArgs: "false" >staticOff:0 "False: {   %globals;   out B: var boolean;   B := 0" superAdj:0} 
 -- $pattern:loadArgs: "False: {   %globals;   out B: var boolean;   B := 0" >E:"false":descNo:27} 
 -- ptn:loadArgs:E "false" 
 -- {(ObjectInvocation_Unary; (name: "false"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "false" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "false" 
 -- $ObjectInvocation_Unary:invoke: "false" >rec:"false" ATd:"pattern" E:"false" E.ATd:"False" unique:"False" 
 -- OI:invoke: "false" 
 -- 
 -- OI:invoke:B: "false" E: "false"  rec: "false"  useRtnV: true "False: {   %globals;   out B: var boolean;   B := 0}" 
 -- OI:invoke:before:ATdx.invoke: pattern False 
 -- $pattern:invoke: "False: {   %globals;   out B: var boolean;   B := 0" E: "false" useRTNv: "True"} 
 -- ptn:invoke: "False" E: "false" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke False 27 0 0
 -- global:pushOut: B off: 1 
 pushg 1 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 1 
 -- GeneralPTN:invoke:after:callInvoke: 1 
 -- OI:invoke:V: adrx: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: false :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "Beq" dstE: "Beq" dstE.ATd: "out Beq: var boolean" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- ... 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right: "false" 
 -- isArgOfAssignI2IwithUniValArg "Beq := false" arg: "false" ObjectGenerator 
 -- arg.super.arg: "false" ObjectInvocation_Unary 
 -- dstDI: "out Beq: var boolean" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg =$13 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "leave(loop)" 
 -- $ObjectGenerator:gen: "leave(loop)" >OGid:"leave" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "leave(loop)" 
 -- OG:before:super.gen: "leave(loop)" 
 -- $Invocation:gen: "leave(loop)" >useRtnV:"False"superAdj: 0 descNo: 19 
 -- INV:gen: "leave(loop)" 
 -- isConstant: "Invocation" "leave(loop)" 
 -- needorigin: "leave(loop)" 
 -- needOrigin:E: "leave(loop)"  E.ATd: "leave(V: var integer): {   %basic 103}" 
 -- doNeedOrigin:Ex: "leave(loop)" 
 -- computeAdr:superAdj: 0 "leave(loop)" 
 -- computeAdr: 1 :rec: "none"  E: "leave(loop)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "leave(loop)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "leave(loop)" >on:7 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "leave(loop)" >ATd.off:0 (isPtn):on:7:superAdj:0"leave(V: var integer): {   %basic 103":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 ...} 
 -- $pattern:getAdr: "leave(V: var integer): {   %basic 103" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:- 
 -- E.on: 7 
 -- beforeIsValueObj:E: "leave(loop)"  ATd: "leave(V: var integer): {   %basic 103}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:- 
 -- computeAdr:isLast:E:  "leave(loop)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:- 
 -- rec:  "leave(loop)" E:  "leave(loop)" 
 -- INV:gen:E.loadArgs "leave(loop)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "leave(loop)" >staticOff:0 "leave(V: var integer): {   %basic 103" superAdj:0arg:"loop"} 
 -- $pattern:loadArgs: "leave(V: var integer): {   %basic 103" >E:"leave(loop)":descNo:19} 
 -- INV:gen:after:E.loadArgs "leave(loop)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "leave(loop)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loo ..." 
 -- $ObjectInvocation_KeyWord:invoke: "leave(loop)" >rec:"leave(loop)" ATd:"pattern" E:"leave(loop)" E.ATd:"leave(V: var integer)" unique:"False" 
 -- OI:invoke: "leave(loop)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- OI:invoke:B: "leave(loop)" E: "leave(loop)"  rec: "leave(loop)"  useRtnV: false "leave(V: var integer): {   %basic 103}" 
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- $pattern:invoke: "leave(V: var integer): {   %basic 103" E: "leave(loop)" useRTNv: "False"} 
 -- ptn:invoke: "leave(V: var integer)" E: "leave(loop)" ptnKind: 0 useRtnV: false 
 break  3 2 14 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- 
 -- OI:invoke:C: leave(loop) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 27 
 -- Items:GenClass: False descNo: 27 isValue: false 
 -- Items:GenClass: False descNo: 21 isValue: false 

 CLASS False 27 0 BETA 2
 -- Store itemArgs: %globals{out B: var boolean;B := 0} 
 allocEventQ
 -- vdtAdd: inx=1 descInx=27 vDescInx=27 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%globals"  
 -- $var:gen: "out B: var boolean"  
 -- DI:gen: "out B: var boolean" DI:isConst: false :isBasicValue: true :primNo: 4 
 -- DI:add:BP1:  B 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%globals" 
 -- $Property:gen: "%globals"  
 -- genclass:stmt: "B := 0" 
 -- $Assign:gen: "B := 0"  
 -- assign: "B := 0" 
 -- computeAdr:superAdj: 0 "B" 
 -- computeAdr: 1 :rec: "none"  E: "B" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "B"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "B" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "B" >ATd.off:1:on:0:superAdj:0"out B: var boolean":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "out B: var boolean" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F o ... 
 -- DI:OG: boolean 
 -- before:floatTest:  "out B: var boolean" ObjectGenerator 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- After:U*U: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- computeAdr:isLast:E:  "B" 
 -- AssignmentStatement:gen: "B := 0" right.label: "ObjectGenerator" "0" 
 -- $ObjectGenerator:gen: "0" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "0" 
 -- OG:before:super.gen: "0" 
 -- $Invocation:gen: "0" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "0" 
 -- isConstant: "Invocation" "0" 
 -- needorigin: "0" 
 -- needOrigin:E: "0"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "0" E:  "0" 
 -- INV:gen:E.loadArgs "0" 
 -- $ConstLiteral:loadArgs: "0"  
 -- INV:gen:after:E.loadArgs "0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0" 
 -- $ConstLiteral:invoke: "0"  
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "B" dstE: "B" dstE.ATd: "out B: var boolean" useRtn: false :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "0" 
 -- isArgOfAssignI2IwithUniValArg "B := 0" arg: "0" ObjectGenerator 
 -- arg.super.arg: "0" ConstLiteral 
 -- dstDI: "out B: var boolean" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg False$27 1
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  "False" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 30 
 -- Items:GenClass: for:to:repeat$30 descNo: 30 isValue: false 
 -- Items:GenClass: for:to:repeat$30 descNo: 28 isValue: false 
 -- Items:GenClass: for:to:repeat descNo: 21 isValue: false 

 CLASS for:to:repeat$30 30 4 loop 14
 -- vdtTableCopy: I:1:28 V:2:29
 -- Store itemArgs:  
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- push:super.origin: 
 -- handleSuperArgs:E: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" theIS: "" 
 -- super.sig:none:superAdj: 4 
 -- $ObjectInvocation_KeyWord:loadArgs: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);" >stati ...} 
 -- $pattern:loadArgs: "for(first: var integer):to(last: var integer):repeat{repeat:< object}: {   %OSDvisibility skipInternal;   %globals inSub;   inx: var integer;   inx :=  ..."} 
 -- ptn:loadArgs:E "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- {(ObjectInvocation_KeyWord; (name: "for:to:repeat"); (Arguments;  (name: "for");  (name: "(");  (ObjectGenerator;   (Invocation;    (ConstLiteral 1));   (Items descNo: 0 o ...} 
 -- args: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- E: "ObjectGenerator" 1 
 -- E: "ObjectGenerator" length 
 -- E: "ObjectGenerator" c1 := get[inx]{   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop)} 
 -- E.arg: "var" first: var integer 
 -- NonVirt: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" "ObjectInvocation_KeyWord" ActAr ... "1 ..." i ... true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}"  isComposit ... false 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=4 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 4 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 4 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "first: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "1" :isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- E.arg: "var" last: var integer 
 -- NonVirt: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" "ObjectInvocation_KeyWord" ActAr ... "l ..." i ... false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}"  isComposit ... false 
 -- $ObjectGenerator:gen: "length" >OGid:"length" IS.isempty! staticOff=0 descNo=0 superAdj=4 
 -- OG:gen: "length" 
 -- OG:before:super.gen: "length" 
 -- $Invocation:gen: "length" >useRtnV:"True"superAdj: 4 descNo: 15 
 -- INV:gen: "length" 
 -- isConstant: "Invocation" "length" 
 -- needorigin: "length" 
 -- needOrigin:E: "length"  E.ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- doNeedOrigin:Ex: "length" 
 -- computeAdr:superAdj: 4 "length" 
 -- computeAdr: 1 :rec: "none"  E: "length" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "length"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "length" >on:2 superAdj:4 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 4 
 rpushg loop$14 4
 -- items:goOrigin:encOG: "loop" on: 2 isValueObj: false 
 -- origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- items:goOrigin:encOG: "=" on: 1 isValueObj: false 
 -- origin: String origin:isValueObj: false 
 rpushg =$13 1
 -- $ObjectInvocation_Unary:getAdr: "length" >ATd.off:0 (isPtn):on:2:superAdj:4"length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length":Adr ...} 
 -- $pattern:getAdr: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "length"  ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- computeAdr:isLast:E:  "length" 
 -- IV:after:computeAdr:superAdj: 4 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- rec:  "length" E:  "length" 
 -- INV:gen:E.loadArgs "length" 
 -- $ObjectInvocation_Unary:loadArgs: "length" >staticOff:0 "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" superAdj:4} 
 -- $pattern:loadArgs: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" >E:"length":descNo:15} 
 -- ptn:loadArgs:E "length" 
 -- {(ObjectInvocation_Unary; (name: "length"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "length" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- $ObjectInvocation_Unary:invoke: "length" >rec:"length" ATd:"pattern" E:"length" E.ATd:"length" unique:"False" 
 -- OI:invoke: "length" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:B: "length" E: "length"  rec: "length"  useRtnV: true "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- $pattern:invoke: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" E: "length" useRTNv: "True"} 
 -- ptn:invoke: "length" E: "length" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:C: length :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- formalArg:isPtn: "last: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "length" :isBasicVal: true 
 -- case:B: length ObjectGenerator 1 0 0 false false 
 -- end:loadArgs:NonVirt: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- args:  "repeat:< object" "c1 := get[inx]{   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop)}" for:to:repeat 
 -- hArgOrg:super: for:to:repeat 
 -- Store itemArgs:  
 -- last: var integer true 1 
 -- DI:store: "last" 
 pushThis 
 storeg integer$5 2
 -- first: var integer true 1 
 -- DI:store: "first" 
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- vdtAdd: inx=1 descInx=30 vDescInx=28 vdtTop: 2 
 -- $Property:gen: "%OSDvisibility skipInternal"  
 -- $Property:gen: "%globals inSub"  
 -- $var:gen: "inx: var integer"  
 -- DI:gen: "inx: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  inx 
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0
 -- Handle VB: "" E: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- vdtAdd: inx=2 descInx=30 vDescInx=24 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 52 
 -- Items:GenClass: <= descNo: 52 isValue: false 
 -- Items:GenClass: <= descNo: 47 isValue: false 
 -- Items:GenClass: <= descNo: 21 isValue: false 
 -- got:sub:vEq:  52  isValueObj:  false 5 
 -- OG:reAlloc: descNo: 0 21 "%basic 52{   in Veq: var this(Value);   out Beq: var boolean}" 
 -- OG:reAlloc: descNo: 0 0 "%ID Object{   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic 57;      i ...}" 
 -- Pattern:Qalloc: == 
 -- Pattern:Qalloc: =/= 
 -- Pattern:Qalloc: suspend 
 -- Pattern:Qalloc: attach 
 -- Pattern:Qalloc: call 
 -- Pattern:Qalloc: resume 
 -- Pattern:Qalloc: onResume 
 -- Pattern:Qalloc: onSuspend 
 -- Pattern:Qalloc: dumpObj 
 -- Pattern:Qalloc: X_asString 
 -- Pattern:Qalloc:B: X_asString 
 -- dataitem:qalloc: "Veq" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: false 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- dataitem:qalloc: "Beq" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 

 CLASS <= 47 1 Value 4
 -- Store itemArgs: %basic 52{in Veq: var this(Value);out Beq: var boolean} 
 -- in Veq: var this(Value) true 18 
 -- DI:store: "Veq" 
 jmpFalse  L3
 pushThis 
 -- vassign:B: Veq off: 4 size: 2 mode: 0 
 vassign  4 2 0
 jmp L4
 L3:
 invokeVal  Veq 31 3
 L4:
 -- Store:Origin: 21 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 allocEventQ
 -- vdtAdd: inx=1 descInx=47 vDescInx=47 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%basic 52"  
 -- $var:gen: "in Veq: var this(Value)"  
 -- DI:gen: "in Veq: var this(Value)" DI:isConst: false :isBasicValue: false :primNo: 18 
 -- DI:add:BP4:  Veq 
 -- inArg: in Veq: var this(Value) 
 -- $var:gen: "out Beq: var boolean"  
 -- DI:gen: "out Beq: var boolean" DI:isConst: false :isBasicValue: true :primNo: 4 
 -- DI:add:BP1:  Beq 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%basic 52" 
 -- $Property:gen: "%basic 52"  
 L2:
 -- pushReturn:  "<=" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0
 -- got:sub:vEq:  52  isValueObj:  false 6 
 -- OG:reAlloc: descNo: 0 5 "loop: obj {      -- "Hello"  <= "World" since H <= W;      -- "Qweabc" <= "Qwevwxy" since a <= e;      -- "Qweayc" <= "Qwexby";      -- "Qwe"    < ...}" 
 -- OG:reAlloc:String: 
 -- currentDcl:this: 
 -- reAllocatedOff: "Veq" 2 
 -- dataitem:qalloc: "Beq" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- reAllocatedOff: "Beq" 3 
 -- dataitem:qalloc: "loop" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 4 "loop: obj {   -- "Hello"  <= "World" since H <= W;   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"    <= "Qwerty";   -- "Q ..."}" 
 -- OG:Qalloc: "-- "Hello"  <= "World" since H <= W{   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"    <= "Qwerty";   -- "Qwerty" <= "Qwe" - fa ...}" q ... 53 
 -- reAllocatedOff: "loop" 4 

 CLASS <= 52 1 String 10
 -- vdtTableCopy: I:1:47
 -- Store itemArgs: loop: obj {   -- "Hello"  <= "World" since H <= W;   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"    <= "Qwerty";   -- "Qwe ..."} 
 -- Store:Origin: 5 
 rShiftUp  1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- super <=
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 -- handleSuperArgs:E: "" theIS: "loop: obj {   -- "Hello"  <= "World" since H <= W;   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"    <= "Qwer ..."}" 
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs: ""  
 rShiftDown  1
 -- hArgOrg:super: <= 
 -- Store itemArgs: loop: obj {   -- "Hello"  <= "World" since H <= W;   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"    <= "Qwerty";   -- "Qwe ..."} 
 -- in Veq: var this(Value) true 18 
 pushThis 
 rstoreg  Veq 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- Store:Origin: 5 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=52 vDescInx=47 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%basic 52"  
 -- $var:gen: "in Veq: var this(Value)"  
 -- DI:gen: "in Veq: var this(Value)" DI:isConst: false :isBasicValue: false :primNo: 18 
 -- DI:add:BP4:  Veq 
 -- inArg: in Veq: var this(Value) 
 -- $var:gen: "out Beq: var boolean"  
 -- DI:gen: "out Beq: var boolean" DI:isConst: false :isBasicValue: true :primNo: 4 
 -- DI:add:BP1:  Beq 
 -- $obj:gen: "loop: obj {   -- "Hello"  <= "World" since H <= W;   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"    <= "Qwerty";   -- "Qwerty"  ..."} 
 -- DI:gen: "loop: obj {   -- "Hello"  <= "World" since H <= W;   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"    <= "Qwerty";   -- "Qwerty" <= ...}" D ... true : ... false : ... 0 
 -- DI:add:BP4:  loop 
 -- $ObjectGenerator:gen: "-- "Hello"  <= "World" since H <= W{   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"    <= "Qwerty";   -- "Qwerty" <= ..."} 
 -- OG:gen: "-- "Hello"  <= "World" since H <= W{   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"    <= "Qwerty";   -- "Qwerty" <= "Qwe" - false ...}" 
 pushThis 
 -- before objTmpStack:add:  53   "loop" 
 invoke loop 53 4 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 -- pushReturn:  "<=" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 53 
 -- Items:GenClass: loop descNo: 53 isValue: false 
 -- Items:GenClass: loop descNo: 21 isValue: false 

 CLASS loop 53 1 <= 52
 -- Store itemArgs: -- "Hello"  <= "World" since H <= W{-- "Qweabc" <= "Qwevwxy" since a <= e;-- "Qweayc" <= "Qwexby";-- "Qwe"    <= "Qwerty";-- "Qwerty" <= "Qwe" - false;-- " ..."} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=53 vDescInx=53 vdtTop: 1 
 mvStack 
 -- $var:gen: "L: var integer"  
 -- DI:gen: "L: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  L 
 -- $var:gen: "L1: var integer"  
 -- DI:gen: "L1: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  L1 
 -- $var:gen: "L2: var integer"  
 -- DI:gen: "L2: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  L2 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "L1 := length{-- min length of this and V}" 
 -- $Assign:gen: "L1 := length{-- min length of this and V" } 
 -- assign: "L1 := length{-- min length of this and V}" 
 -- computeAdr:superAdj: 0 "L1" 
 -- computeAdr: 1 :rec: "none"  E: "L1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L1"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L1" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L1" >ATd.off:3:on:0:superAdj:0"L1: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- $var:getAdr: "L1: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F orig ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L1: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- computeAdr:isLast:E:  "L1" 
 -- AssignmentStatement:gen: "L1 := length{-- min length of this and V}" right.label: "ObjectGenerator" "length{-- min length of this and V}" 
 -- $ObjectGenerator:gen: "length{-- min length of this and V" >OGid:"length" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "length{-- min length of this and V}" 
 -- OG:before:super.gen: "length{-- min length of this and V}" 
 -- $Invocation:gen: "length{-- min length of this and V" >useRtnV:"True"superAdj: 0 descNo: 15} 
 -- INV:gen: "length{-- min length of this and V}" 
 -- isConstant: "Invocation" "length{-- min length of this and V}" 
 -- needorigin: "length{-- min length of this and V}" 
 -- needOrigin:E: "length{-- min length of this and V}"  E.ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- doNeedOrigin:Ex: "length{-- min length of this and V}" 
 -- computeAdr:superAdj: 0 "length{-- min length of this and V}" 
 -- computeAdr: 1 :rec: "none"  E: "length{-- min length of this and V}" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "length{-- min length of this and V" } 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "length{-- min length of this and V" >on:2 superAdj:0 isValueObj:"False"} 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 2 isValueObj: false 
 -- origin: <= origin:isValueObj: false 
 rpushg loop$53 1
 -- items:goOrigin:encOG: "<=" on: 1 isValueObj: false 
 -- origin: String origin:isValueObj: false 
 rpushg <=$52 1
 -- $ObjectInvocation_Unary:getAdr: "length{-- min length of this and V" >ATd.off:0 (isPtn):on:2:superAdj:0"length: ;   out V: var integer;   V := get[0] -- actually an index  ..."} 
 -- $pattern:getAdr: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length{-- min length of this and V":rec:-} 
 -- E.on: 2 
 -- beforeIsValueObj:E: "length{-- min length of this and V}"  ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length{-- min length of this and V":rec:-} 
 -- computeAdr:isLast:E:  "length{-- min length of this and V}" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length{-- min length of this and V":rec:-} 
 -- rec:  "length{-- min length of this and V}" E:  "length{-- min length of this and V}" 
 -- INV:gen:E.loadArgs "length{-- min length of this and V}" 
 -- $ObjectInvocation_Unary:loadArgs: "length{-- min length of this and V" >staticOff:0 "length: ;   out V: var integer;   V := get[0] -- actually an index error, accessing le ..."} 
 -- $pattern:loadArgs: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" >E:"length;-- min length of this and V":descNo:15} 
 -- ptn:loadArgs:E "length{-- min length of this and V}" 
 -- {(ObjectInvocation_Unary; (name: "length"); (Arguments --<14> min length of this and V))} 
 -- args: "-- min length of this and V" 
 -- INV:gen:after:E.loadArgs "length{-- min length of this and V}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length{-- min length of this and V}" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- $ObjectInvocation_Unary:invoke: "length{-- min length of this and V" >rec:"length;-- min length of this and V" ATd:"pattern" E:"length;-- min length of this and V" E.ATd:" ..."} 
 -- OI:invoke: "length{-- min length of this and V}" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length{-- min length of this and V":rec:length;-- min length of this and V} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length{-- min length of this and V":rec:length;-- min length of this and V} 
 -- OI:invoke:B: "length{-- min length of this and V}" E: "length{-- min length of this and V}"  rec: "length{-- min length of this and V}"  useRtnV: true "length: {   out V:  ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- $pattern:invoke: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" E: "length;-- min length of this and V" useRTNv: "True"} 
 -- ptn:invoke: "length" E: "length{-- min length of this and V}" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length{-- min length of this and V":re ...} 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length{-- min length of this and V":rec:length;-- min l ...} 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length{-- min length of this and V":rec:length;-- min length o ...} 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length{-- min length of this and V":rec:length;-- min length of this and V ...} 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length{-- min length of this and V":rec:length;-- min length o ...} 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length{-- min length of this and V":rec:length;-- min length of this and V ...} 
 -- OI:invoke:C: length{-- min length of this and V} :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length{-- min length of this and V":rec:length;-- min length of this ...} 
 -- rec: "L1" dstE: "L1" dstE.ATd: "L1: var integer" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "length{-- min length of this and V}" 
 -- isArgOfAssignI2IwithUniValArg "L1 := length{-- min length of this and V}" arg: "length{-- min length of this and V}" ObjectGenerator 
 -- arg.super.arg: "length{-- min length of this and V}" ObjectInvocation_Unary 
 -- dstDI: "L1: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg loop$53 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "L2 := Veq.length" 
 -- $Assign:gen: "L2 := Veq.length"  
 -- assign: "L2 := Veq.length" 
 -- computeAdr:superAdj: 0 "L2" 
 -- computeAdr: 1 :rec: "none"  E: "L2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L2"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L2" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L2" >ATd.off:4:on:0:superAdj:0"L2: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- $var:getAdr: "L2: var integer" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F orig ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L2: var integer" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- computeAdr:isLast:E:  "L2" 
 -- AssignmentStatement:gen: "L2 := Veq.length" right.label: "ObjectGenerator" "Veq.length" 
 -- $ObjectGenerator:gen: "Veq.length" >OGid:"length" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "Veq.length" 
 -- OG:before:super.gen: "Veq.length" 
 -- $Invocation:gen: "Veq.length" >useRtnV:"True"superAdj: 0 descNo: 15 
 -- INV:gen: "Veq.length" 
 -- isConstant: "Invocation" "Veq.length" 
 -- notConst: Veq in Veq: var this(Value) 
 -- needorigin: "Veq.length" 
 -- needOrigin:E: "length"  E.ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- doNeedOrigin:Ex: "length" 
 -- computeAdr:superAdj: 0 "Veq.length" 
 -- computeAdr: 1 :rec: "none"  E: "Veq" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Veq"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Veq" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: <= origin:isValueObj: false 
 rpushg loop$53 1
 -- $ObjectInvocation_Unary:getAdr: "Veq" >ATd.off:2:on:1:superAdj:0"in Veq: var this(Value)":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVa ... 
 -- PING:String 0 matchEq: {      inx: var integer;      c1: var char;      c2: var char;      isEmpty: do ;         if (L1 = 0) :then ;            Beq := L1 <= L2;            ...} 
 -- BOBS:ATd: "in Veq: var this(Value)" 
 -- String:vEq:  "Veq" off:  2 ATd: "in Veq: var this(Value)" 
 -- E.on: 1 
 -- beforeIsValueObj:E: "Veq"  ATd: "in Veq: var this(Value)" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "Veq"  E: "length" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "length" >ATd.off:0 (isPtn):on:0:superAdj:0"length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length":Adr ...} 
 -- $pattern:getAdr: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "Veq" >staticOff:0 "in Veq: var this(Value)" superAdj:0 
 -- $var:loadArgs: "in Veq: var this(Value)" >E:"Veq" 
 -- $pattern:loadArgs: "this: {   %basic 18;   in this: ref Object" >E:"Veq":descNo:31} 
 -- $ObjectInvocation_Unary:invoke: "Veq" >rec:"Veq" ATd:"var" isValueObj E:"length" E.ATd:"length" unique:"False" 
 -- OI:invoke: "Veq" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:B: "Veq" E: "length"  rec: "Veq"  useRtnV: true "in Veq: var this(Value)" 
 -- OI:invoke:before:ATdx.invoke: var Veq 
 -- $var:invoke: "in Veq: var this(Value)" E: "length">newOff:2 useRTNv: "True" 
 -- DI:invoke: "in Veq: var this(Value)" 
 -- isValueObj:isAdr: true objSize: 2  rec "Veq" ,E: "length" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 rpushg loop$53 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- 
 -- OI:invoke:C: Veq :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "Veq" E: "length" 
 -- computeAdr:isLast:E:  "length" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- rec:  "Veq" E:  "length" 
 -- INV:gen:E.loadArgs "length" 
 -- $ObjectInvocation_Unary:loadArgs: "length" >staticOff:0 "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" superAdj:0} 
 -- $pattern:loadArgs: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" >E:"length":descNo:15} 
 -- ptn:loadArgs:E "length" 
 -- {(ObjectInvocation_Unary; (name: "length"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "length" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- $ObjectInvocation_Unary:invoke: "length" >rec:"Veq" ATd:"pattern" E:"length" E.ATd:"length" unique:"False" 
 -- OI:invoke: "length" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:B: "length" E: "length"  rec: "Veq"  useRtnV: true "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- $pattern:invoke: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" E: "length" useRTNv: "True"} 
 -- ptn:invoke: "length" E: "length" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:C: length :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- rec: "L2" dstE: "L2" dstE.ATd: "L2: var integer" useRtn: false :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "Veq.length" 
 -- isArgOfAssignI2IwithUniValArg "L2 := Veq.length" arg: "Veq.length" ObjectGenerator 
 -- arg.super.arg: "Veq" ObjectInvocation_Unary 
 -- arg.super.arg: "length" ObjectInvocation_Unary 
 -- recx: "Veq" argx: "length" 
 -- checkInt2IntWithUnitArg:rec: "Veq" E: "length" 
 -- dstDI: "L2: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg loop$53 4
 -- assign:adr.store:B: 
 -- genclass:stmt: "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- $ObjectGenerator:gen: "if (L1 < L2) :then {   L := L1;:else ;   L := L2" >OGid:"if:then$0" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- OG:before:super.gen: "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- $Invocation:gen: "if (L1 < L2) :then {   L := L1;:else ;   L := L2" >useRtnV:"False"superAdj: 0} 
 -- INV:gen: "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- isConstant: "Invocation" "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- needorigin: "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- needOrigin:E: "if (L1 < L2) :then {   L := L1;:else ;   L := L2}"  E.ATd: "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;    ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" E:  "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- INV:gen:E.loadArgs "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- $IfThenElse:loadArgs: "if (L1 < L2) :then {   L := L1;:else ;   L := L2" } 
 -- INV:gen:after:E.loadArgs "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThenElse "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- $IfThenElse:invoke: "if (L1 < L2) :then {   L := L1;:else ;   L := L2" } 
 -- $IfThenElse:gen: "if (L1 < L2) :then {   L := L1;:else ;   L := L2" } 
 -- $ObjectGenerator:gen: "(L1 < L2)" >OGid:"<" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(L1 < L2)" 
 -- OG:before:super.gen: "(L1 < L2)" 
 -- $Invocation:gen: "(L1 < L2)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(L1 < L2)" 
 -- isConstant: "Invocation" "(L1 < L2)" 
 -- needorigin: "(L1 < L2)" 
 -- needOrigin:E: "(L1 < L2)"  E.ATd: "<  : {   %basic 51;   in V: var integer;   out B: var boolean}" 
 -- doNeedOrigin:Ex: "(L1 < L2)" 
 -- computeAdr:superAdj: 0 "(L1 < L2)" 
 -- computeAdr: 1 :rec: "none"  E: "(L1 < L2)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(L1 < L2)"  
 -- $BracketedExp:loadOrigin: "(L1 < L2)"  
 -- computeAdr:superAdj: 0 "L1 < L2" 
 -- computeAdr: 1 :rec: "none"  E: "L1 < L2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "L1 < L2"  
 -- $BinOp:loadOrigin: "L1 < L2"  
 -- BinaryExp:loadOrigin:empty: "L1 < L2" superAdj: 0 
 -- $BinOp:getAdr: "L1 < L2"  
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "L1 < L2" 
 -- BE:loadOrigin:E: L1 < L2 
 -- $BinOp:getAdr: "L1 < L2"  
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "L1 < L2" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "L1 < L2" E:  "L1 < L2" 
 -- INV:gen:E.loadArgs "L1 < L2" 
 -- $BinOp:loadArgs: "L1 < L2"  
 -- BinaryExp:loadArgs: "L1 < L2" superAdj: 0 
 -- $Invocation:gen: "L1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L1" 
 -- isConstant: "Invocation" "L1" 
 -- notConst: L1 L1: var integer 
 -- needorigin: "L1" 
 -- needOrigin:E: "L1"  E.ATd: "L1: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L1" 
 -- computeAdr: 1 :rec: "none"  E: "L1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L1"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L1" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L1" >ATd.off:3:on:0:superAdj:0"L1: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- $var:getAdr: "L1: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F orig ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L1: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- computeAdr:isLast:E:  "L1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- rec:  "L1" E:  "L1" 
 -- INV:gen:E.loadArgs "L1" 
 -- $ObjectInvocation_Unary:loadArgs: "L1" >staticOff:0 "L1: var integer" superAdj:0 
 -- $var:loadArgs: "L1: var integer" >E:"L1" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "L1" 
 -- {(ObjectInvocation_Unary; (name: "L1"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L1" >rec:"L1" ATd:"var" isValueObj E:"L1" E.ATd:"L1" unique:"False" 
 -- OI:invoke: "L1" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:B: "L1" E: "L1"  rec: "L1"  useRtnV: true "L1: var integer" 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- $var:invoke: "L1: var integer" E: "L1">newOff:3 useRTNv: "True" 
 -- DI:invoke: "L1: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- isCompositeValueObj: false E: "L1" "L1: var integer" true 
 -- E.ATd.isValueObj: false rec: "L1" 
 pushg 3 loop$53
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 3 vTopMax: 3 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- OI:invoke:C: L1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- left:#I "L1 < L2" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- $pattern:loadArgs: "<  : {   %basic 51;   in V: var integer;   out B: var boolean" >E:"< L2":descNo:54} 
 -- ptn:loadArgs:E "< L2" 
 -- {(ObjectInvocation_Binary; (name: "<"); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "L2");     (Arguments)));   (Items descNo: 0 o ...} 
 -- args: "L2" 
 -- E: "ObjectGenerator" L2 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "< L2" "ObjectInvocation_Binary" ActArg:  "L2" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "< L2"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "L2" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L2" 
 -- OG:before:super.gen: "L2" 
 -- $Invocation:gen: "L2" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L2" 
 -- isConstant: "Invocation" "L2" 
 -- notConst: L2 L2: var integer 
 -- needorigin: "L2" 
 -- needOrigin:E: "L2"  E.ATd: "L2: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L2" 
 -- computeAdr: 1 :rec: "none"  E: "L2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L2"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L2" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L2" >ATd.off:4:on:0:superAdj:0"L2: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- $var:getAdr: "L2: var integer" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F orig ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L2: var integer" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- computeAdr:isLast:E:  "L2" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- rec:  "L2" E:  "L2" 
 -- INV:gen:E.loadArgs "L2" 
 -- $ObjectInvocation_Unary:loadArgs: "L2" >staticOff:0 "L2: var integer" superAdj:0 
 -- $var:loadArgs: "L2: var integer" >E:"L2" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "L2" 
 -- {(ObjectInvocation_Unary; (name: "L2"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L2" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L2" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L2" >rec:"L2" ATd:"var" isValueObj E:"L2" E.ATd:"L2" unique:"False" 
 -- OI:invoke: "L2" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:B: "L2" E: "L2"  rec: "L2"  useRtnV: true "L2: var integer" 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- $var:invoke: "L2: var integer" E: "L2">newOff:4 useRTNv: "True" 
 -- DI:invoke: "L2: var integer" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- isCompositeValueObj: false E: "L2" "L2: var integer" true 
 -- E.ATd.isValueObj: false rec: "L2" 
 pushg 4 loop$53
 -- stack: rpop : vTop: 3 vTopMax: 3 rTop: -4 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 4 vTopMax: 4 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- 
 -- OI:invoke:C: L2 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "L2" :isBasicVal: true 
 -- case:B: L2 ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "< L2" 
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:after:E.loadArgs "L1 < L2" 
 -- OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L1 < L2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- $BinOp:invoke: "L1 < L2"  
 -- BinaryExp:invoke: "L1" rec: "L1 < L2" 
 -- M: "< L2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- $ObjectInvocation_Binary:invoke: "< L2" >rec:"L1" ATd:"pattern" E:"< L2" E.ATd:"<  " unique:"False" 
 -- OI:invoke: "< L2" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- origin:isValueObj "integer" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:B: "< L2" E: "< L2"  rec: "L1"  useRtnV: true "<  : {   %basic 51;   in V: var integer;   out B: var boolean}" 
 -- OI:invoke:before:ATdx.invoke: pattern <   
 -- $pattern:invoke: "<  : {   %basic 51;   in V: var integer;   out B: var boolean" E: "< L2" useRTNv: "True"} 
 -- ptn:invoke: "<  " E: "< L2" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "L1" E: "< L2" 
 -- arg:other 
 lt
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< L2":rec:L1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< L2":rec:L1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: < L2 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: "L := L1" >OGid:"$55" singular! staticOff=0 descNo=55 superAdj=0 
 -- OG:gen: "L := L1" 
 pushThis 
 -- before objTmpStack:add:  55   "$55" 
 invoke $55 55 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 4 vTopMax: 4 rTop: -5 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L5
 L4:
 -- $ObjectGenerator:gen: "L := L2" >OGid:"$56" singular! staticOff=0 descNo=56 superAdj=0 
 -- OG:gen: "L := L2" 
 pushThis 
 -- before objTmpStack:add:  56   "$56" 
 invoke $56 56 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 4 vTopMax: 4 rTop: -6 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L5:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "matchEq" 
 -- $ObjectGenerator:gen: "matchEq" >OGid:"matchEq" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "matchEq" 
 -- OG:before:super.gen: "matchEq" 
 -- $Invocation:gen: "matchEq" >useRtnV:"False"superAdj: 0 descNo: 57 
 -- INV:gen: "matchEq" 
 -- isConstant: "Invocation" "matchEq" 
 -- needorigin: "matchEq" 
 -- needOrigin:E: "matchEq"  E.ATd: "matchEq: {   inx: var integer;   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := L1 <= L2;         l ...}" 
 -- doNeedOrigin:Ex: "matchEq" 
 -- computeAdr:superAdj: 0 "matchEq" 
 -- computeAdr: 1 :rec: "none"  E: "matchEq" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "matchEq"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "matchEq" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "matchEq" >ATd.off:0 (isPtn):on:0:superAdj:0"matchEq: {   inx: var integer;   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0 ..."} 
 -- $pattern:getAdr: "matchEq: {   inx: var integer;   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := L1 <= L2;         leave(matchEq);  ..."} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:- 
 -- computeAdr:isLast:E:  "matchEq" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:- 
 -- rec:  "matchEq" E:  "matchEq" 
 -- INV:gen:E.loadArgs "matchEq" 
 -- $ObjectInvocation_Unary:loadArgs: "matchEq" >staticOff:0 "matchEq: {   inx: var integer;   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         B ..."} 
 -- $pattern:loadArgs: "matchEq: {   inx: var integer;   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := L1 <= L2;         leave(matchEq) ..."} 
 -- ptn:loadArgs:E "matchEq" 
 -- {(ObjectInvocation_Unary; (name: "matchEq"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "matchEq" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "matchEq" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:- 
 -- $ObjectInvocation_Unary:invoke: "matchEq" >rec:"matchEq" ATd:"pattern" E:"matchEq" E.ATd:"matchEq" unique:"False" 
 -- OI:invoke: "matchEq" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:matchEq 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:matchEq 
 -- OI:invoke:B: "matchEq" E: "matchEq"  rec: "matchEq"  useRtnV: false "matchEq: {   inx: var integer;   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then  ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern matchEq 
 -- $pattern:invoke: "matchEq: {   inx: var integer;   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := L1 <= L2;         leave(matchEq);  ..."} 
 -- ptn:invoke: "matchEq" E: "matchEq" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:matchEq 
 invoke matchEq 57 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 4 vTopMax: 4 rTop: -7 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:matchEq 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:matchEq 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: matchEq :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:matchEq 
 L2:
 -- pushReturn:  "loop" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 55 
 -- Items:GenClass: $55 descNo: 55 isValue: false 
 -- Items:GenClass: $55 descNo: 21 isValue: false 

 CLASS $55 55 1 loop 53
 -- Store itemArgs: L := L1 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=55 vDescInx=55 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "L := L1" 
 -- $Assign:gen: "L := L1"  
 -- assign: "L := L1" 
 -- computeAdr:superAdj: 0 "L" 
 -- computeAdr: 1 :rec: "none"  E: "L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$55" on: 1 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg $55$55 1
 -- $ObjectInvocation_Unary:getAdr: "L" >ATd.off:2:on:1:superAdj:0"L: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "L: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "L"  ATd: "L: var integer" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdr:isLast:E:  "L" 
 -- AssignmentStatement:gen: "L := L1" right.label: "ObjectGenerator" "L1" 
 -- $ObjectGenerator:gen: "L1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L1" 
 -- OG:before:super.gen: "L1" 
 -- $Invocation:gen: "L1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L1" 
 -- isConstant: "Invocation" "L1" 
 -- notConst: L1 L1: var integer 
 -- needorigin: "L1" 
 -- needOrigin:E: "L1"  E.ATd: "L1: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L1" 
 -- computeAdr: 1 :rec: "none"  E: "L1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L1"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L1" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$55" on: 1 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg $55$55 1
 -- $ObjectInvocation_Unary:getAdr: "L1" >ATd.off:3:on:1:superAdj:0"L1: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- $var:getAdr: "L1: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F orig ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L1: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "L1"  ATd: "L1: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- computeAdr:isLast:E:  "L1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- rec:  "L1" E:  "L1" 
 -- INV:gen:E.loadArgs "L1" 
 -- $ObjectInvocation_Unary:loadArgs: "L1" >staticOff:0 "L1: var integer" superAdj:0 
 -- $var:loadArgs: "L1: var integer" >E:"L1" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "L1" 
 -- {(ObjectInvocation_Unary; (name: "L1"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L1" >rec:"L1" ATd:"var" isValueObj E:"L1" E.ATd:"L1" unique:"False" 
 -- OI:invoke: "L1" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:B: "L1" E: "L1"  rec: "L1"  useRtnV: true "L1: var integer" 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- $var:invoke: "L1: var integer" E: "L1">newOff:3 useRTNv: "True" 
 -- DI:invoke: "L1: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- isCompositeValueObj: false E: "L1" "L1: var integer" true 
 -- E.ATd.isValueObj: false rec: "L1" 
 pushg 3 loop$53
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- OI:invoke:C: L1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- rec: "L" dstE: "L" dstE.ATd: "L: var integer" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "L1" 
 -- isArgOfAssignI2IwithUniValArg "L := L1" arg: "L1" ObjectGenerator 
 -- arg.super.arg: "L1" ObjectInvocation_Unary 
 -- dstDI: "L: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg loop$53 2
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 56 
 -- Items:GenClass: $56 descNo: 56 isValue: false 
 -- Items:GenClass: $56 descNo: 21 isValue: false 

 CLASS $56 56 1 loop 53
 -- Store itemArgs: L := L2 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=56 vDescInx=56 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "L := L2" 
 -- $Assign:gen: "L := L2"  
 -- assign: "L := L2" 
 -- computeAdr:superAdj: 0 "L" 
 -- computeAdr: 1 :rec: "none"  E: "L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$56" on: 1 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg $56$56 1
 -- $ObjectInvocation_Unary:getAdr: "L" >ATd.off:2:on:1:superAdj:0"L: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "L: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "L"  ATd: "L: var integer" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdr:isLast:E:  "L" 
 -- AssignmentStatement:gen: "L := L2" right.label: "ObjectGenerator" "L2" 
 -- $ObjectGenerator:gen: "L2" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L2" 
 -- OG:before:super.gen: "L2" 
 -- $Invocation:gen: "L2" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L2" 
 -- isConstant: "Invocation" "L2" 
 -- notConst: L2 L2: var integer 
 -- needorigin: "L2" 
 -- needOrigin:E: "L2"  E.ATd: "L2: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L2" 
 -- computeAdr: 1 :rec: "none"  E: "L2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L2"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L2" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$56" on: 1 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg $56$56 1
 -- $ObjectInvocation_Unary:getAdr: "L2" >ATd.off:4:on:1:superAdj:0"L2: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- $var:getAdr: "L2: var integer" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F orig ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L2: var integer" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "L2"  ATd: "L2: var integer" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- computeAdr:isLast:E:  "L2" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- rec:  "L2" E:  "L2" 
 -- INV:gen:E.loadArgs "L2" 
 -- $ObjectInvocation_Unary:loadArgs: "L2" >staticOff:0 "L2: var integer" superAdj:0 
 -- $var:loadArgs: "L2: var integer" >E:"L2" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "L2" 
 -- {(ObjectInvocation_Unary; (name: "L2"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L2" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L2" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L2" >rec:"L2" ATd:"var" isValueObj E:"L2" E.ATd:"L2" unique:"False" 
 -- OI:invoke: "L2" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:B: "L2" E: "L2"  rec: "L2"  useRtnV: true "L2: var integer" 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- $var:invoke: "L2: var integer" E: "L2">newOff:4 useRTNv: "True" 
 -- DI:invoke: "L2: var integer" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- isCompositeValueObj: false E: "L2" "L2: var integer" true 
 -- E.ATd.isValueObj: false rec: "L2" 
 pushg 4 loop$53
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- 
 -- OI:invoke:C: L2 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- rec: "L" dstE: "L" dstE.ATd: "L: var integer" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "L2" 
 -- isArgOfAssignI2IwithUniValArg "L := L2" arg: "L2" ObjectGenerator 
 -- arg.super.arg: "L2" ObjectInvocation_Unary 
 -- dstDI: "L: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg loop$53 2
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 57 
 -- Items:GenClass: matchEq descNo: 57 isValue: false 
 -- Items:GenClass: matchEq descNo: 21 isValue: false 

 CLASS matchEq 57 1 loop 53
 -- Store itemArgs: inx: var integer{c1: var char;c2: var char;isEmpty: do ;   if (L1 = 0) :then ;      Beq := L1 <= L2;      leave(matchEq);   if (L2 = 0) :then ;      Beq := ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=57 vDescInx=57 vdtTop: 1 
 mvStack 
 -- $var:gen: "inx: var integer"  
 -- DI:gen: "inx: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  inx 
 -- $var:gen: "c1: var char"  
 -- DI:gen: "c1: var char" DI:isConst: false :isBasicValue: true :primNo: 3 
 -- DI:add:BP1:  c1 
 -- $var:gen: "c2: var char"  
 -- DI:gen: "c2: var char" DI:isConst: false :isBasicValue: true :primNo: 3 
 -- DI:add:BP1:  c2 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "isEmpty: do {   if (L1 = 0) :then ;      Beq := L1 <= L2;      leave(matchEq);   if (L2 = 0) :then ;      Beq := false;      leave(matchEq)}" 
 -- $do:gen: "isEmpty: do {   if (L1 = 0) :then ;      Beq := L1 <= L2;      leave(matchEq);   if (L2 = 0) :then ;      Beq := false;      leave(matchEq)" } 
 -- $ObjectGenerator:gen: "if (L1 = 0) :then {      Beq := L1 <= L2;      leave(matchEq);   if (L2 = 0) :then ;      Beq := false;      leave(matchEq)" >OGid:"isEmpty" singula ...} 
 -- OG:gen: "if (L1 = 0) :then {      Beq := L1 <= L2;      leave(matchEq);   if (L2 = 0) :then ;      Beq := false;      leave(matchEq)}" 
 pushThis 
 -- before objTmpStack:add:  58   "isEmpty" 
 invoke isEmpty 58 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- genclass:stmt: "loop: do {   inx := inx + 1;   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 = c2) :then ;      if (inx < L) :then ;         restart(loop)}" 
 -- $do:gen: "loop: do {   inx := inx + 1;   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 = c2) :then ;      if (inx < L) :then ;         restart(loop)" } 
 -- $ObjectGenerator:gen: "inx := inx + 1{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 = c2) :then ;      if (inx < L) :then ;         restart(loop)" >OGid:"loop" singula ...} 
 -- OG:gen: "inx := inx + 1{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 = c2) :then ;      if (inx < L) :then ;         restart(loop)}" 
 pushThis 
 -- before objTmpStack:add:  61   "loop" 
 invoke loop 61 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- genclass:stmt: "doit: do {   if (c1 = c2) :then ;      -- we have inx = LBeq := L1 <= L2;      leave(matchEq);   :else ;      Beq := c1 < c2;      leave(matchEq)}" 
 -- $do:gen: "doit: do {   if (c1 = c2) :then ;      -- we have inx = LBeq := L1 <= L2;      leave(matchEq);   :else ;      Beq := c1 < c2;      leave(matchEq)" } 
 -- $ObjectGenerator:gen: "if (c1 = c2) :then {      -- we have inx = LBeq := L1 <= L2;      leave(matchEq);   :else ;      Beq := c1 < c2;      leave(matchEq)" >OGid:"doit" s ...} 
 -- OG:gen: "if (c1 = c2) :then {      -- we have inx = LBeq := L1 <= L2;      leave(matchEq);   :else ;      Beq := c1 < c2;      leave(matchEq)}" 
 pushThis 
 -- before objTmpStack:add:  64   "doit" 
 invoke doit 64 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 -- pushReturn:  "matchEq" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 58 
 -- Items:GenClass: isEmpty descNo: 58 isValue: false 
 -- Items:GenClass: isEmpty descNo: 21 isValue: false 

 CLASS isEmpty 58 1 matchEq 57
 -- Store itemArgs: if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq);if (L2 = 0) :then ;   Beq := false;   leave(matchEq)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=58 vDescInx=58 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- $ObjectGenerator:gen: "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)" >OGid:"if:then$0" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- OG:before:super.gen: "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- $Invocation:gen: "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)" >useRtnV:"False"superAdj: 0} 
 -- INV:gen: "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- isConstant: "Invocation" "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- needorigin: "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- needOrigin:E: "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}"  E.ATd: "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" E:  "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- INV:gen:E.loadArgs "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- $IfThen:loadArgs: "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)" } 
 -- INV:gen:after:E.loadArgs "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- $IfThen:invoke: "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)" } 
 -- $IfThen:gen: "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)" } 
 -- $ObjectGenerator:gen: "(L1 = 0)" >OGid:"=" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(L1 = 0)" 
 -- OG:before:super.gen: "(L1 = 0)" 
 -- $Invocation:gen: "(L1 = 0)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(L1 = 0)" 
 -- isConstant: "Invocation" "(L1 = 0)" 
 -- needorigin: "(L1 = 0)" 
 -- needOrigin:E: "(L1 = 0)"  E.ATd: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- doNeedOrigin:Ex: "(L1 = 0)" 
 -- computeAdr:superAdj: 0 "(L1 = 0)" 
 -- computeAdr: 1 :rec: "none"  E: "(L1 = 0)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(L1 = 0)"  
 -- $BracketedExp:loadOrigin: "(L1 = 0)"  
 -- computeAdr:superAdj: 0 "L1 = 0" 
 -- computeAdr: 1 :rec: "none"  E: "L1 = 0" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "L1 = 0"  
 -- $BinOp:loadOrigin: "L1 = 0"  
 -- BinaryExp:loadOrigin:empty: "L1 = 0" superAdj: 0 
 -- $BinOp:getAdr: "L1 = 0"  
 -- E.on: 2 
 -- beforeIsValueObj:E: "L1 = 0"  ATd: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "L1 = 0" 
 -- BE:loadOrigin:E: L1 = 0 
 -- $BinOp:getAdr: "L1 = 0"  
 -- E.on: 2 
 -- beforeIsValueObj:E: "L1 = 0"  ATd: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "L1 = 0" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "L1 = 0" E:  "L1 = 0" 
 -- INV:gen:E.loadArgs "L1 = 0" 
 -- $BinOp:loadArgs: "L1 = 0"  
 -- BinaryExp:loadArgs: "L1 = 0" superAdj: 0 
 -- $Invocation:gen: "L1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L1" 
 -- isConstant: "Invocation" "L1" 
 -- notConst: L1 L1: var integer 
 -- needorigin: "L1" 
 -- needOrigin:E: "L1"  E.ATd: "L1: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L1" 
 -- computeAdr: 1 :rec: "none"  E: "L1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L1"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L1" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "isEmpty" on: 2 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$58 1
 -- items:goOrigin:encOG: "matchEq" on: 1 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg matchEq$57 1
 -- $ObjectInvocation_Unary:getAdr: "L1" >ATd.off:3:on:2:superAdj:0"L1: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- $var:getAdr: "L1: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F orig ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L1: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "L1"  ATd: "L1: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- computeAdr:isLast:E:  "L1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- rec:  "L1" E:  "L1" 
 -- INV:gen:E.loadArgs "L1" 
 -- $ObjectInvocation_Unary:loadArgs: "L1" >staticOff:0 "L1: var integer" superAdj:0 
 -- $var:loadArgs: "L1: var integer" >E:"L1" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "L1" 
 -- {(ObjectInvocation_Unary; (name: "L1"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L1" >rec:"L1" ATd:"var" isValueObj E:"L1" E.ATd:"L1" unique:"False" 
 -- OI:invoke: "L1" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:B: "L1" E: "L1"  rec: "L1"  useRtnV: true "L1: var integer" 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- $var:invoke: "L1: var integer" E: "L1">newOff:3 useRTNv: "True" 
 -- DI:invoke: "L1: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- isCompositeValueObj: false E: "L1" "L1: var integer" true 
 -- E.ATd.isValueObj: false rec: "L1" 
 pushg 3 loop$53
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- OI:invoke:C: L1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- left:#I "L1 = 0" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- $pattern:loadArgs: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )" >E:"= 0":descNo:11} 
 -- ptn:loadArgs:E "= 0" 
 -- {(ObjectInvocation_Binary; (name: "="); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 0));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "0" 
 -- E: "ObjectGenerator" 0 
 -- E.arg: "var" in Veq: var this(Value) 
 -- NonVirt: "= 0" "ObjectInvocation_Binary" ActArg:  "0" isValue:  true 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "= 0"  isCompositeValueObj: true 
 -- $ObjectGenerator:gen: "0" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "0" 
 -- OG:before:super.gen: "0" 
 -- $Invocation:gen: "0" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "0" 
 -- isConstant: "Invocation" "0" 
 -- needorigin: "0" 
 -- needOrigin:E: "0"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "0" E:  "0" 
 -- INV:gen:E.loadArgs "0" 
 -- $ConstLiteral:loadArgs: "0"  
 -- INV:gen:after:E.loadArgs "0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0" 
 -- $ConstLiteral:invoke: "0"  
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- vEq: 
 -- end:loadArgs:NonVirt: "= 0" 
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:after:E.loadArgs "L1 = 0" 
 -- OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L1 = 0" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- $BinOp:invoke: "L1 = 0"  
 -- BinaryExp:invoke: "L1" rec: "L1 = 0" 
 -- M: "= 0" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- $ObjectInvocation_Binary:invoke: "= 0" >rec:"L1" ATd:"pattern" E:"= 0" E.ATd:"=  " unique:"False" 
 -- OI:invoke: "= 0" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- origin:isValueObj "Value" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:B: "= 0" E: "= 0"  rec: "L1"  useRtnV: true "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OI:invoke:before:ATdx.invoke: pattern =   
 -- $pattern:invoke: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )" E: "= 0" useRTNv: "True"} 
 -- ptn:invoke: "=  " E: "= 0" ptnKind: 1 useRtnV: true 
 -- rec: "L1" "Invocation" OGx.label: "ObjectGenerator" OGx: integer 
 -- rec.ATd: "L1: var integer" 
 -- bobs: 1 OGx: integer 
 eq
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= 0":rec:L1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= 0":rec:L1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: = 0 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: "Beq := L1 <= L2{   leave(matchEq)" >OGid:"$59" singular! staticOff=0 descNo=59 superAdj=0} 
 -- OG:gen: "Beq := L1 <= L2{   leave(matchEq)}" 
 pushThis 
 -- before objTmpStack:add:  59   "$59" 
 invoke $59 59 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- $ObjectGenerator:gen: "if (L2 = 0) :then {   Beq := false;   leave(matchEq)" >OGid:"if:then$0" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- OG:before:super.gen: "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- $Invocation:gen: "if (L2 = 0) :then {   Beq := false;   leave(matchEq)" >useRtnV:"False"superAdj: 0} 
 -- INV:gen: "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- isConstant: "Invocation" "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- needorigin: "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- needOrigin:E: "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}"  E.ATd: "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100 ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" E:  "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- INV:gen:E.loadArgs "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- $IfThen:loadArgs: "if (L2 = 0) :then {   Beq := false;   leave(matchEq)" } 
 -- INV:gen:after:E.loadArgs "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- $IfThen:invoke: "if (L2 = 0) :then {   Beq := false;   leave(matchEq)" } 
 -- $IfThen:gen: "if (L2 = 0) :then {   Beq := false;   leave(matchEq)" } 
 -- $ObjectGenerator:gen: "(L2 = 0)" >OGid:"=" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(L2 = 0)" 
 -- OG:before:super.gen: "(L2 = 0)" 
 -- $Invocation:gen: "(L2 = 0)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(L2 = 0)" 
 -- isConstant: "Invocation" "(L2 = 0)" 
 -- needorigin: "(L2 = 0)" 
 -- needOrigin:E: "(L2 = 0)"  E.ATd: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- doNeedOrigin:Ex: "(L2 = 0)" 
 -- computeAdr:superAdj: 0 "(L2 = 0)" 
 -- computeAdr: 1 :rec: "none"  E: "(L2 = 0)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(L2 = 0)"  
 -- $BracketedExp:loadOrigin: "(L2 = 0)"  
 -- computeAdr:superAdj: 0 "L2 = 0" 
 -- computeAdr: 1 :rec: "none"  E: "L2 = 0" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "L2 = 0"  
 -- $BinOp:loadOrigin: "L2 = 0"  
 -- BinaryExp:loadOrigin:empty: "L2 = 0" superAdj: 0 
 -- $BinOp:getAdr: "L2 = 0"  
 -- E.on: 2 
 -- beforeIsValueObj:E: "L2 = 0"  ATd: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "L2 = 0" 
 -- BE:loadOrigin:E: L2 = 0 
 -- $BinOp:getAdr: "L2 = 0"  
 -- E.on: 2 
 -- beforeIsValueObj:E: "L2 = 0"  ATd: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "L2 = 0" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "L2 = 0" E:  "L2 = 0" 
 -- INV:gen:E.loadArgs "L2 = 0" 
 -- $BinOp:loadArgs: "L2 = 0"  
 -- BinaryExp:loadArgs: "L2 = 0" superAdj: 0 
 -- $Invocation:gen: "L2" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L2" 
 -- isConstant: "Invocation" "L2" 
 -- notConst: L2 L2: var integer 
 -- needorigin: "L2" 
 -- needOrigin:E: "L2"  E.ATd: "L2: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L2" 
 -- computeAdr: 1 :rec: "none"  E: "L2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L2"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L2" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "isEmpty" on: 2 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$58 1
 -- items:goOrigin:encOG: "matchEq" on: 1 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg matchEq$57 1
 -- $ObjectInvocation_Unary:getAdr: "L2" >ATd.off:4:on:2:superAdj:0"L2: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- $var:getAdr: "L2: var integer" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F orig ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L2: var integer" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "L2"  ATd: "L2: var integer" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- computeAdr:isLast:E:  "L2" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- rec:  "L2" E:  "L2" 
 -- INV:gen:E.loadArgs "L2" 
 -- $ObjectInvocation_Unary:loadArgs: "L2" >staticOff:0 "L2: var integer" superAdj:0 
 -- $var:loadArgs: "L2: var integer" >E:"L2" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "L2" 
 -- {(ObjectInvocation_Unary; (name: "L2"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L2" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L2" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L2" >rec:"L2" ATd:"var" isValueObj E:"L2" E.ATd:"L2" unique:"False" 
 -- OI:invoke: "L2" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:B: "L2" E: "L2"  rec: "L2"  useRtnV: true "L2: var integer" 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- $var:invoke: "L2: var integer" E: "L2">newOff:4 useRTNv: "True" 
 -- DI:invoke: "L2: var integer" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- isCompositeValueObj: false E: "L2" "L2: var integer" true 
 -- E.ATd.isValueObj: false rec: "L2" 
 pushg 4 loop$53
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -3 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- 
 -- OI:invoke:C: L2 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- left:#I "L2 = 0" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- $pattern:loadArgs: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )" >E:"= 0":descNo:11} 
 -- ptn:loadArgs:E "= 0" 
 -- {(ObjectInvocation_Binary; (name: "="); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 0));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "0" 
 -- E: "ObjectGenerator" 0 
 -- E.arg: "var" in Veq: var this(Value) 
 -- NonVirt: "= 0" "ObjectInvocation_Binary" ActArg:  "0" isValue:  true 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "= 0"  isCompositeValueObj: true 
 -- $ObjectGenerator:gen: "0" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "0" 
 -- OG:before:super.gen: "0" 
 -- $Invocation:gen: "0" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "0" 
 -- isConstant: "Invocation" "0" 
 -- needorigin: "0" 
 -- needOrigin:E: "0"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "0" E:  "0" 
 -- INV:gen:E.loadArgs "0" 
 -- $ConstLiteral:loadArgs: "0"  
 -- INV:gen:after:E.loadArgs "0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0" 
 -- $ConstLiteral:invoke: "0"  
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- vEq: 
 -- end:loadArgs:NonVirt: "= 0" 
 -- BinaryExp:loadArgs:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- INV:gen:after:E.loadArgs "L2 = 0" 
 -- OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L2 = 0" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- $BinOp:invoke: "L2 = 0"  
 -- BinaryExp:invoke: "L2" rec: "L2 = 0" 
 -- M: "= 0" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- $ObjectInvocation_Binary:invoke: "= 0" >rec:"L2" ATd:"pattern" E:"= 0" E.ATd:"=  " unique:"False" 
 -- OI:invoke: "= 0" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- origin:isValueObj "Value" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:B: "= 0" E: "= 0"  rec: "L2"  useRtnV: true "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OI:invoke:before:ATdx.invoke: pattern =   
 -- $pattern:invoke: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )" E: "= 0" useRTNv: "True"} 
 -- ptn:invoke: "=  " E: "= 0" ptnKind: 1 useRtnV: true 
 -- rec: "L2" "Invocation" OGx.label: "ObjectGenerator" OGx: integer 
 -- rec.ATd: "L2: var integer" 
 -- bobs: 1 OGx: integer 
 eq
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= 0":rec:L2 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= 0":rec:L2 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: = 0 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L7
 L6:
 -- $ObjectGenerator:gen: "Beq := false{   leave(matchEq)" >OGid:"$60" singular! staticOff=0 descNo=60 superAdj=0} 
 -- OG:gen: "Beq := false{   leave(matchEq)}" 
 pushThis 
 -- before objTmpStack:add:  60   "$60" 
 invoke $60 60 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L7:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 -- pushReturn:  "isEmpty" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 59 
 -- Items:GenClass: $59 descNo: 59 isValue: false 
 -- Items:GenClass: $59 descNo: 21 isValue: false 

 CLASS $59 59 1 isEmpty 58
 -- Store itemArgs: Beq := L1 <= L2{leave(matchEq)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=59 vDescInx=59 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "Beq := L1 <= L2" 
 -- $Assign:gen: "Beq := L1 <= L2"  
 -- assign: "Beq := L1 <= L2" 
 -- computeAdr:superAdj: 0 "Beq" 
 -- computeAdr: 1 :rec: "none"  E: "Beq" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Beq"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Beq" >on:4 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$59" on: 4 isValueObj: false 
 -- origin: isEmpty origin:isValueObj: false 
 rpushg $59$59 1
 -- items:goOrigin:encOG: "isEmpty" on: 3 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$58 1
 -- items:goOrigin:encOG: "matchEq" on: 2 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg matchEq$57 1
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: <= origin:isValueObj: false 
 rpushg loop$53 1
 -- $ObjectInvocation_Unary:getAdr: "Beq" >ATd.off:3:on:4:superAdj:0"out Beq: var boolean":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ... 
 -- $var:getAdr: "out Beq: var boolean" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: boolean 
 -- before:floatTest:  "out Beq: var boolean" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "Beq"  ATd: "out Beq: var boolean" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- computeAdr:isLast:E:  "Beq" 
 -- AssignmentStatement:gen: "Beq := L1 <= L2" right.label: "ObjectGenerator" "L1 <= L2" 
 -- $ObjectGenerator:gen: "L1 <= L2" >OGid:"<=" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L1 <= L2" 
 -- OG:before:super.gen: "L1 <= L2" 
 -- $Invocation:gen: "L1 <= L2" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L1 <= L2" 
 -- isConstant: "Invocation" "L1 <= L2" 
 -- needorigin: "L1 <= L2" 
 -- needOrigin:E: "L1 <= L2"  E.ATd: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- doNeedOrigin:Ex: "L1 <= L2" 
 -- computeAdr:superAdj: 0 "L1 <= L2" 
 -- computeAdr: 1 :rec: "none"  E: "L1 <= L2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "L1 <= L2"  
 -- $BinOp:loadOrigin: "L1 <= L2"  
 -- BinaryExp:loadOrigin:empty: "L1 <= L2" superAdj: 0 
 -- $BinOp:getAdr: "L1 <= L2"  
 -- E.on: 3 
 -- beforeIsValueObj:E: "L1 <= L2"  ATd: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "L1 <= L2" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "L1 <= L2" E:  "L1 <= L2" 
 -- INV:gen:E.loadArgs "L1 <= L2" 
 -- $BinOp:loadArgs: "L1 <= L2"  
 -- BinaryExp:loadArgs: "L1 <= L2" superAdj: 0 
 -- $Invocation:gen: "L1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L1" 
 -- isConstant: "Invocation" "L1" 
 -- notConst: L1 L1: var integer 
 -- needorigin: "L1" 
 -- needOrigin:E: "L1"  E.ATd: "L1: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L1" 
 -- computeAdr: 1 :rec: "none"  E: "L1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L1"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L1" >on:3 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$59" on: 3 isValueObj: false 
 -- origin: isEmpty origin:isValueObj: false 
 rpushg $59$59 1
 -- items:goOrigin:encOG: "isEmpty" on: 2 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$58 1
 -- items:goOrigin:encOG: "matchEq" on: 1 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg matchEq$57 1
 -- $ObjectInvocation_Unary:getAdr: "L1" >ATd.off:3:on:3:superAdj:0"L1: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- $var:getAdr: "L1: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F orig ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L1: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- E.on: 3 
 -- beforeIsValueObj:E: "L1"  ATd: "L1: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- computeAdr:isLast:E:  "L1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- rec:  "L1" E:  "L1" 
 -- INV:gen:E.loadArgs "L1" 
 -- $ObjectInvocation_Unary:loadArgs: "L1" >staticOff:0 "L1: var integer" superAdj:0 
 -- $var:loadArgs: "L1: var integer" >E:"L1" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "L1" 
 -- {(ObjectInvocation_Unary; (name: "L1"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L1" >rec:"L1" ATd:"var" isValueObj E:"L1" E.ATd:"L1" unique:"False" 
 -- OI:invoke: "L1" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:B: "L1" E: "L1"  rec: "L1"  useRtnV: true "L1: var integer" 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- $var:invoke: "L1: var integer" E: "L1">newOff:3 useRTNv: "True" 
 -- DI:invoke: "L1: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- isCompositeValueObj: false E: "L1" "L1: var integer" true 
 -- E.ATd.isValueObj: false rec: "L1" 
 pushg 3 loop$53
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- OI:invoke:C: L1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- left:#I "L1 <= L2" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- $pattern:loadArgs: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean" >E:"<= L2":descNo:47} 
 -- ptn:loadArgs:E "<= L2" 
 -- {(ObjectInvocation_Binary; (name: "<="); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "L2");     (Arguments)));   (Items descNo: 0  ...} 
 -- args: "L2" 
 -- E: "ObjectGenerator" L2 
 -- E.arg: "var" in Veq: var this(Value) 
 -- NonVirt: "<= L2" "ObjectInvocation_Binary" ActArg:  "L2" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "<= L2"  isCompositeValueObj: true 
 -- $ObjectGenerator:gen: "L2" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L2" 
 -- OG:before:super.gen: "L2" 
 -- $Invocation:gen: "L2" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L2" 
 -- isConstant: "Invocation" "L2" 
 -- notConst: L2 L2: var integer 
 -- needorigin: "L2" 
 -- needOrigin:E: "L2"  E.ATd: "L2: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L2" 
 -- computeAdr: 1 :rec: "none"  E: "L2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L2"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L2" >on:3 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$59" on: 3 isValueObj: false 
 -- origin: isEmpty origin:isValueObj: false 
 rpushg $59$59 1
 -- items:goOrigin:encOG: "isEmpty" on: 2 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$58 1
 -- items:goOrigin:encOG: "matchEq" on: 1 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg matchEq$57 1
 -- $ObjectInvocation_Unary:getAdr: "L2" >ATd.off:4:on:3:superAdj:0"L2: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- $var:getAdr: "L2: var integer" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F orig ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L2: var integer" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- E.on: 3 
 -- beforeIsValueObj:E: "L2"  ATd: "L2: var integer" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- computeAdr:isLast:E:  "L2" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- rec:  "L2" E:  "L2" 
 -- INV:gen:E.loadArgs "L2" 
 -- $ObjectInvocation_Unary:loadArgs: "L2" >staticOff:0 "L2: var integer" superAdj:0 
 -- $var:loadArgs: "L2: var integer" >E:"L2" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "L2" 
 -- {(ObjectInvocation_Unary; (name: "L2"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L2" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L2" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L2" >rec:"L2" ATd:"var" isValueObj E:"L2" E.ATd:"L2" unique:"False" 
 -- OI:invoke: "L2" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:B: "L2" E: "L2"  rec: "L2"  useRtnV: true "L2: var integer" 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- $var:invoke: "L2: var integer" E: "L2">newOff:4 useRTNv: "True" 
 -- DI:invoke: "L2: var integer" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- isCompositeValueObj: false E: "L2" "L2: var integer" true 
 -- E.ATd.isValueObj: false rec: "L2" 
 pushg 4 loop$53
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- 
 -- OI:invoke:C: L2 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- vEq: 
 -- end:loadArgs:NonVirt: "<= L2" 
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:after:E.loadArgs "L1 <= L2" 
 -- OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L1 <= L2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- $BinOp:invoke: "L1 <= L2"  
 -- BinaryExp:invoke: "L1" rec: "L1 <= L2" 
 -- M: "<= L2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- $ObjectInvocation_Binary:invoke: "<= L2" >rec:"L1" ATd:"pattern" E:"<= L2" E.ATd:"<=  " unique:"False" 
 -- OI:invoke: "<= L2" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- origin:isValueObj "Value" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:B: "<= L2" E: "<= L2"  rec: "L1"  useRtnV: true "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- OI:invoke:before:ATdx.invoke: pattern <=   
 -- $pattern:invoke: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean" E: "<= L2" useRTNv: "True"} 
 -- ptn:invoke: "<=  " E: "<= L2" ptnKind: 1 useRtnV: true 
 -- rec: "L1" "Invocation" OGx.label: "ObjectGenerator" OGx: integer 
 -- rec.ATd: "L1: var integer" 
 -- bobs: 1 OGx: integer 
 le
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<= L2":rec:L1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<= L2":rec:L1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: <= L2 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "Beq" dstE: "Beq" dstE.ATd: "out Beq: var boolean" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- ... 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right: "L1 <= L2" 
 -- isArgOfAssignI2IwithUniValArg "Beq := L1 <= L2" arg: "L1 <= L2" ObjectGenerator 
 -- arg.super.arg: "L1 <= L2" BinOp 
 -- recx:BinaryExp:recx: "L1 <= L2" 
 -- M: "<= L2" label: "ObjectInvocation_Binary" M.ATd: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- checkInt2IntWithUnitArg:rec: "L1" E: "<= L2" 
 -- arg:other 
 -- M:arg: "L2" ObjectGenerator false 
 -- dstDI: "out Beq: var boolean" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg <=$52 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "leave(matchEq)" 
 -- $ObjectGenerator:gen: "leave(matchEq)" >OGid:"leave" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "leave(matchEq)" 
 -- OG:before:super.gen: "leave(matchEq)" 
 -- $Invocation:gen: "leave(matchEq)" >useRtnV:"False"superAdj: 0 descNo: 19 
 -- INV:gen: "leave(matchEq)" 
 -- isConstant: "Invocation" "leave(matchEq)" 
 -- needorigin: "leave(matchEq)" 
 -- needOrigin:E: "leave(matchEq)"  E.ATd: "leave(V: var integer): {   %basic 103}" 
 -- doNeedOrigin:Ex: "leave(matchEq)" 
 -- computeAdr:superAdj: 0 "leave(matchEq)" 
 -- computeAdr: 1 :rec: "none"  E: "leave(matchEq)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "leave(matchEq)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "leave(matchEq)" >on:7 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "leave(matchEq)" >ATd.off:0 (isPtn):on:7:superAdj:0"leave(V: var integer): {   %basic 103":Adr:off:0 size:0 isFloat:F isUnitVal:F superAd ...} 
 -- $pattern:getAdr: "leave(V: var integer): {   %basic 103" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- E.on: 7 
 -- beforeIsValueObj:E: "leave(matchEq)"  ATd: "leave(V: var integer): {   %basic 103}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- computeAdr:isLast:E:  "leave(matchEq)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- rec:  "leave(matchEq)" E:  "leave(matchEq)" 
 -- INV:gen:E.loadArgs "leave(matchEq)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "leave(matchEq)" >staticOff:0 "leave(V: var integer): {   %basic 103" superAdj:0arg:"matchEq"} 
 -- $pattern:loadArgs: "leave(V: var integer): {   %basic 103" >E:"leave(matchEq)":descNo:19} 
 -- INV:gen:after:E.loadArgs "leave(matchEq)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "leave(matchEq)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave( ..." 
 -- $ObjectInvocation_KeyWord:invoke: "leave(matchEq)" >rec:"leave(matchEq)" ATd:"pattern" E:"leave(matchEq)" E.ATd:"leave(V: var integer)" unique:"False" 
 -- OI:invoke: "leave(matchEq)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- OI:invoke:B: "leave(matchEq)" E: "leave(matchEq)"  rec: "leave(matchEq)"  useRtnV: false "leave(V: var integer): {   %basic 103}" 
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- $pattern:invoke: "leave(V: var integer): {   %basic 103" E: "leave(matchEq)" useRTNv: "False"} 
 -- ptn:invoke: "leave(V: var integer)" E: "leave(matchEq)" ptnKind: 0 useRtnV: false 
 break  2 2 57 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- 
 -- OI:invoke:C: leave(matchEq) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 60 
 -- Items:GenClass: $60 descNo: 60 isValue: false 
 -- Items:GenClass: $60 descNo: 21 isValue: false 

 CLASS $60 60 1 isEmpty 58
 -- Store itemArgs: Beq := false{leave(matchEq)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=60 vDescInx=60 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "Beq := false" 
 -- $Assign:gen: "Beq := false"  
 -- assign: "Beq := false" 
 -- computeAdr:superAdj: 0 "Beq" 
 -- computeAdr: 1 :rec: "none"  E: "Beq" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Beq"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Beq" >on:4 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$60" on: 4 isValueObj: false 
 -- origin: isEmpty origin:isValueObj: false 
 rpushg $60$60 1
 -- items:goOrigin:encOG: "isEmpty" on: 3 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$58 1
 -- items:goOrigin:encOG: "matchEq" on: 2 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg matchEq$57 1
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: <= origin:isValueObj: false 
 rpushg loop$53 1
 -- $ObjectInvocation_Unary:getAdr: "Beq" >ATd.off:3:on:4:superAdj:0"out Beq: var boolean":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ... 
 -- $var:getAdr: "out Beq: var boolean" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: boolean 
 -- before:floatTest:  "out Beq: var boolean" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "Beq"  ATd: "out Beq: var boolean" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- computeAdr:isLast:E:  "Beq" 
 -- AssignmentStatement:gen: "Beq := false" right.label: "ObjectGenerator" "false" 
 -- $ObjectGenerator:gen: "false" >OGid:"False" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "false" 
 -- OG:before:super.gen: "false" 
 -- $Invocation:gen: "false" >useRtnV:"True"superAdj: 0 descNo: 27 
 -- INV:gen: "false" 
 -- isConstant: "Invocation" "false" 
 -- needorigin: "false" 
 -- needOrigin:E: "false"  E.ATd: "False: {   %globals;   out B: var boolean;   B := 0}" 
 -- Ex:loadOrign:no:loadOrigin:  "%globals{   out B: var boolean;   B := 0}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "false" E:  "false" 
 -- INV:gen:E.loadArgs "false" 
 -- $ObjectInvocation_Unary:loadArgs: "false" >staticOff:0 "False: {   %globals;   out B: var boolean;   B := 0" superAdj:0} 
 -- $pattern:loadArgs: "False: {   %globals;   out B: var boolean;   B := 0" >E:"false":descNo:27} 
 -- ptn:loadArgs:E "false" 
 -- {(ObjectInvocation_Unary; (name: "false"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "false" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "false" 
 -- $ObjectInvocation_Unary:invoke: "false" >rec:"false" ATd:"pattern" E:"false" E.ATd:"False" unique:"False" 
 -- OI:invoke: "false" 
 -- 
 -- OI:invoke:B: "false" E: "false"  rec: "false"  useRtnV: true "False: {   %globals;   out B: var boolean;   B := 0}" 
 -- OI:invoke:before:ATdx.invoke: pattern False 
 -- $pattern:invoke: "False: {   %globals;   out B: var boolean;   B := 0" E: "false" useRTNv: "True"} 
 -- ptn:invoke: "False" E: "false" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke False 27 0 0
 -- global:pushOut: B off: 1 
 pushg 1 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 1 
 -- GeneralPTN:invoke:after:callInvoke: 1 
 -- OI:invoke:V: adrx: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: false :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "Beq" dstE: "Beq" dstE.ATd: "out Beq: var boolean" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- ... 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right: "false" 
 -- isArgOfAssignI2IwithUniValArg "Beq := false" arg: "false" ObjectGenerator 
 -- arg.super.arg: "false" ObjectInvocation_Unary 
 -- dstDI: "out Beq: var boolean" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg <=$52 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "leave(matchEq)" 
 -- $ObjectGenerator:gen: "leave(matchEq)" >OGid:"leave" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "leave(matchEq)" 
 -- OG:before:super.gen: "leave(matchEq)" 
 -- $Invocation:gen: "leave(matchEq)" >useRtnV:"False"superAdj: 0 descNo: 19 
 -- INV:gen: "leave(matchEq)" 
 -- isConstant: "Invocation" "leave(matchEq)" 
 -- needorigin: "leave(matchEq)" 
 -- needOrigin:E: "leave(matchEq)"  E.ATd: "leave(V: var integer): {   %basic 103}" 
 -- doNeedOrigin:Ex: "leave(matchEq)" 
 -- computeAdr:superAdj: 0 "leave(matchEq)" 
 -- computeAdr: 1 :rec: "none"  E: "leave(matchEq)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "leave(matchEq)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "leave(matchEq)" >on:7 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "leave(matchEq)" >ATd.off:0 (isPtn):on:7:superAdj:0"leave(V: var integer): {   %basic 103":Adr:off:0 size:0 isFloat:F isUnitVal:F superAd ...} 
 -- $pattern:getAdr: "leave(V: var integer): {   %basic 103" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- E.on: 7 
 -- beforeIsValueObj:E: "leave(matchEq)"  ATd: "leave(V: var integer): {   %basic 103}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- computeAdr:isLast:E:  "leave(matchEq)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- rec:  "leave(matchEq)" E:  "leave(matchEq)" 
 -- INV:gen:E.loadArgs "leave(matchEq)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "leave(matchEq)" >staticOff:0 "leave(V: var integer): {   %basic 103" superAdj:0arg:"matchEq"} 
 -- $pattern:loadArgs: "leave(V: var integer): {   %basic 103" >E:"leave(matchEq)":descNo:19} 
 -- INV:gen:after:E.loadArgs "leave(matchEq)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "leave(matchEq)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave( ..." 
 -- $ObjectInvocation_KeyWord:invoke: "leave(matchEq)" >rec:"leave(matchEq)" ATd:"pattern" E:"leave(matchEq)" E.ATd:"leave(V: var integer)" unique:"False" 
 -- OI:invoke: "leave(matchEq)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- OI:invoke:B: "leave(matchEq)" E: "leave(matchEq)"  rec: "leave(matchEq)"  useRtnV: false "leave(V: var integer): {   %basic 103}" 
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- $pattern:invoke: "leave(V: var integer): {   %basic 103" E: "leave(matchEq)" useRTNv: "False"} 
 -- ptn:invoke: "leave(V: var integer)" E: "leave(matchEq)" ptnKind: 0 useRtnV: false 
 break  2 2 57 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- 
 -- OI:invoke:C: leave(matchEq) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 61 
 -- Items:GenClass: loop descNo: 61 isValue: false 
 -- Items:GenClass: loop descNo: 21 isValue: false 

 CLASS loop 61 1 matchEq 57
 -- Store itemArgs: inx := inx + 1{c1 := get[inx];c2 := Veq.get[inx];if (c1 = c2) :then ;   if (inx < L) :then ;      restart(loop)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=61 vDescInx=61 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "inx := inx + 1" 
 -- $Assign:gen: "inx := inx + 1"  
 -- assign: "inx := inx + 1" 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg loop$61 1
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:2:on:1:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- AssignmentStatement:gen: "inx := inx + 1" right.label: "ObjectGenerator" "inx + 1" 
 -- $ObjectGenerator:gen: "inx + 1" >OGid:"+" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inx + 1" 
 -- OG:before:super.gen: "inx + 1" 
 -- $Invocation:gen: "inx + 1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "inx + 1" 
 -- isConstant: "Invocation" "inx + 1" 
 -- needorigin: "inx + 1" 
 -- needOrigin:E: "inx + 1"  E.ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- doNeedOrigin:Ex: "inx + 1" 
 -- computeAdr:superAdj: 0 "inx + 1" 
 -- computeAdr: 1 :rec: "none"  E: "inx + 1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "inx + 1"  
 -- $BinOp:loadOrigin: "inx + 1"  
 -- BinaryExp:loadOrigin:empty: "inx + 1" superAdj: 0 
 -- $BinOp:getAdr: "inx + 1"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx + 1"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "inx + 1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "inx + 1" E:  "inx + 1" 
 -- INV:gen:E.loadArgs "inx + 1" 
 -- $BinOp:loadArgs: "inx + 1"  
 -- BinaryExp:loadArgs: "inx + 1" superAdj: 0 
 -- $Invocation:gen: "inx" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "inx" 
 -- isConstant: "Invocation" "inx" 
 -- notConst: inx inx: var integer 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg loop$61 1
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:2:on:1:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- $ObjectInvocation_Unary:loadArgs: "inx" >staticOff:0 "inx: var integer" superAdj:0 
 -- $var:loadArgs: "inx: var integer" >E:"inx" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "inx" 
 -- {(ObjectInvocation_Unary; (name: "inx"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: "inx" >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:"inx" unique:"False" 
 -- OI:invoke: "inx" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx" E: "inx"  rec: "inx"  useRtnV: true "inx: var integer" 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: "inx: var integer" E: "inx">newOff:2 useRTNv: "True" 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- isCompositeValueObj: false E: "inx" "inx: var integer" true 
 -- E.ATd.isValueObj: false rec: "inx" 
 pushg 2 matchEq$57
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:C: inx :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- left:#I "inx + 1" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- $pattern:loadArgs: "+  : {   %basic 61;   in V: var integer;   out R: var integer" >E:"+ 1":descNo:49} 
 -- ptn:loadArgs:E "+ 1" 
 -- {(ObjectInvocation_Binary; (name: "+"); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 1));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "1" 
 -- E: "ObjectGenerator" 1 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "+ 1" "ObjectInvocation_Binary" ActArg:  "1" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ 1"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "1" :isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "+ 1" 
 -- BinaryExp:loadArgs:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:after:E.loadArgs "inx + 1" 
 -- OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- IV:E.invoke:useRtnVal: true E: BinOp "inx + 1" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- $BinOp:invoke: "inx + 1"  
 -- BinaryExp:invoke: "inx" rec: "inx + 1" 
 -- M: "+ 1" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- $ObjectInvocation_Binary:invoke: "+ 1" >rec:"inx" ATd:"pattern" E:"+ 1" E.ATd:"+  " unique:"False" 
 -- OI:invoke: "+ 1" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- origin:isValueObj "integer" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "+ 1" E: "+ 1"  rec: "inx"  useRtnV: true "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- $pattern:invoke: "+  : {   %basic 61;   in V: var integer;   out R: var integer" E: "+ 1" useRTNv: "True"} 
 -- ptn:invoke: "+  " E: "+ 1" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "inx" E: "+ 1" 
 -- arg:integer 
 plus
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:inx 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:inx 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: + 1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "inx" dstE: "inx" dstE.ATd: "inx: var integer" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "inx + 1" 
 -- isArgOfAssignI2IwithUniValArg "inx := inx + 1" arg: "inx + 1" ObjectGenerator 
 -- arg.super.arg: "inx + 1" BinOp 
 -- recx:BinaryExp:recx: "inx + 1" 
 -- M: "+ 1" label: "ObjectInvocation_Binary" M.ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- checkInt2IntWithUnitArg:rec: "inx" E: "+ 1" 
 -- arg:integer 
 -- M:arg: "1" ObjectGenerator false 
 -- dstDI: "inx: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg matchEq$57 2
 -- assign:adr.store:B: 
 -- genclass:stmt: "c1 := get[inx]" 
 -- $Assign:gen: "c1 := get[inx]"  
 -- assign: "c1 := get[inx]" 
 -- computeAdr:superAdj: 0 "c1" 
 -- computeAdr: 1 :rec: "none"  E: "c1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "c1"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "c1" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg loop$61 1
 -- $ObjectInvocation_Unary:getAdr: "c1" >ATd.off:3:on:1:superAdj:0"c1: var char":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"non ..." 
 -- $var:getAdr: "c1: var char" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- DI:OG: char 
 -- before:floatTest:  "c1: var char" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "c1"  ATd: "c1: var char" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- computeAdr:isLast:E:  "c1" 
 -- AssignmentStatement:gen: "c1 := get[inx]" right.label: "ObjectGenerator" "get[inx]" 
 -- $ObjectGenerator:gen: "get[inx]" >OGid:"get" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "get[inx]" 
 -- OG:before:super.gen: "get[inx]" 
 -- $Invocation:gen: "get[inx]" >useRtnV:"True"superAdj: 0 descNo: 16 
 -- INV:gen: "get[inx]" 
 -- isConstant: "Invocation" "get[inx]" 
 -- needorigin: "get[inx]" 
 -- needOrigin:E: "get[inx]"  E.ATd: "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- doNeedOrigin:Ex: "get[inx]" 
 -- computeAdr:superAdj: 0 "get[inx]" 
 -- computeAdr: 1 :rec: "none"  E: "get[inx]" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "get[inx]"  
 pushThis 
 -- $ObjectInvocation_KeyWord:loadOrigin: "get[inx]" >on:4 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 4 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg loop$61 1
 -- items:goOrigin:encOG: "matchEq" on: 3 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg matchEq$57 1
 -- items:goOrigin:encOG: "loop" on: 2 isValueObj: false 
 -- origin: <= origin:isValueObj: false 
 rpushg loop$53 1
 -- items:goOrigin:encOG: "<=" on: 1 isValueObj: false 
 -- origin: String origin:isValueObj: false 
 rpushg <=$52 1
 -- $ObjectInvocation_KeyWord:getAdr: "get[inx]" >ATd.off:0 (isPtn):on:4:superAdj:0"get[inx: var integer]: {   %basic 117;   out ch: var char":Adr:off:0 size:0 isFloat:F isUni ...} 
 -- $pattern:getAdr: "get[inx: var integer]: {   %basic 117;   out ch: var char" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "get[inx]"  ATd: "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- computeAdr:isLast:E:  "get[inx]" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- rec:  "get[inx]" E:  "get[inx]" 
 -- INV:gen:E.loadArgs "get[inx]" 
 -- $ObjectInvocation_KeyWord:loadArgs: "get[inx]" >staticOff:0 "get[inx: var integer]: {   %basic 117;   out ch: var char" superAdj:0arg:"inx"} 
 -- $pattern:loadArgs: "get[inx: var integer]: {   %basic 117;   out ch: var char" >E:"get[inx]":descNo:16} 
 -- ptn:loadArgs:E "get[inx]" 
 -- {(ObjectInvocation_KeyWord; (name: "get"); (Arguments;  (name: "get");  (name: "[");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "inx");     ( ...} 
 -- args: "get[inx]" 
 -- E: "ObjectGenerator" inx 
 -- E.arg: "var" inx: var integer 
 -- NonVirt: "get[inx]" "ObjectInvocation_KeyWord" ActArg:  "inx" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx]"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "inx" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inx" 
 -- OG:before:super.gen: "inx" 
 -- $Invocation:gen: "inx" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "inx" 
 -- isConstant: "Invocation" "inx" 
 -- notConst: inx inx: var integer 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg loop$61 1
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:2:on:1:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- $ObjectInvocation_Unary:loadArgs: "inx" >staticOff:0 "inx: var integer" superAdj:0 
 -- $var:loadArgs: "inx: var integer" >E:"inx" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "inx" 
 -- {(ObjectInvocation_Unary; (name: "inx"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: "inx" >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:"inx" unique:"False" 
 -- OI:invoke: "inx" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx" E: "inx"  rec: "inx"  useRtnV: true "inx: var integer" 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: "inx: var integer" E: "inx">newOff:2 useRTNv: "True" 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- isCompositeValueObj: false E: "inx" "inx: var integer" true 
 -- E.ATd.isValueObj: false rec: "inx" 
 pushg 2 matchEq$57
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:C: inx :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- formalArg:isPtn: "inx: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "inx" :isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "get[inx]" 
 -- INV:gen:after:E.loadArgs "get[inx]" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx]" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec ... 
 -- $ObjectInvocation_KeyWord:invoke: "get[inx]" >rec:"get[inx]" ATd:"pattern" E:"get[inx]" E.ATd:"get[inx: var integer]" unique:"False" 
 -- OI:invoke: "get[inx]" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- OI:invoke:B: "get[inx]" E: "get[inx]"  rec: "get[inx]"  useRtnV: true "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- $pattern:invoke: "get[inx: var integer]: {   %basic 117;   out ch: var char" E: "get[inx]" useRTNv: "True"} 
 -- ptn:invoke: "get[inx: var integer]" E: "get[inx]" ptnKind: 0 useRtnV: true 
 xpushg  inx 1 0 1
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- stack: vpop : vTop: 1 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- 
 -- OI:invoke:C: get[inx] :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- rec: "c1" dstE: "c1" dstE.ATd: "c1: var char" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right: "get[inx]" 
 -- isArgOfAssignI2IwithUniValArg "c1 := get[inx]" arg: "get[inx]" ObjectGenerator 
 -- arg.super.arg: "get[inx]" ObjectInvocation_KeyWord 
 -- dstDI: "c1: var char" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg matchEq$57 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "c2 := Veq.get[inx]" 
 -- $Assign:gen: "c2 := Veq.get[inx]"  
 -- assign: "c2 := Veq.get[inx]" 
 -- computeAdr:superAdj: 0 "c2" 
 -- computeAdr: 1 :rec: "none"  E: "c2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "c2"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "c2" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg loop$61 1
 -- $ObjectInvocation_Unary:getAdr: "c2" >ATd.off:4:on:1:superAdj:0"c2: var char":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"non ..." 
 -- $var:getAdr: "c2: var char" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- DI:OG: char 
 -- before:floatTest:  "c2: var char" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "c2"  ATd: "c2: var char" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- computeAdr:isLast:E:  "c2" 
 -- AssignmentStatement:gen: "c2 := Veq.get[inx]" right.label: "ObjectGenerator" "Veq.get[inx]" 
 -- $ObjectGenerator:gen: "Veq.get[inx]" >OGid:"get" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "Veq.get[inx]" 
 -- OG:before:super.gen: "Veq.get[inx]" 
 -- $Invocation:gen: "Veq.get[inx]" >useRtnV:"True"superAdj: 0 descNo: 16 
 -- INV:gen: "Veq.get[inx]" 
 -- isConstant: "Invocation" "Veq.get[inx]" 
 -- notConst: Veq in Veq: var this(Value) 
 -- needorigin: "Veq.get[inx]" 
 -- needOrigin:E: "get[inx]"  E.ATd: "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- doNeedOrigin:Ex: "get[inx]" 
 -- computeAdr:superAdj: 0 "Veq.get[inx]" 
 -- computeAdr: 1 :rec: "none"  E: "Veq" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Veq"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Veq" >on:3 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 3 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg loop$61 1
 -- items:goOrigin:encOG: "matchEq" on: 2 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg matchEq$57 1
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: <= origin:isValueObj: false 
 rpushg loop$53 1
 -- $ObjectInvocation_Unary:getAdr: "Veq" >ATd.off:2:on:3:superAdj:0"in Veq: var this(Value)":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVa ... 
 -- PING:String 0 inx := inx + 1{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 = c2) :then ;      if (inx < L) :then ;         restart(loop)} 
 -- BOBS:ATd: "in Veq: var this(Value)" 
 -- String:vEq:  "Veq" off:  2 ATd: "in Veq: var this(Value)" 
 -- E.on: 3 
 -- beforeIsValueObj:E: "Veq"  ATd: "in Veq: var this(Value)" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "Veq"  E: "get[inx]" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:getAdr: "get[inx]" >ATd.off:0 (isPtn):on:0:superAdj:0"get[inx: var integer]: {   %basic 117;   out ch: var char":Adr:off:2 size:0 isFloat:F isUni ...} 
 -- $pattern:getAdr: "get[inx: var integer]: {   %basic 117;   out ch: var char" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "Veq" >staticOff:0 "in Veq: var this(Value)" superAdj:0 
 -- $var:loadArgs: "in Veq: var this(Value)" >E:"Veq" 
 -- $pattern:loadArgs: "this: {   %basic 18;   in this: ref Object" >E:"Veq":descNo:31} 
 -- $ObjectInvocation_Unary:invoke: "Veq" >rec:"Veq" ATd:"var" isValueObj E:"get[inx]" E.ATd:"get[inx: var integer]" unique:"False" 
 -- OI:invoke: "Veq" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- OI:invoke:B: "Veq" E: "get[inx]"  rec: "Veq"  useRtnV: true "in Veq: var this(Value)" 
 -- OI:invoke:before:ATdx.invoke: var Veq 
 -- $var:invoke: "in Veq: var this(Value)" E: "get[inx]">newOff:2 useRTNv: "True" 
 -- DI:invoke: "in Veq: var this(Value)" 
 -- isValueObj:isAdr: true objSize: 2  rec "Veq" ,E: "get[inx]" "ObjectInvocation_KeyWord" E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 rpushg loop$61 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- 
 -- OI:invoke:C: Veq :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "Veq" E: "get[inx]" 
 -- arg:other 
 -- computeAdr:isLast:E:  "get[inx]" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- rec:  "Veq" E:  "get[inx]" 
 -- INV:gen:E.loadArgs "get[inx]" 
 -- $ObjectInvocation_KeyWord:loadArgs: "get[inx]" >staticOff:0 "get[inx: var integer]: {   %basic 117;   out ch: var char" superAdj:0arg:"inx"} 
 -- $pattern:loadArgs: "get[inx: var integer]: {   %basic 117;   out ch: var char" >E:"get[inx]":descNo:16} 
 -- ptn:loadArgs:E "get[inx]" 
 -- {(ObjectInvocation_KeyWord; (name: "get"); (Arguments;  (name: "get");  (name: "[");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "inx");     ( ...} 
 -- args: "get[inx]" 
 -- E: "ObjectGenerator" inx 
 -- E.arg: "var" inx: var integer 
 -- NonVirt: "get[inx]" "ObjectInvocation_KeyWord" ActArg:  "inx" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx]"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "inx" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inx" 
 -- OG:before:super.gen: "inx" 
 -- $Invocation:gen: "inx" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "inx" 
 -- isConstant: "Invocation" "inx" 
 -- notConst: inx inx: var integer 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg loop$61 1
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:2:on:1:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- $ObjectInvocation_Unary:loadArgs: "inx" >staticOff:0 "inx: var integer" superAdj:0 
 -- $var:loadArgs: "inx: var integer" >E:"inx" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "inx" 
 -- {(ObjectInvocation_Unary; (name: "inx"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: "inx" >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:"inx" unique:"False" 
 -- OI:invoke: "inx" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx" E: "inx"  rec: "inx"  useRtnV: true "inx: var integer" 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: "inx: var integer" E: "inx">newOff:2 useRTNv: "True" 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- isCompositeValueObj: false E: "inx" "inx: var integer" true 
 -- E.ATd.isValueObj: false rec: "inx" 
 pushg 2 matchEq$57
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -4 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 3 vTopMax: 3 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:C: inx :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- formalArg:isPtn: "inx: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "inx" :isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "get[inx]" 
 -- INV:gen:after:E.loadArgs "get[inx]" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx]" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec ... 
 -- $ObjectInvocation_KeyWord:invoke: "get[inx]" >rec:"Veq" ATd:"pattern" E:"get[inx]" E.ATd:"get[inx: var integer]" unique:"False" 
 -- OI:invoke: "get[inx]" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- OI:invoke:B: "get[inx]" E: "get[inx]"  rec: "Veq"  useRtnV: true "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- $pattern:invoke: "get[inx: var integer]: {   %basic 117;   out ch: var char" E: "get[inx]" useRTNv: "True"} 
 -- ptn:invoke: "get[inx: var integer]" E: "get[inx]" ptnKind: 0 useRtnV: true 
 xpushg  inx 1 0 1
 -- stack: rpop : vTop: 3 vTopMax: 3 rTop: -5 rTopMax: 0 V: 0 R: 
 -- stack: vpop : vTop: 2 vTopMax: 3 rTop: -5 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 3 vTopMax: 3 rTop: -5 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- 
 -- OI:invoke:C: get[inx] :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- rec: "c2" dstE: "c2" dstE.ATd: "c2: var char" useRtn: false :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right: "Veq.get[inx]" 
 -- isArgOfAssignI2IwithUniValArg "c2 := Veq.get[inx]" arg: "Veq.get[inx]" ObjectGenerator 
 -- arg.super.arg: "Veq" ObjectInvocation_Unary 
 -- arg.super.arg: "get[inx]" ObjectInvocation_KeyWord 
 -- recx: "Veq" argx: "get[inx]" 
 -- checkInt2IntWithUnitArg:rec: "Veq" E: "get[inx]" 
 -- arg:other 
 -- dstDI: "c2: var char" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg matchEq$57 4
 -- assign:adr.store:B: 
 -- genclass:stmt: "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- $ObjectGenerator:gen: "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)" >OGid:"if:then$0" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- OG:before:super.gen: "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- $Invocation:gen: "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)" >useRtnV:"False"superAdj: 0} 
 -- INV:gen: "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- isConstant: "Invocation" "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- needorigin: "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- needOrigin:E: "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}"  E.ATd: "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;    ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" E:  "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- INV:gen:E.loadArgs "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- $IfThen:loadArgs: "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)" } 
 -- INV:gen:after:E.loadArgs "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- $IfThen:invoke: "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)" } 
 -- $IfThen:gen: "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)" } 
 -- $ObjectGenerator:gen: "(c1 = c2)" >OGid:"=" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(c1 = c2)" 
 -- OG:before:super.gen: "(c1 = c2)" 
 -- $Invocation:gen: "(c1 = c2)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(c1 = c2)" 
 -- isConstant: "Invocation" "(c1 = c2)" 
 -- needorigin: "(c1 = c2)" 
 -- needOrigin:E: "(c1 = c2)"  E.ATd: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- doNeedOrigin:Ex: "(c1 = c2)" 
 -- computeAdr:superAdj: 0 "(c1 = c2)" 
 -- computeAdr: 1 :rec: "none"  E: "(c1 = c2)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(c1 = c2)"  
 -- $BracketedExp:loadOrigin: "(c1 = c2)"  
 -- computeAdr:superAdj: 0 "c1 = c2" 
 -- computeAdr: 1 :rec: "none"  E: "c1 = c2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "c1 = c2"  
 -- $BinOp:loadOrigin: "c1 = c2"  
 -- BinaryExp:loadOrigin:empty: "c1 = c2" superAdj: 0 
 -- $BinOp:getAdr: "c1 = c2"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "c1 = c2"  ATd: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "c1 = c2" 
 -- BE:loadOrigin:E: c1 = c2 
 -- $BinOp:getAdr: "c1 = c2"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "c1 = c2"  ATd: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "c1 = c2" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "c1 = c2" E:  "c1 = c2" 
 -- INV:gen:E.loadArgs "c1 = c2" 
 -- $BinOp:loadArgs: "c1 = c2"  
 -- BinaryExp:loadArgs: "c1 = c2" superAdj: 0 
 -- $Invocation:gen: "c1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "c1" 
 -- isConstant: "Invocation" "c1" 
 -- notConst: c1 c1: var char 
 -- needorigin: "c1" 
 -- needOrigin:E: "c1"  E.ATd: "c1: var char" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "c1" 
 -- computeAdr: 1 :rec: "none"  E: "c1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "c1"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "c1" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg loop$61 1
 -- $ObjectInvocation_Unary:getAdr: "c1" >ATd.off:3:on:1:superAdj:0"c1: var char":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"non ..." 
 -- $var:getAdr: "c1: var char" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- DI:OG: char 
 -- before:floatTest:  "c1: var char" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "c1"  ATd: "c1: var char" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- computeAdr:isLast:E:  "c1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- rec:  "c1" E:  "c1" 
 -- INV:gen:E.loadArgs "c1" 
 -- $ObjectInvocation_Unary:loadArgs: "c1" >staticOff:0 "c1: var char" superAdj:0 
 -- $var:loadArgs: "c1: var char" >E:"c1" 
 -- $pattern:loadArgs: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;       ..."} 
 -- ptn:loadArgs:E "c1" 
 -- {(ObjectInvocation_Unary; (name: "c1"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "c1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- $ObjectInvocation_Unary:invoke: "c1" >rec:"c1" ATd:"var" isValueObj E:"c1" E.ATd:"c1" unique:"False" 
 -- OI:invoke: "c1" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:B: "c1" E: "c1"  rec: "c1"  useRtnV: true "c1: var char" 
 -- OI:invoke:before:ATdx.invoke: var c1 
 -- $var:invoke: "c1: var char" E: "c1">newOff:3 useRTNv: "True" 
 -- DI:invoke: "c1: var char" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- isCompositeValueObj: false E: "c1" "c1: var char" true 
 -- E.ATd.isValueObj: false rec: "c1" 
 pushg 3 matchEq$57
 -- stack: rpop : vTop: 3 vTopMax: 3 rTop: -6 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 4 vTopMax: 4 rTop: -6 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- 
 -- OI:invoke:C: c1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- $pattern:loadArgs: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )" >E:"= c2":descNo:11} 
 -- ptn:loadArgs:E "= c2" 
 -- {(ObjectInvocation_Binary; (name: "="); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "c2");     (Arguments)));   (Items descNo: 0 o ...} 
 -- args: "c2" 
 -- E: "ObjectGenerator" c2 
 -- E.arg: "var" in Veq: var this(Value) 
 -- NonVirt: "= c2" "ObjectInvocation_Binary" ActArg:  "c2" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "= c2"  isCompositeValueObj: true 
 -- $ObjectGenerator:gen: "c2" >OGid:"char" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "c2" 
 -- OG:before:super.gen: "c2" 
 -- $Invocation:gen: "c2" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "c2" 
 -- isConstant: "Invocation" "c2" 
 -- notConst: c2 c2: var char 
 -- needorigin: "c2" 
 -- needOrigin:E: "c2"  E.ATd: "c2: var char" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "c2" 
 -- computeAdr: 1 :rec: "none"  E: "c2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "c2"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "c2" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg loop$61 1
 -- $ObjectInvocation_Unary:getAdr: "c2" >ATd.off:4:on:1:superAdj:0"c2: var char":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"non ..." 
 -- $var:getAdr: "c2: var char" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- DI:OG: char 
 -- before:floatTest:  "c2: var char" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "c2"  ATd: "c2: var char" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- computeAdr:isLast:E:  "c2" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- rec:  "c2" E:  "c2" 
 -- INV:gen:E.loadArgs "c2" 
 -- $ObjectInvocation_Unary:loadArgs: "c2" >staticOff:0 "c2: var char" superAdj:0 
 -- $var:loadArgs: "c2: var char" >E:"c2" 
 -- $pattern:loadArgs: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;       ..."} 
 -- ptn:loadArgs:E "c2" 
 -- {(ObjectInvocation_Unary; (name: "c2"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "c2" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c2" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- $ObjectInvocation_Unary:invoke: "c2" >rec:"c2" ATd:"var" isValueObj E:"c2" E.ATd:"c2" unique:"False" 
 -- OI:invoke: "c2" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- OI:invoke:B: "c2" E: "c2"  rec: "c2"  useRtnV: true "c2: var char" 
 -- OI:invoke:before:ATdx.invoke: var c2 
 -- $var:invoke: "c2: var char" E: "c2">newOff:4 useRTNv: "True" 
 -- DI:invoke: "c2: var char" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- isCompositeValueObj: false E: "c2" "c2: var char" true 
 -- E.ATd.isValueObj: false rec: "c2" 
 pushg 4 matchEq$57
 -- stack: rpop : vTop: 4 vTopMax: 4 rTop: -7 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 5 vTopMax: 5 rTop: -7 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- 
 -- OI:invoke:C: c2 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- vEq: 
 -- end:loadArgs:NonVirt: "= c2" 
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:after:E.loadArgs "c1 = c2" 
 -- OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "c1 = c2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- $BinOp:invoke: "c1 = c2"  
 -- BinaryExp:invoke: "c1" rec: "c1 = c2" 
 -- M: "= c2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- $ObjectInvocation_Binary:invoke: "= c2" >rec:"c1" ATd:"pattern" E:"= c2" E.ATd:"=  " unique:"False" 
 -- OI:invoke: "= c2" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- origin:isValueObj "Value" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:B: "= c2" E: "= c2"  rec: "c1"  useRtnV: true "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OI:invoke:before:ATdx.invoke: pattern =   
 -- $pattern:invoke: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )" E: "= c2" useRTNv: "True"} 
 -- ptn:invoke: "=  " E: "= c2" ptnKind: 1 useRtnV: true 
 -- rec: "c1" "Invocation" OGx.label: "ObjectGenerator" OGx: char 
 -- rec.ATd: "c1: var char" 
 -- bobs: 3 OGx: char 
 eq
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= c2":rec:c1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= c2":rec:c1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: = c2 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: "if (inx < L) :then {      restart(loop)" >OGid:"$62" singular! staticOff=0 descNo=62 superAdj=0} 
 -- OG:gen: "if (inx < L) :then {      restart(loop)}" 
 pushThis 
 -- before objTmpStack:add:  62   "$62" 
 invoke $62 62 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 5 vTopMax: 5 rTop: -8 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 -- pushReturn:  "loop" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 62 
 -- Items:GenClass: $62 descNo: 62 isValue: false 
 -- Items:GenClass: $62 descNo: 21 isValue: false 

 CLASS $62 62 1 loop 61
 -- Store itemArgs: if (inx < L) :then {   restart(loop)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=62 vDescInx=62 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "if (inx < L) :then {   restart(loop)}" 
 -- $ObjectGenerator:gen: "if (inx < L) :then {   restart(loop)" >OGid:"if:then$0" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "if (inx < L) :then {   restart(loop)}" 
 -- OG:before:super.gen: "if (inx < L) :then {   restart(loop)}" 
 -- $Invocation:gen: "if (inx < L) :then {   restart(loop)" >useRtnV:"False"superAdj: 0} 
 -- INV:gen: "if (inx < L) :then {   restart(loop)}" 
 -- isConstant: "Invocation" "if (inx < L) :then {   restart(loop)}" 
 -- needorigin: "if (inx < L) :then {   restart(loop)}" 
 -- needOrigin:E: "if (inx < L) :then {   restart(loop)}"  E.ATd: "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inS ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (inx < L) :then {   restart(loop)}" E:  "if (inx < L) :then {   restart(loop)}" 
 -- INV:gen:E.loadArgs "if (inx < L) :then {   restart(loop)}" 
 -- $IfThen:loadArgs: "if (inx < L) :then {   restart(loop)" } 
 -- INV:gen:after:E.loadArgs "if (inx < L) :then {   restart(loop)}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (inx < L) :then {   restart(loop)}" 
 -- $IfThen:invoke: "if (inx < L) :then {   restart(loop)" } 
 -- $IfThen:gen: "if (inx < L) :then {   restart(loop)" } 
 -- $ObjectGenerator:gen: "(inx < L)" >OGid:"<" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(inx < L)" 
 -- OG:before:super.gen: "(inx < L)" 
 -- $Invocation:gen: "(inx < L)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(inx < L)" 
 -- isConstant: "Invocation" "(inx < L)" 
 -- needorigin: "(inx < L)" 
 -- needOrigin:E: "(inx < L)"  E.ATd: "<  : {   %basic 51;   in V: var integer;   out B: var boolean}" 
 -- doNeedOrigin:Ex: "(inx < L)" 
 -- computeAdr:superAdj: 0 "(inx < L)" 
 -- computeAdr: 1 :rec: "none"  E: "(inx < L)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(inx < L)"  
 -- $BracketedExp:loadOrigin: "(inx < L)"  
 -- computeAdr:superAdj: 0 "inx < L" 
 -- computeAdr: 1 :rec: "none"  E: "inx < L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "inx < L"  
 -- $BinOp:loadOrigin: "inx < L"  
 -- BinaryExp:loadOrigin:empty: "inx < L" superAdj: 0 
 -- $BinOp:getAdr: "inx < L"  
 -- E.on: 2 
 -- beforeIsValueObj:E: "inx < L"  ATd: "<  : {   %basic 51;   in V: var integer;   out B: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "inx < L" 
 -- BE:loadOrigin:E: inx < L 
 -- $BinOp:getAdr: "inx < L"  
 -- E.on: 2 
 -- beforeIsValueObj:E: "inx < L"  ATd: "<  : {   %basic 51;   in V: var integer;   out B: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "inx < L" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "inx < L" E:  "inx < L" 
 -- INV:gen:E.loadArgs "inx < L" 
 -- $BinOp:loadArgs: "inx < L"  
 -- BinaryExp:loadArgs: "inx < L" superAdj: 0 
 -- $Invocation:gen: "inx" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "inx" 
 -- isConstant: "Invocation" "inx" 
 -- notConst: inx inx: var integer 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$62" on: 2 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg $62$62 1
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg loop$61 1
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:2:on:2:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- $ObjectInvocation_Unary:loadArgs: "inx" >staticOff:0 "inx: var integer" superAdj:0 
 -- $var:loadArgs: "inx: var integer" >E:"inx" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "inx" 
 -- {(ObjectInvocation_Unary; (name: "inx"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: "inx" >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:"inx" unique:"False" 
 -- OI:invoke: "inx" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx" E: "inx"  rec: "inx"  useRtnV: true "inx: var integer" 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: "inx: var integer" E: "inx">newOff:2 useRTNv: "True" 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- isCompositeValueObj: false E: "inx" "inx: var integer" true 
 -- E.ATd.isValueObj: false rec: "inx" 
 pushg 2 matchEq$57
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:C: inx :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- left:#I "inx < L" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- $pattern:loadArgs: "<  : {   %basic 51;   in V: var integer;   out B: var boolean" >E:"< L":descNo:54} 
 -- ptn:loadArgs:E "< L" 
 -- {(ObjectInvocation_Binary; (name: "<"); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "L");     (Arguments)));   (Items descNo: 0 or ...} 
 -- args: "L" 
 -- E: "ObjectGenerator" L 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "< L" "ObjectInvocation_Binary" ActArg:  "L" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "< L"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "L" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L" 
 -- OG:before:super.gen: "L" 
 -- $Invocation:gen: "L" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L" 
 -- isConstant: "Invocation" "L" 
 -- notConst: L L: var integer 
 -- needorigin: "L" 
 -- needOrigin:E: "L"  E.ATd: "L: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L" 
 -- computeAdr: 1 :rec: "none"  E: "L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L" >on:3 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$62" on: 3 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg $62$62 1
 -- items:goOrigin:encOG: "loop" on: 2 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg loop$61 1
 -- items:goOrigin:encOG: "matchEq" on: 1 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg matchEq$57 1
 -- $ObjectInvocation_Unary:getAdr: "L" >ATd.off:2:on:3:superAdj:0"L: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "L: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 3 
 -- beforeIsValueObj:E: "L"  ATd: "L: var integer" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdr:isLast:E:  "L" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- rec:  "L" E:  "L" 
 -- INV:gen:E.loadArgs "L" 
 -- $ObjectInvocation_Unary:loadArgs: "L" >staticOff:0 "L: var integer" superAdj:0 
 -- $var:loadArgs: "L: var integer" >E:"L" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "L" 
 -- {(ObjectInvocation_Unary; (name: "L"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L" >rec:"L" ATd:"var" isValueObj E:"L" E.ATd:"L" unique:"False" 
 -- OI:invoke: "L" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "L" E: "L"  rec: "L"  useRtnV: true "L: var integer" 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- $var:invoke: "L: var integer" E: "L">newOff:2 useRTNv: "True" 
 -- DI:invoke: "L: var integer" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- isCompositeValueObj: false E: "L" "L: var integer" true 
 -- E.ATd.isValueObj: false rec: "L" 
 pushg 2 loop$53
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- OI:invoke:C: L :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "L" :isBasicVal: true 
 -- case:B: L ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "< L" 
 -- BinaryExp:loadArgs:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:after:E.loadArgs "inx < L" 
 -- OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- IV:E.invoke:useRtnVal: true E: BinOp "inx < L" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- $BinOp:invoke: "inx < L"  
 -- BinaryExp:invoke: "inx" rec: "inx < L" 
 -- M: "< L" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- $ObjectInvocation_Binary:invoke: "< L" >rec:"inx" ATd:"pattern" E:"< L" E.ATd:"<  " unique:"False" 
 -- OI:invoke: "< L" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- origin:isValueObj "integer" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "< L" E: "< L"  rec: "inx"  useRtnV: true "<  : {   %basic 51;   in V: var integer;   out B: var boolean}" 
 -- OI:invoke:before:ATdx.invoke: pattern <   
 -- $pattern:invoke: "<  : {   %basic 51;   in V: var integer;   out B: var boolean" E: "< L" useRTNv: "True"} 
 -- ptn:invoke: "<  " E: "< L" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "inx" E: "< L" 
 -- arg:other 
 lt
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< L":rec:inx 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< L":rec:inx 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: < L :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: "restart(loop)" >OGid:"$63" singular! staticOff=0 descNo=63 superAdj=0 
 -- OG:gen: "restart(loop)" 
 pushThis 
 -- before objTmpStack:add:  63   "$63" 
 invoke $63 63 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 63 
 -- Items:GenClass: $63 descNo: 63 isValue: false 
 -- Items:GenClass: $63 descNo: 21 isValue: false 

 CLASS $63 63 1 $62 62
 -- Store itemArgs: restart(loop) 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=63 vDescInx=63 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "restart(loop)" 
 -- $ObjectGenerator:gen: "restart(loop)" >OGid:"restart" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "restart(loop)" 
 -- OG:before:super.gen: "restart(loop)" 
 -- $Invocation:gen: "restart(loop)" >useRtnV:"False"superAdj: 0 descNo: 50 
 -- INV:gen: "restart(loop)" 
 -- isConstant: "Invocation" "restart(loop)" 
 -- needorigin: "restart(loop)" 
 -- needOrigin:E: "restart(loop)"  E.ATd: "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- doNeedOrigin:Ex: "restart(loop)" 
 -- computeAdr:superAdj: 0 "restart(loop)" 
 -- computeAdr: 1 :rec: "none"  E: "restart(loop)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "restart(loop)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "restart(loop)" >on:8 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "restart(loop)" >ATd.off:0 (isPtn):on:8:superAdj:0"restart(V: var integer):  -- odd parameter type!{   %basic 102":Adr:off:0 size:0 isFlo ...} 
 -- $pattern:getAdr: "restart(V: var integer):  -- odd parameter type!{   %basic 102" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:- 
 -- E.on: 8 
 -- beforeIsValueObj:E: "restart(loop)"  ATd: "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:- 
 -- computeAdr:isLast:E:  "restart(loop)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:- 
 -- rec:  "restart(loop)" E:  "restart(loop)" 
 -- INV:gen:E.loadArgs "restart(loop)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "restart(loop)" >staticOff:0 "restart(V: var integer):  -- odd parameter type!{   %basic 102" superAdj:0arg:"loop"} 
 -- $pattern:loadArgs: "restart(V: var integer):  -- odd parameter type!{   %basic 102" >E:"restart(loop)":descNo:50} 
 -- INV:gen:after:E.loadArgs "restart(loop)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "restart(loop)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart ..." 
 -- $ObjectInvocation_KeyWord:invoke: "restart(loop)" >rec:"restart(loop)" ATd:"pattern" E:"restart(loop)" E.ATd:"restart(V: var integer)" unique:"False" 
 -- OI:invoke: "restart(loop)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- OI:invoke:B: "restart(loop)" E: "restart(loop)"  rec: "restart(loop)"  useRtnV: false "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- OI:invoke:before:ATdx.invoke: pattern restart(V: var integer) 
 -- $pattern:invoke: "restart(V: var integer):  -- odd parameter type!{   %basic 102" E: "restart(loop)" useRTNv: "False"} 
 -- ptn:invoke: "restart(V: var integer)" E: "restart(loop)" ptnKind: 0 useRtnV: false 
 break  2 1 61 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- 
 -- OI:invoke:C: restart(loop) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 64 
 -- Items:GenClass: doit descNo: 64 isValue: false 
 -- Items:GenClass: doit descNo: 21 isValue: false 

 CLASS doit 64 1 matchEq 57
 -- Store itemArgs: if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=64 vDescInx=64 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- $ObjectGenerator:gen: "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)" >OGid:"if:then$0" IS.isempty! ...} 
 -- OG:gen: "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- OG:before:super.gen: "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- $Invocation:gen: "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)" >useRtnV:"False"superAdj: 0} 
 -- INV:gen: "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- isConstant: "Invocation" "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- needorigin: "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- needOrigin:E: "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}"  E.ATd: "if(cond: var boolean):then{ ..." 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" E:  "if (c1 = c2) :then {   -- we have inx = ...}" 
 -- INV:gen:E.loadArgs "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- $IfThenElse:loadArgs: "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)" } 
 -- INV:gen:after:E.loadArgs "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThenElse "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- $IfThenElse:invoke: "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)" } 
 -- $IfThenElse:gen: "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)" } 
 -- $ObjectGenerator:gen: "(c1 = c2)" >OGid:"=" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(c1 = c2)" 
 -- OG:before:super.gen: "(c1 = c2)" 
 -- $Invocation:gen: "(c1 = c2)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(c1 = c2)" 
 -- isConstant: "Invocation" "(c1 = c2)" 
 -- needorigin: "(c1 = c2)" 
 -- needOrigin:E: "(c1 = c2)"  E.ATd: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- doNeedOrigin:Ex: "(c1 = c2)" 
 -- computeAdr:superAdj: 0 "(c1 = c2)" 
 -- computeAdr: 1 :rec: "none"  E: "(c1 = c2)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(c1 = c2)"  
 -- $BracketedExp:loadOrigin: "(c1 = c2)"  
 -- computeAdr:superAdj: 0 "c1 = c2" 
 -- computeAdr: 1 :rec: "none"  E: "c1 = c2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "c1 = c2"  
 -- $BinOp:loadOrigin: "c1 = c2"  
 -- BinaryExp:loadOrigin:empty: "c1 = c2" superAdj: 0 
 -- $BinOp:getAdr: "c1 = c2"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "c1 = c2"  ATd: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "c1 = c2" 
 -- BE:loadOrigin:E: c1 = c2 
 -- $BinOp:getAdr: "c1 = c2"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "c1 = c2"  ATd: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "c1 = c2" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "c1 = c2" E:  "c1 = c2" 
 -- INV:gen:E.loadArgs "c1 = c2" 
 -- $BinOp:loadArgs: "c1 = c2"  
 -- BinaryExp:loadArgs: "c1 = c2" superAdj: 0 
 -- $Invocation:gen: "c1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "c1" 
 -- isConstant: "Invocation" "c1" 
 -- notConst: c1 c1: var char 
 -- needorigin: "c1" 
 -- needOrigin:E: "c1"  E.ATd: "c1: var char" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "c1" 
 -- computeAdr: 1 :rec: "none"  E: "c1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "c1"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "c1" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "doit" on: 1 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg doit$64 1
 -- $ObjectInvocation_Unary:getAdr: "c1" >ATd.off:3:on:1:superAdj:0"c1: var char":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"non ..." 
 -- $var:getAdr: "c1: var char" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- DI:OG: char 
 -- before:floatTest:  "c1: var char" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "c1"  ATd: "c1: var char" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- computeAdr:isLast:E:  "c1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- rec:  "c1" E:  "c1" 
 -- INV:gen:E.loadArgs "c1" 
 -- $ObjectInvocation_Unary:loadArgs: "c1" >staticOff:0 "c1: var char" superAdj:0 
 -- $var:loadArgs: "c1: var char" >E:"c1" 
 -- $pattern:loadArgs: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;       ..."} 
 -- ptn:loadArgs:E "c1" 
 -- {(ObjectInvocation_Unary; (name: "c1"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "c1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- $ObjectInvocation_Unary:invoke: "c1" >rec:"c1" ATd:"var" isValueObj E:"c1" E.ATd:"c1" unique:"False" 
 -- OI:invoke: "c1" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:B: "c1" E: "c1"  rec: "c1"  useRtnV: true "c1: var char" 
 -- OI:invoke:before:ATdx.invoke: var c1 
 -- $var:invoke: "c1: var char" E: "c1">newOff:3 useRTNv: "True" 
 -- DI:invoke: "c1: var char" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- isCompositeValueObj: false E: "c1" "c1: var char" true 
 -- E.ATd.isValueObj: false rec: "c1" 
 pushg 3 matchEq$57
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- 
 -- OI:invoke:C: c1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- $pattern:loadArgs: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )" >E:"= c2":descNo:11} 
 -- ptn:loadArgs:E "= c2" 
 -- {(ObjectInvocation_Binary; (name: "="); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "c2");     (Arguments)));   (Items descNo: 0 o ...} 
 -- args: "c2" 
 -- E: "ObjectGenerator" c2 
 -- E.arg: "var" in Veq: var this(Value) 
 -- NonVirt: "= c2" "ObjectInvocation_Binary" ActArg:  "c2" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "= c2"  isCompositeValueObj: true 
 -- $ObjectGenerator:gen: "c2" >OGid:"char" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "c2" 
 -- OG:before:super.gen: "c2" 
 -- $Invocation:gen: "c2" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "c2" 
 -- isConstant: "Invocation" "c2" 
 -- notConst: c2 c2: var char 
 -- needorigin: "c2" 
 -- needOrigin:E: "c2"  E.ATd: "c2: var char" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "c2" 
 -- computeAdr: 1 :rec: "none"  E: "c2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "c2"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "c2" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "doit" on: 1 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg doit$64 1
 -- $ObjectInvocation_Unary:getAdr: "c2" >ATd.off:4:on:1:superAdj:0"c2: var char":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"non ..." 
 -- $var:getAdr: "c2: var char" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- DI:OG: char 
 -- before:floatTest:  "c2: var char" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "c2"  ATd: "c2: var char" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- computeAdr:isLast:E:  "c2" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- rec:  "c2" E:  "c2" 
 -- INV:gen:E.loadArgs "c2" 
 -- $ObjectInvocation_Unary:loadArgs: "c2" >staticOff:0 "c2: var char" superAdj:0 
 -- $var:loadArgs: "c2: var char" >E:"c2" 
 -- $pattern:loadArgs: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;       ..."} 
 -- ptn:loadArgs:E "c2" 
 -- {(ObjectInvocation_Unary; (name: "c2"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "c2" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c2" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- $ObjectInvocation_Unary:invoke: "c2" >rec:"c2" ATd:"var" isValueObj E:"c2" E.ATd:"c2" unique:"False" 
 -- OI:invoke: "c2" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- OI:invoke:B: "c2" E: "c2"  rec: "c2"  useRtnV: true "c2: var char" 
 -- OI:invoke:before:ATdx.invoke: var c2 
 -- $var:invoke: "c2: var char" E: "c2">newOff:4 useRTNv: "True" 
 -- DI:invoke: "c2: var char" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- isCompositeValueObj: false E: "c2" "c2: var char" true 
 -- E.ATd.isValueObj: false rec: "c2" 
 pushg 4 matchEq$57
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- 
 -- OI:invoke:C: c2 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- vEq: 
 -- end:loadArgs:NonVirt: "= c2" 
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:after:E.loadArgs "c1 = c2" 
 -- OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "c1 = c2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- $BinOp:invoke: "c1 = c2"  
 -- BinaryExp:invoke: "c1" rec: "c1 = c2" 
 -- M: "= c2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- $ObjectInvocation_Binary:invoke: "= c2" >rec:"c1" ATd:"pattern" E:"= c2" E.ATd:"=  " unique:"False" 
 -- OI:invoke: "= c2" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- origin:isValueObj "Value" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:B: "= c2" E: "= c2"  rec: "c1"  useRtnV: true "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OI:invoke:before:ATdx.invoke: pattern =   
 -- $pattern:invoke: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )" E: "= c2" useRTNv: "True"} 
 -- ptn:invoke: "=  " E: "= c2" ptnKind: 1 useRtnV: true 
 -- rec: "c1" "Invocation" OGx.label: "ObjectGenerator" OGx: char 
 -- rec.ATd: "c1: var char" 
 -- bobs: 3 OGx: char 
 eq
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= c2":rec:c1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= c2":rec:c1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: = c2 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: "-- we have inx = LBeq := L1 <= L2{   leave(matchEq)" >OGid:"$65" singular! staticOff=0 descNo=65 superAdj=0} 
 -- OG:gen: "-- we have inx = LBeq := L1 <= L2{   leave(matchEq)}" 
 pushThis 
 -- before objTmpStack:add:  65   "$65" 
 invoke $65 65 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L5
 L4:
 -- $ObjectGenerator:gen: "Beq := c1 < c2{   leave(matchEq)" >OGid:"$66" singular! staticOff=0 descNo=66 superAdj=0} 
 -- OG:gen: "Beq := c1 < c2{   leave(matchEq)}" 
 pushThis 
 -- before objTmpStack:add:  66   "$66" 
 invoke $66 66 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L5:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 -- pushReturn:  "doit" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 65 
 -- Items:GenClass: $65 descNo: 65 isValue: false 
 -- Items:GenClass: $65 descNo: 21 isValue: false 

 CLASS $65 65 1 doit 64
 -- Store itemArgs: -- we have inx = LBeq := L1 <= L2{leave(matchEq)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=65 vDescInx=65 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "Beq := L1 <= L2" 
 -- $Assign:gen: "Beq := L1 <= L2"  
 -- assign: "Beq := L1 <= L2" 
 -- computeAdr:superAdj: 0 "Beq" 
 -- computeAdr: 1 :rec: "none"  E: "Beq" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Beq"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Beq" >on:4 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$65" on: 4 isValueObj: false 
 -- origin: doit origin:isValueObj: false 
 rpushg $65$65 1
 -- items:goOrigin:encOG: "doit" on: 3 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg doit$64 1
 -- items:goOrigin:encOG: "matchEq" on: 2 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg matchEq$57 1
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: <= origin:isValueObj: false 
 rpushg loop$53 1
 -- $ObjectInvocation_Unary:getAdr: "Beq" >ATd.off:3:on:4:superAdj:0"out Beq: var boolean":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ... 
 -- $var:getAdr: "out Beq: var boolean" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: boolean 
 -- before:floatTest:  "out Beq: var boolean" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "Beq"  ATd: "out Beq: var boolean" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- computeAdr:isLast:E:  "Beq" 
 -- AssignmentStatement:gen: "Beq := L1 <= L2" right.label: "ObjectGenerator" "L1 <= L2" 
 -- $ObjectGenerator:gen: "L1 <= L2" >OGid:"<=" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L1 <= L2" 
 -- OG:before:super.gen: "L1 <= L2" 
 -- $Invocation:gen: "L1 <= L2" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L1 <= L2" 
 -- isConstant: "Invocation" "L1 <= L2" 
 -- needorigin: "L1 <= L2" 
 -- needOrigin:E: "L1 <= L2"  E.ATd: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- doNeedOrigin:Ex: "L1 <= L2" 
 -- computeAdr:superAdj: 0 "L1 <= L2" 
 -- computeAdr: 1 :rec: "none"  E: "L1 <= L2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "L1 <= L2"  
 -- $BinOp:loadOrigin: "L1 <= L2"  
 -- BinaryExp:loadOrigin:empty: "L1 <= L2" superAdj: 0 
 -- $BinOp:getAdr: "L1 <= L2"  
 -- E.on: 3 
 -- beforeIsValueObj:E: "L1 <= L2"  ATd: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "L1 <= L2" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "L1 <= L2" E:  "L1 <= L2" 
 -- INV:gen:E.loadArgs "L1 <= L2" 
 -- $BinOp:loadArgs: "L1 <= L2"  
 -- BinaryExp:loadArgs: "L1 <= L2" superAdj: 0 
 -- $Invocation:gen: "L1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L1" 
 -- isConstant: "Invocation" "L1" 
 -- notConst: L1 L1: var integer 
 -- needorigin: "L1" 
 -- needOrigin:E: "L1"  E.ATd: "L1: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L1" 
 -- computeAdr: 1 :rec: "none"  E: "L1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L1"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L1" >on:3 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$65" on: 3 isValueObj: false 
 -- origin: doit origin:isValueObj: false 
 rpushg $65$65 1
 -- items:goOrigin:encOG: "doit" on: 2 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg doit$64 1
 -- items:goOrigin:encOG: "matchEq" on: 1 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg matchEq$57 1
 -- $ObjectInvocation_Unary:getAdr: "L1" >ATd.off:3:on:3:superAdj:0"L1: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- $var:getAdr: "L1: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F orig ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L1: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- E.on: 3 
 -- beforeIsValueObj:E: "L1"  ATd: "L1: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- computeAdr:isLast:E:  "L1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- rec:  "L1" E:  "L1" 
 -- INV:gen:E.loadArgs "L1" 
 -- $ObjectInvocation_Unary:loadArgs: "L1" >staticOff:0 "L1: var integer" superAdj:0 
 -- $var:loadArgs: "L1: var integer" >E:"L1" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "L1" 
 -- {(ObjectInvocation_Unary; (name: "L1"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L1" >rec:"L1" ATd:"var" isValueObj E:"L1" E.ATd:"L1" unique:"False" 
 -- OI:invoke: "L1" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:B: "L1" E: "L1"  rec: "L1"  useRtnV: true "L1: var integer" 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- $var:invoke: "L1: var integer" E: "L1">newOff:3 useRTNv: "True" 
 -- DI:invoke: "L1: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- isCompositeValueObj: false E: "L1" "L1: var integer" true 
 -- E.ATd.isValueObj: false rec: "L1" 
 pushg 3 loop$53
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- OI:invoke:C: L1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- left:#I "L1 <= L2" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- $pattern:loadArgs: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean" >E:"<= L2":descNo:47} 
 -- ptn:loadArgs:E "<= L2" 
 -- {(ObjectInvocation_Binary; (name: "<="); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "L2");     (Arguments)));   (Items descNo: 0  ...} 
 -- args: "L2" 
 -- E: "ObjectGenerator" L2 
 -- E.arg: "var" in Veq: var this(Value) 
 -- NonVirt: "<= L2" "ObjectInvocation_Binary" ActArg:  "L2" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "<= L2"  isCompositeValueObj: true 
 -- $ObjectGenerator:gen: "L2" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L2" 
 -- OG:before:super.gen: "L2" 
 -- $Invocation:gen: "L2" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L2" 
 -- isConstant: "Invocation" "L2" 
 -- notConst: L2 L2: var integer 
 -- needorigin: "L2" 
 -- needOrigin:E: "L2"  E.ATd: "L2: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L2" 
 -- computeAdr: 1 :rec: "none"  E: "L2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L2"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L2" >on:3 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$65" on: 3 isValueObj: false 
 -- origin: doit origin:isValueObj: false 
 rpushg $65$65 1
 -- items:goOrigin:encOG: "doit" on: 2 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg doit$64 1
 -- items:goOrigin:encOG: "matchEq" on: 1 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg matchEq$57 1
 -- $ObjectInvocation_Unary:getAdr: "L2" >ATd.off:4:on:3:superAdj:0"L2: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- $var:getAdr: "L2: var integer" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F orig ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L2: var integer" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- E.on: 3 
 -- beforeIsValueObj:E: "L2"  ATd: "L2: var integer" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- computeAdr:isLast:E:  "L2" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- rec:  "L2" E:  "L2" 
 -- INV:gen:E.loadArgs "L2" 
 -- $ObjectInvocation_Unary:loadArgs: "L2" >staticOff:0 "L2: var integer" superAdj:0 
 -- $var:loadArgs: "L2: var integer" >E:"L2" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "L2" 
 -- {(ObjectInvocation_Unary; (name: "L2"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L2" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L2" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L2" >rec:"L2" ATd:"var" isValueObj E:"L2" E.ATd:"L2" unique:"False" 
 -- OI:invoke: "L2" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:B: "L2" E: "L2"  rec: "L2"  useRtnV: true "L2: var integer" 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- $var:invoke: "L2: var integer" E: "L2">newOff:4 useRTNv: "True" 
 -- DI:invoke: "L2: var integer" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- isCompositeValueObj: false E: "L2" "L2: var integer" true 
 -- E.ATd.isValueObj: false rec: "L2" 
 pushg 4 loop$53
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- 
 -- OI:invoke:C: L2 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- vEq: 
 -- end:loadArgs:NonVirt: "<= L2" 
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:after:E.loadArgs "L1 <= L2" 
 -- OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L1 <= L2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- $BinOp:invoke: "L1 <= L2"  
 -- BinaryExp:invoke: "L1" rec: "L1 <= L2" 
 -- M: "<= L2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- $ObjectInvocation_Binary:invoke: "<= L2" >rec:"L1" ATd:"pattern" E:"<= L2" E.ATd:"<=  " unique:"False" 
 -- OI:invoke: "<= L2" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- origin:isValueObj "Value" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:B: "<= L2" E: "<= L2"  rec: "L1"  useRtnV: true "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- OI:invoke:before:ATdx.invoke: pattern <=   
 -- $pattern:invoke: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean" E: "<= L2" useRTNv: "True"} 
 -- ptn:invoke: "<=  " E: "<= L2" ptnKind: 1 useRtnV: true 
 -- rec: "L1" "Invocation" OGx.label: "ObjectGenerator" OGx: integer 
 -- rec.ATd: "L1: var integer" 
 -- bobs: 1 OGx: integer 
 le
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<= L2":rec:L1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<= L2":rec:L1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: <= L2 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "Beq" dstE: "Beq" dstE.ATd: "out Beq: var boolean" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- ... 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right: "L1 <= L2" 
 -- isArgOfAssignI2IwithUniValArg "Beq := L1 <= L2" arg: "L1 <= L2" ObjectGenerator 
 -- arg.super.arg: "L1 <= L2" BinOp 
 -- recx:BinaryExp:recx: "L1 <= L2" 
 -- M: "<= L2" label: "ObjectInvocation_Binary" M.ATd: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- checkInt2IntWithUnitArg:rec: "L1" E: "<= L2" 
 -- arg:other 
 -- M:arg: "L2" ObjectGenerator false 
 -- dstDI: "out Beq: var boolean" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg <=$52 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "leave(matchEq)" 
 -- $ObjectGenerator:gen: "leave(matchEq)" >OGid:"leave" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "leave(matchEq)" 
 -- OG:before:super.gen: "leave(matchEq)" 
 -- $Invocation:gen: "leave(matchEq)" >useRtnV:"False"superAdj: 0 descNo: 19 
 -- INV:gen: "leave(matchEq)" 
 -- isConstant: "Invocation" "leave(matchEq)" 
 -- needorigin: "leave(matchEq)" 
 -- needOrigin:E: "leave(matchEq)"  E.ATd: "leave(V: var integer): {   %basic 103}" 
 -- doNeedOrigin:Ex: "leave(matchEq)" 
 -- computeAdr:superAdj: 0 "leave(matchEq)" 
 -- computeAdr: 1 :rec: "none"  E: "leave(matchEq)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "leave(matchEq)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "leave(matchEq)" >on:7 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "leave(matchEq)" >ATd.off:0 (isPtn):on:7:superAdj:0"leave(V: var integer): {   %basic 103":Adr:off:0 size:0 isFloat:F isUnitVal:F superAd ...} 
 -- $pattern:getAdr: "leave(V: var integer): {   %basic 103" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- E.on: 7 
 -- beforeIsValueObj:E: "leave(matchEq)"  ATd: "leave(V: var integer): {   %basic 103}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- computeAdr:isLast:E:  "leave(matchEq)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- rec:  "leave(matchEq)" E:  "leave(matchEq)" 
 -- INV:gen:E.loadArgs "leave(matchEq)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "leave(matchEq)" >staticOff:0 "leave(V: var integer): {   %basic 103" superAdj:0arg:"matchEq"} 
 -- $pattern:loadArgs: "leave(V: var integer): {   %basic 103" >E:"leave(matchEq)":descNo:19} 
 -- INV:gen:after:E.loadArgs "leave(matchEq)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "leave(matchEq)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave( ..." 
 -- $ObjectInvocation_KeyWord:invoke: "leave(matchEq)" >rec:"leave(matchEq)" ATd:"pattern" E:"leave(matchEq)" E.ATd:"leave(V: var integer)" unique:"False" 
 -- OI:invoke: "leave(matchEq)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- OI:invoke:B: "leave(matchEq)" E: "leave(matchEq)"  rec: "leave(matchEq)"  useRtnV: false "leave(V: var integer): {   %basic 103}" 
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- $pattern:invoke: "leave(V: var integer): {   %basic 103" E: "leave(matchEq)" useRTNv: "False"} 
 -- ptn:invoke: "leave(V: var integer)" E: "leave(matchEq)" ptnKind: 0 useRtnV: false 
 break  2 2 57 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- 
 -- OI:invoke:C: leave(matchEq) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 66 
 -- Items:GenClass: $66 descNo: 66 isValue: false 
 -- Items:GenClass: $66 descNo: 21 isValue: false 

 CLASS $66 66 1 doit 64
 -- Store itemArgs: Beq := c1 < c2{leave(matchEq)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=66 vDescInx=66 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "Beq := c1 < c2" 
 -- $Assign:gen: "Beq := c1 < c2"  
 -- assign: "Beq := c1 < c2" 
 -- computeAdr:superAdj: 0 "Beq" 
 -- computeAdr: 1 :rec: "none"  E: "Beq" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Beq"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Beq" >on:4 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$66" on: 4 isValueObj: false 
 -- origin: doit origin:isValueObj: false 
 rpushg $66$66 1
 -- items:goOrigin:encOG: "doit" on: 3 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg doit$64 1
 -- items:goOrigin:encOG: "matchEq" on: 2 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg matchEq$57 1
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: <= origin:isValueObj: false 
 rpushg loop$53 1
 -- $ObjectInvocation_Unary:getAdr: "Beq" >ATd.off:3:on:4:superAdj:0"out Beq: var boolean":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ... 
 -- $var:getAdr: "out Beq: var boolean" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: boolean 
 -- before:floatTest:  "out Beq: var boolean" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "Beq"  ATd: "out Beq: var boolean" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- computeAdr:isLast:E:  "Beq" 
 -- AssignmentStatement:gen: "Beq := c1 < c2" right.label: "ObjectGenerator" "c1 < c2" 
 -- $ObjectGenerator:gen: "c1 < c2" >OGid:"<" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "c1 < c2" 
 -- OG:before:super.gen: "c1 < c2" 
 -- $Invocation:gen: "c1 < c2" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "c1 < c2" 
 -- isConstant: "Invocation" "c1 < c2" 
 -- needorigin: "c1 < c2" 
 -- needOrigin:E: "c1 < c2"  E.ATd: "<  : {   %basic 51;   in V: var char;   out B: var boolean}" 
 -- doNeedOrigin:Ex: "c1 < c2" 
 -- computeAdr:superAdj: 0 "c1 < c2" 
 -- computeAdr: 1 :rec: "none"  E: "c1 < c2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "c1 < c2"  
 -- $BinOp:loadOrigin: "c1 < c2"  
 -- BinaryExp:loadOrigin:empty: "c1 < c2" superAdj: 0 
 -- $BinOp:getAdr: "c1 < c2"  
 -- E.on: 2 
 -- beforeIsValueObj:E: "c1 < c2"  ATd: "<  : {   %basic 51;   in V: var char;   out B: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "c1 < c2" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "c1 < c2" E:  "c1 < c2" 
 -- INV:gen:E.loadArgs "c1 < c2" 
 -- $BinOp:loadArgs: "c1 < c2"  
 -- BinaryExp:loadArgs: "c1 < c2" superAdj: 0 
 -- $Invocation:gen: "c1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "c1" 
 -- isConstant: "Invocation" "c1" 
 -- notConst: c1 c1: var char 
 -- needorigin: "c1" 
 -- needOrigin:E: "c1"  E.ATd: "c1: var char" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "c1" 
 -- computeAdr: 1 :rec: "none"  E: "c1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "c1"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "c1" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$66" on: 2 isValueObj: false 
 -- origin: doit origin:isValueObj: false 
 rpushg $66$66 1
 -- items:goOrigin:encOG: "doit" on: 1 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg doit$64 1
 -- $ObjectInvocation_Unary:getAdr: "c1" >ATd.off:3:on:2:superAdj:0"c1: var char":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"non ..." 
 -- $var:getAdr: "c1: var char" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- DI:OG: char 
 -- before:floatTest:  "c1: var char" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "c1"  ATd: "c1: var char" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- computeAdr:isLast:E:  "c1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- rec:  "c1" E:  "c1" 
 -- INV:gen:E.loadArgs "c1" 
 -- $ObjectInvocation_Unary:loadArgs: "c1" >staticOff:0 "c1: var char" superAdj:0 
 -- $var:loadArgs: "c1: var char" >E:"c1" 
 -- $pattern:loadArgs: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;       ..."} 
 -- ptn:loadArgs:E "c1" 
 -- {(ObjectInvocation_Unary; (name: "c1"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "c1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- $ObjectInvocation_Unary:invoke: "c1" >rec:"c1" ATd:"var" isValueObj E:"c1" E.ATd:"c1" unique:"False" 
 -- OI:invoke: "c1" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:B: "c1" E: "c1"  rec: "c1"  useRtnV: true "c1: var char" 
 -- OI:invoke:before:ATdx.invoke: var c1 
 -- $var:invoke: "c1: var char" E: "c1">newOff:3 useRTNv: "True" 
 -- DI:invoke: "c1: var char" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- isCompositeValueObj: false E: "c1" "c1: var char" true 
 -- E.ATd.isValueObj: false rec: "c1" 
 pushg 3 matchEq$57
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- 
 -- OI:invoke:C: c1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- $pattern:loadArgs: "<  : {   %basic 51;   in V: var char;   out B: var boolean" >E:"< c2":descNo:67} 
 -- ptn:loadArgs:E "< c2" 
 -- {(ObjectInvocation_Binary; (name: "<"); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "c2");     (Arguments)));   (Items descNo: 0 o ...} 
 -- args: "c2" 
 -- E: "ObjectGenerator" c2 
 -- E.arg: "var" in V: var char 
 -- NonVirt: "< c2" "ObjectInvocation_Binary" ActArg:  "c2" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "< c2"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "c2" >OGid:"char" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "c2" 
 -- OG:before:super.gen: "c2" 
 -- $Invocation:gen: "c2" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "c2" 
 -- isConstant: "Invocation" "c2" 
 -- notConst: c2 c2: var char 
 -- needorigin: "c2" 
 -- needOrigin:E: "c2"  E.ATd: "c2: var char" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "c2" 
 -- computeAdr: 1 :rec: "none"  E: "c2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "c2"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "c2" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$66" on: 2 isValueObj: false 
 -- origin: doit origin:isValueObj: false 
 rpushg $66$66 1
 -- items:goOrigin:encOG: "doit" on: 1 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg doit$64 1
 -- $ObjectInvocation_Unary:getAdr: "c2" >ATd.off:4:on:2:superAdj:0"c2: var char":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"non ..." 
 -- $var:getAdr: "c2: var char" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- DI:OG: char 
 -- before:floatTest:  "c2: var char" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "c2"  ATd: "c2: var char" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- computeAdr:isLast:E:  "c2" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- rec:  "c2" E:  "c2" 
 -- INV:gen:E.loadArgs "c2" 
 -- $ObjectInvocation_Unary:loadArgs: "c2" >staticOff:0 "c2: var char" superAdj:0 
 -- $var:loadArgs: "c2: var char" >E:"c2" 
 -- $pattern:loadArgs: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;       ..."} 
 -- ptn:loadArgs:E "c2" 
 -- {(ObjectInvocation_Unary; (name: "c2"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "c2" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c2" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- $ObjectInvocation_Unary:invoke: "c2" >rec:"c2" ATd:"var" isValueObj E:"c2" E.ATd:"c2" unique:"False" 
 -- OI:invoke: "c2" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- OI:invoke:B: "c2" E: "c2"  rec: "c2"  useRtnV: true "c2: var char" 
 -- OI:invoke:before:ATdx.invoke: var c2 
 -- $var:invoke: "c2: var char" E: "c2">newOff:4 useRTNv: "True" 
 -- DI:invoke: "c2: var char" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- isCompositeValueObj: false E: "c2" "c2: var char" true 
 -- E.ATd.isValueObj: false rec: "c2" 
 pushg 4 matchEq$57
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- 
 -- OI:invoke:C: c2 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- formalArg:isPtn: "in V: var char" :isBasicVal: true :valueObj: true 
 -- :actArg: "c2" :isBasicVal: true 
 -- case:B: c2 ObjectGenerator 3 0 3 false false 
 -- end:loadArgs:NonVirt: "< c2" 
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:after:E.loadArgs "c1 < c2" 
 -- OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "c1 < c2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- $BinOp:invoke: "c1 < c2"  
 -- BinaryExp:invoke: "c1" rec: "c1 < c2" 
 -- M: "< c2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- $ObjectInvocation_Binary:invoke: "< c2" >rec:"c1" ATd:"pattern" E:"< c2" E.ATd:"<  " unique:"False" 
 -- OI:invoke: "< c2" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- origin:isValueObj "char" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:B: "< c2" E: "< c2"  rec: "c1"  useRtnV: true "<  : {   %basic 51;   in V: var char;   out B: var boolean}" 
 -- OI:invoke:before:ATdx.invoke: pattern <   
 -- $pattern:invoke: "<  : {   %basic 51;   in V: var char;   out B: var boolean" E: "< c2" useRTNv: "True"} 
 -- ptn:invoke: "<  " E: "< c2" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "c1" E: "< c2" 
 -- arg:other 
 lt
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< c2":rec:c1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< c2":rec:c1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: < c2 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "Beq" dstE: "Beq" dstE.ATd: "out Beq: var boolean" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- ... 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right: "c1 < c2" 
 -- isArgOfAssignI2IwithUniValArg "Beq := c1 < c2" arg: "c1 < c2" ObjectGenerator 
 -- arg.super.arg: "c1 < c2" BinOp 
 -- recx:BinaryExp:recx: "c1 < c2" 
 -- M: "< c2" label: "ObjectInvocation_Binary" M.ATd: "<  : {   %basic 51;   in V: var char;   out B: var boolean}" 
 -- checkInt2IntWithUnitArg:rec: "c1" E: "< c2" 
 -- arg:other 
 -- M:arg: "c2" ObjectGenerator false 
 -- dstDI: "out Beq: var boolean" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg <=$52 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "leave(matchEq)" 
 -- $ObjectGenerator:gen: "leave(matchEq)" >OGid:"leave" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "leave(matchEq)" 
 -- OG:before:super.gen: "leave(matchEq)" 
 -- $Invocation:gen: "leave(matchEq)" >useRtnV:"False"superAdj: 0 descNo: 19 
 -- INV:gen: "leave(matchEq)" 
 -- isConstant: "Invocation" "leave(matchEq)" 
 -- needorigin: "leave(matchEq)" 
 -- needOrigin:E: "leave(matchEq)"  E.ATd: "leave(V: var integer): {   %basic 103}" 
 -- doNeedOrigin:Ex: "leave(matchEq)" 
 -- computeAdr:superAdj: 0 "leave(matchEq)" 
 -- computeAdr: 1 :rec: "none"  E: "leave(matchEq)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "leave(matchEq)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "leave(matchEq)" >on:7 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "leave(matchEq)" >ATd.off:0 (isPtn):on:7:superAdj:0"leave(V: var integer): {   %basic 103":Adr:off:0 size:0 isFloat:F isUnitVal:F superAd ...} 
 -- $pattern:getAdr: "leave(V: var integer): {   %basic 103" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- E.on: 7 
 -- beforeIsValueObj:E: "leave(matchEq)"  ATd: "leave(V: var integer): {   %basic 103}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- computeAdr:isLast:E:  "leave(matchEq)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- rec:  "leave(matchEq)" E:  "leave(matchEq)" 
 -- INV:gen:E.loadArgs "leave(matchEq)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "leave(matchEq)" >staticOff:0 "leave(V: var integer): {   %basic 103" superAdj:0arg:"matchEq"} 
 -- $pattern:loadArgs: "leave(V: var integer): {   %basic 103" >E:"leave(matchEq)":descNo:19} 
 -- INV:gen:after:E.loadArgs "leave(matchEq)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "leave(matchEq)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave( ..." 
 -- $ObjectInvocation_KeyWord:invoke: "leave(matchEq)" >rec:"leave(matchEq)" ATd:"pattern" E:"leave(matchEq)" E.ATd:"leave(V: var integer)" unique:"False" 
 -- OI:invoke: "leave(matchEq)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- OI:invoke:B: "leave(matchEq)" E: "leave(matchEq)"  rec: "leave(matchEq)"  useRtnV: false "leave(V: var integer): {   %basic 103}" 
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- $pattern:invoke: "leave(V: var integer): {   %basic 103" E: "leave(matchEq)" useRTNv: "False"} 
 -- ptn:invoke: "leave(V: var integer)" E: "leave(matchEq)" ptnKind: 0 useRtnV: false 
 break  2 2 57 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- 
 -- OI:invoke:C: leave(matchEq) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 68 
 -- Items:GenClass: puttext descNo: 68 isValue: false 
 -- Items:GenClass: puttext descNo: 21 isValue: false 

 CLASS puttext 68 1 ConsoleIF 8
 -- Store itemArgs: inner(puttext) 
 -- T: var LIB.StringLib.String true 5 
 pushThis 
 rstoreg  T 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=68 vDescInx=68 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "inner(puttext)" 
 -- $ObjectGenerator:gen: "inner(puttext)" >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inner(puttext)" 
 -- OG:before:super.gen: "inner(puttext)" 
 -- $Invocation:gen: "inner(puttext)" >useRtnV:"False"superAdj: 0 descNo: 12 
 -- INV:gen: "inner(puttext)" 
 -- isConstant: "Invocation" "inner(puttext)" 
 -- needorigin: "inner(puttext)" 
 -- needOrigin:E: "inner(puttext)"  E.ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- doNeedOrigin:Ex: "inner(puttext)" 
 -- computeAdr:superAdj: 0 "inner(puttext)" 
 -- computeAdr: 1 :rec: "none"  E: "inner(puttext)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "inner(puttext)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "inner(puttext)" >on:2 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "inner(puttext)" >ATd.off:0 (isPtn):on:2:superAdj:0"inner: {   %basic 101;   in inner: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal:F ...} 
 -- $pattern:getAdr: "inner: {   %basic 101;   in inner: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inner(puttext)"  ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:- 
 -- computeAdr:isLast:E:  "inner(puttext)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:- 
 -- rec:  "inner(puttext)" E:  "inner(puttext)" 
 -- INV:gen:E.loadArgs "inner(puttext)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "inner(puttext)" >staticOff:0 "inner: {   %basic 101;   in inner: ref Object" superAdj:0arg:"puttext"} 
 -- $pattern:loadArgs: "inner: {   %basic 101;   in inner: ref Object" >E:"inner(puttext)":descNo:12} 
 -- INV:gen:after:E.loadArgs "inner(puttext)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(puttext)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner( ..." 
 -- $ObjectInvocation_KeyWord:invoke: "inner(puttext)" >rec:"inner(puttext)" ATd:"pattern" E:"inner(puttext)" E.ATd:"inner" unique:"False" 
 -- OI:invoke: "inner(puttext)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:inner(puttext) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:inner(puttext) 
 -- OI:invoke:B: "inner(puttext)" E: "inner(puttext)"  rec: "inner(puttext)"  useRtnV: false "inner: {   %basic 101;   in inner: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- $pattern:invoke: "inner: {   %basic 101;   in inner: ref Object" E: "inner(puttext)" useRTNv: "False"} 
 -- ptn:invoke: "inner" E: "inner(puttext)" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:inner(puttext) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:inner(puttext) 
 -- 
 -- OI:invoke:C: inner(puttext) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:inner(puttext) 
 L2:
 -- pushReturn:  "puttext" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- vdtAdd: inx=2 descInx=68 vDescInx=0 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 69 
 -- Items:GenClass: putint descNo: 69 isValue: false 
 -- Items:GenClass: putint descNo: 21 isValue: false 

 CLASS putint 69 1 ConsoleIF 8
 -- Store itemArgs: inner(putint) 
 -- V: var Integer true 1 
 -- DI:store: "V" 
 pushThis 
 storeg integer$5 2
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=69 vDescInx=69 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "inner(putint)" 
 -- $ObjectGenerator:gen: "inner(putint)" >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inner(putint)" 
 -- OG:before:super.gen: "inner(putint)" 
 -- $Invocation:gen: "inner(putint)" >useRtnV:"False"superAdj: 0 descNo: 12 
 -- INV:gen: "inner(putint)" 
 -- isConstant: "Invocation" "inner(putint)" 
 -- needorigin: "inner(putint)" 
 -- needOrigin:E: "inner(putint)"  E.ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- doNeedOrigin:Ex: "inner(putint)" 
 -- computeAdr:superAdj: 0 "inner(putint)" 
 -- computeAdr: 1 :rec: "none"  E: "inner(putint)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "inner(putint)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "inner(putint)" >on:2 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "inner(putint)" >ATd.off:0 (isPtn):on:2:superAdj:0"inner: {   %basic 101;   in inner: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal:F  ...} 
 -- $pattern:getAdr: "inner: {   %basic 101;   in inner: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inner(putint)"  ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:- 
 -- computeAdr:isLast:E:  "inner(putint)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:- 
 -- rec:  "inner(putint)" E:  "inner(putint)" 
 -- INV:gen:E.loadArgs "inner(putint)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "inner(putint)" >staticOff:0 "inner: {   %basic 101;   in inner: ref Object" superAdj:0arg:"putint"} 
 -- $pattern:loadArgs: "inner: {   %basic 101;   in inner: ref Object" >E:"inner(putint)":descNo:12} 
 -- INV:gen:after:E.loadArgs "inner(putint)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(putint)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(p ..." 
 -- $ObjectInvocation_KeyWord:invoke: "inner(putint)" >rec:"inner(putint)" ATd:"pattern" E:"inner(putint)" E.ATd:"inner" unique:"False" 
 -- OI:invoke: "inner(putint)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:inner(putint) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:inner(putint) 
 -- OI:invoke:B: "inner(putint)" E: "inner(putint)"  rec: "inner(putint)"  useRtnV: false "inner: {   %basic 101;   in inner: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- $pattern:invoke: "inner: {   %basic 101;   in inner: ref Object" E: "inner(putint)" useRTNv: "False"} 
 -- ptn:invoke: "inner" E: "inner(putint)" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:inner(putint) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:inner(putint) 
 -- 
 -- OI:invoke:C: inner(putint) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:inner(putint) 
 L2:
 -- pushReturn:  "putint" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- vdtAdd: inx=2 descInx=69 vDescInx=0 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 70 
 -- Items:GenClass: workspace descNo: 70 isValue: false 
 -- Items:GenClass: workspace descNo: 21 isValue: false 

 CLASS workspace 70 1 BETAworld 1
 -- Store itemArgs: %id "workspace"{%visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib;%domain_boundary;--AbstractEx;--AccessEx;--ApplyPred;--ArduinoEx;--ArmBasicS ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=70 vDescInx=70 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%id "workspace""  
 -- $Property:gen: "%visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib"  
 -- Module:genMI:  "demo" 
 -- $Property:gen: "%domain_boundary"  
 -- $ModuleItem:gen: "--AbstractEx{" } 
 -- $ModuleItem:gen: "--AccessEx{" } 
 -- $ModuleItem:gen: "--ApplyPred{" } 
 -- $ModuleItem:gen: "--ArduinoEx{" } 
 -- $ModuleItem:gen: "--ArmBasicSys{" } 
 -- $ModuleItem:gen: "--ArmLed{" } 
 -- $ModuleItem:gen: "--ArmMultiCore{" } 
 -- $ModuleItem:gen: "--CAStest{" } 
 -- $ModuleItem:gen: "--CAStestCore{" } 
 -- $ModuleItem:gen: "--CoroutineEx{" } 
 -- $ModuleItem:gen: "--CppEx{" } 
 -- $ModuleItem:gen: "--DumpObjEx{" } 
 -- $ModuleItem:gen: "--Errors{" } 
 -- $ModuleItem:gen: "--FoolishUnitEx{" } 
 -- $ModuleItem:gen: "--ForkGC{" } 
 -- $ModuleItem:gen: "--FuncVirtExVclass{" } 
 -- $ModuleItem:gen: "--FunctionalVirtEx{" } 
 -- $ModuleItem:gen: "--Jurgen{" } 
 -- $ModuleItem:gen: "--LLVMex{" } 
 -- $ModuleItem:gen: "--ListLiteralEx{" } 
 -- $ModuleItem:gen: "--LockTestCore{" } 
 -- $ModuleItem:gen: "--MVRsystem{" } 
 -- $ModuleItem:gen: "--MapEx{" } 
 -- $ModuleItem:gen: "--MiniVal{" } 
 -- $ModuleItem:gen: "--NewInner{" } 
 -- $ModuleItem:gen: "--NewSyntax{" } 
 -- $ModuleItem:gen: "--NoneEx{" } 
 -- $ModuleItem:gen: "--ObjectAndValues{" } 
 -- $ModuleItem:gen: "--ReadersSingleWriter{" } 
 -- $ModuleItem:gen: "--RemoteSuperVC{" } 
 -- $ModuleItem:gen: "--Restrictions{" } 
 -- $ModuleItem:gen: "--SlideEx{" } 
 -- $ModuleItem:gen: "--Sub1{" } 
 -- $ModuleItem:gen: "--TST{" } 
 -- $ModuleItem:gen: "--TstBreak{" } 
 -- $ModuleItem:gen: "--UnitIssues{" } 
 -- $ModuleItem:gen: "--UnitKindEx{" } 
 -- $ModuleItem:gen: "--UnitTest{" } 
 -- $ModuleItem:gen: "--ValueArray{" } 
 -- $ModuleItem:gen: "--ValueConv{" } 
 -- $ModuleItem:gen: "--ValueEx{" } 
 -- $ModuleItem:gen: "--ValueItemEx{" } 
 -- $ModuleItem:gen: "--ValueTypes{" } 
 -- $ModuleItem:gen: "--VirtError{" } 
 -- $ModuleItem:gen: "--VirtualEx{" } 
 -- $ModuleItem:gen: "--Visibility{" } 
 -- $ModuleItem:gen: "--demo{" } 
 -- ModuleItem:gen demo 
 -- $ModuleItem:gen: "--embodyex{" } 
 -- $ModuleItem:gen: "--hello{" } 
 -- $ModuleItem:gen: "--qbetaCmp{" } 
 -- $ModuleItem:gen: "--test{" } 
 -- $ModuleItem:gen: "--tiny{" } 
 -- $ModuleItem:gen: "--tinyA{" } 
 -- $ModuleItem:gen: "--tinyAA{" } 
 -- $ModuleItem:gen: "--tinyAB{" } 
 -- $ModuleItem:gen: "--tinyAC{" } 
 -- $ModuleItem:gen: "--tinyB{" } 
 -- $ModuleItem:gen: "--tinyC{" } 
 -- $ModuleItem:gen: "--tinyD{" } 
 -- $ModuleItem:gen: "--tinyE{" } 
 -- $ModuleItem:gen: "--tinyF{" } 
 -- $ModuleItem:gen: "--tinyG{" } 
 -- $ModuleItem:gen: "--tinyH{" } 
 -- $ModuleItem:gen: "--tinyI{" } 
 -- $ModuleItem:gen: "--tinyJ{" } 
 -- $ModuleItem:gen: "--tinyP{" } 
 -- $ModuleItem:gen: "--tinyQ{" } 
 -- $ModuleItem:gen: "--tinyR{" } 
 -- $ModuleItem:gen: "--tinyS{" } 
 -- $ModuleItem:gen: "--tinyV{" } 
 -- $ModuleItem:gen: "--tinyW{" } 
 -- $ModuleItem:gen: "--tinyX{" } 
 -- $ModuleItem:gen: "--tinyY{" } 
 -- $ModuleItem:gen: "--tinyZ{" } 
 -- $obj:gen: "demo: obj {   %id "demo";   --AnimalMonitorSystem;--ArrayDemos;--Bank;--BasicValueSub;--BinTreeMerge;--Break;--COSex;--ChemicalPlantSystem;--CoArg;--CollectionE ..."} 
 -- $ObjectGenerator:gen: "%id "demo"{   --AnimalMonitorSystem;--ArrayDemos;--Bank;--BasicValueSub;--BinTreeMerge;--Break;--COSex;--ChemicalPlantSystem;--CoArg;--CollectionEx; ..."} 
 -- OG:gen: "%id "demo"{   --AnimalMonitorSystem;--ArrayDemos;--Bank;--BasicValueSub;--BinTreeMerge;--Break;--COSex;--ChemicalPlantSystem;--CoArg;--CollectionEx;--ComplexEx;-- ...}" 
 pushThis 
 -- before objTmpStack:add:  71   "demo" 
 invoke demo 71 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%id "workspace"" 
 -- $Property:gen: "%id "workspace""  
 -- genclass:stmt: "%visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib" 
 -- $Property:gen: "%visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib"  
 -- genclass:stmt: "%domain_boundary" 
 -- $Property:gen: "%domain_boundary"  
 L2:
 -- pushReturn:  "workspace" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 71 
 -- Items:GenClass: demo descNo: 71 isValue: false 
 -- Items:GenClass: demo descNo: 21 isValue: false 

 CLASS demo 71 1 workspace 70
 -- Store itemArgs: %id "demo"{--AnimalMonitorSystem;--ArrayDemos;--Bank;--BasicValueSub;--BinTreeMerge;--Break;--COSex;--ChemicalPlantSystem;--CoArg;--CollectionEx;--ComplexE ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=71 vDescInx=71 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%id "demo""  
 -- $ModuleItem:gen: "--AnimalMonitorSystem{" } 
 -- $ModuleItem:gen: "--ArrayDemos{" } 
 -- $ModuleItem:gen: "--Bank{" } 
 -- $ModuleItem:gen: "--BasicValueSub{" } 
 -- $ModuleItem:gen: "--BinTreeMerge{" } 
 -- $ModuleItem:gen: "--Break{" } 
 -- $ModuleItem:gen: "--COSex{" } 
 -- $ModuleItem:gen: "--ChemicalPlantSystem{" } 
 -- $ModuleItem:gen: "--CoArg{" } 
 -- $ModuleItem:gen: "--CollectionEx{" } 
 -- $ModuleItem:gen: "--ComplexEx{" } 
 -- $ModuleItem:gen: "--FactorialEx{" } 
 -- $ModuleItem:gen: "--FileDemo{" } 
 -- $ModuleItem:gen: "--ForkJoinEx{" } 
 -- $ModuleItem:gen: "--Formater{" } 
 -- $ModuleItem:gen: "--ISoLA2022{" } 
 -- $ModuleItem:gen: "--KBprocess{" } 
 -- $ModuleItem:gen: "--LibraEx{" } 
 -- $ModuleItem:gen: "--MixedScheduling{" } 
 -- $ModuleItem:gen: "--MonitorDemo{" } 
 -- ModuleItem:gen MonitorDemo 
 -- $ModuleItem:gen: "--NonBlockingIOex{" } 
 -- $ModuleItem:gen: "--NullList{" } 
 -- $ModuleItem:gen: "--PointEx{" } 
 -- $ModuleItem:gen: "--Robots{" } 
 -- $ModuleItem:gen: "--SCPex{" } 
 -- $ModuleItem:gen: "--SimpleEx{" } 
 -- $ModuleItem:gen: "--SimpleThreadEx{" } 
 -- $ModuleItem:gen: "--SocketEx{" } 
 -- $ModuleItem:gen: "--Static{" } 
 -- $ModuleItem:gen: "--TempEx{" } 
 -- $ModuleItem:gen: "--ToyCar{" } 
 -- $ModuleItem:gen: "--UnitEx{" } 
 -- $ModuleItem:gen: "--Units{" } 
 -- $ModuleItem:gen: "--ValueDemo{" } 
 -- $ModuleItem:gen: "--localsEx{" } 
 -- $obj:gen: "MonitorDemo: obj LIB.MonitorSystemLib.MonitorSystem{   %requires MonitorSystemLib;   %include LIB.StringLib;   P1: obj MonitorProcess("PP1");      fac(V: var in ..."} 
 -- $ObjectGenerator:gen: "LIB.MonitorSystemLib.MonitorSystem{   %requires MonitorSystemLib;   %include LIB.StringLib;   P1: obj MonitorProcess("PP1");      fac(V: var integer ..."} 
 -- OG:gen: "LIB.MonitorSystemLib.MonitorSystem{   %requires MonitorSystemLib;   %include LIB.StringLib;   P1: obj MonitorProcess("PP1");      fac(V: var integer): ;         o ...}" 
 pushThis 
 -- before objTmpStack:add:  189   "MonitorDemo" 
 invoke MonitorDemo 189 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%id "demo"" 
 -- $Property:gen: "%id "demo""  
 L2:
 -- pushReturn:  "demo" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 72 
 -- Items:GenClass: BasicSystem descNo: 72 isValue: false 
 -- Items:GenClass: BasicSystem descNo: 21 isValue: false 

 CLASS BasicSystem 72 1 BasicSystemLib 38
 -- Store itemArgs: %public{BasicProcess: GeneralProcess;   mkActive::< ;      -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;      SQS ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=72 vDescInx=72 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%public"  
 -- $val:gen: "noOfCores: val 4"  
 -- DI:gen: "noOfCores: val 4" DI:isConst: true :isBasicValue: true :primNo: 1 
 -- DI:add:BP2:  noOfCores 
 -- $ObjectGenerator:gen: "4" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "4" 
 -- OG:before:super.gen: "4" 
 -- $Invocation:gen: "4" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "4" 
 -- isConstant: "Invocation" "4" 
 -- needorigin: "4" 
 -- needOrigin:E: "4"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "4" E:  "4" 
 -- INV:gen:E.loadArgs "4" 
 -- $ConstLiteral:loadArgs: "4"  
 -- INV:gen:after:E.loadArgs "4" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "4" 
 -- $ConstLiteral:invoke: "4"  
 pushc 4
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- dataItem:store:basicValue: off: 1  NewOff: 2 
 pushThis 
 storeg noOfCores 2
 -- $obj:gen: "cores: obj {   C1: ref Core;   C2: ref Core;   C3: ref Core;   C4: ref Core;   -- should be array         ;   init: ;      S: ref Scheduler;      C1 := Core;    ..."} 
 -- DI:gen: "cores: obj {   C1: ref Core;   C2: ref Core;   C3: ref Core;   C4: ref Core;   -- should be array         ;   init: ;      S: ref Scheduler;      C1 := Core;      ...}" D ... true : ... false : ... 0 
 -- DI:add:BP4:  cores 
 -- $ObjectGenerator:gen: "C1: ref Core{   C2: ref Core;   C3: ref Core;   C4: ref Core;   -- should be array         ;   init: ;      S: ref Scheduler;      C1 := Core;       ..."} 
 -- OG:gen: "C1: ref Core{   C2: ref Core;   C3: ref Core;   C4: ref Core;   -- should be array         ;   init: ;      S: ref Scheduler;      C1 := Core;      fork(C1);      ...}" 
 pushThis 
 -- before objTmpStack:add:  73   "cores" 
 invoke cores 73 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $obj:gen: "P_status: obj {   %globals;   %Public;   ACTIVE: val 1;   WAITING: val 2;   TERMINATED: val 3" } 
 -- DI:gen: "P_status: obj {   %globals;   %Public;   ACTIVE: val 1;   WAITING: val 2;   TERMINATED: val 3}" DI:isConst: true :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  P_status 
 -- $ObjectGenerator:gen: "%globals{   %Public;   ACTIVE: val 1;   WAITING: val 2;   TERMINATED: val 3" >OGid:"P_status" singular! staticOff=4 descNo=74 superAdj=0} 
 -- OG:gen: "%globals{   %Public;   ACTIVE: val 1;   WAITING: val 2;   TERMINATED: val 3}" 
 pushThis 
 -- before objTmpStack:add:  74   "P_status" 
 invoke P_status 74 4 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $obj:gen: "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      entry;         M := M +  ..."} 
 -- DI:gen: "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      entry;         M := M + 1; ...}" D ... true : ... false : ... 0 
 -- DI:add:BP4:  sch 
 -- $ObjectGenerator:gen: "L: obj Lock("Sch:lock"){   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      entry;         M := M + 1 ..."} 
 -- OG:gen: "L: obj Lock("Sch:lock"){   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      entry;         M := M + 1;   dcr: ;     ...}" 
 pushThis 
 -- before objTmpStack:add:  75   "sch" 
 invoke sch 75 5 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $obj:gen: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if (V  ..."} 
 -- DI:gen: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if (V >  ...}" D ... true : ... false : ... 0 
 -- DI:add:BP4:  SQS 
 -- $ObjectGenerator:gen: "Q: obj ProcessQueue{   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if (V > ..."} 
 -- OG:gen: "Q: obj ProcessQueue{   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if (V > 1) :then ;    ...}" 
 pushThis 
 -- before objTmpStack:add:  77   "SQS" 
 invoke SQS 77 6 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $obj:gen: "coreLock: obj Lock("CoreLock")"  
 -- DI:gen: "coreLock: obj Lock("CoreLock")" DI:isConst: true :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  coreLock 
 -- $ObjectGenerator:gen: "Lock("CoreLock")" >OGid:"Lock" IS.isempty! staticOff=7 descNo=0 superAdj=0 
 -- OG:gen: "Lock("CoreLock")" 
 -- OG:before:super.gen: "Lock("CoreLock")" 
 -- $Invocation:gen: "Lock("CoreLock")" >useRtnV:"False"superAdj: 0 descNo: 76 
 -- INV:gen: "Lock("CoreLock")" 
 -- isConstant: "Invocation" "Lock("CoreLock")" 
 -- needorigin: "Lock("CoreLock")" 
 -- needOrigin:E: "Lock("CoreLock")"  E.ATd: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   g ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%globals{   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ; ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "Lock("CoreLock")" E:  "Lock("CoreLock")" 
 -- INV:gen:E.loadArgs "Lock("CoreLock")" 
 -- $ObjectInvocation_KeyWord:loadArgs: "Lock("CoreLock")" >staticOff:0 "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   in ..."} 
 -- $pattern:loadArgs: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ; ..."} 
 -- ptn:loadArgs:E "Lock("CoreLock")" 
 -- {(ObjectInvocation_KeyWord; (name: "Lock"); (Arguments;  (name: "Lock");  (name: "(");  (ObjectGenerator;   (Invocation;    (String: CoreLock));   (Items descNo: 0 origDes ...} 
 -- args: "Lock("CoreLock")" 
 -- E: "ObjectGenerator" "CoreLock" 
 -- E.arg: "var" in id: var String 
 -- NonVirt: "Lock("CoreLock")" "ObjectInvocation_KeyWord" ActArg:  ""CoreLock"" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "Lock("CoreLock")"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: ""CoreLock"" >OGid:"String" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: ""CoreLock"" 
 -- OG:before:super.gen: ""CoreLock"" 
 -- $Invocation:gen: ""CoreLock"" >useRtnV:"True"superAdj: 0 
 -- INV:gen: ""CoreLock"" 
 -- isConstant: "Invocation" ""CoreLock"" 
 -- needorigin: ""CoreLock"" 
 -- needOrigin:E: ""CoreLock""  E.ATd: "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V : ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  ""CoreLock"" E:  ""CoreLock"" 
 -- INV:gen:E.loadArgs ""CoreLock"" 
 -- $String::loadArgs: ""CoreLock""  
 -- INV:gen:after:E.loadArgs ""CoreLock"" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: String: ""CoreLock"" 
 -- $String::invoke: ""CoreLock""  
 pushText "CoreLock"
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in id: var String" :isBasicVal: false :valueObj: false 
 -- :actArg: ""CoreLock"" :isBasicVal: false 
 -- case:B: "CoreLock" ObjectGenerator 5 5 5 false false 
 -- end:loadArgs:NonVirt: "Lock("CoreLock")" 
 -- INV:gen:after:E.loadArgs "Lock("CoreLock")" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "Lock("CoreLock")" 
 -- $ObjectInvocation_KeyWord:invoke: "Lock("CoreLock")" >rec:"Lock("CoreLock")" ATd:"pattern" E:"Lock("CoreLock")" E.ATd:"Lock" unique:"False" 
 -- OI:invoke: "Lock("CoreLock")" 
 -- 
 -- OI:invoke:B: "Lock("CoreLock")" E: "Lock("CoreLock")"  rec: "Lock("CoreLock")"  useRtnV: false "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: v ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Lock 
 -- $pattern:invoke: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ;   ..."} 
 -- ptn:invoke: "Lock" E: "Lock("CoreLock")" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 7 adr:none 
 invoke Lock 76 7 1
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: Lock("CoreLock") :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- $obj:gen: "console: obj {   L: obj Lock("Console:lock");   %public;   display: ;      L.get;      inner(display);      L.free;   L.init" } 
 -- DI:gen: "console: obj {   L: obj Lock("Console:lock");   %public;   display: ;      L.get;      inner(display);      L.free;   L.init}" DI:isConst: true :isBasicValue: false : ... 0 
 -- DI:add:BP4:  console 
 -- $ObjectGenerator:gen: "L: obj Lock("Console:lock"){   %public;   display: ;      L.get;      inner(display);      L.free;   L.init" >OGid:"console" singular! staticOff=8 d ...} 
 -- OG:gen: "L: obj Lock("Console:lock"){   %public;   display: ;      L.get;      inner(display);      L.free;   L.init}" 
 pushThis 
 -- before objTmpStack:add:  80   "console" 
 invoke console 80 8 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -5 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $obj:gen: "keyboard: obj BasicProcess("Keyboard"){   B: obj Indexed(100,integer);   next: var integer;   top: var integer;   echo: var Boolean;   %Public;   Kscan: ;       ..."} 
 -- DI:gen: "keyboard: obj BasicProcess("Keyboard"){   B: obj Indexed(100,integer);   next: var integer;   top: var integer;   echo: var Boolean;   %Public;   Kscan: ;      lo ...}" D ... true : ... false : ... 0 
 -- DI:add:BP4:  keyboard 
 -- $ObjectGenerator:gen: "BasicProcess("Keyboard"){   B: obj Indexed(100,integer);   next: var integer;   top: var integer;   echo: var Boolean;   %Public;   Kscan: ;      lo ..."} 
 -- OG:gen: "BasicProcess("Keyboard"){   B: obj Indexed(100,integer);   next: var integer;   top: var integer;   echo: var Boolean;   %Public;   Kscan: ;      loopB: obj ;     ...}" 
 pushThis 
 -- before objTmpStack:add:  85   "keyboard" 
 invoke keyboard 85 9 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -6 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%public" 
 -- $Property:gen: "%public"  
 -- genclass:stmt: "init" 
 -- $ObjectGenerator:gen: "init" >OGid:"init" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "init" 
 -- OG:before:super.gen: "init" 
 -- $Invocation:gen: "init" >useRtnV:"False"superAdj: 0 descNo: 94 
 -- INV:gen: "init" 
 -- isConstant: "Invocation" "init" 
 -- needorigin: "init" 
 -- needOrigin:E: "init"  E.ATd: "init: {   SQS.init}" 
 -- doNeedOrigin:Ex: "init" 
 -- computeAdr:superAdj: 0 "init" 
 -- computeAdr: 1 :rec: "none"  E: "init" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "init"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "init" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "init" >ATd.off:0 (isPtn):on:0:superAdj:0"init: {   SQS.init":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origin ...} 
 -- $pattern:getAdr: "init: {   SQS.init" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:- 
 -- computeAdr:isLast:E:  "init" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:- 
 -- rec:  "init" E:  "init" 
 -- INV:gen:E.loadArgs "init" 
 -- $ObjectInvocation_Unary:loadArgs: "init" >staticOff:0 "init: {   SQS.init" superAdj:0} 
 -- $pattern:loadArgs: "init: {   SQS.init" >E:"init":descNo:94} 
 -- ptn:loadArgs:E "init" 
 -- {(ObjectInvocation_Unary; (name: "init"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "init" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "init" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:- 
 -- $ObjectInvocation_Unary:invoke: "init" >rec:"init" ATd:"pattern" E:"init" E.ATd:"init" unique:"False" 
 -- OI:invoke: "init" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:init 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:init 
 -- OI:invoke:B: "init" E: "init"  rec: "init"  useRtnV: false "init: {   SQS.init}" 
 -- OI:invoke:before:ATdx.invoke: pattern init 
 -- $pattern:invoke: "init: {   SQS.init" E: "init" useRTNv: "False"} 
 -- ptn:invoke: "init" E: "init" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:init 
 invoke init 94 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -7 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:init 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:init 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: init :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:init 
 -- genclass:stmt: "inner(BasicSystem)" 
 -- $ObjectGenerator:gen: "inner(BasicSystem)" >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inner(BasicSystem)" 
 -- OG:before:super.gen: "inner(BasicSystem)" 
 -- $Invocation:gen: "inner(BasicSystem)" >useRtnV:"False"superAdj: 0 descNo: 12 
 -- INV:gen: "inner(BasicSystem)" 
 -- isConstant: "Invocation" "inner(BasicSystem)" 
 -- needorigin: "inner(BasicSystem)" 
 -- needOrigin:E: "inner(BasicSystem)"  E.ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- doNeedOrigin:Ex: "inner(BasicSystem)" 
 -- computeAdr:superAdj: 0 "inner(BasicSystem)" 
 -- computeAdr: 1 :rec: "none"  E: "inner(BasicSystem)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "inner(BasicSystem)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "inner(BasicSystem)" >on:2 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "inner(BasicSystem)" >ATd.off:0 (isPtn):on:2:superAdj:0"inner: {   %basic 101;   in inner: ref Object":Adr:off:0 size:0 isFloat:F isUnitV ...} 
 -- $pattern:getAdr: "inner: {   %basic 101;   in inner: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(BasicSystem)":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inner(BasicSystem)"  ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(BasicSystem)":rec:- 
 -- computeAdr:isLast:E:  "inner(BasicSystem)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(BasicSystem)":rec:- 
 -- rec:  "inner(BasicSystem)" E:  "inner(BasicSystem)" 
 -- INV:gen:E.loadArgs "inner(BasicSystem)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "inner(BasicSystem)" >staticOff:0 "inner: {   %basic 101;   in inner: ref Object" superAdj:0arg:"BasicSystem"} 
 -- $pattern:loadArgs: "inner: {   %basic 101;   in inner: ref Object" >E:"inner(BasicSystem)":descNo:12} 
 -- INV:gen:after:E.loadArgs "inner(BasicSystem)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(BasicSystem)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"in ..." 
 -- $ObjectInvocation_KeyWord:invoke: "inner(BasicSystem)" >rec:"inner(BasicSystem)" ATd:"pattern" E:"inner(BasicSystem)" E.ATd:"inner" unique:"False" 
 -- OI:invoke: "inner(BasicSystem)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(BasicSystem)":rec:inner(BasicSystem) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(BasicSystem)":rec:inner(BasicSystem) 
 -- OI:invoke:B: "inner(BasicSystem)" E: "inner(BasicSystem)"  rec: "inner(BasicSystem)"  useRtnV: false "inner: {   %basic 101;   in inner: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- $pattern:invoke: "inner: {   %basic 101;   in inner: ref Object" E: "inner(BasicSystem)" useRTNv: "False"} 
 -- ptn:invoke: "inner" E: "inner(BasicSystem)" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(BasicSystem)":rec:inner(BasicSystem) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(BasicSystem)":rec:inner(BasicSystem) 
 -- 
 -- OI:invoke:C: inner(BasicSystem) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(BasicSystem)":rec:inner(BasicSystem) 
 -- genclass:stmt: "cores.init" 
 -- $ObjectGenerator:gen: "cores.init" >OGid:"init" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "cores.init" 
 -- OG:before:super.gen: "cores.init" 
 -- $Invocation:gen: "cores.init" >useRtnV:"False"superAdj: 0 descNo: 111 
 -- INV:gen: "cores.init" 
 -- isConstant: "Invocation" "cores.init" 
 -- needorigin: "cores.init" 
 -- needOrigin:E: "init"  E.ATd: "init: {   S: ref Scheduler;   C1 := Core;   fork(C1);   C2 := Core;   fork(C2);   C3 := Core;   fork(C3);   C4 := Core;   fork(C4);   S := Sc ...}" 
 -- doNeedOrigin:Ex: "init" 
 -- computeAdr:superAdj: 0 "cores.init" 
 -- computeAdr: 1 :rec: "none"  E: "cores" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "cores"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "cores" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "cores" >ATd.off:3:on:0:superAdj:0"cores: obj {   C1: ref Core;   C2: ref Core;   C3: ref Core;   C4: ref Core;   -- should be array        ..."} 
 -- $obj:getAdr: "cores: obj {   C1: ref Core;   C2: ref Core;   C3: ref Core;   C4: ref Core;   -- should be array         ;   init: ;      S: ref Scheduler;      C1 := Core; ..."} 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "cores"  E: "init" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "init" >ATd.off:0 (isPtn):on:0:superAdj:0"init: {   S: ref Scheduler;   C1 := Core;   fork(C1);   C2 := Core;   fork(C2);   C3 := Core;   f ..."} 
 -- $pattern:getAdr: "init: {   S: ref Scheduler;   C1 := Core;   fork(C1);   C2 := Core;   fork(C2);   C3 := Core;   fork(C3);   C4 := Core;   fork(C4);   S := Scheduler;   C ..."} 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "cores" >staticOff:0 "cores: obj {   C1: ref Core;   C2: ref Core;   C3: ref Core;   C4: ref Core;   -- should be array         ;   init: ..."} 
 -- $obj:loadArgs: "cores: obj {   C1: ref Core;   C2: ref Core;   C3: ref Core;   C4: ref Core;   -- should be array         ;   init: ;      S: ref Scheduler;      C1 := Cor ..."} 
 -- $ObjectInvocation_Unary:invoke: "cores" >rec:"cores" ATd:"obj" E:"init" E.ATd:"init" unique:"False" 
 -- OI:invoke: "cores" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:cores 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:cores 
 -- OI:invoke:B: "cores" E: "init"  rec: "cores"  useRtnV: true "cores: obj {   C1: ref Core;   C2: ref Core;   C3: ref Core;   C4: ref Core;   -- should be array         ;    ...}" 
 -- OI:invoke:before:ATdx.invoke: obj cores 
 -- $obj:invoke: "cores: obj {   C1: ref Core;   C2: ref Core;   C3: ref Core;   C4: ref Core;   -- should be array         ;   init: ;      S: ref Scheduler;      C1 := Core; ..."} 
 -- DI:invoke: "cores: obj {   C1: ref Core;   C2: ref Core;   C3: ref Core;   C4: ref Core;   -- should be array         ;   init: ;      S: ref Scheduler;      C1 := Core;   ...}" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:cores 
 rpushg BasicSystem$72 3
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:cores 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:cores 
 -- 
 -- OI:invoke:C: cores :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "cores" E: "init" 
 -- computeAdr:isLast:E:  "init" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:cores 
 -- rec:  "cores" E:  "init" 
 -- INV:gen:E.loadArgs "init" 
 -- $ObjectInvocation_Unary:loadArgs: "init" >staticOff:0 "init: {   S: ref Scheduler;   C1 := Core;   fork(C1);   C2 := Core;   fork(C2);   C3 := Core;   fork(C3);   C4 := Co ..."} 
 -- $pattern:loadArgs: "init: {   S: ref Scheduler;   C1 := Core;   fork(C1);   C2 := Core;   fork(C2);   C3 := Core;   fork(C3);   C4 := Core;   fork(C4);   S := Scheduler;   ..."} 
 -- ptn:loadArgs:E "init" 
 -- {(ObjectInvocation_Unary; (name: "init"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "init" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "init" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:cores 
 -- $ObjectInvocation_Unary:invoke: "init" >rec:"cores" ATd:"pattern" E:"init" E.ATd:"init" unique:"False" 
 -- OI:invoke: "init" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:cores 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:cores 
 -- OI:invoke:B: "init" E: "init"  rec: "cores"  useRtnV: false "init: {   S: ref Scheduler;   C1 := Core;   fork(C1);   C2 := Core;   fork(C2);   C3 := Core;   fork(C3);   C4 ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern init 
 -- $pattern:invoke: "init: {   S: ref Scheduler;   C1 := Core;   fork(C1);   C2 := Core;   fork(C2);   C3 := Core;   fork(C3);   C4 := Core;   fork(C4);   S := Scheduler;   C ..."} 
 -- ptn:invoke: "init" E: "init" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:cores 
 invoke init 111 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -8 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:cores 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:cores 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: init :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:cores 
 L2:
 -- pushReturn:  "BasicSystem" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:9 isIndexed:0
 -- vdtAdd: inx=2 descInx=72 vDescInx=0 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 73 
 -- Items:GenClass: cores descNo: 73 isValue: false 
 -- Items:GenClass: cores descNo: 21 isValue: false 

 CLASS cores 73 1 BasicSystem 72
 -- Store itemArgs: C1: ref Core{C2: ref Core;C3: ref Core;C4: ref Core;-- should be array         ;init: ;   S: ref Scheduler;   C1 := Core;   fork(C1);   C2 := Core;   fork( ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=73 vDescInx=73 vdtTop: 1 
 mvStack 
 -- $ref:gen: "C1: ref Core"  
 -- DI:gen: "C1: ref Core" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- $ref:gen: "C2: ref Core"  
 -- DI:gen: "C2: ref Core" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- $ref:gen: "C3: ref Core"  
 -- DI:gen: "C3: ref Core" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- $ref:gen: "C4: ref Core{-- should be array         " } 
 -- DI:gen: "C4: ref Core{-- should be array         }" DI:isConst: false :isBasicValue: false :primNo: 0 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 -- pushReturn:  "cores" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 112 
 -- Items:GenClass: SuperCore descNo: 112 isValue: false 
 -- Items:GenClass: SuperCore descNo: 21 isValue: false 

 CLASS SuperCore 112 1 BETA 2
 -- Store itemArgs: %core 16{main: ref SuperScheduler;inner(SuperCore)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=112 vDescInx=112 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%core 16"  
 -- $ref:gen: "main: ref SuperScheduler"  
 -- DI:gen: "main: ref SuperScheduler" DI:isConst: false :isBasicValue: false :primNo: 0 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%core 16" 
 -- $Property:gen: "%core 16"  
 -- genclass:stmt: "inner(SuperCore)" 
 -- $ObjectGenerator:gen: "inner(SuperCore)" >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inner(SuperCore)" 
 -- OG:before:super.gen: "inner(SuperCore)" 
 -- $Invocation:gen: "inner(SuperCore)" >useRtnV:"False"superAdj: 0 descNo: 12 
 -- INV:gen: "inner(SuperCore)" 
 -- isConstant: "Invocation" "inner(SuperCore)" 
 -- needorigin: "inner(SuperCore)" 
 -- needOrigin:E: "inner(SuperCore)"  E.ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- doNeedOrigin:Ex: "inner(SuperCore)" 
 -- computeAdr:superAdj: 0 "inner(SuperCore)" 
 -- computeAdr: 1 :rec: "none"  E: "inner(SuperCore)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "inner(SuperCore)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "inner(SuperCore)" >on:1 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "inner(SuperCore)" >ATd.off:0 (isPtn):on:1:superAdj:0"inner: {   %basic 101;   in inner: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal ...} 
 -- $pattern:getAdr: "inner: {   %basic 101;   in inner: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(SuperCore)":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inner(SuperCore)"  ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(SuperCore)":rec:- 
 -- computeAdr:isLast:E:  "inner(SuperCore)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(SuperCore)":rec:- 
 -- rec:  "inner(SuperCore)" E:  "inner(SuperCore)" 
 -- INV:gen:E.loadArgs "inner(SuperCore)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "inner(SuperCore)" >staticOff:0 "inner: {   %basic 101;   in inner: ref Object" superAdj:0arg:"SuperCore"} 
 -- $pattern:loadArgs: "inner: {   %basic 101;   in inner: ref Object" >E:"inner(SuperCore)":descNo:12} 
 -- INV:gen:after:E.loadArgs "inner(SuperCore)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(SuperCore)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inne ..." 
 -- $ObjectInvocation_KeyWord:invoke: "inner(SuperCore)" >rec:"inner(SuperCore)" ATd:"pattern" E:"inner(SuperCore)" E.ATd:"inner" unique:"False" 
 -- OI:invoke: "inner(SuperCore)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(SuperCore)":rec:inner(SuperCore) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(SuperCore)":rec:inner(SuperCore) 
 -- OI:invoke:B: "inner(SuperCore)" E: "inner(SuperCore)"  rec: "inner(SuperCore)"  useRtnV: false "inner: {   %basic 101;   in inner: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- $pattern:invoke: "inner: {   %basic 101;   in inner: ref Object" E: "inner(SuperCore)" useRTNv: "False"} 
 -- ptn:invoke: "inner" E: "inner(SuperCore)" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(SuperCore)":rec:inner(SuperCore) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(SuperCore)":rec:inner(SuperCore) 
 -- 
 -- OI:invoke:C: inner(SuperCore) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(SuperCore)":rec:inner(SuperCore) 
 L2:
 -- pushReturn:  "SuperCore" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- vdtAdd: inx=2 descInx=112 vDescInx=0 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 122 
 -- Items:GenClass: SuperScheduler descNo: 122 isValue: false 
 -- Items:GenClass: SuperScheduler descNo: 21 isValue: false 

 CLASS SuperScheduler 122 1 BETA 2
 -- Store itemArgs: thisScheduler:< Object{ProcessType:< GeneralProcess;active: ref ProcessType;inner(SuperScheduler)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=122 vDescInx=122 vdtTop: 1 
 mvStack 
 -- $pattern:gen: "thisScheduler:< Object"  
 -- $pattern:gen: "ProcessType:< GeneralProcess"  
 -- $ref:gen: "active: ref ProcessType"  
 -- DI:gen: "active: ref ProcessType" DI:isConst: false :isBasicValue: false :primNo: 0 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "inner(SuperScheduler)" 
 -- $ObjectGenerator:gen: "inner(SuperScheduler)" >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inner(SuperScheduler)" 
 -- OG:before:super.gen: "inner(SuperScheduler)" 
 -- $Invocation:gen: "inner(SuperScheduler)" >useRtnV:"False"superAdj: 0 descNo: 12 
 -- INV:gen: "inner(SuperScheduler)" 
 -- isConstant: "Invocation" "inner(SuperScheduler)" 
 -- needorigin: "inner(SuperScheduler)" 
 -- needOrigin:E: "inner(SuperScheduler)"  E.ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- doNeedOrigin:Ex: "inner(SuperScheduler)" 
 -- computeAdr:superAdj: 0 "inner(SuperScheduler)" 
 -- computeAdr: 1 :rec: "none"  E: "inner(SuperScheduler)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "inner(SuperScheduler)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "inner(SuperScheduler)" >on:1 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "inner(SuperScheduler)" >ATd.off:0 (isPtn):on:1:superAdj:0"inner: {   %basic 101;   in inner: ref Object":Adr:off:0 size:0 isFloat:F isUn ...} 
 -- $pattern:getAdr: "inner: {   %basic 101;   in inner: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(SuperScheduler)":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inner(SuperScheduler)"  ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(SuperScheduler)":rec:- 
 -- computeAdr:isLast:E:  "inner(SuperScheduler)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(SuperScheduler)":rec:- 
 -- rec:  "inner(SuperScheduler)" E:  "inner(SuperScheduler)" 
 -- INV:gen:E.loadArgs "inner(SuperScheduler)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "inner(SuperScheduler)" >staticOff:0 "inner: {   %basic 101;   in inner: ref Object" superAdj:0arg:"SuperScheduler"} 
 -- $pattern:loadArgs: "inner: {   %basic 101;   in inner: ref Object" >E:"inner(SuperScheduler)":descNo:12} 
 -- INV:gen:after:E.loadArgs "inner(SuperScheduler)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(SuperScheduler)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E: ... 
 -- $ObjectInvocation_KeyWord:invoke: "inner(SuperScheduler)" >rec:"inner(SuperScheduler)" ATd:"pattern" E:"inner(SuperScheduler)" E.ATd:"inner" unique:"False" 
 -- OI:invoke: "inner(SuperScheduler)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(SuperScheduler)":rec:inner(SuperScheduler) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(SuperScheduler)":rec:inner(SuperScheduler) 
 -- OI:invoke:B: "inner(SuperScheduler)" E: "inner(SuperScheduler)"  rec: "inner(SuperScheduler)"  useRtnV: false "inner: {   %basic 101;   in inner: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- $pattern:invoke: "inner: {   %basic 101;   in inner: ref Object" E: "inner(SuperScheduler)" useRTNv: "False"} 
 -- ptn:invoke: "inner" E: "inner(SuperScheduler)" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  4
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(SuperScheduler)":rec:inner(SuperScheduler) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(SuperScheduler)":rec:inner(SuperScheduler) 
 -- 
 -- OI:invoke:C: inner(SuperScheduler) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(SuperScheduler)":rec:inner(SuperScheduler) 
 L2:
 -- pushReturn:  "SuperScheduler" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- vdtAdd: inx=4 descInx=122 vDescInx=0 vdtTop: 4 
 -- vdtAdd: inx=2 descInx=122 vDescInx=123 vdtTop: 4 
 -- vdtAdd: inx=3 descInx=122 vDescInx=124 vdtTop: 4 

 CLASS thisScheduler#123 123 1 SuperScheduler$122 122 isVstub
 -- Load origin:OG.isVirtualArg: false 
 -- OG.super.on/descNo: 1 21 
 invoke Object 21 0 1
 pushThis 
 rstoreg   2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- vdt:a:dNo: 123  newDescNo:  122 

 CLASS ProcessType#124 124 1 SuperScheduler$122 122 isVstub
 -- Load origin:OG.isVirtualArg: false 
 -- items:goOrigin:encOG: "SuperScheduler" on: 1 isValueObj: false 
 -- origin: BETA origin:isValueObj: false 
 rpushg SuperScheduler$122 1
 -- OG.super.on/descNo: 1 82 
 invoke GeneralProcess 82 0 1
 pushThis 
 rstoreg   2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- vdt:a:dNo: 124  newDescNo:  122 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 82 
 -- Items:GenClass: GeneralProcess descNo: 82 isValue: false 
 -- Items:GenClass: GeneralProcess descNo: 21 isValue: false 

 CLASS GeneralProcess 82 1 BETA 2
 -- Store itemArgs: start:< {   inner(start);mkActive:< ;   inner(mkActive);addWaiting:< ;   --put('q')inner(addWaiting);   --put('R');dcrWaiting:< ;   inner(dcrWaiting);displ ...} 
 -- id: var LIB.StringLib.String true 5 
 pushThis 
 rstoreg  id 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=82 vDescInx=82 vdtTop: 1 
 mvStack 
 -- $pattern:gen: "start:< {   inner(start)" } 
 -- $pattern:gen: "mkActive:< {   inner(mkActive)" } 
 -- $pattern:gen: "addWaiting:< {   --put('q')inner(addWaiting);   --put('R')" } 
 -- $pattern:gen: "dcrWaiting:< {   inner(dcrWaiting)" } 
 -- $pattern:gen: "display:< {   "\n---GP:---".print;   inner(display)" } 
 -- $var:gen: "status: var integer"  
 -- DI:gen: "status: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  status 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "inner(GeneralProcess)" 
 -- $ObjectGenerator:gen: "inner(GeneralProcess)" >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inner(GeneralProcess)" 
 -- OG:before:super.gen: "inner(GeneralProcess)" 
 -- $Invocation:gen: "inner(GeneralProcess)" >useRtnV:"False"superAdj: 0 descNo: 12 
 -- INV:gen: "inner(GeneralProcess)" 
 -- isConstant: "Invocation" "inner(GeneralProcess)" 
 -- needorigin: "inner(GeneralProcess)" 
 -- needOrigin:E: "inner(GeneralProcess)"  E.ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- doNeedOrigin:Ex: "inner(GeneralProcess)" 
 -- computeAdr:superAdj: 0 "inner(GeneralProcess)" 
 -- computeAdr: 1 :rec: "none"  E: "inner(GeneralProcess)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "inner(GeneralProcess)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "inner(GeneralProcess)" >on:1 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "inner(GeneralProcess)" >ATd.off:0 (isPtn):on:1:superAdj:0"inner: {   %basic 101;   in inner: ref Object":Adr:off:0 size:0 isFloat:F isUn ...} 
 -- $pattern:getAdr: "inner: {   %basic 101;   in inner: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(GeneralProcess)":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inner(GeneralProcess)"  ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(GeneralProcess)":rec:- 
 -- computeAdr:isLast:E:  "inner(GeneralProcess)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(GeneralProcess)":rec:- 
 -- rec:  "inner(GeneralProcess)" E:  "inner(GeneralProcess)" 
 -- INV:gen:E.loadArgs "inner(GeneralProcess)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "inner(GeneralProcess)" >staticOff:0 "inner: {   %basic 101;   in inner: ref Object" superAdj:0arg:"GeneralProcess"} 
 -- $pattern:loadArgs: "inner: {   %basic 101;   in inner: ref Object" >E:"inner(GeneralProcess)":descNo:12} 
 -- INV:gen:after:E.loadArgs "inner(GeneralProcess)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(GeneralProcess)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E: ... 
 -- $ObjectInvocation_KeyWord:invoke: "inner(GeneralProcess)" >rec:"inner(GeneralProcess)" ATd:"pattern" E:"inner(GeneralProcess)" E.ATd:"inner" unique:"False" 
 -- OI:invoke: "inner(GeneralProcess)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(GeneralProcess)":rec:inner(GeneralProcess) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(GeneralProcess)":rec:inner(GeneralProcess) 
 -- OI:invoke:B: "inner(GeneralProcess)" E: "inner(GeneralProcess)"  rec: "inner(GeneralProcess)"  useRtnV: false "inner: {   %basic 101;   in inner: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- $pattern:invoke: "inner: {   %basic 101;   in inner: ref Object" E: "inner(GeneralProcess)" useRTNv: "False"} 
 -- ptn:invoke: "inner" E: "inner(GeneralProcess)" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  7
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(GeneralProcess)":rec:inner(GeneralProcess) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(GeneralProcess)":rec:inner(GeneralProcess) 
 -- 
 -- OI:invoke:C: inner(GeneralProcess) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(GeneralProcess)":rec:inner(GeneralProcess) 
 L2:
 -- pushReturn:  "GeneralProcess" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- vdtAdd: inx=7 descInx=82 vDescInx=0 vdtTop: 7 
 -- vdtAdd: inx=2 descInx=82 vDescInx=132 vdtTop: 7 
 -- vdtAdd: inx=3 descInx=82 vDescInx=133 vdtTop: 7 
 -- vdtAdd: inx=4 descInx=82 vDescInx=134 vdtTop: 7 
 -- vdtAdd: inx=5 descInx=82 vDescInx=135 vdtTop: 7 
 -- vdtAdd: inx=6 descInx=82 vDescInx=136 vdtTop: 7 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 132 
 -- Items:GenClass: start descNo: 132 isValue: false 
 -- Items:GenClass: start descNo: 21 isValue: false 

 CLASS start 132 1 GeneralProcess 82
 -- Store itemArgs: inner(start) 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=132 vDescInx=132 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "inner(start)" 
 -- $ObjectGenerator:gen: "inner(start)" >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inner(start)" 
 -- OG:before:super.gen: "inner(start)" 
 -- $Invocation:gen: "inner(start)" >useRtnV:"False"superAdj: 0 descNo: 12 
 -- INV:gen: "inner(start)" 
 -- isConstant: "Invocation" "inner(start)" 
 -- needorigin: "inner(start)" 
 -- needOrigin:E: "inner(start)"  E.ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- doNeedOrigin:Ex: "inner(start)" 
 -- computeAdr:superAdj: 0 "inner(start)" 
 -- computeAdr: 1 :rec: "none"  E: "inner(start)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "inner(start)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "inner(start)" >on:2 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "inner(start)" >ATd.off:0 (isPtn):on:2:superAdj:0"inner: {   %basic 101;   in inner: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal:F s ...} 
 -- $pattern:getAdr: "inner: {   %basic 101;   in inner: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(start)":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inner(start)"  ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(start)":rec:- 
 -- computeAdr:isLast:E:  "inner(start)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(start)":rec:- 
 -- rec:  "inner(start)" E:  "inner(start)" 
 -- INV:gen:E.loadArgs "inner(start)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "inner(start)" >staticOff:0 "inner: {   %basic 101;   in inner: ref Object" superAdj:0arg:"start"} 
 -- $pattern:loadArgs: "inner: {   %basic 101;   in inner: ref Object" >E:"inner(start)":descNo:12} 
 -- INV:gen:after:E.loadArgs "inner(start)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(start)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(st ..." 
 -- $ObjectInvocation_KeyWord:invoke: "inner(start)" >rec:"inner(start)" ATd:"pattern" E:"inner(start)" E.ATd:"inner" unique:"False" 
 -- OI:invoke: "inner(start)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(start)":rec:inner(start) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(start)":rec:inner(start) 
 -- OI:invoke:B: "inner(start)" E: "inner(start)"  rec: "inner(start)"  useRtnV: false "inner: {   %basic 101;   in inner: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- $pattern:invoke: "inner: {   %basic 101;   in inner: ref Object" E: "inner(start)" useRTNv: "False"} 
 -- ptn:invoke: "inner" E: "inner(start)" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(start)":rec:inner(start) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(start)":rec:inner(start) 
 -- 
 -- OI:invoke:C: inner(start) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(start)":rec:inner(start) 
 L2:
 -- pushReturn:  "start" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- vdtAdd: inx=2 descInx=132 vDescInx=0 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 133 
 -- Items:GenClass: mkActive descNo: 133 isValue: false 
 -- Items:GenClass: mkActive descNo: 21 isValue: false 

 CLASS mkActive 133 1 GeneralProcess 82
 -- Store itemArgs: inner(mkActive) 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=133 vDescInx=133 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "inner(mkActive)" 
 -- $ObjectGenerator:gen: "inner(mkActive)" >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inner(mkActive)" 
 -- OG:before:super.gen: "inner(mkActive)" 
 -- $Invocation:gen: "inner(mkActive)" >useRtnV:"False"superAdj: 0 descNo: 12 
 -- INV:gen: "inner(mkActive)" 
 -- isConstant: "Invocation" "inner(mkActive)" 
 -- needorigin: "inner(mkActive)" 
 -- needOrigin:E: "inner(mkActive)"  E.ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- doNeedOrigin:Ex: "inner(mkActive)" 
 -- computeAdr:superAdj: 0 "inner(mkActive)" 
 -- computeAdr: 1 :rec: "none"  E: "inner(mkActive)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "inner(mkActive)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "inner(mkActive)" >on:2 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "inner(mkActive)" >ATd.off:0 (isPtn):on:2:superAdj:0"inner: {   %basic 101;   in inner: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal: ...} 
 -- $pattern:getAdr: "inner: {   %basic 101;   in inner: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(mkActive)":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inner(mkActive)"  ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(mkActive)":rec:- 
 -- computeAdr:isLast:E:  "inner(mkActive)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(mkActive)":rec:- 
 -- rec:  "inner(mkActive)" E:  "inner(mkActive)" 
 -- INV:gen:E.loadArgs "inner(mkActive)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "inner(mkActive)" >staticOff:0 "inner: {   %basic 101;   in inner: ref Object" superAdj:0arg:"mkActive"} 
 -- $pattern:loadArgs: "inner: {   %basic 101;   in inner: ref Object" >E:"inner(mkActive)":descNo:12} 
 -- INV:gen:after:E.loadArgs "inner(mkActive)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(mkActive)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner ..." 
 -- $ObjectInvocation_KeyWord:invoke: "inner(mkActive)" >rec:"inner(mkActive)" ATd:"pattern" E:"inner(mkActive)" E.ATd:"inner" unique:"False" 
 -- OI:invoke: "inner(mkActive)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(mkActive)":rec:inner(mkActive) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(mkActive)":rec:inner(mkActive) 
 -- OI:invoke:B: "inner(mkActive)" E: "inner(mkActive)"  rec: "inner(mkActive)"  useRtnV: false "inner: {   %basic 101;   in inner: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- $pattern:invoke: "inner: {   %basic 101;   in inner: ref Object" E: "inner(mkActive)" useRTNv: "False"} 
 -- ptn:invoke: "inner" E: "inner(mkActive)" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(mkActive)":rec:inner(mkActive) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(mkActive)":rec:inner(mkActive) 
 -- 
 -- OI:invoke:C: inner(mkActive) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(mkActive)":rec:inner(mkActive) 
 L2:
 -- pushReturn:  "mkActive" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- vdtAdd: inx=2 descInx=133 vDescInx=0 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 134 
 -- Items:GenClass: addWaiting descNo: 134 isValue: false 
 -- Items:GenClass: addWaiting descNo: 21 isValue: false 

 CLASS addWaiting 134 1 GeneralProcess 82
 -- Store itemArgs: --put('q')inner(addWaiting){--put('R')} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=134 vDescInx=134 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "inner(addWaiting){--put('R')}" 
 -- $ObjectGenerator:gen: "inner(addWaiting){--put('R')" >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "inner(addWaiting){--put('R')}" 
 -- OG:before:super.gen: "inner(addWaiting){--put('R')}" 
 -- $Invocation:gen: "inner(addWaiting){--put('R')" >useRtnV:"False"superAdj: 0 descNo: 12} 
 -- INV:gen: "inner(addWaiting){--put('R')}" 
 -- isConstant: "Invocation" "inner(addWaiting){--put('R')}" 
 -- needorigin: "inner(addWaiting){--put('R')}" 
 -- needOrigin:E: "inner(addWaiting)"  E.ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- doNeedOrigin:Ex: "inner(addWaiting)" 
 -- computeAdr:superAdj: 0 "inner(addWaiting){--put('R')}" 
 -- computeAdr: 1 :rec: "none"  E: "inner(addWaiting)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "inner(addWaiting)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "inner(addWaiting)" >on:2 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "inner(addWaiting)" >ATd.off:0 (isPtn):on:2:superAdj:0"inner: {   %basic 101;   in inner: ref Object":Adr:off:0 size:0 isFloat:F isUnitVa ...} 
 -- $pattern:getAdr: "inner: {   %basic 101;   in inner: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(addWaiting)":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inner(addWaiting)"  ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(addWaiting)":rec:- 
 -- computeAdr:isLast:E:  "inner(addWaiting)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(addWaiting)":rec:- 
 -- rec:  "inner(addWaiting)" E:  "inner(addWaiting)" 
 -- INV:gen:E.loadArgs "inner(addWaiting)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "inner(addWaiting)" >staticOff:0 "inner: {   %basic 101;   in inner: ref Object" superAdj:0arg:"addWaiting"} 
 -- $pattern:loadArgs: "inner: {   %basic 101;   in inner: ref Object" >E:"inner(addWaiting)":descNo:12} 
 -- INV:gen:after:E.loadArgs "inner(addWaiting)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(addWaiting)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inn ..." 
 -- $ObjectInvocation_KeyWord:invoke: "inner(addWaiting)" >rec:"inner(addWaiting)" ATd:"pattern" E:"inner(addWaiting)" E.ATd:"inner" unique:"False" 
 -- OI:invoke: "inner(addWaiting)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(addWaiting)":rec:inner(addWaiting) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(addWaiting)":rec:inner(addWaiting) 
 -- OI:invoke:B: "inner(addWaiting)" E: "inner(addWaiting)"  rec: "inner(addWaiting)"  useRtnV: false "inner: {   %basic 101;   in inner: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- $pattern:invoke: "inner: {   %basic 101;   in inner: ref Object" E: "inner(addWaiting)" useRTNv: "False"} 
 -- ptn:invoke: "inner" E: "inner(addWaiting)" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(addWaiting)":rec:inner(addWaiting) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(addWaiting)":rec:inner(addWaiting) 
 -- 
 -- OI:invoke:C: inner(addWaiting) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(addWaiting)":rec:inner(addWaiting) 
 L2:
 -- pushReturn:  "addWaiting" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- vdtAdd: inx=2 descInx=134 vDescInx=0 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 135 
 -- Items:GenClass: dcrWaiting descNo: 135 isValue: false 
 -- Items:GenClass: dcrWaiting descNo: 21 isValue: false 

 CLASS dcrWaiting 135 1 GeneralProcess 82
 -- Store itemArgs: inner(dcrWaiting) 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=135 vDescInx=135 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "inner(dcrWaiting)" 
 -- $ObjectGenerator:gen: "inner(dcrWaiting)" >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inner(dcrWaiting)" 
 -- OG:before:super.gen: "inner(dcrWaiting)" 
 -- $Invocation:gen: "inner(dcrWaiting)" >useRtnV:"False"superAdj: 0 descNo: 12 
 -- INV:gen: "inner(dcrWaiting)" 
 -- isConstant: "Invocation" "inner(dcrWaiting)" 
 -- needorigin: "inner(dcrWaiting)" 
 -- needOrigin:E: "inner(dcrWaiting)"  E.ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- doNeedOrigin:Ex: "inner(dcrWaiting)" 
 -- computeAdr:superAdj: 0 "inner(dcrWaiting)" 
 -- computeAdr: 1 :rec: "none"  E: "inner(dcrWaiting)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "inner(dcrWaiting)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "inner(dcrWaiting)" >on:2 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "inner(dcrWaiting)" >ATd.off:0 (isPtn):on:2:superAdj:0"inner: {   %basic 101;   in inner: ref Object":Adr:off:0 size:0 isFloat:F isUnitVa ...} 
 -- $pattern:getAdr: "inner: {   %basic 101;   in inner: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(dcrWaiting)":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inner(dcrWaiting)"  ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(dcrWaiting)":rec:- 
 -- computeAdr:isLast:E:  "inner(dcrWaiting)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(dcrWaiting)":rec:- 
 -- rec:  "inner(dcrWaiting)" E:  "inner(dcrWaiting)" 
 -- INV:gen:E.loadArgs "inner(dcrWaiting)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "inner(dcrWaiting)" >staticOff:0 "inner: {   %basic 101;   in inner: ref Object" superAdj:0arg:"dcrWaiting"} 
 -- $pattern:loadArgs: "inner: {   %basic 101;   in inner: ref Object" >E:"inner(dcrWaiting)":descNo:12} 
 -- INV:gen:after:E.loadArgs "inner(dcrWaiting)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(dcrWaiting)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inn ..." 
 -- $ObjectInvocation_KeyWord:invoke: "inner(dcrWaiting)" >rec:"inner(dcrWaiting)" ATd:"pattern" E:"inner(dcrWaiting)" E.ATd:"inner" unique:"False" 
 -- OI:invoke: "inner(dcrWaiting)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(dcrWaiting)":rec:inner(dcrWaiting) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(dcrWaiting)":rec:inner(dcrWaiting) 
 -- OI:invoke:B: "inner(dcrWaiting)" E: "inner(dcrWaiting)"  rec: "inner(dcrWaiting)"  useRtnV: false "inner: {   %basic 101;   in inner: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- $pattern:invoke: "inner: {   %basic 101;   in inner: ref Object" E: "inner(dcrWaiting)" useRTNv: "False"} 
 -- ptn:invoke: "inner" E: "inner(dcrWaiting)" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(dcrWaiting)":rec:inner(dcrWaiting) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(dcrWaiting)":rec:inner(dcrWaiting) 
 -- 
 -- OI:invoke:C: inner(dcrWaiting) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(dcrWaiting)":rec:inner(dcrWaiting) 
 L2:
 -- pushReturn:  "dcrWaiting" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- vdtAdd: inx=2 descInx=135 vDescInx=0 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 136 
 -- Items:GenClass: display descNo: 136 isValue: false 
 -- Items:GenClass: display descNo: 21 isValue: false 

 CLASS display 136 1 GeneralProcess 82
 -- Store itemArgs: "\n---GP:---".print{inner(display)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=136 vDescInx=136 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: ""\n---GP:---".print" 
 -- $ObjectGenerator:gen: ""\n---GP:---".print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: ""\n---GP:---".print" 
 -- OG:before:super.gen: ""\n---GP:---".print" 
 -- $Invocation:gen: ""\n---GP:---".print" >useRtnV:"False"superAdj: 0 descNo: 103 
 -- INV:gen: ""\n---GP:---".print" 
 -- isConstant: "Invocation" ""\n---GP:---".print" 
 -- needorigin: ""\n---GP:---".print" 
 -- needOrigin:E: "print"  E.ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  ""\n---GP:---"" E:  ""\n---GP:---"" 
 -- INV:gen:E.loadArgs ""\n---GP:---"" 
 -- $String::loadArgs: ""\n---GP:---""  
 -- INV:gen:after:E.loadArgs ""\n---GP:---"" 
 -- OIadr: 
 -- $String::invoke: ""\n---GP:---""  
 pushText "\n---GP:---"
 -- IV:gen:checkTail: ""\n---GP:---".print" E: ""\n---GP:---"" tail: "print"  not isLast: false 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " superAdj:0} 
 -- $pattern:loadArgs: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " >E:"print":descNo:103} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:""\n---GP:---"" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- 
 -- OI:invoke:B: "print" E: "print"  rec: ""\n---GP:---""  useRtnV: false "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke print 103 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "inner(display)" 
 -- $ObjectGenerator:gen: "inner(display)" >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inner(display)" 
 -- OG:before:super.gen: "inner(display)" 
 -- $Invocation:gen: "inner(display)" >useRtnV:"False"superAdj: 0 descNo: 12 
 -- INV:gen: "inner(display)" 
 -- isConstant: "Invocation" "inner(display)" 
 -- needorigin: "inner(display)" 
 -- needOrigin:E: "inner(display)"  E.ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- doNeedOrigin:Ex: "inner(display)" 
 -- computeAdr:superAdj: 0 "inner(display)" 
 -- computeAdr: 1 :rec: "none"  E: "inner(display)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "inner(display)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "inner(display)" >on:2 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "inner(display)" >ATd.off:0 (isPtn):on:2:superAdj:0"inner: {   %basic 101;   in inner: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal:F ...} 
 -- $pattern:getAdr: "inner: {   %basic 101;   in inner: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(display)":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inner(display)"  ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(display)":rec:- 
 -- computeAdr:isLast:E:  "inner(display)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(display)":rec:- 
 -- rec:  "inner(display)" E:  "inner(display)" 
 -- INV:gen:E.loadArgs "inner(display)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "inner(display)" >staticOff:0 "inner: {   %basic 101;   in inner: ref Object" superAdj:0arg:"display"} 
 -- $pattern:loadArgs: "inner: {   %basic 101;   in inner: ref Object" >E:"inner(display)":descNo:12} 
 -- INV:gen:after:E.loadArgs "inner(display)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(display)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner( ..." 
 -- $ObjectInvocation_KeyWord:invoke: "inner(display)" >rec:"inner(display)" ATd:"pattern" E:"inner(display)" E.ATd:"inner" unique:"False" 
 -- OI:invoke: "inner(display)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(display)":rec:inner(display) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(display)":rec:inner(display) 
 -- OI:invoke:B: "inner(display)" E: "inner(display)"  rec: "inner(display)"  useRtnV: false "inner: {   %basic 101;   in inner: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- $pattern:invoke: "inner: {   %basic 101;   in inner: ref Object" E: "inner(display)" useRTNv: "False"} 
 -- ptn:invoke: "inner" E: "inner(display)" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(display)":rec:inner(display) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(display)":rec:inner(display) 
 -- 
 -- OI:invoke:C: inner(display) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(display)":rec:inner(display) 
 L2:
 -- pushReturn:  "display" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- vdtAdd: inx=2 descInx=136 vDescInx=0 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 103 
 -- Items:GenClass: print descNo: 103 isValue: false 
 -- Items:GenClass: print descNo: 21 isValue: false 

 CLASS print 103 1 String 10
 -- Store itemArgs: gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);} 
 -- Store:Origin: 5 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=103 vDescInx=103 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "for(1):to(length):repeat{   put(get[inx]);}" 
 -- $ObjectGenerator:gen: "for(1):to(length):repeat{   put(get[inx]);" >OGid:"for:to:repeat$106" IS.isempty! staticOff=0 descNo=106 superAdj=0} 
 -- OG:gen: "for(1):to(length):repeat{   put(get[inx]);}" 
 pushThis 
 -- before objTmpStack:add:  106   "for:to:repeat$106" 
 invoke for:to:repeat$106 106 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 -- pushReturn:  "print" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 104 
 -- Items:GenClass: repeat$104 descNo: 104 isValue: false 
 -- Items:GenClass: repeat$104 descNo: 21 isValue: false 

 CLASS repeat$104 104 1 for:to:repeat$106 106
 -- Store itemArgs: put(get[inx]) 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=104 vDescInx=104 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "put(get[inx])" 
 -- $ObjectGenerator:gen: "put(get[inx])" >OGid:"put" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "put(get[inx])" 
 -- OG:before:super.gen: "put(get[inx])" 
 -- $Invocation:gen: "put(get[inx])" >useRtnV:"False"superAdj: 0 descNo: 105 
 -- INV:gen: "put(get[inx])" 
 -- isConstant: "Invocation" "put(get[inx])" 
 -- needorigin: "put(get[inx])" 
 -- needOrigin:E: "put(get[inx])"  E.ATd: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- Ex:loadOrign:no:loadOrigin:  "-- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "put(get[inx])" E:  "put(get[inx])" 
 -- INV:gen:E.loadArgs "put(get[inx])" 
 -- $ObjectInvocation_KeyWord:loadArgs: "put(get[inx])" >staticOff:0 "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char" superAdj:0arg:"get[inx]"} 
 -- $pattern:loadArgs: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char" >E:"put(get[inx])":descNo:105} 
 -- ptn:loadArgs:E "put(get[inx])" 
 -- {(ObjectInvocation_KeyWord; (name: "put"); (Arguments;  (name: "put");  (name: "(");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_KeyWord;     (name: "get");     ...} 
 -- args: "put(get[inx])" 
 -- E: "ObjectGenerator" get[inx] 
 -- E.arg: "val" in ch: val char 
 -- NonVirt: "put(get[inx])" "ObjectInvocation_KeyWord" ActArg:  "get[inx]" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(get[inx])"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "get[inx]" >OGid:"get" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "get[inx]" 
 -- OG:before:super.gen: "get[inx]" 
 -- $Invocation:gen: "get[inx]" >useRtnV:"True"superAdj: 0 descNo: 16 
 -- INV:gen: "get[inx]" 
 -- isConstant: "Invocation" "get[inx]" 
 -- needorigin: "get[inx]" 
 -- needOrigin:E: "get[inx]"  E.ATd: "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- doNeedOrigin:Ex: "get[inx]" 
 -- computeAdr:superAdj: 0 "get[inx]" 
 -- computeAdr: 1 :rec: "none"  E: "get[inx]" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "get[inx]"  
 pushThis 
 -- $ObjectInvocation_KeyWord:loadOrigin: "get[inx]" >on:3 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$104" on: 3 isValueObj: false 
 -- origin: for:to:repeat$106 origin:isValueObj: false 
 rpushg repeat$104$104 1
 -- items:goOrigin:encOG: "for:to:repeat$106" on: 2 isValueObj: false 
 -- origin: print origin:isValueObj: false 
 rpushg for:to:repeat$106$106 4
 -- items:goOrigin:encOG: "print" on: 1 isValueObj: false 
 -- origin: String origin:isValueObj: false 
 rpushg print$103 1
 -- $ObjectInvocation_KeyWord:getAdr: "get[inx]" >ATd.off:0 (isPtn):on:3:superAdj:0"get[inx: var integer]: {   %basic 117;   out ch: var char":Adr:off:0 size:0 isFloat:F isUni ...} 
 -- $pattern:getAdr: "get[inx: var integer]: {   %basic 117;   out ch: var char" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- E.on: 3 
 -- beforeIsValueObj:E: "get[inx]"  ATd: "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- computeAdr:isLast:E:  "get[inx]" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- rec:  "get[inx]" E:  "get[inx]" 
 -- INV:gen:E.loadArgs "get[inx]" 
 -- $ObjectInvocation_KeyWord:loadArgs: "get[inx]" >staticOff:0 "get[inx: var integer]: {   %basic 117;   out ch: var char" superAdj:0arg:"inx"} 
 -- $pattern:loadArgs: "get[inx: var integer]: {   %basic 117;   out ch: var char" >E:"get[inx]":descNo:16} 
 -- ptn:loadArgs:E "get[inx]" 
 -- {(ObjectInvocation_KeyWord; (name: "get"); (Arguments;  (name: "get");  (name: "[");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "inx");     ( ...} 
 -- args: "get[inx]" 
 -- E: "ObjectGenerator" inx 
 -- E.arg: "var" inx: var integer 
 -- NonVirt: "get[inx]" "ObjectInvocation_KeyWord" ActArg:  "inx" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx]"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "inx" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inx" 
 -- OG:before:super.gen: "inx" 
 -- $Invocation:gen: "inx" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "inx" 
 -- isConstant: "Invocation" "inx" 
 -- notConst: inx inx: var integer 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$104" on: 1 isValueObj: false 
 -- origin: for:to:repeat$106 origin:isValueObj: false 
 rpushg repeat$104$104 1
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:3:on:1:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- $ObjectInvocation_Unary:loadArgs: "inx" >staticOff:0 "inx: var integer" superAdj:0 
 -- $var:loadArgs: "inx: var integer" >E:"inx" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "inx" 
 -- {(ObjectInvocation_Unary; (name: "inx"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: "inx" >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:"inx" unique:"False" 
 -- OI:invoke: "inx" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx" E: "inx"  rec: "inx"  useRtnV: true "inx: var integer" 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: "inx: var integer" E: "inx">newOff:3 useRTNv: "True" 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- isCompositeValueObj: false E: "inx" "inx: var integer" true 
 -- E.ATd.isValueObj: false rec: "inx" 
 pushg 3 for:to:repeat$106$106
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:C: inx :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- formalArg:isPtn: "inx: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "inx" :isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "get[inx]" 
 -- INV:gen:after:E.loadArgs "get[inx]" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx]" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec ... 
 -- $ObjectInvocation_KeyWord:invoke: "get[inx]" >rec:"get[inx]" ATd:"pattern" E:"get[inx]" E.ATd:"get[inx: var integer]" unique:"False" 
 -- OI:invoke: "get[inx]" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- OI:invoke:B: "get[inx]" E: "get[inx]"  rec: "get[inx]"  useRtnV: true "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- $pattern:invoke: "get[inx: var integer]: {   %basic 117;   out ch: var char" E: "get[inx]" useRTNv: "True"} 
 -- ptn:invoke: "get[inx: var integer]" E: "get[inx]" ptnKind: 0 useRtnV: true 
 xpushg  inx 1 0 1
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpop : vTop: 0 vTopMax: 1 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- 
 -- OI:invoke:C: get[inx] :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- formalArg:isPtn: "in ch: val char" :isBasicVal: true :valueObj: true 
 -- :actArg: "get[inx]" :isBasicVal: true 
 -- case:B: get[inx] ObjectGenerator 3 117 117 false false 
 -- end:loadArgs:NonVirt: "put(get[inx])" 
 -- INV:gen:after:E.loadArgs "put(get[inx])" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(get[inx])" 
 -- $ObjectInvocation_KeyWord:invoke: "put(get[inx])" >rec:"put(get[inx])" ATd:"pattern" E:"put(get[inx])" E.ATd:"put" unique:"False" 
 -- OI:invoke: "put(get[inx])" 
 -- 
 -- OI:invoke:B: "put(get[inx])" E: "put(get[inx])"  rec: "put(get[inx])"  useRtnV: false "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- $pattern:invoke: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char" E: "put(get[inx])" useRTNv: "False"} 
 -- ptn:invoke: "put" E: "put(get[inx])" ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- OI:invoke:C: put(get[inx]) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 105 
 -- Items:GenClass: put descNo: 105 isValue: false 
 -- Items:GenClass: put descNo: 21 isValue: false 

 CLASS put 105 0 BETA 2
 -- Store itemArgs: %globals{%basic 2;in ch: val char} 
 -- in ch: val char true 3 
 -- DI:store: "ch" 
 pushThis 
 storeg char$7 1
 allocEventQ
 -- vdtAdd: inx=1 descInx=105 vDescInx=105 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%globals"  
 -- $Property:gen: "%basic 2"  
 -- $val:gen: "in ch: val char"  
 -- DI:gen: "in ch: val char" DI:isConst: true :isBasicValue: true :primNo: 3 
 -- DI:add:BP1:  ch 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%globals" 
 -- $Property:gen: "%globals"  
 -- genclass:stmt: "%basic 2" 
 -- $Property:gen: "%basic 2"  
 L2:
 -- pushReturn:  "put" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 106 
 -- Items:GenClass: for:to:repeat$106 descNo: 106 isValue: false 
 -- Items:GenClass: for:to:repeat$106 descNo: 28 isValue: false 
 -- Items:GenClass: for:to:repeat descNo: 21 isValue: false 

 CLASS for:to:repeat$106 106 4 print 103
 -- vdtTableCopy: I:1:28 V:2:29
 -- Store itemArgs:  
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- push:super.origin: 
 -- handleSuperArgs:E: "for(1):to(length):repeat{   put(get[inx]);}" theIS: "" 
 -- super.sig:none:superAdj: 4 
 -- $ObjectInvocation_KeyWord:loadArgs: "for(1):to(length):repeat{   put(get[inx]);" >staticOff:0 "for(first: var integer):to(last: var integer):repeat{repeat:< object}: ;   % ..."} 
 -- $pattern:loadArgs: "for(first: var integer):to(last: var integer):repeat{repeat:< object}: {   %OSDvisibility skipInternal;   %globals inSub;   inx: var integer;   inx :=  ..."} 
 -- ptn:loadArgs:E "for(1):to(length):repeat{   put(get[inx]);}" 
 -- {(ObjectInvocation_KeyWord; (name: "for:to:repeat"); (Arguments;  (name: "for");  (name: "(");  (ObjectGenerator;   (Invocation;    (ConstLiteral 1));   (Items descNo: 0 o ...} 
 -- args: "for(1):to(length):repeat{   put(get[inx]);}" 
 -- E: "ObjectGenerator" 1 
 -- E: "ObjectGenerator" length 
 -- E: "ObjectGenerator" put(get[inx]) 
 -- E.arg: "var" first: var integer 
 -- NonVirt: "for(1):to(length):repeat{   put(get[inx]);}" "ObjectInvocation_KeyWord" ActArg:  "1" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "for(1):to(length):repeat{   put(get[inx]);}"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=4 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 4 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 4 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "first: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "1" :isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "for(1):to(length):repeat{   put(get[inx]);}" 
 -- E.arg: "var" last: var integer 
 -- NonVirt: "for(1):to(length):repeat{   put(get[inx]);}" "ObjectInvocation_KeyWord" ActArg:  "length" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "for(1):to(length):repeat{   put(get[inx]);}"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "length" >OGid:"length" IS.isempty! staticOff=0 descNo=0 superAdj=4 
 -- OG:gen: "length" 
 -- OG:before:super.gen: "length" 
 -- $Invocation:gen: "length" >useRtnV:"True"superAdj: 4 descNo: 15 
 -- INV:gen: "length" 
 -- isConstant: "Invocation" "length" 
 -- needorigin: "length" 
 -- needOrigin:E: "length"  E.ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- doNeedOrigin:Ex: "length" 
 -- computeAdr:superAdj: 4 "length" 
 -- computeAdr: 1 :rec: "none"  E: "length" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "length"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "length" >on:1 superAdj:4 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 4 
 rpushg print$103 4
 -- items:goOrigin:encOG: "print" on: 1 isValueObj: false 
 -- origin: String origin:isValueObj: false 
 rpushg print$103 1
 -- $ObjectInvocation_Unary:getAdr: "length" >ATd.off:0 (isPtn):on:1:superAdj:4"length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length":Adr ...} 
 -- PING:String 0 gogo: {      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   } 
 -- $pattern:getAdr: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "length"  ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- computeAdr:isLast:E:  "length" 
 -- IV:after:computeAdr:superAdj: 4 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- rec:  "length" E:  "length" 
 -- INV:gen:E.loadArgs "length" 
 -- $ObjectInvocation_Unary:loadArgs: "length" >staticOff:0 "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" superAdj:4} 
 -- $pattern:loadArgs: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" >E:"length":descNo:15} 
 -- ptn:loadArgs:E "length" 
 -- {(ObjectInvocation_Unary; (name: "length"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "length" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- $ObjectInvocation_Unary:invoke: "length" >rec:"length" ATd:"pattern" E:"length" E.ATd:"length" unique:"False" 
 -- OI:invoke: "length" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:B: "length" E: "length"  rec: "length"  useRtnV: true "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- $pattern:invoke: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" E: "length" useRTNv: "True"} 
 -- ptn:invoke: "length" E: "length" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:C: length :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- formalArg:isPtn: "last: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "length" :isBasicVal: true 
 -- case:B: length ObjectGenerator 1 0 0 false false 
 -- end:loadArgs:NonVirt: "for(1):to(length):repeat{   put(get[inx]);}" 
 -- args:  "repeat:< object" "put(get[inx])" for:to:repeat 
 -- hArgOrg:super: for:to:repeat 
 -- Store itemArgs:  
 -- last: var integer true 1 
 -- DI:store: "last" 
 pushThis 
 storeg integer$5 2
 -- first: var integer true 1 
 -- DI:store: "first" 
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- vdtAdd: inx=1 descInx=106 vDescInx=28 vdtTop: 2 
 -- $Property:gen: "%OSDvisibility skipInternal"  
 -- $Property:gen: "%globals inSub"  
 -- $var:gen: "inx: var integer"  
 -- DI:gen: "inx: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  inx 
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0
 -- Handle VB: "" E: "for(1):to(length):repeat{   put(get[inx]);}" 
 -- vdtAdd: inx=2 descInx=106 vDescInx=104 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 113 
 -- Items:GenClass: Core descNo: 113 isValue: false 
 -- Items:GenClass: Core descNo: 112 isValue: false 
 -- Items:GenClass: SuperCore descNo: 21 isValue: false 

 CLASS Core 113 3 BasicSystem 72
 -- vdtTableCopy: I:1:112 I:2:0
 -- vdtAdd: inx=2 descInx=113 vDescInx=113 vdtTop: 2 
 -- Store itemArgs: %Public{attach: ;   in M: ref Scheduler;   main := M;%Private;dummy: var integer;go: ;   loopX: obj ;      if (main =/= none) :then ;         main.call;    ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  3 origin
 -- super SuperCore
 -- push:super.origin: 
 -- computeAdr:superAdj: 3 "SuperCore" 
 -- computeAdr: 1 :rec: "none"  E: "SuperCore" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:3 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "SuperCore"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "SuperCore" >on:2 superAdj:3 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 3 
 rpushg BasicSystem$72 3
 -- items:goOrigin:encOG: "BasicSystem" on: 2 isValueObj: false 
 -- origin: BasicSystemLib origin:isValueObj: false 
 rpushg BasicSystem$72 1
 -- items:goOrigin:encOG: "BasicSystemLib" on: 1 isValueObj: false 
 -- origin: LIB origin:isValueObj: false 
 rpushg BasicSystemLib$38 1
 -- IV:viaIncl:on: 0 "BETA"  org: "%id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--Collectio ...}" 
 -- viaIncl:son:isFirst: true viaIncl<>none: false "BETA" 
 -- items:goOrigin:encOG: "LIB" on: 1 isValueObj: false 
 -- origin: BETAworld origin:isValueObj: false 
 rpushg LIB$33 1
 rpushg BETA 2
 -- $ObjectInvocation_Unary:getAdr: "SuperCore" >ATd.off:0 (isPtn):on:2:superAdj:3"SuperCore: {   %core 16;   main: ref SuperScheduler;   inner(SuperCore)":Adr:off:0 size:0 is ...} 
 -- $pattern:getAdr: "SuperCore: {   %core 16;   main: ref SuperScheduler;   inner(SuperCore)" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:3 isUnique:F isValue:F originIsValue:F:E:"SuperCore":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "SuperCore"  ATd: "SuperCore: {   %core 16;   main: ref SuperScheduler;   inner(SuperCore)}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:3 isUnique:F isValue:F originIsValue:F:E:"SuperCore":rec:- 
 -- computeAdr:isLast:E:  "SuperCore" 
 -- genClass:after:pushAddress: "SuperCore" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:3 isUnique:F isValue:F originIsValue:F:E:"SuperCore":rec:- 
 -- handleSuperArgs:E: "SuperCore" theIS: "%Public{attach: ;   in M: ref Scheduler;   main := M;%Private;dummy: var integer;go: ;   loopX: obj ;      if (main =/= none) :then  ...}" 
 -- super.sig:not:none:superAdj: -3 
 -- $ObjectInvocation_Unary:loadArgs: "SuperCore" >staticOff:0 "SuperCore: {   %core 16;   main: ref SuperScheduler;   inner(SuperCore)" superAdj:-3} 
 -- $pattern:loadArgs: "SuperCore: {   %core 16;   main: ref SuperScheduler;   inner(SuperCore)" >E:"SuperCore":descNo:112} 
 -- ptn:loadArgs:E "SuperCore" 
 -- {(ObjectInvocation_Unary; (name: "SuperCore"); (Arguments))} 
 -- args: "" 
 -- hArgOrg:super: SuperCore 
 -- Store itemArgs: %Public{attach: ;   in M: ref Scheduler;   main := M;%Private;dummy: var integer;go: ;   loopX: obj ;      if (main =/= none) :then ;         main.call;    ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=113 vDescInx=112 vdtTop: 2 
 -- $Property:gen: "%core 16"  
 -- $ref:gen: "main: ref SuperScheduler"  
 -- DI:gen: "main: ref SuperScheduler" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- $Property:gen: "%Public"  
 -- $Property:gen: "%Private"  
 -- $var:gen: "dummy: var integer"  
 -- DI:gen: "dummy: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  dummy 
 rtnAlloc 1
 toSuper 112
DO:
 mvStack 
 L1:
 -- genclass:stmt: "%Public" 
 -- $Property:gen: "%Public"  
 -- genclass:stmt: "%Private" 
 -- $Property:gen: "%Private"  
 -- genclass:stmt: "(this(Core)).suspend{--main:= none         }" 
 -- $ObjectGenerator:gen: "(this(Core)).suspend{--main:= none         " >OGid:"suspend" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "(this(Core)).suspend{--main:= none         }" 
 -- OG:before:super.gen: "(this(Core)).suspend{--main:= none         }" 
 -- $Invocation:gen: "(this(Core)).suspend{--main:= none         " >useRtnV:"False"superAdj: 0 descNo: 84} 
 -- INV:gen: "(this(Core)).suspend{--main:= none         }" 
 -- isConstant: "Invocation" "(this(Core)).suspend{--main:= none         }" 
 -- needorigin: "(this(Core)).suspend{--main:= none         }" 
 -- needOrigin:E: "suspend{--main:= none         }"  E.ATd: "suspend: {   %basic 111}" 
 -- doNeedOrigin:Ex: "(this(Core))" 
 -- computeAdr:superAdj: 0 "(this(Core)).suspend{--main:= none         }" 
 -- computeAdr: 1 :rec: "none"  E: "(this(Core))" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(this(Core))"  
 -- $BracketedExp:loadOrigin: "(this(Core))"  
 -- computeAdr:superAdj: 0 "this(Core)" 
 -- computeAdr: 1 :rec: "none"  E: "this(Core)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "this(Core)"  
 pushThis 
 -- $ObjectInvocation_KeyWord:loadOrigin: "this(Core)" >on:3 superAdj:0 isValueObj:"False" 
 -- this_prim: Core :super.on: 1 
 -- $ObjectInvocation_KeyWord:getAdr: "this(Core)" >ATd.off:0 (isPtn):on:3:superAdj:0"this: {   %basic 18;   in this: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal:F superA ...} 
 -- $pattern:getAdr: "this: {   %basic 18;   in this: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(Core)":rec:- 
 -- E.on: 3 
 -- beforeIsValueObj:E: "this(Core)"  ATd: "this: {   %basic 18;   in this: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(Core)":rec:- 
 -- computeAdr:isLast:E:  "this(Core)" 
 -- BE:loadOrigin:E: this(Core) 
 -- $ObjectInvocation_KeyWord:getAdr: "this(Core)" >ATd.off:0 (isPtn):on:3:superAdj:0"this: {   %basic 18;   in this: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal:F superA ...} 
 -- $pattern:getAdr: "this: {   %basic 18;   in this: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(Core)":rec:- 
 -- E.on: 3 
 -- beforeIsValueObj:E: "this(Core)"  ATd: "this: {   %basic 18;   in this: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(Core)":rec:- 
 -- computeAdr: 2 :rec: "this(Core)"  E: "suspend{--main:= none         }"  A.E: "this(Core)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(Core)":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "suspend{--main:= none         " >ATd.off:0 (isPtn):on:0:superAdj:0"suspend: ;   %basic 111":Adr:off:0 size:0 isFloat:F isUnitVal:F superAd ...} 
 -- $pattern:getAdr: "suspend: {   %basic 111" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(Core)":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_KeyWord:loadArgs: "this(Core)" >staticOff:0 "this: {   %basic 18;   in this: ref Object" superAdj:0arg:"Core"} 
 -- $pattern:loadArgs: "this: {   %basic 18;   in this: ref Object" >E:"this(Core)":descNo:31} 
 -- $ObjectInvocation_KeyWord:invoke: "this(Core)" >rec:"this(Core)" ATd:"pattern" E:"suspend{--main:= none         " E.ATd:"suspend" unique:"False"} 
 -- OI:invoke: "this(Core)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(Core)":rec:this(Core) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(Core)":rec:this(Core) 
 -- OI:invoke:B: "this(Core)" E: "suspend{--main:= none         }"  rec: "this(Core)"  useRtnV: true "this: {   %basic 18;   in this: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern this 
 -- $pattern:invoke: "this: {   %basic 18;   in this: ref Object" E: "suspend;--main:= none         " useRTNv: "True"} 
 -- ptn:invoke: "this" E: "suspend{--main:= none         }" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend{--main:= none         ":rec:th ...} 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend{--main:= none         ":rec:this(Core)} 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend{--main:= none         ":rec:this(Core)} 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: this(Core) :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "this(Core)" E: "suspend{--main:= none         }" 
 -- computeAdr:isLast:E:  "suspend{--main:= none         }" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend{--main:= none         ":rec:this(Core)} 
 -- rec:  "this(Core)" E:  "suspend{--main:= none         }" 
 -- INV:gen:E.loadArgs "suspend{--main:= none         }" 
 -- $ObjectInvocation_Unary:loadArgs: "suspend{--main:= none         " >staticOff:0 "suspend: ;   %basic 111" superAdj:0} 
 -- $pattern:loadArgs: "suspend: {   %basic 111" >E:"suspend;--main:= none         ":descNo:84} 
 -- ptn:loadArgs:E "suspend{--main:= none         }" 
 -- {(ObjectInvocation_Unary; (name: "suspend"); (Arguments --<12>main:= none         ))} 
 -- args: "--main:= none         " 
 -- INV:gen:after:E.loadArgs "suspend{--main:= none         }" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "suspend{--main:= none         }" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVa ... 
 -- $ObjectInvocation_Unary:invoke: "suspend{--main:= none         " >rec:"this(Core)" ATd:"pattern" E:"suspend;--main:= none         " E.ATd:"suspend" unique:"False"} 
 -- OI:invoke: "suspend{--main:= none         }" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend{--main:= none         ":rec:this(Core)} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend{--main:= none         ":rec:this(Core)} 
 -- OI:invoke:B: "suspend{--main:= none         }" E: "suspend{--main:= none         }"  rec: "this(Core)"  useRtnV: false "suspend: {   %basic 111}" 
 -- OI:invoke:before:ATdx.invoke: pattern suspend 
 -- $pattern:invoke: "suspend: {   %basic 111" E: "suspend;--main:= none         " useRTNv: "False"} 
 -- ptn:invoke: "suspend" E: "suspend{--main:= none         }" ptnKind: 0 useRtnV: false 
 suspend
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend{--main:= none         ":rec:this(Core)} 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend{--main:= none         ":rec:this(Core)} 
 -- 
 -- OI:invoke:C: suspend{--main:= none         } :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend{--main:= none         ":rec:this(Core)} 
 -- genclass:stmt: "dummy := 213" 
 -- $Assign:gen: "dummy := 213"  
 -- assign: "dummy := 213" 
 -- computeAdr:superAdj: 0 "dummy" 
 -- computeAdr: 1 :rec: "none"  E: "dummy" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "dummy"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "dummy" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "dummy" >ATd.off:4:on:0:superAdj:0"dummy: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ... 
 -- $var:getAdr: "dummy: var integer" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F o ... 
 -- DI:OG: integer 
 -- before:floatTest:  "dummy: var integer" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"dummy":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"dummy":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"dummy":rec:- 
 -- computeAdr:isLast:E:  "dummy" 
 -- AssignmentStatement:gen: "dummy := 213" right.label: "ObjectGenerator" "213" 
 -- $ObjectGenerator:gen: "213" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "213" 
 -- OG:before:super.gen: "213" 
 -- $Invocation:gen: "213" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "213" 
 -- isConstant: "Invocation" "213" 
 -- needorigin: "213" 
 -- needOrigin:E: "213"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: va ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "213" E:  "213" 
 -- INV:gen:E.loadArgs "213" 
 -- $ConstLiteral:loadArgs: "213"  
 -- INV:gen:after:E.loadArgs "213" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "213" 
 -- $ConstLiteral:invoke: "213"  
 pushc 213
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "dummy" dstE: "dummy" dstE.ATd: "dummy: var integer" useRtn: false :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"dummy":r ... 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "213" 
 -- isArgOfAssignI2IwithUniValArg "dummy := 213" arg: "213" ObjectGenerator 
 -- arg.super.arg: "213" ConstLiteral 
 -- dstDI: "dummy: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"dummy":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg Core$113 4
 -- assign:adr.store:B: 
 -- genclass:stmt: "go" 
 -- $ObjectGenerator:gen: "go" >OGid:"go" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "go" 
 -- OG:before:super.gen: "go" 
 -- $Invocation:gen: "go" >useRtnV:"False"superAdj: 0 descNo: 114 
 -- INV:gen: "go" 
 -- isConstant: "Invocation" "go" 
 -- needorigin: "go" 
 -- needOrigin:E: "go"  E.ATd: "go: {   loopX: obj ;      if (main =/= none) :then ;         main.call;      :else ;         sleep(100);         restart(loopX)}" 
 -- doNeedOrigin:Ex: "go" 
 -- computeAdr:superAdj: 0 "go" 
 -- computeAdr: 1 :rec: "none"  E: "go" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "go"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "go" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "go" >ATd.off:0 (isPtn):on:0:superAdj:0"go: {   loopX: obj ;      if (main =/= none) :then ;         main.call;      :else ;         sleep( ..."} 
 -- $pattern:getAdr: "go: {   loopX: obj ;      if (main =/= none) :then ;         main.call;      :else ;         sleep(100);         restart(loopX)" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"go":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"go":rec:- 
 -- computeAdr:isLast:E:  "go" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"go":rec:- 
 -- rec:  "go" E:  "go" 
 -- INV:gen:E.loadArgs "go" 
 -- $ObjectInvocation_Unary:loadArgs: "go" >staticOff:0 "go: {   loopX: obj ;      if (main =/= none) :then ;         main.call;      :else ;         sleep(100);         resta ..."} 
 -- $pattern:loadArgs: "go: {   loopX: obj ;      if (main =/= none) :then ;         main.call;      :else ;         sleep(100);         restart(loopX)" >E:"go":descNo:114} 
 -- ptn:loadArgs:E "go" 
 -- {(ObjectInvocation_Unary; (name: "go"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "go" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "go" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"go":rec:- 
 -- $ObjectInvocation_Unary:invoke: "go" >rec:"go" ATd:"pattern" E:"go" E.ATd:"go" unique:"False" 
 -- OI:invoke: "go" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"go":rec:go 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"go":rec:go 
 -- OI:invoke:B: "go" E: "go"  rec: "go"  useRtnV: false "go: {   loopX: obj ;      if (main =/= none) :then ;         main.call;      :else ;         sleep(100);         rest ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern go 
 -- $pattern:invoke: "go: {   loopX: obj ;      if (main =/= none) :then ;         main.call;      :else ;         sleep(100);         restart(loopX)" E: "go" useRTNv: "False" ...} 
 -- ptn:invoke: "go" E: "go" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"go":rec:go 
 invoke go 114 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"go":rec:go 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"go":rec:go 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: go :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"go":rec:go 
 L2:
 rtnInner  M
 END OSDV:0 objSize:4 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 114 
 -- Items:GenClass: go descNo: 114 isValue: false 
 -- Items:GenClass: go descNo: 21 isValue: false 

 CLASS go 114 1 Core 113
 -- Store itemArgs: loopX: obj {   if (main =/= none) :then ;      main.call;   :else ;      sleep(100);      restart(loopX)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=114 vDescInx=114 vdtTop: 1 
 mvStack 
 -- $obj:gen: "loopX: obj {   if (main =/= none) :then ;      main.call;   :else ;      sleep(100);      restart(loopX)" } 
 -- DI:gen: "loopX: obj {   if (main =/= none) :then ;      main.call;   :else ;      sleep(100);      restart(loopX)}" DI:isConst: true :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  loopX 
 -- $ObjectGenerator:gen: "if (main =/= none) :then {      main.call;   :else ;      sleep(100);      restart(loopX)" >OGid:"loopX" singular! staticOff=2 descNo=115 superAdj=0 ...} 
 -- OG:gen: "if (main =/= none) :then {      main.call;   :else ;      sleep(100);      restart(loopX)}" 
 pushThis 
 -- before objTmpStack:add:  115   "loopX" 
 invoke loopX 115 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 -- pushReturn:  "go" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 115 
 -- Items:GenClass: loopX descNo: 115 isValue: false 
 -- Items:GenClass: loopX descNo: 21 isValue: false 

 CLASS loopX 115 1 go 114
 -- Store itemArgs: if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=115 vDescInx=115 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)}" 
 -- $ObjectGenerator:gen: "if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)" >OGid:"if:then$0" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)}" 
 -- OG:before:super.gen: "if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)}" 
 -- $Invocation:gen: "if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)" >useRtnV:"False"superAdj: 0} 
 -- INV:gen: "if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)}" 
 -- isConstant: "Invocation" "if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)}" 
 -- needorigin: "if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)}" 
 -- needOrigin:E: "if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)}"  E.ATd: "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility s ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)}" E:  "if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)}" 
 -- INV:gen:E.loadArgs "if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)}" 
 -- $IfThenElse:loadArgs: "if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)" } 
 -- INV:gen:after:E.loadArgs "if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThenElse "if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)}" 
 -- $IfThenElse:invoke: "if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)" } 
 -- $IfThenElse:gen: "if (main =/= none) :then {   main.call;:else ;   sleep(100);   restart(loopX)" } 
 -- $ObjectGenerator:gen: "(main =/= none)" >OGid:"=/=" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(main =/= none)" 
 -- OG:before:super.gen: "(main =/= none)" 
 -- $Invocation:gen: "(main =/= none)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(main =/= none)" 
 -- isConstant: "Invocation" "(main =/= none)" 
 -- needorigin: "(main =/= none)" 
 -- needOrigin:E: "(main =/= none)"  E.ATd: "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean}" 
 -- doNeedOrigin:Ex: "(main =/= none)" 
 -- computeAdr:superAdj: 0 "(main =/= none)" 
 -- computeAdr: 1 :rec: "none"  E: "(main =/= none)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(main =/= none)"  
 -- $BracketedExp:loadOrigin: "(main =/= none)"  
 -- computeAdr:superAdj: 0 "main =/= none" 
 -- computeAdr: 1 :rec: "none"  E: "main =/= none" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "main =/= none"  
 -- $BinOp:loadOrigin: "main =/= none"  
 -- BinaryExp:loadOrigin:empty: "main =/= none" superAdj: 0 
 -- $BinOp:getAdr: "main =/= none"  
 -- E.on: 2 
 -- beforeIsValueObj:E: "main =/= none"  ATd: "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "main =/= none" 
 -- BE:loadOrigin:E: main =/= none 
 -- $BinOp:getAdr: "main =/= none"  
 -- E.on: 2 
 -- beforeIsValueObj:E: "main =/= none"  ATd: "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "main =/= none" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "main =/= none" E:  "main =/= none" 
 -- INV:gen:E.loadArgs "main =/= none" 
 -- $BinOp:loadArgs: "main =/= none"  
 -- BinaryExp:loadArgs: "main =/= none" superAdj: 0 
 -- $Invocation:gen: "main" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "main" 
 -- isConstant: "Invocation" "main" 
 -- notConst: main main: ref SuperScheduler 
 -- needorigin: "main" 
 -- needOrigin:E: "main"  E.ATd: "main: ref SuperScheduler" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "main" 
 -- computeAdr: 1 :rec: "none"  E: "main" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "main"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "main" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loopX" on: 2 isValueObj: false 
 -- origin: go origin:isValueObj: false 
 rpushg loopX$115 1
 -- items:goOrigin:encOG: "go" on: 1 isValueObj: false 
 -- origin: Core origin:isValueObj: false 
 rpushg go$114 1
 -- $ObjectInvocation_Unary:getAdr: "main" >ATd.off:2:on:2:superAdj:0"main: ref SuperScheduler":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIs ... 
 -- $ref:getAdr: "main: ref SuperScheduler" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F i ... 
 -- E.on: 2 
 -- beforeIsValueObj:E: "main"  ATd: "main: ref SuperScheduler" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "main" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "main" E:  "main" 
 -- INV:gen:E.loadArgs "main" 
 -- $ObjectInvocation_Unary:loadArgs: "main" >staticOff:0 "main: ref SuperScheduler" superAdj:0 
 -- $ref:loadArgs: "main: ref SuperScheduler" >E:"main" 
 -- $pattern:loadArgs: "SuperScheduler: {   thisScheduler:< Object;   ProcessType:< GeneralProcess;   active: ref ProcessType;   inner(SuperScheduler)" >E:"main":descNo:122} 
 -- ptn:loadArgs:E "main" 
 -- {(ObjectInvocation_Unary; (name: "main"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "main" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "main" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "main" >rec:"main" ATd:"ref" E:"main" E.ATd:"main" unique:"False" 
 -- OI:invoke: "main" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:main 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:main 
 -- OI:invoke:B: "main" E: "main"  rec: "main"  useRtnV: true "main: ref SuperScheduler" 
 -- OI:invoke:before:ATdx.invoke: ref main 
 -- $ref:invoke: "main: ref SuperScheduler" E: "main">newOff:2 useRTNv: "True" 
 -- DI:invoke: "main: ref SuperScheduler" 
 -- >Object:unique: false 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"main":rec:main 
 -- isCompositeValueObj: false E: "main" "main: ref SuperScheduler" false 
 -- E.ATd.isValueObj: false rec: "main" 
 rpushg Core$113 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"main":rec:main 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"main":rec:main 
 -- 
 -- OI:invoke:C: main :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"main":rec:main 
 -- $pattern:loadArgs: "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean" >E:"=/= none":descNo:117} 
 -- ptn:loadArgs:E "=/= none" 
 -- {(ObjectInvocation_Binary; (name: "=/="); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "none");     (Arguments)));   (Items descNo: ...} 
 -- args: "none" 
 -- E: "ObjectGenerator" none 
 -- E.arg: "ref" in objx: ref Object 
 -- NonVirt: "=/= none" "ObjectInvocation_Binary" ActArg:  "none" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "=/= none"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "none" >OGid:"none" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "none" 
 -- OG:before:super.gen: "none" 
 -- $Invocation:gen: "none" >useRtnV:"True"superAdj: 0 descNo: 116 
 -- INV:gen: "none" 
 -- isConstant: "Invocation" "none" 
 -- needorigin: "none" 
 -- needOrigin:E: "none"  E.ATd: "none: {   %basic 19;   none_x: var integer}" 
 -- doNeedOrigin:Ex: "none" 
 -- computeAdr:superAdj: 0 "none" 
 -- computeAdr: 1 :rec: "none"  E: "none" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "none"  
 -- $ObjectInvocation_Unary:loadOrigin: "none" >on:5 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_Unary:getAdr: "none" >ATd.off:0 (isPtn):on:5:superAdj:0"none: {   %basic 19;   none_x: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU ...} 
 -- $pattern:getAdr: "none: {   %basic 19;   none_x: var integer" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- E.on: 5 
 -- beforeIsValueObj:E: "none"  ATd: "none: {   %basic 19;   none_x: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "none" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "none" E:  "none" 
 -- INV:gen:E.loadArgs "none" 
 -- $ObjectInvocation_Unary:loadArgs: "none" >staticOff:0 "none: {   %basic 19;   none_x: var integer" superAdj:0} 
 -- $pattern:loadArgs: "none: {   %basic 19;   none_x: var integer" >E:"none":descNo:116} 
 -- ptn:loadArgs:E "none" 
 -- {(ObjectInvocation_Unary; (name: "none"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "none" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "none" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "none" >rec:"none" ATd:"pattern" E:"none" E.ATd:"none" unique:"False" 
 -- OI:invoke: "none" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- OI:invoke:B: "none" E: "none"  rec: "none"  useRtnV: true "none: {   %basic 19;   none_x: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern none 
 -- $pattern:invoke: "none: {   %basic 19;   none_x: var integer" E: "none" useRTNv: "True"} 
 -- ptn:invoke: "none" E: "none" ptnKind: 0 useRtnV: true 
 pushNone 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- 
 -- OI:invoke:C: none :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- formalArg:isPtn: "in objx: ref Object" :isBasicVal: false :valueObj: false 
 -- :actArg: "none" :isBasicVal: false 
 -- case:B: none ObjectGenerator 64 19 19 false false 
 -- end:loadArgs:NonVirt: "=/= none" 
 -- BinaryExp:loadArgs:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"main":rec:main 
 -- INV:gen:after:E.loadArgs "main =/= none" 
 -- OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"main":rec:main 
 -- IV:E.invoke:useRtnVal: true E: BinOp "main =/= none" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"main":rec:main 
 -- $BinOp:invoke: "main =/= none"  
 -- BinaryExp:invoke: "main" rec: "main =/= none" 
 -- M: "=/= none" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"main":rec:main 
 -- $ObjectInvocation_Binary:invoke: "=/= none" >rec:"main" ATd:"pattern" E:"=/= none" E.ATd:"=/=  " unique:"False" 
 -- OI:invoke: "=/= none" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"main":rec:main 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"main":rec:main 
 -- OI:invoke:B: "=/= none" E: "=/= none"  rec: "main"  useRtnV: true "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean}" 
 -- OI:invoke:before:ATdx.invoke: pattern =/=   
 -- $pattern:invoke: "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean" E: "=/= none" useRTNv: "True"} 
 -- ptn:invoke: "=/=  " E: "=/= none" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "main" E: "=/= none" 
 -- arg:other 
 rne
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"=/= none":rec:main 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"=/= none":rec:main 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: =/= none :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: "main.call" >OGid:"$118" singular! staticOff=0 descNo=118 superAdj=0 
 -- OG:gen: "main.call" 
 pushThis 
 -- before objTmpStack:add:  118   "$118" 
 invoke $118 118 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L5
 L4:
 -- $ObjectGenerator:gen: "sleep(100){   restart(loopX)" >OGid:"$120" singular! staticOff=0 descNo=120 superAdj=0} 
 -- OG:gen: "sleep(100){   restart(loopX)}" 
 pushThis 
 -- before objTmpStack:add:  120   "$120" 
 invoke $120 120 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 1 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L5:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 -- pushReturn:  "loopX" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 118 
 -- Items:GenClass: $118 descNo: 118 isValue: false 
 -- Items:GenClass: $118 descNo: 21 isValue: false 

 CLASS $118 118 1 loopX 115
 -- Store itemArgs: main.call 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=118 vDescInx=118 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "main.call" 
 -- $ObjectGenerator:gen: "main.call" >OGid:"call" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "main.call" 
 -- OG:before:super.gen: "main.call" 
 -- $Invocation:gen: "main.call" >useRtnV:"False"superAdj: 0 descNo: 119 
 -- INV:gen: "main.call" 
 -- isConstant: "Invocation" "main.call" 
 -- notConst: main main: ref SuperScheduler 
 -- needorigin: "main.call" 
 -- needOrigin:E: "call"  E.ATd: "call: {   %basic 113}" 
 -- doNeedOrigin:Ex: "call" 
 -- computeAdr:superAdj: 0 "main.call" 
 -- computeAdr: 1 :rec: "none"  E: "main" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "main"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "main" >on:3 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$118" on: 3 isValueObj: false 
 -- origin: loopX origin:isValueObj: false 
 rpushg $118$118 1
 -- items:goOrigin:encOG: "loopX" on: 2 isValueObj: false 
 -- origin: go origin:isValueObj: false 
 rpushg loopX$115 1
 -- items:goOrigin:encOG: "go" on: 1 isValueObj: false 
 -- origin: Core origin:isValueObj: false 
 rpushg go$114 1
 -- $ObjectInvocation_Unary:getAdr: "main" >ATd.off:2:on:3:superAdj:0"main: ref SuperScheduler":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIs ... 
 -- $ref:getAdr: "main: ref SuperScheduler" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F i ... 
 -- E.on: 3 
 -- beforeIsValueObj:E: "main"  ATd: "main: ref SuperScheduler" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "main"  E: "call" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "call" >ATd.off:0 (isPtn):on:0:superAdj:0"call: {   %basic 113":Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F orig ...} 
 -- $pattern:getAdr: "call: {   %basic 113" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"call":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "main" >staticOff:0 "main: ref SuperScheduler" superAdj:0 
 -- $ref:loadArgs: "main: ref SuperScheduler" >E:"main" 
 -- $pattern:loadArgs: "SuperScheduler: {   thisScheduler:< Object;   ProcessType:< GeneralProcess;   active: ref ProcessType;   inner(SuperScheduler)" >E:"main":descNo:122} 
 -- ptn:loadArgs:E "main" 
 -- {(ObjectInvocation_Unary; (name: "main"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "main" >rec:"main" ATd:"ref" E:"call" E.ATd:"call" unique:"False" 
 -- OI:invoke: "main" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"call":rec:main 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"call":rec:main 
 -- OI:invoke:B: "main" E: "call"  rec: "main"  useRtnV: true "main: ref SuperScheduler" 
 -- OI:invoke:before:ATdx.invoke: ref main 
 -- $ref:invoke: "main: ref SuperScheduler" E: "call">newOff:2 useRTNv: "True" 
 -- DI:invoke: "main: ref SuperScheduler" 
 -- >Object:unique: false 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"call":rec:main 
 -- isCompositeValueObj: false E: "call" "call: {   %basic 113}" false 
 -- E.ATd.isValueObj: false rec: "main" 
 rpushg $118$118 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"call":rec:main 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"call":rec:main 
 -- 
 -- OI:invoke:C: main :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "main" E: "call" 
 -- computeAdr:isLast:E:  "call" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"call":rec:main 
 -- rec:  "main" E:  "call" 
 -- INV:gen:E.loadArgs "call" 
 -- $ObjectInvocation_Unary:loadArgs: "call" >staticOff:0 "call: {   %basic 113" superAdj:0} 
 -- $pattern:loadArgs: "call: {   %basic 113" >E:"call":descNo:119} 
 -- ptn:loadArgs:E "call" 
 -- {(ObjectInvocation_Unary; (name: "call"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "call" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "call" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"call":rec:main 
 -- $ObjectInvocation_Unary:invoke: "call" >rec:"main" ATd:"pattern" E:"call" E.ATd:"call" unique:"False" 
 -- OI:invoke: "call" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"call":rec:main 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"call":rec:main 
 -- OI:invoke:B: "call" E: "call"  rec: "main"  useRtnV: false "call: {   %basic 113}" 
 -- OI:invoke:before:ATdx.invoke: pattern call 
 -- $pattern:invoke: "call: {   %basic 113" E: "call" useRTNv: "False"} 
 -- ptn:invoke: "call" E: "call" ptnKind: 0 useRtnV: false 
 call(D)Resume
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"call":rec:main 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"call":rec:main 
 -- 
 -- OI:invoke:C: call :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"call":rec:main 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 120 
 -- Items:GenClass: $120 descNo: 120 isValue: false 
 -- Items:GenClass: $120 descNo: 21 isValue: false 

 CLASS $120 120 1 loopX 115
 -- Store itemArgs: sleep(100){restart(loopX)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=120 vDescInx=120 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "sleep(100)" 
 -- $ObjectGenerator:gen: "sleep(100)" >OGid:"sleep" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "sleep(100)" 
 -- OG:before:super.gen: "sleep(100)" 
 -- $Invocation:gen: "sleep(100)" >useRtnV:"False"superAdj: 0 descNo: 100 
 -- INV:gen: "sleep(100)" 
 -- isConstant: "Invocation" "sleep(100)" 
 -- needorigin: "sleep(100)" 
 -- needOrigin:E: "sleep(100)"  E.ATd: "sleep: {   %basic 15;   in V: var integer}" 
 -- doNeedOrigin:Ex: "sleep(100)" 
 -- computeAdr:superAdj: 0 "sleep(100)" 
 -- computeAdr: 1 :rec: "none"  E: "sleep(100)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "sleep(100)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "sleep(100)" >on:6 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "sleep(100)" >ATd.off:0 (isPtn):on:6:superAdj:0"sleep: {   %basic 15;   in V: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAd ...} 
 -- $pattern:getAdr: "sleep: {   %basic 15;   in V: var integer" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sleep(100)":rec:- 
 -- E.on: 6 
 -- beforeIsValueObj:E: "sleep(100)"  ATd: "sleep: {   %basic 15;   in V: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sleep(100)":rec:- 
 -- computeAdr:isLast:E:  "sleep(100)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sleep(100)":rec:- 
 -- rec:  "sleep(100)" E:  "sleep(100)" 
 -- INV:gen:E.loadArgs "sleep(100)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "sleep(100)" >staticOff:0 "sleep: {   %basic 15;   in V: var integer" superAdj:0arg:"100"} 
 -- $pattern:loadArgs: "sleep: {   %basic 15;   in V: var integer" >E:"sleep(100)":descNo:100} 
 -- ptn:loadArgs:E "sleep(100)" 
 -- {(ObjectInvocation_KeyWord; (name: "sleep"); (Arguments;  (name: "sleep");  (name: "(");  (ObjectGenerator;   (Invocation;    (ConstLiteral 100));   (Items descNo: 0 origD ...} 
 -- args: "sleep(100)" 
 -- E: "ObjectGenerator" 100 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "sleep(100)" "ObjectInvocation_KeyWord" ActArg:  "100" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "sleep(100)"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "100" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "100" 
 -- OG:before:super.gen: "100" 
 -- $Invocation:gen: "100" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "100" 
 -- isConstant: "Invocation" "100" 
 -- needorigin: "100" 
 -- needOrigin:E: "100"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: va ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "100" E:  "100" 
 -- INV:gen:E.loadArgs "100" 
 -- $ConstLiteral:loadArgs: "100"  
 -- INV:gen:after:E.loadArgs "100" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "100" 
 -- $ConstLiteral:invoke: "100"  
 pushc 100
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "100" :isBasicVal: true 
 -- case:B: 100 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "sleep(100)" 
 -- INV:gen:after:E.loadArgs "sleep(100)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "sleep(100)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sleep(100) ..." 
 -- $ObjectInvocation_KeyWord:invoke: "sleep(100)" >rec:"sleep(100)" ATd:"pattern" E:"sleep(100)" E.ATd:"sleep" unique:"False" 
 -- OI:invoke: "sleep(100)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sleep(100)":rec:sleep(100) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sleep(100)":rec:sleep(100) 
 -- OI:invoke:B: "sleep(100)" E: "sleep(100)"  rec: "sleep(100)"  useRtnV: false "sleep: {   %basic 15;   in V: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern sleep 
 -- $pattern:invoke: "sleep: {   %basic 15;   in V: var integer" E: "sleep(100)" useRTNv: "False"} 
 -- ptn:invoke: "sleep" E: "sleep(100)" ptnKind: 0 useRtnV: false 
 %sleep 15
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sleep(100)":rec:sleep(100) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sleep(100)":rec:sleep(100) 
 -- 
 -- OI:invoke:C: sleep(100) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sleep(100)":rec:sleep(100) 
 -- genclass:stmt: "restart(loopX)" 
 -- $ObjectGenerator:gen: "restart(loopX)" >OGid:"restart" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "restart(loopX)" 
 -- OG:before:super.gen: "restart(loopX)" 
 -- $Invocation:gen: "restart(loopX)" >useRtnV:"False"superAdj: 0 descNo: 50 
 -- INV:gen: "restart(loopX)" 
 -- isConstant: "Invocation" "restart(loopX)" 
 -- needorigin: "restart(loopX)" 
 -- needOrigin:E: "restart(loopX)"  E.ATd: "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- doNeedOrigin:Ex: "restart(loopX)" 
 -- computeAdr:superAdj: 0 "restart(loopX)" 
 -- computeAdr: 1 :rec: "none"  E: "restart(loopX)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "restart(loopX)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "restart(loopX)" >on:6 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "restart(loopX)" >ATd.off:0 (isPtn):on:6:superAdj:0"restart(V: var integer):  -- odd parameter type!{   %basic 102":Adr:off:0 size:0 isFl ...} 
 -- $pattern:getAdr: "restart(V: var integer):  -- odd parameter type!{   %basic 102" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loopX)":rec:- 
 -- E.on: 6 
 -- beforeIsValueObj:E: "restart(loopX)"  ATd: "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loopX)":rec:- 
 -- computeAdr:isLast:E:  "restart(loopX)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loopX)":rec:- 
 -- rec:  "restart(loopX)" E:  "restart(loopX)" 
 -- INV:gen:E.loadArgs "restart(loopX)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "restart(loopX)" >staticOff:0 "restart(V: var integer):  -- odd parameter type!{   %basic 102" superAdj:0arg:"loopX"} 
 -- $pattern:loadArgs: "restart(V: var integer):  -- odd parameter type!{   %basic 102" >E:"restart(loopX)":descNo:50} 
 -- INV:gen:after:E.loadArgs "restart(loopX)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "restart(loopX)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restar ..." 
 -- $ObjectInvocation_KeyWord:invoke: "restart(loopX)" >rec:"restart(loopX)" ATd:"pattern" E:"restart(loopX)" E.ATd:"restart(V: var integer)" unique:"False" 
 -- OI:invoke: "restart(loopX)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loopX)":rec:restart(loopX) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loopX)":rec:restart(loopX) 
 -- OI:invoke:B: "restart(loopX)" E: "restart(loopX)"  rec: "restart(loopX)"  useRtnV: false "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- OI:invoke:before:ATdx.invoke: pattern restart(V: var integer) 
 -- $pattern:invoke: "restart(V: var integer):  -- odd parameter type!{   %basic 102" E: "restart(loopX)" useRTNv: "False"} 
 -- ptn:invoke: "restart(V: var integer)" E: "restart(loopX)" ptnKind: 0 useRtnV: false 
 break  1 1 115 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loopX)":rec:restart(loopX) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loopX)":rec:restart(loopX) 
 -- 
 -- OI:invoke:C: restart(loopX) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loopX)":rec:restart(loopX) 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 74 
 -- Items:GenClass: P_status descNo: 74 isValue: false 
 -- Items:GenClass: P_status descNo: 21 isValue: false 

 CLASS P_status 74 1 BasicSystem 72
 -- Store itemArgs: %globals{%Public;ACTIVE: val 1;WAITING: val 2;TERMINATED: val 3} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=74 vDescInx=74 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%globals"  
 -- $Property:gen: "%Public"  
 -- $val:gen: "ACTIVE: val 1"  
 -- DI:gen: "ACTIVE: val 1" DI:isConst: true :isBasicValue: true :primNo: 1 
 -- DI:add:BP2:  ACTIVE 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- dataItem:store:basicValue: off: 1  NewOff: 2 
 pushThis 
 storeg ACTIVE 2
 -- $val:gen: "WAITING: val 2"  
 -- DI:gen: "WAITING: val 2" DI:isConst: true :isBasicValue: true :primNo: 1 
 -- DI:add:BP2:  WAITING 
 -- $ObjectGenerator:gen: "2" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "2" 
 -- OG:before:super.gen: "2" 
 -- $Invocation:gen: "2" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "2" 
 -- isConstant: "Invocation" "2" 
 -- needorigin: "2" 
 -- needOrigin:E: "2"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "2" E:  "2" 
 -- INV:gen:E.loadArgs "2" 
 -- $ConstLiteral:loadArgs: "2"  
 -- INV:gen:after:E.loadArgs "2" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "2" 
 -- $ConstLiteral:invoke: "2"  
 pushc 2
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- dataItem:store:basicValue: off: 2  NewOff: 3 
 pushThis 
 storeg WAITING 3
 -- $val:gen: "TERMINATED: val 3"  
 -- DI:gen: "TERMINATED: val 3" DI:isConst: true :isBasicValue: true :primNo: 1 
 -- DI:add:BP2:  TERMINATED 
 -- $ObjectGenerator:gen: "3" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "3" 
 -- OG:before:super.gen: "3" 
 -- $Invocation:gen: "3" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "3" 
 -- isConstant: "Invocation" "3" 
 -- needorigin: "3" 
 -- needOrigin:E: "3"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "3" E:  "3" 
 -- INV:gen:E.loadArgs "3" 
 -- $ConstLiteral:loadArgs: "3"  
 -- INV:gen:after:E.loadArgs "3" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "3" 
 -- $ConstLiteral:invoke: "3"  
 pushc 3
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- dataItem:store:basicValue: off: 3  NewOff: 4 
 pushThis 
 storeg TERMINATED 4
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%globals" 
 -- $Property:gen: "%globals"  
 -- genclass:stmt: "%Public" 
 -- $Property:gen: "%Public"  
 L2:
 -- pushReturn:  "P_status" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 75 
 -- Items:GenClass: sch descNo: 75 isValue: false 
 -- Items:GenClass: sch descNo: 21 isValue: false 

 CLASS sch 75 1 BasicSystem 72
 -- Store itemArgs: L: obj Lock("Sch:lock"){M: var integer;%Public;entry: ;   L.get;   inner(entry);   L.free;add: ;   entry;      M := M + 1;dcr: ;   entry;      M := M - 1;r ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=75 vDescInx=75 vdtTop: 1 
 mvStack 
 -- $obj:gen: "L: obj Lock("Sch:lock")"  
 -- DI:gen: "L: obj Lock("Sch:lock")" DI:isConst: true :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  L 
 -- $ObjectGenerator:gen: "Lock("Sch:lock")" >OGid:"Lock" IS.isempty! staticOff=2 descNo=0 superAdj=0 
 -- OG:gen: "Lock("Sch:lock")" 
 -- OG:before:super.gen: "Lock("Sch:lock")" 
 -- $Invocation:gen: "Lock("Sch:lock")" >useRtnV:"False"superAdj: 0 descNo: 76 
 -- INV:gen: "Lock("Sch:lock")" 
 -- isConstant: "Invocation" "Lock("Sch:lock")" 
 -- needorigin: "Lock("Sch:lock")" 
 -- needOrigin:E: "Lock("Sch:lock")"  E.ATd: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   g ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%globals{   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ; ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "Lock("Sch:lock")" E:  "Lock("Sch:lock")" 
 -- INV:gen:E.loadArgs "Lock("Sch:lock")" 
 -- $ObjectInvocation_KeyWord:loadArgs: "Lock("Sch:lock")" >staticOff:0 "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   in ..."} 
 -- $pattern:loadArgs: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ; ..."} 
 -- ptn:loadArgs:E "Lock("Sch:lock")" 
 -- {(ObjectInvocation_KeyWord; (name: "Lock"); (Arguments;  (name: "Lock");  (name: "(");  (ObjectGenerator;   (Invocation;    (String: Sch:lock));   (Items descNo: 0 origDes ...} 
 -- args: "Lock("Sch:lock")" 
 -- E: "ObjectGenerator" "Sch:lock" 
 -- E.arg: "var" in id: var String 
 -- NonVirt: "Lock("Sch:lock")" "ObjectInvocation_KeyWord" ActArg:  ""Sch:lock"" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "Lock("Sch:lock")"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: ""Sch:lock"" >OGid:"String" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: ""Sch:lock"" 
 -- OG:before:super.gen: ""Sch:lock"" 
 -- $Invocation:gen: ""Sch:lock"" >useRtnV:"True"superAdj: 0 
 -- INV:gen: ""Sch:lock"" 
 -- isConstant: "Invocation" ""Sch:lock"" 
 -- needorigin: ""Sch:lock"" 
 -- needOrigin:E: ""Sch:lock""  E.ATd: "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V : ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  ""Sch:lock"" E:  ""Sch:lock"" 
 -- INV:gen:E.loadArgs ""Sch:lock"" 
 -- $String::loadArgs: ""Sch:lock""  
 -- INV:gen:after:E.loadArgs ""Sch:lock"" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: String: ""Sch:lock"" 
 -- $String::invoke: ""Sch:lock""  
 pushText "Sch:lock"
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in id: var String" :isBasicVal: false :valueObj: false 
 -- :actArg: ""Sch:lock"" :isBasicVal: false 
 -- case:B: "Sch:lock" ObjectGenerator 5 5 5 false false 
 -- end:loadArgs:NonVirt: "Lock("Sch:lock")" 
 -- INV:gen:after:E.loadArgs "Lock("Sch:lock")" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "Lock("Sch:lock")" 
 -- $ObjectInvocation_KeyWord:invoke: "Lock("Sch:lock")" >rec:"Lock("Sch:lock")" ATd:"pattern" E:"Lock("Sch:lock")" E.ATd:"Lock" unique:"False" 
 -- OI:invoke: "Lock("Sch:lock")" 
 -- 
 -- OI:invoke:B: "Lock("Sch:lock")" E: "Lock("Sch:lock")"  rec: "Lock("Sch:lock")"  useRtnV: false "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: v ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Lock 
 -- $pattern:invoke: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ;   ..."} 
 -- ptn:invoke: "Lock" E: "Lock("Sch:lock")" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 2 adr:none 
 invoke Lock 76 2 1
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: Lock("Sch:lock") :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- $var:gen: "M: var integer"  
 -- DI:gen: "M: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  M 
 -- $Property:gen: "%Public"  
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%Public" 
 -- $Property:gen: "%Public"  
 L2:
 -- pushReturn:  "sch" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 76 
 -- Items:GenClass: Lock descNo: 76 isValue: false 
 -- Items:GenClass: Lock descNo: 21 isValue: false 

 CLASS Lock 76 0 BasicSystemLib 38
 -- Store itemArgs: %globals{%Public;in id: var String;%private;free_M: var integer;%public;init: ;   free_M := 0;get: ;   loop: obj ;      res: var integer;      i: var integ ...} 
 -- in id: var String true 5 
 pushThis 
 rstoreg  id 1
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 allocEventQ
 -- vdtAdd: inx=1 descInx=76 vDescInx=76 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%globals"  
 -- $Property:gen: "%Public"  
 -- $var:gen: "in id: var String"  
 -- DI:gen: "in id: var String" DI:isConst: false :isBasicValue: false :primNo: 5 
 -- $Property:gen: "%private"  
 -- $var:gen: "free_M: var integer"  
 -- DI:gen: "free_M: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  free_M 
 -- $Property:gen: "%public"  
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%globals" 
 -- $Property:gen: "%globals"  
 -- genclass:stmt: "%Public" 
 -- $Property:gen: "%Public"  
 -- genclass:stmt: "%private" 
 -- $Property:gen: "%private"  
 -- genclass:stmt: "%public" 
 -- $Property:gen: "%public"  
 L2:
 -- pushReturn:  "Lock" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 77 
 -- Items:GenClass: SQS descNo: 77 isValue: false 
 -- Items:GenClass: SQS descNo: 21 isValue: false 

 CLASS SQS 77 1 BasicSystem 72
 -- Store itemArgs: Q: obj ProcessQueue{L: obj Lock("SQS:Lock:");V: var integer;W: var integer;%Public;entry: ;   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   in ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=77 vDescInx=77 vdtTop: 1 
 mvStack 
 -- $obj:gen: "Q: obj ProcessQueue"  
 -- DI:gen: "Q: obj ProcessQueue" DI:isConst: true :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  Q 
 -- $ObjectGenerator:gen: "ProcessQueue" >OGid:"ProcessQueue" IS.isempty! staticOff=2 descNo=0 superAdj=0 
 -- OG:gen: "ProcessQueue" 
 -- OG:before:super.gen: "ProcessQueue" 
 -- $Invocation:gen: "ProcessQueue" >useRtnV:"False"superAdj: 0 descNo: 79 
 -- INV:gen: "ProcessQueue" 
 -- isConstant: "Invocation" "ProcessQueue" 
 -- needorigin: "ProcessQueue" 
 -- needOrigin:E: "ProcessQueue"  E.ATd: "ProcessQueue: LIB.Collections.QueueLib.Queue{   %Public;   displayx: ;      put('Q')}" 
 -- Ex:loadOrign:no:loadOrigin:  "LIB.Collections.QueueLib.Queue{   %Public;   displayx: ;      put('Q')}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "ProcessQueue" E:  "ProcessQueue" 
 -- INV:gen:E.loadArgs "ProcessQueue" 
 -- $ObjectInvocation_Unary:loadArgs: "ProcessQueue" >staticOff:0 "ProcessQueue: LIB.Collections.QueueLib.Queue{   %Public;   displayx: ;      put('Q')" superAdj:0} 
 -- $pattern:loadArgs: "ProcessQueue: LIB.Collections.QueueLib.Queue{   %Public;   displayx: ;      put('Q')" >E:"ProcessQueue":descNo:79} 
 -- ptn:loadArgs:E "ProcessQueue" 
 -- {(ObjectInvocation_Unary; (name: "ProcessQueue"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "ProcessQueue" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "ProcessQueue" 
 -- $ObjectInvocation_Unary:invoke: "ProcessQueue" >rec:"ProcessQueue" ATd:"pattern" E:"ProcessQueue" E.ATd:"ProcessQueue" unique:"False" 
 -- OI:invoke: "ProcessQueue" 
 -- 
 -- OI:invoke:B: "ProcessQueue" E: "ProcessQueue"  rec: "ProcessQueue"  useRtnV: false "ProcessQueue: LIB.Collections.QueueLib.Queue{   %Public;   displayx: ;      put('Q')}" 
 -- OI:invoke:before:ATdx.invoke: pattern ProcessQueue 
 -- $pattern:invoke: "ProcessQueue: LIB.Collections.QueueLib.Queue{   %Public;   displayx: ;      put('Q')" E: "ProcessQueue" useRTNv: "False"} 
 -- ptn:invoke: "ProcessQueue" E: "ProcessQueue" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 2 adr:none 
 invoke ProcessQueue 79 2 1
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: ProcessQueue :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- $obj:gen: "L: obj Lock("SQS:Lock:")"  
 -- DI:gen: "L: obj Lock("SQS:Lock:")" DI:isConst: true :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  L 
 -- $ObjectGenerator:gen: "Lock("SQS:Lock:")" >OGid:"Lock" IS.isempty! staticOff=3 descNo=0 superAdj=0 
 -- OG:gen: "Lock("SQS:Lock:")" 
 -- OG:before:super.gen: "Lock("SQS:Lock:")" 
 -- $Invocation:gen: "Lock("SQS:Lock:")" >useRtnV:"False"superAdj: 0 descNo: 76 
 -- INV:gen: "Lock("SQS:Lock:")" 
 -- isConstant: "Invocation" "Lock("SQS:Lock:")" 
 -- needorigin: "Lock("SQS:Lock:")" 
 -- needOrigin:E: "Lock("SQS:Lock:")"  E.ATd: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;    ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%globals{   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ; ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "Lock("SQS:Lock:")" E:  "Lock("SQS:Lock:")" 
 -- INV:gen:E.loadArgs "Lock("SQS:Lock:")" 
 -- $ObjectInvocation_KeyWord:loadArgs: "Lock("SQS:Lock:")" >staticOff:0 "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   i ..."} 
 -- $pattern:loadArgs: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ; ..."} 
 -- ptn:loadArgs:E "Lock("SQS:Lock:")" 
 -- {(ObjectInvocation_KeyWord; (name: "Lock"); (Arguments;  (name: "Lock");  (name: "(");  (ObjectGenerator;   (Invocation;    (String: SQS:Lock:));   (Items descNo: 0 origDe ...} 
 -- args: "Lock("SQS:Lock:")" 
 -- E: "ObjectGenerator" "SQS:Lock:" 
 -- E.arg: "var" in id: var String 
 -- NonVirt: "Lock("SQS:Lock:")" "ObjectInvocation_KeyWord" ActArg:  ""SQS:Lock:"" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "Lock("SQS:Lock:")"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: ""SQS:Lock:"" >OGid:"String" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: ""SQS:Lock:"" 
 -- OG:before:super.gen: ""SQS:Lock:"" 
 -- $Invocation:gen: ""SQS:Lock:"" >useRtnV:"True"superAdj: 0 
 -- INV:gen: ""SQS:Lock:"" 
 -- isConstant: "Invocation" ""SQS:Lock:"" 
 -- needorigin: ""SQS:Lock:"" 
 -- needOrigin:E: ""SQS:Lock:""  E.ATd: "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  ""SQS:Lock:"" E:  ""SQS:Lock:"" 
 -- INV:gen:E.loadArgs ""SQS:Lock:"" 
 -- $String::loadArgs: ""SQS:Lock:""  
 -- INV:gen:after:E.loadArgs ""SQS:Lock:"" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: String: ""SQS:Lock:"" 
 -- $String::invoke: ""SQS:Lock:""  
 pushText "SQS:Lock:"
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in id: var String" :isBasicVal: false :valueObj: false 
 -- :actArg: ""SQS:Lock:"" :isBasicVal: false 
 -- case:B: "SQS:Lock:" ObjectGenerator 5 5 5 false false 
 -- end:loadArgs:NonVirt: "Lock("SQS:Lock:")" 
 -- INV:gen:after:E.loadArgs "Lock("SQS:Lock:")" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "Lock("SQS:Lock:")" 
 -- $ObjectInvocation_KeyWord:invoke: "Lock("SQS:Lock:")" >rec:"Lock("SQS:Lock:")" ATd:"pattern" E:"Lock("SQS:Lock:")" E.ATd:"Lock" unique:"False" 
 -- OI:invoke: "Lock("SQS:Lock:")" 
 -- 
 -- OI:invoke:B: "Lock("SQS:Lock:")" E: "Lock("SQS:Lock:")"  rec: "Lock("SQS:Lock:")"  useRtnV: false "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Lock 
 -- $pattern:invoke: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ;   ..."} 
 -- ptn:invoke: "Lock" E: "Lock("SQS:Lock:")" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 3 adr:none 
 invoke Lock 76 3 1
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: Lock("SQS:Lock:") :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- $var:gen: "V: var integer"  
 -- DI:gen: "V: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  V 
 -- $var:gen: "W: var integer"  
 -- DI:gen: "W: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  W 
 -- $Property:gen: "%Public"  
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%Public" 
 -- $Property:gen: "%Public"  
 L2:
 -- pushReturn:  "SQS" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 78 
 -- Items:GenClass: Queue descNo: 78 isValue: false 
 -- Items:GenClass: Queue descNo: 21 isValue: false 

 CLASS Queue 78 0 QueueLib 41
 -- Store itemArgs: %globals{idf: var LIB.StringLib.String;idc: var integer;noOfElm: var integer;Element: ;   in elm: ref Object;   out res: ref Element;   id: var integer;    ...} 
 allocEventQ
 -- vdtAdd: inx=1 descInx=78 vDescInx=78 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%globals"  
 -- $var:gen: "idf: var LIB.StringLib.String"  
 -- DI:gen: "idf: var LIB.StringLib.String" DI:isConst: false :isBasicValue: false :primNo: 5 
 -- StringVar "idf: var LIB.StringLib.String" 
 pushText ""
 pushThis 
 rstoreg  idf 1
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 1 V: R: 
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 -- $var:gen: "idc: var integer"  
 -- DI:gen: "idc: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  idc 
 -- $var:gen: "noOfElm: var integer"  
 -- DI:gen: "noOfElm: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  noOfElm 
 -- $ref:gen: "head: ref Element"  
 -- DI:gen: "head: ref Element" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- $ref:gen: "last: ref Element"  
 -- DI:gen: "last: ref Element" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- $Property:gen: "%Public"  
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%globals" 
 -- $Property:gen: "%globals"  
 -- genclass:stmt: "%Public" 
 -- $Property:gen: "%Public"  
 L2:
 -- pushReturn:  "Queue" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 137 
 -- Items:GenClass: Element descNo: 137 isValue: false 
 -- Items:GenClass: Element descNo: 21 isValue: false 

 CLASS Element 137 1 Queue 78
 -- Store itemArgs: in elm: ref Object{out res: ref Element;id: var integer;pred: ref Element;succ: ref Element;res := this(Element);idc := idc + 1;id := idc} 
 -- in elm: ref Object true 64 
 -- DI:store: "elm" 
 pushThis 
 rstoreg  elm 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=137 vDescInx=137 vdtTop: 1 
 mvStack 
 -- $ref:gen: "in elm: ref Object"  
 -- DI:gen: "in elm: ref Object" DI:isConst: false :isBasicValue: false :primNo: 64 
 -- $ref:gen: "out res: ref Element"  
 -- DI:gen: "out res: ref Element" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- $var:gen: "id: var integer"  
 -- DI:gen: "id: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  id 
 -- $ref:gen: "pred: ref Element"  
 -- DI:gen: "pred: ref Element" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- $ref:gen: "succ: ref Element"  
 -- DI:gen: "succ: ref Element" DI:isConst: false :isBasicValue: false :primNo: 0 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "res := this(Element)" 
 -- $Assign:gen: "res := this(Element)"  
 -- assign: "res := this(Element)" 
 -- computeAdr:superAdj: 0 "res" 
 -- computeAdr: 1 :rec: "none"  E: "res" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "res"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "res" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "res" >ATd.off:3:on:0:superAdj:0"out res: ref Element":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ... 
 -- $ref:getAdr: "out res: ref Element" >newOff:3,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVal ... 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "res" 
 -- AssignmentStatement:gen: "res := this(Element)" right.label: "ObjectGenerator" "this(Element)" 
 -- $ObjectGenerator:gen: "this(Element)" >OGid:"this" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "this(Element)" 
 -- OG:before:super.gen: "this(Element)" 
 -- $Invocation:gen: "this(Element)" >useRtnV:"True"superAdj: 0 descNo: 31 
 -- INV:gen: "this(Element)" 
 -- isConstant: "Invocation" "this(Element)" 
 -- needorigin: "this(Element)" 
 -- needOrigin:E: "this(Element)"  E.ATd: "this: {   %basic 18;   in this: ref Object}" 
 -- doNeedOrigin:Ex: "this(Element)" 
 -- computeAdr:superAdj: 0 "this(Element)" 
 -- computeAdr: 1 :rec: "none"  E: "this(Element)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "this(Element)"  
 pushThis 
 -- $ObjectInvocation_KeyWord:loadOrigin: "this(Element)" >on:4 superAdj:0 isValueObj:"False" 
 -- this_prim: Element :super.on: 1 
 -- $ObjectInvocation_KeyWord:getAdr: "this(Element)" >ATd.off:0 (isPtn):on:4:superAdj:0"this: {   %basic 18;   in this: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal:F sup ...} 
 -- $pattern:getAdr: "this: {   %basic 18;   in this: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(Element)":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "this(Element)"  ATd: "this: {   %basic 18;   in this: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(Element)":rec:- 
 -- computeAdr:isLast:E:  "this(Element)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(Element)":rec:- 
 -- rec:  "this(Element)" E:  "this(Element)" 
 -- INV:gen:E.loadArgs "this(Element)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "this(Element)" >staticOff:0 "this: {   %basic 18;   in this: ref Object" superAdj:0arg:"Element"} 
 -- $pattern:loadArgs: "this: {   %basic 18;   in this: ref Object" >E:"this(Element)":descNo:31} 
 -- INV:gen:after:E.loadArgs "this(Element)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "this(Element)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(Ele ..." 
 -- $ObjectInvocation_KeyWord:invoke: "this(Element)" >rec:"this(Element)" ATd:"pattern" E:"this(Element)" E.ATd:"this" unique:"False" 
 -- OI:invoke: "this(Element)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(Element)":rec:this(Element) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(Element)":rec:this(Element) 
 -- OI:invoke:B: "this(Element)" E: "this(Element)"  rec: "this(Element)"  useRtnV: true "this: {   %basic 18;   in this: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern this 
 -- $pattern:invoke: "this: {   %basic 18;   in this: ref Object" E: "this(Element)" useRTNv: "True"} 
 -- ptn:invoke: "this" E: "this(Element)" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(Element)":rec:this(Element) 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(Element)":rec:this(Element) 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(Element)":rec:this(Element) 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: this(Element) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(Element)":rec:this(Element) 
 -- rec: "res" dstE: "res" dstE.ATd: "out res: ref Element" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec: ... 
 -- dstDI.isBasicVal: false dstDI.isValObj: false dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- isValue: false  isAdr: true  descNo:  0 
 rswap 0
 rstoreg  EisNone 3
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-4,0)=[]
 -- assign:adr.store:B: 
 -- genclass:stmt: "idc := idc + 1" 
 -- $Assign:gen: "idc := idc + 1"  
 -- assign: "idc := idc + 1" 
 -- computeAdr:superAdj: 0 "idc" 
 -- computeAdr: 1 :rec: "none"  E: "idc" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "idc"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "idc" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "Element" on: 1 isValueObj: false 
 -- origin: Queue origin:isValueObj: false 
 rpushg Element$137 1
 -- $ObjectInvocation_Unary:getAdr: "idc" >ATd.off:2:on:1:superAdj:0"idc: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "idc: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "idc: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"idc":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"idc":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "idc"  ATd: "idc: var integer" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"idc":rec:- 
 -- computeAdr:isLast:E:  "idc" 
 -- AssignmentStatement:gen: "idc := idc + 1" right.label: "ObjectGenerator" "idc + 1" 
 -- $ObjectGenerator:gen: "idc + 1" >OGid:"+" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "idc + 1" 
 -- OG:before:super.gen: "idc + 1" 
 -- $Invocation:gen: "idc + 1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "idc + 1" 
 -- isConstant: "Invocation" "idc + 1" 
 -- needorigin: "idc + 1" 
 -- needOrigin:E: "idc + 1"  E.ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- doNeedOrigin:Ex: "idc + 1" 
 -- computeAdr:superAdj: 0 "idc + 1" 
 -- computeAdr: 1 :rec: "none"  E: "idc + 1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "idc + 1"  
 -- $BinOp:loadOrigin: "idc + 1"  
 -- BinaryExp:loadOrigin:empty: "idc + 1" superAdj: 0 
 -- $BinOp:getAdr: "idc + 1"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "idc + 1"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "idc + 1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "idc + 1" E:  "idc + 1" 
 -- INV:gen:E.loadArgs "idc + 1" 
 -- $BinOp:loadArgs: "idc + 1"  
 -- BinaryExp:loadArgs: "idc + 1" superAdj: 0 
 -- $Invocation:gen: "idc" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "idc" 
 -- isConstant: "Invocation" "idc" 
 -- notConst: idc idc: var integer 
 -- needorigin: "idc" 
 -- needOrigin:E: "idc"  E.ATd: "idc: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "idc" 
 -- computeAdr: 1 :rec: "none"  E: "idc" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "idc"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "idc" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "Element" on: 1 isValueObj: false 
 -- origin: Queue origin:isValueObj: false 
 rpushg Element$137 1
 -- $ObjectInvocation_Unary:getAdr: "idc" >ATd.off:2:on:1:superAdj:0"idc: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "idc: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "idc: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"idc":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"idc":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "idc"  ATd: "idc: var integer" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"idc":rec:- 
 -- computeAdr:isLast:E:  "idc" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"idc":rec:- 
 -- rec:  "idc" E:  "idc" 
 -- INV:gen:E.loadArgs "idc" 
 -- $ObjectInvocation_Unary:loadArgs: "idc" >staticOff:0 "idc: var integer" superAdj:0 
 -- $var:loadArgs: "idc: var integer" >E:"idc" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "idc" 
 -- {(ObjectInvocation_Unary; (name: "idc"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "idc" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "idc" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"idc":rec:- 
 -- $ObjectInvocation_Unary:invoke: "idc" >rec:"idc" ATd:"var" isValueObj E:"idc" E.ATd:"idc" unique:"False" 
 -- OI:invoke: "idc" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"idc":rec:idc 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"idc":rec:idc 
 -- OI:invoke:B: "idc" E: "idc"  rec: "idc"  useRtnV: true "idc: var integer" 
 -- OI:invoke:before:ATdx.invoke: var idc 
 -- $var:invoke: "idc: var integer" E: "idc">newOff:2 useRTNv: "True" 
 -- DI:invoke: "idc: var integer" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"idc":rec:idc 
 -- isCompositeValueObj: false E: "idc" "idc: var integer" true 
 -- E.ATd.isValueObj: false rec: "idc" 
 pushg 2 Queue$78
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -5 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -5 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"idc":rec:idc 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"idc":rec:idc 
 -- 
 -- OI:invoke:C: idc :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- left:#I "idc + 1" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"idc":rec:idc 
 -- $pattern:loadArgs: "+  : {   %basic 61;   in V: var integer;   out R: var integer" >E:"+ 1":descNo:49} 
 -- ptn:loadArgs:E "+ 1" 
 -- {(ObjectInvocation_Binary; (name: "+"); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 1));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "1" 
 -- E: "ObjectGenerator" 1 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "+ 1" "ObjectInvocation_Binary" ActArg:  "1" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ 1"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "1" :isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "+ 1" 
 -- BinaryExp:loadArgs:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"idc":rec:idc 
 -- INV:gen:after:E.loadArgs "idc + 1" 
 -- OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"idc":rec:idc 
 -- IV:E.invoke:useRtnVal: true E: BinOp "idc + 1" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"idc":rec:idc 
 -- $BinOp:invoke: "idc + 1"  
 -- BinaryExp:invoke: "idc" rec: "idc + 1" 
 -- M: "+ 1" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"idc":rec:idc 
 -- $ObjectInvocation_Binary:invoke: "+ 1" >rec:"idc" ATd:"pattern" E:"+ 1" E.ATd:"+  " unique:"False" 
 -- OI:invoke: "+ 1" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"idc":rec:idc 
 -- origin:isValueObj "integer" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"idc":rec:idc 
 -- OI:invoke:B: "+ 1" E: "+ 1"  rec: "idc"  useRtnV: true "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- $pattern:invoke: "+  : {   %basic 61;   in V: var integer;   out R: var integer" E: "+ 1" useRTNv: "True"} 
 -- ptn:invoke: "+  " E: "+ 1" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "idc" E: "+ 1" 
 -- arg:integer 
 plus
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:idc 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:idc 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: + 1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "idc" dstE: "idc" dstE.ATd: "idc: var integer" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"idc":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "idc + 1" 
 -- isArgOfAssignI2IwithUniValArg "idc := idc + 1" arg: "idc + 1" ObjectGenerator 
 -- arg.super.arg: "idc + 1" BinOp 
 -- recx:BinaryExp:recx: "idc + 1" 
 -- M: "+ 1" label: "ObjectInvocation_Binary" M.ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- checkInt2IntWithUnitArg:rec: "idc" E: "+ 1" 
 -- arg:integer 
 -- M:arg: "1" ObjectGenerator false 
 -- dstDI: "idc: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"idc":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg Queue$78 2
 -- assign:adr.store:B: 
 -- genclass:stmt: "id := idc" 
 -- $Assign:gen: "id := idc"  
 -- assign: "id := idc" 
 -- computeAdr:superAdj: 0 "id" 
 -- computeAdr: 1 :rec: "none"  E: "id" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "id"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "id" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "id" >ATd.off:4:on:0:superAdj:0"id: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- $var:getAdr: "id: var integer" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F orig ... 
 -- DI:OG: integer 
 -- before:floatTest:  "id: var integer" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"id":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"id":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"id":rec:- 
 -- computeAdr:isLast:E:  "id" 
 -- AssignmentStatement:gen: "id := idc" right.label: "ObjectGenerator" "idc" 
 -- $ObjectGenerator:gen: "idc" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "idc" 
 -- OG:before:super.gen: "idc" 
 -- $Invocation:gen: "idc" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "idc" 
 -- isConstant: "Invocation" "idc" 
 -- notConst: idc idc: var integer 
 -- needorigin: "idc" 
 -- needOrigin:E: "idc"  E.ATd: "idc: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "idc" 
 -- computeAdr: 1 :rec: "none"  E: "idc" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "idc"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "idc" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "Element" on: 1 isValueObj: false 
 -- origin: Queue origin:isValueObj: false 
 rpushg Element$137 1
 -- $ObjectInvocation_Unary:getAdr: "idc" >ATd.off:2:on:1:superAdj:0"idc: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "idc: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "idc: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"idc":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"idc":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "idc"  ATd: "idc: var integer" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"idc":rec:- 
 -- computeAdr:isLast:E:  "idc" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"idc":rec:- 
 -- rec:  "idc" E:  "idc" 
 -- INV:gen:E.loadArgs "idc" 
 -- $ObjectInvocation_Unary:loadArgs: "idc" >staticOff:0 "idc: var integer" superAdj:0 
 -- $var:loadArgs: "idc: var integer" >E:"idc" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "idc" 
 -- {(ObjectInvocation_Unary; (name: "idc"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "idc" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "idc" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"idc":rec:- 
 -- $ObjectInvocation_Unary:invoke: "idc" >rec:"idc" ATd:"var" isValueObj E:"idc" E.ATd:"idc" unique:"False" 
 -- OI:invoke: "idc" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"idc":rec:idc 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"idc":rec:idc 
 -- OI:invoke:B: "idc" E: "idc"  rec: "idc"  useRtnV: true "idc: var integer" 
 -- OI:invoke:before:ATdx.invoke: var idc 
 -- $var:invoke: "idc: var integer" E: "idc">newOff:2 useRTNv: "True" 
 -- DI:invoke: "idc: var integer" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"idc":rec:idc 
 -- isCompositeValueObj: false E: "idc" "idc: var integer" true 
 -- E.ATd.isValueObj: false rec: "idc" 
 pushg 2 Queue$78
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -6 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -6 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"idc":rec:idc 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"idc":rec:idc 
 -- 
 -- OI:invoke:C: idc :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"idc":rec:idc 
 -- rec: "id" dstE: "id" dstE.ATd: "id: var integer" useRtn: false :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"id":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "idc" 
 -- isArgOfAssignI2IwithUniValArg "id := idc" arg: "idc" ObjectGenerator 
 -- arg.super.arg: "idc" ObjectInvocation_Unary 
 -- dstDI: "id: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"id":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg Element$137 4
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  "Element" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:6 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 79 
 -- Items:GenClass: ProcessQueue descNo: 79 isValue: false 
 -- Items:GenClass: ProcessQueue descNo: 78 isValue: false 
 -- Items:GenClass: Queue descNo: 21 isValue: false 

 CLASS ProcessQueue 79 0 BasicSystem 72
 -- vdtTableCopy: I:1:78
 -- Store itemArgs: %Public{displayx: ;   put('Q')} 
 -- super Queue
 -- push:super.origin: 
 -- handleSuperArgs:E: "Queue" theIS: "%Public{displayx: ;   put('Q')}" 
 -- super.sig:not:none:superAdj: 0 
 -- $ObjectInvocation_Unary:loadArgs: "Queue" >staticOff:0 "Queue: {   %globals;   idf: var LIB.StringLib.String;   idc: var integer;   noOfElm: var integer;   Element: ;      ..."} 
 -- $pattern:loadArgs: "Queue: {   %globals;   idf: var LIB.StringLib.String;   idc: var integer;   noOfElm: var integer;   Element: ;      in elm: ref Object;      out res: r ..."} 
 -- ptn:loadArgs:E "Queue" 
 -- {(ObjectInvocation_Unary; (name: "Queue"); (Arguments))} 
 -- args: "" 
 -- hArgOrg:super: Queue 
 -- Store itemArgs: %Public{displayx: ;   put('Q')} 
 allocEventQ
 -- vdtAdd: inx=1 descInx=79 vDescInx=78 vdtTop: 1 
 -- $Property:gen: "%globals"  
 -- $var:gen: "idf: var LIB.StringLib.String"  
 -- DI:gen: "idf: var LIB.StringLib.String" DI:isConst: false :isBasicValue: false :primNo: 5 
 -- StringVar "idf: var LIB.StringLib.String" 
 pushText ""
 pushThis 
 rstoreg  idf 1
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 1 V: R: 
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 -- $var:gen: "idc: var integer"  
 -- DI:gen: "idc: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  idc 
 -- $var:gen: "noOfElm: var integer"  
 -- DI:gen: "noOfElm: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  noOfElm 
 -- $ref:gen: "head: ref Element"  
 -- DI:gen: "head: ref Element" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- $ref:gen: "last: ref Element"  
 -- DI:gen: "last: ref Element" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- $Property:gen: "%Public"  
 -- $Property:gen: "%Public"  
 rtnAlloc 1
 toSuper 78
DO:
 mvStack 
 L1:
 -- genclass:stmt: "%Public" 
 -- $Property:gen: "%Public"  
 L2:
 rtnInner  M
 END OSDV:0 objSize:5 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 80 
 -- Items:GenClass: console descNo: 80 isValue: false 
 -- Items:GenClass: console descNo: 21 isValue: false 

 CLASS console 80 1 BasicSystem 72
 -- Store itemArgs: L: obj Lock("Console:lock"){%public;display: ;   L.get;   inner(display);   L.free;L.init} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=80 vDescInx=80 vdtTop: 1 
 mvStack 
 -- $obj:gen: "L: obj Lock("Console:lock")"  
 -- DI:gen: "L: obj Lock("Console:lock")" DI:isConst: true :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  L 
 -- $ObjectGenerator:gen: "Lock("Console:lock")" >OGid:"Lock" IS.isempty! staticOff=2 descNo=0 superAdj=0 
 -- OG:gen: "Lock("Console:lock")" 
 -- OG:before:super.gen: "Lock("Console:lock")" 
 -- $Invocation:gen: "Lock("Console:lock")" >useRtnV:"False"superAdj: 0 descNo: 76 
 -- INV:gen: "Lock("Console:lock")" 
 -- isConstant: "Invocation" "Lock("Console:lock")" 
 -- needorigin: "Lock("Console:lock")" 
 -- needOrigin:E: "Lock("Console:lock")"  E.ATd: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0; ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%globals{   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ; ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "Lock("Console:lock")" E:  "Lock("Console:lock")" 
 -- INV:gen:E.loadArgs "Lock("Console:lock")" 
 -- $ObjectInvocation_KeyWord:loadArgs: "Lock("Console:lock")" >staticOff:0 "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;  ..."} 
 -- $pattern:loadArgs: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ; ..."} 
 -- ptn:loadArgs:E "Lock("Console:lock")" 
 -- {(ObjectInvocation_KeyWord; (name: "Lock"); (Arguments;  (name: "Lock");  (name: "(");  (ObjectGenerator;   (Invocation;    (String: Console:lock));   (Items descNo: 0 ori ...} 
 -- args: "Lock("Console:lock")" 
 -- E: "ObjectGenerator" "Console:lock" 
 -- E.arg: "var" in id: var String 
 -- NonVirt: "Lock("Console:lock")" "ObjectInvocation_KeyWord" ActArg:  ""Console:lock"" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "Lock("Console:lock")"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: ""Console:lock"" >OGid:"String" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: ""Console:lock"" 
 -- OG:before:super.gen: ""Console:lock"" 
 -- $Invocation:gen: ""Console:lock"" >useRtnV:"True"superAdj: 0 
 -- INV:gen: ""Console:lock"" 
 -- isConstant: "Invocation" ""Console:lock"" 
 -- needorigin: ""Console:lock"" 
 -- needOrigin:E: ""Console:lock""  E.ATd: "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  ""Console:lock"" E:  ""Console:lock"" 
 -- INV:gen:E.loadArgs ""Console:lock"" 
 -- $String::loadArgs: ""Console:lock""  
 -- INV:gen:after:E.loadArgs ""Console:lock"" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: String: ""Console:lock"" 
 -- $String::invoke: ""Console:lock""  
 pushText "Console:lock"
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in id: var String" :isBasicVal: false :valueObj: false 
 -- :actArg: ""Console:lock"" :isBasicVal: false 
 -- case:B: "Console:lock" ObjectGenerator 5 5 5 false false 
 -- end:loadArgs:NonVirt: "Lock("Console:lock")" 
 -- INV:gen:after:E.loadArgs "Lock("Console:lock")" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "Lock("Console:lock")" 
 -- $ObjectInvocation_KeyWord:invoke: "Lock("Console:lock")" >rec:"Lock("Console:lock")" ATd:"pattern" E:"Lock("Console:lock")" E.ATd:"Lock" unique:"False" 
 -- OI:invoke: "Lock("Console:lock")" 
 -- 
 -- OI:invoke:B: "Lock("Console:lock")" E: "Lock("Console:lock")"  rec: "Lock("Console:lock")"  useRtnV: false "Lock: {   %globals;   %Public;   in id: var String;   %private; ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Lock 
 -- $pattern:invoke: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ;   ..."} 
 -- ptn:invoke: "Lock" E: "Lock("Console:lock")" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 2 adr:none 
 invoke Lock 76 2 1
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: Lock("Console:lock") :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- $Property:gen: "%public"  
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%public" 
 -- $Property:gen: "%public"  
 -- genclass:stmt: "L.init" 
 -- $ObjectGenerator:gen: "L.init" >OGid:"init" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L.init" 
 -- OG:before:super.gen: "L.init" 
 -- $Invocation:gen: "L.init" >useRtnV:"False"superAdj: 0 descNo: 81 
 -- INV:gen: "L.init" 
 -- isConstant: "Invocation" "L.init" 
 -- needorigin: "L.init" 
 -- needOrigin:E: "init"  E.ATd: "init: {   free_M := 0}" 
 -- doNeedOrigin:Ex: "init" 
 -- computeAdr:superAdj: 0 "L.init" 
 -- computeAdr: 1 :rec: "none"  E: "L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L" >ATd.off:2:on:0:superAdj:0"L: obj Lock("Console:lock")":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIs ... 
 -- $obj:getAdr: "L: obj Lock("Console:lock")" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique: ... 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "L"  E: "init" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "init" >ATd.off:0 (isPtn):on:0:superAdj:0"init: {   free_M := 0":Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ...} 
 -- $pattern:getAdr: "init: {   free_M := 0" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "L" >staticOff:0 "L: obj Lock("Console:lock")" superAdj:0 
 -- $obj:loadArgs: "L: obj Lock("Console:lock")" >E:"L" 
 -- $pattern:loadArgs: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ; ..."} 
 -- ptn:loadArgs:E "L" 
 -- {(ObjectInvocation_Unary; (name: "L"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "L" >rec:"L" ATd:"obj" E:"init" E.ATd:"init" unique:"False" 
 -- OI:invoke: "L" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:L 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:L 
 -- OI:invoke:B: "L" E: "init"  rec: "L"  useRtnV: true "L: obj Lock("Console:lock")" 
 -- OI:invoke:before:ATdx.invoke: obj L 
 -- $obj:invoke: "L: obj Lock("Console:lock")" E: "init">newOff:2 useRTNv: "True" 
 -- DI:invoke: "L: obj Lock("Console:lock")" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:L 
 rpushg console$80 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:L 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:L 
 -- 
 -- OI:invoke:C: L :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "L" E: "init" 
 -- computeAdr:isLast:E:  "init" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:L 
 -- rec:  "L" E:  "init" 
 -- INV:gen:E.loadArgs "init" 
 -- $ObjectInvocation_Unary:loadArgs: "init" >staticOff:0 "init: {   free_M := 0" superAdj:0} 
 -- $pattern:loadArgs: "init: {   free_M := 0" >E:"init":descNo:81} 
 -- ptn:loadArgs:E "init" 
 -- {(ObjectInvocation_Unary; (name: "init"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "init" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "init" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:L 
 -- $ObjectInvocation_Unary:invoke: "init" >rec:"L" ATd:"pattern" E:"init" E.ATd:"init" unique:"False" 
 -- OI:invoke: "init" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:L 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:L 
 -- OI:invoke:B: "init" E: "init"  rec: "L"  useRtnV: false "init: {   free_M := 0}" 
 -- OI:invoke:before:ATdx.invoke: pattern init 
 -- $pattern:invoke: "init: {   free_M := 0" E: "init" useRTNv: "False"} 
 -- ptn:invoke: "init" E: "init" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:L 
 invoke init 81 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 1 V: R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:L 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:L 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: init :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:L 
 L2:
 -- pushReturn:  "console" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 81 
 -- Items:GenClass: init descNo: 81 isValue: false 
 -- Items:GenClass: init descNo: 21 isValue: false 

 CLASS init 81 1 Lock 76
 -- Store itemArgs: free_M := 0 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=81 vDescInx=81 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "free_M := 0" 
 -- $Assign:gen: "free_M := 0"  
 -- assign: "free_M := 0" 
 -- computeAdr:superAdj: 0 "free_M" 
 -- computeAdr: 1 :rec: "none"  E: "free_M" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "free_M"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "free_M" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "init" on: 1 isValueObj: false 
 -- origin: Lock origin:isValueObj: false 
 rpushg init$81 1
 -- $ObjectInvocation_Unary:getAdr: "free_M" >ATd.off:2:on:1:superAdj:0"free_M: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVal ... 
 -- $var:getAdr: "free_M: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F  ... 
 -- DI:OG: integer 
 -- before:floatTest:  "free_M: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"free_M":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"free_M":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "free_M"  ATd: "free_M: var integer" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"free_M":rec:- 
 -- computeAdr:isLast:E:  "free_M" 
 -- AssignmentStatement:gen: "free_M := 0" right.label: "ObjectGenerator" "0" 
 -- $ObjectGenerator:gen: "0" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "0" 
 -- OG:before:super.gen: "0" 
 -- $Invocation:gen: "0" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "0" 
 -- isConstant: "Invocation" "0" 
 -- needorigin: "0" 
 -- needOrigin:E: "0"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "0" E:  "0" 
 -- INV:gen:E.loadArgs "0" 
 -- $ConstLiteral:loadArgs: "0"  
 -- INV:gen:after:E.loadArgs "0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0" 
 -- $ConstLiteral:invoke: "0"  
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "free_M" dstE: "free_M" dstE.ATd: "free_M: var integer" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"free_ ..." 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "0" 
 -- isArgOfAssignI2IwithUniValArg "free_M := 0" arg: "0" ObjectGenerator 
 -- arg.super.arg: "0" ConstLiteral 
 -- dstDI: "free_M: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"free_M":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg Lock$76 2
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  "init" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 83 
 -- Items:GenClass: BasicProcess descNo: 83 isValue: false 
 -- Items:GenClass: BasicProcess descNo: 82 isValue: false 
 -- Items:GenClass: GeneralProcess descNo: 21 isValue: false 

 CLASS BasicProcess 83 4 BasicSystem 72
 -- vdtTableCopy: I:1:82 V:2:132 V:3:133 V:4:134 V:5:135 V:6:136 I:7:0
 -- vdtAdd: inx=7 descInx=83 vDescInx=83 vdtTop: 7 
 -- Store itemArgs: mkActive::< {   -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;   SQS.insert(this(BasicProcess));%Public;start::<   ...} 
 -- Store:Origin: 0 
 rShiftUp  1
 tstOriginIsNone 
 rstore  4 origin
 -- super GeneralProcess
 -- push:super.origin: 
 -- computeAdr:superAdj: 4 "GeneralProcess" 
 -- computeAdr: 1 :rec: "none"  E: "GeneralProcess" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "GeneralProcess"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "GeneralProcess" >on:2 superAdj:4 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 4 
 rpushg BasicSystem$72 4
 -- items:goOrigin:encOG: "BasicSystem" on: 2 isValueObj: false 
 -- origin: BasicSystemLib origin:isValueObj: false 
 rpushg BasicSystem$72 1
 -- items:goOrigin:encOG: "BasicSystemLib" on: 1 isValueObj: false 
 -- origin: LIB origin:isValueObj: false 
 rpushg BasicSystemLib$38 1
 -- IV:viaIncl:on: 0 "BETA"  org: "%id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--Collectio ...}" 
 -- viaIncl:son:isFirst: true viaIncl<>none: false "BETA" 
 -- items:goOrigin:encOG: "LIB" on: 1 isValueObj: false 
 -- origin: BETAworld origin:isValueObj: false 
 rpushg LIB$33 1
 rpushg BETA 2
 -- $ObjectInvocation_Unary:getAdr: "GeneralProcess" >ATd.off:0 (isPtn):on:2:superAdj:4"GeneralProcess(id: var LIB.StringLib.String): {   start:< ;      inner(start);   mkActi ..."} 
 -- $pattern:getAdr: "GeneralProcess(id: var LIB.StringLib.String): {   start:< ;      inner(start);   mkActive:< ;      inner(mkActive);   addWaiting:< ;      inner(addWaitin ..."} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"GeneralProcess":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "GeneralProcess"  ATd: "GeneralProcess(id: var LIB.StringLib.String): {   start:< ;      inner(start);   mkActive:< ;      inner(mkActive);   addWaitin ...}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"GeneralProcess":rec:- 
 -- computeAdr:isLast:E:  "GeneralProcess" 
 -- genClass:after:pushAddress: "GeneralProcess" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"GeneralProcess":rec:- 
 -- handleSuperArgs:E: "GeneralProcess" theIS: "mkActive::< {   -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;   SQS.insert(this(Basic ...}" 
 -- super.sig:not:none:superAdj: -4 
 -- $ObjectInvocation_Unary:loadArgs: "GeneralProcess" >staticOff:0 "GeneralProcess(id: var LIB.StringLib.String): {   start:< ;      inner(start);   mkActive:< ;      inner(m ..."} 
 -- $pattern:loadArgs: "GeneralProcess(id: var LIB.StringLib.String): {   start:< ;      inner(start);   mkActive:< ;      inner(mkActive);   addWaiting:< ;      inner(addWait ..."} 
 -- ptn:loadArgs:E "GeneralProcess" 
 -- {(ObjectInvocation_Unary; (name: "GeneralProcess"); (Arguments))} 
 -- args: "" 
 rShiftDown  1
 -- hArgOrg:super: GeneralProcess 
 -- Store itemArgs: mkActive::< {   -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;   SQS.insert(this(BasicProcess));%Public;start::<   ...} 
 -- id: var LIB.StringLib.String true 5 
 pushThis 
 rstoreg  id 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=83 vDescInx=82 vdtTop: 7 
 -- $pattern:gen: "start:< {   inner(start)" } 
 -- $pattern:gen: "mkActive:< {   inner(mkActive)" } 
 -- $pattern:gen: "addWaiting:< {   inner(addWaiting);   --put('R')" } 
 -- $pattern:gen: "dcrWaiting:< {   inner(dcrWaiting)" } 
 -- $pattern:gen: "display:< {   "\n---GP:---".print;   inner(display)" } 
 -- $var:gen: "status: var integer"  
 -- DI:gen: "status: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  status 
 -- $pattern:gen: "mkActive::< {   -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE;   SQS.insert(this(BasicProcess))" } 
 -- $Property:gen: "%Public"  
 -- $pattern:gen: "start::<  -- need id as argument{   status := p_status.ACTIVE;   SQS.insert(this(BasicProcess));   inner(start)" } 
 -- $pattern:gen: "addWaiting::< {   --SQS.addWaitingstatus := P_status.WAITING" } 
 -- $pattern:gen: "dcrWaiting::< {   SQS.dcrWaiting" } 
 -- $pattern:gen: "display::< {   "\n---BP:---\n".print;   --(id + ":A:").print	 " } 
 rtnAlloc 1
 toSuper 82
DO:
 mvStack 
 L1:
 -- genclass:stmt: "%Public" 
 -- $Property:gen: "%Public"  
 -- genclass:stmt: "this(BasicProcess).suspend{--(id + ":B:").print	 	 }" 
 -- $ObjectGenerator:gen: "this(BasicProcess).suspend{--(id + ":B:").print	 	 " >OGid:"suspend" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "this(BasicProcess).suspend{--(id + ":B:").print	 	 }" 
 -- OG:before:super.gen: "this(BasicProcess).suspend{--(id + ":B:").print	 	 }" 
 -- $Invocation:gen: "this(BasicProcess).suspend{--(id + ":B:").print	 	 " >useRtnV:"False"superAdj: 0 descNo: 31 descNo: 84} 
 -- INV:gen: "this(BasicProcess).suspend{--(id + ":B:").print	 	 }" 
 -- isConstant: "Invocation" "this(BasicProcess).suspend{--(id + ":B:").print	 	 }" 
 -- needorigin: "this(BasicProcess).suspend{--(id + ":B:").print	 	 }" 
 -- needOrigin:E: "suspend{--(id + ":B:").print	 	 }"  E.ATd: "suspend: {   %basic 111}" 
 -- doNeedOrigin:Ex: "this(BasicProcess)" 
 -- computeAdr:superAdj: 0 "this(BasicProcess).suspend{--(id + ":B:").print	 	 }" 
 -- computeAdr: 1 :rec: "none"  E: "this(BasicProcess)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "this(BasicProcess)"  
 pushThis 
 -- $ObjectInvocation_KeyWord:loadOrigin: "this(BasicProcess)" >on:3 superAdj:0 isValueObj:"False" 
 -- this_prim: BasicProcess :super.on: 1 
 -- $ObjectInvocation_KeyWord:getAdr: "this(BasicProcess)" >ATd.off:0 (isPtn):on:3:superAdj:0"this: {   %basic 18;   in this: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal: ...} 
 -- $pattern:getAdr: "this: {   %basic 18;   in this: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(BasicProcess)":rec:- 
 -- E.on: 3 
 -- beforeIsValueObj:E: "this(BasicProcess)"  ATd: "this: {   %basic 18;   in this: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(BasicProcess)":rec:- 
 -- computeAdr: 2 :rec: "this(BasicProcess)"  E: "suspend{--(id + ":B:").print	 	 }"  A.E: "this(BasicProcess)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(BasicProcess)":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "suspend{--(id + ":B:").print	 	 " >ATd.off:0 (isPtn):on:0:superAdj:0"suspend: ;   %basic 111":Adr:off:0 size:0 isFloat:F isUnitVal:F super ...} 
 -- $pattern:getAdr: "suspend: {   %basic 111" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(BasicProcess)":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_KeyWord:loadArgs: "this(BasicProcess)" >staticOff:0 "this: {   %basic 18;   in this: ref Object" superAdj:0arg:"BasicProcess"} 
 -- $pattern:loadArgs: "this: {   %basic 18;   in this: ref Object" >E:"this(BasicProcess)":descNo:31} 
 -- $ObjectInvocation_KeyWord:invoke: "this(BasicProcess)" >rec:"this(BasicProcess)" ATd:"pattern" E:"suspend{--(id + ":B:").print	 	 " E.ATd:"suspend" unique:"False"} 
 -- OI:invoke: "this(BasicProcess)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(BasicProcess)":rec:this(BasicProcess) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(BasicProcess)":rec:this(BasicProcess) 
 -- OI:invoke:B: "this(BasicProcess)" E: "suspend{--(id + ":B:").print	 	 }"  rec: "this(BasicProcess)"  useRtnV: true "this: {   %basic 18;   in this: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern this 
 -- $pattern:invoke: "this: {   %basic 18;   in this: ref Object" E: "suspend;--(id + ":B:").print	 	 " useRTNv: "True"} 
 -- ptn:invoke: "this" E: "suspend{--(id + ":B:").print	 	 }" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend{--(id + ":B:").print	 	 ":rec: ...} 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend{--(id + ":B:").print	 	 ":rec:this(BasicProcess)} 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend{--(id + ":B:").print	 	 ":rec:this(BasicProcess)} 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: this(BasicProcess) :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "this(BasicProcess)" E: "suspend{--(id + ":B:").print	 	 }" 
 -- computeAdr:isLast:E:  "suspend{--(id + ":B:").print	 	 }" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend{--(id + ":B:").print	 	 ":rec:this(Basic ...} 
 -- rec:  "this(BasicProcess)" E:  "suspend{--(id + ":B:").print	 	 }" 
 -- INV:gen:E.loadArgs "suspend{--(id + ":B:").print	 	 }" 
 -- $ObjectInvocation_Unary:loadArgs: "suspend{--(id + ":B:").print	 	 " >staticOff:0 "suspend: ;   %basic 111" superAdj:0} 
 -- $pattern:loadArgs: "suspend: {   %basic 111" >E:"suspend;--(id + ":B:").print	 	 ":descNo:84} 
 -- ptn:loadArgs:E "suspend{--(id + ":B:").print	 	 }" 
 -- {(ObjectInvocation_Unary; (name: "suspend"); (Arguments --<12>(id + ":B:").print	 	 ))} 
 -- args: "--(id + ":B:").print	 	 " 
 -- INV:gen:after:E.loadArgs "suspend{--(id + ":B:").print	 	 }" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "suspend{--(id + ":B:").print	 	 }" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIs ... 
 -- $ObjectInvocation_Unary:invoke: "suspend{--(id + ":B:").print	 	 " >rec:"this(BasicProcess)" ATd:"pattern" E:"suspend;--(id + ":B:").print	 	 " E.ATd:"suspend" unique:"Fal ..."} 
 -- OI:invoke: "suspend{--(id + ":B:").print	 	 }" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend{--(id + ":B:").print	 	 ":rec:this(BasicProcess)} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend{--(id + ":B:").print	 	 ":rec:this(BasicProcess)} 
 -- OI:invoke:B: "suspend{--(id + ":B:").print	 	 }" E: "suspend{--(id + ":B:").print	 	 }"  rec: "this(BasicProcess)"  useRtnV: false "suspend: {   %basic 111}" 
 -- OI:invoke:before:ATdx.invoke: pattern suspend 
 -- $pattern:invoke: "suspend: {   %basic 111" E: "suspend;--(id + ":B:").print	 	 " useRTNv: "False"} 
 -- ptn:invoke: "suspend" E: "suspend{--(id + ":B:").print	 	 }" ptnKind: 0 useRtnV: false 
 suspend
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend{--(id + ":B:").print	 	 ":rec:this(BasicProcess)} 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend{--(id + ":B:").print	 	 ":rec:this(BasicProcess)} 
 -- 
 -- OI:invoke:C: suspend{--(id + ":B:").print	 	 } :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend{--(id + ":B:").print	 	 ":rec:this(BasicProcess)} 
 -- genclass:stmt: "inner(BasicProcess)" 
 -- $ObjectGenerator:gen: "inner(BasicProcess)" >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inner(BasicProcess)" 
 -- OG:before:super.gen: "inner(BasicProcess)" 
 -- $Invocation:gen: "inner(BasicProcess)" >useRtnV:"False"superAdj: 0 descNo: 12 
 -- INV:gen: "inner(BasicProcess)" 
 -- isConstant: "Invocation" "inner(BasicProcess)" 
 -- needorigin: "inner(BasicProcess)" 
 -- needOrigin:E: "inner(BasicProcess)"  E.ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- doNeedOrigin:Ex: "inner(BasicProcess)" 
 -- computeAdr:superAdj: 0 "inner(BasicProcess)" 
 -- computeAdr: 1 :rec: "none"  E: "inner(BasicProcess)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "inner(BasicProcess)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "inner(BasicProcess)" >on:3 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "inner(BasicProcess)" >ATd.off:0 (isPtn):on:3:superAdj:0"inner: {   %basic 101;   in inner: ref Object":Adr:off:0 size:0 isFloat:F isUnit ...} 
 -- $pattern:getAdr: "inner: {   %basic 101;   in inner: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(BasicProcess)":rec:- 
 -- E.on: 3 
 -- beforeIsValueObj:E: "inner(BasicProcess)"  ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(BasicProcess)":rec:- 
 -- computeAdr:isLast:E:  "inner(BasicProcess)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(BasicProcess)":rec:- 
 -- rec:  "inner(BasicProcess)" E:  "inner(BasicProcess)" 
 -- INV:gen:E.loadArgs "inner(BasicProcess)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "inner(BasicProcess)" >staticOff:0 "inner: {   %basic 101;   in inner: ref Object" superAdj:0arg:"BasicProcess"} 
 -- $pattern:loadArgs: "inner: {   %basic 101;   in inner: ref Object" >E:"inner(BasicProcess)":descNo:12} 
 -- INV:gen:after:E.loadArgs "inner(BasicProcess)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(BasicProcess)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"i ..." 
 -- $ObjectInvocation_KeyWord:invoke: "inner(BasicProcess)" >rec:"inner(BasicProcess)" ATd:"pattern" E:"inner(BasicProcess)" E.ATd:"inner" unique:"False" 
 -- OI:invoke: "inner(BasicProcess)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(BasicProcess)":rec:inner(BasicProcess) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(BasicProcess)":rec:inner(BasicProcess) 
 -- OI:invoke:B: "inner(BasicProcess)" E: "inner(BasicProcess)"  rec: "inner(BasicProcess)"  useRtnV: false "inner: {   %basic 101;   in inner: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- $pattern:invoke: "inner: {   %basic 101;   in inner: ref Object" E: "inner(BasicProcess)" useRTNv: "False"} 
 -- ptn:invoke: "inner" E: "inner(BasicProcess)" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  8
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(BasicProcess)":rec:inner(BasicProcess) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(BasicProcess)":rec:inner(BasicProcess) 
 -- 
 -- OI:invoke:C: inner(BasicProcess) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(BasicProcess)":rec:inner(BasicProcess) 
 -- genclass:stmt: "status := P_status.TERMINATED" 
 -- $Assign:gen: "status := P_status.TERMINATED"  
 -- assign: "status := P_status.TERMINATED" 
 -- computeAdr:superAdj: 0 "status" 
 -- computeAdr: 1 :rec: "none"  E: "status" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "status"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "status" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "status" >ATd.off:3:on:0:superAdj:0"status: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVal ... 
 -- $var:getAdr: "status: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F  ... 
 -- DI:OG: integer 
 -- before:floatTest:  "status: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"status":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"status":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"status":rec:- 
 -- computeAdr:isLast:E:  "status" 
 -- AssignmentStatement:gen: "status := P_status.TERMINATED" right.label: "ObjectGenerator" "P_status.TERMINATED" 
 -- $ObjectGenerator:gen: "P_status.TERMINATED" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "P_status.TERMINATED" 
 -- OG:before:super.gen: "P_status.TERMINATED" 
 -- $Invocation:gen: "P_status.TERMINATED" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "P_status.TERMINATED" 
 -- isConstant: "Invocation" "P_status.TERMINATED" 
 -- const literal:  3   ConstLiteral 
 pushc 3
 -- OG:gen:end: 
 -- rec: "status" dstE: "status" dstE.ATd: "status: var integer" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"statu ..." 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "P_status.TERMINATED" 
 -- isArgOfAssignI2IwithUniValArg "status := P_status.TERMINATED" arg: "P_status.TERMINATED" ObjectGenerator 
 -- arg.super.arg: "P_status" ObjectInvocation_Unary 
 -- arg.super.arg: "TERMINATED" ObjectInvocation_Unary 
 -- recx: "P_status" argx: "TERMINATED" 
 -- checkInt2IntWithUnitArg:rec: "P_status" E: "TERMINATED" 
 -- dstDI: "status: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"status":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg BasicProcess$83 3
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:4 isIndexed:0
 -- vdtAdd: inx=8 descInx=83 vDescInx=0 vdtTop: 8 
 -- vdtAdd: inx=3 descInx=83 vDescInx=138 vdtTop: 8 
 -- vdtAdd: inx=2 descInx=83 vDescInx=160 vdtTop: 8 
 -- vdtAdd: inx=4 descInx=83 vDescInx=161 vdtTop: 8 
 -- vdtAdd: inx=5 descInx=83 vDescInx=162 vdtTop: 8 
 -- vdtAdd: inx=6 descInx=83 vDescInx=164 vdtTop: 8 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 138 
 -- Items:GenClass: mkActive descNo: 138 isValue: false 
 -- Items:GenClass: mkActive descNo: 133 isValue: false 
 -- Items:GenClass: mkActive descNo: 21 isValue: false 

 CLASS mkActive 138 1 BasicProcess 83
 -- vdtTableCopy: I:1:133 I:2:0
 -- vdtAdd: inx=2 descInx=138 vDescInx=138 vdtTop: 2 
 -- Store itemArgs: -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE{SQS.insert(this(BasicProcess))} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 -- super mkActive
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 -- handleSuperArgs:E: "" theIS: "-- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE{SQS.insert(this(BasicProcess))}" 
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs: ""  
 -- hArgOrg:super: mkActive 
 -- Store itemArgs: -- start and mkActive are identical and one may be eliminatedstatus := p_status.ACTIVE{SQS.insert(this(BasicProcess))} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=138 vDescInx=133 vdtTop: 2 
 rtnAlloc 1
 toSuper 133
DO:
 mvStack 
 L1:
 -- genclass:stmt: "status := p_status.ACTIVE" 
 -- $Assign:gen: "status := p_status.ACTIVE"  
 -- assign: "status := p_status.ACTIVE" 
 -- computeAdr:superAdj: 0 "status" 
 -- computeAdr: 1 :rec: "none"  E: "status" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "status"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "status" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "mkActive" on: 1 isValueObj: false 
 -- origin: BasicProcess origin:isValueObj: false 
 rpushg mkActive$138 1
 -- $ObjectInvocation_Unary:getAdr: "status" >ATd.off:3:on:1:superAdj:0"status: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVal ... 
 -- $var:getAdr: "status: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F  ... 
 -- DI:OG: integer 
 -- before:floatTest:  "status: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"status":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"status":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "status"  ATd: "status: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"status":rec:- 
 -- computeAdr:isLast:E:  "status" 
 -- AssignmentStatement:gen: "status := p_status.ACTIVE" right.label: "ObjectGenerator" "p_status.ACTIVE" 
 -- $ObjectGenerator:gen: "p_status.ACTIVE" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "p_status.ACTIVE" 
 -- OG:before:super.gen: "p_status.ACTIVE" 
 -- $Invocation:gen: "p_status.ACTIVE" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "p_status.ACTIVE" 
 -- isConstant: "Invocation" "p_status.ACTIVE" 
 -- const literal:  1   ConstLiteral 
 pushc 1
 -- OG:gen:end: 
 -- rec: "status" dstE: "status" dstE.ATd: "status: var integer" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"statu ..." 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "p_status.ACTIVE" 
 -- isArgOfAssignI2IwithUniValArg "status := p_status.ACTIVE" arg: "p_status.ACTIVE" ObjectGenerator 
 -- arg.super.arg: "p_status" ObjectInvocation_Unary 
 -- arg.super.arg: "ACTIVE" ObjectInvocation_Unary 
 -- recx: "p_status" argx: "ACTIVE" 
 -- checkInt2IntWithUnitArg:rec: "p_status" E: "ACTIVE" 
 -- dstDI: "status: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"status":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg BasicProcess$83 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "SQS.insert(this(BasicProcess))" 
 -- $ObjectGenerator:gen: "SQS.insert(this(BasicProcess))" >OGid:"insert" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "SQS.insert(this(BasicProcess))" 
 -- OG:before:super.gen: "SQS.insert(this(BasicProcess))" 
 -- $Invocation:gen: "SQS.insert(this(BasicProcess))" >useRtnV:"False"superAdj: 0 descNo: 139 
 -- INV:gen: "SQS.insert(this(BasicProcess))" 
 -- isConstant: "Invocation" "SQS.insert(this(BasicProcess))" 
 -- needorigin: "SQS.insert(this(BasicProcess))" 
 -- needOrigin:E: "insert(this(BasicProcess))"  E.ATd: "insert: entry{   in P: ref BasicProcess;   if (Q.has(P).not) :then ;      Q.insert(P)}" 
 -- doNeedOrigin:Ex: "insert(this(BasicProcess))" 
 -- computeAdr:superAdj: 0 "SQS.insert(this(BasicProcess))" 
 -- computeAdr: 1 :rec: "none"  E: "SQS" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "SQS"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "SQS" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "mkActive" on: 2 isValueObj: false 
 -- origin: BasicProcess origin:isValueObj: false 
 rpushg mkActive$138 1
 -- items:goOrigin:encOG: "BasicProcess" on: 1 isValueObj: false 
 -- origin: BasicSystem origin:isValueObj: false 
 rpushg BasicProcess$83 4
 -- $ObjectInvocation_Unary:getAdr: "SQS" >ATd.off:6:on:2:superAdj:0"SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Publi ..."} 
 -- $obj:getAdr: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if  ..."} 
 -- E.on: 2 
 -- beforeIsValueObj:E: "SQS"  ATd: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V ...}" 
 -- computeAdr:isFirst: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "SQS"  E: "insert(this(BasicProcess))" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:getAdr: "insert(this(BasicProcess))" >ATd.off:0 (isPtn):on:0:superAdj:0"insert: entry{   in P: ref BasicProcess;   if (Q.has(P).not) :then ;      ..."} 
 -- $pattern:getAdr: "insert: entry{   in P: ref BasicProcess;   if (Q.has(P).not) :then ;      Q.insert(P)" } 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(this(BasicProcess))":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "SQS" >staticOff:0 "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ..."} 
 -- $obj:loadArgs: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      i ..."} 
 -- $ObjectInvocation_Unary:invoke: "SQS" >rec:"SQS" ATd:"obj" E:"insert(this(BasicProcess))" E.ATd:"insert" unique:"False" 
 -- OI:invoke: "SQS" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(this(BasicProcess))":rec:SQS 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(this(BasicProcess))":rec:SQS 
 -- OI:invoke:B: "SQS" E: "insert(this(BasicProcess))"  rec: "SQS"  useRtnV: true "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var int ...}" 
 -- OI:invoke:before:ATdx.invoke: obj SQS 
 -- $obj:invoke: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if  ..."} 
 -- DI:invoke: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if (V ...}" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(this(BasicProcess))":rec:SQS 
 rpushg mkActive$138 6
 -- OI:invoke:V: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(this(BasicProcess))":rec:SQS 
 -- 
 -- OI:invoke:X: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(this(BasicProcess))":rec:SQS 
 -- 
 -- OI:invoke:C: SQS :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "SQS" E: "insert(this(BasicProcess))" 
 -- arg:other 
 -- computeAdr:isLast:E:  "insert(this(BasicProcess))" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(this(BasicProcess))":rec:SQS 
 -- rec:  "SQS" E:  "insert(this(BasicProcess))" 
 -- INV:gen:E.loadArgs "insert(this(BasicProcess))" 
 -- $ObjectInvocation_KeyWord:loadArgs: "insert(this(BasicProcess))" >staticOff:0 "insert: entry{   in P: ref BasicProcess;   if (Q.has(P).not) :then ;      Q.insert(P)" super ...} 
 -- $pattern:loadArgs: "insert: entry{   in P: ref BasicProcess;   if (Q.has(P).not) :then ;      Q.insert(P)" >E:"insert(this(BasicProcess))":descNo:139} 
 -- ptn:loadArgs:E "insert(this(BasicProcess))" 
 -- {(ObjectInvocation_KeyWord; (name: "insert"); (Arguments;  (name: "insert");  (name: "(");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_KeyWord;     (name: "this ..."} 
 -- args: "insert(this(BasicProcess))" 
 -- E: "ObjectGenerator" this(BasicProcess) 
 -- E.arg: "ref" in P: ref BasicProcess 
 -- NonVirt: "insert(this(BasicProcess))" "ObjectInvocation_KeyWord" ActArg:  "this(BasicProcess)" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "insert(this(BasicProcess))"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "this(BasicProcess)" >OGid:"this" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "this(BasicProcess)" 
 -- OG:before:super.gen: "this(BasicProcess)" 
 -- $Invocation:gen: "this(BasicProcess)" >useRtnV:"True"superAdj: 0 descNo: 31 
 -- INV:gen: "this(BasicProcess)" 
 -- isConstant: "Invocation" "this(BasicProcess)" 
 -- needorigin: "this(BasicProcess)" 
 -- needOrigin:E: "this(BasicProcess)"  E.ATd: "this: {   %basic 18;   in this: ref Object}" 
 -- doNeedOrigin:Ex: "this(BasicProcess)" 
 -- computeAdr:superAdj: 0 "this(BasicProcess)" 
 -- computeAdr: 1 :rec: "none"  E: "this(BasicProcess)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "this(BasicProcess)"  
 pushThis 
 -- $ObjectInvocation_KeyWord:loadOrigin: "this(BasicProcess)" >on:4 superAdj:0 isValueObj:"False" 
 -- this_prim: BasicProcess :super.on: 2 
 -- items:goOrigin:encOG: "mkActive" on: 1 isValueObj: false 
 -- origin: BasicProcess origin:isValueObj: false 
 rpushg mkActive$138 1
 -- $ObjectInvocation_KeyWord:getAdr: "this(BasicProcess)" >ATd.off:0 (isPtn):on:4:superAdj:0"this: {   %basic 18;   in this: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal: ...} 
 -- $pattern:getAdr: "this: {   %basic 18;   in this: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(BasicProcess)":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "this(BasicProcess)"  ATd: "this: {   %basic 18;   in this: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(BasicProcess)":rec:- 
 -- computeAdr:isLast:E:  "this(BasicProcess)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(BasicProcess)":rec:- 
 -- rec:  "this(BasicProcess)" E:  "this(BasicProcess)" 
 -- INV:gen:E.loadArgs "this(BasicProcess)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "this(BasicProcess)" >staticOff:0 "this: {   %basic 18;   in this: ref Object" superAdj:0arg:"BasicProcess"} 
 -- $pattern:loadArgs: "this: {   %basic 18;   in this: ref Object" >E:"this(BasicProcess)":descNo:31} 
 -- INV:gen:after:E.loadArgs "this(BasicProcess)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "this(BasicProcess)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"thi ..." 
 -- $ObjectInvocation_KeyWord:invoke: "this(BasicProcess)" >rec:"this(BasicProcess)" ATd:"pattern" E:"this(BasicProcess)" E.ATd:"this" unique:"False" 
 -- OI:invoke: "this(BasicProcess)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(BasicProcess)":rec:this(BasicProcess) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(BasicProcess)":rec:this(BasicProcess) 
 -- OI:invoke:B: "this(BasicProcess)" E: "this(BasicProcess)"  rec: "this(BasicProcess)"  useRtnV: true "this: {   %basic 18;   in this: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern this 
 -- $pattern:invoke: "this: {   %basic 18;   in this: ref Object" E: "this(BasicProcess)" useRTNv: "True"} 
 -- ptn:invoke: "this" E: "this(BasicProcess)" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(BasicProcess)":rec:this(BasicProc ... 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(BasicProcess)":rec:this(BasicProcess) 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(BasicProcess)":rec:this(BasicProcess) 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: this(BasicProcess) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(BasicProcess)":rec:this(BasicProcess) 
 -- formalArg:isPtn: "in P: ref BasicProcess" :isBasicVal: false :valueObj: false 
 -- :actArg: "this(BasicProcess)" :isBasicVal: false 
 -- case:B: this(BasicProcess) ObjectGenerator 0 18 18 false false 
 -- end:loadArgs:NonVirt: "insert(this(BasicProcess))" 
 -- INV:gen:after:E.loadArgs "insert(this(BasicProcess))" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "insert(this(BasicProcess))" :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ... 
 -- $ObjectInvocation_KeyWord:invoke: "insert(this(BasicProcess))" >rec:"SQS" ATd:"pattern" E:"insert(this(BasicProcess))" E.ATd:"insert" unique:"False" 
 -- OI:invoke: "insert(this(BasicProcess))" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(this(BasicProcess))":rec:SQS 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(this(BasicProcess))":rec:SQS 
 -- OI:invoke:B: "insert(this(BasicProcess))" E: "insert(this(BasicProcess))"  rec: "SQS"  useRtnV: false "insert: entry{   in P: ref BasicProcess;   if (Q.has(P).not) :then ; ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern insert 
 -- $pattern:invoke: "insert: entry{   in P: ref BasicProcess;   if (Q.has(P).not) :then ;      Q.insert(P)" E: "insert(this(BasicProcess))" useRTNv: "False"} 
 -- ptn:invoke: "insert" E: "insert(this(BasicProcess))" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(this(BasicProcess))":rec:SQS 
 invoke insert 139 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(this(BasicProcess))":rec:SQS 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(this(BasicProcess))":rec:SQS 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: insert(this(BasicProcess)) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 6 
 -- OG:gen:end: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(this(BasicProcess))":rec:SQS 
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 95 
 -- Items:GenClass: entry descNo: 95 isValue: false 
 -- Items:GenClass: entry descNo: 21 isValue: false 

 CLASS entry 95 1 SQS 77
 -- Store itemArgs: L.get{V := V + 1;if (V > 1) :then ;   put('V');inner(entry);V := V - 1;L.free} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=95 vDescInx=95 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "L.get" 
 -- $ObjectGenerator:gen: "L.get" >OGid:"get" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L.get" 
 -- OG:before:super.gen: "L.get" 
 -- $Invocation:gen: "L.get" >useRtnV:"False"superAdj: 0 descNo: 96 
 -- INV:gen: "L.get" 
 -- isConstant: "Invocation" "L.get" 
 -- needorigin: "L.get" 
 -- needOrigin:E: "get"  E.ATd: "get: {   loop: obj ;      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);      if (res = 1) :then ;   ...}" 
 -- doNeedOrigin:Ex: "get" 
 -- computeAdr:superAdj: 0 "L.get" 
 -- computeAdr: 1 :rec: "none"  E: "L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "entry" on: 1 isValueObj: false 
 -- origin: SQS origin:isValueObj: false 
 rpushg entry$95 1
 -- $ObjectInvocation_Unary:getAdr: "L" >ATd.off:3:on:1:superAdj:0"L: obj Lock("SQS:Lock:")":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVal ... 
 -- $obj:getAdr: "L: obj Lock("SQS:Lock:")" >newOff:3,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F i ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "L"  ATd: "L: obj Lock("SQS:Lock:")" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "L"  E: "get" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "get" >ATd.off:0 (isPtn):on:0:superAdj:0"get: {   loop: obj ;      res: var integer;      i: var integer;      --disable;      res := free_ ..."} 
 -- $pattern:getAdr: "get: {   loop: obj ;      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);      if (res = 1) :then ;         --en ..."} 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "L" >staticOff:0 "L: obj Lock("SQS:Lock:")" superAdj:0 
 -- $obj:loadArgs: "L: obj Lock("SQS:Lock:")" >E:"L" 
 -- $pattern:loadArgs: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ; ..."} 
 -- ptn:loadArgs:E "L" 
 -- {(ObjectInvocation_Unary; (name: "L"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "L" >rec:"L" ATd:"obj" E:"get" E.ATd:"get" unique:"False" 
 -- OI:invoke: "L" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:L 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:L 
 -- OI:invoke:B: "L" E: "get"  rec: "L"  useRtnV: true "L: obj Lock("SQS:Lock:")" 
 -- OI:invoke:before:ATdx.invoke: obj L 
 -- $obj:invoke: "L: obj Lock("SQS:Lock:")" E: "get">newOff:3 useRTNv: "True" 
 -- DI:invoke: "L: obj Lock("SQS:Lock:")" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:L 
 rpushg entry$95 3
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:L 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:L 
 -- 
 -- OI:invoke:C: L :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "L" E: "get" 
 -- computeAdr:isLast:E:  "get" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:L 
 -- rec:  "L" E:  "get" 
 -- INV:gen:E.loadArgs "get" 
 -- $ObjectInvocation_Unary:loadArgs: "get" >staticOff:0 "get: {   loop: obj ;      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);    ..."} 
 -- $pattern:loadArgs: "get: {   loop: obj ;      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);      if (res = 1) :then ;         -- ..."} 
 -- ptn:loadArgs:E "get" 
 -- {(ObjectInvocation_Unary; (name: "get"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "get" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "get" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:L 
 -- $ObjectInvocation_Unary:invoke: "get" >rec:"L" ATd:"pattern" E:"get" E.ATd:"get" unique:"False" 
 -- OI:invoke: "get" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:L 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:L 
 -- OI:invoke:B: "get" E: "get"  rec: "L"  useRtnV: false "get: {   loop: obj ;      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);   ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern get 
 -- $pattern:invoke: "get: {   loop: obj ;      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);      if (res = 1) :then ;         --en ..."} 
 -- ptn:invoke: "get" E: "get" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:L 
 invoke get 96 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:L 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:L 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: get :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:L 
 -- genclass:stmt: "V := V + 1" 
 -- $Assign:gen: "V := V + 1"  
 -- assign: "V := V + 1" 
 -- computeAdr:superAdj: 0 "V" 
 -- computeAdr: 1 :rec: "none"  E: "V" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "V"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "V" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "entry" on: 1 isValueObj: false 
 -- origin: SQS origin:isValueObj: false 
 rpushg entry$95 1
 -- $ObjectInvocation_Unary:getAdr: "V" >ATd.off:4:on:1:superAdj:0"V: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "V: var integer" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "V: var integer" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "V"  ATd: "V: var integer" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- computeAdr:isLast:E:  "V" 
 -- AssignmentStatement:gen: "V := V + 1" right.label: "ObjectGenerator" "V + 1" 
 -- $ObjectGenerator:gen: "V + 1" >OGid:"+" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "V + 1" 
 -- OG:before:super.gen: "V + 1" 
 -- $Invocation:gen: "V + 1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "V + 1" 
 -- isConstant: "Invocation" "V + 1" 
 -- needorigin: "V + 1" 
 -- needOrigin:E: "V + 1"  E.ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- doNeedOrigin:Ex: "V + 1" 
 -- computeAdr:superAdj: 0 "V + 1" 
 -- computeAdr: 1 :rec: "none"  E: "V + 1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "V + 1"  
 -- $BinOp:loadOrigin: "V + 1"  
 -- BinaryExp:loadOrigin:empty: "V + 1" superAdj: 0 
 -- $BinOp:getAdr: "V + 1"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "V + 1"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "V + 1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "V + 1" E:  "V + 1" 
 -- INV:gen:E.loadArgs "V + 1" 
 -- $BinOp:loadArgs: "V + 1"  
 -- BinaryExp:loadArgs: "V + 1" superAdj: 0 
 -- $Invocation:gen: "V" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "V" 
 -- isConstant: "Invocation" "V" 
 -- notConst: V V: var integer 
 -- needorigin: "V" 
 -- needOrigin:E: "V"  E.ATd: "V: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "V" 
 -- computeAdr: 1 :rec: "none"  E: "V" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "V"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "V" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "entry" on: 1 isValueObj: false 
 -- origin: SQS origin:isValueObj: false 
 rpushg entry$95 1
 -- $ObjectInvocation_Unary:getAdr: "V" >ATd.off:4:on:1:superAdj:0"V: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "V: var integer" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "V: var integer" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "V"  ATd: "V: var integer" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- computeAdr:isLast:E:  "V" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- rec:  "V" E:  "V" 
 -- INV:gen:E.loadArgs "V" 
 -- $ObjectInvocation_Unary:loadArgs: "V" >staticOff:0 "V: var integer" superAdj:0 
 -- $var:loadArgs: "V: var integer" >E:"V" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "V" 
 -- {(ObjectInvocation_Unary; (name: "V"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "V" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "V" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- $ObjectInvocation_Unary:invoke: "V" >rec:"V" ATd:"var" isValueObj E:"V" E.ATd:"V" unique:"False" 
 -- OI:invoke: "V" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "V" E: "V"  rec: "V"  useRtnV: true "V: var integer" 
 -- OI:invoke:before:ATdx.invoke: var V 
 -- $var:invoke: "V: var integer" E: "V">newOff:4 useRTNv: "True" 
 -- DI:invoke: "V: var integer" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- isCompositeValueObj: false E: "V" "V: var integer" true 
 -- E.ATd.isValueObj: false rec: "V" 
 pushg 4 SQS$77
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- 
 -- OI:invoke:C: V :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- left:#I "V + 1" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- $pattern:loadArgs: "+  : {   %basic 61;   in V: var integer;   out R: var integer" >E:"+ 1":descNo:49} 
 -- ptn:loadArgs:E "+ 1" 
 -- {(ObjectInvocation_Binary; (name: "+"); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 1));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "1" 
 -- E: "ObjectGenerator" 1 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "+ 1" "ObjectInvocation_Binary" ActArg:  "1" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ 1"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "1" :isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "+ 1" 
 -- BinaryExp:loadArgs:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- INV:gen:after:E.loadArgs "V + 1" 
 -- OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- IV:E.invoke:useRtnVal: true E: BinOp "V + 1" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- $BinOp:invoke: "V + 1"  
 -- BinaryExp:invoke: "V" rec: "V + 1" 
 -- M: "+ 1" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- $ObjectInvocation_Binary:invoke: "+ 1" >rec:"V" ATd:"pattern" E:"+ 1" E.ATd:"+  " unique:"False" 
 -- OI:invoke: "+ 1" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- origin:isValueObj "integer" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "+ 1" E: "+ 1"  rec: "V"  useRtnV: true "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- $pattern:invoke: "+  : {   %basic 61;   in V: var integer;   out R: var integer" E: "+ 1" useRTNv: "True"} 
 -- ptn:invoke: "+  " E: "+ 1" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "V" E: "+ 1" 
 -- arg:integer 
 plus
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:V 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:V 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: + 1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "V" dstE: "V" dstE.ATd: "V: var integer" useRtn: false :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "V + 1" 
 -- isArgOfAssignI2IwithUniValArg "V := V + 1" arg: "V + 1" ObjectGenerator 
 -- arg.super.arg: "V + 1" BinOp 
 -- recx:BinaryExp:recx: "V + 1" 
 -- M: "+ 1" label: "ObjectInvocation_Binary" M.ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- checkInt2IntWithUnitArg:rec: "V" E: "+ 1" 
 -- arg:integer 
 -- M:arg: "1" ObjectGenerator false 
 -- dstDI: "V: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg SQS$77 4
 -- assign:adr.store:B: 
 -- genclass:stmt: "if (V > 1) :then {   put('V')}" 
 -- $ObjectGenerator:gen: "if (V > 1) :then {   put('V')" >OGid:"if:then$0" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "if (V > 1) :then {   put('V')}" 
 -- OG:before:super.gen: "if (V > 1) :then {   put('V')}" 
 -- $Invocation:gen: "if (V > 1) :then {   put('V')" >useRtnV:"False"superAdj: 0} 
 -- INV:gen: "if (V > 1) :then {   put('V')}" 
 -- isConstant: "Invocation" "if (V > 1) :then {   put('V')}" 
 -- needorigin: "if (V > 1) :then {   put('V')}" 
 -- needOrigin:E: "if (V > 1) :then {   put('V')}"  E.ATd: "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (V > 1) :then {   put('V')}" E:  "if (V > 1) :then {   put('V')}" 
 -- INV:gen:E.loadArgs "if (V > 1) :then {   put('V')}" 
 -- $IfThen:loadArgs: "if (V > 1) :then {   put('V')" } 
 -- INV:gen:after:E.loadArgs "if (V > 1) :then {   put('V')}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (V > 1) :then {   put('V')}" 
 -- $IfThen:invoke: "if (V > 1) :then {   put('V')" } 
 -- $IfThen:gen: "if (V > 1) :then {   put('V')" } 
 -- $ObjectGenerator:gen: "(V > 1)" >OGid:">" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(V > 1)" 
 -- OG:before:super.gen: "(V > 1)" 
 -- $Invocation:gen: "(V > 1)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(V > 1)" 
 -- isConstant: "Invocation" "(V > 1)" 
 -- needorigin: "(V > 1)" 
 -- needOrigin:E: "(V > 1)"  E.ATd: ">  : {   %basic 53;   in V: var integer;   out B: var boolean}" 
 -- doNeedOrigin:Ex: "(V > 1)" 
 -- computeAdr:superAdj: 0 "(V > 1)" 
 -- computeAdr: 1 :rec: "none"  E: "(V > 1)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(V > 1)"  
 -- $BracketedExp:loadOrigin: "(V > 1)"  
 -- computeAdr:superAdj: 0 "V > 1" 
 -- computeAdr: 1 :rec: "none"  E: "V > 1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "V > 1"  
 -- $BinOp:loadOrigin: "V > 1"  
 -- BinaryExp:loadOrigin:empty: "V > 1" superAdj: 0 
 -- $BinOp:getAdr: "V > 1"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "V > 1"  ATd: ">  : {   %basic 53;   in V: var integer;   out B: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "V > 1" 
 -- BE:loadOrigin:E: V > 1 
 -- $BinOp:getAdr: "V > 1"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "V > 1"  ATd: ">  : {   %basic 53;   in V: var integer;   out B: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "V > 1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "V > 1" E:  "V > 1" 
 -- INV:gen:E.loadArgs "V > 1" 
 -- $BinOp:loadArgs: "V > 1"  
 -- BinaryExp:loadArgs: "V > 1" superAdj: 0 
 -- $Invocation:gen: "V" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "V" 
 -- isConstant: "Invocation" "V" 
 -- notConst: V V: var integer 
 -- needorigin: "V" 
 -- needOrigin:E: "V"  E.ATd: "V: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "V" 
 -- computeAdr: 1 :rec: "none"  E: "V" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "V"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "V" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "entry" on: 1 isValueObj: false 
 -- origin: SQS origin:isValueObj: false 
 rpushg entry$95 1
 -- $ObjectInvocation_Unary:getAdr: "V" >ATd.off:4:on:1:superAdj:0"V: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "V: var integer" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "V: var integer" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "V"  ATd: "V: var integer" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- computeAdr:isLast:E:  "V" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- rec:  "V" E:  "V" 
 -- INV:gen:E.loadArgs "V" 
 -- $ObjectInvocation_Unary:loadArgs: "V" >staticOff:0 "V: var integer" superAdj:0 
 -- $var:loadArgs: "V: var integer" >E:"V" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "V" 
 -- {(ObjectInvocation_Unary; (name: "V"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "V" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "V" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- $ObjectInvocation_Unary:invoke: "V" >rec:"V" ATd:"var" isValueObj E:"V" E.ATd:"V" unique:"False" 
 -- OI:invoke: "V" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "V" E: "V"  rec: "V"  useRtnV: true "V: var integer" 
 -- OI:invoke:before:ATdx.invoke: var V 
 -- $var:invoke: "V: var integer" E: "V">newOff:4 useRTNv: "True" 
 -- DI:invoke: "V: var integer" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- isCompositeValueObj: false E: "V" "V: var integer" true 
 -- E.ATd.isValueObj: false rec: "V" 
 pushg 4 SQS$77
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -3 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- 
 -- OI:invoke:C: V :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- left:#I "V > 1" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- $pattern:loadArgs: ">  : {   %basic 53;   in V: var integer;   out B: var boolean" >E:"> 1":descNo:101} 
 -- ptn:loadArgs:E "> 1" 
 -- {(ObjectInvocation_Binary; (name: ">"); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 1));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "1" 
 -- E: "ObjectGenerator" 1 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "> 1" "ObjectInvocation_Binary" ActArg:  "1" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "> 1"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "1" :isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "> 1" 
 -- BinaryExp:loadArgs:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- INV:gen:after:E.loadArgs "V > 1" 
 -- OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- IV:E.invoke:useRtnVal: true E: BinOp "V > 1" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- $BinOp:invoke: "V > 1"  
 -- BinaryExp:invoke: "V" rec: "V > 1" 
 -- M: "> 1" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- $ObjectInvocation_Binary:invoke: "> 1" >rec:"V" ATd:"pattern" E:"> 1" E.ATd:">  " unique:"False" 
 -- OI:invoke: "> 1" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- origin:isValueObj "integer" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "> 1" E: "> 1"  rec: "V"  useRtnV: true ">  : {   %basic 53;   in V: var integer;   out B: var boolean}" 
 -- OI:invoke:before:ATdx.invoke: pattern >   
 -- $pattern:invoke: ">  : {   %basic 53;   in V: var integer;   out B: var boolean" E: "> 1" useRTNv: "True"} 
 -- ptn:invoke: ">  " E: "> 1" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "V" E: "> 1" 
 -- arg:integer 
 gt
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"> 1":rec:V 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"> 1":rec:V 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: > 1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: "put('V')" >OGid:"$107" singular! staticOff=0 descNo=107 superAdj=0 
 -- OG:gen: "put('V')" 
 pushThis 
 -- before objTmpStack:add:  107   "$107" 
 invoke $107 107 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "inner(entry)" 
 -- $ObjectGenerator:gen: "inner(entry)" >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inner(entry)" 
 -- OG:before:super.gen: "inner(entry)" 
 -- $Invocation:gen: "inner(entry)" >useRtnV:"False"superAdj: 0 descNo: 12 
 -- INV:gen: "inner(entry)" 
 -- isConstant: "Invocation" "inner(entry)" 
 -- needorigin: "inner(entry)" 
 -- needOrigin:E: "inner(entry)"  E.ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- doNeedOrigin:Ex: "inner(entry)" 
 -- computeAdr:superAdj: 0 "inner(entry)" 
 -- computeAdr: 1 :rec: "none"  E: "inner(entry)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "inner(entry)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "inner(entry)" >on:4 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "inner(entry)" >ATd.off:0 (isPtn):on:4:superAdj:0"inner: {   %basic 101;   in inner: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal:F s ...} 
 -- $pattern:getAdr: "inner: {   %basic 101;   in inner: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(entry)":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "inner(entry)"  ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(entry)":rec:- 
 -- computeAdr:isLast:E:  "inner(entry)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(entry)":rec:- 
 -- rec:  "inner(entry)" E:  "inner(entry)" 
 -- INV:gen:E.loadArgs "inner(entry)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "inner(entry)" >staticOff:0 "inner: {   %basic 101;   in inner: ref Object" superAdj:0arg:"entry"} 
 -- $pattern:loadArgs: "inner: {   %basic 101;   in inner: ref Object" >E:"inner(entry)":descNo:12} 
 -- INV:gen:after:E.loadArgs "inner(entry)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(entry)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(en ..." 
 -- $ObjectInvocation_KeyWord:invoke: "inner(entry)" >rec:"inner(entry)" ATd:"pattern" E:"inner(entry)" E.ATd:"inner" unique:"False" 
 -- OI:invoke: "inner(entry)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(entry)":rec:inner(entry) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(entry)":rec:inner(entry) 
 -- OI:invoke:B: "inner(entry)" E: "inner(entry)"  rec: "inner(entry)"  useRtnV: false "inner: {   %basic 101;   in inner: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- $pattern:invoke: "inner: {   %basic 101;   in inner: ref Object" E: "inner(entry)" useRTNv: "False"} 
 -- ptn:invoke: "inner" E: "inner(entry)" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(entry)":rec:inner(entry) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(entry)":rec:inner(entry) 
 -- 
 -- OI:invoke:C: inner(entry) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(entry)":rec:inner(entry) 
 -- genclass:stmt: "V := V - 1" 
 -- $Assign:gen: "V := V - 1"  
 -- assign: "V := V - 1" 
 -- computeAdr:superAdj: 0 "V" 
 -- computeAdr: 1 :rec: "none"  E: "V" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "V"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "V" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "entry" on: 1 isValueObj: false 
 -- origin: SQS origin:isValueObj: false 
 rpushg entry$95 1
 -- $ObjectInvocation_Unary:getAdr: "V" >ATd.off:4:on:1:superAdj:0"V: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "V: var integer" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "V: var integer" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "V"  ATd: "V: var integer" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- computeAdr:isLast:E:  "V" 
 -- AssignmentStatement:gen: "V := V - 1" right.label: "ObjectGenerator" "V - 1" 
 -- $ObjectGenerator:gen: "V - 1" >OGid:"-" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "V - 1" 
 -- OG:before:super.gen: "V - 1" 
 -- $Invocation:gen: "V - 1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "V - 1" 
 -- isConstant: "Invocation" "V - 1" 
 -- needorigin: "V - 1" 
 -- needOrigin:E: "V - 1"  E.ATd: "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- doNeedOrigin:Ex: "V - 1" 
 -- computeAdr:superAdj: 0 "V - 1" 
 -- computeAdr: 1 :rec: "none"  E: "V - 1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "V - 1"  
 -- $BinOp:loadOrigin: "V - 1"  
 -- BinaryExp:loadOrigin:empty: "V - 1" superAdj: 0 
 -- $BinOp:getAdr: "V - 1"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "V - 1"  ATd: "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "V - 1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "V - 1" E:  "V - 1" 
 -- INV:gen:E.loadArgs "V - 1" 
 -- $BinOp:loadArgs: "V - 1"  
 -- BinaryExp:loadArgs: "V - 1" superAdj: 0 
 -- $Invocation:gen: "V" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "V" 
 -- isConstant: "Invocation" "V" 
 -- notConst: V V: var integer 
 -- needorigin: "V" 
 -- needOrigin:E: "V"  E.ATd: "V: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "V" 
 -- computeAdr: 1 :rec: "none"  E: "V" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "V"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "V" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "entry" on: 1 isValueObj: false 
 -- origin: SQS origin:isValueObj: false 
 rpushg entry$95 1
 -- $ObjectInvocation_Unary:getAdr: "V" >ATd.off:4:on:1:superAdj:0"V: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "V: var integer" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "V: var integer" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "V"  ATd: "V: var integer" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- computeAdr:isLast:E:  "V" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- rec:  "V" E:  "V" 
 -- INV:gen:E.loadArgs "V" 
 -- $ObjectInvocation_Unary:loadArgs: "V" >staticOff:0 "V: var integer" superAdj:0 
 -- $var:loadArgs: "V: var integer" >E:"V" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "V" 
 -- {(ObjectInvocation_Unary; (name: "V"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "V" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "V" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- $ObjectInvocation_Unary:invoke: "V" >rec:"V" ATd:"var" isValueObj E:"V" E.ATd:"V" unique:"False" 
 -- OI:invoke: "V" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "V" E: "V"  rec: "V"  useRtnV: true "V: var integer" 
 -- OI:invoke:before:ATdx.invoke: var V 
 -- $var:invoke: "V: var integer" E: "V">newOff:4 useRTNv: "True" 
 -- DI:invoke: "V: var integer" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- isCompositeValueObj: false E: "V" "V: var integer" true 
 -- E.ATd.isValueObj: false rec: "V" 
 pushg 4 SQS$77
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -5 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 3 vTopMax: 3 rTop: -5 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- 
 -- OI:invoke:C: V :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- left:#I "V - 1" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- $pattern:loadArgs: "-  : {   %basic 62;   in V: var integer;   out R: var integer" >E:"- 1":descNo:108} 
 -- ptn:loadArgs:E "- 1" 
 -- {(ObjectInvocation_Binary; (name: "-"); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 1));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "1" 
 -- E: "ObjectGenerator" 1 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "- 1" "ObjectInvocation_Binary" ActArg:  "1" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "- 1"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "1" :isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "- 1" 
 -- BinaryExp:loadArgs:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- INV:gen:after:E.loadArgs "V - 1" 
 -- OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- IV:E.invoke:useRtnVal: true E: BinOp "V - 1" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- $BinOp:invoke: "V - 1"  
 -- BinaryExp:invoke: "V" rec: "V - 1" 
 -- M: "- 1" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- $ObjectInvocation_Binary:invoke: "- 1" >rec:"V" ATd:"pattern" E:"- 1" E.ATd:"-  " unique:"False" 
 -- OI:invoke: "- 1" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- origin:isValueObj "integer" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "- 1" E: "- 1"  rec: "V"  useRtnV: true "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern -   
 -- $pattern:invoke: "-  : {   %basic 62;   in V: var integer;   out R: var integer" E: "- 1" useRTNv: "True"} 
 -- ptn:invoke: "-  " E: "- 1" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "V" E: "- 1" 
 -- arg:integer 
 minus
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"- 1":rec:V 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"- 1":rec:V 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: - 1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "V" dstE: "V" dstE.ATd: "V: var integer" useRtn: false :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "V - 1" 
 -- isArgOfAssignI2IwithUniValArg "V := V - 1" arg: "V - 1" ObjectGenerator 
 -- arg.super.arg: "V - 1" BinOp 
 -- recx:BinaryExp:recx: "V - 1" 
 -- M: "- 1" label: "ObjectInvocation_Binary" M.ATd: "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- checkInt2IntWithUnitArg:rec: "V" E: "- 1" 
 -- arg:integer 
 -- M:arg: "1" ObjectGenerator false 
 -- dstDI: "V: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg SQS$77 4
 -- assign:adr.store:B: 
 -- genclass:stmt: "L.free" 
 -- $ObjectGenerator:gen: "L.free" >OGid:"free" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L.free" 
 -- OG:before:super.gen: "L.free" 
 -- $Invocation:gen: "L.free" >useRtnV:"False"superAdj: 0 descNo: 109 
 -- INV:gen: "L.free" 
 -- isConstant: "Invocation" "L.free" 
 -- needorigin: "L.free" 
 -- needOrigin:E: "free"  E.ATd: "free: {   free_M := 0}" 
 -- doNeedOrigin:Ex: "free" 
 -- computeAdr:superAdj: 0 "L.free" 
 -- computeAdr: 1 :rec: "none"  E: "L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "entry" on: 1 isValueObj: false 
 -- origin: SQS origin:isValueObj: false 
 rpushg entry$95 1
 -- $ObjectInvocation_Unary:getAdr: "L" >ATd.off:3:on:1:superAdj:0"L: obj Lock("SQS:Lock:")":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVal ... 
 -- $obj:getAdr: "L: obj Lock("SQS:Lock:")" >newOff:3,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F i ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "L"  ATd: "L: obj Lock("SQS:Lock:")" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "L"  E: "free" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "free" >ATd.off:0 (isPtn):on:0:superAdj:0"free: {   free_M := 0":Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ...} 
 -- $pattern:getAdr: "free: {   free_M := 0" } 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "L" >staticOff:0 "L: obj Lock("SQS:Lock:")" superAdj:0 
 -- $obj:loadArgs: "L: obj Lock("SQS:Lock:")" >E:"L" 
 -- $pattern:loadArgs: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ; ..."} 
 -- ptn:loadArgs:E "L" 
 -- {(ObjectInvocation_Unary; (name: "L"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "L" >rec:"L" ATd:"obj" E:"free" E.ATd:"free" unique:"False" 
 -- OI:invoke: "L" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:L 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:L 
 -- OI:invoke:B: "L" E: "free"  rec: "L"  useRtnV: true "L: obj Lock("SQS:Lock:")" 
 -- OI:invoke:before:ATdx.invoke: obj L 
 -- $obj:invoke: "L: obj Lock("SQS:Lock:")" E: "free">newOff:3 useRTNv: "True" 
 -- DI:invoke: "L: obj Lock("SQS:Lock:")" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:L 
 rpushg entry$95 3
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:L 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:L 
 -- 
 -- OI:invoke:C: L :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "L" E: "free" 
 -- computeAdr:isLast:E:  "free" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:L 
 -- rec:  "L" E:  "free" 
 -- INV:gen:E.loadArgs "free" 
 -- $ObjectInvocation_Unary:loadArgs: "free" >staticOff:0 "free: {   free_M := 0" superAdj:0} 
 -- $pattern:loadArgs: "free: {   free_M := 0" >E:"free":descNo:109} 
 -- ptn:loadArgs:E "free" 
 -- {(ObjectInvocation_Unary; (name: "free"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "free" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "free" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:L 
 -- $ObjectInvocation_Unary:invoke: "free" >rec:"L" ATd:"pattern" E:"free" E.ATd:"free" unique:"False" 
 -- OI:invoke: "free" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:L 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:L 
 -- OI:invoke:B: "free" E: "free"  rec: "L"  useRtnV: false "free: {   free_M := 0}" 
 -- OI:invoke:before:ATdx.invoke: pattern free 
 -- $pattern:invoke: "free: {   free_M := 0" E: "free" useRTNv: "False"} 
 -- ptn:invoke: "free" E: "free" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:L 
 invoke free 109 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 3 vTopMax: 3 rTop: -6 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:L 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:L 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: free :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:L 
 L2:
 -- pushReturn:  "entry" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- vdtAdd: inx=2 descInx=95 vDescInx=0 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 96 
 -- Items:GenClass: get descNo: 96 isValue: false 
 -- Items:GenClass: get descNo: 21 isValue: false 

 CLASS get 96 1 Lock 76
 -- Store itemArgs: loop: obj {   res: var integer;   i: var integer;   --disable;   res := free_M.cmpAndSwap(1);   if (res = 1) :then ;      --enablesleep(50);      i := i +  ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=96 vDescInx=96 vdtTop: 1 
 mvStack 
 -- $obj:gen: "loop: obj {   res: var integer;   i: var integer;   --disable;   res := free_M.cmpAndSwap(1);   if (res = 1) :then ;      --enablesleep(50);      i := i + 1;    ..."} 
 -- DI:gen: "loop: obj {   res: var integer;   i: var integer;   --disable;   res := free_M.cmpAndSwap(1);   if (res = 1) :then ;      --enablesleep(50);      i := i + 1;      ...}" D ... true : ... false : ... 0 
 -- DI:add:BP4:  loop 
 -- $ObjectGenerator:gen: "res: var integer{   i: var integer;   --disable;   res := free_M.cmpAndSwap(1);   if (res = 1) :then ;      --enablesleep(50);      i := i + 1;      ..."} 
 -- OG:gen: "res: var integer{   i: var integer;   --disable;   res := free_M.cmpAndSwap(1);   if (res = 1) :then ;      --enablesleep(50);      i := i + 1;      if (i > 10000 ...}" 
 pushThis 
 -- before objTmpStack:add:  97   "loop" 
 invoke loop 97 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 -- pushReturn:  "get" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 97 
 -- Items:GenClass: loop descNo: 97 isValue: false 
 -- Items:GenClass: loop descNo: 21 isValue: false 

 CLASS loop 97 1 get 96
 -- Store itemArgs: res: var integer{i: var integer;--disable;res := free_M.cmpAndSwap(1);if (res = 1) :then ;   --enablesleep(50);   i := i + 1;   if (i > 10000) :then ;      ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=97 vDescInx=97 vdtTop: 1 
 mvStack 
 -- $var:gen: "res: var integer"  
 -- DI:gen: "res: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  res 
 -- $var:gen: "i: var integer{--disable" } 
 -- DI:gen: "i: var integer{--disable}" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  i 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "res := free_M.cmpAndSwap(1)" 
 -- $Assign:gen: "res := free_M.cmpAndSwap(1)"  
 -- assign: "res := free_M.cmpAndSwap(1)" 
 -- computeAdr:superAdj: 0 "res" 
 -- computeAdr: 1 :rec: "none"  E: "res" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "res"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "res" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "res" >ATd.off:2:on:0:superAdj:0"res: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "res: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "res: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:- 
 -- computeAdr:isLast:E:  "res" 
 -- AssignmentStatement:gen: "res := free_M.cmpAndSwap(1)" right.label: "ObjectGenerator" "free_M.cmpAndSwap(1)" 
 -- $ObjectGenerator:gen: "free_M.cmpAndSwap(1)" >OGid:"cmpAndSwap" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "free_M.cmpAndSwap(1)" 
 -- OG:before:super.gen: "free_M.cmpAndSwap(1)" 
 -- $Invocation:gen: "free_M.cmpAndSwap(1)" >useRtnV:"True"superAdj: 0 descNo: 98 
 -- INV:gen: "free_M.cmpAndSwap(1)" 
 -- isConstant: "Invocation" "free_M.cmpAndSwap(1)" 
 -- notConst: free_M free_M: var integer 
 -- needorigin: "free_M.cmpAndSwap(1)" 
 -- needOrigin:E: "cmpAndSwap(1)"  E.ATd: "cmpAndSwap: {   %basic 14;   in V: var integer;   out res: var integer}" 
 -- doNeedOrigin:Ex: "cmpAndSwap(1)" 
 -- computeAdr:superAdj: 0 "free_M.cmpAndSwap(1)" 
 -- computeAdr: 1 :rec: "none"  E: "free_M" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "free_M"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "free_M" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 2 isValueObj: false 
 -- origin: get origin:isValueObj: false 
 rpushg loop$97 1
 -- items:goOrigin:encOG: "get" on: 1 isValueObj: false 
 -- origin: Lock origin:isValueObj: false 
 rpushg get$96 1
 -- $ObjectInvocation_Unary:getAdr: "free_M" >ATd.off:2:on:2:superAdj:0"free_M: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVal ... 
 -- $var:getAdr: "free_M: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F  ... 
 -- DI:OG: integer 
 -- before:floatTest:  "free_M: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"free_M":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"free_M":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "free_M"  ATd: "free_M: var integer" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"free_M":rec:- 
 -- computeAdr: 2 :rec: "free_M"  E: "cmpAndSwap(1)"  A.E: "free_M" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"free_M":rec:- 
 -- $ObjectInvocation_KeyWord:getAdr: "cmpAndSwap(1)" >ATd.off:0 (isPtn):on:0:superAdj:0"cmpAndSwap: {   %basic 14;   in V: var integer;   out res: var integer":Adr:off:2 size ...} 
 -- $pattern:getAdr: "cmpAndSwap: {   %basic 14;   in V: var integer;   out res: var integer" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"free_M":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "free_M" >staticOff:0 "free_M: var integer" superAdj:0 
 -- $var:loadArgs: "free_M: var integer" >E:"free_M" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "free_M" 
 -- {(ObjectInvocation_Unary; (name: "free_M"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "free_M" >rec:"free_M" ATd:"var" isValueObj E:"cmpAndSwap(1)" E.ATd:"cmpAndSwap" unique:"False" 
 -- OI:invoke: "free_M" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"free_M":rec:free_M 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"free_M":rec:free_M 
 -- OI:invoke:B: "free_M" E: "cmpAndSwap(1)"  rec: "free_M"  useRtnV: true "free_M: var integer" 
 -- OI:invoke:before:ATdx.invoke: var free_M 
 -- $var:invoke: "free_M: var integer" E: "cmpAndSwap(1)">newOff:2 useRTNv: "True" 
 -- DI:invoke: "free_M: var integer" 
 -- cmpAndSwap:Off: 1 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cmpAndSwap(1)":rec:free_M 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cmpAndSwap(1)":rec:free_M 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 2
 pushc 5
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cmpAndSwap(1)":rec:free_M 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cmpAndSwap(1)":rec:free_M 
 -- 
 -- OI:invoke:C: free_M :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "free_M" E: "cmpAndSwap(1)" 
 -- arg:integer 
 -- computeAdr:isLast:E:  "cmpAndSwap(1)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cmpAndSwap(1)":rec:free_M 
 -- rec:  "free_M" E:  "cmpAndSwap(1)" 
 -- INV:gen:E.loadArgs "cmpAndSwap(1)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "cmpAndSwap(1)" >staticOff:0 "cmpAndSwap: {   %basic 14;   in V: var integer;   out res: var integer" superAdj:0arg:"1"} 
 -- $pattern:loadArgs: "cmpAndSwap: {   %basic 14;   in V: var integer;   out res: var integer" >E:"cmpAndSwap(1)":descNo:98} 
 -- ptn:loadArgs:E "cmpAndSwap(1)" 
 -- {(ObjectInvocation_KeyWord; (name: "cmpAndSwap"); (Arguments;  (name: "cmpAndSwap");  (name: "(");  (ObjectGenerator;   (Invocation;    (ConstLiteral 1));   (Items descNo: ...} 
 -- args: "cmpAndSwap(1)" 
 -- E: "ObjectGenerator" 1 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "cmpAndSwap(1)" "ObjectInvocation_KeyWord" ActArg:  "1" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "cmpAndSwap(1)"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "1" :isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "cmpAndSwap(1)" 
 -- INV:gen:after:E.loadArgs "cmpAndSwap(1)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "cmpAndSwap(1)" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cmpAndSw ..." 
 -- $ObjectInvocation_KeyWord:invoke: "cmpAndSwap(1)" >rec:"free_M" ATd:"pattern" E:"cmpAndSwap(1)" E.ATd:"cmpAndSwap" unique:"False" 
 -- OI:invoke: "cmpAndSwap(1)" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cmpAndSwap(1)":rec:free_M 
 -- origin:isValueObj "integer" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cmpAndSwap(1)":rec:free_M 
 -- OI:invoke:B: "cmpAndSwap(1)" E: "cmpAndSwap(1)"  rec: "free_M"  useRtnV: true "cmpAndSwap: {   %basic 14;   in V: var integer;   out res: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern cmpAndSwap 
 -- $pattern:invoke: "cmpAndSwap: {   %basic 14;   in V: var integer;   out res: var integer" E: "cmpAndSwap(1)" useRTNv: "True"} 
 -- ptn:invoke: "cmpAndSwap" E: "cmpAndSwap(1)" ptnKind: 0 useRtnV: true 
 swap
 vpop
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 swap
 %cmpAndSwap 14
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cmpAndSwap(1)":rec:free_M 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cmpAndSwap(1)":rec:free_M 
 -- 
 -- OI:invoke:C: cmpAndSwap(1) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cmpAndSwap(1)":rec:free_M 
 -- rec: "res" dstE: "res" dstE.ATd: "res: var integer" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "free_M.cmpAndSwap(1)" 
 -- isArgOfAssignI2IwithUniValArg "res := free_M.cmpAndSwap(1)" arg: "free_M.cmpAndSwap(1)" ObjectGenerator 
 -- arg.super.arg: "free_M" ObjectInvocation_Unary 
 -- arg.super.arg: "cmpAndSwap(1)" ObjectInvocation_KeyWord 
 -- recx: "free_M" argx: "cmpAndSwap(1)" 
 -- checkInt2IntWithUnitArg:rec: "free_M" E: "cmpAndSwap(1)" 
 -- arg:integer 
 -- dstDI: "res: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg loop$97 2
 -- assign:adr.store:B: 
 -- genclass:stmt: "if (res = 1) :then {   --enablesleep(50);   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts").print;      i := 0;   restart ...}" 
 -- $ObjectGenerator:gen: "if (res = 1) :then {   --enablesleep(50);   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts").print;      i := 0;    ..."} 
 -- OG:gen: "if (res = 1) :then {   --enablesleep(50);   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts").print;      i := 0;   restart(loop)}" 
 -- OG:before:super.gen: "if (res = 1) :then {   --enablesleep(50);   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts").print;      i := 0;   r ...}" 
 -- $Invocation:gen: "if (res = 1) :then {   --enablesleep(50);   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts").print;      i := 0;   resta ..."} 
 -- INV:gen: "if (res = 1) :then {   --enablesleep(50);   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts").print;      i := 0;   restart(loop) ...}" 
 -- isConstant: "Invocation" "if (res = 1) :then {   --enablesleep(50);   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts").print;      i := 0; ...}" 
 -- needorigin: "if (res = 1) :then {   --enablesleep(50);   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts").print;      i := 0;   restart(lo ...}" 
 -- needOrigin:E: "if (res = 1) :then {   --enablesleep(50);   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts").print;      i := 0;   restart( ...}"   ... "i ..." 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (res = 1) :then {   --enablesleep(50);   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts").print;      i := 0;   restart(loop)}" E ... "i ..." 
 -- INV:gen:E.loadArgs "if (res = 1) :then {   --enablesleep(50);   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts").print;      i := 0;   res ...}" 
 -- $IfThen:loadArgs: "if (res = 1) :then {   --enablesleep(50);   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts").print;      i := 0;   rest ..."} 
 -- INV:gen:after:E.loadArgs "if (res = 1) :then {   --enablesleep(50);   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts").print;      i := 0; ...}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (res = 1) :then {   --enablesleep(50);   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts").print ...}" 
 -- $IfThen:invoke: "if (res = 1) :then {   --enablesleep(50);   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts").print;      i := 0;   restar ..."} 
 -- $IfThen:gen: "if (res = 1) :then {   --enablesleep(50);   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts").print;      i := 0;   restart(l ..."} 
 -- $ObjectGenerator:gen: "(res = 1)" >OGid:"=" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(res = 1)" 
 -- OG:before:super.gen: "(res = 1)" 
 -- $Invocation:gen: "(res = 1)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(res = 1)" 
 -- isConstant: "Invocation" "(res = 1)" 
 -- needorigin: "(res = 1)" 
 -- needOrigin:E: "(res = 1)"  E.ATd: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- doNeedOrigin:Ex: "(res = 1)" 
 -- computeAdr:superAdj: 0 "(res = 1)" 
 -- computeAdr: 1 :rec: "none"  E: "(res = 1)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(res = 1)"  
 -- $BracketedExp:loadOrigin: "(res = 1)"  
 -- computeAdr:superAdj: 0 "res = 1" 
 -- computeAdr: 1 :rec: "none"  E: "res = 1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "res = 1"  
 -- $BinOp:loadOrigin: "res = 1"  
 -- BinaryExp:loadOrigin:empty: "res = 1" superAdj: 0 
 -- $BinOp:getAdr: "res = 1"  
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "res = 1" 
 -- BE:loadOrigin:E: res = 1 
 -- $BinOp:getAdr: "res = 1"  
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "res = 1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "res = 1" E:  "res = 1" 
 -- INV:gen:E.loadArgs "res = 1" 
 -- $BinOp:loadArgs: "res = 1"  
 -- BinaryExp:loadArgs: "res = 1" superAdj: 0 
 -- $Invocation:gen: "res" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "res" 
 -- isConstant: "Invocation" "res" 
 -- notConst: res res: var integer 
 -- needorigin: "res" 
 -- needOrigin:E: "res"  E.ATd: "res: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "res" 
 -- computeAdr: 1 :rec: "none"  E: "res" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "res"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "res" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "res" >ATd.off:2:on:0:superAdj:0"res: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "res: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "res: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:- 
 -- computeAdr:isLast:E:  "res" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:- 
 -- rec:  "res" E:  "res" 
 -- INV:gen:E.loadArgs "res" 
 -- $ObjectInvocation_Unary:loadArgs: "res" >staticOff:0 "res: var integer" superAdj:0 
 -- $var:loadArgs: "res: var integer" >E:"res" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "res" 
 -- {(ObjectInvocation_Unary; (name: "res"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "res" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "res" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:- 
 -- $ObjectInvocation_Unary:invoke: "res" >rec:"res" ATd:"var" isValueObj E:"res" E.ATd:"res" unique:"False" 
 -- OI:invoke: "res" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:res 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:res 
 -- OI:invoke:B: "res" E: "res"  rec: "res"  useRtnV: true "res: var integer" 
 -- OI:invoke:before:ATdx.invoke: var res 
 -- $var:invoke: "res: var integer" E: "res">newOff:2 useRTNv: "True" 
 -- DI:invoke: "res: var integer" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:res 
 -- isCompositeValueObj: false E: "res" "res: var integer" true 
 -- E.ATd.isValueObj: false rec: "res" 
 pushg 2 loop$97
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:res 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:res 
 -- 
 -- OI:invoke:C: res :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- left:#I "res = 1" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:res 
 -- $pattern:loadArgs: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )" >E:"= 1":descNo:11} 
 -- ptn:loadArgs:E "= 1" 
 -- {(ObjectInvocation_Binary; (name: "="); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 1));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "1" 
 -- E: "ObjectGenerator" 1 
 -- E.arg: "var" in Veq: var this(Value) 
 -- NonVirt: "= 1" "ObjectInvocation_Binary" ActArg:  "1" isValue:  true 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "= 1"  isCompositeValueObj: true 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- vEq: 
 -- end:loadArgs:NonVirt: "= 1" 
 -- BinaryExp:loadArgs:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:res 
 -- INV:gen:after:E.loadArgs "res = 1" 
 -- OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:res 
 -- IV:E.invoke:useRtnVal: true E: BinOp "res = 1" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:res 
 -- $BinOp:invoke: "res = 1"  
 -- BinaryExp:invoke: "res" rec: "res = 1" 
 -- M: "= 1" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:res 
 -- $ObjectInvocation_Binary:invoke: "= 1" >rec:"res" ATd:"pattern" E:"= 1" E.ATd:"=  " unique:"False" 
 -- OI:invoke: "= 1" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:res 
 -- origin:isValueObj "Value" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:res 
 -- OI:invoke:B: "= 1" E: "= 1"  rec: "res"  useRtnV: true "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OI:invoke:before:ATdx.invoke: pattern =   
 -- $pattern:invoke: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )" E: "= 1" useRTNv: "True"} 
 -- ptn:invoke: "=  " E: "= 1" ptnKind: 1 useRtnV: true 
 -- rec: "res" "Invocation" OGx.label: "ObjectGenerator" OGx: integer 
 -- rec.ATd: "res: var integer" 
 -- bobs: 1 OGx: integer 
 eq
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= 1":rec:res 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= 1":rec:res 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: = 1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: "--enablesleep(50){   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts").print;      i := 0;   restart(loop)" >OGid:"$ ..."} 
 -- OG:gen: "--enablesleep(50){   i := i + 1;   if (i > 10000) :then ;      (id + " not free after 10000 attempts").print;      i := 0;   restart(loop)}" 
 pushThis 
 -- before objTmpStack:add:  99   "$99" 
 invoke $99 99 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 -- pushReturn:  "loop" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 99 
 -- Items:GenClass: $99 descNo: 99 isValue: false 
 -- Items:GenClass: $99 descNo: 21 isValue: false 

 CLASS $99 99 1 loop 97
 -- Store itemArgs: --enablesleep(50){i := i + 1;if (i > 10000) :then ;   (id + " not free after 10000 attempts").print;   i := 0;restart(loop)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=99 vDescInx=99 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "sleep(50)" 
 -- $ObjectGenerator:gen: "sleep(50)" >OGid:"sleep" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "sleep(50)" 
 -- OG:before:super.gen: "sleep(50)" 
 -- $Invocation:gen: "sleep(50)" >useRtnV:"False"superAdj: 0 descNo: 100 
 -- INV:gen: "sleep(50)" 
 -- isConstant: "Invocation" "sleep(50)" 
 -- needorigin: "sleep(50)" 
 -- needOrigin:E: "sleep(50)"  E.ATd: "sleep: {   %basic 15;   in V: var integer}" 
 -- doNeedOrigin:Ex: "sleep(50)" 
 -- computeAdr:superAdj: 0 "sleep(50)" 
 -- computeAdr: 1 :rec: "none"  E: "sleep(50)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "sleep(50)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "sleep(50)" >on:5 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "sleep(50)" >ATd.off:0 (isPtn):on:5:superAdj:0"sleep: {   %basic 15;   in V: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj ...} 
 -- $pattern:getAdr: "sleep: {   %basic 15;   in V: var integer" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sleep(50)":rec:- 
 -- E.on: 5 
 -- beforeIsValueObj:E: "sleep(50)"  ATd: "sleep: {   %basic 15;   in V: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sleep(50)":rec:- 
 -- computeAdr:isLast:E:  "sleep(50)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sleep(50)":rec:- 
 -- rec:  "sleep(50)" E:  "sleep(50)" 
 -- INV:gen:E.loadArgs "sleep(50)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "sleep(50)" >staticOff:0 "sleep: {   %basic 15;   in V: var integer" superAdj:0arg:"50"} 
 -- $pattern:loadArgs: "sleep: {   %basic 15;   in V: var integer" >E:"sleep(50)":descNo:100} 
 -- ptn:loadArgs:E "sleep(50)" 
 -- {(ObjectInvocation_KeyWord; (name: "sleep"); (Arguments;  (name: "sleep");  (name: "(");  (ObjectGenerator;   (Invocation;    (ConstLiteral 50));   (Items descNo: 0 origDe ...} 
 -- args: "sleep(50)" 
 -- E: "ObjectGenerator" 50 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "sleep(50)" "ObjectInvocation_KeyWord" ActArg:  "50" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "sleep(50)"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "50" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "50" 
 -- OG:before:super.gen: "50" 
 -- $Invocation:gen: "50" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "50" 
 -- isConstant: "Invocation" "50" 
 -- needorigin: "50" 
 -- needOrigin:E: "50"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "50" E:  "50" 
 -- INV:gen:E.loadArgs "50" 
 -- $ConstLiteral:loadArgs: "50"  
 -- INV:gen:after:E.loadArgs "50" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "50" 
 -- $ConstLiteral:invoke: "50"  
 pushc 50
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "50" :isBasicVal: true 
 -- case:B: 50 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "sleep(50)" 
 -- INV:gen:after:E.loadArgs "sleep(50)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "sleep(50)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sleep(50)": ... 
 -- $ObjectInvocation_KeyWord:invoke: "sleep(50)" >rec:"sleep(50)" ATd:"pattern" E:"sleep(50)" E.ATd:"sleep" unique:"False" 
 -- OI:invoke: "sleep(50)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sleep(50)":rec:sleep(50) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sleep(50)":rec:sleep(50) 
 -- OI:invoke:B: "sleep(50)" E: "sleep(50)"  rec: "sleep(50)"  useRtnV: false "sleep: {   %basic 15;   in V: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern sleep 
 -- $pattern:invoke: "sleep: {   %basic 15;   in V: var integer" E: "sleep(50)" useRTNv: "False"} 
 -- ptn:invoke: "sleep" E: "sleep(50)" ptnKind: 0 useRtnV: false 
 %sleep 15
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sleep(50)":rec:sleep(50) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sleep(50)":rec:sleep(50) 
 -- 
 -- OI:invoke:C: sleep(50) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sleep(50)":rec:sleep(50) 
 -- genclass:stmt: "i := i + 1" 
 -- $Assign:gen: "i := i + 1"  
 -- assign: "i := i + 1" 
 -- computeAdr:superAdj: 0 "i" 
 -- computeAdr: 1 :rec: "none"  E: "i" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "i"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "i" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$99" on: 1 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg $99$99 1
 -- $ObjectInvocation_Unary:getAdr: "i" >ATd.off:3:on:1:superAdj:0"i: var integer{--disable":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVal ...} 
 -- $var:getAdr: "i: var integer{--disable" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVal ...} 
 -- DI:OG: integer{--disable} 
 -- before:floatTest:  "i: var integer{--disable}" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "i"  ATd: "i: var integer{--disable}" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- computeAdr:isLast:E:  "i" 
 -- AssignmentStatement:gen: "i := i + 1" right.label: "ObjectGenerator" "i + 1" 
 -- $ObjectGenerator:gen: "i + 1" >OGid:"+" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "i + 1" 
 -- OG:before:super.gen: "i + 1" 
 -- $Invocation:gen: "i + 1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "i + 1" 
 -- isConstant: "Invocation" "i + 1" 
 -- needorigin: "i + 1" 
 -- needOrigin:E: "i + 1"  E.ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- doNeedOrigin:Ex: "i + 1" 
 -- computeAdr:superAdj: 0 "i + 1" 
 -- computeAdr: 1 :rec: "none"  E: "i + 1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "i + 1"  
 -- $BinOp:loadOrigin: "i + 1"  
 -- BinaryExp:loadOrigin:empty: "i + 1" superAdj: 0 
 -- $BinOp:getAdr: "i + 1"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "i + 1"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "i + 1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "i + 1" E:  "i + 1" 
 -- INV:gen:E.loadArgs "i + 1" 
 -- $BinOp:loadArgs: "i + 1"  
 -- BinaryExp:loadArgs: "i + 1" superAdj: 0 
 -- $Invocation:gen: "i" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "i" 
 -- isConstant: "Invocation" "i" 
 -- notConst: i i: var integer{--disable} 
 -- needorigin: "i" 
 -- needOrigin:E: "i"  E.ATd: "i: var integer{--disable}" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "i" 
 -- computeAdr: 1 :rec: "none"  E: "i" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "i"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "i" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$99" on: 1 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg $99$99 1
 -- $ObjectInvocation_Unary:getAdr: "i" >ATd.off:3:on:1:superAdj:0"i: var integer{--disable":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVal ...} 
 -- $var:getAdr: "i: var integer{--disable" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVal ...} 
 -- DI:OG: integer{--disable} 
 -- before:floatTest:  "i: var integer{--disable}" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "i"  ATd: "i: var integer{--disable}" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- computeAdr:isLast:E:  "i" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- rec:  "i" E:  "i" 
 -- INV:gen:E.loadArgs "i" 
 -- $ObjectInvocation_Unary:loadArgs: "i" >staticOff:0 "i: var integer{--disable" superAdj:0} 
 -- $var:loadArgs: "i: var integer{--disable" >E:"i"} 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "i" 
 -- {(ObjectInvocation_Unary; (name: "i"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "i" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "i" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- $ObjectInvocation_Unary:invoke: "i" >rec:"i" ATd:"var" isValueObj E:"i" E.ATd:"i" unique:"False" 
 -- OI:invoke: "i" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- OI:invoke:B: "i" E: "i"  rec: "i"  useRtnV: true "i: var integer{--disable}" 
 -- OI:invoke:before:ATdx.invoke: var i 
 -- $var:invoke: "i: var integer{--disable" E: "i">newOff:3 useRTNv: "True"} 
 -- DI:invoke: "i: var integer{--disable}" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- isCompositeValueObj: false E: "i" "i: var integer{--disable}" true 
 -- E.ATd.isValueObj: false rec: "i" 
 pushg 3 loop$97
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- 
 -- OI:invoke:C: i :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- left:#I "i + 1" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- $pattern:loadArgs: "+  : {   %basic 61;   in V: var integer;   out R: var integer" >E:"+ 1":descNo:49} 
 -- ptn:loadArgs:E "+ 1" 
 -- {(ObjectInvocation_Binary; (name: "+"); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 1));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "1" 
 -- E: "ObjectGenerator" 1 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "+ 1" "ObjectInvocation_Binary" ActArg:  "1" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ 1"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "1" :isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "+ 1" 
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- INV:gen:after:E.loadArgs "i + 1" 
 -- OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- IV:E.invoke:useRtnVal: true E: BinOp "i + 1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- $BinOp:invoke: "i + 1"  
 -- BinaryExp:invoke: "i" rec: "i + 1" 
 -- M: "+ 1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- $ObjectInvocation_Binary:invoke: "+ 1" >rec:"i" ATd:"pattern" E:"+ 1" E.ATd:"+  " unique:"False" 
 -- OI:invoke: "+ 1" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- origin:isValueObj "integer" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- OI:invoke:B: "+ 1" E: "+ 1"  rec: "i"  useRtnV: true "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- $pattern:invoke: "+  : {   %basic 61;   in V: var integer;   out R: var integer" E: "+ 1" useRTNv: "True"} 
 -- ptn:invoke: "+  " E: "+ 1" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "i" E: "+ 1" 
 -- arg:integer 
 plus
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:i 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:i 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: + 1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "i" dstE: "i" dstE.ATd: "i: var integer{--disable}" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "i + 1" 
 -- isArgOfAssignI2IwithUniValArg "i := i + 1" arg: "i + 1" ObjectGenerator 
 -- arg.super.arg: "i + 1" BinOp 
 -- recx:BinaryExp:recx: "i + 1" 
 -- M: "+ 1" label: "ObjectInvocation_Binary" M.ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- checkInt2IntWithUnitArg:rec: "i" E: "+ 1" 
 -- arg:integer 
 -- M:arg: "1" ObjectGenerator false 
 -- dstDI: "i: var integer{--disable}" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg loop$97 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "if (i > 10000) :then {   (id + " not free after 10000 attempts").print;   i := 0}" 
 -- $ObjectGenerator:gen: "if (i > 10000) :then {   (id + " not free after 10000 attempts").print;   i := 0" >OGid:"if:then$0" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "if (i > 10000) :then {   (id + " not free after 10000 attempts").print;   i := 0}" 
 -- OG:before:super.gen: "if (i > 10000) :then {   (id + " not free after 10000 attempts").print;   i := 0}" 
 -- $Invocation:gen: "if (i > 10000) :then {   (id + " not free after 10000 attempts").print;   i := 0" >useRtnV:"False"superAdj: 0} 
 -- INV:gen: "if (i > 10000) :then {   (id + " not free after 10000 attempts").print;   i := 0}" 
 -- isConstant: "Invocation" "if (i > 10000) :then {   (id + " not free after 10000 attempts").print;   i := 0}" 
 -- needorigin: "if (i > 10000) :then {   (id + " not free after 10000 attempts").print;   i := 0}" 
 -- needOrigin:E: "if (i > 10000) :then {   (id + " not free after 10000 attempts").print;   i := 0}"  E.ATd: "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibilit ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (i > 10000) :then {   (id + " not free after 10000 attempts").print;   i := 0}" E:  "if (i > 10000) :then {   (id + " not free after 10000 attempts").print;   i  ...}" 
 -- INV:gen:E.loadArgs "if (i > 10000) :then {   (id + " not free after 10000 attempts").print;   i := 0}" 
 -- $IfThen:loadArgs: "if (i > 10000) :then {   (id + " not free after 10000 attempts").print;   i := 0" } 
 -- INV:gen:after:E.loadArgs "if (i > 10000) :then {   (id + " not free after 10000 attempts").print;   i := 0}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (i > 10000) :then {   (id + " not free after 10000 attempts").print;   i := 0}" 
 -- $IfThen:invoke: "if (i > 10000) :then {   (id + " not free after 10000 attempts").print;   i := 0" } 
 -- $IfThen:gen: "if (i > 10000) :then {   (id + " not free after 10000 attempts").print;   i := 0" } 
 -- $ObjectGenerator:gen: "(i > 10000)" >OGid:">" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(i > 10000)" 
 -- OG:before:super.gen: "(i > 10000)" 
 -- $Invocation:gen: "(i > 10000)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(i > 10000)" 
 -- isConstant: "Invocation" "(i > 10000)" 
 -- needorigin: "(i > 10000)" 
 -- needOrigin:E: "(i > 10000)"  E.ATd: ">  : {   %basic 53;   in V: var integer;   out B: var boolean}" 
 -- doNeedOrigin:Ex: "(i > 10000)" 
 -- computeAdr:superAdj: 0 "(i > 10000)" 
 -- computeAdr: 1 :rec: "none"  E: "(i > 10000)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(i > 10000)"  
 -- $BracketedExp:loadOrigin: "(i > 10000)"  
 -- computeAdr:superAdj: 0 "i > 10000" 
 -- computeAdr: 1 :rec: "none"  E: "i > 10000" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "i > 10000"  
 -- $BinOp:loadOrigin: "i > 10000"  
 -- BinaryExp:loadOrigin:empty: "i > 10000" superAdj: 0 
 -- $BinOp:getAdr: "i > 10000"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "i > 10000"  ATd: ">  : {   %basic 53;   in V: var integer;   out B: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "i > 10000" 
 -- BE:loadOrigin:E: i > 10000 
 -- $BinOp:getAdr: "i > 10000"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "i > 10000"  ATd: ">  : {   %basic 53;   in V: var integer;   out B: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "i > 10000" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "i > 10000" E:  "i > 10000" 
 -- INV:gen:E.loadArgs "i > 10000" 
 -- $BinOp:loadArgs: "i > 10000"  
 -- BinaryExp:loadArgs: "i > 10000" superAdj: 0 
 -- $Invocation:gen: "i" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "i" 
 -- isConstant: "Invocation" "i" 
 -- notConst: i i: var integer{--disable} 
 -- needorigin: "i" 
 -- needOrigin:E: "i"  E.ATd: "i: var integer{--disable}" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "i" 
 -- computeAdr: 1 :rec: "none"  E: "i" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "i"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "i" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$99" on: 1 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg $99$99 1
 -- $ObjectInvocation_Unary:getAdr: "i" >ATd.off:3:on:1:superAdj:0"i: var integer{--disable":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVal ...} 
 -- $var:getAdr: "i: var integer{--disable" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVal ...} 
 -- DI:OG: integer{--disable} 
 -- before:floatTest:  "i: var integer{--disable}" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "i"  ATd: "i: var integer{--disable}" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- computeAdr:isLast:E:  "i" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- rec:  "i" E:  "i" 
 -- INV:gen:E.loadArgs "i" 
 -- $ObjectInvocation_Unary:loadArgs: "i" >staticOff:0 "i: var integer{--disable" superAdj:0} 
 -- $var:loadArgs: "i: var integer{--disable" >E:"i"} 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "i" 
 -- {(ObjectInvocation_Unary; (name: "i"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "i" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "i" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- $ObjectInvocation_Unary:invoke: "i" >rec:"i" ATd:"var" isValueObj E:"i" E.ATd:"i" unique:"False" 
 -- OI:invoke: "i" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- OI:invoke:B: "i" E: "i"  rec: "i"  useRtnV: true "i: var integer{--disable}" 
 -- OI:invoke:before:ATdx.invoke: var i 
 -- $var:invoke: "i: var integer{--disable" E: "i">newOff:3 useRTNv: "True"} 
 -- DI:invoke: "i: var integer{--disable}" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- isCompositeValueObj: false E: "i" "i: var integer{--disable}" true 
 -- E.ATd.isValueObj: false rec: "i" 
 pushg 3 loop$97
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- 
 -- OI:invoke:C: i :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- left:#I "i > 10000" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- $pattern:loadArgs: ">  : {   %basic 53;   in V: var integer;   out B: var boolean" >E:"> 10000":descNo:101} 
 -- ptn:loadArgs:E "> 10000" 
 -- {(ObjectInvocation_Binary; (name: ">"); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 10000));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "10000" 
 -- E: "ObjectGenerator" 10000 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "> 10000" "ObjectInvocation_Binary" ActArg:  "10000" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "> 10000"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "10000" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "10000" 
 -- OG:before:super.gen: "10000" 
 -- $Invocation:gen: "10000" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "10000" 
 -- isConstant: "Invocation" "10000" 
 -- needorigin: "10000" 
 -- needOrigin:E: "10000"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V:  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "10000" E:  "10000" 
 -- INV:gen:E.loadArgs "10000" 
 -- $ConstLiteral:loadArgs: "10000"  
 -- INV:gen:after:E.loadArgs "10000" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "10000" 
 -- $ConstLiteral:invoke: "10000"  
 pushc 10000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "10000" :isBasicVal: true 
 -- case:B: 10000 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "> 10000" 
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- INV:gen:after:E.loadArgs "i > 10000" 
 -- OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- IV:E.invoke:useRtnVal: true E: BinOp "i > 10000" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- $BinOp:invoke: "i > 10000"  
 -- BinaryExp:invoke: "i" rec: "i > 10000" 
 -- M: "> 10000" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- $ObjectInvocation_Binary:invoke: "> 10000" >rec:"i" ATd:"pattern" E:"> 10000" E.ATd:">  " unique:"False" 
 -- OI:invoke: "> 10000" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- origin:isValueObj "integer" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- OI:invoke:B: "> 10000" E: "> 10000"  rec: "i"  useRtnV: true ">  : {   %basic 53;   in V: var integer;   out B: var boolean}" 
 -- OI:invoke:before:ATdx.invoke: pattern >   
 -- $pattern:invoke: ">  : {   %basic 53;   in V: var integer;   out B: var boolean" E: "> 10000" useRTNv: "True"} 
 -- ptn:invoke: ">  " E: "> 10000" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "i" E: "> 10000" 
 -- arg:integer 
 gt
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"> 10000":rec:i 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"> 10000":rec:i 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: > 10000 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: "(id + " not free after 10000 attempts").print{   i := 0" >OGid:"$102" singular! staticOff=0 descNo=102 superAdj=0} 
 -- OG:gen: "(id + " not free after 10000 attempts").print{   i := 0}" 
 pushThis 
 -- before objTmpStack:add:  102   "$102" 
 invoke $102 102 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "restart(loop)" 
 -- $ObjectGenerator:gen: "restart(loop)" >OGid:"restart" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "restart(loop)" 
 -- OG:before:super.gen: "restart(loop)" 
 -- $Invocation:gen: "restart(loop)" >useRtnV:"False"superAdj: 0 descNo: 50 
 -- INV:gen: "restart(loop)" 
 -- isConstant: "Invocation" "restart(loop)" 
 -- needorigin: "restart(loop)" 
 -- needOrigin:E: "restart(loop)"  E.ATd: "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- doNeedOrigin:Ex: "restart(loop)" 
 -- computeAdr:superAdj: 0 "restart(loop)" 
 -- computeAdr: 1 :rec: "none"  E: "restart(loop)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "restart(loop)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "restart(loop)" >on:5 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "restart(loop)" >ATd.off:0 (isPtn):on:5:superAdj:0"restart(V: var integer):  -- odd parameter type!{   %basic 102":Adr:off:0 size:0 isFlo ...} 
 -- $pattern:getAdr: "restart(V: var integer):  -- odd parameter type!{   %basic 102" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:- 
 -- E.on: 5 
 -- beforeIsValueObj:E: "restart(loop)"  ATd: "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:- 
 -- computeAdr:isLast:E:  "restart(loop)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:- 
 -- rec:  "restart(loop)" E:  "restart(loop)" 
 -- INV:gen:E.loadArgs "restart(loop)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "restart(loop)" >staticOff:0 "restart(V: var integer):  -- odd parameter type!{   %basic 102" superAdj:0arg:"loop"} 
 -- $pattern:loadArgs: "restart(V: var integer):  -- odd parameter type!{   %basic 102" >E:"restart(loop)":descNo:50} 
 -- INV:gen:after:E.loadArgs "restart(loop)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "restart(loop)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart ..." 
 -- $ObjectInvocation_KeyWord:invoke: "restart(loop)" >rec:"restart(loop)" ATd:"pattern" E:"restart(loop)" E.ATd:"restart(V: var integer)" unique:"False" 
 -- OI:invoke: "restart(loop)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- OI:invoke:B: "restart(loop)" E: "restart(loop)"  rec: "restart(loop)"  useRtnV: false "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- OI:invoke:before:ATdx.invoke: pattern restart(V: var integer) 
 -- $pattern:invoke: "restart(V: var integer):  -- odd parameter type!{   %basic 102" E: "restart(loop)" useRTNv: "False"} 
 -- ptn:invoke: "restart(V: var integer)" E: "restart(loop)" ptnKind: 0 useRtnV: false 
 break  1 1 97 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- 
 -- OI:invoke:C: restart(loop) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 102 
 -- Items:GenClass: $102 descNo: 102 isValue: false 
 -- Items:GenClass: $102 descNo: 21 isValue: false 

 CLASS $102 102 1 $99 99
 -- Store itemArgs: (id + " not free after 10000 attempts").print{i := 0} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=102 vDescInx=102 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "(id + " not free after 10000 attempts").print" 
 -- $ObjectGenerator:gen: "(id + " not free after 10000 attempts").print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(id + " not free after 10000 attempts").print" 
 -- OG:before:super.gen: "(id + " not free after 10000 attempts").print" 
 -- $Invocation:gen: "(id + " not free after 10000 attempts").print" >useRtnV:"False"superAdj: 0 descNo: 103 
 -- INV:gen: "(id + " not free after 10000 attempts").print" 
 -- isConstant: "Invocation" "(id + " not free after 10000 attempts").print" 
 -- needorigin: "(id + " not free after 10000 attempts").print" 
 -- needOrigin:E: "print"  E.ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- doNeedOrigin:Ex: "(id + " not free after 10000 attempts")" 
 -- computeAdr:superAdj: 0 "(id + " not free after 10000 attempts").print" 
 -- computeAdr: 1 :rec: "none"  E: "(id + " not free after 10000 attempts")" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(id + " not free after 10000 attempts")"  
 -- $BracketedExp:loadOrigin: "(id + " not free after 10000 attempts")"  
 -- computeAdr:superAdj: 0 "id + " not free after 10000 attempts"" 
 -- computeAdr: 1 :rec: "none"  E: "id + " not free after 10000 attempts"" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "id + " not free after 10000 attempts""  
 -- $BinOp:loadOrigin: "id + " not free after 10000 attempts""  
 -- BinaryExp:loadOrigin:empty: "id + " not free after 10000 attempts"" superAdj: 0 
 -- $BinOp:getAdr: "id + " not free after 10000 attempts""  
 -- E.on: 4 
 -- beforeIsValueObj:E: "id + " not free after 10000 attempts""  ATd: "+  : {   in S: var String;   out V: var String;   L: var integer;   L := Length;   doplus: do ;      e:  ...}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "id + " not free after 10000 attempts"" 
 -- BE:loadOrigin:E: id + " not free after 10000 attempts" 
 -- $BinOp:getAdr: "id + " not free after 10000 attempts""  
 -- E.on: 4 
 -- beforeIsValueObj:E: "id + " not free after 10000 attempts""  ATd: "+  : {   in S: var String;   out V: var String;   L: var integer;   L := Length;   doplus: do ;      e:  ...}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "id + " not free after 10000 attempts""  E: "print" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "print" >ATd.off:0 (isPtn):on:0:superAdj:0"print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   ":Adr: ...} 
 -- $pattern:getAdr: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $BinOp:loadArgs: "id + " not free after 10000 attempts""  
 -- BinaryExp:loadArgs: "id + " not free after 10000 attempts"" superAdj: 0 
 -- $Invocation:gen: "id" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "id" 
 -- isConstant: "Invocation" "id" 
 -- notConst: id in id: var String 
 -- needorigin: "id" 
 -- needOrigin:E: "id"  E.ATd: "in id: var String" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "id" 
 -- computeAdr: 1 :rec: "none"  E: "id" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "id"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "id" >on:4 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$102" on: 4 isValueObj: false 
 -- origin: $99 origin:isValueObj: false 
 rpushg $102$102 1
 -- items:goOrigin:encOG: "$99" on: 3 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg $99$99 1
 -- items:goOrigin:encOG: "loop" on: 2 isValueObj: false 
 -- origin: get origin:isValueObj: false 
 rpushg loop$97 1
 -- items:goOrigin:encOG: "get" on: 1 isValueObj: false 
 -- origin: Lock origin:isValueObj: false 
 rpushg get$96 1
 -- $ObjectInvocation_Unary:getAdr: "id" >ATd.off:1:on:4:superAdj:0"in id: var String":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- PING:String 0 (id + " not free after 10000 attempts").print{   i := 0} 
 -- BOBS:ATd: "in id: var String" 
 -- $var:getAdr: "in id: var String" >newOff:1,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- E.on: 4 
 -- beforeIsValueObj:E: "id"  ATd: "in id: var String" 
 -- computeAdr:isFirst: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "id" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "id" E:  "id" 
 -- INV:gen:E.loadArgs "id" 
 -- $ObjectInvocation_Unary:loadArgs: "id" >staticOff:0 "in id: var String" superAdj:0 
 -- $var:loadArgs: "in id: var String" >E:"id" 
 -- $pattern:loadArgs: "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- actu ..."} 
 -- ptn:loadArgs:E "id" 
 -- {(ObjectInvocation_Unary; (name: "id"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "id" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "id" :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "id" >rec:"id" ATd:"var" E:"id" E.ATd:"id" unique:"False" 
 -- OI:invoke: "id" 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:id 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:id 
 -- OI:invoke:B: "id" E: "id"  rec: "id"  useRtnV: true "in id: var String" 
 -- OI:invoke:before:ATdx.invoke: var id 
 -- $var:invoke: "in id: var String" E: "id">newOff:1 useRTNv: "True" 
 -- DI:invoke: "in id: var String" 
 -- >Object:unique: false 
 -- load: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"id":rec:id 
 -- isCompositeValueObj: false E: "id" "in id: var String" false 
 -- E.ATd.isValueObj: false rec: "id" 
 rpushg Lock$76 1
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"id":rec:id 
 -- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"id":rec:id 
 -- 
 -- OI:invoke:C: id :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 1 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"id":rec:id 
 -- $pattern:loadArgs: "+  : {   in S: var String;   out V: var String;   L: var integer;   L := Length;   doplus: do ;      e: var integer;      i: var integer;      T: obj I ..."} 
 -- ptn:loadArgs:E "+ " not free after 10000 attempts"" 
 -- {(ObjectInvocation_Binary; (name: "+"); (Arguments;  (ObjectGenerator;   (Invocation;    (String:  not free after 10000 attempts));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "" not free after 10000 attempts"" 
 -- E: "ObjectGenerator" " not free after 10000 attempts" 
 -- E.arg: "var" in S: var String 
 -- NonVirt: "+ " not free after 10000 attempts"" "ObjectInvocation_Binary" ActArg:  "" not free after 10000 attempts"" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ " not free after 10000 attempts""  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "" not free after 10000 attempts"" >OGid:"String" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "" not free after 10000 attempts"" 
 -- OG:before:super.gen: "" not free after 10000 attempts"" 
 -- $Invocation:gen: "" not free after 10000 attempts"" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "" not free after 10000 attempts"" 
 -- isConstant: "Invocation" "" not free after 10000 attempts"" 
 -- needorigin: "" not free after 10000 attempts"" 
 -- needOrigin:E: "" not free after 10000 attempts""  E.ATd: "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "" not free after 10000 attempts"" E:  "" not free after 10000 attempts"" 
 -- INV:gen:E.loadArgs "" not free after 10000 attempts"" 
 -- $String::loadArgs: "" not free after 10000 attempts""  
 -- INV:gen:after:E.loadArgs "" not free after 10000 attempts"" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: String: "" not free after 10000 attempts"" 
 -- $String::invoke: "" not free after 10000 attempts""  
 pushText " not free after 10000 attempts"
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in S: var String" :isBasicVal: false :valueObj: false 
 -- :actArg: "" not free after 10000 attempts"" :isBasicVal: false 
 -- case:B: " not free after 10000 attempts" ObjectGenerator 5 5 5 false false 
 -- end:loadArgs:NonVirt: "+ " not free after 10000 attempts"" 
 -- BinaryExp:loadArgs:end: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"id":rec:id 
 -- $BinOp:invoke: "id + " not free after 10000 attempts""  
 -- BinaryExp:invoke: "id" rec: "id + " not free after 10000 attempts"" 
 -- M: "+ " not free after 10000 attempts"" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:- 
 -- $ObjectInvocation_Binary:invoke: "+ " not free after 10000 attempts"" >rec:"id" ATd:"pattern" E:"+ " not free after 10000 attempts"" E.ATd:"+  " unique:"False" 
 -- OI:invoke: "+ " not free after 10000 attempts"" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:id 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:id 
 -- OI:invoke:B: "+ " not free after 10000 attempts"" E: "+ " not free after 10000 attempts""  rec: "id"  useRtnV: true "+  : {   in S: var String;   out V: var String;   L: v ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- $pattern:invoke: "+  : {   in S: var String;   out V: var String;   L: var integer;   L := Length;   doplus: do ;      e: var integer;      i: var integer;      T: obj Ind ..."} 
 -- ptn:invoke: "+  " E: "+ " not free after 10000 attempts"" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"+ " not free after 10000 attempts"":re ... 
 invoke + 147 0 0
 -- global:pushOut: V off: 3 
 rpushg  3
 -- callInvoke:after:pushOut: 3 
 -- GeneralPTN:invoke:after:callInvoke: 3 
 -- GeneralPTN:invoke:end: 3 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"+ " not free after 10000 attempts"":rec:id 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"+ " not free after 10000 attempts"":rec:id 
 -- adrx: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"+ " not free after 10000 attempts"":rec:id 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"+ " not free after 10000 attempts"":rec:id 
 -- adrx: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"+ " not free after 10000 attempts"":rec:id 
 -- OI:invoke:C: + " not free after 10000 attempts" :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "id + " not free after 10000 attempts"" E: "print" 
 -- computeAdr:isLast:E:  "print" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"+ " not free after 10000 attempts"":rec:id 
 -- rec:  "id + " not free after 10000 attempts"" E:  "print" 
 -- INV:gen:E.loadArgs "print" 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " superAdj:0} 
 -- $pattern:loadArgs: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " >E:"print":descNo:103} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "print" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"+ " not free afte ... 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:"id + " not free after 10000 attempts"" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"+ " not free after 10000 attempts"":rec:id + " not free after 10000 attempts" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"+ " not free after 10000 attempts"":rec:id + " not free after 10000 attempts" 
 -- OI:invoke:B: "print" E: "print"  rec: "id + " not free after 10000 attempts""  useRtnV: false "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:id + " not free after 10000 ..." 
 invoke print 103 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:id + " not free after 10000 attempts" 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:id + " not free after 10000 attempts" 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:id + " not free after 10000 attempts" 
 -- genclass:stmt: "i := 0" 
 -- $Assign:gen: "i := 0"  
 -- assign: "i := 0" 
 -- computeAdr:superAdj: 0 "i" 
 -- computeAdr: 1 :rec: "none"  E: "i" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "i"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "i" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$102" on: 2 isValueObj: false 
 -- origin: $99 origin:isValueObj: false 
 rpushg $102$102 1
 -- items:goOrigin:encOG: "$99" on: 1 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg $99$99 1
 -- $ObjectInvocation_Unary:getAdr: "i" >ATd.off:3:on:2:superAdj:0"i: var integer{--disable":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVal ...} 
 -- $var:getAdr: "i: var integer{--disable" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVal ...} 
 -- DI:OG: integer{--disable} 
 -- before:floatTest:  "i: var integer{--disable}" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "i"  ATd: "i: var integer{--disable}" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- computeAdr:isLast:E:  "i" 
 -- AssignmentStatement:gen: "i := 0" right.label: "ObjectGenerator" "0" 
 -- $ObjectGenerator:gen: "0" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "0" 
 -- OG:before:super.gen: "0" 
 -- $Invocation:gen: "0" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "0" 
 -- isConstant: "Invocation" "0" 
 -- needorigin: "0" 
 -- needOrigin:E: "0"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "0" E:  "0" 
 -- INV:gen:E.loadArgs "0" 
 -- $ConstLiteral:loadArgs: "0"  
 -- INV:gen:after:E.loadArgs "0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0" 
 -- $ConstLiteral:invoke: "0"  
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "i" dstE: "i" dstE.ATd: "i: var integer{--disable}" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "0" 
 -- isArgOfAssignI2IwithUniValArg "i := 0" arg: "0" ObjectGenerator 
 -- arg.super.arg: "0" ConstLiteral 
 -- dstDI: "i: var integer{--disable}" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg loop$97 3
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 147 
 -- Items:GenClass: + descNo: 147 isValue: false 
 -- Items:GenClass: + descNo: 21 isValue: false 

 CLASS + 147 1 String 10
 -- Store itemArgs: in S: var String{out V: var String;L: var integer;L := Length;doplus: do ;   e: var integer;   i: var integer;   T: obj Indexed(L + S.length,Integer);   fo ...} 
 -- in S: var String true 5 
 pushThis 
 rstoreg  S 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- Store:Origin: 5 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=147 vDescInx=147 vdtTop: 1 
 mvStack 
 -- $var:gen: "in S: var String"  
 -- DI:gen: "in S: var String" DI:isConst: false :isBasicValue: false :primNo: 5 
 -- $var:gen: "out V: var String"  
 -- DI:gen: "out V: var String" DI:isConst: false :isBasicValue: false :primNo: 5 
 -- StringVar "out V: var String" 
 pushText ""
 pushThis 
 rstoreg  V 3
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-3,0)=[]
 -- $var:gen: "L: var integer"  
 -- DI:gen: "L: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  L 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "L := Length" 
 -- $Assign:gen: "L := Length"  
 -- assign: "L := Length" 
 -- computeAdr:superAdj: 0 "L" 
 -- computeAdr: 1 :rec: "none"  E: "L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L" >ATd.off:4:on:0:superAdj:0"L: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- PING:String 0 in S: var String{   out V: var String;   L: var integer;   L := Length;   doplus: do ;      e: var integer;      i: var integer;      T: obj Indexed(L + S.le ...} 
 -- $var:getAdr: "L: var integer" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L: var integer" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdr:isLast:E:  "L" 
 -- AssignmentStatement:gen: "L := Length" right.label: "ObjectGenerator" "Length" 
 -- $ObjectGenerator:gen: "Length" >OGid:"length" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "Length" 
 -- OG:before:super.gen: "Length" 
 -- $Invocation:gen: "Length" >useRtnV:"True"superAdj: 0 descNo: 15 
 -- INV:gen: "Length" 
 -- isConstant: "Invocation" "Length" 
 -- needorigin: "Length" 
 -- needOrigin:E: "Length"  E.ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- doNeedOrigin:Ex: "Length" 
 -- computeAdr:superAdj: 0 "Length" 
 -- computeAdr: 1 :rec: "none"  E: "Length" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Length"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Length" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "+" on: 1 isValueObj: false 
 -- origin: String origin:isValueObj: false 
 rpushg +$147 1
 -- $ObjectInvocation_Unary:getAdr: "Length" >ATd.off:0 (isPtn):on:1:superAdj:0"length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length":Adr ...} 
 -- PING:String 0 in S: var String{   out V: var String;   L: var integer;   L := Length;   doplus: do ;      e: var integer;      i: var integer;      T: obj Indexed(L + S.le ...} 
 -- $pattern:getAdr: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "Length"  ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:- 
 -- computeAdr:isLast:E:  "Length" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:- 
 -- rec:  "Length" E:  "Length" 
 -- INV:gen:E.loadArgs "Length" 
 -- $ObjectInvocation_Unary:loadArgs: "Length" >staticOff:0 "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" superAdj:0} 
 -- $pattern:loadArgs: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" >E:"Length":descNo:15} 
 -- ptn:loadArgs:E "Length" 
 -- {(ObjectInvocation_Unary; (name: "Length"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "Length" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "Length" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:- 
 -- $ObjectInvocation_Unary:invoke: "Length" >rec:"Length" ATd:"pattern" E:"Length" E.ATd:"length" unique:"False" 
 -- OI:invoke: "Length" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 -- OI:invoke:B: "Length" E: "Length"  rec: "Length"  useRtnV: true "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- $pattern:invoke: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" E: "Length" useRTNv: "True"} 
 -- ptn:invoke: "length" E: "Length" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -4 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 -- OI:invoke:C: Length :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 -- rec: "L" dstE: "L" dstE.ATd: "L: var integer" useRtn: false :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "Length" 
 -- isArgOfAssignI2IwithUniValArg "L := Length" arg: "Length" ObjectGenerator 
 -- arg.super.arg: "Length" ObjectInvocation_Unary 
 -- dstDI: "L: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg +$147 4
 -- assign:adr.store:B: 
 -- genclass:stmt: "doplus: do {   e: var integer;   i: var integer;   T: obj Indexed(L + S.length,Integer);   for(1):to(L):repeat;      e := get[inx];      T.put(e):at[inx];  ...}" 
 -- $do:gen: "doplus: do {   e: var integer;   i: var integer;   T: obj Indexed(L + S.length,Integer);   for(1):to(L):repeat;      e := get[inx];      T.put(e):at[inx];   ;    ..."} 
 -- $ObjectGenerator:gen: "e: var integer{   i: var integer;   T: obj Indexed(L + S.length,Integer);   for(1):to(L):repeat;      e := get[inx];      T.put(e):at[inx];   ;   fo ..."} 
 -- OG:gen: "e: var integer{   i: var integer;   T: obj Indexed(L + S.length,Integer);   for(1):to(L):repeat;      e := get[inx];      T.put(e):at[inx];   ;   for(1):to(S.leng ...}" 
 pushThis 
 -- before objTmpStack:add:  148   "doplus" 
 invoke doplus 148 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -5 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 -- pushReturn:  "+" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 148 
 -- Items:GenClass: doplus descNo: 148 isValue: false 
 -- Items:GenClass: doplus descNo: 21 isValue: false 

 CLASS doplus 148 1 + 147
 -- Store itemArgs: e: var integer{i: var integer;T: obj Indexed(L + S.length,Integer);for(1):to(L):repeat;   e := get[inx];   T.put(e):at[inx];;for(1):to(S.length):repeat;    ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=148 vDescInx=148 vdtTop: 1 
 mvStack 
 -- $var:gen: "e: var integer"  
 -- DI:gen: "e: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  e 
 -- $var:gen: "i: var integer"  
 -- DI:gen: "i: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  i 
 -- $obj:gen: "T: obj Indexed(L + S.length,Integer)"  
 -- DI:gen: "T: obj Indexed(L + S.length,Integer)" DI:isConst: true :isBasicValue: false :primNo: 114 
 -- DI:add:BP4:  T 
 -- $ObjectGenerator:gen: "Indexed(L + S.length,Integer)" >OGid:"T" IS.isempty! staticOff=4 descNo=0 superAdj=0 
 -- OG:gen: "Indexed(L + S.length,Integer)" 
 -- OG:before:super.gen: "Indexed(L + S.length,Integer)" 
 -- $Invocation:gen: "Indexed(L + S.length,Integer)" >useRtnV:"False"superAdj: 0 descNo: 86 
 -- INV:gen: "Indexed(L + S.length,Integer)" 
 -- isConstant: "Invocation" "Indexed(L + S.length,Integer)" 
 -- needorigin: "Indexed(L + S.length,Integer)" 
 -- needOrigin:E: "Indexed(L + S.length,Integer)"  E.ATd: "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%globals{   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];   p ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "Indexed(L + S.length,Integer)" E:  "Indexed(L + S.length,Integer)" 
 -- INV:gen:E.loadArgs "Indexed(L + S.length,Integer)" 
 -- $ObjectInvocation_Function:loadArgs: "Indexed(L + S.length,Integer)" >staticOff:0 "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Obje ..."} 
 -- $pattern:loadArgs: "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];  ..."} 
 -- ptn:loadArgs:E "Indexed(L + S.length,Integer)" 
 -- {(ObjectInvocation_Function; (name: "Indexed"); (Arguments;  (ObjectGenerator;   (Invocation;    (BinOp:+;     (Invocation;      (ObjectInvocation_Unary;       (name: "L") ...} 
 -- args: "(L + S.length,Integer)" 
 -- E: "ObjectGenerator" L + S.length 
 -- E: "ObjectGenerator" Integer 
 -- E.arg: "var" in range: var Integer 
 -- NonVirt: "Indexed(L + S.length,Integer)" "ObjectInvocation_Function" ActArg:  "L + S.length" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "Indexed(L + S.length,Integer)"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "L + S.length" >OGid:"+" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L + S.length" 
 -- OG:before:super.gen: "L + S.length" 
 -- $Invocation:gen: "L + S.length" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L + S.length" 
 -- isConstant: "Invocation" "L + S.length" 
 -- needorigin: "L + S.length" 
 -- needOrigin:E: "L + S.length"  E.ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- doNeedOrigin:Ex: "L + S.length" 
 -- computeAdr:superAdj: 0 "L + S.length" 
 -- computeAdr: 1 :rec: "none"  E: "L + S.length" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "L + S.length"  
 -- $BinOp:loadOrigin: "L + S.length"  
 -- BinaryExp:loadOrigin:empty: "L + S.length" superAdj: 0 
 -- $BinOp:getAdr: "L + S.length"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "L + S.length"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "L + S.length" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "L + S.length" E:  "L + S.length" 
 -- INV:gen:E.loadArgs "L + S.length" 
 -- $BinOp:loadArgs: "L + S.length"  
 -- BinaryExp:loadArgs: "L + S.length" superAdj: 0 
 -- $Invocation:gen: "L" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L" 
 -- isConstant: "Invocation" "L" 
 -- notConst: L L: var integer 
 -- needorigin: "L" 
 -- needOrigin:E: "L"  E.ATd: "L: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L" 
 -- computeAdr: 1 :rec: "none"  E: "L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "doplus" on: 1 isValueObj: false 
 -- origin: + origin:isValueObj: false 
 rpushg doplus$148 1
 -- $ObjectInvocation_Unary:getAdr: "L" >ATd.off:4:on:1:superAdj:0"L: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "L: var integer" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L: var integer" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "L"  ATd: "L: var integer" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdr:isLast:E:  "L" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- rec:  "L" E:  "L" 
 -- INV:gen:E.loadArgs "L" 
 -- $ObjectInvocation_Unary:loadArgs: "L" >staticOff:0 "L: var integer" superAdj:0 
 -- $var:loadArgs: "L: var integer" >E:"L" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "L" 
 -- {(ObjectInvocation_Unary; (name: "L"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L" >rec:"L" ATd:"var" isValueObj E:"L" E.ATd:"L" unique:"False" 
 -- OI:invoke: "L" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "L" E: "L"  rec: "L"  useRtnV: true "L: var integer" 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- $var:invoke: "L: var integer" E: "L">newOff:4 useRTNv: "True" 
 -- DI:invoke: "L: var integer" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- isCompositeValueObj: false E: "L" "L: var integer" true 
 -- E.ATd.isValueObj: false rec: "L" 
 pushg 4 +$147
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- OI:invoke:C: L :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- left:#I "L + S.length" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- $pattern:loadArgs: "+  : {   %basic 61;   in V: var integer;   out R: var integer" >E:"+ S.length":descNo:49} 
 -- ptn:loadArgs:E "+ S.length" 
 -- {(ObjectInvocation_Binary; (name: "+"); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "S");     (Arguments));    (ObjectInvocation_U ...} 
 -- args: "S.length" 
 -- E: "ObjectGenerator" S.length 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "+ S.length" "ObjectInvocation_Binary" ActArg:  "S.length" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ S.length"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "S.length" >OGid:"length" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "S.length" 
 -- OG:before:super.gen: "S.length" 
 -- $Invocation:gen: "S.length" >useRtnV:"True"superAdj: 0 descNo: 15 
 -- INV:gen: "S.length" 
 -- isConstant: "Invocation" "S.length" 
 -- notConst: S in S: var String 
 -- needorigin: "S.length" 
 -- needOrigin:E: "length"  E.ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- doNeedOrigin:Ex: "length" 
 -- computeAdr:superAdj: 0 "S.length" 
 -- computeAdr: 1 :rec: "none"  E: "S" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "S"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "S" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "doplus" on: 1 isValueObj: false 
 -- origin: + origin:isValueObj: false 
 rpushg doplus$148 1
 -- $ObjectInvocation_Unary:getAdr: "S" >ATd.off:2:on:1:superAdj:0"in S: var String":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- PING:String 0 e: var integer{   i: var integer;   T: obj Indexed(L + S.length,Integer);   for(1):to(L):repeat;      e := get[inx];      T.put(e):at[inx];   ;   for(1):to(S ...} 
 -- BOBS:ATd: "in S: var String" 
 -- Is not: in Veq: var this(Value) 
 -- $var:getAdr: "in S: var String" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "S"  ATd: "in S: var String" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "S"  E: "length" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "length" >ATd.off:0 (isPtn):on:0:superAdj:0"length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length":Adr ...} 
 -- $pattern:getAdr: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "S" >staticOff:0 "in S: var String" superAdj:0 
 -- $var:loadArgs: "in S: var String" >E:"S" 
 -- $pattern:loadArgs: "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- actu ..."} 
 -- ptn:loadArgs:E "S" 
 -- {(ObjectInvocation_Unary; (name: "S"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "S" >rec:"S" ATd:"var" E:"length" E.ATd:"length" unique:"False" 
 -- OI:invoke: "S" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:B: "S" E: "length"  rec: "S"  useRtnV: true "in S: var String" 
 -- OI:invoke:before:ATdx.invoke: var S 
 -- $var:invoke: "in S: var String" E: "length">newOff:2 useRTNv: "True" 
 -- DI:invoke: "in S: var String" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 rpushg doplus$148 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- 
 -- OI:invoke:C: S :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "S" E: "length" 
 -- computeAdr:isLast:E:  "length" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- rec:  "S" E:  "length" 
 -- INV:gen:E.loadArgs "length" 
 -- $ObjectInvocation_Unary:loadArgs: "length" >staticOff:0 "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" superAdj:0} 
 -- $pattern:loadArgs: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" >E:"length":descNo:15} 
 -- ptn:loadArgs:E "length" 
 -- {(ObjectInvocation_Unary; (name: "length"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "length" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- $ObjectInvocation_Unary:invoke: "length" >rec:"S" ATd:"pattern" E:"length" E.ATd:"length" unique:"False" 
 -- OI:invoke: "length" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:B: "length" E: "length"  rec: "S"  useRtnV: true "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- $pattern:invoke: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" E: "length" useRTNv: "True"} 
 -- ptn:invoke: "length" E: "length" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:C: length :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "S.length" :isBasicVal: true 
 -- case:B: S.length ObjectGenerator 1 0 0 false false 
 -- end:loadArgs:NonVirt: "+ S.length" 
 -- BinaryExp:loadArgs:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:after:E.loadArgs "L + S.length" 
 -- OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L + S.length" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- $BinOp:invoke: "L + S.length"  
 -- BinaryExp:invoke: "L" rec: "L + S.length" 
 -- M: "+ S.length" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- $ObjectInvocation_Binary:invoke: "+ S.length" >rec:"L" ATd:"pattern" E:"+ S.length" E.ATd:"+  " unique:"False" 
 -- OI:invoke: "+ S.length" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- origin:isValueObj "integer" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "+ S.length" E: "+ S.length"  rec: "L"  useRtnV: true "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- $pattern:invoke: "+  : {   %basic 61;   in V: var integer;   out R: var integer" E: "+ S.length" useRTNv: "True"} 
 -- ptn:invoke: "+  " E: "+ S.length" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "L" E: "+ S.length" 
 -- arg:other 
 plus
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ S.length":rec:L 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ S.length":rec:L 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: + S.length :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in range: var Integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "L + S.length" :isBasicVal: true 
 -- case:B: L + S.length ObjectGenerator 1 61 61 false false 
 -- end:loadArgs:NonVirt: "Indexed(L + S.length,Integer)" 
 -- INV:gen:after:E.loadArgs "Indexed(L + S.length,Integer)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Function "Indexed(L + S.length,Integer)" 
 -- $ObjectInvocation_Function:invoke: "Indexed(L + S.length,Integer)" >rec:"Indexed(L + S.length,Integer)" ATd:"pattern" E:"Indexed(L + S.length,Integer)" E.ATd:"Indexed" uni ... 
 -- OI:invoke: "Indexed(L + S.length,Integer)" 
 -- 
 -- OI:invoke:B: "Indexed(L + S.length,Integer)" E: "Indexed(L + S.length,Integer)"  rec: "Indexed(L + S.length,Integer)"  useRtnV: false "Indexed: {   %globals;   %basic 114; ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Indexed 
 -- $pattern:invoke: "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];    ..."} 
 -- ptn:invoke: "Indexed" E: "Indexed(L + S.length,Integer)" ptnKind: 0 useRtnV: false 
 pushThis 
 -- ObjTmpStack:add: "Indexed" : "%globals{   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];   p ...}" 
 pushc 1
 allocIndexed doplus$148 86 1 0
 pushThis 
 rstoreg  doplus$148 4
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -4 rTopMax: 0 V: 0 R: 
   ;; vTop(2,2)=[0/0,0/0] rTop(-4,0)=[]
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- OI:invoke:C: Indexed(L + S.length,Integer) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- $ObjectGenerator:gen: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];" >OGid:"for:to:repeat$150" IS.isempty! staticOff=0 descNo=150 superAdj=0} 
 -- OG:gen: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 pushThis 
 -- before objTmpStack:add:  150   "for:to:repeat$150" 
 invoke for:to:repeat$150 150 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -5 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- genclass:stmt: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- $ObjectGenerator:gen: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];" >OGid:"for:to:repeat$152" IS.isempty! staticOff=0 descNo=152 super ...} 
 -- OG:gen: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 pushThis 
 -- before objTmpStack:add:  152   "for:to:repeat$152" 
 invoke for:to:repeat$152 152 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -6 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- genclass:stmt: "V := T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- $Assign:gen: "V := T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]" } 
 -- assign: "V := T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- computeAdr:superAdj: 0 "V" 
 -- computeAdr: 1 :rec: "none"  E: "V" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "V"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "V" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "doplus" on: 1 isValueObj: false 
 -- origin: + origin:isValueObj: false 
 rpushg doplus$148 1
 -- $ObjectInvocation_Unary:getAdr: "V" >ATd.off:3:on:1:superAdj:0"out V: var String":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E: ... 
 -- PING:String 0 e: var integer{   i: var integer;   T: obj Indexed(L + S.length,Integer);   for(1):to(L):repeat;      e := get[inx];      T.put(e):at[inx];   ;   for(1):to(S ...} 
 -- BOBS:ATd: "out V: var String" 
 -- $var:getAdr: "out V: var String" >newOff:3,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "V"  ATd: "out V: var String" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "V" 
 -- AssignmentStatement:gen: "V := T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" right.label: "ObjectGenerator" "T.asString{-- V: obj ...}" 
 -- $ObjectGenerator:gen: "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]" >OGid:"asString" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- OG:before:super.gen: "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- $Invocation:gen: "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]" >useRtnV:"True"superAdj: 0 descNo: 153} 
 -- INV:gen: "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- isConstant: "Invocation" "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- needorigin: "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- needOrigin:E: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}"  E.ATd: "asString: {   %basic 118;   out S: var LIB.StringLib.String}" 
 -- doNeedOrigin:Ex: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- computeAdr:superAdj: 0 "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- computeAdr: 1 :rec: "none"  E: "T" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "T"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "T" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "T" >ATd.off:4:on:0:superAdj:0"T: obj Indexed(L + S.length,Integer)":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- $obj:getAdr: "T: obj Indexed(L + S.length,Integer)" >newOff:4,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0  ... 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "T"  E: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]" >ATd.off:0 (isPtn):on:0:superAdj:0"asString: ;   %bas ..."} 
 -- PING:String 0 e: var integer{   i: var integer;   T: obj Indexed(L + S.length,Integer);   for(1):to(L):repeat;      e := get[inx];      T.put(e):at[inx];   ;   for(1):to(S ...} 
 -- BOBS:ATd: "asString: {   %basic 118;   out S: var LIB.StringLib.String}" 
 -- $pattern:getAdr: "asString: {   %basic 118;   out S: var LIB.StringLib.String" } 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.leng ..."} 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "T" >staticOff:0 "T: obj Indexed(L + S.length,Integer)" superAdj:0 
 -- $obj:loadArgs: "T: obj Indexed(L + S.length,Integer)" >E:"T" 
 -- $pattern:loadArgs: "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];  ..."} 
 -- ptn:loadArgs:E "T" 
 -- {(ObjectInvocation_Unary; (name: "T"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "T" >rec:"T" ATd:"obj" E:"asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]" E.ATd:"asString" unique:"Fal ..."} 
 -- OI:invoke: "T" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.leng ..."} 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.leng ..."} 
 -- OI:invoke:B: "T" E: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}"  rec: "T"  useRtnV: true "T: obj Indexed(L + S.length,Integer)" 
 -- OI:invoke:before:ATdx.invoke: obj T 
 -- $obj:invoke: "T: obj Indexed(L + S.length,Integer)" E: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]">newOff:4 useRTNv: "True"} 
 -- DI:invoke: "T: obj Indexed(L + S.length,Integer)" 
 -- >Object:unique: false 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1: ..."} 
 -- isCompositeValueObj: false E: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" "asString: {   %basic 118;   out S: var LIB.StringLib. ...}" false 
 -- E.ATd.isValueObj: false rec: "T" 
 rpushg doplus$148 4
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString{-- V: obj Indexed(Length + S.length);-- V := T[1:leng ..."} 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString{-- V: obj Indexed(Length + S.length);-- V := T[1:leng ..."} 
 -- 
 -- OI:invoke:C: T :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "T" E: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- computeAdr:isLast:E:  "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString{-- V: obj Indexed(Length + S.length);-- ..."} 
 -- rec:  "T" E:  "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- INV:gen:E.loadArgs "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- $ObjectInvocation_Unary:loadArgs: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]" >staticOff:0 "asString: ;   %basic 118;   out S: va ..."} 
 -- $pattern:loadArgs: "asString: {   %basic 118;   out S: var LIB.StringLib.String" >E:"asString;-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]":d ...} 
 -- ptn:loadArgs:E "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- {(ObjectInvocation_Unary; (name: "asString"); (Arguments --<12> V: obj Indexed(Length + S.length);<12> V := T[1:length] + S.T[1:S.length]))} 
 -- args: "-- V: obj Indexed(Length + S.length){-- V := T[1:length] + S.T[1:S.length]}" 
 -- INV:gen:after:E.loadArgs "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" :Adr:off:4 size:0 isFloat:F is ... 
 -- $ObjectInvocation_Unary:invoke: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]" >rec:"T" ATd:"pattern" E:"asString;-- V: obj Indexed( ..."} 
 -- OI:invoke: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.leng ..."} 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.leng ..."} 
 -- OI:invoke:B: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" E: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + ...}"   ... "T ..."   ... true "a ..." 
 -- OI:invoke:before:ATdx.invoke: pattern asString 
 -- $pattern:invoke: "asString: {   %basic 118;   out S: var LIB.StringLib.String" E: "asString;-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]" use ...} 
 -- ptn:invoke: "asString" E: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" ptnKind: 0 useRtnV: true 
 %asString 118
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString{-- V: obj Indexed(Length + S.length);-- V := T[1:leng ..."} 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString{-- V: obj Indexed(Length + S.length);-- V := T[1:leng ..."} 
 -- 
 -- OI:invoke:C: asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]} :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] +  ..."} 
 -- rec: "V" dstE: "V" dstE.ATd: "out V: var String" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- dstDI.isBasicVal: false dstDI.isValObj: false dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- isValue: false  isAdr: true  descNo:  0 
 rswap 0
 rstoreg  EisNone 3
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -8 rTopMax: 0 V: 0 R: 
   ;; vTop(2,2)=[0/0,0/0] rTop(-8,0)=[]
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  "doplus" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 86 
 -- Items:GenClass: Indexed descNo: 86 isValue: false 
 -- Items:GenClass: Indexed descNo: 21 isValue: false 

 CLASS Indexed 86 0 BETA 2
 -- Store itemArgs: %globals{%basic 114;%public;in range: var Integer;in elm:< Object;length: ;   out res: var integer;   res := get[0];put(V: var integer):at[inx: var integer ...} 
 -- in range: var Integer true 1 
 -- DI:store: "range" 
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- vdtAdd: inx=1 descInx=86 vDescInx=86 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%globals"  
 -- $Property:gen: "%basic 114"  
 -- $Property:gen: "%public"  
 -- $var:gen: "in range: var Integer"  
 -- DI:gen: "in range: var Integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  range 
 -- $pattern:gen: "in elm:< Object"  
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%globals" 
 -- $Property:gen: "%globals"  
 -- genclass:stmt: "%basic 114" 
 -- $Property:gen: "%basic 114"  
 -- genclass:stmt: "%public" 
 -- $Property:gen: "%public"  
 L2:
 -- pushReturn:  "Indexed" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:1
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 149 
 -- Items:GenClass: repeat$149 descNo: 149 isValue: false 
 -- Items:GenClass: repeat$149 descNo: 21 isValue: false 

 CLASS repeat$149 149 1 for:to:repeat$150 150
 -- Store itemArgs: e := get[inx]{T.put(e):at[inx]} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=149 vDescInx=149 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "e := get[inx]" 
 -- $Assign:gen: "e := get[inx]"  
 -- assign: "e := get[inx]" 
 -- computeAdr:superAdj: 0 "e" 
 -- computeAdr: 1 :rec: "none"  E: "e" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "e"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "e" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$149" on: 2 isValueObj: false 
 -- origin: for:to:repeat$150 origin:isValueObj: false 
 rpushg repeat$149$149 1
 -- items:goOrigin:encOG: "for:to:repeat$150" on: 1 isValueObj: false 
 -- origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$150$150 4
 -- $ObjectInvocation_Unary:getAdr: "e" >ATd.off:2:on:2:superAdj:0"e: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "e: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "e: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "e"  ATd: "e: var integer" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- computeAdr:isLast:E:  "e" 
 -- AssignmentStatement:gen: "e := get[inx]" right.label: "ObjectGenerator" "get[inx]" 
 -- $ObjectGenerator:gen: "get[inx]" >OGid:"get" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "get[inx]" 
 -- OG:before:super.gen: "get[inx]" 
 -- $Invocation:gen: "get[inx]" >useRtnV:"True"superAdj: 0 descNo: 16 
 -- INV:gen: "get[inx]" 
 -- isConstant: "Invocation" "get[inx]" 
 -- needorigin: "get[inx]" 
 -- needOrigin:E: "get[inx]"  E.ATd: "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- doNeedOrigin:Ex: "get[inx]" 
 -- computeAdr:superAdj: 0 "get[inx]" 
 -- computeAdr: 1 :rec: "none"  E: "get[inx]" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "get[inx]"  
 pushThis 
 -- $ObjectInvocation_KeyWord:loadOrigin: "get[inx]" >on:4 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$149" on: 4 isValueObj: false 
 -- origin: for:to:repeat$150 origin:isValueObj: false 
 rpushg repeat$149$149 1
 -- items:goOrigin:encOG: "for:to:repeat$150" on: 3 isValueObj: false 
 -- origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$150$150 4
 -- items:goOrigin:encOG: "doplus" on: 2 isValueObj: false 
 -- origin: + origin:isValueObj: false 
 rpushg doplus$148 1
 -- items:goOrigin:encOG: "+" on: 1 isValueObj: false 
 -- origin: String origin:isValueObj: false 
 rpushg +$147 1
 -- $ObjectInvocation_KeyWord:getAdr: "get[inx]" >ATd.off:0 (isPtn):on:4:superAdj:0"get[inx: var integer]: {   %basic 117;   out ch: var char":Adr:off:0 size:0 isFloat:F isUni ...} 
 -- $pattern:getAdr: "get[inx: var integer]: {   %basic 117;   out ch: var char" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "get[inx]"  ATd: "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- computeAdr:isLast:E:  "get[inx]" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- rec:  "get[inx]" E:  "get[inx]" 
 -- INV:gen:E.loadArgs "get[inx]" 
 -- $ObjectInvocation_KeyWord:loadArgs: "get[inx]" >staticOff:0 "get[inx: var integer]: {   %basic 117;   out ch: var char" superAdj:0arg:"inx"} 
 -- $pattern:loadArgs: "get[inx: var integer]: {   %basic 117;   out ch: var char" >E:"get[inx]":descNo:16} 
 -- ptn:loadArgs:E "get[inx]" 
 -- {(ObjectInvocation_KeyWord; (name: "get"); (Arguments;  (name: "get");  (name: "[");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "inx");     ( ...} 
 -- args: "get[inx]" 
 -- E: "ObjectGenerator" inx 
 -- E.arg: "var" inx: var integer 
 -- NonVirt: "get[inx]" "ObjectInvocation_KeyWord" ActArg:  "inx" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx]"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "inx" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inx" 
 -- OG:before:super.gen: "inx" 
 -- $Invocation:gen: "inx" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "inx" 
 -- isConstant: "Invocation" "inx" 
 -- notConst: inx inx: var integer 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$149" on: 1 isValueObj: false 
 -- origin: for:to:repeat$150 origin:isValueObj: false 
 rpushg repeat$149$149 1
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:3:on:1:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- $ObjectInvocation_Unary:loadArgs: "inx" >staticOff:0 "inx: var integer" superAdj:0 
 -- $var:loadArgs: "inx: var integer" >E:"inx" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "inx" 
 -- {(ObjectInvocation_Unary; (name: "inx"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: "inx" >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:"inx" unique:"False" 
 -- OI:invoke: "inx" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx" E: "inx"  rec: "inx"  useRtnV: true "inx: var integer" 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: "inx: var integer" E: "inx">newOff:3 useRTNv: "True" 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- isCompositeValueObj: false E: "inx" "inx: var integer" true 
 -- E.ATd.isValueObj: false rec: "inx" 
 pushg 3 for:to:repeat$150$150
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:C: inx :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- formalArg:isPtn: "inx: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "inx" :isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "get[inx]" 
 -- INV:gen:after:E.loadArgs "get[inx]" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx]" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec ... 
 -- $ObjectInvocation_KeyWord:invoke: "get[inx]" >rec:"get[inx]" ATd:"pattern" E:"get[inx]" E.ATd:"get[inx: var integer]" unique:"False" 
 -- OI:invoke: "get[inx]" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- OI:invoke:B: "get[inx]" E: "get[inx]"  rec: "get[inx]"  useRtnV: true "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- $pattern:invoke: "get[inx: var integer]: {   %basic 117;   out ch: var char" E: "get[inx]" useRTNv: "True"} 
 -- ptn:invoke: "get[inx: var integer]" E: "get[inx]" ptnKind: 0 useRtnV: true 
 xpushg  inx 1 0 1
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpop : vTop: 0 vTopMax: 1 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- 
 -- OI:invoke:C: get[inx] :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- rec: "e" dstE: "e" dstE.ATd: "e: var integer" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right: "get[inx]" 
 -- isArgOfAssignI2IwithUniValArg "e := get[inx]" arg: "get[inx]" ObjectGenerator 
 -- arg.super.arg: "get[inx]" ObjectInvocation_KeyWord 
 -- dstDI: "e: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg doplus$148 2
 -- assign:adr.store:B: 
 -- genclass:stmt: "T.put(e):at[inx]" 
 -- $ObjectGenerator:gen: "T.put(e):at[inx]" >OGid:"put:at" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "T.put(e):at[inx]" 
 -- OG:before:super.gen: "T.put(e):at[inx]" 
 -- $Invocation:gen: "T.put(e):at[inx]" >useRtnV:"False"superAdj: 0 descNo: 93 
 -- INV:gen: "T.put(e):at[inx]" 
 -- isConstant: "Invocation" "T.put(e):at[inx]" 
 -- needorigin: "T.put(e):at[inx]" 
 -- needOrigin:E: "put(e):at[inx]"  E.ATd: "put(V: var integer):at[inx: var integer]: {   %basic 115}" 
 -- doNeedOrigin:Ex: "put(e):at[inx]" 
 -- computeAdr:superAdj: 0 "T.put(e):at[inx]" 
 -- computeAdr: 1 :rec: "none"  E: "T" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "T"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "T" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$149" on: 2 isValueObj: false 
 -- origin: for:to:repeat$150 origin:isValueObj: false 
 rpushg repeat$149$149 1
 -- items:goOrigin:encOG: "for:to:repeat$150" on: 1 isValueObj: false 
 -- origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$150$150 4
 -- $ObjectInvocation_Unary:getAdr: "T" >ATd.off:4:on:2:superAdj:0"T: obj Indexed(L + S.length,Integer)":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- $obj:getAdr: "T: obj Indexed(L + S.length,Integer)" >newOff:4,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0  ... 
 -- E.on: 2 
 -- beforeIsValueObj:E: "T"  ATd: "T: obj Indexed(L + S.length,Integer)" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "T"  E: "put(e):at[inx]" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:getAdr: "put(e):at[inx]" >ATd.off:0 (isPtn):on:0:superAdj:0"put(V: var integer):at[inx: var integer]: {   %basic 115":Adr:off:4 size:0 isFloat:F  ...} 
 -- $pattern:getAdr: "put(V: var integer):at[inx: var integer]: {   %basic 115" } 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "T" >staticOff:0 "T: obj Indexed(L + S.length,Integer)" superAdj:0 
 -- $obj:loadArgs: "T: obj Indexed(L + S.length,Integer)" >E:"T" 
 -- $pattern:loadArgs: "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];  ..."} 
 -- ptn:loadArgs:E "T" 
 -- {(ObjectInvocation_Unary; (name: "T"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "T" >rec:"T" ATd:"obj" E:"put(e):at[inx]" E.ATd:"put(V: var integer):at[inx: var integer]" unique:"False" 
 -- OI:invoke: "T" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- OI:invoke:B: "T" E: "put(e):at[inx]"  rec: "T"  useRtnV: true "T: obj Indexed(L + S.length,Integer)" 
 -- OI:invoke:before:ATdx.invoke: obj T 
 -- $obj:invoke: "T: obj Indexed(L + S.length,Integer)" E: "put(e):at[inx]">newOff:4 useRTNv: "True" 
 -- DI:invoke: "T: obj Indexed(L + S.length,Integer)" 
 -- >Object:unique: false 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- isCompositeValueObj: false E: "put(e):at[inx]" "put(V: var integer):at[inx: var integer]: {   %basic 115}" false 
 -- E.ATd.isValueObj: false rec: "T" 
 rpushg repeat$149$149 4
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- 
 -- OI:invoke:C: T :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "T" E: "put(e):at[inx]" 
 -- arg:other 
 -- computeAdr:isLast:E:  "put(e):at[inx]" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- rec:  "T" E:  "put(e):at[inx]" 
 -- INV:gen:E.loadArgs "put(e):at[inx]" 
 -- $ObjectInvocation_KeyWord:loadArgs: "put(e):at[inx]" >staticOff:0 "put(V: var integer):at[inx: var integer]: {   %basic 115" superAdj:0arg:"e"arg:"inx"} 
 -- $pattern:loadArgs: "put(V: var integer):at[inx: var integer]: {   %basic 115" >E:"put(e):at[inx]":descNo:93} 
 -- ptn:loadArgs:E "put(e):at[inx]" 
 -- {(ObjectInvocation_KeyWord; (name: "put:at"); (Arguments;  (name: "put");  (name: "(");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "e");      ...} 
 -- args: "put(e):at[inx]" 
 -- E: "ObjectGenerator" e 
 -- E: "ObjectGenerator" inx 
 -- E.arg: "var" V: var integer 
 -- NonVirt: "put(e):at[inx]" "ObjectInvocation_KeyWord" ActArg:  "e" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(e):at[inx]"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "e" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "e" 
 -- OG:before:super.gen: "e" 
 -- $Invocation:gen: "e" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "e" 
 -- isConstant: "Invocation" "e" 
 -- notConst: e e: var integer 
 -- needorigin: "e" 
 -- needOrigin:E: "e"  E.ATd: "e: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "e" 
 -- computeAdr: 1 :rec: "none"  E: "e" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "e"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "e" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$149" on: 2 isValueObj: false 
 -- origin: for:to:repeat$150 origin:isValueObj: false 
 rpushg repeat$149$149 1
 -- items:goOrigin:encOG: "for:to:repeat$150" on: 1 isValueObj: false 
 -- origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$150$150 4
 -- $ObjectInvocation_Unary:getAdr: "e" >ATd.off:2:on:2:superAdj:0"e: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "e: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "e: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "e"  ATd: "e: var integer" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- computeAdr:isLast:E:  "e" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- rec:  "e" E:  "e" 
 -- INV:gen:E.loadArgs "e" 
 -- $ObjectInvocation_Unary:loadArgs: "e" >staticOff:0 "e: var integer" superAdj:0 
 -- $var:loadArgs: "e: var integer" >E:"e" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "e" 
 -- {(ObjectInvocation_Unary; (name: "e"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "e" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "e" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- $ObjectInvocation_Unary:invoke: "e" >rec:"e" ATd:"var" isValueObj E:"e" E.ATd:"e" unique:"False" 
 -- OI:invoke: "e" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- OI:invoke:B: "e" E: "e"  rec: "e"  useRtnV: true "e: var integer" 
 -- OI:invoke:before:ATdx.invoke: var e 
 -- $var:invoke: "e: var integer" E: "e">newOff:2 useRTNv: "True" 
 -- DI:invoke: "e: var integer" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- isCompositeValueObj: false E: "e" "e: var integer" true 
 -- E.ATd.isValueObj: false rec: "e" 
 pushg 2 doplus$148
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -3 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- 
 -- OI:invoke:C: e :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- formalArg:isPtn: "V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "e" :isBasicVal: true 
 -- case:B: e ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "put(e):at[inx]" 
 -- E.arg: "var" inx: var integer 
 -- NonVirt: "put(e):at[inx]" "ObjectInvocation_KeyWord" ActArg:  "inx" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(e):at[inx]"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "inx" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inx" 
 -- OG:before:super.gen: "inx" 
 -- $Invocation:gen: "inx" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "inx" 
 -- isConstant: "Invocation" "inx" 
 -- notConst: inx inx: var integer 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$149" on: 1 isValueObj: false 
 -- origin: for:to:repeat$150 origin:isValueObj: false 
 rpushg repeat$149$149 1
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:3:on:1:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- $ObjectInvocation_Unary:loadArgs: "inx" >staticOff:0 "inx: var integer" superAdj:0 
 -- $var:loadArgs: "inx: var integer" >E:"inx" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "inx" 
 -- {(ObjectInvocation_Unary; (name: "inx"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: "inx" >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:"inx" unique:"False" 
 -- OI:invoke: "inx" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx" E: "inx"  rec: "inx"  useRtnV: true "inx: var integer" 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: "inx: var integer" E: "inx">newOff:3 useRTNv: "True" 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- isCompositeValueObj: false E: "inx" "inx: var integer" true 
 -- E.ATd.isValueObj: false rec: "inx" 
 pushg 3 for:to:repeat$150$150
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -4 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 3 vTopMax: 3 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:C: inx :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- formalArg:isPtn: "inx: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "inx" :isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "put(e):at[inx]" 
 -- INV:gen:after:E.loadArgs "put(e):at[inx]" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(e):at[inx]" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e) ..." 
 -- $ObjectInvocation_KeyWord:invoke: "put(e):at[inx]" >rec:"T" ATd:"pattern" E:"put(e):at[inx]" E.ATd:"put(V: var integer):at[inx: var integer]" unique:"False" 
 -- OI:invoke: "put(e):at[inx]" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- OI:invoke:B: "put(e):at[inx]" E: "put(e):at[inx]"  rec: "T"  useRtnV: false "put(V: var integer):at[inx: var integer]: {   %basic 115}" 
 -- OI:invoke:before:ATdx.invoke: pattern put(V: var integer):at[inx: var integer] 
 -- $pattern:invoke: "put(V: var integer):at[inx: var integer]: {   %basic 115" E: "put(e):at[inx]" useRTNv: "False"} 
 -- ptn:invoke: "put(V: var integer):at[inx: var integer]" E: "put(e):at[inx]" ptnKind: 0 useRtnV: false 
 xstoreg  inx 1 0 1
 -- stack: rpop : vTop: 3 vTopMax: 3 rTop: -5 rTopMax: 0 V: 0 R: 
 -- stack: vpop : vTop: 1 vTopMax: 3 rTop: -5 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- 
 -- OI:invoke:C: put(e):at[inx] :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 150 
 -- Items:GenClass: for:to:repeat$150 descNo: 150 isValue: false 
 -- Items:GenClass: for:to:repeat$150 descNo: 28 isValue: false 
 -- Items:GenClass: for:to:repeat descNo: 21 isValue: false 

 CLASS for:to:repeat$150 150 4 doplus 148
 -- vdtTableCopy: I:1:28 V:2:29
 -- Store itemArgs:  
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- push:super.origin: 
 -- handleSuperArgs:E: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" theIS: "" 
 -- super.sig:none:superAdj: 4 
 -- $ObjectInvocation_KeyWord:loadArgs: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];" >staticOff:0 "for(first: var integer):to(last: var integer):repeat{repeat:< ..."} 
 -- $pattern:loadArgs: "for(first: var integer):to(last: var integer):repeat{repeat:< object}: {   %OSDvisibility skipInternal;   %globals inSub;   inx: var integer;   inx :=  ..."} 
 -- ptn:loadArgs:E "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- {(ObjectInvocation_KeyWord; (name: "for:to:repeat"); (Arguments;  (name: "for");  (name: "(");  (ObjectGenerator;   (Invocation;    (ConstLiteral 1));   (Items descNo: 0 o ...} 
 -- args: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- E: "ObjectGenerator" 1 
 -- E: "ObjectGenerator" L 
 -- E: "ObjectGenerator" e := get[inx]{   T.put(e):at[inx]} 
 -- E.arg: "var" first: var integer 
 -- NonVirt: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" "ObjectInvocation_KeyWord" ActArg:  "1" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=4 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 4 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 4 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "first: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "1" :isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- E.arg: "var" last: var integer 
 -- NonVirt: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" "ObjectInvocation_KeyWord" ActArg:  "L" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "L" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=4 
 -- OG:gen: "L" 
 -- OG:before:super.gen: "L" 
 -- $Invocation:gen: "L" >useRtnV:"True"superAdj: 4 
 -- INV:gen: "L" 
 -- isConstant: "Invocation" "L" 
 -- notConst: L L: var integer 
 -- needorigin: "L" 
 -- needOrigin:E: "L"  E.ATd: "L: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 4 "L" 
 -- computeAdr: 1 :rec: "none"  E: "L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L" >on:1 superAdj:4 isValueObj:"True" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 4 
 rpushg doplus$148 4
 -- items:goOrigin:encOG: "doplus" on: 1 isValueObj: false 
 -- origin: + origin:isValueObj: false 
 rpushg doplus$148 1
 -- $ObjectInvocation_Unary:getAdr: "L" >ATd.off:4:on:1:superAdj:4"L: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "L: var integer" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L: var integer" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "L"  ATd: "L: var integer" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdr:isLast:E:  "L" 
 -- IV:after:computeAdr:superAdj: 4 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- rec:  "L" E:  "L" 
 -- INV:gen:E.loadArgs "L" 
 -- $ObjectInvocation_Unary:loadArgs: "L" >staticOff:0 "L: var integer" superAdj:4 
 -- $var:loadArgs: "L: var integer" >E:"L" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "L" 
 -- {(ObjectInvocation_Unary; (name: "L"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L" >rec:"L" ATd:"var" isValueObj E:"L" E.ATd:"L" unique:"False" 
 -- OI:invoke: "L" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "L" E: "L"  rec: "L"  useRtnV: true "L: var integer" 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- $var:invoke: "L: var integer" E: "L">newOff:4 useRTNv: "True" 
 -- DI:invoke: "L: var integer" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- isCompositeValueObj: false E: "L" "L: var integer" true 
 -- E.ATd.isValueObj: false rec: "L" 
 pushg 4 +$147
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- OI:invoke:C: L :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- formalArg:isPtn: "last: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "L" :isBasicVal: true 
 -- case:B: L ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- args:  "repeat:< object" "e := get[inx]{   T.put(e):at[inx]}" for:to:repeat 
 -- hArgOrg:super: for:to:repeat 
 -- Store itemArgs:  
 -- last: var integer true 1 
 -- DI:store: "last" 
 pushThis 
 storeg integer$5 2
 -- first: var integer true 1 
 -- DI:store: "first" 
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- vdtAdd: inx=1 descInx=150 vDescInx=28 vdtTop: 2 
 -- $Property:gen: "%OSDvisibility skipInternal"  
 -- $Property:gen: "%globals inSub"  
 -- $var:gen: "inx: var integer"  
 -- DI:gen: "inx: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  inx 
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0
 -- Handle VB: "" E: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- vdtAdd: inx=2 descInx=150 vDescInx=149 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 151 
 -- Items:GenClass: repeat$151 descNo: 151 isValue: false 
 -- Items:GenClass: repeat$151 descNo: 21 isValue: false 

 CLASS repeat$151 151 1 for:to:repeat$152 152
 -- Store itemArgs: e := S.get[inx]{i := L + inx;T.put(e):at[i]} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=151 vDescInx=151 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "e := S.get[inx]" 
 -- $Assign:gen: "e := S.get[inx]"  
 -- assign: "e := S.get[inx]" 
 -- computeAdr:superAdj: 0 "e" 
 -- computeAdr: 1 :rec: "none"  E: "e" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "e"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "e" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$151" on: 2 isValueObj: false 
 -- origin: for:to:repeat$152 origin:isValueObj: false 
 rpushg repeat$151$151 1
 -- items:goOrigin:encOG: "for:to:repeat$152" on: 1 isValueObj: false 
 -- origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$152$152 4
 -- $ObjectInvocation_Unary:getAdr: "e" >ATd.off:2:on:2:superAdj:0"e: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "e: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "e: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "e"  ATd: "e: var integer" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- computeAdr:isLast:E:  "e" 
 -- AssignmentStatement:gen: "e := S.get[inx]" right.label: "ObjectGenerator" "S.get[inx]" 
 -- $ObjectGenerator:gen: "S.get[inx]" >OGid:"get" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "S.get[inx]" 
 -- OG:before:super.gen: "S.get[inx]" 
 -- $Invocation:gen: "S.get[inx]" >useRtnV:"True"superAdj: 0 descNo: 16 
 -- INV:gen: "S.get[inx]" 
 -- isConstant: "Invocation" "S.get[inx]" 
 -- notConst: S in S: var String 
 -- needorigin: "S.get[inx]" 
 -- needOrigin:E: "get[inx]"  E.ATd: "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- doNeedOrigin:Ex: "get[inx]" 
 -- computeAdr:superAdj: 0 "S.get[inx]" 
 -- computeAdr: 1 :rec: "none"  E: "S" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "S"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "S" >on:3 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$151" on: 3 isValueObj: false 
 -- origin: for:to:repeat$152 origin:isValueObj: false 
 rpushg repeat$151$151 1
 -- items:goOrigin:encOG: "for:to:repeat$152" on: 2 isValueObj: false 
 -- origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$152$152 4
 -- items:goOrigin:encOG: "doplus" on: 1 isValueObj: false 
 -- origin: + origin:isValueObj: false 
 rpushg doplus$148 1
 -- $ObjectInvocation_Unary:getAdr: "S" >ATd.off:2:on:3:superAdj:0"in S: var String":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- PING:String 0 e := S.get[inx]{   i := L + inx;   T.put(e):at[i]} 
 -- BOBS:ATd: "in S: var String" 
 -- Is not: in Veq: var this(Value) 
 -- $var:getAdr: "in S: var String" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- E.on: 3 
 -- beforeIsValueObj:E: "S"  ATd: "in S: var String" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "S"  E: "get[inx]" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:getAdr: "get[inx]" >ATd.off:0 (isPtn):on:0:superAdj:0"get[inx: var integer]: {   %basic 117;   out ch: var char":Adr:off:2 size:0 isFloat:F isUni ...} 
 -- $pattern:getAdr: "get[inx: var integer]: {   %basic 117;   out ch: var char" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "S" >staticOff:0 "in S: var String" superAdj:0 
 -- $var:loadArgs: "in S: var String" >E:"S" 
 -- $pattern:loadArgs: "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- actu ..."} 
 -- ptn:loadArgs:E "S" 
 -- {(ObjectInvocation_Unary; (name: "S"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "S" >rec:"S" ATd:"var" E:"get[inx]" E.ATd:"get[inx: var integer]" unique:"False" 
 -- OI:invoke: "S" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- OI:invoke:B: "S" E: "get[inx]"  rec: "S"  useRtnV: true "in S: var String" 
 -- OI:invoke:before:ATdx.invoke: var S 
 -- $var:invoke: "in S: var String" E: "get[inx]">newOff:2 useRTNv: "True" 
 -- DI:invoke: "in S: var String" 
 -- >Object:unique: false 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- isCompositeValueObj: false E: "get[inx]" "get[inx: var integer]: {   %basic 117;   out ch: var char}" false 
 -- E.ATd.isValueObj: false rec: "S" 
 rpushg repeat$151$151 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- 
 -- OI:invoke:C: S :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "S" E: "get[inx]" 
 -- arg:other 
 -- computeAdr:isLast:E:  "get[inx]" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- rec:  "S" E:  "get[inx]" 
 -- INV:gen:E.loadArgs "get[inx]" 
 -- $ObjectInvocation_KeyWord:loadArgs: "get[inx]" >staticOff:0 "get[inx: var integer]: {   %basic 117;   out ch: var char" superAdj:0arg:"inx"} 
 -- $pattern:loadArgs: "get[inx: var integer]: {   %basic 117;   out ch: var char" >E:"get[inx]":descNo:16} 
 -- ptn:loadArgs:E "get[inx]" 
 -- {(ObjectInvocation_KeyWord; (name: "get"); (Arguments;  (name: "get");  (name: "[");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "inx");     ( ...} 
 -- args: "get[inx]" 
 -- E: "ObjectGenerator" inx 
 -- E.arg: "var" inx: var integer 
 -- NonVirt: "get[inx]" "ObjectInvocation_KeyWord" ActArg:  "inx" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx]"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "inx" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inx" 
 -- OG:before:super.gen: "inx" 
 -- $Invocation:gen: "inx" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "inx" 
 -- isConstant: "Invocation" "inx" 
 -- notConst: inx inx: var integer 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$151" on: 1 isValueObj: false 
 -- origin: for:to:repeat$152 origin:isValueObj: false 
 rpushg repeat$151$151 1
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:3:on:1:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- $ObjectInvocation_Unary:loadArgs: "inx" >staticOff:0 "inx: var integer" superAdj:0 
 -- $var:loadArgs: "inx: var integer" >E:"inx" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "inx" 
 -- {(ObjectInvocation_Unary; (name: "inx"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: "inx" >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:"inx" unique:"False" 
 -- OI:invoke: "inx" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx" E: "inx"  rec: "inx"  useRtnV: true "inx: var integer" 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: "inx: var integer" E: "inx">newOff:3 useRTNv: "True" 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- isCompositeValueObj: false E: "inx" "inx: var integer" true 
 -- E.ATd.isValueObj: false rec: "inx" 
 pushg 3 for:to:repeat$152$152
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:C: inx :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- formalArg:isPtn: "inx: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "inx" :isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "get[inx]" 
 -- INV:gen:after:E.loadArgs "get[inx]" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx]" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec ... 
 -- $ObjectInvocation_KeyWord:invoke: "get[inx]" >rec:"S" ATd:"pattern" E:"get[inx]" E.ATd:"get[inx: var integer]" unique:"False" 
 -- OI:invoke: "get[inx]" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- OI:invoke:B: "get[inx]" E: "get[inx]"  rec: "S"  useRtnV: true "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- $pattern:invoke: "get[inx: var integer]: {   %basic 117;   out ch: var char" E: "get[inx]" useRTNv: "True"} 
 -- ptn:invoke: "get[inx: var integer]" E: "get[inx]" ptnKind: 0 useRtnV: true 
 xpushg  inx 1 0 1
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpop : vTop: 0 vTopMax: 1 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- 
 -- OI:invoke:C: get[inx] :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- rec: "e" dstE: "e" dstE.ATd: "e: var integer" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right: "S.get[inx]" 
 -- isArgOfAssignI2IwithUniValArg "e := S.get[inx]" arg: "S.get[inx]" ObjectGenerator 
 -- arg.super.arg: "S" ObjectInvocation_Unary 
 -- arg.super.arg: "get[inx]" ObjectInvocation_KeyWord 
 -- recx: "S" argx: "get[inx]" 
 -- checkInt2IntWithUnitArg:rec: "S" E: "get[inx]" 
 -- arg:other 
 -- dstDI: "e: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg doplus$148 2
 -- assign:adr.store:B: 
 -- genclass:stmt: "i := L + inx" 
 -- $Assign:gen: "i := L + inx"  
 -- assign: "i := L + inx" 
 -- computeAdr:superAdj: 0 "i" 
 -- computeAdr: 1 :rec: "none"  E: "i" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "i"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "i" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$151" on: 2 isValueObj: false 
 -- origin: for:to:repeat$152 origin:isValueObj: false 
 rpushg repeat$151$151 1
 -- items:goOrigin:encOG: "for:to:repeat$152" on: 1 isValueObj: false 
 -- origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$152$152 4
 -- $ObjectInvocation_Unary:getAdr: "i" >ATd.off:3:on:2:superAdj:0"i: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "i: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "i: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "i"  ATd: "i: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- computeAdr:isLast:E:  "i" 
 -- AssignmentStatement:gen: "i := L + inx" right.label: "ObjectGenerator" "L + inx" 
 -- $ObjectGenerator:gen: "L + inx" >OGid:"+" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L + inx" 
 -- OG:before:super.gen: "L + inx" 
 -- $Invocation:gen: "L + inx" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L + inx" 
 -- isConstant: "Invocation" "L + inx" 
 -- needorigin: "L + inx" 
 -- needOrigin:E: "L + inx"  E.ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- doNeedOrigin:Ex: "L + inx" 
 -- computeAdr:superAdj: 0 "L + inx" 
 -- computeAdr: 1 :rec: "none"  E: "L + inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "L + inx"  
 -- $BinOp:loadOrigin: "L + inx"  
 -- BinaryExp:loadOrigin:empty: "L + inx" superAdj: 0 
 -- $BinOp:getAdr: "L + inx"  
 -- E.on: 3 
 -- beforeIsValueObj:E: "L + inx"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "L + inx" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "L + inx" E:  "L + inx" 
 -- INV:gen:E.loadArgs "L + inx" 
 -- $BinOp:loadArgs: "L + inx"  
 -- BinaryExp:loadArgs: "L + inx" superAdj: 0 
 -- $Invocation:gen: "L" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L" 
 -- isConstant: "Invocation" "L" 
 -- notConst: L L: var integer 
 -- needorigin: "L" 
 -- needOrigin:E: "L"  E.ATd: "L: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L" 
 -- computeAdr: 1 :rec: "none"  E: "L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L" >on:3 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$151" on: 3 isValueObj: false 
 -- origin: for:to:repeat$152 origin:isValueObj: false 
 rpushg repeat$151$151 1
 -- items:goOrigin:encOG: "for:to:repeat$152" on: 2 isValueObj: false 
 -- origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$152$152 4
 -- items:goOrigin:encOG: "doplus" on: 1 isValueObj: false 
 -- origin: + origin:isValueObj: false 
 rpushg doplus$148 1
 -- $ObjectInvocation_Unary:getAdr: "L" >ATd.off:4:on:3:superAdj:0"L: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "L: var integer" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L: var integer" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 3 
 -- beforeIsValueObj:E: "L"  ATd: "L: var integer" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdr:isLast:E:  "L" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- rec:  "L" E:  "L" 
 -- INV:gen:E.loadArgs "L" 
 -- $ObjectInvocation_Unary:loadArgs: "L" >staticOff:0 "L: var integer" superAdj:0 
 -- $var:loadArgs: "L: var integer" >E:"L" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "L" 
 -- {(ObjectInvocation_Unary; (name: "L"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L" >rec:"L" ATd:"var" isValueObj E:"L" E.ATd:"L" unique:"False" 
 -- OI:invoke: "L" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "L" E: "L"  rec: "L"  useRtnV: true "L: var integer" 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- $var:invoke: "L: var integer" E: "L">newOff:4 useRTNv: "True" 
 -- DI:invoke: "L: var integer" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- isCompositeValueObj: false E: "L" "L: var integer" true 
 -- E.ATd.isValueObj: false rec: "L" 
 pushg 4 +$147
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -3 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- OI:invoke:C: L :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- left:#I "L + inx" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- $pattern:loadArgs: "+  : {   %basic 61;   in V: var integer;   out R: var integer" >E:"+ inx":descNo:49} 
 -- ptn:loadArgs:E "+ inx" 
 -- {(ObjectInvocation_Binary; (name: "+"); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "inx");     (Arguments)));   (Items descNo: 0  ...} 
 -- args: "inx" 
 -- E: "ObjectGenerator" inx 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "+ inx" "ObjectInvocation_Binary" ActArg:  "inx" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ inx"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "inx" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inx" 
 -- OG:before:super.gen: "inx" 
 -- $Invocation:gen: "inx" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "inx" 
 -- isConstant: "Invocation" "inx" 
 -- notConst: inx inx: var integer 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$151" on: 1 isValueObj: false 
 -- origin: for:to:repeat$152 origin:isValueObj: false 
 rpushg repeat$151$151 1
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:3:on:1:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- $ObjectInvocation_Unary:loadArgs: "inx" >staticOff:0 "inx: var integer" superAdj:0 
 -- $var:loadArgs: "inx: var integer" >E:"inx" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "inx" 
 -- {(ObjectInvocation_Unary; (name: "inx"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: "inx" >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:"inx" unique:"False" 
 -- OI:invoke: "inx" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx" E: "inx"  rec: "inx"  useRtnV: true "inx: var integer" 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: "inx: var integer" E: "inx">newOff:3 useRTNv: "True" 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- isCompositeValueObj: false E: "inx" "inx: var integer" true 
 -- E.ATd.isValueObj: false rec: "inx" 
 pushg 3 for:to:repeat$152$152
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -4 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 3 vTopMax: 3 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:C: inx :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "inx" :isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "+ inx" 
 -- BinaryExp:loadArgs:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:after:E.loadArgs "L + inx" 
 -- OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L + inx" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- $BinOp:invoke: "L + inx"  
 -- BinaryExp:invoke: "L" rec: "L + inx" 
 -- M: "+ inx" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- $ObjectInvocation_Binary:invoke: "+ inx" >rec:"L" ATd:"pattern" E:"+ inx" E.ATd:"+  " unique:"False" 
 -- OI:invoke: "+ inx" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- origin:isValueObj "integer" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "+ inx" E: "+ inx"  rec: "L"  useRtnV: true "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- $pattern:invoke: "+  : {   %basic 61;   in V: var integer;   out R: var integer" E: "+ inx" useRTNv: "True"} 
 -- ptn:invoke: "+  " E: "+ inx" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "L" E: "+ inx" 
 -- arg:other 
 plus
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ inx":rec:L 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ inx":rec:L 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: + inx :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "i" dstE: "i" dstE.ATd: "i: var integer" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "L + inx" 
 -- isArgOfAssignI2IwithUniValArg "i := L + inx" arg: "L + inx" ObjectGenerator 
 -- arg.super.arg: "L + inx" BinOp 
 -- recx:BinaryExp:recx: "L + inx" 
 -- M: "+ inx" label: "ObjectInvocation_Binary" M.ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- checkInt2IntWithUnitArg:rec: "L" E: "+ inx" 
 -- arg:other 
 -- M:arg: "inx" ObjectGenerator false 
 -- dstDI: "i: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg doplus$148 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "T.put(e):at[i]" 
 -- $ObjectGenerator:gen: "T.put(e):at[i]" >OGid:"put:at" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "T.put(e):at[i]" 
 -- OG:before:super.gen: "T.put(e):at[i]" 
 -- $Invocation:gen: "T.put(e):at[i]" >useRtnV:"False"superAdj: 0 descNo: 93 
 -- INV:gen: "T.put(e):at[i]" 
 -- isConstant: "Invocation" "T.put(e):at[i]" 
 -- needorigin: "T.put(e):at[i]" 
 -- needOrigin:E: "put(e):at[i]"  E.ATd: "put(V: var integer):at[inx: var integer]: {   %basic 115}" 
 -- doNeedOrigin:Ex: "put(e):at[i]" 
 -- computeAdr:superAdj: 0 "T.put(e):at[i]" 
 -- computeAdr: 1 :rec: "none"  E: "T" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "T"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "T" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$151" on: 2 isValueObj: false 
 -- origin: for:to:repeat$152 origin:isValueObj: false 
 rpushg repeat$151$151 1
 -- items:goOrigin:encOG: "for:to:repeat$152" on: 1 isValueObj: false 
 -- origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$152$152 4
 -- $ObjectInvocation_Unary:getAdr: "T" >ATd.off:4:on:2:superAdj:0"T: obj Indexed(L + S.length,Integer)":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- $obj:getAdr: "T: obj Indexed(L + S.length,Integer)" >newOff:4,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0  ... 
 -- E.on: 2 
 -- beforeIsValueObj:E: "T"  ATd: "T: obj Indexed(L + S.length,Integer)" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "T"  E: "put(e):at[i]" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:getAdr: "put(e):at[i]" >ATd.off:0 (isPtn):on:0:superAdj:0"put(V: var integer):at[inx: var integer]: {   %basic 115":Adr:off:4 size:0 isFloat:F is ...} 
 -- $pattern:getAdr: "put(V: var integer):at[inx: var integer]: {   %basic 115" } 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "T" >staticOff:0 "T: obj Indexed(L + S.length,Integer)" superAdj:0 
 -- $obj:loadArgs: "T: obj Indexed(L + S.length,Integer)" >E:"T" 
 -- $pattern:loadArgs: "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];  ..."} 
 -- ptn:loadArgs:E "T" 
 -- {(ObjectInvocation_Unary; (name: "T"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "T" >rec:"T" ATd:"obj" E:"put(e):at[i]" E.ATd:"put(V: var integer):at[inx: var integer]" unique:"False" 
 -- OI:invoke: "T" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- OI:invoke:B: "T" E: "put(e):at[i]"  rec: "T"  useRtnV: true "T: obj Indexed(L + S.length,Integer)" 
 -- OI:invoke:before:ATdx.invoke: obj T 
 -- $obj:invoke: "T: obj Indexed(L + S.length,Integer)" E: "put(e):at[i]">newOff:4 useRTNv: "True" 
 -- DI:invoke: "T: obj Indexed(L + S.length,Integer)" 
 -- >Object:unique: false 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- isCompositeValueObj: false E: "put(e):at[i]" "put(V: var integer):at[inx: var integer]: {   %basic 115}" false 
 -- E.ATd.isValueObj: false rec: "T" 
 rpushg repeat$151$151 4
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- 
 -- OI:invoke:C: T :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "T" E: "put(e):at[i]" 
 -- arg:other 
 -- computeAdr:isLast:E:  "put(e):at[i]" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- rec:  "T" E:  "put(e):at[i]" 
 -- INV:gen:E.loadArgs "put(e):at[i]" 
 -- $ObjectInvocation_KeyWord:loadArgs: "put(e):at[i]" >staticOff:0 "put(V: var integer):at[inx: var integer]: {   %basic 115" superAdj:0arg:"e"arg:"i"} 
 -- $pattern:loadArgs: "put(V: var integer):at[inx: var integer]: {   %basic 115" >E:"put(e):at[i]":descNo:93} 
 -- ptn:loadArgs:E "put(e):at[i]" 
 -- {(ObjectInvocation_KeyWord; (name: "put:at"); (Arguments;  (name: "put");  (name: "(");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "e");      ...} 
 -- args: "put(e):at[i]" 
 -- E: "ObjectGenerator" e 
 -- E: "ObjectGenerator" i 
 -- E.arg: "var" V: var integer 
 -- NonVirt: "put(e):at[i]" "ObjectInvocation_KeyWord" ActArg:  "e" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(e):at[i]"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "e" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "e" 
 -- OG:before:super.gen: "e" 
 -- $Invocation:gen: "e" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "e" 
 -- isConstant: "Invocation" "e" 
 -- notConst: e e: var integer 
 -- needorigin: "e" 
 -- needOrigin:E: "e"  E.ATd: "e: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "e" 
 -- computeAdr: 1 :rec: "none"  E: "e" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "e"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "e" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$151" on: 2 isValueObj: false 
 -- origin: for:to:repeat$152 origin:isValueObj: false 
 rpushg repeat$151$151 1
 -- items:goOrigin:encOG: "for:to:repeat$152" on: 1 isValueObj: false 
 -- origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$152$152 4
 -- $ObjectInvocation_Unary:getAdr: "e" >ATd.off:2:on:2:superAdj:0"e: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "e: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "e: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "e"  ATd: "e: var integer" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- computeAdr:isLast:E:  "e" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- rec:  "e" E:  "e" 
 -- INV:gen:E.loadArgs "e" 
 -- $ObjectInvocation_Unary:loadArgs: "e" >staticOff:0 "e: var integer" superAdj:0 
 -- $var:loadArgs: "e: var integer" >E:"e" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "e" 
 -- {(ObjectInvocation_Unary; (name: "e"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "e" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "e" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- $ObjectInvocation_Unary:invoke: "e" >rec:"e" ATd:"var" isValueObj E:"e" E.ATd:"e" unique:"False" 
 -- OI:invoke: "e" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- OI:invoke:B: "e" E: "e"  rec: "e"  useRtnV: true "e: var integer" 
 -- OI:invoke:before:ATdx.invoke: var e 
 -- $var:invoke: "e: var integer" E: "e">newOff:2 useRTNv: "True" 
 -- DI:invoke: "e: var integer" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- isCompositeValueObj: false E: "e" "e: var integer" true 
 -- E.ATd.isValueObj: false rec: "e" 
 pushg 2 doplus$148
 -- stack: rpop : vTop: 3 vTopMax: 3 rTop: -5 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 4 vTopMax: 4 rTop: -5 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- 
 -- OI:invoke:C: e :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- formalArg:isPtn: "V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "e" :isBasicVal: true 
 -- case:B: e ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "put(e):at[i]" 
 -- E.arg: "var" inx: var integer 
 -- NonVirt: "put(e):at[i]" "ObjectInvocation_KeyWord" ActArg:  "i" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(e):at[i]"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "i" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "i" 
 -- OG:before:super.gen: "i" 
 -- $Invocation:gen: "i" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "i" 
 -- isConstant: "Invocation" "i" 
 -- notConst: i i: var integer 
 -- needorigin: "i" 
 -- needOrigin:E: "i"  E.ATd: "i: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "i" 
 -- computeAdr: 1 :rec: "none"  E: "i" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "i"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "i" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$151" on: 2 isValueObj: false 
 -- origin: for:to:repeat$152 origin:isValueObj: false 
 rpushg repeat$151$151 1
 -- items:goOrigin:encOG: "for:to:repeat$152" on: 1 isValueObj: false 
 -- origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$152$152 4
 -- $ObjectInvocation_Unary:getAdr: "i" >ATd.off:3:on:2:superAdj:0"i: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "i: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "i: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "i"  ATd: "i: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- computeAdr:isLast:E:  "i" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- rec:  "i" E:  "i" 
 -- INV:gen:E.loadArgs "i" 
 -- $ObjectInvocation_Unary:loadArgs: "i" >staticOff:0 "i: var integer" superAdj:0 
 -- $var:loadArgs: "i: var integer" >E:"i" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "i" 
 -- {(ObjectInvocation_Unary; (name: "i"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "i" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "i" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- $ObjectInvocation_Unary:invoke: "i" >rec:"i" ATd:"var" isValueObj E:"i" E.ATd:"i" unique:"False" 
 -- OI:invoke: "i" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- OI:invoke:B: "i" E: "i"  rec: "i"  useRtnV: true "i: var integer" 
 -- OI:invoke:before:ATdx.invoke: var i 
 -- $var:invoke: "i: var integer" E: "i">newOff:3 useRTNv: "True" 
 -- DI:invoke: "i: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- isCompositeValueObj: false E: "i" "i: var integer" true 
 -- E.ATd.isValueObj: false rec: "i" 
 pushg 3 doplus$148
 -- stack: rpop : vTop: 4 vTopMax: 4 rTop: -6 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 5 vTopMax: 5 rTop: -6 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- 
 -- OI:invoke:C: i :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- formalArg:isPtn: "inx: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "i" :isBasicVal: true 
 -- case:B: i ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "put(e):at[i]" 
 -- INV:gen:after:E.loadArgs "put(e):at[i]" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(e):at[i]" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):a ..." 
 -- $ObjectInvocation_KeyWord:invoke: "put(e):at[i]" >rec:"T" ATd:"pattern" E:"put(e):at[i]" E.ATd:"put(V: var integer):at[inx: var integer]" unique:"False" 
 -- OI:invoke: "put(e):at[i]" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- OI:invoke:B: "put(e):at[i]" E: "put(e):at[i]"  rec: "T"  useRtnV: false "put(V: var integer):at[inx: var integer]: {   %basic 115}" 
 -- OI:invoke:before:ATdx.invoke: pattern put(V: var integer):at[inx: var integer] 
 -- $pattern:invoke: "put(V: var integer):at[inx: var integer]: {   %basic 115" E: "put(e):at[i]" useRTNv: "False"} 
 -- ptn:invoke: "put(V: var integer):at[inx: var integer]" E: "put(e):at[i]" ptnKind: 0 useRtnV: false 
 xstoreg  inx 1 0 1
 -- stack: rpop : vTop: 5 vTopMax: 5 rTop: -7 rTopMax: 0 V: 0 R: 
 -- stack: vpop : vTop: 3 vTopMax: 5 rTop: -7 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- 
 -- OI:invoke:C: put(e):at[i] :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 152 
 -- Items:GenClass: for:to:repeat$152 descNo: 152 isValue: false 
 -- Items:GenClass: for:to:repeat$152 descNo: 28 isValue: false 
 -- Items:GenClass: for:to:repeat descNo: 21 isValue: false 

 CLASS for:to:repeat$152 152 4 doplus 148
 -- vdtTableCopy: I:1:28 V:2:29
 -- Store itemArgs:  
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- push:super.origin: 
 -- handleSuperArgs:E: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" theIS: "" 
 -- super.sig:none:superAdj: 4 
 -- $ObjectInvocation_KeyWord:loadArgs: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];" >staticOff:0 "for(first: var integer):to(last: var i ..."} 
 -- $pattern:loadArgs: "for(first: var integer):to(last: var integer):repeat{repeat:< object}: {   %OSDvisibility skipInternal;   %globals inSub;   inx: var integer;   inx :=  ..."} 
 -- ptn:loadArgs:E "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- {(ObjectInvocation_KeyWord; (name: "for:to:repeat"); (Arguments;  (name: "for");  (name: "(");  (ObjectGenerator;   (Invocation;    (ConstLiteral 1));   (Items descNo: 0 o ...} 
 -- args: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- E: "ObjectGenerator" 1 
 -- E: "ObjectGenerator" S.length 
 -- E: "ObjectGenerator" e := S.get[inx]{   i := L + inx;   T.put(e):at[i]} 
 -- E.arg: "var" first: var integer 
 -- NonVirt: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" "ObjectInvocation_KeyWord" ActArg:  "1" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=4 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 4 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 4 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "first: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "1" :isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- E.arg: "var" last: var integer 
 -- NonVirt: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" "ObjectInvocation_KeyWord" ActArg:  "S.length" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "S.length" >OGid:"length" IS.isempty! staticOff=0 descNo=0 superAdj=4 
 -- OG:gen: "S.length" 
 -- OG:before:super.gen: "S.length" 
 -- $Invocation:gen: "S.length" >useRtnV:"True"superAdj: 4 descNo: 15 
 -- INV:gen: "S.length" 
 -- isConstant: "Invocation" "S.length" 
 -- notConst: S in S: var String 
 -- needorigin: "S.length" 
 -- needOrigin:E: "length"  E.ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- doNeedOrigin:Ex: "length" 
 -- computeAdr:superAdj: 4 "S.length" 
 -- computeAdr: 1 :rec: "none"  E: "S" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "S"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "S" >on:1 superAdj:4 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 4 
 rpushg doplus$148 4
 -- items:goOrigin:encOG: "doplus" on: 1 isValueObj: false 
 -- origin: + origin:isValueObj: false 
 rpushg doplus$148 1
 -- $ObjectInvocation_Unary:getAdr: "S" >ATd.off:2:on:1:superAdj:4"in S: var String":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- PING:String 0 e: var integer{   i: var integer;   T: obj Indexed(L + S.length,Integer);   for(1):to(L):repeat;      e := get[inx];      T.put(e):at[inx];   ;   for(1):to(S ...} 
 -- BOBS:ATd: "in S: var String" 
 -- Is not: in Veq: var this(Value) 
 -- $var:getAdr: "in S: var String" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "S"  ATd: "in S: var String" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "S"  E: "length" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "length" >ATd.off:0 (isPtn):on:0:superAdj:0"length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length":Adr ...} 
 -- $pattern:getAdr: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "S" >staticOff:0 "in S: var String" superAdj:4 
 -- $var:loadArgs: "in S: var String" >E:"S" 
 -- $pattern:loadArgs: "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- actu ..."} 
 -- ptn:loadArgs:E "S" 
 -- {(ObjectInvocation_Unary; (name: "S"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "S" >rec:"S" ATd:"var" E:"length" E.ATd:"length" unique:"False" 
 -- OI:invoke: "S" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:B: "S" E: "length"  rec: "S"  useRtnV: true "in S: var String" 
 -- OI:invoke:before:ATdx.invoke: var S 
 -- $var:invoke: "in S: var String" E: "length">newOff:2 useRTNv: "True" 
 -- DI:invoke: "in S: var String" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 rpushg doplus$148 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- 
 -- OI:invoke:C: S :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "S" E: "length" 
 -- computeAdr:isLast:E:  "length" 
 -- IV:after:computeAdr:superAdj: 4 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- rec:  "S" E:  "length" 
 -- INV:gen:E.loadArgs "length" 
 -- $ObjectInvocation_Unary:loadArgs: "length" >staticOff:0 "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" superAdj:4} 
 -- $pattern:loadArgs: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" >E:"length":descNo:15} 
 -- ptn:loadArgs:E "length" 
 -- {(ObjectInvocation_Unary; (name: "length"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "length" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- $ObjectInvocation_Unary:invoke: "length" >rec:"S" ATd:"pattern" E:"length" E.ATd:"length" unique:"False" 
 -- OI:invoke: "length" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:B: "length" E: "length"  rec: "S"  useRtnV: true "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- $pattern:invoke: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" E: "length" useRTNv: "True"} 
 -- ptn:invoke: "length" E: "length" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:C: length :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- formalArg:isPtn: "last: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "S.length" :isBasicVal: true 
 -- case:B: S.length ObjectGenerator 1 0 0 false false 
 -- end:loadArgs:NonVirt: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- args:  "repeat:< object" "e := S.get[inx]{   i := L + inx;   T.put(e):at[i]}" for:to:repeat 
 -- hArgOrg:super: for:to:repeat 
 -- Store itemArgs:  
 -- last: var integer true 1 
 -- DI:store: "last" 
 pushThis 
 storeg integer$5 2
 -- first: var integer true 1 
 -- DI:store: "first" 
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- vdtAdd: inx=1 descInx=152 vDescInx=28 vdtTop: 2 
 -- $Property:gen: "%OSDvisibility skipInternal"  
 -- $Property:gen: "%globals inSub"  
 -- $var:gen: "inx: var integer"  
 -- DI:gen: "inx: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  inx 
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0
 -- Handle VB: "" E: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- vdtAdd: inx=2 descInx=152 vDescInx=151 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 153 
 -- Items:GenClass: asString descNo: 153 isValue: false 
 -- Items:GenClass: asString descNo: 21 isValue: false 

 CLASS asString 153 1 Indexed 86
 -- Store itemArgs: %basic 118{out S: var LIB.StringLib.String} 
 -- Store:Origin: 114 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=153 vDescInx=153 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%basic 118"  
 -- $var:gen: "out S: var LIB.StringLib.String"  
 -- DI:gen: "out S: var LIB.StringLib.String" DI:isConst: false :isBasicValue: false :primNo: 5 
 -- StringVar "out S: var LIB.StringLib.String" 
 pushText ""
 pushThis 
 rstoreg  S 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 1 V: R: 
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%basic 118" 
 -- $Property:gen: "%basic 118"  
 L2:
 -- pushReturn:  "asString" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 107 
 -- Items:GenClass: $107 descNo: 107 isValue: false 
 -- Items:GenClass: $107 descNo: 21 isValue: false 

 CLASS $107 107 1 entry 95
 -- Store itemArgs: put('V') 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=107 vDescInx=107 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "put('V')" 
 -- $ObjectGenerator:gen: "put('V')" >OGid:"put" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "put('V')" 
 -- OG:before:super.gen: "put('V')" 
 -- $Invocation:gen: "put('V')" >useRtnV:"False"superAdj: 0 descNo: 105 
 -- INV:gen: "put('V')" 
 -- isConstant: "Invocation" "put('V')" 
 -- needorigin: "put('V')" 
 -- needOrigin:E: "put('V')"  E.ATd: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- Ex:loadOrign:no:loadOrigin:  "-- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "put('V')" E:  "put('V')" 
 -- INV:gen:E.loadArgs "put('V')" 
 -- $ObjectInvocation_KeyWord:loadArgs: "put('V')" >staticOff:0 "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char" superAdj:0arg:"'V'"} 
 -- $pattern:loadArgs: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char" >E:"put('V')":descNo:105} 
 -- ptn:loadArgs:E "put('V')" 
 -- {(ObjectInvocation_KeyWord; (name: "put"); (Arguments;  (name: "put");  (name: "(");  (ObjectGenerator;   (Invocation;    (Char: 'V'));   (Items descNo: 0 origDescNo: 0)); ...} 
 -- args: "put('V')" 
 -- E: "ObjectGenerator" 'V' 
 -- E.arg: "val" in ch: val char 
 -- NonVirt: "put('V')" "ObjectInvocation_KeyWord" ActArg:  "'V'" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put('V')"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "'V'" >OGid:"char" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "'V'" 
 -- OG:before:super.gen: "'V'" 
 -- $Invocation:gen: "'V'" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "'V'" 
 -- isConstant: "Invocation" "'V'" 
 -- needorigin: "'V'" 
 -- needOrigin:E: "'V'"  E.ATd: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var ch ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;   ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "'V'" E:  "'V'" 
 -- INV:gen:E.loadArgs "'V'" 
 -- $Char::loadArgs: "'V'"  
 -- INV:gen:after:E.loadArgs "'V'" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "'V'" 
 -- $Char::invoke: "'V'"  
 pushc 86
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in ch: val char" :isBasicVal: true :valueObj: true 
 -- :actArg: "'V'" :isBasicVal: true 
 -- case:B: 'V' ObjectGenerator 3 3 3 false true 
 -- end:loadArgs:NonVirt: "put('V')" 
 -- INV:gen:after:E.loadArgs "put('V')" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put('V')" 
 -- $ObjectInvocation_KeyWord:invoke: "put('V')" >rec:"put('V')" ATd:"pattern" E:"put('V')" E.ATd:"put" unique:"False" 
 -- OI:invoke: "put('V')" 
 -- 
 -- OI:invoke:B: "put('V')" E: "put('V')"  rec: "put('V')"  useRtnV: false "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- $pattern:invoke: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char" E: "put('V')" useRTNv: "False"} 
 -- ptn:invoke: "put" E: "put('V')" ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- OI:invoke:C: put('V') :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 109 
 -- Items:GenClass: free descNo: 109 isValue: false 
 -- Items:GenClass: free descNo: 21 isValue: false 

 CLASS free 109 1 Lock 76
 -- Store itemArgs: free_M := 0 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=109 vDescInx=109 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "free_M := 0" 
 -- $Assign:gen: "free_M := 0"  
 -- assign: "free_M := 0" 
 -- computeAdr:superAdj: 0 "free_M" 
 -- computeAdr: 1 :rec: "none"  E: "free_M" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "free_M"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "free_M" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "free" on: 1 isValueObj: false 
 -- origin: Lock origin:isValueObj: false 
 rpushg free$109 1
 -- $ObjectInvocation_Unary:getAdr: "free_M" >ATd.off:2:on:1:superAdj:0"free_M: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVal ... 
 -- $var:getAdr: "free_M: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F  ... 
 -- DI:OG: integer 
 -- before:floatTest:  "free_M: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"free_M":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"free_M":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "free_M"  ATd: "free_M: var integer" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"free_M":rec:- 
 -- computeAdr:isLast:E:  "free_M" 
 -- AssignmentStatement:gen: "free_M := 0" right.label: "ObjectGenerator" "0" 
 -- $ObjectGenerator:gen: "0" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "0" 
 -- OG:before:super.gen: "0" 
 -- $Invocation:gen: "0" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "0" 
 -- isConstant: "Invocation" "0" 
 -- needorigin: "0" 
 -- needOrigin:E: "0"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "0" E:  "0" 
 -- INV:gen:E.loadArgs "0" 
 -- $ConstLiteral:loadArgs: "0"  
 -- INV:gen:after:E.loadArgs "0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0" 
 -- $ConstLiteral:invoke: "0"  
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "free_M" dstE: "free_M" dstE.ATd: "free_M: var integer" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"free_ ..." 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "0" 
 -- isArgOfAssignI2IwithUniValArg "free_M := 0" arg: "0" ObjectGenerator 
 -- arg.super.arg: "0" ConstLiteral 
 -- dstDI: "free_M: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"free_M":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg Lock$76 2
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  "free" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 139 
 -- Items:GenClass: insert descNo: 139 isValue: false 
 -- Items:GenClass: insert descNo: 95 isValue: false 
 -- Items:GenClass: entry descNo: 21 isValue: false 

 CLASS insert 139 1 SQS 77
 -- vdtTableCopy: I:1:95 I:2:0
 -- vdtAdd: inx=2 descInx=139 vDescInx=139 vdtTop: 2 
 -- Store itemArgs: in P: ref BasicProcess{if (Q.has(P).not) :then ;   Q.insert(P)} 
 -- in P: ref BasicProcess true 0 
 -- DI:store: "P" 
 pushThis 
 rstoreg  P 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 -- super entry
 -- push:super.origin: 
 -- computeAdr:superAdj: 1 "entry" 
 -- computeAdr: 1 :rec: "none"  E: "entry" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "entry"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "entry" >on:0 superAdj:1 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 1 
 rpushg SQS$77 1
 -- $ObjectInvocation_Unary:getAdr: "entry" >ATd.off:0 (isPtn):on:0:superAdj:1"entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1 ..."} 
 -- $pattern:getAdr: "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"entry":rec:- 
 -- E.on: 0 
 -- beforeIsValueObj:E: "entry"  ATd: "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"entry":rec:- 
 -- computeAdr:isLast:E:  "entry" 
 -- genClass:after:pushAddress: "entry" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"entry":rec:- 
 -- handleSuperArgs:E: "entry" theIS: "in P: ref BasicProcess{if (Q.has(P).not) :then ;   Q.insert(P)}" 
 -- super.sig:not:none:superAdj: -1 
 -- $ObjectInvocation_Unary:loadArgs: "entry" >staticOff:0 "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free" superAd ...} 
 -- $pattern:loadArgs: "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free" >E:"entry":descNo:95} 
 -- ptn:loadArgs:E "entry" 
 -- {(ObjectInvocation_Unary; (name: "entry"); (Arguments))} 
 -- args: "" 
 -- hArgOrg:super: entry 
 -- Store itemArgs: in P: ref BasicProcess{if (Q.has(P).not) :then ;   Q.insert(P)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=139 vDescInx=95 vdtTop: 2 
 -- $ref:gen: "in P: ref BasicProcess"  
 -- DI:gen: "in P: ref BasicProcess" DI:isConst: false :isBasicValue: false :primNo: 0 
 rtnAlloc 1
 toSuper 95
DO:
 mvStack 
 L1:
 -- genclass:stmt: "if (Q.has(P).not) :then {   Q.insert(P)}" 
 -- $ObjectGenerator:gen: "if (Q.has(P).not) :then {   Q.insert(P)" >OGid:"if:then$0" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "if (Q.has(P).not) :then {   Q.insert(P)}" 
 -- OG:before:super.gen: "if (Q.has(P).not) :then {   Q.insert(P)}" 
 -- $Invocation:gen: "if (Q.has(P).not) :then {   Q.insert(P)" >useRtnV:"False"superAdj: 0} 
 -- INV:gen: "if (Q.has(P).not) :then {   Q.insert(P)}" 
 -- isConstant: "Invocation" "if (Q.has(P).not) :then {   Q.insert(P)}" 
 -- needorigin: "if (Q.has(P).not) :then {   Q.insert(P)}" 
 -- needOrigin:E: "if (Q.has(P).not) :then {   Q.insert(P)}"  E.ATd: "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (Q.has(P).not) :then {   Q.insert(P)}" E:  "if (Q.has(P).not) :then {   Q.insert(P)}" 
 -- INV:gen:E.loadArgs "if (Q.has(P).not) :then {   Q.insert(P)}" 
 -- $IfThen:loadArgs: "if (Q.has(P).not) :then {   Q.insert(P)" } 
 -- INV:gen:after:E.loadArgs "if (Q.has(P).not) :then {   Q.insert(P)}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (Q.has(P).not) :then {   Q.insert(P)}" 
 -- $IfThen:invoke: "if (Q.has(P).not) :then {   Q.insert(P)" } 
 -- $IfThen:gen: "if (Q.has(P).not) :then {   Q.insert(P)" } 
 -- $ObjectGenerator:gen: "(Q.has(P).not)" >OGid:"not" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(Q.has(P).not)" 
 -- OG:before:super.gen: "(Q.has(P).not)" 
 -- $Invocation:gen: "(Q.has(P).not)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(Q.has(P).not)" 
 -- isConstant: "Invocation" "(Q.has(P).not)" 
 -- needorigin: "(Q.has(P).not)" 
 -- needOrigin:E: "(Q.has(P).not)"  E.ATd: "not: {   %basic 65;   out R: var boolean}" 
 -- doNeedOrigin:Ex: "(Q.has(P).not)" 
 -- computeAdr:superAdj: 0 "(Q.has(P).not)" 
 -- computeAdr: 1 :rec: "none"  E: "(Q.has(P).not)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(Q.has(P).not)"  
 -- $BracketedExp:loadOrigin: "(Q.has(P).not)"  
 -- computeAdr:superAdj: 0 "Q.has(P).not" 
 -- computeAdr: 1 :rec: "none"  E: "Q" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Q"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Q" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "insert" on: 1 isValueObj: false 
 -- origin: SQS origin:isValueObj: false 
 rpushg insert$139 1
 -- $ObjectInvocation_Unary:getAdr: "Q" >ATd.off:2:on:1:superAdj:0"Q: obj ProcessQueue":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F: ... 
 -- $obj:getAdr: "Q: obj ProcessQueue" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValu ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "Q"  ATd: "Q: obj ProcessQueue" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "Q"  E: "has(P)" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:getAdr: "has(P)" >ATd.off:0 (isPtn):on:0:superAdj:0"has: {   in elm: ref Object;   out B: var Boolean;   scan;      if (elm == current) :then ;   ..."} 
 -- $pattern:getAdr: "has: {   in elm: ref Object;   out B: var Boolean;   scan;      if (elm == current) :then ;         --"Queue:has:elm\n".printB := true;         leave(has ..."} 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"has(P)":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "Q" >staticOff:0 "Q: obj ProcessQueue" superAdj:0 
 -- $obj:loadArgs: "Q: obj ProcessQueue" >E:"Q" 
 -- $pattern:loadArgs: "ProcessQueue: LIB.Collections.QueueLib.Queue{   %Public;   displayx: ;      put('Q')" >E:"Q":descNo:79} 
 -- ptn:loadArgs:E "Q" 
 -- {(ObjectInvocation_Unary; (name: "Q"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "Q" >rec:"Q" ATd:"obj" E:"has(P)" E.ATd:"has" unique:"False" 
 -- OI:invoke: "Q" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"has(P)":rec:Q 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"has(P)":rec:Q 
 -- OI:invoke:B: "Q" E: "has(P)"  rec: "Q"  useRtnV: true "Q: obj ProcessQueue" 
 -- OI:invoke:before:ATdx.invoke: obj Q 
 -- $obj:invoke: "Q: obj ProcessQueue" E: "has(P)">newOff:2 useRTNv: "True" 
 -- DI:invoke: "Q: obj ProcessQueue" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"has(P)":rec:Q 
 rpushg insert$139 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"has(P)":rec:Q 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"has(P)":rec:Q 
 -- 
 -- OI:invoke:C: Q :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "Q" E: "has(P)" 
 -- arg:other 
 -- computeAdr: 3 :rec: "has(P)"  E: "not"  A.E: "has(P)" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"has(P)":rec:Q 
 -- $ObjectInvocation_Unary:getAdr: "not" >ATd.off:0 (isPtn):on:0:superAdj:0"not: {   %basic 65;   out R: var boolean":Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUniq ...} 
 -- $pattern:getAdr: "not: {   %basic 65;   out R: var boolean" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"has(P)":rec:Q 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_KeyWord:loadArgs: "has(P)" >staticOff:0 "has: {   in elm: ref Object;   out B: var Boolean;   scan;      if (elm == current) :then ;         --"Queue:has ...} 
 -- $pattern:loadArgs: "has: {   in elm: ref Object;   out B: var Boolean;   scan;      if (elm == current) :then ;         --"Queue:has:elm\n".printB := true;         leave(h ..."} 
 -- ptn:loadArgs:E "has(P)" 
 -- {(ObjectInvocation_KeyWord; (name: "has"); (Arguments;  (name: "has");  (name: "(");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "P");     (Ar ...} 
 -- args: "has(P)" 
 -- E: "ObjectGenerator" P 
 -- E.arg: "ref" in elm: ref Object 
 -- NonVirt: "has(P)" "ObjectInvocation_KeyWord" ActArg:  "P" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "has(P)"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "P" >OGid:"BasicProcess" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "P" 
 -- OG:before:super.gen: "P" 
 -- $Invocation:gen: "P" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "P" 
 -- isConstant: "Invocation" "P" 
 -- notConst: P in P: ref BasicProcess 
 -- needorigin: "P" 
 -- needOrigin:E: "P"  E.ATd: "in P: ref BasicProcess" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "P" 
 -- computeAdr: 1 :rec: "none"  E: "P" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "P"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "P" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "P" >ATd.off:2:on:0:superAdj:0"in P: ref BasicProcess":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ... 
 -- $ref:getAdr: "in P: ref BasicProcess" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV ... 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "P" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "P" E:  "P" 
 -- INV:gen:E.loadArgs "P" 
 -- $ObjectInvocation_Unary:loadArgs: "P" >staticOff:0 "in P: ref BasicProcess" superAdj:0 
 -- $ref:loadArgs: "in P: ref BasicProcess" >E:"P" 
 -- $pattern:loadArgs: "BasicProcess: GeneralProcess{   mkActive::< ;      status := p_status.ACTIVE;      SQS.insert(this(BasicProcess));   %Public;   start::<  -- need id as ..."} 
 -- ptn:loadArgs:E "P" 
 -- {(ObjectInvocation_Unary; (name: "P"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "P" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "P" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "P" >rec:"P" ATd:"ref" E:"P" E.ATd:"P" unique:"False" 
 -- OI:invoke: "P" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:P 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:P 
 -- OI:invoke:B: "P" E: "P"  rec: "P"  useRtnV: true "in P: ref BasicProcess" 
 -- OI:invoke:before:ATdx.invoke: ref P 
 -- $ref:invoke: "in P: ref BasicProcess" E: "P">newOff:2 useRTNv: "True" 
 -- DI:invoke: "in P: ref BasicProcess" 
 -- >Object:unique: false 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"P":rec:P 
 -- isCompositeValueObj: false E: "P" "in P: ref BasicProcess" false 
 -- E.ATd.isValueObj: false rec: "P" 
 rpushg insert$139 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"P":rec:P 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"P":rec:P 
 -- 
 -- OI:invoke:C: P :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"P":rec:P 
 -- formalArg:isPtn: "in elm: ref Object" :isBasicVal: false :valueObj: false 
 -- :actArg: "P" :isBasicVal: false 
 -- case:B: P ObjectGenerator 64 0 0 false false 
 -- end:loadArgs:NonVirt: "has(P)" 
 -- $ObjectInvocation_KeyWord:invoke: "has(P)" >rec:"Q" ATd:"pattern" E:"not" E.ATd:"not" unique:"False" 
 -- OI:invoke: "has(P)" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"has(P)":rec:Q 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"has(P)":rec:Q 
 -- OI:invoke:B: "has(P)" E: "not"  rec: "Q"  useRtnV: true "has: {   in elm: ref Object;   out B: var Boolean;   scan;      if (elm == current) :then ;         --"Queue:has:e ..."}" 
 -- OI:invoke:before:ATdx.invoke: pattern has 
 -- $pattern:invoke: "has: {   in elm: ref Object;   out B: var Boolean;   scan;      if (elm == current) :then ;         --"Queue:has:elm\n".printB := true;         leave(has ..."} 
 -- ptn:invoke: "has" E: "not" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"not":rec:Q 
 invoke has 154 0 0
 -- global:pushOut: B off: 3 
 pushg 3 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -3 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 3 
 -- GeneralPTN:invoke:after:callInvoke: 3 
 -- GeneralPTN:invoke:end: 3 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"not":rec:Q 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"not":rec:Q 
 -- adrx: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"not":rec:Q 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"not":rec:Q 
 -- adrx: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"not":rec:Q 
 -- OI:invoke:C: has(P) :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "Q" E: "not" 
 -- computeAdr:isLast:E:  "not" 
 -- BE:loadOrigin:E: not 
 -- $ObjectInvocation_Unary:getAdr: "not" >ATd.off:0 (isPtn):on:0:superAdj:0"not: {   %basic 65;   out R: var boolean":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUniq ...} 
 -- $pattern:getAdr: "not: {   %basic 65;   out R: var boolean" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"not":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"not":rec:- 
 -- computeAdr:isLast:E:  "not" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"not":rec:- 
 -- rec:  "has(P)" E:  "not" 
 -- INV:gen:E.loadArgs "not" 
 -- $ObjectInvocation_Unary:loadArgs: "not" >staticOff:0 "not: {   %basic 65;   out R: var boolean" superAdj:0} 
 -- $pattern:loadArgs: "not: {   %basic 65;   out R: var boolean" >E:"not":descNo:140} 
 -- ptn:loadArgs:E "not" 
 -- {(ObjectInvocation_Unary; (name: "not"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "not" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "not" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"not":rec:- 
 -- $ObjectInvocation_Unary:invoke: "not" >rec:"has(P)" ATd:"pattern" E:"not" E.ATd:"not" unique:"False" 
 -- OI:invoke: "not" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"not":rec:has(P) 
 -- origin:isValueObj "Boolean" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"not":rec:has(P) 
 -- OI:invoke:B: "not" E: "not"  rec: "has(P)"  useRtnV: true "not: {   %basic 65;   out R: var boolean}" 
 -- OI:invoke:before:ATdx.invoke: pattern not 
 -- $pattern:invoke: "not: {   %basic 65;   out R: var boolean" E: "not" useRTNv: "True"} 
 -- ptn:invoke: "not" E: "not" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "has(P)" E: "not" 
 nott
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"not":rec:has(P) 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"not":rec:has(P) 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: not :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"not":rec:has(P) 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: "Q.insert(P)" >OGid:"$141" singular! staticOff=0 descNo=141 superAdj=0 
 -- OG:gen: "Q.insert(P)" 
 pushThis 
 -- before objTmpStack:add:  141   "$141" 
 invoke $141 141 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 154 
 -- Items:GenClass: has descNo: 154 isValue: false 
 -- Items:GenClass: has descNo: 21 isValue: false 

 CLASS has 154 1 Queue 78
 -- Store itemArgs: in elm: ref Object{out B: var Boolean;scan;   if (elm == current) :then ;      --"Queue:has:elm\n".printB := true;      leave(has)} 
 -- in elm: ref Object true 64 
 -- DI:store: "elm" 
 pushThis 
 rstoreg  elm 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=154 vDescInx=154 vdtTop: 1 
 mvStack 
 -- $ref:gen: "in elm: ref Object"  
 -- DI:gen: "in elm: ref Object" DI:isConst: false :isBasicValue: false :primNo: 64 
 -- $var:gen: "out B: var Boolean"  
 -- DI:gen: "out B: var Boolean" DI:isConst: false :isBasicValue: true :primNo: 4 
 -- DI:add:BP1:  B 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "scan{   if (elm == current) :then ;      --"Queue:has:elm\n".printB := true;      leave(has)}" 
 -- $ObjectGenerator:gen: "scan{   if (elm == current) :then ;      --"Queue:has:elm\n".printB := true;      leave(has)" >OGid:"scan$158" singular! staticOff=0 descNo=158 supe ...} 
 -- OG:gen: "scan{   if (elm == current) :then ;      --"Queue:has:elm\n".printB := true;      leave(has)}" 
 pushThis 
 -- before objTmpStack:add:  158   "scan$158" 
 invoke scan$158 158 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 -- pushReturn:  "has" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 155 
 -- Items:GenClass: scan descNo: 155 isValue: false 
 -- Items:GenClass: scan descNo: 21 isValue: false 

 CLASS scan 155 1 Queue 78
 -- Store itemArgs: %Public{current: ref Object;currentElement: ref Element;currentElement := head;loop: ;   if (currentElement =/= none) :then ;      current := currentElemen ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=155 vDescInx=155 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%Public"  
 -- $ref:gen: "current: ref Object"  
 -- DI:gen: "current: ref Object" DI:isConst: false :isBasicValue: false :primNo: 64 
 -- $ref:gen: "currentElement: ref Element"  
 -- DI:gen: "currentElement: ref Element" DI:isConst: false :isBasicValue: false :primNo: 0 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%Public" 
 -- $Property:gen: "%Public"  
 -- genclass:stmt: "currentElement := head" 
 -- $Assign:gen: "currentElement := head"  
 -- assign: "currentElement := head" 
 -- computeAdr:superAdj: 0 "currentElement" 
 -- computeAdr: 1 :rec: "none"  E: "currentElement" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "currentElement"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "currentElement" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "currentElement" >ATd.off:3:on:0:superAdj:0"currentElement: ref Element":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVal ... 
 -- $ref:getAdr: "currentElement: ref Element" >newOff:3,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique: ... 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "currentElement" 
 -- AssignmentStatement:gen: "currentElement := head" right.label: "ObjectGenerator" "head" 
 -- $ObjectGenerator:gen: "head" >OGid:"Element" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "head" 
 -- OG:before:super.gen: "head" 
 -- $Invocation:gen: "head" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "head" 
 -- isConstant: "Invocation" "head" 
 -- notConst: head head: ref Element 
 -- needorigin: "head" 
 -- needOrigin:E: "head"  E.ATd: "head: ref Element" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "head" 
 -- computeAdr: 1 :rec: "none"  E: "head" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "head"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "head" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "scan" on: 1 isValueObj: false 
 -- origin: Queue origin:isValueObj: false 
 rpushg scan$155 1
 -- $ObjectInvocation_Unary:getAdr: "head" >ATd.off:4:on:1:superAdj:0"head: ref Element":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F ... 
 -- $ref:getAdr: "head: ref Element" >newOff:4,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "head"  ATd: "head: ref Element" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "head" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "head" E:  "head" 
 -- INV:gen:E.loadArgs "head" 
 -- $ObjectInvocation_Unary:loadArgs: "head" >staticOff:0 "head: ref Element" superAdj:0 
 -- $ref:loadArgs: "head: ref Element" >E:"head" 
 -- $pattern:loadArgs: "Element: {   in elm: ref Object;   out res: ref Element;   id: var integer;   pred: ref Element;   succ: ref Element;   res := this(Element);   idc :=  ..."} 
 -- ptn:loadArgs:E "head" 
 -- {(ObjectInvocation_Unary; (name: "head"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "head" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "head" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "head" >rec:"head" ATd:"ref" E:"head" E.ATd:"head" unique:"False" 
 -- OI:invoke: "head" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:head 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:head 
 -- OI:invoke:B: "head" E: "head"  rec: "head"  useRtnV: true "head: ref Element" 
 -- OI:invoke:before:ATdx.invoke: ref head 
 -- $ref:invoke: "head: ref Element" E: "head">newOff:4 useRTNv: "True" 
 -- DI:invoke: "head: ref Element" 
 -- >Object:unique: false 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- isCompositeValueObj: false E: "head" "head: ref Element" false 
 -- E.ATd.isValueObj: false rec: "head" 
 rpushg Queue$78 4
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- 
 -- OI:invoke:C: head :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- rec: "currentElement" dstE: "currentElement" dstE.ATd: "currentElement: ref Element" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F  ... 
 -- dstDI.isBasicVal: false dstDI.isValObj: false dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- isValue: false  isAdr: true  descNo:  0 
 rswap 0
 rstoreg  EisNone 3
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- assign:adr.store:B: 
 -- genclass:stmt: "loop" 
 -- $ObjectGenerator:gen: "loop" >OGid:"loop" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "loop" 
 -- OG:before:super.gen: "loop" 
 -- $Invocation:gen: "loop" >useRtnV:"False"superAdj: 0 descNo: 156 
 -- INV:gen: "loop" 
 -- isConstant: "Invocation" "loop" 
 -- needorigin: "loop" 
 -- needOrigin:E: "loop"  E.ATd: "loop: {   if (currentElement =/= none) :then ;      current := currentElement.elm;      inner(scan);      currentElement := currentElement.su ...}" 
 -- doNeedOrigin:Ex: "loop" 
 -- computeAdr:superAdj: 0 "loop" 
 -- computeAdr: 1 :rec: "none"  E: "loop" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "loop"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "loop" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "loop" >ATd.off:0 (isPtn):on:0:superAdj:0"loop: {   if (currentElement =/= none) :then ;      current := currentElement.elm;      inner(sca ..."} 
 -- $pattern:getAdr: "loop: {   if (currentElement =/= none) :then ;      current := currentElement.elm;      inner(scan);      currentElement := currentElement.succ;      res ..."} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"loop":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"loop":rec:- 
 -- computeAdr:isLast:E:  "loop" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"loop":rec:- 
 -- rec:  "loop" E:  "loop" 
 -- INV:gen:E.loadArgs "loop" 
 -- $ObjectInvocation_Unary:loadArgs: "loop" >staticOff:0 "loop: {   if (currentElement =/= none) :then ;      current := currentElement.elm;      inner(scan);      currentEle ..."} 
 -- $pattern:loadArgs: "loop: {   if (currentElement =/= none) :then ;      current := currentElement.elm;      inner(scan);      currentElement := currentElement.succ;      r ..."} 
 -- ptn:loadArgs:E "loop" 
 -- {(ObjectInvocation_Unary; (name: "loop"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "loop" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "loop" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"loop":rec:- 
 -- $ObjectInvocation_Unary:invoke: "loop" >rec:"loop" ATd:"pattern" E:"loop" E.ATd:"loop" unique:"False" 
 -- OI:invoke: "loop" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"loop":rec:loop 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"loop":rec:loop 
 -- OI:invoke:B: "loop" E: "loop"  rec: "loop"  useRtnV: false "loop: {   if (currentElement =/= none) :then ;      current := currentElement.elm;      inner(scan);      curre ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern loop 
 -- $pattern:invoke: "loop: {   if (currentElement =/= none) :then ;      current := currentElement.elm;      inner(scan);      currentElement := currentElement.succ;      res ..."} 
 -- ptn:invoke: "loop" E: "loop" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"loop":rec:loop 
 invoke loop 156 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"loop":rec:loop 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"loop":rec:loop 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: loop :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"loop":rec:loop 
 L2:
 -- pushReturn:  "scan" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- vdtAdd: inx=2 descInx=155 vDescInx=0 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 156 
 -- Items:GenClass: loop descNo: 156 isValue: false 
 -- Items:GenClass: loop descNo: 21 isValue: false 

 CLASS loop 156 1 scan 155
 -- Store itemArgs: if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentElement := currentElement.succ;   restart(loop)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=156 vDescInx=156 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentElement := currentElement.succ;   restart(loop)}" 
 -- $ObjectGenerator:gen: "if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentElement := currentElement.succ;   restart(loop)" >OGid ...} 
 -- OG:gen: "if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentElement := currentElement.succ;   restart(loop)}" 
 -- OG:before:super.gen: "if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentElement := currentElement.succ;   restart(loop)}" 
 -- $Invocation:gen: "if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentElement := currentElement.succ;   restart(loop)" >useRtnV:" ..."} 
 -- INV:gen: "if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentElement := currentElement.succ;   restart(loop)}" 
 -- isConstant: "Invocation" "if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentElement := currentElement.succ;   restart(loop)}" 
 -- needorigin: "if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentElement := currentElement.succ;   restart(loop)}" 
 -- needOrigin:E: "if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentElement := currentElement.succ;   restart(loop)}"  E.ATd: "if( ..." 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentElement := currentElement.succ;   restart(loop)}" E:  "if (currentElem ..." 
 -- INV:gen:E.loadArgs "if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentElement := currentElement.succ;   restart(loop)}" 
 -- $IfThen:loadArgs: "if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentElement := currentElement.succ;   restart(loop)" } 
 -- INV:gen:after:E.loadArgs "if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentElement := currentElement.succ;   restart(loop)}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentElement := currentElement.succ;   res ...}" 
 -- $IfThen:invoke: "if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentElement := currentElement.succ;   restart(loop)" } 
 -- $IfThen:gen: "if (currentElement =/= none) :then {   current := currentElement.elm;   inner(scan);   currentElement := currentElement.succ;   restart(loop)" } 
 -- $ObjectGenerator:gen: "(currentElement =/= none)" >OGid:"=/=" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(currentElement =/= none)" 
 -- OG:before:super.gen: "(currentElement =/= none)" 
 -- $Invocation:gen: "(currentElement =/= none)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(currentElement =/= none)" 
 -- isConstant: "Invocation" "(currentElement =/= none)" 
 -- needorigin: "(currentElement =/= none)" 
 -- needOrigin:E: "(currentElement =/= none)"  E.ATd: "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean}" 
 -- doNeedOrigin:Ex: "(currentElement =/= none)" 
 -- computeAdr:superAdj: 0 "(currentElement =/= none)" 
 -- computeAdr: 1 :rec: "none"  E: "(currentElement =/= none)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(currentElement =/= none)"  
 -- $BracketedExp:loadOrigin: "(currentElement =/= none)"  
 -- computeAdr:superAdj: 0 "currentElement =/= none" 
 -- computeAdr: 1 :rec: "none"  E: "currentElement =/= none" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "currentElement =/= none"  
 -- $BinOp:loadOrigin: "currentElement =/= none"  
 -- BinaryExp:loadOrigin:empty: "currentElement =/= none" superAdj: 0 
 -- $BinOp:getAdr: "currentElement =/= none"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "currentElement =/= none"  ATd: "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "currentElement =/= none" 
 -- BE:loadOrigin:E: currentElement =/= none 
 -- $BinOp:getAdr: "currentElement =/= none"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "currentElement =/= none"  ATd: "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "currentElement =/= none" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "currentElement =/= none" E:  "currentElement =/= none" 
 -- INV:gen:E.loadArgs "currentElement =/= none" 
 -- $BinOp:loadArgs: "currentElement =/= none"  
 -- BinaryExp:loadArgs: "currentElement =/= none" superAdj: 0 
 -- $Invocation:gen: "currentElement" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "currentElement" 
 -- isConstant: "Invocation" "currentElement" 
 -- notConst: currentElement currentElement: ref Element 
 -- needorigin: "currentElement" 
 -- needOrigin:E: "currentElement"  E.ATd: "currentElement: ref Element" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "currentElement" 
 -- computeAdr: 1 :rec: "none"  E: "currentElement" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "currentElement"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "currentElement" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: scan origin:isValueObj: false 
 rpushg loop$156 1
 -- $ObjectInvocation_Unary:getAdr: "currentElement" >ATd.off:3:on:1:superAdj:0"currentElement: ref Element":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVal ... 
 -- $ref:getAdr: "currentElement: ref Element" >newOff:3,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique: ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "currentElement"  ATd: "currentElement: ref Element" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "currentElement" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "currentElement" E:  "currentElement" 
 -- INV:gen:E.loadArgs "currentElement" 
 -- $ObjectInvocation_Unary:loadArgs: "currentElement" >staticOff:0 "currentElement: ref Element" superAdj:0 
 -- $ref:loadArgs: "currentElement: ref Element" >E:"currentElement" 
 -- $pattern:loadArgs: "Element: {   in elm: ref Object;   out res: ref Element;   id: var integer;   pred: ref Element;   succ: ref Element;   res := this(Element);   idc :=  ..."} 
 -- ptn:loadArgs:E "currentElement" 
 -- {(ObjectInvocation_Unary; (name: "currentElement"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "currentElement" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "currentElement" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec ... 
 -- $ObjectInvocation_Unary:invoke: "currentElement" >rec:"currentElement" ATd:"ref" E:"currentElement" E.ATd:"currentElement" unique:"False" 
 -- OI:invoke: "currentElement" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:currentElement 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:currentElement 
 -- OI:invoke:B: "currentElement" E: "currentElement"  rec: "currentElement"  useRtnV: true "currentElement: ref Element" 
 -- OI:invoke:before:ATdx.invoke: ref currentElement 
 -- $ref:invoke: "currentElement: ref Element" E: "currentElement">newOff:3 useRTNv: "True" 
 -- DI:invoke: "currentElement: ref Element" 
 -- >Object:unique: false 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"currentElement":rec:currentElement 
 -- isCompositeValueObj: false E: "currentElement" "currentElement: ref Element" false 
 -- E.ATd.isValueObj: false rec: "currentElement" 
 rpushg scan$155 3
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"currentElement":rec:currentElement 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"currentElement":rec:currentElement 
 -- 
 -- OI:invoke:C: currentElement :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"currentElement":rec:currentElement 
 -- $pattern:loadArgs: "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean" >E:"=/= none":descNo:117} 
 -- ptn:loadArgs:E "=/= none" 
 -- {(ObjectInvocation_Binary; (name: "=/="); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "none");     (Arguments)));   (Items descNo: ...} 
 -- args: "none" 
 -- E: "ObjectGenerator" none 
 -- E.arg: "ref" in objx: ref Object 
 -- NonVirt: "=/= none" "ObjectInvocation_Binary" ActArg:  "none" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "=/= none"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "none" >OGid:"none" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "none" 
 -- OG:before:super.gen: "none" 
 -- $Invocation:gen: "none" >useRtnV:"True"superAdj: 0 descNo: 116 
 -- INV:gen: "none" 
 -- isConstant: "Invocation" "none" 
 -- needorigin: "none" 
 -- needOrigin:E: "none"  E.ATd: "none: {   %basic 19;   none_x: var integer}" 
 -- doNeedOrigin:Ex: "none" 
 -- computeAdr:superAdj: 0 "none" 
 -- computeAdr: 1 :rec: "none"  E: "none" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "none"  
 -- $ObjectInvocation_Unary:loadOrigin: "none" >on:5 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_Unary:getAdr: "none" >ATd.off:0 (isPtn):on:5:superAdj:0"none: {   %basic 19;   none_x: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU ...} 
 -- $pattern:getAdr: "none: {   %basic 19;   none_x: var integer" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- E.on: 5 
 -- beforeIsValueObj:E: "none"  ATd: "none: {   %basic 19;   none_x: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "none" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "none" E:  "none" 
 -- INV:gen:E.loadArgs "none" 
 -- $ObjectInvocation_Unary:loadArgs: "none" >staticOff:0 "none: {   %basic 19;   none_x: var integer" superAdj:0} 
 -- $pattern:loadArgs: "none: {   %basic 19;   none_x: var integer" >E:"none":descNo:116} 
 -- ptn:loadArgs:E "none" 
 -- {(ObjectInvocation_Unary; (name: "none"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "none" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "none" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "none" >rec:"none" ATd:"pattern" E:"none" E.ATd:"none" unique:"False" 
 -- OI:invoke: "none" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- OI:invoke:B: "none" E: "none"  rec: "none"  useRtnV: true "none: {   %basic 19;   none_x: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern none 
 -- $pattern:invoke: "none: {   %basic 19;   none_x: var integer" E: "none" useRTNv: "True"} 
 -- ptn:invoke: "none" E: "none" ptnKind: 0 useRtnV: true 
 pushNone 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- 
 -- OI:invoke:C: none :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- formalArg:isPtn: "in objx: ref Object" :isBasicVal: false :valueObj: false 
 -- :actArg: "none" :isBasicVal: false 
 -- case:B: none ObjectGenerator 64 19 19 false false 
 -- end:loadArgs:NonVirt: "=/= none" 
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"currentElement":rec:currentElement 
 -- INV:gen:after:E.loadArgs "currentElement =/= none" 
 -- OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"currentElement":rec:currentElement 
 -- IV:E.invoke:useRtnVal: true E: BinOp "currentElement =/= none" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"currentElement":r ... 
 -- $BinOp:invoke: "currentElement =/= none"  
 -- BinaryExp:invoke: "currentElement" rec: "currentElement =/= none" 
 -- M: "=/= none" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"currentElement":rec:currentElement 
 -- $ObjectInvocation_Binary:invoke: "=/= none" >rec:"currentElement" ATd:"pattern" E:"=/= none" E.ATd:"=/=  " unique:"False" 
 -- OI:invoke: "=/= none" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"currentElement":rec:currentElement 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"currentElement":rec:currentElement 
 -- OI:invoke:B: "=/= none" E: "=/= none"  rec: "currentElement"  useRtnV: true "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean}" 
 -- OI:invoke:before:ATdx.invoke: pattern =/=   
 -- $pattern:invoke: "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean" E: "=/= none" useRTNv: "True"} 
 -- ptn:invoke: "=/=  " E: "=/= none" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "currentElement" E: "=/= none" 
 -- arg:other 
 rne
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"=/= none":rec:currentElement 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"=/= none":rec:currentElement 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: =/= none :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: "current := currentElement.elm{   inner(scan);   currentElement := currentElement.succ;   restart(loop)" >OGid:"$157" singular! staticOff=0 descNo=15 ...} 
 -- OG:gen: "current := currentElement.elm{   inner(scan);   currentElement := currentElement.succ;   restart(loop)}" 
 pushThis 
 -- before objTmpStack:add:  157   "$157" 
 invoke $157 157 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 -- pushReturn:  "loop" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 157 
 -- Items:GenClass: $157 descNo: 157 isValue: false 
 -- Items:GenClass: $157 descNo: 21 isValue: false 

 CLASS $157 157 1 loop 156
 -- Store itemArgs: current := currentElement.elm{inner(scan);currentElement := currentElement.succ;restart(loop)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=157 vDescInx=157 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "current := currentElement.elm" 
 -- $Assign:gen: "current := currentElement.elm"  
 -- assign: "current := currentElement.elm" 
 -- computeAdr:superAdj: 0 "current" 
 -- computeAdr: 1 :rec: "none"  E: "current" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "current"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "current" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$157" on: 2 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg $157$157 1
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: scan origin:isValueObj: false 
 rpushg loop$156 1
 -- $ObjectInvocation_Unary:getAdr: "current" >ATd.off:2:on:2:superAdj:0"current: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVa ... 
 -- $ref:getAdr: "current: ref Object" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValu ... 
 -- E.on: 2 
 -- beforeIsValueObj:E: "current"  ATd: "current: ref Object" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "current" 
 -- AssignmentStatement:gen: "current := currentElement.elm" right.label: "ObjectGenerator" "currentElement.elm" 
 -- $ObjectGenerator:gen: "currentElement.elm" >OGid:"Object" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "currentElement.elm" 
 -- OG:before:super.gen: "currentElement.elm" 
 -- $Invocation:gen: "currentElement.elm" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "currentElement.elm" 
 -- isConstant: "Invocation" "currentElement.elm" 
 -- notConst: currentElement currentElement: ref Element 
 -- needorigin: "currentElement.elm" 
 -- needOrigin:E: "elm"  E.ATd: "in elm: ref Object" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "currentElement.elm" 
 -- computeAdr: 1 :rec: "none"  E: "currentElement" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "currentElement"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "currentElement" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$157" on: 2 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg $157$157 1
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: scan origin:isValueObj: false 
 rpushg loop$156 1
 -- $ObjectInvocation_Unary:getAdr: "currentElement" >ATd.off:3:on:2:superAdj:0"currentElement: ref Element":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVal ... 
 -- $ref:getAdr: "currentElement: ref Element" >newOff:3,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique: ... 
 -- E.on: 2 
 -- beforeIsValueObj:E: "currentElement"  ATd: "currentElement: ref Element" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "currentElement"  E: "elm" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "elm" >ATd.off:2:on:0:superAdj:0"in elm: ref Object":Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F ... 
 -- $ref:getAdr: "in elm: ref Object" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue ... 
 -- $ObjectInvocation_Unary:loadArgs: "currentElement" >staticOff:0 "currentElement: ref Element" superAdj:0 
 -- $ref:loadArgs: "currentElement: ref Element" >E:"currentElement" 
 -- $pattern:loadArgs: "Element: {   in elm: ref Object;   out res: ref Element;   id: var integer;   pred: ref Element;   succ: ref Element;   res := this(Element);   idc :=  ..."} 
 -- ptn:loadArgs:E "currentElement" 
 -- {(ObjectInvocation_Unary; (name: "currentElement"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "currentElement" >rec:"currentElement" ATd:"ref" E:"elm" E.ATd:"elm" unique:"False" 
 -- OI:invoke: "currentElement" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"elm":rec:currentElement 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"elm":rec:currentElement 
 -- OI:invoke:B: "currentElement" E: "elm"  rec: "currentElement"  useRtnV: true "currentElement: ref Element" 
 -- OI:invoke:before:ATdx.invoke: ref currentElement 
 -- $ref:invoke: "currentElement: ref Element" E: "elm">newOff:3 useRTNv: "True" 
 -- DI:invoke: "currentElement: ref Element" 
 -- >Object:unique: false 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"elm":rec:currentElement 
 -- isCompositeValueObj: false E: "elm" "in elm: ref Object" false 
 -- E.ATd.isValueObj: false rec: "currentElement" 
 rpushg $157$157 3
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"elm":rec:currentElement 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"elm":rec:currentElement 
 -- 
 -- OI:invoke:C: currentElement :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "currentElement" E: "elm" 
 -- computeAdr:isLast:E:  "elm" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "currentElement" E:  "elm" 
 -- INV:gen:E.loadArgs "elm" 
 -- $ObjectInvocation_Unary:loadArgs: "elm" >staticOff:0 "in elm: ref Object" superAdj:0 
 -- $ref:loadArgs: "in elm: ref Object" >E:"elm" 
 -- $pattern:loadArgs: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic 57; ..."} 
 -- ptn:loadArgs:E "elm" 
 -- {(ObjectInvocation_Unary; (name: "elm"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "elm" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "elm" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "elm" >rec:"currentElement" ATd:"ref" E:"elm" E.ATd:"elm" unique:"False" 
 -- OI:invoke: "elm" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:currentElement 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:currentElement 
 -- OI:invoke:B: "elm" E: "elm"  rec: "currentElement"  useRtnV: true "in elm: ref Object" 
 -- OI:invoke:before:ATdx.invoke: ref elm 
 -- $ref:invoke: "in elm: ref Object" E: "elm">newOff:2 useRTNv: "True" 
 -- DI:invoke: "in elm: ref Object" 
 -- >Object:unique: false 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"elm":rec:currentElement 
 -- isCompositeValueObj: false E: "elm" "in elm: ref Object" false 
 -- E.ATd.isValueObj: false rec: "currentElement" 
 rpushg $157$157 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"elm":rec:currentElement 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"elm":rec:currentElement 
 -- 
 -- OI:invoke:C: elm :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"elm":rec:currentElement 
 -- rec: "current" dstE: "current" dstE.ATd: "current: ref Object" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"non ..." 
 -- dstDI.isBasicVal: false dstDI.isValObj: false dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- isValue: false  isAdr: true  descNo:  0 
 rswap 0
 rstoreg  EisNone 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- assign:adr.store:B: 
 -- genclass:stmt: "inner(scan)" 
 -- $ObjectGenerator:gen: "inner(scan)" >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inner(scan)" 
 -- OG:before:super.gen: "inner(scan)" 
 -- $Invocation:gen: "inner(scan)" >useRtnV:"False"superAdj: 0 descNo: 12 
 -- INV:gen: "inner(scan)" 
 -- isConstant: "Invocation" "inner(scan)" 
 -- needorigin: "inner(scan)" 
 -- needOrigin:E: "inner(scan)"  E.ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- doNeedOrigin:Ex: "inner(scan)" 
 -- computeAdr:superAdj: 0 "inner(scan)" 
 -- computeAdr: 1 :rec: "none"  E: "inner(scan)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "inner(scan)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "inner(scan)" >on:6 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "inner(scan)" >ATd.off:0 (isPtn):on:6:superAdj:0"inner: {   %basic 101;   in inner: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal:F su ...} 
 -- $pattern:getAdr: "inner: {   %basic 101;   in inner: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(scan)":rec:- 
 -- E.on: 6 
 -- beforeIsValueObj:E: "inner(scan)"  ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(scan)":rec:- 
 -- computeAdr:isLast:E:  "inner(scan)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(scan)":rec:- 
 -- rec:  "inner(scan)" E:  "inner(scan)" 
 -- INV:gen:E.loadArgs "inner(scan)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "inner(scan)" >staticOff:0 "inner: {   %basic 101;   in inner: ref Object" superAdj:0arg:"scan"} 
 -- $pattern:loadArgs: "inner: {   %basic 101;   in inner: ref Object" >E:"inner(scan)":descNo:12} 
 -- INV:gen:after:E.loadArgs "inner(scan)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(scan)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(sca ..." 
 -- $ObjectInvocation_KeyWord:invoke: "inner(scan)" >rec:"inner(scan)" ATd:"pattern" E:"inner(scan)" E.ATd:"inner" unique:"False" 
 -- OI:invoke: "inner(scan)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(scan)":rec:inner(scan) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(scan)":rec:inner(scan) 
 -- OI:invoke:B: "inner(scan)" E: "inner(scan)"  rec: "inner(scan)"  useRtnV: false "inner: {   %basic 101;   in inner: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- $pattern:invoke: "inner: {   %basic 101;   in inner: ref Object" E: "inner(scan)" useRTNv: "False"} 
 -- ptn:invoke: "inner" E: "inner(scan)" ptnKind: 0 useRtnV: false 
 pushThis 
 -- items:goOrigin:encOG: "$157" on: 2 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg $157$157 1
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: scan origin:isValueObj: false 
 rpushg loop$156 1
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(scan)":rec:inner(scan) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(scan)":rec:inner(scan) 
 -- 
 -- OI:invoke:C: inner(scan) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(scan)":rec:inner(scan) 
 -- genclass:stmt: "currentElement := currentElement.succ" 
 -- $Assign:gen: "currentElement := currentElement.succ"  
 -- assign: "currentElement := currentElement.succ" 
 -- computeAdr:superAdj: 0 "currentElement" 
 -- computeAdr: 1 :rec: "none"  E: "currentElement" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "currentElement"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "currentElement" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$157" on: 2 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg $157$157 1
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: scan origin:isValueObj: false 
 rpushg loop$156 1
 -- $ObjectInvocation_Unary:getAdr: "currentElement" >ATd.off:3:on:2:superAdj:0"currentElement: ref Element":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVal ... 
 -- $ref:getAdr: "currentElement: ref Element" >newOff:3,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique: ... 
 -- E.on: 2 
 -- beforeIsValueObj:E: "currentElement"  ATd: "currentElement: ref Element" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "currentElement" 
 -- AssignmentStatement:gen: "currentElement := currentElement.succ" right.label: "ObjectGenerator" "currentElement.succ" 
 -- $ObjectGenerator:gen: "currentElement.succ" >OGid:"Element" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "currentElement.succ" 
 -- OG:before:super.gen: "currentElement.succ" 
 -- $Invocation:gen: "currentElement.succ" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "currentElement.succ" 
 -- isConstant: "Invocation" "currentElement.succ" 
 -- notConst: currentElement currentElement: ref Element 
 -- needorigin: "currentElement.succ" 
 -- needOrigin:E: "succ"  E.ATd: "succ: ref Element" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "currentElement.succ" 
 -- computeAdr: 1 :rec: "none"  E: "currentElement" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "currentElement"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "currentElement" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$157" on: 2 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg $157$157 1
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: scan origin:isValueObj: false 
 rpushg loop$156 1
 -- $ObjectInvocation_Unary:getAdr: "currentElement" >ATd.off:3:on:2:superAdj:0"currentElement: ref Element":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVal ... 
 -- $ref:getAdr: "currentElement: ref Element" >newOff:3,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique: ... 
 -- E.on: 2 
 -- beforeIsValueObj:E: "currentElement"  ATd: "currentElement: ref Element" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "currentElement"  E: "succ" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "succ" >ATd.off:6:on:0:superAdj:0"succ: ref Element":Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F ... 
 -- $ref:getAdr: "succ: ref Element" >newOff:6,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- $ObjectInvocation_Unary:loadArgs: "currentElement" >staticOff:0 "currentElement: ref Element" superAdj:0 
 -- $ref:loadArgs: "currentElement: ref Element" >E:"currentElement" 
 -- $pattern:loadArgs: "Element: {   in elm: ref Object;   out res: ref Element;   id: var integer;   pred: ref Element;   succ: ref Element;   res := this(Element);   idc :=  ..."} 
 -- ptn:loadArgs:E "currentElement" 
 -- {(ObjectInvocation_Unary; (name: "currentElement"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "currentElement" >rec:"currentElement" ATd:"ref" E:"succ" E.ATd:"succ" unique:"False" 
 -- OI:invoke: "currentElement" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"succ":rec:currentElement 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"succ":rec:currentElement 
 -- OI:invoke:B: "currentElement" E: "succ"  rec: "currentElement"  useRtnV: true "currentElement: ref Element" 
 -- OI:invoke:before:ATdx.invoke: ref currentElement 
 -- $ref:invoke: "currentElement: ref Element" E: "succ">newOff:3 useRTNv: "True" 
 -- DI:invoke: "currentElement: ref Element" 
 -- >Object:unique: false 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"succ":rec:currentElement 
 -- isCompositeValueObj: false E: "succ" "succ: ref Element" false 
 -- E.ATd.isValueObj: false rec: "currentElement" 
 rpushg $157$157 3
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"succ":rec:currentElement 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"succ":rec:currentElement 
 -- 
 -- OI:invoke:C: currentElement :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "currentElement" E: "succ" 
 -- computeAdr:isLast:E:  "succ" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "currentElement" E:  "succ" 
 -- INV:gen:E.loadArgs "succ" 
 -- $ObjectInvocation_Unary:loadArgs: "succ" >staticOff:0 "succ: ref Element" superAdj:0 
 -- $ref:loadArgs: "succ: ref Element" >E:"succ" 
 -- $pattern:loadArgs: "Element: {   in elm: ref Object;   out res: ref Element;   id: var integer;   pred: ref Element;   succ: ref Element;   res := this(Element);   idc :=  ..."} 
 -- ptn:loadArgs:E "succ" 
 -- {(ObjectInvocation_Unary; (name: "succ"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "succ" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "succ" :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "succ" >rec:"currentElement" ATd:"ref" E:"succ" E.ATd:"succ" unique:"False" 
 -- OI:invoke: "succ" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:currentElement 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:currentElement 
 -- OI:invoke:B: "succ" E: "succ"  rec: "currentElement"  useRtnV: true "succ: ref Element" 
 -- OI:invoke:before:ATdx.invoke: ref succ 
 -- $ref:invoke: "succ: ref Element" E: "succ">newOff:6 useRTNv: "True" 
 -- DI:invoke: "succ: ref Element" 
 -- >Object:unique: false 
 -- load: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"succ":rec:currentElement 
 -- isCompositeValueObj: false E: "succ" "succ: ref Element" false 
 -- E.ATd.isValueObj: false rec: "currentElement" 
 rpushg $157$157 6
 -- OI:invoke:V: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"succ":rec:currentElement 
 -- 
 -- OI:invoke:X: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"succ":rec:currentElement 
 -- 
 -- OI:invoke:C: succ :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 6 
 -- OG:gen:end: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"succ":rec:currentElement 
 -- rec: "currentElement" dstE: "currentElement" dstE.ATd: "currentElement: ref Element" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F  ... 
 -- dstDI.isBasicVal: false dstDI.isValObj: false dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- isValue: false  isAdr: true  descNo:  0 
 rswap 0
 rstoreg  EisNone 3
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-4,0)=[]
 -- assign:adr.store:B: 
 -- genclass:stmt: "restart(loop)" 
 -- $ObjectGenerator:gen: "restart(loop)" >OGid:"restart" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "restart(loop)" 
 -- OG:before:super.gen: "restart(loop)" 
 -- $Invocation:gen: "restart(loop)" >useRtnV:"False"superAdj: 0 descNo: 50 
 -- INV:gen: "restart(loop)" 
 -- isConstant: "Invocation" "restart(loop)" 
 -- needorigin: "restart(loop)" 
 -- needOrigin:E: "restart(loop)"  E.ATd: "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- doNeedOrigin:Ex: "restart(loop)" 
 -- computeAdr:superAdj: 0 "restart(loop)" 
 -- computeAdr: 1 :rec: "none"  E: "restart(loop)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "restart(loop)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "restart(loop)" >on:6 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "restart(loop)" >ATd.off:0 (isPtn):on:6:superAdj:0"restart(V: var integer):  -- odd parameter type!{   %basic 102":Adr:off:0 size:0 isFlo ...} 
 -- $pattern:getAdr: "restart(V: var integer):  -- odd parameter type!{   %basic 102" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:- 
 -- E.on: 6 
 -- beforeIsValueObj:E: "restart(loop)"  ATd: "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:- 
 -- computeAdr:isLast:E:  "restart(loop)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:- 
 -- rec:  "restart(loop)" E:  "restart(loop)" 
 -- INV:gen:E.loadArgs "restart(loop)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "restart(loop)" >staticOff:0 "restart(V: var integer):  -- odd parameter type!{   %basic 102" superAdj:0arg:"loop"} 
 -- $pattern:loadArgs: "restart(V: var integer):  -- odd parameter type!{   %basic 102" >E:"restart(loop)":descNo:50} 
 -- INV:gen:after:E.loadArgs "restart(loop)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "restart(loop)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart ..." 
 -- $ObjectInvocation_KeyWord:invoke: "restart(loop)" >rec:"restart(loop)" ATd:"pattern" E:"restart(loop)" E.ATd:"restart(V: var integer)" unique:"False" 
 -- OI:invoke: "restart(loop)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- OI:invoke:B: "restart(loop)" E: "restart(loop)"  rec: "restart(loop)"  useRtnV: false "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- OI:invoke:before:ATdx.invoke: pattern restart(V: var integer) 
 -- $pattern:invoke: "restart(V: var integer):  -- odd parameter type!{   %basic 102" E: "restart(loop)" useRTNv: "False"} 
 -- ptn:invoke: "restart(V: var integer)" E: "restart(loop)" ptnKind: 0 useRtnV: false 
 break  1 1 156 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- 
 -- OI:invoke:C: restart(loop) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 158 
 -- Items:GenClass: scan$158 descNo: 158 isValue: false 
 -- Items:GenClass: scan$158 descNo: 155 isValue: false 
 -- Items:GenClass: scan descNo: 21 isValue: false 

 CLASS scan$158 158 4 has 154
 -- vdtTableCopy: I:1:155 I:2:0
 -- vdtAdd: inx=2 descInx=158 vDescInx=158 vdtTop: 2 
 -- Store itemArgs: if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  4 origin
 -- super scan
 -- push:super.origin: 
 -- computeAdr:superAdj: 4 "scan" 
 -- computeAdr: 1 :rec: "none"  E: "scan" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "scan"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "scan" >on:1 superAdj:4 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 4 
 rpushg has$154 4
 -- items:goOrigin:encOG: "has" on: 1 isValueObj: false 
 -- origin: Queue origin:isValueObj: false 
 rpushg has$154 1
 -- $ObjectInvocation_Unary:getAdr: "scan" >ATd.off:0 (isPtn):on:1:superAdj:4"scan: {   %Public;   current: ref Object;   currentElement: ref Element;   currentElement := head ..."} 
 -- $pattern:getAdr: "scan: {   %Public;   current: ref Object;   currentElement: ref Element;   currentElement := head;   loop: ;      if (currentElement =/= none) :then ;    ..."} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"scan":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "scan"  ATd: "scan: {   %Public;   current: ref Object;   currentElement: ref Element;   currentElement := head;   loop: ;      if (currentElement =/=  ...}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"scan":rec:- 
 -- computeAdr:isLast:E:  "scan" 
 -- genClass:after:pushAddress: "scan" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"scan":rec:- 
 -- handleSuperArgs:E: "scan" theIS: "if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)}" 
 -- super.sig:none:superAdj: 4 
 -- $ObjectInvocation_Unary:loadArgs: "scan" >staticOff:0 "scan: {   %Public;   current: ref Object;   currentElement: ref Element;   currentElement := head;   loop: ;      if ..."} 
 -- $pattern:loadArgs: "scan: {   %Public;   current: ref Object;   currentElement: ref Element;   currentElement := head;   loop: ;      if (currentElement =/= none) :then ;  ..."} 
 -- ptn:loadArgs:E "scan" 
 -- {(ObjectInvocation_Unary; (name: "scan"); (Arguments))} 
 -- args: "" 
 -- hArgOrg:super: scan 
 -- Store itemArgs: if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=158 vDescInx=155 vdtTop: 2 
 -- $Property:gen: "%Public"  
 -- $ref:gen: "current: ref Object"  
 -- DI:gen: "current: ref Object" DI:isConst: false :isBasicValue: false :primNo: 64 
 -- $ref:gen: "currentElement: ref Element"  
 -- DI:gen: "currentElement: ref Element" DI:isConst: false :isBasicValue: false :primNo: 0 
 rtnAlloc 1
 toSuper 155
DO:
 mvStack 
 L1:
 -- genclass:stmt: "if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)}" 
 -- $ObjectGenerator:gen: "if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)" >OGid:"if:then$0" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)}" 
 -- OG:before:super.gen: "if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)}" 
 -- $Invocation:gen: "if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)" >useRtnV:"False"superAdj: 0} 
 -- INV:gen: "if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)}" 
 -- isConstant: "Invocation" "if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)}" 
 -- needorigin: "if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)}" 
 -- needOrigin:E: "if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)}"  E.ATd: "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)}" E:  "if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has) ...}" 
 -- INV:gen:E.loadArgs "if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)}" 
 -- $IfThen:loadArgs: "if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)" } 
 -- INV:gen:after:E.loadArgs "if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)}" 
 -- $IfThen:invoke: "if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)" } 
 -- $IfThen:gen: "if (elm == current) :then {   --"Queue:has:elm\n".printB := true;   leave(has)" } 
 -- $ObjectGenerator:gen: "(elm == current)" >OGid:"==" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(elm == current)" 
 -- OG:before:super.gen: "(elm == current)" 
 -- $Invocation:gen: "(elm == current)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(elm == current)" 
 -- isConstant: "Invocation" "(elm == current)" 
 -- needorigin: "(elm == current)" 
 -- needOrigin:E: "(elm == current)"  E.ATd: "==  : {   %basic 56;   in objx: ref Object;   out V: var boolean}" 
 -- doNeedOrigin:Ex: "(elm == current)" 
 -- computeAdr:superAdj: 0 "(elm == current)" 
 -- computeAdr: 1 :rec: "none"  E: "(elm == current)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(elm == current)"  
 -- $BracketedExp:loadOrigin: "(elm == current)"  
 -- computeAdr:superAdj: 0 "elm == current" 
 -- computeAdr: 1 :rec: "none"  E: "elm == current" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "elm == current"  
 -- $BinOp:loadOrigin: "elm == current"  
 -- BinaryExp:loadOrigin:empty: "elm == current" superAdj: 0 
 -- $BinOp:getAdr: "elm == current"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "elm == current"  ATd: "==  : {   %basic 56;   in objx: ref Object;   out V: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "elm == current" 
 -- BE:loadOrigin:E: elm == current 
 -- $BinOp:getAdr: "elm == current"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "elm == current"  ATd: "==  : {   %basic 56;   in objx: ref Object;   out V: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "elm == current" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "elm == current" E:  "elm == current" 
 -- INV:gen:E.loadArgs "elm == current" 
 -- $BinOp:loadArgs: "elm == current"  
 -- BinaryExp:loadArgs: "elm == current" superAdj: 0 
 -- $Invocation:gen: "elm" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "elm" 
 -- isConstant: "Invocation" "elm" 
 -- notConst: elm in elm: ref Object 
 -- needorigin: "elm" 
 -- needOrigin:E: "elm"  E.ATd: "in elm: ref Object" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "elm" 
 -- computeAdr: 1 :rec: "none"  E: "elm" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "elm"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "elm" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "scan$158" on: 1 isValueObj: false 
 -- origin: has origin:isValueObj: false 
 rpushg scan$158$158 4
 -- $ObjectInvocation_Unary:getAdr: "elm" >ATd.off:2:on:1:superAdj:0"in elm: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F ... 
 -- $ref:getAdr: "in elm: ref Object" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "elm"  ATd: "in elm: ref Object" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "elm" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "elm" E:  "elm" 
 -- INV:gen:E.loadArgs "elm" 
 -- $ObjectInvocation_Unary:loadArgs: "elm" >staticOff:0 "in elm: ref Object" superAdj:0 
 -- $ref:loadArgs: "in elm: ref Object" >E:"elm" 
 -- $pattern:loadArgs: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic 57; ..."} 
 -- ptn:loadArgs:E "elm" 
 -- {(ObjectInvocation_Unary; (name: "elm"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "elm" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "elm" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "elm" >rec:"elm" ATd:"ref" E:"elm" E.ATd:"elm" unique:"False" 
 -- OI:invoke: "elm" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:elm 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:elm 
 -- OI:invoke:B: "elm" E: "elm"  rec: "elm"  useRtnV: true "in elm: ref Object" 
 -- OI:invoke:before:ATdx.invoke: ref elm 
 -- $ref:invoke: "in elm: ref Object" E: "elm">newOff:2 useRTNv: "True" 
 -- DI:invoke: "in elm: ref Object" 
 -- >Object:unique: false 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"elm":rec:elm 
 -- isCompositeValueObj: false E: "elm" "in elm: ref Object" false 
 -- E.ATd.isValueObj: false rec: "elm" 
 rpushg has$154 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"elm":rec:elm 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"elm":rec:elm 
 -- 
 -- OI:invoke:C: elm :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"elm":rec:elm 
 -- $pattern:loadArgs: "==  : {   %basic 56;   in objx: ref Object;   out V: var boolean" >E:"== current":descNo:144} 
 -- ptn:loadArgs:E "== current" 
 -- {(ObjectInvocation_Binary; (name: "=="); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "current");     (Arguments)));   (Items descN ...} 
 -- args: "current" 
 -- E: "ObjectGenerator" current 
 -- E.arg: "ref" in objx: ref Object 
 -- NonVirt: "== current" "ObjectInvocation_Binary" ActArg:  "current" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "== current"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "current" >OGid:"Object" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "current" 
 -- OG:before:super.gen: "current" 
 -- $Invocation:gen: "current" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "current" 
 -- isConstant: "Invocation" "current" 
 -- notConst: current current: ref Object 
 -- needorigin: "current" 
 -- needOrigin:E: "current"  E.ATd: "current: ref Object" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "current" 
 -- computeAdr: 1 :rec: "none"  E: "current" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "current"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "current" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "current" >ATd.off:2:on:0:superAdj:0"current: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVa ... 
 -- $ref:getAdr: "current: ref Object" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValu ... 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "current" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "current" E:  "current" 
 -- INV:gen:E.loadArgs "current" 
 -- $ObjectInvocation_Unary:loadArgs: "current" >staticOff:0 "current: ref Object" superAdj:0 
 -- $ref:loadArgs: "current: ref Object" >E:"current" 
 -- $pattern:loadArgs: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic 57; ..."} 
 -- ptn:loadArgs:E "current" 
 -- {(ObjectInvocation_Unary; (name: "current"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "current" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "current" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "current" >rec:"current" ATd:"ref" E:"current" E.ATd:"current" unique:"False" 
 -- OI:invoke: "current" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:current 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:current 
 -- OI:invoke:B: "current" E: "current"  rec: "current"  useRtnV: true "current: ref Object" 
 -- OI:invoke:before:ATdx.invoke: ref current 
 -- $ref:invoke: "current: ref Object" E: "current">newOff:2 useRTNv: "True" 
 -- DI:invoke: "current: ref Object" 
 -- >Object:unique: false 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"current":rec:current 
 -- isCompositeValueObj: false E: "current" "current: ref Object" false 
 -- E.ATd.isValueObj: false rec: "current" 
 rpushg scan$158$158 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"current":rec:current 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"current":rec:current 
 -- 
 -- OI:invoke:C: current :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"current":rec:current 
 -- formalArg:isPtn: "in objx: ref Object" :isBasicVal: false :valueObj: false 
 -- :actArg: "current" :isBasicVal: false 
 -- case:B: current ObjectGenerator 64 0 64 false false 
 -- end:loadArgs:NonVirt: "== current" 
 -- BinaryExp:loadArgs:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"elm":rec:elm 
 -- INV:gen:after:E.loadArgs "elm == current" 
 -- OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"elm":rec:elm 
 -- IV:E.invoke:useRtnVal: true E: BinOp "elm == current" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"elm":rec:elm 
 -- $BinOp:invoke: "elm == current"  
 -- BinaryExp:invoke: "elm" rec: "elm == current" 
 -- M: "== current" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"elm":rec:elm 
 -- $ObjectInvocation_Binary:invoke: "== current" >rec:"elm" ATd:"pattern" E:"== current" E.ATd:"==  " unique:"False" 
 -- OI:invoke: "== current" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"elm":rec:elm 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"elm":rec:elm 
 -- OI:invoke:B: "== current" E: "== current"  rec: "elm"  useRtnV: true "==  : {   %basic 56;   in objx: ref Object;   out V: var boolean}" 
 -- OI:invoke:before:ATdx.invoke: pattern ==   
 -- $pattern:invoke: "==  : {   %basic 56;   in objx: ref Object;   out V: var boolean" E: "== current" useRTNv: "True"} 
 -- ptn:invoke: "==  " E: "== current" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "elm" E: "== current" 
 -- arg:other 
 req
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"== current":rec:elm 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"== current":rec:elm 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: == current :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: "--"Queue:has:elm\n".printB := true{   leave(has)" >OGid:"$159" singular! staticOff=0 descNo=159 superAdj=0} 
 -- OG:gen: "--"Queue:has:elm\n".printB := true{   leave(has)}" 
 pushThis 
 -- before objTmpStack:add:  159   "$159" 
 invoke $159 159 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:4 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 159 
 -- Items:GenClass: $159 descNo: 159 isValue: false 
 -- Items:GenClass: $159 descNo: 21 isValue: false 

 CLASS $159 159 1 scan$158 158
 -- Store itemArgs: --"Queue:has:elm\n".printB := true{leave(has)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=159 vDescInx=159 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "B := true" 
 -- $Assign:gen: "B := true"  
 -- assign: "B := true" 
 -- computeAdr:superAdj: 0 "B" 
 -- computeAdr: 1 :rec: "none"  E: "B" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "B"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "B" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$159" on: 2 isValueObj: false 
 -- origin: scan$158 origin:isValueObj: false 
 rpushg $159$159 1
 -- items:goOrigin:encOG: "scan$158" on: 1 isValueObj: false 
 -- origin: has origin:isValueObj: false 
 rpushg scan$158$158 4
 -- $ObjectInvocation_Unary:getAdr: "B" >ATd.off:3:on:2:superAdj:0"out B: var Boolean":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "out B: var Boolean" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F o ... 
 -- DI:OG: Boolean 
 -- before:floatTest:  "out B: var Boolean" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "B"  ATd: "out B: var Boolean" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- computeAdr:isLast:E:  "B" 
 -- AssignmentStatement:gen: "B := true" right.label: "ObjectGenerator" "true" 
 -- $ObjectGenerator:gen: "true" >OGid:"True" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "true" 
 -- OG:before:super.gen: "true" 
 -- $Invocation:gen: "true" >useRtnV:"True"superAdj: 0 descNo: 23 
 -- INV:gen: "true" 
 -- isConstant: "Invocation" "true" 
 -- needorigin: "true" 
 -- needOrigin:E: "true"  E.ATd: "True: {   %globals;   out B: var boolean;   B := 1}" 
 -- Ex:loadOrign:no:loadOrigin:  "%globals{   out B: var boolean;   B := 1}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "true" E:  "true" 
 -- INV:gen:E.loadArgs "true" 
 -- $ObjectInvocation_Unary:loadArgs: "true" >staticOff:0 "True: {   %globals;   out B: var boolean;   B := 1" superAdj:0} 
 -- $pattern:loadArgs: "True: {   %globals;   out B: var boolean;   B := 1" >E:"true":descNo:23} 
 -- ptn:loadArgs:E "true" 
 -- {(ObjectInvocation_Unary; (name: "true"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "true" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "true" 
 -- $ObjectInvocation_Unary:invoke: "true" >rec:"true" ATd:"pattern" E:"true" E.ATd:"True" unique:"False" 
 -- OI:invoke: "true" 
 -- 
 -- OI:invoke:B: "true" E: "true"  rec: "true"  useRtnV: true "True: {   %globals;   out B: var boolean;   B := 1}" 
 -- OI:invoke:before:ATdx.invoke: pattern True 
 -- $pattern:invoke: "True: {   %globals;   out B: var boolean;   B := 1" E: "true" useRTNv: "True"} 
 -- ptn:invoke: "True" E: "true" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke True 23 0 0
 -- global:pushOut: B off: 1 
 pushg 1 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 1 
 -- GeneralPTN:invoke:after:callInvoke: 1 
 -- OI:invoke:V: adrx: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: true :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "B" dstE: "B" dstE.ATd: "out B: var Boolean" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right: "true" 
 -- isArgOfAssignI2IwithUniValArg "B := true" arg: "true" ObjectGenerator 
 -- arg.super.arg: "true" ObjectInvocation_Unary 
 -- dstDI: "out B: var Boolean" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg has$154 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "leave(has)" 
 -- $ObjectGenerator:gen: "leave(has)" >OGid:"leave" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "leave(has)" 
 -- OG:before:super.gen: "leave(has)" 
 -- $Invocation:gen: "leave(has)" >useRtnV:"False"superAdj: 0 descNo: 19 
 -- INV:gen: "leave(has)" 
 -- isConstant: "Invocation" "leave(has)" 
 -- needorigin: "leave(has)" 
 -- needOrigin:E: "leave(has)"  E.ATd: "leave(V: var integer): {   %basic 103}" 
 -- doNeedOrigin:Ex: "leave(has)" 
 -- computeAdr:superAdj: 0 "leave(has)" 
 -- computeAdr: 1 :rec: "none"  E: "leave(has)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "leave(has)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "leave(has)" >on:6 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "leave(has)" >ATd.off:0 (isPtn):on:6:superAdj:0"leave(V: var integer): {   %basic 103":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0  ...} 
 -- $pattern:getAdr: "leave(V: var integer): {   %basic 103" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(has)":rec:- 
 -- E.on: 6 
 -- beforeIsValueObj:E: "leave(has)"  ATd: "leave(V: var integer): {   %basic 103}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(has)":rec:- 
 -- computeAdr:isLast:E:  "leave(has)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(has)":rec:- 
 -- rec:  "leave(has)" E:  "leave(has)" 
 -- INV:gen:E.loadArgs "leave(has)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "leave(has)" >staticOff:0 "leave(V: var integer): {   %basic 103" superAdj:0arg:"has"} 
 -- $pattern:loadArgs: "leave(V: var integer): {   %basic 103" >E:"leave(has)":descNo:19} 
 -- INV:gen:after:E.loadArgs "leave(has)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "leave(has)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(has) ..." 
 -- $ObjectInvocation_KeyWord:invoke: "leave(has)" >rec:"leave(has)" ATd:"pattern" E:"leave(has)" E.ATd:"leave(V: var integer)" unique:"False" 
 -- OI:invoke: "leave(has)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(has)":rec:leave(has) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(has)":rec:leave(has) 
 -- OI:invoke:B: "leave(has)" E: "leave(has)"  rec: "leave(has)"  useRtnV: false "leave(V: var integer): {   %basic 103}" 
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- $pattern:invoke: "leave(V: var integer): {   %basic 103" E: "leave(has)" useRTNv: "False"} 
 -- ptn:invoke: "leave(V: var integer)" E: "leave(has)" ptnKind: 0 useRtnV: false 
 break  2 2 154 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(has)":rec:leave(has) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(has)":rec:leave(has) 
 -- 
 -- OI:invoke:C: leave(has) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(has)":rec:leave(has) 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 141 
 -- Items:GenClass: $141 descNo: 141 isValue: false 
 -- Items:GenClass: $141 descNo: 21 isValue: false 

 CLASS $141 141 1 insert 139
 -- Store itemArgs: Q.insert(P) 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=141 vDescInx=141 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "Q.insert(P)" 
 -- $ObjectGenerator:gen: "Q.insert(P)" >OGid:"insert" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "Q.insert(P)" 
 -- OG:before:super.gen: "Q.insert(P)" 
 -- $Invocation:gen: "Q.insert(P)" >useRtnV:"False"superAdj: 0 descNo: 142 
 -- INV:gen: "Q.insert(P)" 
 -- isConstant: "Invocation" "Q.insert(P)" 
 -- needorigin: "Q.insert(P)" 
 -- needOrigin:E: "insert(P)"  E.ATd: "insert: {   in elm: ref Object;   E: ref Element;   b: var BOOLEAN;   B := ELM =/= NONE;   --if (has(elm)) :then;   --    "insert:leave\ ..."}" 
 -- doNeedOrigin:Ex: "insert(P)" 
 -- computeAdr:superAdj: 0 "Q.insert(P)" 
 -- computeAdr: 1 :rec: "none"  E: "Q" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Q"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Q" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$141" on: 2 isValueObj: false 
 -- origin: insert origin:isValueObj: false 
 rpushg $141$141 1
 -- items:goOrigin:encOG: "insert" on: 1 isValueObj: false 
 -- origin: SQS origin:isValueObj: false 
 rpushg insert$139 1
 -- $ObjectInvocation_Unary:getAdr: "Q" >ATd.off:2:on:2:superAdj:0"Q: obj ProcessQueue":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F: ... 
 -- $obj:getAdr: "Q: obj ProcessQueue" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValu ... 
 -- E.on: 2 
 -- beforeIsValueObj:E: "Q"  ATd: "Q: obj ProcessQueue" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "Q"  E: "insert(P)" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:getAdr: "insert(P)" >ATd.off:0 (isPtn):on:0:superAdj:0"insert: {   in elm: ref Object;   E: ref Element;   b: var BOOLEAN;   B := ELM =/= NONE;   ..."} 
 -- $pattern:getAdr: "insert: {   in elm: ref Object;   E: ref Element;   b: var BOOLEAN;   B := ELM =/= NONE;   --if (has(elm)) :then;   --    "insert:leave\n".print;   --    ..."} 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(P)":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "Q" >staticOff:0 "Q: obj ProcessQueue" superAdj:0 
 -- $obj:loadArgs: "Q: obj ProcessQueue" >E:"Q" 
 -- $pattern:loadArgs: "ProcessQueue: LIB.Collections.QueueLib.Queue{   %Public;   displayx: ;      put('Q')" >E:"Q":descNo:79} 
 -- ptn:loadArgs:E "Q" 
 -- {(ObjectInvocation_Unary; (name: "Q"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "Q" >rec:"Q" ATd:"obj" E:"insert(P)" E.ATd:"insert" unique:"False" 
 -- OI:invoke: "Q" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(P)":rec:Q 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(P)":rec:Q 
 -- OI:invoke:B: "Q" E: "insert(P)"  rec: "Q"  useRtnV: true "Q: obj ProcessQueue" 
 -- OI:invoke:before:ATdx.invoke: obj Q 
 -- $obj:invoke: "Q: obj ProcessQueue" E: "insert(P)">newOff:2 useRTNv: "True" 
 -- DI:invoke: "Q: obj ProcessQueue" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(P)":rec:Q 
 rpushg $141$141 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(P)":rec:Q 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(P)":rec:Q 
 -- 
 -- OI:invoke:C: Q :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "Q" E: "insert(P)" 
 -- arg:other 
 -- computeAdr:isLast:E:  "insert(P)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(P)":rec:Q 
 -- rec:  "Q" E:  "insert(P)" 
 -- INV:gen:E.loadArgs "insert(P)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "insert(P)" >staticOff:0 "insert: {   in elm: ref Object;   E: ref Element;   b: var BOOLEAN;   B := ELM =/= NONE;   --if (has(elm)) :t ..."} 
 -- $pattern:loadArgs: "insert: {   in elm: ref Object;   E: ref Element;   b: var BOOLEAN;   B := ELM =/= NONE;   --if (has(elm)) :then;   --    "insert:leave\n".print;   --  ..."} 
 -- ptn:loadArgs:E "insert(P)" 
 -- {(ObjectInvocation_KeyWord; (name: "insert"); (Arguments;  (name: "insert");  (name: "(");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "P");   ...} 
 -- args: "insert(P)" 
 -- E: "ObjectGenerator" P 
 -- E.arg: "ref" in elm: ref Object 
 -- NonVirt: "insert(P)" "ObjectInvocation_KeyWord" ActArg:  "P" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "insert(P)"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "P" >OGid:"BasicProcess" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "P" 
 -- OG:before:super.gen: "P" 
 -- $Invocation:gen: "P" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "P" 
 -- isConstant: "Invocation" "P" 
 -- notConst: P in P: ref BasicProcess 
 -- needorigin: "P" 
 -- needOrigin:E: "P"  E.ATd: "in P: ref BasicProcess" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "P" 
 -- computeAdr: 1 :rec: "none"  E: "P" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "P"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "P" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$141" on: 1 isValueObj: false 
 -- origin: insert origin:isValueObj: false 
 rpushg $141$141 1
 -- $ObjectInvocation_Unary:getAdr: "P" >ATd.off:2:on:1:superAdj:0"in P: ref BasicProcess":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ... 
 -- $ref:getAdr: "in P: ref BasicProcess" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "P"  ATd: "in P: ref BasicProcess" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "P" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "P" E:  "P" 
 -- INV:gen:E.loadArgs "P" 
 -- $ObjectInvocation_Unary:loadArgs: "P" >staticOff:0 "in P: ref BasicProcess" superAdj:0 
 -- $ref:loadArgs: "in P: ref BasicProcess" >E:"P" 
 -- $pattern:loadArgs: "BasicProcess: GeneralProcess{   mkActive::< ;      status := p_status.ACTIVE;      SQS.insert(this(BasicProcess));   %Public;   start::<  -- need id as ..."} 
 -- ptn:loadArgs:E "P" 
 -- {(ObjectInvocation_Unary; (name: "P"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "P" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "P" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "P" >rec:"P" ATd:"ref" E:"P" E.ATd:"P" unique:"False" 
 -- OI:invoke: "P" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:P 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:P 
 -- OI:invoke:B: "P" E: "P"  rec: "P"  useRtnV: true "in P: ref BasicProcess" 
 -- OI:invoke:before:ATdx.invoke: ref P 
 -- $ref:invoke: "in P: ref BasicProcess" E: "P">newOff:2 useRTNv: "True" 
 -- DI:invoke: "in P: ref BasicProcess" 
 -- >Object:unique: false 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"P":rec:P 
 -- isCompositeValueObj: false E: "P" "in P: ref BasicProcess" false 
 -- E.ATd.isValueObj: false rec: "P" 
 rpushg insert$139 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"P":rec:P 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"P":rec:P 
 -- 
 -- OI:invoke:C: P :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"P":rec:P 
 -- formalArg:isPtn: "in elm: ref Object" :isBasicVal: false :valueObj: false 
 -- :actArg: "P" :isBasicVal: false 
 -- case:B: P ObjectGenerator 64 0 0 false false 
 -- end:loadArgs:NonVirt: "insert(P)" 
 -- INV:gen:after:E.loadArgs "insert(P)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "insert(P)" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(P)": ... 
 -- $ObjectInvocation_KeyWord:invoke: "insert(P)" >rec:"Q" ATd:"pattern" E:"insert(P)" E.ATd:"insert" unique:"False" 
 -- OI:invoke: "insert(P)" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(P)":rec:Q 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(P)":rec:Q 
 -- OI:invoke:B: "insert(P)" E: "insert(P)"  rec: "Q"  useRtnV: false "insert: {   in elm: ref Object;   E: ref Element;   b: var BOOLEAN;   B := ELM =/= NONE;   --if (has(elm ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern insert 
 -- $pattern:invoke: "insert: {   in elm: ref Object;   E: ref Element;   b: var BOOLEAN;   B := ELM =/= NONE;   --if (has(elm)) :then;   --    "insert:leave\n".print;   --    ..."} 
 -- ptn:invoke: "insert" E: "insert(P)" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(P)":rec:Q 
 invoke insert 142 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(P)":rec:Q 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(P)":rec:Q 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: insert(P) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(P)":rec:Q 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 142 
 -- Items:GenClass: insert descNo: 142 isValue: false 
 -- Items:GenClass: insert descNo: 21 isValue: false 

 CLASS insert 142 1 Queue 78
 -- Store itemArgs: in elm: ref Object{E: ref Element;b: var BOOLEAN;B := ELM =/= NONE;--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert);if (B) :then ;    ...} 
 -- in elm: ref Object true 64 
 -- DI:store: "elm" 
 pushThis 
 rstoreg  elm 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=142 vDescInx=142 vdtTop: 1 
 mvStack 
 -- $ref:gen: "in elm: ref Object"  
 -- DI:gen: "in elm: ref Object" DI:isConst: false :isBasicValue: false :primNo: 64 
 -- $ref:gen: "E: ref Element"  
 -- DI:gen: "E: ref Element" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- $var:gen: "b: var BOOLEAN"  
 -- DI:gen: "b: var BOOLEAN" DI:isConst: false :isBasicValue: true :primNo: 4 
 -- DI:add:BP1:  b 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "B := ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- $Assign:gen: "B := ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)" } 
 -- assign: "B := ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- computeAdr:superAdj: 0 "B" 
 -- computeAdr: 1 :rec: "none"  E: "B" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "B"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "B" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "B" >ATd.off:4:on:0:superAdj:0"b: var BOOLEAN":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "b: var BOOLEAN" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: BOOLEAN 
 -- before:floatTest:  "b: var BOOLEAN" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- computeAdr:isLast:E:  "B" 
 -- AssignmentStatement:gen: "B := ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" right.label: "ObjectGenerator" "ELM =/= NONE{--if (has ...}" 
 -- $ObjectGenerator:gen: "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)" >OGid:"=/=" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- OG:before:super.gen: "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- $Invocation:gen: "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)" >useRtnV:"True"superAdj: 0} 
 -- INV:gen: "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- isConstant: "Invocation" "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- needorigin: "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- needOrigin:E: "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}"  E.ATd: "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boo ...}" 
 -- doNeedOrigin:Ex: "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- computeAdr:superAdj: 0 "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- computeAdr: 1 :rec: "none"  E: "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)" } 
 -- $BinOp:loadOrigin: "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)" } 
 -- BinaryExp:loadOrigin:empty: "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" superAdj: 0 
 -- $BinOp:getAdr: "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)" } 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" E:  "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    lea ...}" 
 -- INV:gen:E.loadArgs "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- $BinOp:loadArgs: "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)" } 
 -- BinaryExp:loadArgs: "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" superAdj: 0 
 -- $Invocation:gen: "ELM" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "ELM" 
 -- isConstant: "Invocation" "ELM" 
 -- notConst: ELM in elm: ref Object 
 -- needorigin: "ELM" 
 -- needOrigin:E: "ELM"  E.ATd: "in elm: ref Object" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "ELM" 
 -- computeAdr: 1 :rec: "none"  E: "ELM" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "ELM"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "ELM" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "ELM" >ATd.off:2:on:0:superAdj:0"in elm: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F ... 
 -- $ref:getAdr: "in elm: ref Object" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue ... 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "ELM" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "ELM" E:  "ELM" 
 -- INV:gen:E.loadArgs "ELM" 
 -- $ObjectInvocation_Unary:loadArgs: "ELM" >staticOff:0 "in elm: ref Object" superAdj:0 
 -- $ref:loadArgs: "in elm: ref Object" >E:"ELM" 
 -- $pattern:loadArgs: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic 57; ..."} 
 -- ptn:loadArgs:E "ELM" 
 -- {(ObjectInvocation_Unary; (name: "ELM"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "ELM" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "ELM" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "ELM" >rec:"ELM" ATd:"ref" E:"ELM" E.ATd:"elm" unique:"False" 
 -- OI:invoke: "ELM" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:ELM 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:ELM 
 -- OI:invoke:B: "ELM" E: "ELM"  rec: "ELM"  useRtnV: true "in elm: ref Object" 
 -- OI:invoke:before:ATdx.invoke: ref elm 
 -- $ref:invoke: "in elm: ref Object" E: "ELM">newOff:2 useRTNv: "True" 
 -- DI:invoke: "in elm: ref Object" 
 -- >Object:unique: false 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"ELM":rec:ELM 
 -- isCompositeValueObj: false E: "ELM" "in elm: ref Object" false 
 -- E.ATd.isValueObj: false rec: "ELM" 
 rpushg insert$142 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"ELM":rec:ELM 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"ELM":rec:ELM 
 -- 
 -- OI:invoke:C: ELM :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"ELM":rec:ELM 
 -- $pattern:loadArgs: "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean" >E:"=/= NONE;--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)" ...} 
 -- ptn:loadArgs:E "=/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- {(ObjectInvocation_Binary; (name: "=/="); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "NONE");     (Arguments --<12>if (has(elm))  ...} 
 -- args: "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- E: "ObjectGenerator" NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)} 
 -- E.arg: "ref" in objx: ref Object 
 -- NonVirt: "=/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" "ObjectInvocation_Binary" ActArg:  "NONE{--if (has(elm)) :then;--    "insert:le ..."}" i ... false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "=/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)" >OGid:"none" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- OG:before:super.gen: "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- $Invocation:gen: "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)" >useRtnV:"True"superAdj: 0 descNo: 116} 
 -- INV:gen: "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- isConstant: "Invocation" "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- needorigin: "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- needOrigin:E: "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}"  E.ATd: "none: {   %basic 19;   none_x: var integer}" 
 -- doNeedOrigin:Ex: "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- computeAdr:superAdj: 0 "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- computeAdr: 1 :rec: "none"  E: "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)" } 
 -- $ObjectInvocation_Unary:loadOrigin: "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)" >on:4 superAdj:0 isValueObj:"False"} 
 -- $ObjectInvocation_Unary:getAdr: "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)" >ATd.off:0 (isPtn):on:4:superAdj:0"none: ;   %basic 19;   non ..."} 
 -- $pattern:getAdr: "none: {   %basic 19;   none_x: var integer" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)":rec ...} 
 -- E.on: 4 
 -- beforeIsValueObj:E: "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}"  ATd: "none: {   %basic 19;   none_x: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--   ..."} 
 -- computeAdr:isLast:E:  "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"NONE{--if (has(elm)) :then;--    "insert:leave\n ...} 
 -- rec:  "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" E:  "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- INV:gen:E.loadArgs "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- $ObjectInvocation_Unary:loadArgs: "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)" >staticOff:0 "none: ;   %basic 19;   none_x: var integer" s ...} 
 -- $pattern:loadArgs: "none: {   %basic 19;   none_x: var integer" >E:"NONE;--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)":descNo:116} 
 -- ptn:loadArgs:E "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- {(ObjectInvocation_Unary; (name: "NONE"); (Arguments --<12>if (has(elm)) :then;<12>    "insert:leave\n".print;<12>    leave(insert)))} 
 -- args: "--if (has(elm)) :then{--    "insert:leave\n".print;--    leave(insert)}" 
 -- INV:gen:after:E.loadArgs "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" :Adr:off:0 size:0 isFloat:F isUnitVal: ... 
 -- $ObjectInvocation_Unary:invoke: "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)" >rec:"NONE;--if (has(elm)) :then;--    "insert:leave\n".print ..."} 
 -- OI:invoke: "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)":rec ...} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)":rec ...} 
 -- OI:invoke:B: "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" E: "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert) ...}"   ... "N ..."   ... true "n ..." 
 -- OI:invoke:before:ATdx.invoke: pattern none 
 -- $pattern:invoke: "none: {   %basic 19;   none_x: var integer" E: "NONE;--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)" useRTNv: "True"} 
 -- ptn:invoke: "none" E: "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" ptnKind: 0 useRtnV: true 
 pushNone 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--     ..."} 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--     ..."} 
 -- 
 -- OI:invoke:C: NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)} :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave( ..."} 
 -- formalArg:isPtn: "in objx: ref Object" :isBasicVal: false :valueObj: false 
 -- :actArg: "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" :isBasicVal: false 
 -- case:B: NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)} ObjectGenerator 64 19 19 false false 
 -- end:loadArgs:NonVirt: "=/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- BinaryExp:loadArgs:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"ELM":rec:ELM 
 -- INV:gen:after:E.loadArgs "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"ELM":rec:ELM 
 -- IV:E.invoke:useRtnVal: true E: BinOp "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAd ... 
 -- $BinOp:invoke: "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)" } 
 -- BinaryExp:invoke: "ELM" rec: "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- M: "=/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ... 
 -- $ObjectInvocation_Binary:invoke: "=/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)" >rec:"ELM" ATd:"pattern" E:"=/= NONE;--if (has(elm)) :th ..."} 
 -- OI:invoke: "=/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"ELM":rec:ELM 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"ELM":rec:ELM 
 -- OI:invoke:B: "=/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" E: "=/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave ...}"   ... "E ..."   ... true "= ..." 
 -- OI:invoke:before:ATdx.invoke: pattern =/=   
 -- $pattern:invoke: "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean" E: "=/= NONE;--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)" u ...} 
 -- ptn:invoke: "=/=  " E: "=/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "ELM" E: "=/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- arg:other 
 rne
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"=/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;-- ..."} 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"=/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;-- ..."} 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)} :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "B" dstE: "B" dstE.ATd: "b: var BOOLEAN" useRtn: false :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right: "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- isArgOfAssignI2IwithUniValArg "B := ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" arg: "ELM =/= NONE{--if (has(elm)) :then;--    "i ..."}" O ... 
 -- arg.super.arg: "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" BinOp 
 -- recx:BinaryExp:recx: "ELM =/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- M: "=/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" label: "ObjectInvocation_Binary" M.ATd: "=/=  : {   %basic 57;   in objx: ref Object; ...}" 
 -- checkInt2IntWithUnitArg:rec: "ELM" E: "=/= NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" 
 -- arg:other 
 -- M:arg: "NONE{--if (has(elm)) :then;--    "insert:leave\n".print;--    leave(insert)}" ObjectGenerator false 
 -- dstDI: "b: var BOOLEAN" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg insert$142 4
 -- assign:adr.store:B: 
 -- genclass:stmt: "if (B) :then {   E := Element(elm);   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head;   :else ;      E.succ := head; ...}" 
 -- $ObjectGenerator:gen: "if (B) :then {   E := Element(elm);   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head;   :else ;      E.succ : ..."} 
 -- OG:gen: "if (B) :then {   E := Element(elm);   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head;   :else ;      E.succ := head;      h ...}" 
 -- OG:before:super.gen: "if (B) :then {   E := Element(elm);   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head;   :else ;      E.succ := ...}" 
 -- $Invocation:gen: "if (B) :then {   E := Element(elm);   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head;   :else ;      E.succ := hea ..."} 
 -- INV:gen: "if (B) :then {   E := Element(elm);   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head;   :else ;      E.succ := head;       ...}" 
 -- isConstant: "Invocation" "if (B) :then {   E := Element(elm);   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head;   :else ;      E.suc ...}" 
 -- needorigin: "if (B) :then {   E := Element(elm);   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head;   :else ;      E.succ := head;    ...}" 
 -- needOrigin:E: "if (B) :then {   E := Element(elm);   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head;   :else ;      E.succ := head;  ...}"   ... "i ..." 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (B) :then {   E := Element(elm);   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head;   :else ;      E.succ := head;      hea ...}" E ... "i ..." 
 -- INV:gen:E.loadArgs "if (B) :then {   E := Element(elm);   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head;   :else ;      E.succ := h ...}" 
 -- $IfThen:loadArgs: "if (B) :then {   E := Element(elm);   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head;   :else ;      E.succ := he ..."} 
 -- INV:gen:after:E.loadArgs "if (B) :then {   E := Element(elm);   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head;   :else ;      E.suc ...}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (B) :then {   E := Element(elm);   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head;   :els ...}" 
 -- $IfThen:invoke: "if (B) :then {   E := Element(elm);   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head;   :else ;      E.succ := head ..."} 
 -- $IfThen:gen: "if (B) :then {   E := Element(elm);   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head;   :else ;      E.succ := head;   ..."} 
 -- $ObjectGenerator:gen: "(B)" >OGid:"Boolean" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(B)" 
 -- OG:before:super.gen: "(B)" 
 -- $Invocation:gen: "(B)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(B)" 
 -- isConstant: "Invocation" "(B)" 
 -- notConst: (B) b: var BOOLEAN 
 -- needorigin: "(B)" 
 -- needOrigin:E: "(B)"  E.ATd: "b: var BOOLEAN" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "(B)" 
 -- computeAdr: 1 :rec: "none"  E: "(B)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(B)"  
 -- $BracketedExp:loadOrigin: "(B)"  
 -- computeAdr:superAdj: 0 "B" 
 -- computeAdr: 1 :rec: "none"  E: "B" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "B"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "B" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "B" >ATd.off:4:on:0:superAdj:0"b: var BOOLEAN":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "b: var BOOLEAN" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: BOOLEAN 
 -- before:floatTest:  "b: var BOOLEAN" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- computeAdr:isLast:E:  "B" 
 -- BE:loadOrigin:E: B 
 -- $ObjectInvocation_Unary:getAdr: "B" >ATd.off:4:on:0:superAdj:0"b: var BOOLEAN":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "b: var BOOLEAN" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: BOOLEAN 
 -- before:floatTest:  "b: var BOOLEAN" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- computeAdr:isLast:E:  "B" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- rec:  "B" E:  "B" 
 -- INV:gen:E.loadArgs "B" 
 -- $ObjectInvocation_Unary:loadArgs: "B" >staticOff:0 "b: var BOOLEAN" superAdj:0 
 -- $var:loadArgs: "b: var BOOLEAN" >E:"B" 
 -- $pattern:loadArgs: "Boolean: value{   %id "Boolean";   %globals inSub;   %basic 4, 8;   %public;   _thisBasicValue: var Universal;   &&  : ;      %basic 70;      in B: var ..."} 
 -- ptn:loadArgs:E "B" 
 -- {(ObjectInvocation_Unary; (name: "B"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "B" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "B" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- $ObjectInvocation_Unary:invoke: "B" >rec:"B" ATd:"var" isValueObj E:"B" E.ATd:"b" unique:"False" 
 -- OI:invoke: "B" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:B 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:B 
 -- OI:invoke:B: "B" E: "B"  rec: "B"  useRtnV: true "b: var BOOLEAN" 
 -- OI:invoke:before:ATdx.invoke: var b 
 -- $var:invoke: "b: var BOOLEAN" E: "B">newOff:4 useRTNv: "True" 
 -- DI:invoke: "b: var BOOLEAN" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:B 
 -- isCompositeValueObj: false E: "B" "b: var BOOLEAN" true 
 -- E.ATd.isValueObj: false rec: "B" 
 pushg 4 insert$142
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:B 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:B 
 -- 
 -- OI:invoke:C: B :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:B 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: "E := Element(elm){   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head;   :else ;      E.succ := head;      head ..."} 
 -- OG:gen: "E := Element(elm){   noOfElm := noOfElm + 1;   if (head == none) :then ;      head := E;      last := head;   :else ;      E.succ := head;      head.pred := E;    ...}" 
 pushThis 
 -- before objTmpStack:add:  143   "$143" 
 invoke $143 143 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 -- pushReturn:  "insert" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 143 
 -- Items:GenClass: $143 descNo: 143 isValue: false 
 -- Items:GenClass: $143 descNo: 21 isValue: false 

 CLASS $143 143 1 insert 142
 -- Store itemArgs: E := Element(elm){noOfElm := noOfElm + 1;if (head == none) :then ;   head := E;   last := head;:else ;   E.succ := head;   head.pred := E;   head := E;   - ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=143 vDescInx=143 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "E := Element(elm)" 
 -- $Assign:gen: "E := Element(elm)"  
 -- assign: "E := Element(elm)" 
 -- computeAdr:superAdj: 0 "E" 
 -- computeAdr: 1 :rec: "none"  E: "E" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "E"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "E" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$143" on: 1 isValueObj: false 
 -- origin: insert origin:isValueObj: false 
 rpushg $143$143 1
 -- $ObjectInvocation_Unary:getAdr: "E" >ATd.off:3:on:1:superAdj:0"E: ref Element":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $ref:getAdr: "E: ref Element" >newOff:3,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F o ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "E"  ATd: "E: ref Element" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "E" 
 -- AssignmentStatement:gen: "E := Element(elm)" right.label: "ObjectGenerator" "Element(elm)" 
 -- $ObjectGenerator:gen: "Element(elm)" >OGid:"Element" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "Element(elm)" 
 -- OG:before:super.gen: "Element(elm)" 
 -- $Invocation:gen: "Element(elm)" >useRtnV:"True"superAdj: 0 descNo: 137 
 -- INV:gen: "Element(elm)" 
 -- isConstant: "Invocation" "Element(elm)" 
 -- needorigin: "Element(elm)" 
 -- needOrigin:E: "Element(elm)"  E.ATd: "Element: {   in elm: ref Object;   out res: ref Element;   id: var integer;   pred: ref Element;   succ: ref Element;   res := this(E ...}" 
 -- doNeedOrigin:Ex: "Element(elm)" 
 -- computeAdr:superAdj: 0 "Element(elm)" 
 -- computeAdr: 1 :rec: "none"  E: "Element(elm)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "Element(elm)"  
 pushThis 
 -- $ObjectInvocation_KeyWord:loadOrigin: "Element(elm)" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$143" on: 2 isValueObj: false 
 -- origin: insert origin:isValueObj: false 
 rpushg $143$143 1
 -- items:goOrigin:encOG: "insert" on: 1 isValueObj: false 
 -- origin: Queue origin:isValueObj: false 
 rpushg insert$142 1
 -- $ObjectInvocation_KeyWord:getAdr: "Element(elm)" >ATd.off:0 (isPtn):on:2:superAdj:0"Element: {   in elm: ref Object;   out res: ref Element;   id: var integer;   pred: ref ..."} 
 -- $pattern:getAdr: "Element: {   in elm: ref Object;   out res: ref Element;   id: var integer;   pred: ref Element;   succ: ref Element;   res := this(Element);   idc := id ..."} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Element(elm)":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "Element(elm)"  ATd: "Element: {   in elm: ref Object;   out res: ref Element;   id: var integer;   pred: ref Element;   succ: ref Element;   res := th ...}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Element(elm)":rec:- 
 -- computeAdr:isLast:E:  "Element(elm)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Element(elm)":rec:- 
 -- rec:  "Element(elm)" E:  "Element(elm)" 
 -- INV:gen:E.loadArgs "Element(elm)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "Element(elm)" >staticOff:0 "Element: {   in elm: ref Object;   out res: ref Element;   id: var integer;   pred: ref Element;   succ: r ..."} 
 -- $pattern:loadArgs: "Element: {   in elm: ref Object;   out res: ref Element;   id: var integer;   pred: ref Element;   succ: ref Element;   res := this(Element);   idc :=  ..."} 
 -- ptn:loadArgs:E "Element(elm)" 
 -- {(ObjectInvocation_KeyWord; (name: "Element"); (Arguments;  (name: "Element");  (name: "(");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "elm" ...} 
 -- args: "Element(elm)" 
 -- E: "ObjectGenerator" elm 
 -- E.arg: "ref" in elm: ref Object 
 -- NonVirt: "Element(elm)" "ObjectInvocation_KeyWord" ActArg:  "elm" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "Element(elm)"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "elm" >OGid:"Object" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "elm" 
 -- OG:before:super.gen: "elm" 
 -- $Invocation:gen: "elm" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "elm" 
 -- isConstant: "Invocation" "elm" 
 -- notConst: elm in elm: ref Object 
 -- needorigin: "elm" 
 -- needOrigin:E: "elm"  E.ATd: "in elm: ref Object" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "elm" 
 -- computeAdr: 1 :rec: "none"  E: "elm" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "elm"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "elm" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$143" on: 1 isValueObj: false 
 -- origin: insert origin:isValueObj: false 
 rpushg $143$143 1
 -- $ObjectInvocation_Unary:getAdr: "elm" >ATd.off:2:on:1:superAdj:0"in elm: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F ... 
 -- $ref:getAdr: "in elm: ref Object" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "elm"  ATd: "in elm: ref Object" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "elm" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "elm" E:  "elm" 
 -- INV:gen:E.loadArgs "elm" 
 -- $ObjectInvocation_Unary:loadArgs: "elm" >staticOff:0 "in elm: ref Object" superAdj:0 
 -- $ref:loadArgs: "in elm: ref Object" >E:"elm" 
 -- $pattern:loadArgs: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic 57; ..."} 
 -- ptn:loadArgs:E "elm" 
 -- {(ObjectInvocation_Unary; (name: "elm"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "elm" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "elm" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "elm" >rec:"elm" ATd:"ref" E:"elm" E.ATd:"elm" unique:"False" 
 -- OI:invoke: "elm" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:elm 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:elm 
 -- OI:invoke:B: "elm" E: "elm"  rec: "elm"  useRtnV: true "in elm: ref Object" 
 -- OI:invoke:before:ATdx.invoke: ref elm 
 -- $ref:invoke: "in elm: ref Object" E: "elm">newOff:2 useRTNv: "True" 
 -- DI:invoke: "in elm: ref Object" 
 -- >Object:unique: false 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"elm":rec:elm 
 -- isCompositeValueObj: false E: "elm" "in elm: ref Object" false 
 -- E.ATd.isValueObj: false rec: "elm" 
 rpushg insert$142 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"elm":rec:elm 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"elm":rec:elm 
 -- 
 -- OI:invoke:C: elm :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"elm":rec:elm 
 -- formalArg:isPtn: "in elm: ref Object" :isBasicVal: false :valueObj: false 
 -- :actArg: "elm" :isBasicVal: false 
 -- case:B: elm ObjectGenerator 64 0 64 false false 
 -- end:loadArgs:NonVirt: "Element(elm)" 
 -- INV:gen:after:E.loadArgs "Element(elm)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "Element(elm)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Element(e ..." 
 -- $ObjectInvocation_KeyWord:invoke: "Element(elm)" >rec:"Element(elm)" ATd:"pattern" E:"Element(elm)" E.ATd:"Element" unique:"False" 
 -- OI:invoke: "Element(elm)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Element(elm)":rec:Element(elm) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Element(elm)":rec:Element(elm) 
 -- OI:invoke:B: "Element(elm)" E: "Element(elm)"  rec: "Element(elm)"  useRtnV: true "Element: {   in elm: ref Object;   out res: ref Element;   id: var integer;   pred: ref  ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Element 
 -- $pattern:invoke: "Element: {   in elm: ref Object;   out res: ref Element;   id: var integer;   pred: ref Element;   succ: ref Element;   res := this(Element);   idc := id ..."} 
 -- ptn:invoke: "Element" E: "Element(elm)" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Element(elm)":rec:Element(elm) 
 invoke Element 137 0 1
 -- global:pushOut: res off: 3 
 rpushg  3
 -- callInvoke:after:pushOut: 3 
 -- GeneralPTN:invoke:after:callInvoke: 3 
 -- GeneralPTN:invoke:end: 3 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Element(elm)":rec:Element(elm) 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Element(elm)":rec:Element(elm) 
 -- adrx: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Element(elm)":rec:Element(elm) 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Element(elm)":rec:Element(elm) 
 -- adrx: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Element(elm)":rec:Element(elm) 
 -- OI:invoke:C: Element(elm) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Element(elm)":rec:Element(elm) 
 -- rec: "E" dstE: "E" dstE.ATd: "E: ref Element" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- dstDI.isBasicVal: false dstDI.isValObj: false dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- isValue: false  isAdr: true  descNo:  0 
 rswap 0
 rstoreg  EisNone 3
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- assign:adr.store:B: 
 -- genclass:stmt: "noOfElm := noOfElm + 1" 
 -- $Assign:gen: "noOfElm := noOfElm + 1"  
 -- assign: "noOfElm := noOfElm + 1" 
 -- computeAdr:superAdj: 0 "noOfElm" 
 -- computeAdr: 1 :rec: "none"  E: "noOfElm" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "noOfElm"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "noOfElm" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$143" on: 2 isValueObj: false 
 -- origin: insert origin:isValueObj: false 
 rpushg $143$143 1
 -- items:goOrigin:encOG: "insert" on: 1 isValueObj: false 
 -- origin: Queue origin:isValueObj: false 
 rpushg insert$142 1
 -- $ObjectInvocation_Unary:getAdr: "noOfElm" >ATd.off:3:on:2:superAdj:0"noOfElm: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsV ... 
 -- $var:getAdr: "noOfElm: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: integer 
 -- before:floatTest:  "noOfElm: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "noOfElm"  ATd: "noOfElm: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:- 
 -- computeAdr:isLast:E:  "noOfElm" 
 -- AssignmentStatement:gen: "noOfElm := noOfElm + 1" right.label: "ObjectGenerator" "noOfElm + 1" 
 -- $ObjectGenerator:gen: "noOfElm + 1" >OGid:"+" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "noOfElm + 1" 
 -- OG:before:super.gen: "noOfElm + 1" 
 -- $Invocation:gen: "noOfElm + 1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "noOfElm + 1" 
 -- isConstant: "Invocation" "noOfElm + 1" 
 -- needorigin: "noOfElm + 1" 
 -- needOrigin:E: "noOfElm + 1"  E.ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- doNeedOrigin:Ex: "noOfElm + 1" 
 -- computeAdr:superAdj: 0 "noOfElm + 1" 
 -- computeAdr: 1 :rec: "none"  E: "noOfElm + 1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "noOfElm + 1"  
 -- $BinOp:loadOrigin: "noOfElm + 1"  
 -- BinaryExp:loadOrigin:empty: "noOfElm + 1" superAdj: 0 
 -- $BinOp:getAdr: "noOfElm + 1"  
 -- E.on: 2 
 -- beforeIsValueObj:E: "noOfElm + 1"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "noOfElm + 1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "noOfElm + 1" E:  "noOfElm + 1" 
 -- INV:gen:E.loadArgs "noOfElm + 1" 
 -- $BinOp:loadArgs: "noOfElm + 1"  
 -- BinaryExp:loadArgs: "noOfElm + 1" superAdj: 0 
 -- $Invocation:gen: "noOfElm" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "noOfElm" 
 -- isConstant: "Invocation" "noOfElm" 
 -- notConst: noOfElm noOfElm: var integer 
 -- needorigin: "noOfElm" 
 -- needOrigin:E: "noOfElm"  E.ATd: "noOfElm: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "noOfElm" 
 -- computeAdr: 1 :rec: "none"  E: "noOfElm" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "noOfElm"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "noOfElm" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$143" on: 2 isValueObj: false 
 -- origin: insert origin:isValueObj: false 
 rpushg $143$143 1
 -- items:goOrigin:encOG: "insert" on: 1 isValueObj: false 
 -- origin: Queue origin:isValueObj: false 
 rpushg insert$142 1
 -- $ObjectInvocation_Unary:getAdr: "noOfElm" >ATd.off:3:on:2:superAdj:0"noOfElm: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsV ... 
 -- $var:getAdr: "noOfElm: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: integer 
 -- before:floatTest:  "noOfElm: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "noOfElm"  ATd: "noOfElm: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:- 
 -- computeAdr:isLast:E:  "noOfElm" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:- 
 -- rec:  "noOfElm" E:  "noOfElm" 
 -- INV:gen:E.loadArgs "noOfElm" 
 -- $ObjectInvocation_Unary:loadArgs: "noOfElm" >staticOff:0 "noOfElm: var integer" superAdj:0 
 -- $var:loadArgs: "noOfElm: var integer" >E:"noOfElm" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "noOfElm" 
 -- {(ObjectInvocation_Unary; (name: "noOfElm"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "noOfElm" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "noOfElm" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:- 
 -- $ObjectInvocation_Unary:invoke: "noOfElm" >rec:"noOfElm" ATd:"var" isValueObj E:"noOfElm" E.ATd:"noOfElm" unique:"False" 
 -- OI:invoke: "noOfElm" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:noOfElm 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:noOfElm 
 -- OI:invoke:B: "noOfElm" E: "noOfElm"  rec: "noOfElm"  useRtnV: true "noOfElm: var integer" 
 -- OI:invoke:before:ATdx.invoke: var noOfElm 
 -- $var:invoke: "noOfElm: var integer" E: "noOfElm">newOff:3 useRTNv: "True" 
 -- DI:invoke: "noOfElm: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:noOfElm 
 -- isCompositeValueObj: false E: "noOfElm" "noOfElm: var integer" true 
 -- E.ATd.isValueObj: false rec: "noOfElm" 
 pushg 3 Queue$78
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:noOfElm 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:noOfElm 
 -- 
 -- OI:invoke:C: noOfElm :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- left:#I "noOfElm + 1" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:noOfElm 
 -- $pattern:loadArgs: "+  : {   %basic 61;   in V: var integer;   out R: var integer" >E:"+ 1":descNo:49} 
 -- ptn:loadArgs:E "+ 1" 
 -- {(ObjectInvocation_Binary; (name: "+"); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 1));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "1" 
 -- E: "ObjectGenerator" 1 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "+ 1" "ObjectInvocation_Binary" ActArg:  "1" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ 1"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "1" :isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "+ 1" 
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:noOfElm 
 -- INV:gen:after:E.loadArgs "noOfElm + 1" 
 -- OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:noOfElm 
 -- IV:E.invoke:useRtnVal: true E: BinOp "noOfElm + 1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:noOfElm 
 -- $BinOp:invoke: "noOfElm + 1"  
 -- BinaryExp:invoke: "noOfElm" rec: "noOfElm + 1" 
 -- M: "+ 1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:noOfElm 
 -- $ObjectInvocation_Binary:invoke: "+ 1" >rec:"noOfElm" ATd:"pattern" E:"+ 1" E.ATd:"+  " unique:"False" 
 -- OI:invoke: "+ 1" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:noOfElm 
 -- origin:isValueObj "integer" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:noOfElm 
 -- OI:invoke:B: "+ 1" E: "+ 1"  rec: "noOfElm"  useRtnV: true "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- $pattern:invoke: "+  : {   %basic 61;   in V: var integer;   out R: var integer" E: "+ 1" useRTNv: "True"} 
 -- ptn:invoke: "+  " E: "+ 1" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "noOfElm" E: "+ 1" 
 -- arg:integer 
 plus
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:noOfElm 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:noOfElm 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: + 1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "noOfElm" dstE: "noOfElm" dstE.ATd: "noOfElm: var integer" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"no ..." 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "noOfElm + 1" 
 -- isArgOfAssignI2IwithUniValArg "noOfElm := noOfElm + 1" arg: "noOfElm + 1" ObjectGenerator 
 -- arg.super.arg: "noOfElm + 1" BinOp 
 -- recx:BinaryExp:recx: "noOfElm + 1" 
 -- M: "+ 1" label: "ObjectInvocation_Binary" M.ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- checkInt2IntWithUnitArg:rec: "noOfElm" E: "+ 1" 
 -- arg:integer 
 -- M:arg: "1" ObjectGenerator false 
 -- dstDI: "noOfElm: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg Queue$78 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "if (head == none) :then {   head := E;   last := head;:else ;   E.succ := head;   head.pred := E;   head := E;   --"insert:".print;   --idf.print;   --puti ...}" 
 -- $ObjectGenerator:gen: "if (head == none) :then {   head := E;   last := head;:else ;   E.succ := head;   head.pred := E;   head := E;   --"insert:".print;   --idf.print;   ..."} 
 -- OG:gen: "if (head == none) :then {   head := E;   last := head;:else ;   E.succ := head;   head.pred := E;   head := E;   --"insert:".print;   --idf.print;   --putint(noOf ...}" 
 -- OG:before:super.gen: "if (head == none) :then {   head := E;   last := head;:else ;   E.succ := head;   head.pred := E;   head := E;   --"insert:".print;   --idf.print;    ...}" 
 -- $Invocation:gen: "if (head == none) :then {   head := E;   last := head;:else ;   E.succ := head;   head.pred := E;   head := E;   --"insert:".print;   --idf.print;   --pu ..."} 
 -- INV:gen: "if (head == none) :then {   head := E;   last := head;:else ;   E.succ := head;   head.pred := E;   head := E;   --"insert:".print;   --idf.print;   --putint(noO ...}" 
 -- isConstant: "Invocation" "if (head == none) :then {   head := E;   last := head;:else ;   E.succ := head;   head.pred := E;   head := E;   --"insert:".print;   --idf.print ...}" 
 -- needorigin: "if (head == none) :then {   head := E;   last := head;:else ;   E.succ := head;   head.pred := E;   head := E;   --"insert:".print;   --idf.print;   --putint( ...}" 
 -- needOrigin:E: "if (head == none) :then {   head := E;   last := head;:else ;   E.succ := head;   head.pred := E;   head := E;   --"insert:".print;   --idf.print;   --putin ...}"   ... "i ..." 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (head == none) :then {   head := E;   last := head;:else ;   E.succ := head;   head.pred := E;   head := E;   --"insert:".print;   --idf.print;   --putint(noOfEl ...}" E ... "i ..." 
 -- INV:gen:E.loadArgs "if (head == none) :then {   head := E;   last := head;:else ;   E.succ := head;   head.pred := E;   head := E;   --"insert:".print;   --idf.print;   -- ...}" 
 -- $IfThenElse:loadArgs: "if (head == none) :then {   head := E;   last := head;:else ;   E.succ := head;   head.pred := E;   head := E;   --"insert:".print;   --idf.print;   ..."} 
 -- INV:gen:after:E.loadArgs "if (head == none) :then {   head := E;   last := head;:else ;   E.succ := head;   head.pred := E;   head := E;   --"insert:".print;   --idf.print ...}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThenElse "if (head == none) :then {   head := E;   last := head;:else ;   E.succ := head;   head.pred := E;   head := E;   --"insert:".pr ...}" 
 -- $IfThenElse:invoke: "if (head == none) :then {   head := E;   last := head;:else ;   E.succ := head;   head.pred := E;   head := E;   --"insert:".print;   --idf.print;   - ..."} 
 -- $IfThenElse:gen: "if (head == none) :then {   head := E;   last := head;:else ;   E.succ := head;   head.pred := E;   head := E;   --"insert:".print;   --idf.print;   --pu ..."} 
 -- $ObjectGenerator:gen: "(head == none)" >OGid:"==" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(head == none)" 
 -- OG:before:super.gen: "(head == none)" 
 -- $Invocation:gen: "(head == none)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(head == none)" 
 -- isConstant: "Invocation" "(head == none)" 
 -- needorigin: "(head == none)" 
 -- needOrigin:E: "(head == none)"  E.ATd: "==  : {   %basic 56;   in objx: ref Object;   out V: var boolean}" 
 -- doNeedOrigin:Ex: "(head == none)" 
 -- computeAdr:superAdj: 0 "(head == none)" 
 -- computeAdr: 1 :rec: "none"  E: "(head == none)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(head == none)"  
 -- $BracketedExp:loadOrigin: "(head == none)"  
 -- computeAdr:superAdj: 0 "head == none" 
 -- computeAdr: 1 :rec: "none"  E: "head == none" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "head == none"  
 -- $BinOp:loadOrigin: "head == none"  
 -- BinaryExp:loadOrigin:empty: "head == none" superAdj: 0 
 -- $BinOp:getAdr: "head == none"  
 -- E.on: 2 
 -- beforeIsValueObj:E: "head == none"  ATd: "==  : {   %basic 56;   in objx: ref Object;   out V: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "head == none" 
 -- BE:loadOrigin:E: head == none 
 -- $BinOp:getAdr: "head == none"  
 -- E.on: 2 
 -- beforeIsValueObj:E: "head == none"  ATd: "==  : {   %basic 56;   in objx: ref Object;   out V: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "head == none" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "head == none" E:  "head == none" 
 -- INV:gen:E.loadArgs "head == none" 
 -- $BinOp:loadArgs: "head == none"  
 -- BinaryExp:loadArgs: "head == none" superAdj: 0 
 -- $Invocation:gen: "head" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "head" 
 -- isConstant: "Invocation" "head" 
 -- notConst: head head: ref Element 
 -- needorigin: "head" 
 -- needOrigin:E: "head"  E.ATd: "head: ref Element" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "head" 
 -- computeAdr: 1 :rec: "none"  E: "head" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "head"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "head" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$143" on: 2 isValueObj: false 
 -- origin: insert origin:isValueObj: false 
 rpushg $143$143 1
 -- items:goOrigin:encOG: "insert" on: 1 isValueObj: false 
 -- origin: Queue origin:isValueObj: false 
 rpushg insert$142 1
 -- $ObjectInvocation_Unary:getAdr: "head" >ATd.off:4:on:2:superAdj:0"head: ref Element":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F ... 
 -- $ref:getAdr: "head: ref Element" >newOff:4,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- E.on: 2 
 -- beforeIsValueObj:E: "head"  ATd: "head: ref Element" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "head" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "head" E:  "head" 
 -- INV:gen:E.loadArgs "head" 
 -- $ObjectInvocation_Unary:loadArgs: "head" >staticOff:0 "head: ref Element" superAdj:0 
 -- $ref:loadArgs: "head: ref Element" >E:"head" 
 -- $pattern:loadArgs: "Element: {   in elm: ref Object;   out res: ref Element;   id: var integer;   pred: ref Element;   succ: ref Element;   res := this(Element);   idc :=  ..."} 
 -- ptn:loadArgs:E "head" 
 -- {(ObjectInvocation_Unary; (name: "head"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "head" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "head" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "head" >rec:"head" ATd:"ref" E:"head" E.ATd:"head" unique:"False" 
 -- OI:invoke: "head" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:head 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:head 
 -- OI:invoke:B: "head" E: "head"  rec: "head"  useRtnV: true "head: ref Element" 
 -- OI:invoke:before:ATdx.invoke: ref head 
 -- $ref:invoke: "head: ref Element" E: "head">newOff:4 useRTNv: "True" 
 -- DI:invoke: "head: ref Element" 
 -- >Object:unique: false 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- isCompositeValueObj: false E: "head" "head: ref Element" false 
 -- E.ATd.isValueObj: false rec: "head" 
 rpushg Queue$78 4
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- 
 -- OI:invoke:C: head :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- $pattern:loadArgs: "==  : {   %basic 56;   in objx: ref Object;   out V: var boolean" >E:"== none":descNo:144} 
 -- ptn:loadArgs:E "== none" 
 -- {(ObjectInvocation_Binary; (name: "=="); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "none");     (Arguments)));   (Items descNo:  ...} 
 -- args: "none" 
 -- E: "ObjectGenerator" none 
 -- E.arg: "ref" in objx: ref Object 
 -- NonVirt: "== none" "ObjectInvocation_Binary" ActArg:  "none" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "== none"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "none" >OGid:"none" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "none" 
 -- OG:before:super.gen: "none" 
 -- $Invocation:gen: "none" >useRtnV:"True"superAdj: 0 descNo: 116 
 -- INV:gen: "none" 
 -- isConstant: "Invocation" "none" 
 -- needorigin: "none" 
 -- needOrigin:E: "none"  E.ATd: "none: {   %basic 19;   none_x: var integer}" 
 -- doNeedOrigin:Ex: "none" 
 -- computeAdr:superAdj: 0 "none" 
 -- computeAdr: 1 :rec: "none"  E: "none" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "none"  
 -- $ObjectInvocation_Unary:loadOrigin: "none" >on:5 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_Unary:getAdr: "none" >ATd.off:0 (isPtn):on:5:superAdj:0"none: {   %basic 19;   none_x: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU ...} 
 -- $pattern:getAdr: "none: {   %basic 19;   none_x: var integer" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- E.on: 5 
 -- beforeIsValueObj:E: "none"  ATd: "none: {   %basic 19;   none_x: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "none" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "none" E:  "none" 
 -- INV:gen:E.loadArgs "none" 
 -- $ObjectInvocation_Unary:loadArgs: "none" >staticOff:0 "none: {   %basic 19;   none_x: var integer" superAdj:0} 
 -- $pattern:loadArgs: "none: {   %basic 19;   none_x: var integer" >E:"none":descNo:116} 
 -- ptn:loadArgs:E "none" 
 -- {(ObjectInvocation_Unary; (name: "none"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "none" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "none" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "none" >rec:"none" ATd:"pattern" E:"none" E.ATd:"none" unique:"False" 
 -- OI:invoke: "none" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- OI:invoke:B: "none" E: "none"  rec: "none"  useRtnV: true "none: {   %basic 19;   none_x: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern none 
 -- $pattern:invoke: "none: {   %basic 19;   none_x: var integer" E: "none" useRTNv: "True"} 
 -- ptn:invoke: "none" E: "none" ptnKind: 0 useRtnV: true 
 pushNone 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- 
 -- OI:invoke:C: none :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- formalArg:isPtn: "in objx: ref Object" :isBasicVal: false :valueObj: false 
 -- :actArg: "none" :isBasicVal: false 
 -- case:B: none ObjectGenerator 64 19 19 false false 
 -- end:loadArgs:NonVirt: "== none" 
 -- BinaryExp:loadArgs:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- INV:gen:after:E.loadArgs "head == none" 
 -- OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- IV:E.invoke:useRtnVal: true E: BinOp "head == none" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- $BinOp:invoke: "head == none"  
 -- BinaryExp:invoke: "head" rec: "head == none" 
 -- M: "== none" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- $ObjectInvocation_Binary:invoke: "== none" >rec:"head" ATd:"pattern" E:"== none" E.ATd:"==  " unique:"False" 
 -- OI:invoke: "== none" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- OI:invoke:B: "== none" E: "== none"  rec: "head"  useRtnV: true "==  : {   %basic 56;   in objx: ref Object;   out V: var boolean}" 
 -- OI:invoke:before:ATdx.invoke: pattern ==   
 -- $pattern:invoke: "==  : {   %basic 56;   in objx: ref Object;   out V: var boolean" E: "== none" useRTNv: "True"} 
 -- ptn:invoke: "==  " E: "== none" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "head" E: "== none" 
 -- arg:other 
 req
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"== none":rec:head 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"== none":rec:head 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: == none :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: "head := E{   last := head" >OGid:"$145" singular! staticOff=0 descNo=145 superAdj=0} 
 -- OG:gen: "head := E{   last := head}" 
 pushThis 
 -- before objTmpStack:add:  145   "$145" 
 invoke $145 145 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L5
 L4:
 -- $ObjectGenerator:gen: "E.succ := head{   head.pred := E;   head := E;   --"insert:".print;   --idf.print;   --putint(noOfElm);   --newline	 " >OGid:"$146" singular! static ...} 
 -- OG:gen: "E.succ := head{   head.pred := E;   head := E;   --"insert:".print;   --idf.print;   --putint(noOfElm);   --newline	 }" 
 pushThis 
 -- before objTmpStack:add:  146   "$146" 
 invoke $146 146 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L5:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 145 
 -- Items:GenClass: $145 descNo: 145 isValue: false 
 -- Items:GenClass: $145 descNo: 21 isValue: false 

 CLASS $145 145 1 $143 143
 -- Store itemArgs: head := E{last := head} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=145 vDescInx=145 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "head := E" 
 -- $Assign:gen: "head := E"  
 -- assign: "head := E" 
 -- computeAdr:superAdj: 0 "head" 
 -- computeAdr: 1 :rec: "none"  E: "head" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "head"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "head" >on:3 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$145" on: 3 isValueObj: false 
 -- origin: $143 origin:isValueObj: false 
 rpushg $145$145 1
 -- items:goOrigin:encOG: "$143" on: 2 isValueObj: false 
 -- origin: insert origin:isValueObj: false 
 rpushg $143$143 1
 -- items:goOrigin:encOG: "insert" on: 1 isValueObj: false 
 -- origin: Queue origin:isValueObj: false 
 rpushg insert$142 1
 -- $ObjectInvocation_Unary:getAdr: "head" >ATd.off:4:on:3:superAdj:0"head: ref Element":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F ... 
 -- $ref:getAdr: "head: ref Element" >newOff:4,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- E.on: 3 
 -- beforeIsValueObj:E: "head"  ATd: "head: ref Element" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "head" 
 -- AssignmentStatement:gen: "head := E" right.label: "ObjectGenerator" "E" 
 -- $ObjectGenerator:gen: "E" >OGid:"Element" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "E" 
 -- OG:before:super.gen: "E" 
 -- $Invocation:gen: "E" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "E" 
 -- isConstant: "Invocation" "E" 
 -- notConst: E E: ref Element 
 -- needorigin: "E" 
 -- needOrigin:E: "E"  E.ATd: "E: ref Element" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "E" 
 -- computeAdr: 1 :rec: "none"  E: "E" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "E"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "E" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$145" on: 2 isValueObj: false 
 -- origin: $143 origin:isValueObj: false 
 rpushg $145$145 1
 -- items:goOrigin:encOG: "$143" on: 1 isValueObj: false 
 -- origin: insert origin:isValueObj: false 
 rpushg $143$143 1
 -- $ObjectInvocation_Unary:getAdr: "E" >ATd.off:3:on:2:superAdj:0"E: ref Element":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $ref:getAdr: "E: ref Element" >newOff:3,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F o ... 
 -- E.on: 2 
 -- beforeIsValueObj:E: "E"  ATd: "E: ref Element" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "E" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "E" E:  "E" 
 -- INV:gen:E.loadArgs "E" 
 -- $ObjectInvocation_Unary:loadArgs: "E" >staticOff:0 "E: ref Element" superAdj:0 
 -- $ref:loadArgs: "E: ref Element" >E:"E" 
 -- $pattern:loadArgs: "Element: {   in elm: ref Object;   out res: ref Element;   id: var integer;   pred: ref Element;   succ: ref Element;   res := this(Element);   idc :=  ..."} 
 -- ptn:loadArgs:E "E" 
 -- {(ObjectInvocation_Unary; (name: "E"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "E" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "E" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "E" >rec:"E" ATd:"ref" E:"E" E.ATd:"E" unique:"False" 
 -- OI:invoke: "E" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:E 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:E 
 -- OI:invoke:B: "E" E: "E"  rec: "E"  useRtnV: true "E: ref Element" 
 -- OI:invoke:before:ATdx.invoke: ref E 
 -- $ref:invoke: "E: ref Element" E: "E">newOff:3 useRTNv: "True" 
 -- DI:invoke: "E: ref Element" 
 -- >Object:unique: false 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"E":rec:E 
 -- isCompositeValueObj: false E: "E" "E: ref Element" false 
 -- E.ATd.isValueObj: false rec: "E" 
 rpushg insert$142 3
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"E":rec:E 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"E":rec:E 
 -- 
 -- OI:invoke:C: E :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"E":rec:E 
 -- rec: "head" dstE: "head" dstE.ATd: "head: ref Element" useRtn: false :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- ... 
 -- dstDI.isBasicVal: false dstDI.isValObj: false dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- assign:adr.store:A: 
 -- store: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- isValue: false  isAdr: true  descNo:  0 
 rswap 0
 rstoreg  EisNone 4
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- assign:adr.store:B: 
 -- genclass:stmt: "last := head" 
 -- $Assign:gen: "last := head"  
 -- assign: "last := head" 
 -- computeAdr:superAdj: 0 "last" 
 -- computeAdr: 1 :rec: "none"  E: "last" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "last"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "last" >on:3 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$145" on: 3 isValueObj: false 
 -- origin: $143 origin:isValueObj: false 
 rpushg $145$145 1
 -- items:goOrigin:encOG: "$143" on: 2 isValueObj: false 
 -- origin: insert origin:isValueObj: false 
 rpushg $143$143 1
 -- items:goOrigin:encOG: "insert" on: 1 isValueObj: false 
 -- origin: Queue origin:isValueObj: false 
 rpushg insert$142 1
 -- $ObjectInvocation_Unary:getAdr: "last" >ATd.off:5:on:3:superAdj:0"last: ref Element":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F ... 
 -- $ref:getAdr: "last: ref Element" >newOff:5,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- E.on: 3 
 -- beforeIsValueObj:E: "last"  ATd: "last: ref Element" 
 -- computeAdr:isFirst: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "last" 
 -- AssignmentStatement:gen: "last := head" right.label: "ObjectGenerator" "head" 
 -- $ObjectGenerator:gen: "head" >OGid:"Element" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "head" 
 -- OG:before:super.gen: "head" 
 -- $Invocation:gen: "head" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "head" 
 -- isConstant: "Invocation" "head" 
 -- notConst: head head: ref Element 
 -- needorigin: "head" 
 -- needOrigin:E: "head"  E.ATd: "head: ref Element" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "head" 
 -- computeAdr: 1 :rec: "none"  E: "head" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "head"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "head" >on:3 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$145" on: 3 isValueObj: false 
 -- origin: $143 origin:isValueObj: false 
 rpushg $145$145 1
 -- items:goOrigin:encOG: "$143" on: 2 isValueObj: false 
 -- origin: insert origin:isValueObj: false 
 rpushg $143$143 1
 -- items:goOrigin:encOG: "insert" on: 1 isValueObj: false 
 -- origin: Queue origin:isValueObj: false 
 rpushg insert$142 1
 -- $ObjectInvocation_Unary:getAdr: "head" >ATd.off:4:on:3:superAdj:0"head: ref Element":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F ... 
 -- $ref:getAdr: "head: ref Element" >newOff:4,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- E.on: 3 
 -- beforeIsValueObj:E: "head"  ATd: "head: ref Element" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "head" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "head" E:  "head" 
 -- INV:gen:E.loadArgs "head" 
 -- $ObjectInvocation_Unary:loadArgs: "head" >staticOff:0 "head: ref Element" superAdj:0 
 -- $ref:loadArgs: "head: ref Element" >E:"head" 
 -- $pattern:loadArgs: "Element: {   in elm: ref Object;   out res: ref Element;   id: var integer;   pred: ref Element;   succ: ref Element;   res := this(Element);   idc :=  ..."} 
 -- ptn:loadArgs:E "head" 
 -- {(ObjectInvocation_Unary; (name: "head"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "head" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "head" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "head" >rec:"head" ATd:"ref" E:"head" E.ATd:"head" unique:"False" 
 -- OI:invoke: "head" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:head 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:head 
 -- OI:invoke:B: "head" E: "head"  rec: "head"  useRtnV: true "head: ref Element" 
 -- OI:invoke:before:ATdx.invoke: ref head 
 -- $ref:invoke: "head: ref Element" E: "head">newOff:4 useRTNv: "True" 
 -- DI:invoke: "head: ref Element" 
 -- >Object:unique: false 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- isCompositeValueObj: false E: "head" "head: ref Element" false 
 -- E.ATd.isValueObj: false rec: "head" 
 rpushg Queue$78 4
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- 
 -- OI:invoke:C: head :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- rec: "last" dstE: "last" dstE.ATd: "last: ref Element" useRtn: false :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- ... 
 -- dstDI.isBasicVal: false dstDI.isValObj: false dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- assign:adr.store:A: 
 -- store: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- isValue: false  isAdr: true  descNo:  0 
 rswap 0
 rstoreg  EisNone 5
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-4,0)=[]
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 146 
 -- Items:GenClass: $146 descNo: 146 isValue: false 
 -- Items:GenClass: $146 descNo: 21 isValue: false 

 CLASS $146 146 1 $143 143
 -- Store itemArgs: E.succ := head{head.pred := E;head := E;--"insert:".print;--idf.print;--putint(noOfElm);--newline	 } 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=146 vDescInx=146 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "E.succ := head" 
 -- $Assign:gen: "E.succ := head"  
 -- assign: "E.succ := head" 
 -- computeAdr:superAdj: 0 "E.succ" 
 -- computeAdr: 1 :rec: "none"  E: "E" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "E"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "E" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$146" on: 2 isValueObj: false 
 -- origin: $143 origin:isValueObj: false 
 rpushg $146$146 1
 -- items:goOrigin:encOG: "$143" on: 1 isValueObj: false 
 -- origin: insert origin:isValueObj: false 
 rpushg $143$143 1
 -- $ObjectInvocation_Unary:getAdr: "E" >ATd.off:3:on:2:superAdj:0"E: ref Element":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $ref:getAdr: "E: ref Element" >newOff:3,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F o ... 
 -- E.on: 2 
 -- beforeIsValueObj:E: "E"  ATd: "E: ref Element" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "E"  E: "succ" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "succ" >ATd.off:6:on:0:superAdj:0"succ: ref Element":Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F ... 
 -- $ref:getAdr: "succ: ref Element" >newOff:6,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- $ObjectInvocation_Unary:loadArgs: "E" >staticOff:0 "E: ref Element" superAdj:0 
 -- $ref:loadArgs: "E: ref Element" >E:"E" 
 -- $pattern:loadArgs: "Element: {   in elm: ref Object;   out res: ref Element;   id: var integer;   pred: ref Element;   succ: ref Element;   res := this(Element);   idc :=  ..."} 
 -- ptn:loadArgs:E "E" 
 -- {(ObjectInvocation_Unary; (name: "E"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "E" >rec:"E" ATd:"ref" E:"succ" E.ATd:"succ" unique:"False" 
 -- OI:invoke: "E" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"succ":rec:E 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"succ":rec:E 
 -- OI:invoke:B: "E" E: "succ"  rec: "E"  useRtnV: true "E: ref Element" 
 -- OI:invoke:before:ATdx.invoke: ref E 
 -- $ref:invoke: "E: ref Element" E: "succ">newOff:3 useRTNv: "True" 
 -- DI:invoke: "E: ref Element" 
 -- >Object:unique: false 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"succ":rec:E 
 -- isCompositeValueObj: false E: "succ" "succ: ref Element" false 
 -- E.ATd.isValueObj: false rec: "E" 
 rpushg $146$146 3
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"succ":rec:E 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"succ":rec:E 
 -- 
 -- OI:invoke:C: E :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "E" E: "succ" 
 -- computeAdr:isLast:E:  "succ" 
 -- AssignmentStatement:gen: "E.succ := head" right.label: "ObjectGenerator" "head" 
 -- $ObjectGenerator:gen: "head" >OGid:"Element" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "head" 
 -- OG:before:super.gen: "head" 
 -- $Invocation:gen: "head" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "head" 
 -- isConstant: "Invocation" "head" 
 -- notConst: head head: ref Element 
 -- needorigin: "head" 
 -- needOrigin:E: "head"  E.ATd: "head: ref Element" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "head" 
 -- computeAdr: 1 :rec: "none"  E: "head" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "head"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "head" >on:3 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$146" on: 3 isValueObj: false 
 -- origin: $143 origin:isValueObj: false 
 rpushg $146$146 1
 -- items:goOrigin:encOG: "$143" on: 2 isValueObj: false 
 -- origin: insert origin:isValueObj: false 
 rpushg $143$143 1
 -- items:goOrigin:encOG: "insert" on: 1 isValueObj: false 
 -- origin: Queue origin:isValueObj: false 
 rpushg insert$142 1
 -- $ObjectInvocation_Unary:getAdr: "head" >ATd.off:4:on:3:superAdj:0"head: ref Element":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F ... 
 -- $ref:getAdr: "head: ref Element" >newOff:4,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- E.on: 3 
 -- beforeIsValueObj:E: "head"  ATd: "head: ref Element" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "head" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "head" E:  "head" 
 -- INV:gen:E.loadArgs "head" 
 -- $ObjectInvocation_Unary:loadArgs: "head" >staticOff:0 "head: ref Element" superAdj:0 
 -- $ref:loadArgs: "head: ref Element" >E:"head" 
 -- $pattern:loadArgs: "Element: {   in elm: ref Object;   out res: ref Element;   id: var integer;   pred: ref Element;   succ: ref Element;   res := this(Element);   idc :=  ..."} 
 -- ptn:loadArgs:E "head" 
 -- {(ObjectInvocation_Unary; (name: "head"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "head" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "head" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "head" >rec:"head" ATd:"ref" E:"head" E.ATd:"head" unique:"False" 
 -- OI:invoke: "head" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:head 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:head 
 -- OI:invoke:B: "head" E: "head"  rec: "head"  useRtnV: true "head: ref Element" 
 -- OI:invoke:before:ATdx.invoke: ref head 
 -- $ref:invoke: "head: ref Element" E: "head">newOff:4 useRTNv: "True" 
 -- DI:invoke: "head: ref Element" 
 -- >Object:unique: false 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- isCompositeValueObj: false E: "head" "head: ref Element" false 
 -- E.ATd.isValueObj: false rec: "head" 
 rpushg Queue$78 4
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- 
 -- OI:invoke:C: head :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- rec: "E" dstE: "succ" dstE.ATd: "succ: ref Element" useRtn: false :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- dstDI.isBasicVal: false dstDI.isValObj: false dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- assign:adr.store:A: 
 -- store: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- isValue: false  isAdr: true  descNo:  0 
 rswap 0
 rstoreg  EisNone 6
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- assign:adr.store:B: 
 -- genclass:stmt: "head.pred := E" 
 -- $Assign:gen: "head.pred := E"  
 -- assign: "head.pred := E" 
 -- computeAdr:superAdj: 0 "head.pred" 
 -- computeAdr: 1 :rec: "none"  E: "head" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "head"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "head" >on:3 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$146" on: 3 isValueObj: false 
 -- origin: $143 origin:isValueObj: false 
 rpushg $146$146 1
 -- items:goOrigin:encOG: "$143" on: 2 isValueObj: false 
 -- origin: insert origin:isValueObj: false 
 rpushg $143$143 1
 -- items:goOrigin:encOG: "insert" on: 1 isValueObj: false 
 -- origin: Queue origin:isValueObj: false 
 rpushg insert$142 1
 -- $ObjectInvocation_Unary:getAdr: "head" >ATd.off:4:on:3:superAdj:0"head: ref Element":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F ... 
 -- $ref:getAdr: "head: ref Element" >newOff:4,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- E.on: 3 
 -- beforeIsValueObj:E: "head"  ATd: "head: ref Element" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "head"  E: "pred" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "pred" >ATd.off:5:on:0:superAdj:0"pred: ref Element":Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F ... 
 -- $ref:getAdr: "pred: ref Element" >newOff:5,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- $ObjectInvocation_Unary:loadArgs: "head" >staticOff:0 "head: ref Element" superAdj:0 
 -- $ref:loadArgs: "head: ref Element" >E:"head" 
 -- $pattern:loadArgs: "Element: {   in elm: ref Object;   out res: ref Element;   id: var integer;   pred: ref Element;   succ: ref Element;   res := this(Element);   idc :=  ..."} 
 -- ptn:loadArgs:E "head" 
 -- {(ObjectInvocation_Unary; (name: "head"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "head" >rec:"head" ATd:"ref" E:"pred" E.ATd:"pred" unique:"False" 
 -- OI:invoke: "head" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"pred":rec:head 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"pred":rec:head 
 -- OI:invoke:B: "head" E: "pred"  rec: "head"  useRtnV: true "head: ref Element" 
 -- OI:invoke:before:ATdx.invoke: ref head 
 -- $ref:invoke: "head: ref Element" E: "pred">newOff:4 useRTNv: "True" 
 -- DI:invoke: "head: ref Element" 
 -- >Object:unique: false 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"pred":rec:head 
 -- isCompositeValueObj: false E: "pred" "pred: ref Element" false 
 -- E.ATd.isValueObj: false rec: "head" 
 rpushg $146$146 4
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"pred":rec:head 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"pred":rec:head 
 -- 
 -- OI:invoke:C: head :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "head" E: "pred" 
 -- computeAdr:isLast:E:  "pred" 
 -- AssignmentStatement:gen: "head.pred := E" right.label: "ObjectGenerator" "E" 
 -- $ObjectGenerator:gen: "E" >OGid:"Element" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "E" 
 -- OG:before:super.gen: "E" 
 -- $Invocation:gen: "E" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "E" 
 -- isConstant: "Invocation" "E" 
 -- notConst: E E: ref Element 
 -- needorigin: "E" 
 -- needOrigin:E: "E"  E.ATd: "E: ref Element" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "E" 
 -- computeAdr: 1 :rec: "none"  E: "E" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "E"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "E" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$146" on: 2 isValueObj: false 
 -- origin: $143 origin:isValueObj: false 
 rpushg $146$146 1
 -- items:goOrigin:encOG: "$143" on: 1 isValueObj: false 
 -- origin: insert origin:isValueObj: false 
 rpushg $143$143 1
 -- $ObjectInvocation_Unary:getAdr: "E" >ATd.off:3:on:2:superAdj:0"E: ref Element":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $ref:getAdr: "E: ref Element" >newOff:3,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F o ... 
 -- E.on: 2 
 -- beforeIsValueObj:E: "E"  ATd: "E: ref Element" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "E" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "E" E:  "E" 
 -- INV:gen:E.loadArgs "E" 
 -- $ObjectInvocation_Unary:loadArgs: "E" >staticOff:0 "E: ref Element" superAdj:0 
 -- $ref:loadArgs: "E: ref Element" >E:"E" 
 -- $pattern:loadArgs: "Element: {   in elm: ref Object;   out res: ref Element;   id: var integer;   pred: ref Element;   succ: ref Element;   res := this(Element);   idc :=  ..."} 
 -- ptn:loadArgs:E "E" 
 -- {(ObjectInvocation_Unary; (name: "E"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "E" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "E" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "E" >rec:"E" ATd:"ref" E:"E" E.ATd:"E" unique:"False" 
 -- OI:invoke: "E" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:E 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:E 
 -- OI:invoke:B: "E" E: "E"  rec: "E"  useRtnV: true "E: ref Element" 
 -- OI:invoke:before:ATdx.invoke: ref E 
 -- $ref:invoke: "E: ref Element" E: "E">newOff:3 useRTNv: "True" 
 -- DI:invoke: "E: ref Element" 
 -- >Object:unique: false 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"E":rec:E 
 -- isCompositeValueObj: false E: "E" "E: ref Element" false 
 -- E.ATd.isValueObj: false rec: "E" 
 rpushg insert$142 3
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"E":rec:E 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"E":rec:E 
 -- 
 -- OI:invoke:C: E :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"E":rec:E 
 -- rec: "head" dstE: "pred" dstE.ATd: "pred: ref Element" useRtn: false :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- ... 
 -- dstDI.isBasicVal: false dstDI.isValObj: false dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- assign:adr.store:A: 
 -- store: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- isValue: false  isAdr: true  descNo:  0 
 rswap 0
 rstoreg  EisNone 5
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-4,0)=[]
 -- assign:adr.store:B: 
 -- genclass:stmt: "head := E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- $Assign:gen: "head := E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 " } 
 -- assign: "head := E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- computeAdr:superAdj: 0 "head" 
 -- computeAdr: 1 :rec: "none"  E: "head" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "head"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "head" >on:3 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$146" on: 3 isValueObj: false 
 -- origin: $143 origin:isValueObj: false 
 rpushg $146$146 1
 -- items:goOrigin:encOG: "$143" on: 2 isValueObj: false 
 -- origin: insert origin:isValueObj: false 
 rpushg $143$143 1
 -- items:goOrigin:encOG: "insert" on: 1 isValueObj: false 
 -- origin: Queue origin:isValueObj: false 
 rpushg insert$142 1
 -- $ObjectInvocation_Unary:getAdr: "head" >ATd.off:4:on:3:superAdj:0"head: ref Element":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F ... 
 -- $ref:getAdr: "head: ref Element" >newOff:4,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- E.on: 3 
 -- beforeIsValueObj:E: "head"  ATd: "head: ref Element" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "head" 
 -- AssignmentStatement:gen: "head := E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }" right.label: "ObjectGenerator" "E{--"insert:".print;--idf.print;--putint( ...}" 
 -- $ObjectGenerator:gen: "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 " >OGid:"Element" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- OG:before:super.gen: "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- $Invocation:gen: "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 " >useRtnV:"True"superAdj: 0} 
 -- INV:gen: "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- isConstant: "Invocation" "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- notConst: E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 } E: ref Element 
 -- needorigin: "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- needOrigin:E: "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }"  E.ATd: "E: ref Element" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- computeAdr: 1 :rec: "none"  E: "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 " } 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 " >on:2 superAdj:0 isValueObj:"False"} 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$146" on: 2 isValueObj: false 
 -- origin: $143 origin:isValueObj: false 
 rpushg $146$146 1
 -- items:goOrigin:encOG: "$143" on: 1 isValueObj: false 
 -- origin: insert origin:isValueObj: false 
 rpushg $143$143 1
 -- $ObjectInvocation_Unary:getAdr: "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 " >ATd.off:3:on:2:superAdj:0"E: ref Element":Adr:off:0 size:0 isFloat:F isUni ...} 
 -- $ref:getAdr: "E: ref Element" >newOff:3,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F o ... 
 -- E.on: 2 
 -- beforeIsValueObj:E: "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }"  ATd: "E: ref Element" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }" E:  "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- INV:gen:E.loadArgs "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- $ObjectInvocation_Unary:loadArgs: "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 " >staticOff:0 "E: ref Element" superAdj:0} 
 -- $ref:loadArgs: "E: ref Element" >E:"E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 "--"insert:".print;--idf.print;--putint(noOfElm);--newline	 } 
 -- $pattern:loadArgs: "Element: {   in elm: ref Object;   out res: ref Element;   id: var integer;   pred: ref Element;   succ: ref Element;   res := this(Element);   idc :=  ..."} 
 -- ptn:loadArgs:E "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- {(ObjectInvocation_Unary; (name: "E"); (Arguments --<12>"insert:".print;<12>idf.print;<12>putint(noOfElm);<12>newline	 ))} 
 -- args: "--"insert:".print{--idf.print;--putint(noOfElm);--newline	 }" 
 -- INV:gen:after:E.loadArgs "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 i ... 
 -- $ObjectInvocation_Unary:invoke: "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 " >rec:"E;--"insert:".print;--idf.print;--putint(noOfElm);--newline	 " ATd:"r ..."} 
 -- OI:invoke: "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 } 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 } 
 -- OI:invoke:B: "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }" E: "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }"  rec: "E{--"insert:".prin ...}"   ... true "E ..." 
 -- OI:invoke:before:ATdx.invoke: ref E 
 -- $ref:invoke: "E: ref Element" E: "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 ">newOff:3 useRTNv: "True"} 
 -- DI:invoke: "E: ref Element" 
 -- >Object:unique: false 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 ":rec:E;--"in ..."} 
 -- isCompositeValueObj: false E: "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }" "E: ref Element" false 
 -- E.ATd.isValueObj: false rec: "E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 rpushg insert$142 3
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 " ...} 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 " ...} 
 -- 
 -- OI:invoke:C: E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 } :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"E{--"insert:".print;--idf.print;--putint(noOfElm);--newline	 ":rec:E ...} 
 -- rec: "head" dstE: "head" dstE.ATd: "head: ref Element" useRtn: false :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- ... 
 -- dstDI.isBasicVal: false dstDI.isValObj: false dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- assign:adr.store:A: 
 -- store: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- isValue: false  isAdr: true  descNo:  0 
 rswap 0
 rstoreg  EisNone 4
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -6 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-6,0)=[]
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 160 
 -- Items:GenClass: start descNo: 160 isValue: false 
 -- Items:GenClass: start descNo: 132 isValue: false 
 -- Items:GenClass: start descNo: 21 isValue: false 

 CLASS start 160 1 BasicProcess 83
 -- vdtTableCopy: I:1:132 I:2:0
 -- vdtAdd: inx=2 descInx=160 vDescInx=160 vdtTop: 2 
 -- Store itemArgs: status := p_status.ACTIVE{SQS.insert(this(BasicProcess));inner(start)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 -- super start
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 -- handleSuperArgs:E: "" theIS: "status := p_status.ACTIVE{SQS.insert(this(BasicProcess));inner(start)}" 
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs: ""  
 -- hArgOrg:super: start 
 -- Store itemArgs: status := p_status.ACTIVE{SQS.insert(this(BasicProcess));inner(start)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=160 vDescInx=132 vdtTop: 2 
 rtnAlloc 1
 toSuper 132
DO:
 mvStack 
 L1:
 -- genclass:stmt: "status := p_status.ACTIVE" 
 -- $Assign:gen: "status := p_status.ACTIVE"  
 -- assign: "status := p_status.ACTIVE" 
 -- computeAdr:superAdj: 0 "status" 
 -- computeAdr: 1 :rec: "none"  E: "status" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "status"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "status" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "start" on: 1 isValueObj: false 
 -- origin: BasicProcess origin:isValueObj: false 
 rpushg start$160 1
 -- $ObjectInvocation_Unary:getAdr: "status" >ATd.off:3:on:1:superAdj:0"status: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVal ... 
 -- $var:getAdr: "status: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F  ... 
 -- DI:OG: integer 
 -- before:floatTest:  "status: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"status":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"status":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "status"  ATd: "status: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"status":rec:- 
 -- computeAdr:isLast:E:  "status" 
 -- AssignmentStatement:gen: "status := p_status.ACTIVE" right.label: "ObjectGenerator" "p_status.ACTIVE" 
 -- $ObjectGenerator:gen: "p_status.ACTIVE" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "p_status.ACTIVE" 
 -- OG:before:super.gen: "p_status.ACTIVE" 
 -- $Invocation:gen: "p_status.ACTIVE" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "p_status.ACTIVE" 
 -- isConstant: "Invocation" "p_status.ACTIVE" 
 -- const literal:  1   ConstLiteral 
 pushc 1
 -- OG:gen:end: 
 -- rec: "status" dstE: "status" dstE.ATd: "status: var integer" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"statu ..." 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "p_status.ACTIVE" 
 -- isArgOfAssignI2IwithUniValArg "status := p_status.ACTIVE" arg: "p_status.ACTIVE" ObjectGenerator 
 -- arg.super.arg: "p_status" ObjectInvocation_Unary 
 -- arg.super.arg: "ACTIVE" ObjectInvocation_Unary 
 -- recx: "p_status" argx: "ACTIVE" 
 -- checkInt2IntWithUnitArg:rec: "p_status" E: "ACTIVE" 
 -- dstDI: "status: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"status":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg BasicProcess$83 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "SQS.insert(this(BasicProcess))" 
 -- $ObjectGenerator:gen: "SQS.insert(this(BasicProcess))" >OGid:"insert" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "SQS.insert(this(BasicProcess))" 
 -- OG:before:super.gen: "SQS.insert(this(BasicProcess))" 
 -- $Invocation:gen: "SQS.insert(this(BasicProcess))" >useRtnV:"False"superAdj: 0 descNo: 139 
 -- INV:gen: "SQS.insert(this(BasicProcess))" 
 -- isConstant: "Invocation" "SQS.insert(this(BasicProcess))" 
 -- needorigin: "SQS.insert(this(BasicProcess))" 
 -- needOrigin:E: "insert(this(BasicProcess))"  E.ATd: "insert: entry{   in P: ref BasicProcess;   if (Q.has(P).not) :then ;      Q.insert(P)}" 
 -- doNeedOrigin:Ex: "insert(this(BasicProcess))" 
 -- computeAdr:superAdj: 0 "SQS.insert(this(BasicProcess))" 
 -- computeAdr: 1 :rec: "none"  E: "SQS" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "SQS"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "SQS" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "start" on: 2 isValueObj: false 
 -- origin: BasicProcess origin:isValueObj: false 
 rpushg start$160 1
 -- items:goOrigin:encOG: "BasicProcess" on: 1 isValueObj: false 
 -- origin: BasicSystem origin:isValueObj: false 
 rpushg BasicProcess$83 4
 -- $ObjectInvocation_Unary:getAdr: "SQS" >ATd.off:6:on:2:superAdj:0"SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Publi ..."} 
 -- $obj:getAdr: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if  ..."} 
 -- E.on: 2 
 -- beforeIsValueObj:E: "SQS"  ATd: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V ...}" 
 -- computeAdr:isFirst: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "SQS"  E: "insert(this(BasicProcess))" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:getAdr: "insert(this(BasicProcess))" >ATd.off:0 (isPtn):on:0:superAdj:0"insert: entry{   in P: ref BasicProcess;   if (Q.has(P).not) :then ;      ..."} 
 -- $pattern:getAdr: "insert: entry{   in P: ref BasicProcess;   if (Q.has(P).not) :then ;      Q.insert(P)" } 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(this(BasicProcess))":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "SQS" >staticOff:0 "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ..."} 
 -- $obj:loadArgs: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      i ..."} 
 -- $ObjectInvocation_Unary:invoke: "SQS" >rec:"SQS" ATd:"obj" E:"insert(this(BasicProcess))" E.ATd:"insert" unique:"False" 
 -- OI:invoke: "SQS" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(this(BasicProcess))":rec:SQS 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(this(BasicProcess))":rec:SQS 
 -- OI:invoke:B: "SQS" E: "insert(this(BasicProcess))"  rec: "SQS"  useRtnV: true "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var int ...}" 
 -- OI:invoke:before:ATdx.invoke: obj SQS 
 -- $obj:invoke: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if  ..."} 
 -- DI:invoke: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if (V ...}" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(this(BasicProcess))":rec:SQS 
 rpushg start$160 6
 -- OI:invoke:V: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(this(BasicProcess))":rec:SQS 
 -- 
 -- OI:invoke:X: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(this(BasicProcess))":rec:SQS 
 -- 
 -- OI:invoke:C: SQS :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "SQS" E: "insert(this(BasicProcess))" 
 -- arg:other 
 -- computeAdr:isLast:E:  "insert(this(BasicProcess))" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(this(BasicProcess))":rec:SQS 
 -- rec:  "SQS" E:  "insert(this(BasicProcess))" 
 -- INV:gen:E.loadArgs "insert(this(BasicProcess))" 
 -- $ObjectInvocation_KeyWord:loadArgs: "insert(this(BasicProcess))" >staticOff:0 "insert: entry{   in P: ref BasicProcess;   if (Q.has(P).not) :then ;      Q.insert(P)" super ...} 
 -- $pattern:loadArgs: "insert: entry{   in P: ref BasicProcess;   if (Q.has(P).not) :then ;      Q.insert(P)" >E:"insert(this(BasicProcess))":descNo:139} 
 -- ptn:loadArgs:E "insert(this(BasicProcess))" 
 -- {(ObjectInvocation_KeyWord; (name: "insert"); (Arguments;  (name: "insert");  (name: "(");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_KeyWord;     (name: "this ..."} 
 -- args: "insert(this(BasicProcess))" 
 -- E: "ObjectGenerator" this(BasicProcess) 
 -- E.arg: "ref" in P: ref BasicProcess 
 -- NonVirt: "insert(this(BasicProcess))" "ObjectInvocation_KeyWord" ActArg:  "this(BasicProcess)" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "insert(this(BasicProcess))"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "this(BasicProcess)" >OGid:"this" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "this(BasicProcess)" 
 -- OG:before:super.gen: "this(BasicProcess)" 
 -- $Invocation:gen: "this(BasicProcess)" >useRtnV:"True"superAdj: 0 descNo: 31 
 -- INV:gen: "this(BasicProcess)" 
 -- isConstant: "Invocation" "this(BasicProcess)" 
 -- needorigin: "this(BasicProcess)" 
 -- needOrigin:E: "this(BasicProcess)"  E.ATd: "this: {   %basic 18;   in this: ref Object}" 
 -- doNeedOrigin:Ex: "this(BasicProcess)" 
 -- computeAdr:superAdj: 0 "this(BasicProcess)" 
 -- computeAdr: 1 :rec: "none"  E: "this(BasicProcess)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "this(BasicProcess)"  
 pushThis 
 -- $ObjectInvocation_KeyWord:loadOrigin: "this(BasicProcess)" >on:4 superAdj:0 isValueObj:"False" 
 -- this_prim: BasicProcess :super.on: 2 
 -- items:goOrigin:encOG: "start" on: 1 isValueObj: false 
 -- origin: BasicProcess origin:isValueObj: false 
 rpushg start$160 1
 -- $ObjectInvocation_KeyWord:getAdr: "this(BasicProcess)" >ATd.off:0 (isPtn):on:4:superAdj:0"this: {   %basic 18;   in this: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal: ...} 
 -- $pattern:getAdr: "this: {   %basic 18;   in this: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(BasicProcess)":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "this(BasicProcess)"  ATd: "this: {   %basic 18;   in this: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(BasicProcess)":rec:- 
 -- computeAdr:isLast:E:  "this(BasicProcess)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(BasicProcess)":rec:- 
 -- rec:  "this(BasicProcess)" E:  "this(BasicProcess)" 
 -- INV:gen:E.loadArgs "this(BasicProcess)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "this(BasicProcess)" >staticOff:0 "this: {   %basic 18;   in this: ref Object" superAdj:0arg:"BasicProcess"} 
 -- $pattern:loadArgs: "this: {   %basic 18;   in this: ref Object" >E:"this(BasicProcess)":descNo:31} 
 -- INV:gen:after:E.loadArgs "this(BasicProcess)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "this(BasicProcess)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"thi ..." 
 -- $ObjectInvocation_KeyWord:invoke: "this(BasicProcess)" >rec:"this(BasicProcess)" ATd:"pattern" E:"this(BasicProcess)" E.ATd:"this" unique:"False" 
 -- OI:invoke: "this(BasicProcess)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(BasicProcess)":rec:this(BasicProcess) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(BasicProcess)":rec:this(BasicProcess) 
 -- OI:invoke:B: "this(BasicProcess)" E: "this(BasicProcess)"  rec: "this(BasicProcess)"  useRtnV: true "this: {   %basic 18;   in this: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern this 
 -- $pattern:invoke: "this: {   %basic 18;   in this: ref Object" E: "this(BasicProcess)" useRTNv: "True"} 
 -- ptn:invoke: "this" E: "this(BasicProcess)" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(BasicProcess)":rec:this(BasicProc ... 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(BasicProcess)":rec:this(BasicProcess) 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(BasicProcess)":rec:this(BasicProcess) 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: this(BasicProcess) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(BasicProcess)":rec:this(BasicProcess) 
 -- formalArg:isPtn: "in P: ref BasicProcess" :isBasicVal: false :valueObj: false 
 -- :actArg: "this(BasicProcess)" :isBasicVal: false 
 -- case:B: this(BasicProcess) ObjectGenerator 0 18 18 false false 
 -- end:loadArgs:NonVirt: "insert(this(BasicProcess))" 
 -- INV:gen:after:E.loadArgs "insert(this(BasicProcess))" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "insert(this(BasicProcess))" :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ... 
 -- $ObjectInvocation_KeyWord:invoke: "insert(this(BasicProcess))" >rec:"SQS" ATd:"pattern" E:"insert(this(BasicProcess))" E.ATd:"insert" unique:"False" 
 -- OI:invoke: "insert(this(BasicProcess))" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(this(BasicProcess))":rec:SQS 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(this(BasicProcess))":rec:SQS 
 -- OI:invoke:B: "insert(this(BasicProcess))" E: "insert(this(BasicProcess))"  rec: "SQS"  useRtnV: false "insert: entry{   in P: ref BasicProcess;   if (Q.has(P).not) :then ; ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern insert 
 -- $pattern:invoke: "insert: entry{   in P: ref BasicProcess;   if (Q.has(P).not) :then ;      Q.insert(P)" E: "insert(this(BasicProcess))" useRTNv: "False"} 
 -- ptn:invoke: "insert" E: "insert(this(BasicProcess))" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(this(BasicProcess))":rec:SQS 
 invoke insert 139 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(this(BasicProcess))":rec:SQS 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(this(BasicProcess))":rec:SQS 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: insert(this(BasicProcess)) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 6 
 -- OG:gen:end: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(this(BasicProcess))":rec:SQS 
 -- genclass:stmt: "inner(start)" 
 -- $ObjectGenerator:gen: "inner(start)" >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inner(start)" 
 -- OG:before:super.gen: "inner(start)" 
 -- $Invocation:gen: "inner(start)" >useRtnV:"False"superAdj: 0 descNo: 12 
 -- INV:gen: "inner(start)" 
 -- isConstant: "Invocation" "inner(start)" 
 -- needorigin: "inner(start)" 
 -- needOrigin:E: "inner(start)"  E.ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- doNeedOrigin:Ex: "inner(start)" 
 -- computeAdr:superAdj: 0 "inner(start)" 
 -- computeAdr: 1 :rec: "none"  E: "inner(start)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "inner(start)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "inner(start)" >on:4 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "inner(start)" >ATd.off:0 (isPtn):on:4:superAdj:0"inner: {   %basic 101;   in inner: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal:F s ...} 
 -- $pattern:getAdr: "inner: {   %basic 101;   in inner: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(start)":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "inner(start)"  ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(start)":rec:- 
 -- computeAdr:isLast:E:  "inner(start)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(start)":rec:- 
 -- rec:  "inner(start)" E:  "inner(start)" 
 -- INV:gen:E.loadArgs "inner(start)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "inner(start)" >staticOff:0 "inner: {   %basic 101;   in inner: ref Object" superAdj:0arg:"start"} 
 -- $pattern:loadArgs: "inner: {   %basic 101;   in inner: ref Object" >E:"inner(start)":descNo:12} 
 -- INV:gen:after:E.loadArgs "inner(start)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(start)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(st ..." 
 -- $ObjectInvocation_KeyWord:invoke: "inner(start)" >rec:"inner(start)" ATd:"pattern" E:"inner(start)" E.ATd:"inner" unique:"False" 
 -- OI:invoke: "inner(start)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(start)":rec:inner(start) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(start)":rec:inner(start) 
 -- OI:invoke:B: "inner(start)" E: "inner(start)"  rec: "inner(start)"  useRtnV: false "inner: {   %basic 101;   in inner: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- $pattern:invoke: "inner: {   %basic 101;   in inner: ref Object" E: "inner(start)" useRTNv: "False"} 
 -- ptn:invoke: "inner" E: "inner(start)" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  3
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(start)":rec:inner(start) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(start)":rec:inner(start) 
 -- 
 -- OI:invoke:C: inner(start) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(start)":rec:inner(start) 
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0
 -- vdtAdd: inx=3 descInx=160 vDescInx=0 vdtTop: 3 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 161 
 -- Items:GenClass: addWaiting descNo: 161 isValue: false 
 -- Items:GenClass: addWaiting descNo: 134 isValue: false 
 -- Items:GenClass: addWaiting descNo: 21 isValue: false 

 CLASS addWaiting 161 1 BasicProcess 83
 -- vdtTableCopy: I:1:134 I:2:0
 -- vdtAdd: inx=2 descInx=161 vDescInx=161 vdtTop: 2 
 -- Store itemArgs: --SQS.addWaitingstatus := P_status.WAITING 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 -- super addWaiting
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 -- handleSuperArgs:E: "" theIS: "--SQS.addWaitingstatus := P_status.WAITING" 
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs: ""  
 -- hArgOrg:super: addWaiting 
 -- Store itemArgs: --SQS.addWaitingstatus := P_status.WAITING 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=161 vDescInx=134 vdtTop: 2 
 rtnAlloc 1
 toSuper 134
DO:
 mvStack 
 L1:
 -- genclass:stmt: "status := P_status.WAITING" 
 -- $Assign:gen: "status := P_status.WAITING"  
 -- assign: "status := P_status.WAITING" 
 -- computeAdr:superAdj: 0 "status" 
 -- computeAdr: 1 :rec: "none"  E: "status" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "status"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "status" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "addWaiting" on: 1 isValueObj: false 
 -- origin: BasicProcess origin:isValueObj: false 
 rpushg addWaiting$161 1
 -- $ObjectInvocation_Unary:getAdr: "status" >ATd.off:3:on:1:superAdj:0"status: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVal ... 
 -- $var:getAdr: "status: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F  ... 
 -- DI:OG: integer 
 -- before:floatTest:  "status: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"status":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"status":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "status"  ATd: "status: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"status":rec:- 
 -- computeAdr:isLast:E:  "status" 
 -- AssignmentStatement:gen: "status := P_status.WAITING" right.label: "ObjectGenerator" "P_status.WAITING" 
 -- $ObjectGenerator:gen: "P_status.WAITING" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "P_status.WAITING" 
 -- OG:before:super.gen: "P_status.WAITING" 
 -- $Invocation:gen: "P_status.WAITING" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "P_status.WAITING" 
 -- isConstant: "Invocation" "P_status.WAITING" 
 -- const literal:  2   ConstLiteral 
 pushc 2
 -- OG:gen:end: 
 -- rec: "status" dstE: "status" dstE.ATd: "status: var integer" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"statu ..." 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "P_status.WAITING" 
 -- isArgOfAssignI2IwithUniValArg "status := P_status.WAITING" arg: "P_status.WAITING" ObjectGenerator 
 -- arg.super.arg: "P_status" ObjectInvocation_Unary 
 -- arg.super.arg: "WAITING" ObjectInvocation_Unary 
 -- recx: "P_status" argx: "WAITING" 
 -- checkInt2IntWithUnitArg:rec: "P_status" E: "WAITING" 
 -- dstDI: "status: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"status":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg BasicProcess$83 3
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 162 
 -- Items:GenClass: dcrWaiting descNo: 162 isValue: false 
 -- Items:GenClass: dcrWaiting descNo: 135 isValue: false 
 -- Items:GenClass: dcrWaiting descNo: 21 isValue: false 

 CLASS dcrWaiting 162 1 BasicProcess 83
 -- vdtTableCopy: I:1:135 I:2:0
 -- vdtAdd: inx=2 descInx=162 vDescInx=162 vdtTop: 2 
 -- Store itemArgs: SQS.dcrWaiting 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 -- super dcrWaiting
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 -- handleSuperArgs:E: "" theIS: "SQS.dcrWaiting" 
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs: ""  
 -- hArgOrg:super: dcrWaiting 
 -- Store itemArgs: SQS.dcrWaiting 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=162 vDescInx=135 vdtTop: 2 
 rtnAlloc 1
 toSuper 135
DO:
 mvStack 
 L1:
 -- genclass:stmt: "SQS.dcrWaiting" 
 -- $ObjectGenerator:gen: "SQS.dcrWaiting" >OGid:"dcrWaiting" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "SQS.dcrWaiting" 
 -- OG:before:super.gen: "SQS.dcrWaiting" 
 -- $Invocation:gen: "SQS.dcrWaiting" >useRtnV:"False"superAdj: 0 descNo: 163 
 -- INV:gen: "SQS.dcrWaiting" 
 -- isConstant: "Invocation" "SQS.dcrWaiting" 
 -- needorigin: "SQS.dcrWaiting" 
 -- needOrigin:E: "dcrWaiting"  E.ATd: "dcrWaiting: entry{   W := W - 1}" 
 -- doNeedOrigin:Ex: "dcrWaiting" 
 -- computeAdr:superAdj: 0 "SQS.dcrWaiting" 
 -- computeAdr: 1 :rec: "none"  E: "SQS" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "SQS"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "SQS" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "dcrWaiting" on: 2 isValueObj: false 
 -- origin: BasicProcess origin:isValueObj: false 
 rpushg dcrWaiting$162 1
 -- items:goOrigin:encOG: "BasicProcess" on: 1 isValueObj: false 
 -- origin: BasicSystem origin:isValueObj: false 
 rpushg BasicProcess$83 4
 -- $ObjectInvocation_Unary:getAdr: "SQS" >ATd.off:6:on:2:superAdj:0"SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Publi ..."} 
 -- $obj:getAdr: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if  ..."} 
 -- E.on: 2 
 -- beforeIsValueObj:E: "SQS"  ATd: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V ...}" 
 -- computeAdr:isFirst: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "SQS"  E: "dcrWaiting" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "dcrWaiting" >ATd.off:0 (isPtn):on:0:superAdj:0"dcrWaiting: entry{   W := W - 1":Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique ...} 
 -- $pattern:getAdr: "dcrWaiting: entry{   W := W - 1" } 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"dcrWaiting":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "SQS" >staticOff:0 "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ..."} 
 -- $obj:loadArgs: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      i ..."} 
 -- $ObjectInvocation_Unary:invoke: "SQS" >rec:"SQS" ATd:"obj" E:"dcrWaiting" E.ATd:"dcrWaiting" unique:"False" 
 -- OI:invoke: "SQS" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"dcrWaiting":rec:SQS 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"dcrWaiting":rec:SQS 
 -- OI:invoke:B: "SQS" E: "dcrWaiting"  rec: "SQS"  useRtnV: true "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public; ...}" 
 -- OI:invoke:before:ATdx.invoke: obj SQS 
 -- $obj:invoke: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if  ..."} 
 -- DI:invoke: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if (V ...}" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"dcrWaiting":rec:SQS 
 rpushg dcrWaiting$162 6
 -- OI:invoke:V: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"dcrWaiting":rec:SQS 
 -- 
 -- OI:invoke:X: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"dcrWaiting":rec:SQS 
 -- 
 -- OI:invoke:C: SQS :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "SQS" E: "dcrWaiting" 
 -- computeAdr:isLast:E:  "dcrWaiting" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"dcrWaiting":rec:SQS 
 -- rec:  "SQS" E:  "dcrWaiting" 
 -- INV:gen:E.loadArgs "dcrWaiting" 
 -- $ObjectInvocation_Unary:loadArgs: "dcrWaiting" >staticOff:0 "dcrWaiting: entry{   W := W - 1" superAdj:0} 
 -- $pattern:loadArgs: "dcrWaiting: entry{   W := W - 1" >E:"dcrWaiting":descNo:163} 
 -- ptn:loadArgs:E "dcrWaiting" 
 -- {(ObjectInvocation_Unary; (name: "dcrWaiting"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "dcrWaiting" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "dcrWaiting" :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"dcrWaiting": ... 
 -- $ObjectInvocation_Unary:invoke: "dcrWaiting" >rec:"SQS" ATd:"pattern" E:"dcrWaiting" E.ATd:"dcrWaiting" unique:"False" 
 -- OI:invoke: "dcrWaiting" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"dcrWaiting":rec:SQS 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"dcrWaiting":rec:SQS 
 -- OI:invoke:B: "dcrWaiting" E: "dcrWaiting"  rec: "SQS"  useRtnV: false "dcrWaiting: entry{   W := W - 1}" 
 -- OI:invoke:before:ATdx.invoke: pattern dcrWaiting 
 -- $pattern:invoke: "dcrWaiting: entry{   W := W - 1" E: "dcrWaiting" useRTNv: "False"} 
 -- ptn:invoke: "dcrWaiting" E: "dcrWaiting" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"dcrWaiting":rec:SQS 
 invoke dcrWaiting 163 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"dcrWaiting":rec:SQS 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"dcrWaiting":rec:SQS 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: dcrWaiting :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 6 
 -- OG:gen:end: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"dcrWaiting":rec:SQS 
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 163 
 -- Items:GenClass: dcrWaiting descNo: 163 isValue: false 
 -- Items:GenClass: dcrWaiting descNo: 95 isValue: false 
 -- Items:GenClass: entry descNo: 21 isValue: false 

 CLASS dcrWaiting 163 1 SQS 77
 -- vdtTableCopy: I:1:95 I:2:0
 -- vdtAdd: inx=2 descInx=163 vDescInx=163 vdtTop: 2 
 -- Store itemArgs: W := W - 1 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 -- super entry
 -- push:super.origin: 
 -- computeAdr:superAdj: 1 "entry" 
 -- computeAdr: 1 :rec: "none"  E: "entry" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "entry"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "entry" >on:0 superAdj:1 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 1 
 rpushg SQS$77 1
 -- $ObjectInvocation_Unary:getAdr: "entry" >ATd.off:0 (isPtn):on:0:superAdj:1"entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1 ..."} 
 -- $pattern:getAdr: "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"entry":rec:- 
 -- E.on: 0 
 -- beforeIsValueObj:E: "entry"  ATd: "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"entry":rec:- 
 -- computeAdr:isLast:E:  "entry" 
 -- genClass:after:pushAddress: "entry" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"entry":rec:- 
 -- handleSuperArgs:E: "entry" theIS: "W := W - 1" 
 -- super.sig:not:none:superAdj: -1 
 -- $ObjectInvocation_Unary:loadArgs: "entry" >staticOff:0 "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free" superAd ...} 
 -- $pattern:loadArgs: "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free" >E:"entry":descNo:95} 
 -- ptn:loadArgs:E "entry" 
 -- {(ObjectInvocation_Unary; (name: "entry"); (Arguments))} 
 -- args: "" 
 -- hArgOrg:super: entry 
 -- Store itemArgs: W := W - 1 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=163 vDescInx=95 vdtTop: 2 
 rtnAlloc 1
 toSuper 95
DO:
 mvStack 
 L1:
 -- genclass:stmt: "W := W - 1" 
 -- $Assign:gen: "W := W - 1"  
 -- assign: "W := W - 1" 
 -- computeAdr:superAdj: 0 "W" 
 -- computeAdr: 1 :rec: "none"  E: "W" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "W"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "W" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "dcrWaiting" on: 1 isValueObj: false 
 -- origin: SQS origin:isValueObj: false 
 rpushg dcrWaiting$163 1
 -- $ObjectInvocation_Unary:getAdr: "W" >ATd.off:5:on:1:superAdj:0"W: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "W: var integer" >newOff:5,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "W: var integer" ObjectGenerator 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"W":rec:- 
 -- After:U*U: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"W":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "W"  ATd: "W: var integer" 
 -- computeAdr:isFirst: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"W":rec:- 
 -- computeAdr:isLast:E:  "W" 
 -- AssignmentStatement:gen: "W := W - 1" right.label: "ObjectGenerator" "W - 1" 
 -- $ObjectGenerator:gen: "W - 1" >OGid:"-" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "W - 1" 
 -- OG:before:super.gen: "W - 1" 
 -- $Invocation:gen: "W - 1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "W - 1" 
 -- isConstant: "Invocation" "W - 1" 
 -- needorigin: "W - 1" 
 -- needOrigin:E: "W - 1"  E.ATd: "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- doNeedOrigin:Ex: "W - 1" 
 -- computeAdr:superAdj: 0 "W - 1" 
 -- computeAdr: 1 :rec: "none"  E: "W - 1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "W - 1"  
 -- $BinOp:loadOrigin: "W - 1"  
 -- BinaryExp:loadOrigin:empty: "W - 1" superAdj: 0 
 -- $BinOp:getAdr: "W - 1"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "W - 1"  ATd: "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "W - 1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "W - 1" E:  "W - 1" 
 -- INV:gen:E.loadArgs "W - 1" 
 -- $BinOp:loadArgs: "W - 1"  
 -- BinaryExp:loadArgs: "W - 1" superAdj: 0 
 -- $Invocation:gen: "W" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "W" 
 -- isConstant: "Invocation" "W" 
 -- notConst: W W: var integer 
 -- needorigin: "W" 
 -- needOrigin:E: "W"  E.ATd: "W: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "W" 
 -- computeAdr: 1 :rec: "none"  E: "W" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "W"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "W" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "dcrWaiting" on: 1 isValueObj: false 
 -- origin: SQS origin:isValueObj: false 
 rpushg dcrWaiting$163 1
 -- $ObjectInvocation_Unary:getAdr: "W" >ATd.off:5:on:1:superAdj:0"W: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "W: var integer" >newOff:5,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "W: var integer" ObjectGenerator 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"W":rec:- 
 -- After:U*U: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"W":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "W"  ATd: "W: var integer" 
 -- computeAdr:isFirst: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"W":rec:- 
 -- computeAdr:isLast:E:  "W" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"W":rec:- 
 -- rec:  "W" E:  "W" 
 -- INV:gen:E.loadArgs "W" 
 -- $ObjectInvocation_Unary:loadArgs: "W" >staticOff:0 "W: var integer" superAdj:0 
 -- $var:loadArgs: "W: var integer" >E:"W" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "W" 
 -- {(ObjectInvocation_Unary; (name: "W"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "W" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "W" :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"W":rec:- 
 -- $ObjectInvocation_Unary:invoke: "W" >rec:"W" ATd:"var" isValueObj E:"W" E.ATd:"W" unique:"False" 
 -- OI:invoke: "W" 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"W":rec:W 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"W":rec:W 
 -- OI:invoke:B: "W" E: "W"  rec: "W"  useRtnV: true "W: var integer" 
 -- OI:invoke:before:ATdx.invoke: var W 
 -- $var:invoke: "W: var integer" E: "W">newOff:5 useRTNv: "True" 
 -- DI:invoke: "W: var integer" 
 -- load: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"W":rec:W 
 -- isCompositeValueObj: false E: "W" "W: var integer" true 
 -- E.ATd.isValueObj: false rec: "W" 
 pushg 5 SQS$77
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"W":rec:W 
 -- 
 -- OI:invoke:X: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"W":rec:W 
 -- 
 -- OI:invoke:C: W :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 5 
 -- left:#I "W - 1" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"W":rec:W 
 -- $pattern:loadArgs: "-  : {   %basic 62;   in V: var integer;   out R: var integer" >E:"- 1":descNo:108} 
 -- ptn:loadArgs:E "- 1" 
 -- {(ObjectInvocation_Binary; (name: "-"); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 1));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "1" 
 -- E: "ObjectGenerator" 1 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "- 1" "ObjectInvocation_Binary" ActArg:  "1" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "- 1"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "1" :isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "- 1" 
 -- BinaryExp:loadArgs:end: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"W":rec:W 
 -- INV:gen:after:E.loadArgs "W - 1" 
 -- OIadr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"W":rec:W 
 -- IV:E.invoke:useRtnVal: true E: BinOp "W - 1" :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"W":rec:W 
 -- $BinOp:invoke: "W - 1"  
 -- BinaryExp:invoke: "W" rec: "W - 1" 
 -- M: "- 1" :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"W":rec:W 
 -- $ObjectInvocation_Binary:invoke: "- 1" >rec:"W" ATd:"pattern" E:"- 1" E.ATd:"-  " unique:"False" 
 -- OI:invoke: "- 1" 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"W":rec:W 
 -- origin:isValueObj "integer" 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"W":rec:W 
 -- OI:invoke:B: "- 1" E: "- 1"  rec: "W"  useRtnV: true "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern -   
 -- $pattern:invoke: "-  : {   %basic 62;   in V: var integer;   out R: var integer" E: "- 1" useRTNv: "True"} 
 -- ptn:invoke: "-  " E: "- 1" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "W" E: "- 1" 
 -- arg:integer 
 minus
 -- OI:invoke:V: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"- 1":rec:W 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"- 1":rec:W 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: - 1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "W" dstE: "W" dstE.ATd: "W: var integer" useRtn: false :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"W":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "W - 1" 
 -- isArgOfAssignI2IwithUniValArg "W := W - 1" arg: "W - 1" ObjectGenerator 
 -- arg.super.arg: "W - 1" BinOp 
 -- recx:BinaryExp:recx: "W - 1" 
 -- M: "- 1" label: "ObjectInvocation_Binary" M.ATd: "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- checkInt2IntWithUnitArg:rec: "W" E: "- 1" 
 -- arg:integer 
 -- M:arg: "1" ObjectGenerator false 
 -- dstDI: "W: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"W":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg SQS$77 5
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 164 
 -- Items:GenClass: display descNo: 164 isValue: false 
 -- Items:GenClass: display descNo: 136 isValue: false 
 -- Items:GenClass: display descNo: 21 isValue: false 

 CLASS display 164 1 BasicProcess 83
 -- vdtTableCopy: I:1:136 I:2:0
 -- vdtAdd: inx=2 descInx=164 vDescInx=164 vdtTop: 2 
 -- Store itemArgs: "\n---BP:---\n".print{--(id + ":A:").print	 } 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 -- super display
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 -- handleSuperArgs:E: "" theIS: ""\n---BP:---\n".print{--(id + ":A:").print	 }" 
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs: ""  
 -- hArgOrg:super: display 
 -- Store itemArgs: "\n---BP:---\n".print{--(id + ":A:").print	 } 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=164 vDescInx=136 vdtTop: 2 
 rtnAlloc 1
 toSuper 136
DO:
 mvStack 
 L1:
 -- genclass:stmt: ""\n---BP:---\n".print{--(id + ":A:").print	 }" 
 -- $ObjectGenerator:gen: ""\n---BP:---\n".print{--(id + ":A:").print	 " >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: ""\n---BP:---\n".print{--(id + ":A:").print	 }" 
 -- OG:before:super.gen: ""\n---BP:---\n".print{--(id + ":A:").print	 }" 
 -- $Invocation:gen: ""\n---BP:---\n".print{--(id + ":A:").print	 " >useRtnV:"False"superAdj: 0 descNo: 103} 
 -- INV:gen: ""\n---BP:---\n".print{--(id + ":A:").print	 }" 
 -- isConstant: "Invocation" ""\n---BP:---\n".print{--(id + ":A:").print	 }" 
 -- needorigin: ""\n---BP:---\n".print{--(id + ":A:").print	 }" 
 -- needOrigin:E: "print{--(id + ":A:").print	 }"  E.ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  ""\n---BP:---\n"" E:  ""\n---BP:---\n"" 
 -- INV:gen:E.loadArgs ""\n---BP:---\n"" 
 -- $String::loadArgs: ""\n---BP:---\n""  
 -- INV:gen:after:E.loadArgs ""\n---BP:---\n"" 
 -- OIadr: 
 -- $String::invoke: ""\n---BP:---\n""  
 pushText "\n---BP:---\n"
 -- IV:gen:checkTail: ""\n---BP:---\n".print{--(id + ":A:").print	 }" E: ""\n---BP:---\n"" tail: "print{--(id + ":A:").print	 }"  not isLast: false 
 -- $ObjectInvocation_Unary:loadArgs: "print{--(id + ":A:").print	 " >staticOff:0 "print: ;   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   "  ...} 
 -- $pattern:loadArgs: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " >E:"print;--(id + ":A:").print	 ":descNo:103} 
 -- ptn:loadArgs:E "print{--(id + ":A:").print	 }" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments --<12>(id + ":A:").print	 ))} 
 -- args: "--(id + ":A:").print	 " 
 -- $ObjectInvocation_Unary:invoke: "print{--(id + ":A:").print	 " >rec:""\n---BP:---\n"" ATd:"pattern" E:"print;--(id + ":A:").print	 " E.ATd:"print" unique:"False"} 
 -- OI:invoke: "print{--(id + ":A:").print	 }" 
 -- 
 -- OI:invoke:B: "print{--(id + ":A:").print	 }" E: "print{--(id + ":A:").print	 }"  rec: ""\n---BP:---\n""  useRtnV: false "print: {   gogo: ;      "gogo\n".print;   for(1):t ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " E: "print;--(id + ":A:").print	 " useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print{--(id + ":A:").print	 }" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke print 103 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print{--(id + ":A:").print	 } :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 85 
 -- Items:GenClass: keyboard descNo: 85 isValue: false 
 -- Items:GenClass: keyboard descNo: 83 isValue: false 
 -- Items:GenClass: BasicProcess descNo: 82 isValue: false 
 -- Items:GenClass: GeneralProcess descNo: 21 isValue: false 

 CLASS keyboard 85 4 BasicSystem 72
 -- vdtTableCopy: I:1:82 V:2:160 V:3:138 V:4:161 V:5:162 V:6:164 I:7:83 I:8:0
 -- vdtAdd: inx=8 descInx=85 vDescInx=85 vdtTop: 8 
 -- Store itemArgs: B: obj Indexed(100,integer){next: var integer;top: var integer;echo: var Boolean;%Public;Kscan: ;   loopB: obj ;      if (_kbhit) :then ;         top := to ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  4 origin
 -- super BasicProcess
 -- push:super.origin: 
 -- computeAdr:superAdj: 4 "BasicProcess("Keyboard")" 
 -- computeAdr: 1 :rec: "none"  E: "BasicProcess("Keyboard")" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "BasicProcess("Keyboard")"  
 pushThis 
 -- $ObjectInvocation_KeyWord:loadOrigin: "BasicProcess("Keyboard")" >on:0 superAdj:4 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 4 
 rpushg BasicSystem$72 4
 -- $ObjectInvocation_KeyWord:getAdr: "BasicProcess("Keyboard")" >ATd.off:0 (isPtn):on:0:superAdj:4"BasicProcess: GeneralProcess{   mkActive::< ;      status := p_status.ACTIV ..."} 
 -- $pattern:getAdr: "BasicProcess: GeneralProcess{   mkActive::< ;      status := p_status.ACTIVE;      SQS.insert(this(BasicProcess));   %Public;   start::<  -- need id as a ..."} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"BasicProcess("Keyboard")":rec:- 
 -- E.on: 0 
 -- beforeIsValueObj:E: "BasicProcess("Keyboard")"  ATd: "BasicProcess: GeneralProcess{   mkActive::< ;      status := p_status.ACTIVE;      SQS.insert(this(BasicProcess));    ...}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"BasicProcess("Keyboard")":rec:- 
 -- computeAdr:isLast:E:  "BasicProcess("Keyboard")" 
 -- genClass:after:pushAddress: "BasicProcess("Keyboard")" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"BasicProcess("Keyboard")" ... 
 -- handleSuperArgs:E: "BasicProcess("Keyboard")" theIS: "B: obj Indexed(100,integer){next: var integer;top: var integer;echo: var Boolean;%Public;Kscan: ;   loopB: obj ;      ...}" 
 -- super.sig:none:superAdj: 4 
 -- $ObjectInvocation_KeyWord:loadArgs: "BasicProcess("Keyboard")" >staticOff:0 "BasicProcess: GeneralProcess{   mkActive::< ;      status := p_status.ACTIVE;      SQS.insert( ..."} 
 -- $pattern:loadArgs: "BasicProcess: GeneralProcess{   mkActive::< ;      status := p_status.ACTIVE;      SQS.insert(this(BasicProcess));   %Public;   start::<  -- need id as ..."} 
 -- ptn:loadArgs:E "BasicProcess("Keyboard")" 
 -- {(ObjectInvocation_KeyWord; (name: "BasicProcess"); (Arguments;  (name: "BasicProcess");  (name: "(");  (ObjectGenerator;   (Invocation;    (String: Keyboard));   (Items d ...} 
 -- args: "BasicProcess("Keyboard")" 
 -- E: "ObjectGenerator" "Keyboard" 
 -- E.arg: "var" id: var LIB.StringLib.String 
 -- NonVirt: "BasicProcess("Keyboard")" "ObjectInvocation_KeyWord" ActArg:  ""Keyboard"" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "BasicProcess("Keyboard")"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: ""Keyboard"" >OGid:"String" IS.isempty! staticOff=0 descNo=0 superAdj=4 
 -- OG:gen: ""Keyboard"" 
 -- OG:before:super.gen: ""Keyboard"" 
 -- $Invocation:gen: ""Keyboard"" >useRtnV:"True"superAdj: 4 
 -- INV:gen: ""Keyboard"" 
 -- isConstant: "Invocation" ""Keyboard"" 
 -- needorigin: ""Keyboard"" 
 -- needOrigin:E: ""Keyboard""  E.ATd: "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V : ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 4 
 -- rec:  ""Keyboard"" E:  ""Keyboard"" 
 -- INV:gen:E.loadArgs ""Keyboard"" 
 -- $String::loadArgs: ""Keyboard""  
 -- INV:gen:after:E.loadArgs ""Keyboard"" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: String: ""Keyboard"" 
 -- $String::invoke: ""Keyboard""  
 pushText "Keyboard"
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "id: var LIB.StringLib.String" :isBasicVal: false :valueObj: false 
 -- :actArg: ""Keyboard"" :isBasicVal: false 
 -- case:B: "Keyboard" ObjectGenerator 5 5 5 false false 
 -- end:loadArgs:NonVirt: "BasicProcess("Keyboard")" 
 -- hArgOrg:super: BasicProcess 
 -- Store itemArgs: B: obj Indexed(100,integer){next: var integer;top: var integer;echo: var Boolean;%Public;Kscan: ;   loopB: obj ;      if (_kbhit) :then ;         top := to ...} 
 -- Store:Origin: 0 
 rShiftUp  1
 tstOriginIsNone 
 rstore  4 origin
 -- super BasicProcess
 -- push:super.origin: 
 -- computeAdr:superAdj: 4 "GeneralProcess" 
 -- computeAdr: 1 :rec: "none"  E: "GeneralProcess" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "GeneralProcess"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "GeneralProcess" >on:2 superAdj:4 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 4 
 rpushg BasicSystem$72 4
 -- items:goOrigin:encOG: "BasicSystem" on: 2 isValueObj: false 
 -- origin: BasicSystemLib origin:isValueObj: false 
 rpushg BasicSystem$72 1
 -- items:goOrigin:encOG: "BasicSystemLib" on: 1 isValueObj: false 
 -- origin: LIB origin:isValueObj: false 
 rpushg BasicSystemLib$38 1
 -- IV:viaIncl:on: 0 "BETA"  org: "%id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--Collectio ...}" 
 -- viaIncl:son:isFirst: true viaIncl<>none: false "BETA" 
 -- items:goOrigin:encOG: "LIB" on: 1 isValueObj: false 
 -- origin: BETAworld origin:isValueObj: false 
 rpushg LIB$33 1
 rpushg BETA 2
 -- $ObjectInvocation_Unary:getAdr: "GeneralProcess" >ATd.off:0 (isPtn):on:2:superAdj:4"GeneralProcess(id: var LIB.StringLib.String): {   start:< ;      inner(start);   mkActi ..."} 
 -- $pattern:getAdr: "GeneralProcess(id: var LIB.StringLib.String): {   start:< ;      inner(start);   mkActive:< ;      inner(mkActive);   addWaiting:< ;      inner(addWaitin ..."} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"GeneralProcess":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "GeneralProcess"  ATd: "GeneralProcess(id: var LIB.StringLib.String): {   start:< ;      inner(start);   mkActive:< ;      inner(mkActive);   addWaitin ...}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"GeneralProcess":rec:- 
 -- computeAdr:isLast:E:  "GeneralProcess" 
 -- genClass:after:pushAddress: "GeneralProcess" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"GeneralProcess":rec:- 
 -- handleSuperArgs:E: "GeneralProcess" theIS: "mkActive::< {   status := p_status.ACTIVE;   SQS.insert(this(BasicProcess));%Public;start::<  -- need id as argument;   status  ...}" 
 -- super.sig:not:none:superAdj: -4 
 -- $ObjectInvocation_Unary:loadArgs: "GeneralProcess" >staticOff:0 "GeneralProcess(id: var LIB.StringLib.String): {   start:< ;      inner(start);   mkActive:< ;      inner(m ..."} 
 -- $pattern:loadArgs: "GeneralProcess(id: var LIB.StringLib.String): {   start:< ;      inner(start);   mkActive:< ;      inner(mkActive);   addWaiting:< ;      inner(addWait ..."} 
 -- ptn:loadArgs:E "GeneralProcess" 
 -- {(ObjectInvocation_Unary; (name: "GeneralProcess"); (Arguments))} 
 -- args: "" 
 rShiftDown  1
 -- hArgOrg:super: GeneralProcess 
 -- Store itemArgs: B: obj Indexed(100,integer){next: var integer;top: var integer;echo: var Boolean;%Public;Kscan: ;   loopB: obj ;      if (_kbhit) :then ;         top := to ...} 
 -- id: var LIB.StringLib.String true 5 
 pushThis 
 rstoreg  id 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 1 V: R: 
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=85 vDescInx=82 vdtTop: 8 
 -- $pattern:gen: "start:< {   inner(start)" } 
 -- $pattern:gen: "mkActive:< {   inner(mkActive)" } 
 -- $pattern:gen: "addWaiting:< {   inner(addWaiting);   --put('R')" } 
 -- $pattern:gen: "dcrWaiting:< {   inner(dcrWaiting)" } 
 -- $pattern:gen: "display:< {   "\n---GP:---".print;   inner(display)" } 
 -- $var:gen: "status: var integer"  
 -- DI:gen: "status: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  status 
 -- $pattern:gen: "mkActive::< {   status := p_status.ACTIVE;   SQS.insert(this(BasicProcess))" } 
 -- $Property:gen: "%Public"  
 -- $pattern:gen: "start::<  -- need id as argument{   status := p_status.ACTIVE;   SQS.insert(this(BasicProcess));   inner(start)" } 
 -- $pattern:gen: "addWaiting::< {   --SQS.addWaitingstatus := P_status.WAITING" } 
 -- $pattern:gen: "dcrWaiting::< {   SQS.dcrWaiting" } 
 -- $pattern:gen: "display::< {   "\n---BP:---\n".print;   --(id + ":A:").print	 " } 
 -- $obj:gen: "B: obj Indexed(100,integer)"  
 -- DI:gen: "B: obj Indexed(100,integer)" DI:isConst: true :isBasicValue: false :primNo: 114 
 -- DI:add:BP4:  B 
 -- $ObjectGenerator:gen: "Indexed(100,integer)" >OGid:"B" IS.isempty! staticOff=5 descNo=0 superAdj=0 
 -- OG:gen: "Indexed(100,integer)" 
 -- OG:before:super.gen: "Indexed(100,integer)" 
 -- $Invocation:gen: "Indexed(100,integer)" >useRtnV:"False"superAdj: 0 descNo: 86 
 -- INV:gen: "Indexed(100,integer)" 
 -- isConstant: "Invocation" "Indexed(100,integer)" 
 -- needorigin: "Indexed(100,integer)" 
 -- needOrigin:E: "Indexed(100,integer)"  E.ATd: "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var int ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%globals{   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];   p ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "Indexed(100,integer)" E:  "Indexed(100,integer)" 
 -- INV:gen:E.loadArgs "Indexed(100,integer)" 
 -- $ObjectInvocation_Function:loadArgs: "Indexed(100,integer)" >staticOff:0 "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   len ..."} 
 -- $pattern:loadArgs: "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];  ..."} 
 -- ptn:loadArgs:E "Indexed(100,integer)" 
 -- {(ObjectInvocation_Function; (name: "Indexed"); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 100));   (Items descNo: 0 origDescNo: 0));  (ObjectGenerator ...} 
 -- args: "(100,integer)" 
 -- E: "ObjectGenerator" 100 
 -- E: "ObjectGenerator" integer 
 -- E.arg: "var" in range: var Integer 
 -- NonVirt: "Indexed(100,integer)" "ObjectInvocation_Function" ActArg:  "100" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "Indexed(100,integer)"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "100" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "100" 
 -- OG:before:super.gen: "100" 
 -- $Invocation:gen: "100" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "100" 
 -- isConstant: "Invocation" "100" 
 -- needorigin: "100" 
 -- needOrigin:E: "100"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: va ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "100" E:  "100" 
 -- INV:gen:E.loadArgs "100" 
 -- $ConstLiteral:loadArgs: "100"  
 -- INV:gen:after:E.loadArgs "100" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "100" 
 -- $ConstLiteral:invoke: "100"  
 pushc 100
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in range: var Integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "100" :isBasicVal: true 
 -- case:B: 100 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "Indexed(100,integer)" 
 -- INV:gen:after:E.loadArgs "Indexed(100,integer)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Function "Indexed(100,integer)" 
 -- $ObjectInvocation_Function:invoke: "Indexed(100,integer)" >rec:"Indexed(100,integer)" ATd:"pattern" E:"Indexed(100,integer)" E.ATd:"Indexed" unique:"False" 
 -- OI:invoke: "Indexed(100,integer)" 
 -- 
 -- OI:invoke:B: "Indexed(100,integer)" E: "Indexed(100,integer)"  rec: "Indexed(100,integer)"  useRtnV: false "Indexed: {   %globals;   %basic 114;   %public;   in range: var ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Indexed 
 -- $pattern:invoke: "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];    ..."} 
 -- ptn:invoke: "Indexed" E: "Indexed(100,integer)" ptnKind: 0 useRtnV: false 
 pushThis 
 -- ObjTmpStack:add: "Indexed" : "%globals{   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];   p ...}" 
 pushc 1
 allocIndexed keyboard$85 86 1 0
 pushThis 
 rstoreg  keyboard$85 5
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 1 V: R: 
   ;; vTop(0,0)=[] rTop(-3,1)=[]
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- OI:invoke:C: Indexed(100,integer) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- $var:gen: "next: var integer"  
 -- DI:gen: "next: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  next 
 -- $var:gen: "top: var integer"  
 -- DI:gen: "top: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  top 
 -- $var:gen: "echo: var Boolean"  
 -- DI:gen: "echo: var Boolean" DI:isConst: false :isBasicValue: true :primNo: 4 
 -- DI:add:BP1:  echo 
 -- $Property:gen: "%Public"  
 rtnAlloc 1
 toSuper 82
DO:
 mvStack 
 L1:
 -- genclass:stmt: "%Public" 
 -- $Property:gen: "%Public"  
 -- genclass:stmt: "Kscan" 
 -- $ObjectGenerator:gen: "Kscan" >OGid:"Kscan" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "Kscan" 
 -- OG:before:super.gen: "Kscan" 
 -- $Invocation:gen: "Kscan" >useRtnV:"False"superAdj: 0 descNo: 88 
 -- INV:gen: "Kscan" 
 -- isConstant: "Invocation" "Kscan" 
 -- needorigin: "Kscan" 
 -- needOrigin:E: "Kscan"  E.ATd: "Kscan: {   loopB: obj ;      if (_kbhit) :then ;         top := top + 1;         B.put(_iget):at[top];      keyboard.suspend;      restart(l ...}" 
 -- doNeedOrigin:Ex: "Kscan" 
 -- computeAdr:superAdj: 0 "Kscan" 
 -- computeAdr: 1 :rec: "none"  E: "Kscan" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Kscan"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Kscan" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "Kscan" >ATd.off:0 (isPtn):on:0:superAdj:0"Kscan: {   loopB: obj ;      if (_kbhit) :then ;         top := top + 1;         B.put(_iget):at ..."} 
 -- $pattern:getAdr: "Kscan: {   loopB: obj ;      if (_kbhit) :then ;         top := top + 1;         B.put(_iget):at[top];      keyboard.suspend;      restart(loopB)" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Kscan":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Kscan":rec:- 
 -- computeAdr:isLast:E:  "Kscan" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Kscan":rec:- 
 -- rec:  "Kscan" E:  "Kscan" 
 -- INV:gen:E.loadArgs "Kscan" 
 -- $ObjectInvocation_Unary:loadArgs: "Kscan" >staticOff:0 "Kscan: {   loopB: obj ;      if (_kbhit) :then ;         top := top + 1;         B.put(_iget):at[top];      keyboar ..."} 
 -- $pattern:loadArgs: "Kscan: {   loopB: obj ;      if (_kbhit) :then ;         top := top + 1;         B.put(_iget):at[top];      keyboard.suspend;      restart(loopB)" >E:" ..."} 
 -- ptn:loadArgs:E "Kscan" 
 -- {(ObjectInvocation_Unary; (name: "Kscan"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "Kscan" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "Kscan" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Kscan":rec:- 
 -- $ObjectInvocation_Unary:invoke: "Kscan" >rec:"Kscan" ATd:"pattern" E:"Kscan" E.ATd:"Kscan" unique:"False" 
 -- OI:invoke: "Kscan" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Kscan":rec:Kscan 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Kscan":rec:Kscan 
 -- OI:invoke:B: "Kscan" E: "Kscan"  rec: "Kscan"  useRtnV: false "Kscan: {   loopB: obj ;      if (_kbhit) :then ;         top := top + 1;         B.put(_iget):at[top];       ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Kscan 
 -- $pattern:invoke: "Kscan: {   loopB: obj ;      if (_kbhit) :then ;         top := top + 1;         B.put(_iget):at[top];      keyboard.suspend;      restart(loopB)" E: "Ks ..."} 
 -- ptn:invoke: "Kscan" E: "Kscan" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Kscan":rec:Kscan 
 invoke Kscan 88 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -4 rTopMax: 1 V: R: 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Kscan":rec:Kscan 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Kscan":rec:Kscan 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: Kscan :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Kscan":rec:Kscan 
 L2:
 rtnInner  M
 END OSDV:0 objSize:8 isIndexed:0
 -- Handle VB: "B: obj Indexed(100,integer){next: var integer;top: var integer;echo: var Boolean;%Public;Kscan: ;   loopB: obj ;      if (_kbhit) :then ;         top := top +  ...}" E ... "B ..." 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 88 
 -- Items:GenClass: Kscan descNo: 88 isValue: false 
 -- Items:GenClass: Kscan descNo: 21 isValue: false 

 CLASS Kscan 88 1 keyboard 85
 -- Store itemArgs: loopB: obj {   if (_kbhit) :then ;      top := top + 1;      B.put(_iget):at[top];   keyboard.suspend;   restart(loopB)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=88 vDescInx=88 vdtTop: 1 
 mvStack 
 -- $obj:gen: "loopB: obj {   if (_kbhit) :then ;      top := top + 1;      B.put(_iget):at[top];   keyboard.suspend;   restart(loopB)" } 
 -- DI:gen: "loopB: obj {   if (_kbhit) :then ;      top := top + 1;      B.put(_iget):at[top];   keyboard.suspend;   restart(loopB)}" DI:isConst: true :isBasicValue: false :p ... 0 
 -- DI:add:BP4:  loopB 
 -- $ObjectGenerator:gen: "if (_kbhit) :then {      top := top + 1;      B.put(_iget):at[top];   keyboard.suspend;   restart(loopB)" >OGid:"loopB" singular! staticOff=2 descNo ...} 
 -- OG:gen: "if (_kbhit) :then {      top := top + 1;      B.put(_iget):at[top];   keyboard.suspend;   restart(loopB)}" 
 pushThis 
 -- before objTmpStack:add:  89   "loopB" 
 invoke loopB 89 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 -- pushReturn:  "Kscan" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 89 
 -- Items:GenClass: loopB descNo: 89 isValue: false 
 -- Items:GenClass: loopB descNo: 21 isValue: false 

 CLASS loopB 89 1 Kscan 88
 -- Store itemArgs: if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top];keyboard.suspend;restart(loopB)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=89 vDescInx=89 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top]}" 
 -- $ObjectGenerator:gen: "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top]" >OGid:"if:then$0" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top]}" 
 -- OG:before:super.gen: "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top]}" 
 -- $Invocation:gen: "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top]" >useRtnV:"False"superAdj: 0} 
 -- INV:gen: "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top]}" 
 -- isConstant: "Invocation" "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top]}" 
 -- needorigin: "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top]}" 
 -- needOrigin:E: "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top]}"  E.ATd: "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %b ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top]}" E:  "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top]}" 
 -- INV:gen:E.loadArgs "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top]}" 
 -- $IfThen:loadArgs: "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top]" } 
 -- INV:gen:after:E.loadArgs "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top]}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top]}" 
 -- $IfThen:invoke: "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top]" } 
 -- $IfThen:gen: "if (_kbhit) :then {   top := top + 1;   B.put(_iget):at[top]" } 
 -- $ObjectGenerator:gen: "(_kbhit)" >OGid:"_kbhit" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(_kbhit)" 
 -- OG:before:super.gen: "(_kbhit)" 
 -- $Invocation:gen: "(_kbhit)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(_kbhit)" 
 -- isConstant: "Invocation" "(_kbhit)" 
 -- needorigin: "(_kbhit)" 
 -- needOrigin:E: "(_kbhit)"  E.ATd: "_kbhit: {   %external 5;   out B: var boolean}" 
 -- doNeedOrigin:Ex: "(_kbhit)" 
 -- computeAdr:superAdj: 0 "(_kbhit)" 
 -- computeAdr: 1 :rec: "none"  E: "(_kbhit)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(_kbhit)"  
 -- $BracketedExp:loadOrigin: "(_kbhit)"  
 -- computeAdr:superAdj: 0 "_kbhit" 
 -- computeAdr: 1 :rec: "none"  E: "_kbhit" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "_kbhit"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "_kbhit" >on:5 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loopB" on: 5 isValueObj: false 
 -- origin: Kscan origin:isValueObj: false 
 rpushg loopB$89 1
 -- items:goOrigin:encOG: "Kscan" on: 4 isValueObj: false 
 -- origin: keyboard origin:isValueObj: false 
 rpushg Kscan$88 1
 -- items:goOrigin:encOG: "keyboard" on: 3 isValueObj: false 
 -- origin: BasicSystem origin:isValueObj: false 
 rpushg keyboard$85 4
 -- items:goOrigin:encOG: "BasicSystem" on: 2 isValueObj: false 
 -- origin: BasicSystemLib origin:isValueObj: false 
 rpushg BasicSystem$72 1
 -- items:goOrigin:encOG: "BasicSystemLib" on: 1 isValueObj: false 
 -- origin: LIB origin:isValueObj: false 
 rpushg BasicSystemLib$38 1
 -- IV:viaIncl:on: 0 "BETA"  org: "%id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--Collectio ...}" 
 -- viaIncl:son:isFirst: true viaIncl<>none: false "BETA" 
 -- items:goOrigin:encOG: "LIB" on: 1 isValueObj: false 
 -- origin: BETAworld origin:isValueObj: false 
 rpushg LIB$33 1
 rpushg BETA 2
 -- $ObjectInvocation_Unary:getAdr: "_kbhit" >ATd.off:0 (isPtn):on:5:superAdj:0"_kbhit: {   %external 5;   out B: var boolean":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj: ...} 
 -- $pattern:getAdr: "_kbhit: {   %external 5;   out B: var boolean" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"_kbhit":rec:- 
 -- E.on: 5 
 -- beforeIsValueObj:E: "_kbhit"  ATd: "_kbhit: {   %external 5;   out B: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"_kbhit":rec:- 
 -- computeAdr:isLast:E:  "_kbhit" 
 -- BE:loadOrigin:E: _kbhit 
 -- $ObjectInvocation_Unary:getAdr: "_kbhit" >ATd.off:0 (isPtn):on:5:superAdj:0"_kbhit: {   %external 5;   out B: var boolean":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj: ...} 
 -- $pattern:getAdr: "_kbhit: {   %external 5;   out B: var boolean" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"_kbhit":rec:- 
 -- E.on: 5 
 -- beforeIsValueObj:E: "_kbhit"  ATd: "_kbhit: {   %external 5;   out B: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"_kbhit":rec:- 
 -- computeAdr:isLast:E:  "_kbhit" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"_kbhit":rec:- 
 -- rec:  "_kbhit" E:  "_kbhit" 
 -- INV:gen:E.loadArgs "_kbhit" 
 -- $ObjectInvocation_Unary:loadArgs: "_kbhit" >staticOff:0 "_kbhit: {   %external 5;   out B: var boolean" superAdj:0} 
 -- $pattern:loadArgs: "_kbhit: {   %external 5;   out B: var boolean" >E:"_kbhit":descNo:90} 
 -- ptn:loadArgs:E "_kbhit" 
 -- {(ObjectInvocation_Unary; (name: "_kbhit"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "_kbhit" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "_kbhit" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"_kbhit":rec:- 
 -- $ObjectInvocation_Unary:invoke: "_kbhit" >rec:"_kbhit" ATd:"pattern" E:"_kbhit" E.ATd:"_kbhit" unique:"False" 
 -- OI:invoke: "_kbhit" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"_kbhit":rec:_kbhit 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"_kbhit":rec:_kbhit 
 -- OI:invoke:B: "_kbhit" E: "_kbhit"  rec: "_kbhit"  useRtnV: true "_kbhit: {   %external 5;   out B: var boolean}" 
 -- OI:invoke:before:ATdx.invoke: pattern _kbhit 
 -- $pattern:invoke: "_kbhit: {   %external 5;   out B: var boolean" E: "_kbhit" useRTNv: "True"} 
 -- ptn:invoke: "_kbhit" E: "_kbhit" ptnKind: 0 useRtnV: true 
 invokeExternal 5
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"_kbhit":rec:_kbhit 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"_kbhit":rec:_kbhit 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: _kbhit :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"_kbhit":rec:_kbhit 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: "top := top + 1{   B.put(_iget):at[top]" >OGid:"$91" singular! staticOff=0 descNo=91 superAdj=0} 
 -- OG:gen: "top := top + 1{   B.put(_iget):at[top]}" 
 pushThis 
 -- before objTmpStack:add:  91   "$91" 
 invoke $91 91 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "keyboard.suspend" 
 -- $ObjectGenerator:gen: "keyboard.suspend" >OGid:"suspend" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "keyboard.suspend" 
 -- OG:before:super.gen: "keyboard.suspend" 
 -- $Invocation:gen: "keyboard.suspend" >useRtnV:"False"superAdj: 0 descNo: 84 
 -- INV:gen: "keyboard.suspend" 
 -- isConstant: "Invocation" "keyboard.suspend" 
 -- needorigin: "keyboard.suspend" 
 -- needOrigin:E: "suspend"  E.ATd: "suspend: {   %basic 111}" 
 -- doNeedOrigin:Ex: "suspend" 
 -- computeAdr:superAdj: 0 "keyboard.suspend" 
 -- computeAdr: 1 :rec: "none"  E: "keyboard" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "keyboard"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "keyboard" >on:3 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loopB" on: 3 isValueObj: false 
 -- origin: Kscan origin:isValueObj: false 
 rpushg loopB$89 1
 -- items:goOrigin:encOG: "Kscan" on: 2 isValueObj: false 
 -- origin: keyboard origin:isValueObj: false 
 rpushg Kscan$88 1
 -- items:goOrigin:encOG: "keyboard" on: 1 isValueObj: false 
 -- origin: BasicSystem origin:isValueObj: false 
 rpushg keyboard$85 4
 -- $ObjectInvocation_Unary:getAdr: "keyboard" >ATd.off:9:on:3:superAdj:0"keyboard: obj BasicProcess("Keyboard"){   B: obj Indexed(100,integer);   next: var integer;   top: va ..."} 
 -- $obj:getAdr: "keyboard: obj BasicProcess("Keyboard"){   B: obj Indexed(100,integer);   next: var integer;   top: var integer;   echo: var Boolean;   %Public;   Kscan: ;    ..."} 
 -- E.on: 3 
 -- beforeIsValueObj:E: "keyboard"  ATd: "keyboard: obj BasicProcess("Keyboard"){   B: obj Indexed(100,integer);   next: var integer;   top: var integer;   echo: var Boolean;  ...}" 
 -- computeAdr:isFirst: :Adr:off:9 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "keyboard"  E: "suspend" 
 -- :Adr:off:9 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "suspend" >ATd.off:0 (isPtn):on:0:superAdj:0"suspend: {   %basic 111":Adr:off:9 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ...} 
 -- $pattern:getAdr: "suspend: {   %basic 111" } 
 -- :Adr:off:9 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "keyboard" >staticOff:0 "keyboard: obj BasicProcess("Keyboard"){   B: obj Indexed(100,integer);   next: var integer;   top: var integer;  ..."} 
 -- $obj:loadArgs: "keyboard: obj BasicProcess("Keyboard"){   B: obj Indexed(100,integer);   next: var integer;   top: var integer;   echo: var Boolean;   %Public;   Kscan: ;  ..."} 
 -- $ObjectInvocation_Unary:invoke: "keyboard" >rec:"keyboard" ATd:"obj" E:"suspend" E.ATd:"suspend" unique:"False" 
 -- OI:invoke: "keyboard" 
 -- :Adr:off:9 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend":rec:keyboard 
 -- :Adr:off:9 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend":rec:keyboard 
 -- OI:invoke:B: "keyboard" E: "suspend"  rec: "keyboard"  useRtnV: true "keyboard: obj BasicProcess("Keyboard"){   B: obj Indexed(100,integer);   next: var integer;   top: va ...}" 
 -- OI:invoke:before:ATdx.invoke: obj keyboard 
 -- $obj:invoke: "keyboard: obj BasicProcess("Keyboard"){   B: obj Indexed(100,integer);   next: var integer;   top: var integer;   echo: var Boolean;   %Public;   Kscan: ;    ..."} 
 -- DI:invoke: "keyboard: obj BasicProcess("Keyboard"){   B: obj Indexed(100,integer);   next: var integer;   top: var integer;   echo: var Boolean;   %Public;   Kscan: ;      ...}" 
 -- >Object:unique: false 
 -- load: :Adr:off:9 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend":rec:keyboard 
 -- isCompositeValueObj: false E: "suspend" "suspend: {   %basic 111}" false 
 -- E.ATd.isValueObj: false rec: "keyboard" 
 rpushg loopB$89 9
 -- OI:invoke:V: adr: :Adr:off:9 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend":rec:keyboard 
 -- 
 -- OI:invoke:X: adr: :Adr:off:9 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend":rec:keyboard 
 -- 
 -- OI:invoke:C: keyboard :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "keyboard" E: "suspend" 
 -- computeAdr:isLast:E:  "suspend" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:9 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend":rec:keyboard 
 -- rec:  "keyboard" E:  "suspend" 
 -- INV:gen:E.loadArgs "suspend" 
 -- $ObjectInvocation_Unary:loadArgs: "suspend" >staticOff:0 "suspend: {   %basic 111" superAdj:0} 
 -- $pattern:loadArgs: "suspend: {   %basic 111" >E:"suspend":descNo:84} 
 -- ptn:loadArgs:E "suspend" 
 -- {(ObjectInvocation_Unary; (name: "suspend"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "suspend" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "suspend" :Adr:off:9 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend":rec:ke ... 
 -- $ObjectInvocation_Unary:invoke: "suspend" >rec:"keyboard" ATd:"pattern" E:"suspend" E.ATd:"suspend" unique:"False" 
 -- OI:invoke: "suspend" 
 -- :Adr:off:9 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend":rec:keyboard 
 -- :Adr:off:9 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend":rec:keyboard 
 -- OI:invoke:B: "suspend" E: "suspend"  rec: "keyboard"  useRtnV: false "suspend: {   %basic 111}" 
 -- OI:invoke:before:ATdx.invoke: pattern suspend 
 -- $pattern:invoke: "suspend: {   %basic 111" E: "suspend" useRTNv: "False"} 
 -- ptn:invoke: "suspend" E: "suspend" ptnKind: 0 useRtnV: false 
 suspend
 -- OI:invoke:V: adr: :Adr:off:9 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend":rec:keyboard 
 -- 
 -- OI:invoke:X: adr: :Adr:off:9 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend":rec:keyboard 
 -- 
 -- OI:invoke:C: suspend :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 9 
 -- OG:gen:end: :Adr:off:9 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend":rec:keyboard 
 -- genclass:stmt: "restart(loopB)" 
 -- $ObjectGenerator:gen: "restart(loopB)" >OGid:"restart" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "restart(loopB)" 
 -- OG:before:super.gen: "restart(loopB)" 
 -- $Invocation:gen: "restart(loopB)" >useRtnV:"False"superAdj: 0 descNo: 50 
 -- INV:gen: "restart(loopB)" 
 -- isConstant: "Invocation" "restart(loopB)" 
 -- needorigin: "restart(loopB)" 
 -- needOrigin:E: "restart(loopB)"  E.ATd: "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- doNeedOrigin:Ex: "restart(loopB)" 
 -- computeAdr:superAdj: 0 "restart(loopB)" 
 -- computeAdr: 1 :rec: "none"  E: "restart(loopB)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "restart(loopB)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "restart(loopB)" >on:5 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "restart(loopB)" >ATd.off:0 (isPtn):on:5:superAdj:0"restart(V: var integer):  -- odd parameter type!{   %basic 102":Adr:off:0 size:0 isFl ...} 
 -- $pattern:getAdr: "restart(V: var integer):  -- odd parameter type!{   %basic 102" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loopB)":rec:- 
 -- E.on: 5 
 -- beforeIsValueObj:E: "restart(loopB)"  ATd: "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loopB)":rec:- 
 -- computeAdr:isLast:E:  "restart(loopB)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loopB)":rec:- 
 -- rec:  "restart(loopB)" E:  "restart(loopB)" 
 -- INV:gen:E.loadArgs "restart(loopB)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "restart(loopB)" >staticOff:0 "restart(V: var integer):  -- odd parameter type!{   %basic 102" superAdj:0arg:"loopB"} 
 -- $pattern:loadArgs: "restart(V: var integer):  -- odd parameter type!{   %basic 102" >E:"restart(loopB)":descNo:50} 
 -- INV:gen:after:E.loadArgs "restart(loopB)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "restart(loopB)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restar ..." 
 -- $ObjectInvocation_KeyWord:invoke: "restart(loopB)" >rec:"restart(loopB)" ATd:"pattern" E:"restart(loopB)" E.ATd:"restart(V: var integer)" unique:"False" 
 -- OI:invoke: "restart(loopB)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loopB)":rec:restart(loopB) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loopB)":rec:restart(loopB) 
 -- OI:invoke:B: "restart(loopB)" E: "restart(loopB)"  rec: "restart(loopB)"  useRtnV: false "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- OI:invoke:before:ATdx.invoke: pattern restart(V: var integer) 
 -- $pattern:invoke: "restart(V: var integer):  -- odd parameter type!{   %basic 102" E: "restart(loopB)" useRTNv: "False"} 
 -- ptn:invoke: "restart(V: var integer)" E: "restart(loopB)" ptnKind: 0 useRtnV: false 
 jmp L1
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loopB)":rec:restart(loopB) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loopB)":rec:restart(loopB) 
 -- 
 -- OI:invoke:C: restart(loopB) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loopB)":rec:restart(loopB) 
 L2:
 -- pushReturn:  "loopB" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 91 
 -- Items:GenClass: $91 descNo: 91 isValue: false 
 -- Items:GenClass: $91 descNo: 21 isValue: false 

 CLASS $91 91 1 loopB 89
 -- Store itemArgs: top := top + 1{B.put(_iget):at[top]} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=91 vDescInx=91 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "top := top + 1" 
 -- $Assign:gen: "top := top + 1"  
 -- assign: "top := top + 1" 
 -- computeAdr:superAdj: 0 "top" 
 -- computeAdr: 1 :rec: "none"  E: "top" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "top"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "top" >on:3 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$91" on: 3 isValueObj: false 
 -- origin: loopB origin:isValueObj: false 
 rpushg $91$91 1
 -- items:goOrigin:encOG: "loopB" on: 2 isValueObj: false 
 -- origin: Kscan origin:isValueObj: false 
 rpushg loopB$89 1
 -- items:goOrigin:encOG: "Kscan" on: 1 isValueObj: false 
 -- origin: keyboard origin:isValueObj: false 
 rpushg Kscan$88 1
 -- $ObjectInvocation_Unary:getAdr: "top" >ATd.off:7:on:3:superAdj:0"top: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "top: var integer" >newOff:7,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "top: var integer" ObjectGenerator 
 -- :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"top":rec:- 
 -- After:U*U: :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"top":rec:- 
 -- E.on: 3 
 -- beforeIsValueObj:E: "top"  ATd: "top: var integer" 
 -- computeAdr:isFirst: :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"top":rec:- 
 -- computeAdr:isLast:E:  "top" 
 -- AssignmentStatement:gen: "top := top + 1" right.label: "ObjectGenerator" "top + 1" 
 -- $ObjectGenerator:gen: "top + 1" >OGid:"+" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "top + 1" 
 -- OG:before:super.gen: "top + 1" 
 -- $Invocation:gen: "top + 1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "top + 1" 
 -- isConstant: "Invocation" "top + 1" 
 -- needorigin: "top + 1" 
 -- needOrigin:E: "top + 1"  E.ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- doNeedOrigin:Ex: "top + 1" 
 -- computeAdr:superAdj: 0 "top + 1" 
 -- computeAdr: 1 :rec: "none"  E: "top + 1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "top + 1"  
 -- $BinOp:loadOrigin: "top + 1"  
 -- BinaryExp:loadOrigin:empty: "top + 1" superAdj: 0 
 -- $BinOp:getAdr: "top + 1"  
 -- E.on: 3 
 -- beforeIsValueObj:E: "top + 1"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "top + 1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "top + 1" E:  "top + 1" 
 -- INV:gen:E.loadArgs "top + 1" 
 -- $BinOp:loadArgs: "top + 1"  
 -- BinaryExp:loadArgs: "top + 1" superAdj: 0 
 -- $Invocation:gen: "top" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "top" 
 -- isConstant: "Invocation" "top" 
 -- notConst: top top: var integer 
 -- needorigin: "top" 
 -- needOrigin:E: "top"  E.ATd: "top: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "top" 
 -- computeAdr: 1 :rec: "none"  E: "top" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "top"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "top" >on:3 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$91" on: 3 isValueObj: false 
 -- origin: loopB origin:isValueObj: false 
 rpushg $91$91 1
 -- items:goOrigin:encOG: "loopB" on: 2 isValueObj: false 
 -- origin: Kscan origin:isValueObj: false 
 rpushg loopB$89 1
 -- items:goOrigin:encOG: "Kscan" on: 1 isValueObj: false 
 -- origin: keyboard origin:isValueObj: false 
 rpushg Kscan$88 1
 -- $ObjectInvocation_Unary:getAdr: "top" >ATd.off:7:on:3:superAdj:0"top: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "top: var integer" >newOff:7,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "top: var integer" ObjectGenerator 
 -- :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"top":rec:- 
 -- After:U*U: :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"top":rec:- 
 -- E.on: 3 
 -- beforeIsValueObj:E: "top"  ATd: "top: var integer" 
 -- computeAdr:isFirst: :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"top":rec:- 
 -- computeAdr:isLast:E:  "top" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"top":rec:- 
 -- rec:  "top" E:  "top" 
 -- INV:gen:E.loadArgs "top" 
 -- $ObjectInvocation_Unary:loadArgs: "top" >staticOff:0 "top: var integer" superAdj:0 
 -- $var:loadArgs: "top: var integer" >E:"top" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "top" 
 -- {(ObjectInvocation_Unary; (name: "top"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "top" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "top" :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"top":rec:- 
 -- $ObjectInvocation_Unary:invoke: "top" >rec:"top" ATd:"var" isValueObj E:"top" E.ATd:"top" unique:"False" 
 -- OI:invoke: "top" 
 -- :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"top":rec:top 
 -- :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"top":rec:top 
 -- OI:invoke:B: "top" E: "top"  rec: "top"  useRtnV: true "top: var integer" 
 -- OI:invoke:before:ATdx.invoke: var top 
 -- $var:invoke: "top: var integer" E: "top">newOff:7 useRTNv: "True" 
 -- DI:invoke: "top: var integer" 
 -- load: :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"top":rec:top 
 -- isCompositeValueObj: false E: "top" "top: var integer" true 
 -- E.ATd.isValueObj: false rec: "top" 
 pushg 7 keyboard$85
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"top":rec:top 
 -- 
 -- OI:invoke:X: adr: :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"top":rec:top 
 -- 
 -- OI:invoke:C: top :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 7 
 -- left:#I "top + 1" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"top":rec:top 
 -- $pattern:loadArgs: "+  : {   %basic 61;   in V: var integer;   out R: var integer" >E:"+ 1":descNo:49} 
 -- ptn:loadArgs:E "+ 1" 
 -- {(ObjectInvocation_Binary; (name: "+"); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 1));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "1" 
 -- E: "ObjectGenerator" 1 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "+ 1" "ObjectInvocation_Binary" ActArg:  "1" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ 1"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "1" :isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "+ 1" 
 -- BinaryExp:loadArgs:end: :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"top":rec:top 
 -- INV:gen:after:E.loadArgs "top + 1" 
 -- OIadr: :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"top":rec:top 
 -- IV:E.invoke:useRtnVal: true E: BinOp "top + 1" :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"top":rec:top 
 -- $BinOp:invoke: "top + 1"  
 -- BinaryExp:invoke: "top" rec: "top + 1" 
 -- M: "+ 1" :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"top":rec:top 
 -- $ObjectInvocation_Binary:invoke: "+ 1" >rec:"top" ATd:"pattern" E:"+ 1" E.ATd:"+  " unique:"False" 
 -- OI:invoke: "+ 1" 
 -- :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"top":rec:top 
 -- origin:isValueObj "integer" 
 -- :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"top":rec:top 
 -- OI:invoke:B: "+ 1" E: "+ 1"  rec: "top"  useRtnV: true "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- $pattern:invoke: "+  : {   %basic 61;   in V: var integer;   out R: var integer" E: "+ 1" useRTNv: "True"} 
 -- ptn:invoke: "+  " E: "+ 1" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "top" E: "+ 1" 
 -- arg:integer 
 plus
 -- OI:invoke:V: adr: :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:top 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:top 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: + 1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "top" dstE: "top" dstE.ATd: "top: var integer" useRtn: false :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"top":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "top + 1" 
 -- isArgOfAssignI2IwithUniValArg "top := top + 1" arg: "top + 1" ObjectGenerator 
 -- arg.super.arg: "top + 1" BinOp 
 -- recx:BinaryExp:recx: "top + 1" 
 -- M: "+ 1" label: "ObjectInvocation_Binary" M.ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- checkInt2IntWithUnitArg:rec: "top" E: "+ 1" 
 -- arg:integer 
 -- M:arg: "1" ObjectGenerator false 
 -- dstDI: "top: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"top":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg keyboard$85 7
 -- assign:adr.store:B: 
 -- genclass:stmt: "B.put(_iget):at[top]" 
 -- $ObjectGenerator:gen: "B.put(_iget):at[top]" >OGid:"put:at" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "B.put(_iget):at[top]" 
 -- OG:before:super.gen: "B.put(_iget):at[top]" 
 -- $Invocation:gen: "B.put(_iget):at[top]" >useRtnV:"False"superAdj: 0 descNo: 93 
 -- INV:gen: "B.put(_iget):at[top]" 
 -- isConstant: "Invocation" "B.put(_iget):at[top]" 
 -- needorigin: "B.put(_iget):at[top]" 
 -- needOrigin:E: "put(_iget):at[top]"  E.ATd: "put(V: var integer):at[inx: var integer]: {   %basic 115}" 
 -- doNeedOrigin:Ex: "put(_iget):at[top]" 
 -- computeAdr:superAdj: 0 "B.put(_iget):at[top]" 
 -- computeAdr: 1 :rec: "none"  E: "B" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "B"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "B" >on:3 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$91" on: 3 isValueObj: false 
 -- origin: loopB origin:isValueObj: false 
 rpushg $91$91 1
 -- items:goOrigin:encOG: "loopB" on: 2 isValueObj: false 
 -- origin: Kscan origin:isValueObj: false 
 rpushg loopB$89 1
 -- items:goOrigin:encOG: "Kscan" on: 1 isValueObj: false 
 -- origin: keyboard origin:isValueObj: false 
 rpushg Kscan$88 1
 -- $ObjectInvocation_Unary:getAdr: "B" >ATd.off:5:on:3:superAdj:0"B: obj Indexed(100,integer)":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIs ... 
 -- $obj:getAdr: "B: obj Indexed(100,integer)" >newOff:5,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique: ... 
 -- E.on: 3 
 -- beforeIsValueObj:E: "B"  ATd: "B: obj Indexed(100,integer)" 
 -- computeAdr:isFirst: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "B"  E: "put(_iget):at[top]" 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:getAdr: "put(_iget):at[top]" >ATd.off:0 (isPtn):on:0:superAdj:0"put(V: var integer):at[inx: var integer]: {   %basic 115":Adr:off:5 size:0 isFloa ...} 
 -- $pattern:getAdr: "put(V: var integer):at[inx: var integer]: {   %basic 115" } 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(_iget):at[top]":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "B" >staticOff:0 "B: obj Indexed(100,integer)" superAdj:0 
 -- $obj:loadArgs: "B: obj Indexed(100,integer)" >E:"B" 
 -- $pattern:loadArgs: "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];  ..."} 
 -- ptn:loadArgs:E "B" 
 -- {(ObjectInvocation_Unary; (name: "B"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "B" >rec:"B" ATd:"obj" E:"put(_iget):at[top]" E.ATd:"put(V: var integer):at[inx: var integer]" unique:"False" 
 -- OI:invoke: "B" 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(_iget):at[top]":rec:B 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(_iget):at[top]":rec:B 
 -- OI:invoke:B: "B" E: "put(_iget):at[top]"  rec: "B"  useRtnV: true "B: obj Indexed(100,integer)" 
 -- OI:invoke:before:ATdx.invoke: obj B 
 -- $obj:invoke: "B: obj Indexed(100,integer)" E: "put(_iget):at[top]">newOff:5 useRTNv: "True" 
 -- DI:invoke: "B: obj Indexed(100,integer)" 
 -- >Object:unique: false 
 -- load: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(_iget):at[top]":rec:B 
 -- isCompositeValueObj: false E: "put(_iget):at[top]" "put(V: var integer):at[inx: var integer]: {   %basic 115}" false 
 -- E.ATd.isValueObj: false rec: "B" 
 rpushg $91$91 5
 -- OI:invoke:V: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(_iget):at[top]":rec:B 
 -- 
 -- OI:invoke:X: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(_iget):at[top]":rec:B 
 -- 
 -- OI:invoke:C: B :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "B" E: "put(_iget):at[top]" 
 -- arg:other 
 -- computeAdr:isLast:E:  "put(_iget):at[top]" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(_iget):at[top]":rec:B 
 -- rec:  "B" E:  "put(_iget):at[top]" 
 -- INV:gen:E.loadArgs "put(_iget):at[top]" 
 -- $ObjectInvocation_KeyWord:loadArgs: "put(_iget):at[top]" >staticOff:0 "put(V: var integer):at[inx: var integer]: {   %basic 115" superAdj:0arg:"_iget"arg:"top"} 
 -- $pattern:loadArgs: "put(V: var integer):at[inx: var integer]: {   %basic 115" >E:"put(_iget):at[top]":descNo:93} 
 -- ptn:loadArgs:E "put(_iget):at[top]" 
 -- {(ObjectInvocation_KeyWord; (name: "put:at"); (Arguments;  (name: "put");  (name: "(");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "_iget");  ...} 
 -- args: "put(_iget):at[top]" 
 -- E: "ObjectGenerator" _iget 
 -- E: "ObjectGenerator" top 
 -- E.arg: "var" V: var integer 
 -- NonVirt: "put(_iget):at[top]" "ObjectInvocation_KeyWord" ActArg:  "_iget" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(_iget):at[top]"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "_iget" >OGid:"_iget" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "_iget" 
 -- OG:before:super.gen: "_iget" 
 -- $Invocation:gen: "_iget" >useRtnV:"True"superAdj: 0 descNo: 92 
 -- INV:gen: "_iget" 
 -- isConstant: "Invocation" "_iget" 
 -- needorigin: "_iget" 
 -- needOrigin:E: "_iget"  E.ATd: "_iget: {   %external 4;   out ch: var char}" 
 -- doNeedOrigin:Ex: "_iget" 
 -- computeAdr:superAdj: 0 "_iget" 
 -- computeAdr: 1 :rec: "none"  E: "_iget" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "_iget"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "_iget" >on:6 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$91" on: 6 isValueObj: false 
 -- origin: loopB origin:isValueObj: false 
 rpushg $91$91 1
 -- items:goOrigin:encOG: "loopB" on: 5 isValueObj: false 
 -- origin: Kscan origin:isValueObj: false 
 rpushg loopB$89 1
 -- items:goOrigin:encOG: "Kscan" on: 4 isValueObj: false 
 -- origin: keyboard origin:isValueObj: false 
 rpushg Kscan$88 1
 -- items:goOrigin:encOG: "keyboard" on: 3 isValueObj: false 
 -- origin: BasicSystem origin:isValueObj: false 
 rpushg keyboard$85 4
 -- items:goOrigin:encOG: "BasicSystem" on: 2 isValueObj: false 
 -- origin: BasicSystemLib origin:isValueObj: false 
 rpushg BasicSystem$72 1
 -- items:goOrigin:encOG: "BasicSystemLib" on: 1 isValueObj: false 
 -- origin: LIB origin:isValueObj: false 
 rpushg BasicSystemLib$38 1
 -- IV:viaIncl:on: 0 "BETA"  org: "%id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--Collectio ...}" 
 -- viaIncl:son:isFirst: true viaIncl<>none: false "BETA" 
 -- items:goOrigin:encOG: "LIB" on: 1 isValueObj: false 
 -- origin: BETAworld origin:isValueObj: false 
 rpushg LIB$33 1
 rpushg BETA 2
 -- $ObjectInvocation_Unary:getAdr: "_iget" >ATd.off:0 (isPtn):on:6:superAdj:0"_iget: {   %external 4;   out ch: var char":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 is ...} 
 -- $pattern:getAdr: "_iget: {   %external 4;   out ch: var char" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"_iget":rec:- 
 -- E.on: 6 
 -- beforeIsValueObj:E: "_iget"  ATd: "_iget: {   %external 4;   out ch: var char}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"_iget":rec:- 
 -- computeAdr:isLast:E:  "_iget" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"_iget":rec:- 
 -- rec:  "_iget" E:  "_iget" 
 -- INV:gen:E.loadArgs "_iget" 
 -- $ObjectInvocation_Unary:loadArgs: "_iget" >staticOff:0 "_iget: {   %external 4;   out ch: var char" superAdj:0} 
 -- $pattern:loadArgs: "_iget: {   %external 4;   out ch: var char" >E:"_iget":descNo:92} 
 -- ptn:loadArgs:E "_iget" 
 -- {(ObjectInvocation_Unary; (name: "_iget"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "_iget" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "_iget" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"_iget":rec:- 
 -- $ObjectInvocation_Unary:invoke: "_iget" >rec:"_iget" ATd:"pattern" E:"_iget" E.ATd:"_iget" unique:"False" 
 -- OI:invoke: "_iget" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"_iget":rec:_iget 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"_iget":rec:_iget 
 -- OI:invoke:B: "_iget" E: "_iget"  rec: "_iget"  useRtnV: true "_iget: {   %external 4;   out ch: var char}" 
 -- OI:invoke:before:ATdx.invoke: pattern _iget 
 -- $pattern:invoke: "_iget: {   %external 4;   out ch: var char" E: "_iget" useRTNv: "True"} 
 -- ptn:invoke: "_iget" E: "_iget" ptnKind: 0 useRtnV: true 
 invokeExternal 4
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"_iget":rec:_iget 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"_iget":rec:_iget 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: _iget :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"_iget":rec:_iget 
 -- formalArg:isPtn: "V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "_iget" :isBasicVal: true 
 -- case:B: _iget ObjectGenerator 1 0 0 false false 
 -- end:loadArgs:NonVirt: "put(_iget):at[top]" 
 -- E.arg: "var" inx: var integer 
 -- NonVirt: "put(_iget):at[top]" "ObjectInvocation_KeyWord" ActArg:  "top" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(_iget):at[top]"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "top" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "top" 
 -- OG:before:super.gen: "top" 
 -- $Invocation:gen: "top" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "top" 
 -- isConstant: "Invocation" "top" 
 -- notConst: top top: var integer 
 -- needorigin: "top" 
 -- needOrigin:E: "top"  E.ATd: "top: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "top" 
 -- computeAdr: 1 :rec: "none"  E: "top" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "top"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "top" >on:3 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$91" on: 3 isValueObj: false 
 -- origin: loopB origin:isValueObj: false 
 rpushg $91$91 1
 -- items:goOrigin:encOG: "loopB" on: 2 isValueObj: false 
 -- origin: Kscan origin:isValueObj: false 
 rpushg loopB$89 1
 -- items:goOrigin:encOG: "Kscan" on: 1 isValueObj: false 
 -- origin: keyboard origin:isValueObj: false 
 rpushg Kscan$88 1
 -- $ObjectInvocation_Unary:getAdr: "top" >ATd.off:7:on:3:superAdj:0"top: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "top: var integer" >newOff:7,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "top: var integer" ObjectGenerator 
 -- :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"top":rec:- 
 -- After:U*U: :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"top":rec:- 
 -- E.on: 3 
 -- beforeIsValueObj:E: "top"  ATd: "top: var integer" 
 -- computeAdr:isFirst: :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"top":rec:- 
 -- computeAdr:isLast:E:  "top" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"top":rec:- 
 -- rec:  "top" E:  "top" 
 -- INV:gen:E.loadArgs "top" 
 -- $ObjectInvocation_Unary:loadArgs: "top" >staticOff:0 "top: var integer" superAdj:0 
 -- $var:loadArgs: "top: var integer" >E:"top" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "top" 
 -- {(ObjectInvocation_Unary; (name: "top"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "top" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "top" :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"top":rec:- 
 -- $ObjectInvocation_Unary:invoke: "top" >rec:"top" ATd:"var" isValueObj E:"top" E.ATd:"top" unique:"False" 
 -- OI:invoke: "top" 
 -- :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"top":rec:top 
 -- :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"top":rec:top 
 -- OI:invoke:B: "top" E: "top"  rec: "top"  useRtnV: true "top: var integer" 
 -- OI:invoke:before:ATdx.invoke: var top 
 -- $var:invoke: "top: var integer" E: "top">newOff:7 useRTNv: "True" 
 -- DI:invoke: "top: var integer" 
 -- load: :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"top":rec:top 
 -- isCompositeValueObj: false E: "top" "top: var integer" true 
 -- E.ATd.isValueObj: false rec: "top" 
 pushg 7 keyboard$85
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"top":rec:top 
 -- 
 -- OI:invoke:X: adr: :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"top":rec:top 
 -- 
 -- OI:invoke:C: top :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 7 
 -- OG:gen:end: :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"top":rec:top 
 -- formalArg:isPtn: "inx: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "top" :isBasicVal: true 
 -- case:B: top ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "put(_iget):at[top]" 
 -- INV:gen:after:E.loadArgs "put(_iget):at[top]" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(_iget):at[top]" :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"pu ..." 
 -- $ObjectInvocation_KeyWord:invoke: "put(_iget):at[top]" >rec:"B" ATd:"pattern" E:"put(_iget):at[top]" E.ATd:"put(V: var integer):at[inx: var integer]" unique:"False" 
 -- OI:invoke: "put(_iget):at[top]" 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(_iget):at[top]":rec:B 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(_iget):at[top]":rec:B 
 -- OI:invoke:B: "put(_iget):at[top]" E: "put(_iget):at[top]"  rec: "B"  useRtnV: false "put(V: var integer):at[inx: var integer]: {   %basic 115}" 
 -- OI:invoke:before:ATdx.invoke: pattern put(V: var integer):at[inx: var integer] 
 -- $pattern:invoke: "put(V: var integer):at[inx: var integer]: {   %basic 115" E: "put(_iget):at[top]" useRTNv: "False"} 
 -- ptn:invoke: "put(V: var integer):at[inx: var integer]" E: "put(_iget):at[top]" ptnKind: 0 useRtnV: false 
 xstoreg  inx 1 0 1
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- stack: vpop : vTop: 0 vTopMax: 2 rTop: -3 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(_iget):at[top]":rec:B 
 -- 
 -- OI:invoke:X: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(_iget):at[top]":rec:B 
 -- 
 -- OI:invoke:C: put(_iget):at[top] :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 5 
 -- OG:gen:end: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(_iget):at[top]":rec:B 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 94 
 -- Items:GenClass: init descNo: 94 isValue: false 
 -- Items:GenClass: init descNo: 21 isValue: false 

 CLASS init 94 1 BasicSystem 72
 -- Store itemArgs: SQS.init 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=94 vDescInx=94 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "SQS.init" 
 -- $ObjectGenerator:gen: "SQS.init" >OGid:"init" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "SQS.init" 
 -- OG:before:super.gen: "SQS.init" 
 -- $Invocation:gen: "SQS.init" >useRtnV:"False"superAdj: 0 descNo: 110 
 -- INV:gen: "SQS.init" 
 -- isConstant: "Invocation" "SQS.init" 
 -- needorigin: "SQS.init" 
 -- needOrigin:E: "init"  E.ATd: "init: entry{   V := 1;   L.init;   L.id := "SQS";   Q.idf := "SQS:"}" 
 -- doNeedOrigin:Ex: "init" 
 -- computeAdr:superAdj: 0 "SQS.init" 
 -- computeAdr: 1 :rec: "none"  E: "SQS" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "SQS"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "SQS" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "init" on: 1 isValueObj: false 
 -- origin: BasicSystem origin:isValueObj: false 
 rpushg init$94 1
 -- $ObjectInvocation_Unary:getAdr: "SQS" >ATd.off:6:on:1:superAdj:0"SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Publi ..."} 
 -- $obj:getAdr: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if  ..."} 
 -- E.on: 1 
 -- beforeIsValueObj:E: "SQS"  ATd: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V ...}" 
 -- computeAdr:isFirst: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "SQS"  E: "init" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "init" >ATd.off:0 (isPtn):on:0:superAdj:0"init: entry{   V := 1;   L.init;   L.id := "SQS";   Q.idf := "SQS:"":Adr:off:6 size:0 isFloat:F i ...} 
 -- $pattern:getAdr: "init: entry{   V := 1;   L.init;   L.id := "SQS";   Q.idf := "SQS:"" } 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "SQS" >staticOff:0 "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ..."} 
 -- $obj:loadArgs: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      i ..."} 
 -- $ObjectInvocation_Unary:invoke: "SQS" >rec:"SQS" ATd:"obj" E:"init" E.ATd:"init" unique:"False" 
 -- OI:invoke: "SQS" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:SQS 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:SQS 
 -- OI:invoke:B: "SQS" E: "init"  rec: "SQS"  useRtnV: true "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   ent ...}" 
 -- OI:invoke:before:ATdx.invoke: obj SQS 
 -- $obj:invoke: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if  ..."} 
 -- DI:invoke: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if (V ...}" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:SQS 
 rpushg init$94 6
 -- OI:invoke:V: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:SQS 
 -- 
 -- OI:invoke:X: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:SQS 
 -- 
 -- OI:invoke:C: SQS :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "SQS" E: "init" 
 -- computeAdr:isLast:E:  "init" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:SQS 
 -- rec:  "SQS" E:  "init" 
 -- INV:gen:E.loadArgs "init" 
 -- $ObjectInvocation_Unary:loadArgs: "init" >staticOff:0 "init: entry{   V := 1;   L.init;   L.id := "SQS";   Q.idf := "SQS:"" superAdj:0} 
 -- $pattern:loadArgs: "init: entry{   V := 1;   L.init;   L.id := "SQS";   Q.idf := "SQS:"" >E:"init":descNo:110} 
 -- ptn:loadArgs:E "init" 
 -- {(ObjectInvocation_Unary; (name: "init"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "init" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "init" :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:SQS 
 -- $ObjectInvocation_Unary:invoke: "init" >rec:"SQS" ATd:"pattern" E:"init" E.ATd:"init" unique:"False" 
 -- OI:invoke: "init" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:SQS 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:SQS 
 -- OI:invoke:B: "init" E: "init"  rec: "SQS"  useRtnV: false "init: entry{   V := 1;   L.init;   L.id := "SQS";   Q.idf := "SQS:"}" 
 -- OI:invoke:before:ATdx.invoke: pattern init 
 -- $pattern:invoke: "init: entry{   V := 1;   L.init;   L.id := "SQS";   Q.idf := "SQS:"" E: "init" useRTNv: "False"} 
 -- ptn:invoke: "init" E: "init" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:SQS 
 invoke init 110 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:SQS 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:SQS 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: init :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 6 
 -- OG:gen:end: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:SQS 
 L2:
 -- pushReturn:  "init" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 110 
 -- Items:GenClass: init descNo: 110 isValue: false 
 -- Items:GenClass: init descNo: 95 isValue: false 
 -- Items:GenClass: entry descNo: 21 isValue: false 

 CLASS init 110 1 SQS 77
 -- vdtTableCopy: I:1:95 I:2:0
 -- vdtAdd: inx=2 descInx=110 vDescInx=110 vdtTop: 2 
 -- Store itemArgs: V := 1{L.init;L.id := "SQS";Q.idf := "SQS:"} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 -- super entry
 -- push:super.origin: 
 -- computeAdr:superAdj: 1 "entry" 
 -- computeAdr: 1 :rec: "none"  E: "entry" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "entry"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "entry" >on:0 superAdj:1 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 1 
 rpushg SQS$77 1
 -- $ObjectInvocation_Unary:getAdr: "entry" >ATd.off:0 (isPtn):on:0:superAdj:1"entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1 ..."} 
 -- $pattern:getAdr: "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"entry":rec:- 
 -- E.on: 0 
 -- beforeIsValueObj:E: "entry"  ATd: "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"entry":rec:- 
 -- computeAdr:isLast:E:  "entry" 
 -- genClass:after:pushAddress: "entry" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"entry":rec:- 
 -- handleSuperArgs:E: "entry" theIS: "V := 1{L.init;L.id := "SQS";Q.idf := "SQS:"}" 
 -- super.sig:not:none:superAdj: -1 
 -- $ObjectInvocation_Unary:loadArgs: "entry" >staticOff:0 "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free" superAd ...} 
 -- $pattern:loadArgs: "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free" >E:"entry":descNo:95} 
 -- ptn:loadArgs:E "entry" 
 -- {(ObjectInvocation_Unary; (name: "entry"); (Arguments))} 
 -- args: "" 
 -- hArgOrg:super: entry 
 -- Store itemArgs: V := 1{L.init;L.id := "SQS";Q.idf := "SQS:"} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=110 vDescInx=95 vdtTop: 2 
 rtnAlloc 1
 toSuper 95
DO:
 mvStack 
 L1:
 -- genclass:stmt: "V := 1" 
 -- $Assign:gen: "V := 1"  
 -- assign: "V := 1" 
 -- computeAdr:superAdj: 0 "V" 
 -- computeAdr: 1 :rec: "none"  E: "V" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "V"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "V" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "init" on: 1 isValueObj: false 
 -- origin: SQS origin:isValueObj: false 
 rpushg init$110 1
 -- $ObjectInvocation_Unary:getAdr: "V" >ATd.off:4:on:1:superAdj:0"V: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "V: var integer" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "V: var integer" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "V"  ATd: "V: var integer" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- computeAdr:isLast:E:  "V" 
 -- AssignmentStatement:gen: "V := 1" right.label: "ObjectGenerator" "1" 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "V" dstE: "V" dstE.ATd: "V: var integer" useRtn: false :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "1" 
 -- isArgOfAssignI2IwithUniValArg "V := 1" arg: "1" ObjectGenerator 
 -- arg.super.arg: "1" ConstLiteral 
 -- dstDI: "V: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg SQS$77 4
 -- assign:adr.store:B: 
 -- genclass:stmt: "L.init" 
 -- $ObjectGenerator:gen: "L.init" >OGid:"init" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L.init" 
 -- OG:before:super.gen: "L.init" 
 -- $Invocation:gen: "L.init" >useRtnV:"False"superAdj: 0 descNo: 81 
 -- INV:gen: "L.init" 
 -- isConstant: "Invocation" "L.init" 
 -- needorigin: "L.init" 
 -- needOrigin:E: "init"  E.ATd: "init: {   free_M := 0}" 
 -- doNeedOrigin:Ex: "init" 
 -- computeAdr:superAdj: 0 "L.init" 
 -- computeAdr: 1 :rec: "none"  E: "L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "init" on: 1 isValueObj: false 
 -- origin: SQS origin:isValueObj: false 
 rpushg init$110 1
 -- $ObjectInvocation_Unary:getAdr: "L" >ATd.off:3:on:1:superAdj:0"L: obj Lock("SQS:Lock:")":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVal ... 
 -- $obj:getAdr: "L: obj Lock("SQS:Lock:")" >newOff:3,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F i ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "L"  ATd: "L: obj Lock("SQS:Lock:")" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "L"  E: "init" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "init" >ATd.off:0 (isPtn):on:0:superAdj:0"init: {   free_M := 0":Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ...} 
 -- $pattern:getAdr: "init: {   free_M := 0" } 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "L" >staticOff:0 "L: obj Lock("SQS:Lock:")" superAdj:0 
 -- $obj:loadArgs: "L: obj Lock("SQS:Lock:")" >E:"L" 
 -- $pattern:loadArgs: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ; ..."} 
 -- ptn:loadArgs:E "L" 
 -- {(ObjectInvocation_Unary; (name: "L"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "L" >rec:"L" ATd:"obj" E:"init" E.ATd:"init" unique:"False" 
 -- OI:invoke: "L" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:L 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:L 
 -- OI:invoke:B: "L" E: "init"  rec: "L"  useRtnV: true "L: obj Lock("SQS:Lock:")" 
 -- OI:invoke:before:ATdx.invoke: obj L 
 -- $obj:invoke: "L: obj Lock("SQS:Lock:")" E: "init">newOff:3 useRTNv: "True" 
 -- DI:invoke: "L: obj Lock("SQS:Lock:")" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:L 
 rpushg init$110 3
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:L 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:L 
 -- 
 -- OI:invoke:C: L :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "L" E: "init" 
 -- computeAdr:isLast:E:  "init" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:L 
 -- rec:  "L" E:  "init" 
 -- INV:gen:E.loadArgs "init" 
 -- $ObjectInvocation_Unary:loadArgs: "init" >staticOff:0 "init: {   free_M := 0" superAdj:0} 
 -- $pattern:loadArgs: "init: {   free_M := 0" >E:"init":descNo:81} 
 -- ptn:loadArgs:E "init" 
 -- {(ObjectInvocation_Unary; (name: "init"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "init" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "init" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:L 
 -- $ObjectInvocation_Unary:invoke: "init" >rec:"L" ATd:"pattern" E:"init" E.ATd:"init" unique:"False" 
 -- OI:invoke: "init" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:L 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:L 
 -- OI:invoke:B: "init" E: "init"  rec: "L"  useRtnV: false "init: {   free_M := 0}" 
 -- OI:invoke:before:ATdx.invoke: pattern init 
 -- $pattern:invoke: "init: {   free_M := 0" E: "init" useRTNv: "False"} 
 -- ptn:invoke: "init" E: "init" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:L 
 invoke init 81 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:L 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:L 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: init :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:L 
 -- genclass:stmt: "L.id := "SQS"" 
 -- $Assign:gen: "L.id := "SQS""  
 -- assign: "L.id := "SQS"" 
 -- computeAdr:superAdj: 0 "L.id" 
 -- computeAdr: 1 :rec: "none"  E: "L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "init" on: 1 isValueObj: false 
 -- origin: SQS origin:isValueObj: false 
 rpushg init$110 1
 -- $ObjectInvocation_Unary:getAdr: "L" >ATd.off:3:on:1:superAdj:0"L: obj Lock("SQS:Lock:")":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVal ... 
 -- $obj:getAdr: "L: obj Lock("SQS:Lock:")" >newOff:3,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F i ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "L"  ATd: "L: obj Lock("SQS:Lock:")" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "L"  E: "id" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "id" >ATd.off:1:on:0:superAdj:0"in id: var String":Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- PING:String 0 entry{   V := 1;   L.init;   L.id := "SQS";   Q.idf := "SQS:"} 
 -- BOBS:ATd: "in id: var String" 
 -- $var:getAdr: "in id: var String" >newOff:1,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- $ObjectInvocation_Unary:loadArgs: "L" >staticOff:0 "L: obj Lock("SQS:Lock:")" superAdj:0 
 -- $obj:loadArgs: "L: obj Lock("SQS:Lock:")" >E:"L" 
 -- $pattern:loadArgs: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ; ..."} 
 -- ptn:loadArgs:E "L" 
 -- {(ObjectInvocation_Unary; (name: "L"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "L" >rec:"L" ATd:"obj" E:"id" E.ATd:"id" unique:"False" 
 -- OI:invoke: "L" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"id":rec:L 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"id":rec:L 
 -- OI:invoke:B: "L" E: "id"  rec: "L"  useRtnV: true "L: obj Lock("SQS:Lock:")" 
 -- OI:invoke:before:ATdx.invoke: obj L 
 -- $obj:invoke: "L: obj Lock("SQS:Lock:")" E: "id">newOff:3 useRTNv: "True" 
 -- DI:invoke: "L: obj Lock("SQS:Lock:")" 
 -- >Object:unique: false 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"id":rec:L 
 -- isCompositeValueObj: false E: "id" "in id: var String" false 
 -- E.ATd.isValueObj: false rec: "L" 
 rpushg init$110 3
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"id":rec:L 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"id":rec:L 
 -- 
 -- OI:invoke:C: L :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "L" E: "id" 
 -- computeAdr:isLast:E:  "id" 
 -- AssignmentStatement:gen: "L.id := "SQS"" right.label: "ObjectGenerator" ""SQS"" 
 -- $ObjectGenerator:gen: ""SQS"" >OGid:"String" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: ""SQS"" 
 -- OG:before:super.gen: ""SQS"" 
 -- $Invocation:gen: ""SQS"" >useRtnV:"True"superAdj: 0 
 -- INV:gen: ""SQS"" 
 -- isConstant: "Invocation" ""SQS"" 
 -- needorigin: ""SQS"" 
 -- needOrigin:E: ""SQS""  E.ATd: "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  ""SQS"" E:  ""SQS"" 
 -- INV:gen:E.loadArgs ""SQS"" 
 -- $String::loadArgs: ""SQS""  
 -- INV:gen:after:E.loadArgs ""SQS"" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: String: ""SQS"" 
 -- $String::invoke: ""SQS""  
 pushText "SQS"
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "L" dstE: "id" dstE.ATd: "in id: var String" useRtn: false :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- dstDI.isBasicVal: false dstDI.isValObj: false dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- assign:adr.store:A: 
 -- store: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- isValue: false  isAdr: true  descNo:  0 
 rswap 0
 rstoreg  EisNone 1
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- assign:adr.store:B: 
 -- genclass:stmt: "Q.idf := "SQS:"" 
 -- $Assign:gen: "Q.idf := "SQS:""  
 -- assign: "Q.idf := "SQS:"" 
 -- computeAdr:superAdj: 0 "Q.idf" 
 -- computeAdr: 1 :rec: "none"  E: "Q" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Q"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Q" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "init" on: 1 isValueObj: false 
 -- origin: SQS origin:isValueObj: false 
 rpushg init$110 1
 -- $ObjectInvocation_Unary:getAdr: "Q" >ATd.off:2:on:1:superAdj:0"Q: obj ProcessQueue":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F: ... 
 -- $obj:getAdr: "Q: obj ProcessQueue" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValu ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "Q"  ATd: "Q: obj ProcessQueue" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "Q"  E: "idf" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "idf" >ATd.off:1:on:0:superAdj:0"idf: var LIB.StringLib.String":Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F orig ... 
 -- PING:String 0 entry{   V := 1;   L.init;   L.id := "SQS";   Q.idf := "SQS:"} 
 -- BOBS:ATd: "idf: var LIB.StringLib.String" 
 -- $var:getAdr: "idf: var LIB.StringLib.String" >newOff:1,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUniqu ... 
 -- $ObjectInvocation_Unary:loadArgs: "Q" >staticOff:0 "Q: obj ProcessQueue" superAdj:0 
 -- $obj:loadArgs: "Q: obj ProcessQueue" >E:"Q" 
 -- $pattern:loadArgs: "ProcessQueue: LIB.Collections.QueueLib.Queue{   %Public;   displayx: ;      put('Q')" >E:"Q":descNo:79} 
 -- ptn:loadArgs:E "Q" 
 -- {(ObjectInvocation_Unary; (name: "Q"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "Q" >rec:"Q" ATd:"obj" E:"idf" E.ATd:"idf" unique:"False" 
 -- OI:invoke: "Q" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"idf":rec:Q 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"idf":rec:Q 
 -- OI:invoke:B: "Q" E: "idf"  rec: "Q"  useRtnV: true "Q: obj ProcessQueue" 
 -- OI:invoke:before:ATdx.invoke: obj Q 
 -- $obj:invoke: "Q: obj ProcessQueue" E: "idf">newOff:2 useRTNv: "True" 
 -- DI:invoke: "Q: obj ProcessQueue" 
 -- >Object:unique: false 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"idf":rec:Q 
 -- isCompositeValueObj: false E: "idf" "idf: var LIB.StringLib.String" false 
 -- E.ATd.isValueObj: false rec: "Q" 
 rpushg init$110 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"idf":rec:Q 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"idf":rec:Q 
 -- 
 -- OI:invoke:C: Q :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "Q" E: "idf" 
 -- computeAdr:isLast:E:  "idf" 
 -- AssignmentStatement:gen: "Q.idf := "SQS:"" right.label: "ObjectGenerator" ""SQS:"" 
 -- $ObjectGenerator:gen: ""SQS:"" >OGid:"String" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: ""SQS:"" 
 -- OG:before:super.gen: ""SQS:"" 
 -- $Invocation:gen: ""SQS:"" >useRtnV:"True"superAdj: 0 
 -- INV:gen: ""SQS:"" 
 -- isConstant: "Invocation" ""SQS:"" 
 -- needorigin: ""SQS:"" 
 -- needOrigin:E: ""SQS:""  E.ATd: "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := ge ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  ""SQS:"" E:  ""SQS:"" 
 -- INV:gen:E.loadArgs ""SQS:"" 
 -- $String::loadArgs: ""SQS:""  
 -- INV:gen:after:E.loadArgs ""SQS:"" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: String: ""SQS:"" 
 -- $String::invoke: ""SQS:""  
 pushText "SQS:"
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "Q" dstE: "idf" dstE.ATd: "idf: var LIB.StringLib.String" useRtn: false :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"non ..." 
 -- dstDI.isBasicVal: false dstDI.isValObj: false dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- assign:adr.store:A: 
 -- store: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- isValue: false  isAdr: true  descNo:  0 
 rswap 0
 rstoreg  EisNone 1
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-3,0)=[]
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 111 
 -- Items:GenClass: init descNo: 111 isValue: false 
 -- Items:GenClass: init descNo: 21 isValue: false 

 CLASS init 111 1 cores 73
 -- Store itemArgs: S: ref Scheduler{C1 := Core;fork(C1);C2 := Core;fork(C2);C3 := Core;fork(C3);C4 := Core;fork(C4);S := Scheduler;C1.attach(S);S := Scheduler;C2.attach(S);S  ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=111 vDescInx=111 vdtTop: 1 
 mvStack 
 -- $ref:gen: "S: ref Scheduler"  
 -- DI:gen: "S: ref Scheduler" DI:isConst: false :isBasicValue: false :primNo: 0 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "C1 := Core" 
 -- $Assign:gen: "C1 := Core"  
 -- assign: "C1 := Core" 
 -- computeAdr:superAdj: 0 "C1" 
 -- computeAdr: 1 :rec: "none"  E: "C1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "C1"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "C1" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "init" on: 1 isValueObj: false 
 -- origin: cores origin:isValueObj: false 
 rpushg init$111 1
 -- $ObjectInvocation_Unary:getAdr: "C1" >ATd.off:2:on:1:superAdj:0"C1: ref Core":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"non ..." 
 -- $ref:getAdr: "C1: ref Core" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "C1"  ATd: "C1: ref Core" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "C1" 
 -- AssignmentStatement:gen: "C1 := Core" right.label: "ObjectGenerator" "Core" 
 -- $ObjectGenerator:gen: "Core" >OGid:"Core" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "Core" 
 -- OG:before:super.gen: "Core" 
 -- $Invocation:gen: "Core" >useRtnV:"True"superAdj: 0 descNo: 113 
 -- INV:gen: "Core" 
 -- isConstant: "Invocation" "Core" 
 -- needorigin: "Core" 
 -- needOrigin:E: "Core"  E.ATd: "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: obj ; ...}" 
 -- doNeedOrigin:Ex: "Core" 
 -- computeAdr:superAdj: 0 "Core" 
 -- computeAdr: 1 :rec: "none"  E: "Core" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Core"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Core" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "init" on: 2 isValueObj: false 
 -- origin: cores origin:isValueObj: false 
 rpushg init$111 1
 -- items:goOrigin:encOG: "cores" on: 1 isValueObj: false 
 -- origin: BasicSystem origin:isValueObj: false 
 rpushg cores$73 1
 -- $ObjectInvocation_Unary:getAdr: "Core" >ATd.off:0 (isPtn):on:2:superAdj:0"Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   d ..."} 
 -- $pattern:getAdr: "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: obj ;         if  ..."} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "Core"  ATd: "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: o ...}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:- 
 -- computeAdr:isLast:E:  "Core" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:- 
 -- rec:  "Core" E:  "Core" 
 -- INV:gen:E.loadArgs "Core" 
 -- $ObjectInvocation_Unary:loadArgs: "Core" >staticOff:0 "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;  ..."} 
 -- $pattern:loadArgs: "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: obj ;         i ..."} 
 -- ptn:loadArgs:E "Core" 
 -- {(ObjectInvocation_Unary; (name: "Core"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "Core" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "Core" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:- 
 -- $ObjectInvocation_Unary:invoke: "Core" >rec:"Core" ATd:"pattern" E:"Core" E.ATd:"Core" unique:"False" 
 -- OI:invoke: "Core" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:Core 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:Core 
 -- OI:invoke:B: "Core" E: "Core"  rec: "Core"  useRtnV: true "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integ ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Core 
 -- $pattern:invoke: "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: obj ;         if  ..."} 
 -- ptn:invoke: "Core" E: "Core" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:Core 
 invoke Core 113 0 1
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:Core 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:Core 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: Core :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:Core 
 -- rec: "C1" dstE: "C1" dstE.ATd: "C1: ref Core" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- dstDI.isBasicVal: false dstDI.isValObj: false dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- isValue: false  isAdr: true  descNo:  0 
 rswap 0
 rstoreg  EisNone 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- assign:adr.store:B: 
 -- genclass:stmt: "fork(C1)" 
 -- $ObjectGenerator:gen: "fork(C1)" >OGid:"fork" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "fork(C1)" 
 -- OG:before:super.gen: "fork(C1)" 
 -- $Invocation:gen: "fork(C1)" >useRtnV:"False"superAdj: 0 descNo: 121 
 -- INV:gen: "fork(C1)" 
 -- isConstant: "Invocation" "fork(C1)" 
 -- needorigin: "fork(C1)" 
 -- needOrigin:E: "fork(C1)"  E.ATd: "fork: {   %basic 13;   in S: ref Object}" 
 -- doNeedOrigin:Ex: "fork(C1)" 
 -- computeAdr:superAdj: 0 "fork(C1)" 
 -- computeAdr: 1 :rec: "none"  E: "fork(C1)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "fork(C1)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "fork(C1)" >on:4 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "fork(C1)" >ATd.off:0 (isPtn):on:4:superAdj:0"fork: {   %basic 13;   in S: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0  ...} 
 -- $pattern:getAdr: "fork: {   %basic 13;   in S: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fork(C1)":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "fork(C1)"  ATd: "fork: {   %basic 13;   in S: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fork(C1)":rec:- 
 -- computeAdr:isLast:E:  "fork(C1)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fork(C1)":rec:- 
 -- rec:  "fork(C1)" E:  "fork(C1)" 
 -- INV:gen:E.loadArgs "fork(C1)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "fork(C1)" >staticOff:0 "fork: {   %basic 13;   in S: ref Object" superAdj:0arg:"C1"} 
 -- $pattern:loadArgs: "fork: {   %basic 13;   in S: ref Object" >E:"fork(C1)":descNo:121} 
 -- ptn:loadArgs:E "fork(C1)" 
 -- {(ObjectInvocation_KeyWord; (name: "fork"); (Arguments;  (name: "fork");  (name: "(");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "C1");      ...} 
 -- args: "fork(C1)" 
 -- E: "ObjectGenerator" C1 
 -- E.arg: "ref" in S: ref Object 
 -- NonVirt: "fork(C1)" "ObjectInvocation_KeyWord" ActArg:  "C1" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "fork(C1)"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "C1" >OGid:"Core" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "C1" 
 -- OG:before:super.gen: "C1" 
 -- $Invocation:gen: "C1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "C1" 
 -- isConstant: "Invocation" "C1" 
 -- notConst: C1 C1: ref Core 
 -- needorigin: "C1" 
 -- needOrigin:E: "C1"  E.ATd: "C1: ref Core" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "C1" 
 -- computeAdr: 1 :rec: "none"  E: "C1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "C1"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "C1" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "init" on: 1 isValueObj: false 
 -- origin: cores origin:isValueObj: false 
 rpushg init$111 1
 -- $ObjectInvocation_Unary:getAdr: "C1" >ATd.off:2:on:1:superAdj:0"C1: ref Core":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"non ..." 
 -- $ref:getAdr: "C1: ref Core" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "C1"  ATd: "C1: ref Core" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "C1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "C1" E:  "C1" 
 -- INV:gen:E.loadArgs "C1" 
 -- $ObjectInvocation_Unary:loadArgs: "C1" >staticOff:0 "C1: ref Core" superAdj:0 
 -- $ref:loadArgs: "C1: ref Core" >E:"C1" 
 -- $pattern:loadArgs: "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: obj ;         i ..."} 
 -- ptn:loadArgs:E "C1" 
 -- {(ObjectInvocation_Unary; (name: "C1"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "C1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "C1" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "C1" >rec:"C1" ATd:"ref" E:"C1" E.ATd:"C1" unique:"False" 
 -- OI:invoke: "C1" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:C1 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:C1 
 -- OI:invoke:B: "C1" E: "C1"  rec: "C1"  useRtnV: true "C1: ref Core" 
 -- OI:invoke:before:ATdx.invoke: ref C1 
 -- $ref:invoke: "C1: ref Core" E: "C1">newOff:2 useRTNv: "True" 
 -- DI:invoke: "C1: ref Core" 
 -- >Object:unique: false 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"C1":rec:C1 
 -- isCompositeValueObj: false E: "C1" "C1: ref Core" false 
 -- E.ATd.isValueObj: false rec: "C1" 
 rpushg cores$73 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"C1":rec:C1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"C1":rec:C1 
 -- 
 -- OI:invoke:C: C1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"C1":rec:C1 
 -- formalArg:isPtn: "in S: ref Object" :isBasicVal: false :valueObj: false 
 -- :actArg: "C1" :isBasicVal: false 
 -- case:B: C1 ObjectGenerator 64 0 0 false false 
 -- end:loadArgs:NonVirt: "fork(C1)" 
 -- INV:gen:after:E.loadArgs "fork(C1)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "fork(C1)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fork(C1)":re ... 
 -- $ObjectInvocation_KeyWord:invoke: "fork(C1)" >rec:"fork(C1)" ATd:"pattern" E:"fork(C1)" E.ATd:"fork" unique:"False" 
 -- OI:invoke: "fork(C1)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fork(C1)":rec:fork(C1) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fork(C1)":rec:fork(C1) 
 -- OI:invoke:B: "fork(C1)" E: "fork(C1)"  rec: "fork(C1)"  useRtnV: false "fork: {   %basic 13;   in S: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern fork 
 -- $pattern:invoke: "fork: {   %basic 13;   in S: ref Object" E: "fork(C1)" useRTNv: "False"} 
 -- ptn:invoke: "fork" E: "fork(C1)" ptnKind: 0 useRtnV: false 
 %fork 13
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fork(C1)":rec:fork(C1) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fork(C1)":rec:fork(C1) 
 -- 
 -- OI:invoke:C: fork(C1) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fork(C1)":rec:fork(C1) 
 -- genclass:stmt: "C2 := Core" 
 -- $Assign:gen: "C2 := Core"  
 -- assign: "C2 := Core" 
 -- computeAdr:superAdj: 0 "C2" 
 -- computeAdr: 1 :rec: "none"  E: "C2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "C2"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "C2" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "init" on: 1 isValueObj: false 
 -- origin: cores origin:isValueObj: false 
 rpushg init$111 1
 -- $ObjectInvocation_Unary:getAdr: "C2" >ATd.off:3:on:1:superAdj:0"C2: ref Core":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"non ..." 
 -- $ref:getAdr: "C2: ref Core" >newOff:3,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "C2"  ATd: "C2: ref Core" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "C2" 
 -- AssignmentStatement:gen: "C2 := Core" right.label: "ObjectGenerator" "Core" 
 -- $ObjectGenerator:gen: "Core" >OGid:"Core" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "Core" 
 -- OG:before:super.gen: "Core" 
 -- $Invocation:gen: "Core" >useRtnV:"True"superAdj: 0 descNo: 113 
 -- INV:gen: "Core" 
 -- isConstant: "Invocation" "Core" 
 -- needorigin: "Core" 
 -- needOrigin:E: "Core"  E.ATd: "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: obj ; ...}" 
 -- doNeedOrigin:Ex: "Core" 
 -- computeAdr:superAdj: 0 "Core" 
 -- computeAdr: 1 :rec: "none"  E: "Core" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Core"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Core" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "init" on: 2 isValueObj: false 
 -- origin: cores origin:isValueObj: false 
 rpushg init$111 1
 -- items:goOrigin:encOG: "cores" on: 1 isValueObj: false 
 -- origin: BasicSystem origin:isValueObj: false 
 rpushg cores$73 1
 -- $ObjectInvocation_Unary:getAdr: "Core" >ATd.off:0 (isPtn):on:2:superAdj:0"Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   d ..."} 
 -- $pattern:getAdr: "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: obj ;         if  ..."} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "Core"  ATd: "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: o ...}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:- 
 -- computeAdr:isLast:E:  "Core" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:- 
 -- rec:  "Core" E:  "Core" 
 -- INV:gen:E.loadArgs "Core" 
 -- $ObjectInvocation_Unary:loadArgs: "Core" >staticOff:0 "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;  ..."} 
 -- $pattern:loadArgs: "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: obj ;         i ..."} 
 -- ptn:loadArgs:E "Core" 
 -- {(ObjectInvocation_Unary; (name: "Core"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "Core" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "Core" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:- 
 -- $ObjectInvocation_Unary:invoke: "Core" >rec:"Core" ATd:"pattern" E:"Core" E.ATd:"Core" unique:"False" 
 -- OI:invoke: "Core" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:Core 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:Core 
 -- OI:invoke:B: "Core" E: "Core"  rec: "Core"  useRtnV: true "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integ ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Core 
 -- $pattern:invoke: "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: obj ;         if  ..."} 
 -- ptn:invoke: "Core" E: "Core" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:Core 
 invoke Core 113 0 1
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:Core 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:Core 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: Core :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:Core 
 -- rec: "C2" dstE: "C2" dstE.ATd: "C2: ref Core" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- dstDI.isBasicVal: false dstDI.isValObj: false dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- isValue: false  isAdr: true  descNo:  0 
 rswap 0
 rstoreg  EisNone 3
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-4,0)=[]
 -- assign:adr.store:B: 
 -- genclass:stmt: "fork(C2)" 
 -- $ObjectGenerator:gen: "fork(C2)" >OGid:"fork" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "fork(C2)" 
 -- OG:before:super.gen: "fork(C2)" 
 -- $Invocation:gen: "fork(C2)" >useRtnV:"False"superAdj: 0 descNo: 121 
 -- INV:gen: "fork(C2)" 
 -- isConstant: "Invocation" "fork(C2)" 
 -- needorigin: "fork(C2)" 
 -- needOrigin:E: "fork(C2)"  E.ATd: "fork: {   %basic 13;   in S: ref Object}" 
 -- doNeedOrigin:Ex: "fork(C2)" 
 -- computeAdr:superAdj: 0 "fork(C2)" 
 -- computeAdr: 1 :rec: "none"  E: "fork(C2)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "fork(C2)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "fork(C2)" >on:4 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "fork(C2)" >ATd.off:0 (isPtn):on:4:superAdj:0"fork: {   %basic 13;   in S: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0  ...} 
 -- $pattern:getAdr: "fork: {   %basic 13;   in S: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fork(C2)":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "fork(C2)"  ATd: "fork: {   %basic 13;   in S: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fork(C2)":rec:- 
 -- computeAdr:isLast:E:  "fork(C2)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fork(C2)":rec:- 
 -- rec:  "fork(C2)" E:  "fork(C2)" 
 -- INV:gen:E.loadArgs "fork(C2)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "fork(C2)" >staticOff:0 "fork: {   %basic 13;   in S: ref Object" superAdj:0arg:"C2"} 
 -- $pattern:loadArgs: "fork: {   %basic 13;   in S: ref Object" >E:"fork(C2)":descNo:121} 
 -- ptn:loadArgs:E "fork(C2)" 
 -- {(ObjectInvocation_KeyWord; (name: "fork"); (Arguments;  (name: "fork");  (name: "(");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "C2");      ...} 
 -- args: "fork(C2)" 
 -- E: "ObjectGenerator" C2 
 -- E.arg: "ref" in S: ref Object 
 -- NonVirt: "fork(C2)" "ObjectInvocation_KeyWord" ActArg:  "C2" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "fork(C2)"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "C2" >OGid:"Core" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "C2" 
 -- OG:before:super.gen: "C2" 
 -- $Invocation:gen: "C2" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "C2" 
 -- isConstant: "Invocation" "C2" 
 -- notConst: C2 C2: ref Core 
 -- needorigin: "C2" 
 -- needOrigin:E: "C2"  E.ATd: "C2: ref Core" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "C2" 
 -- computeAdr: 1 :rec: "none"  E: "C2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "C2"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "C2" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "init" on: 1 isValueObj: false 
 -- origin: cores origin:isValueObj: false 
 rpushg init$111 1
 -- $ObjectInvocation_Unary:getAdr: "C2" >ATd.off:3:on:1:superAdj:0"C2: ref Core":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"non ..." 
 -- $ref:getAdr: "C2: ref Core" >newOff:3,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "C2"  ATd: "C2: ref Core" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "C2" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "C2" E:  "C2" 
 -- INV:gen:E.loadArgs "C2" 
 -- $ObjectInvocation_Unary:loadArgs: "C2" >staticOff:0 "C2: ref Core" superAdj:0 
 -- $ref:loadArgs: "C2: ref Core" >E:"C2" 
 -- $pattern:loadArgs: "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: obj ;         i ..."} 
 -- ptn:loadArgs:E "C2" 
 -- {(ObjectInvocation_Unary; (name: "C2"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "C2" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "C2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "C2" >rec:"C2" ATd:"ref" E:"C2" E.ATd:"C2" unique:"False" 
 -- OI:invoke: "C2" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:C2 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:C2 
 -- OI:invoke:B: "C2" E: "C2"  rec: "C2"  useRtnV: true "C2: ref Core" 
 -- OI:invoke:before:ATdx.invoke: ref C2 
 -- $ref:invoke: "C2: ref Core" E: "C2">newOff:3 useRTNv: "True" 
 -- DI:invoke: "C2: ref Core" 
 -- >Object:unique: false 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"C2":rec:C2 
 -- isCompositeValueObj: false E: "C2" "C2: ref Core" false 
 -- E.ATd.isValueObj: false rec: "C2" 
 rpushg cores$73 3
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"C2":rec:C2 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"C2":rec:C2 
 -- 
 -- OI:invoke:C: C2 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"C2":rec:C2 
 -- formalArg:isPtn: "in S: ref Object" :isBasicVal: false :valueObj: false 
 -- :actArg: "C2" :isBasicVal: false 
 -- case:B: C2 ObjectGenerator 64 0 0 false false 
 -- end:loadArgs:NonVirt: "fork(C2)" 
 -- INV:gen:after:E.loadArgs "fork(C2)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "fork(C2)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fork(C2)":re ... 
 -- $ObjectInvocation_KeyWord:invoke: "fork(C2)" >rec:"fork(C2)" ATd:"pattern" E:"fork(C2)" E.ATd:"fork" unique:"False" 
 -- OI:invoke: "fork(C2)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fork(C2)":rec:fork(C2) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fork(C2)":rec:fork(C2) 
 -- OI:invoke:B: "fork(C2)" E: "fork(C2)"  rec: "fork(C2)"  useRtnV: false "fork: {   %basic 13;   in S: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern fork 
 -- $pattern:invoke: "fork: {   %basic 13;   in S: ref Object" E: "fork(C2)" useRTNv: "False"} 
 -- ptn:invoke: "fork" E: "fork(C2)" ptnKind: 0 useRtnV: false 
 %fork 13
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fork(C2)":rec:fork(C2) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fork(C2)":rec:fork(C2) 
 -- 
 -- OI:invoke:C: fork(C2) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fork(C2)":rec:fork(C2) 
 -- genclass:stmt: "C3 := Core" 
 -- $Assign:gen: "C3 := Core"  
 -- assign: "C3 := Core" 
 -- computeAdr:superAdj: 0 "C3" 
 -- computeAdr: 1 :rec: "none"  E: "C3" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "C3"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "C3" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "init" on: 1 isValueObj: false 
 -- origin: cores origin:isValueObj: false 
 rpushg init$111 1
 -- $ObjectInvocation_Unary:getAdr: "C3" >ATd.off:4:on:1:superAdj:0"C3: ref Core":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"non ..." 
 -- $ref:getAdr: "C3: ref Core" >newOff:4,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "C3"  ATd: "C3: ref Core" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "C3" 
 -- AssignmentStatement:gen: "C3 := Core" right.label: "ObjectGenerator" "Core" 
 -- $ObjectGenerator:gen: "Core" >OGid:"Core" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "Core" 
 -- OG:before:super.gen: "Core" 
 -- $Invocation:gen: "Core" >useRtnV:"True"superAdj: 0 descNo: 113 
 -- INV:gen: "Core" 
 -- isConstant: "Invocation" "Core" 
 -- needorigin: "Core" 
 -- needOrigin:E: "Core"  E.ATd: "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: obj ; ...}" 
 -- doNeedOrigin:Ex: "Core" 
 -- computeAdr:superAdj: 0 "Core" 
 -- computeAdr: 1 :rec: "none"  E: "Core" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Core"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Core" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "init" on: 2 isValueObj: false 
 -- origin: cores origin:isValueObj: false 
 rpushg init$111 1
 -- items:goOrigin:encOG: "cores" on: 1 isValueObj: false 
 -- origin: BasicSystem origin:isValueObj: false 
 rpushg cores$73 1
 -- $ObjectInvocation_Unary:getAdr: "Core" >ATd.off:0 (isPtn):on:2:superAdj:0"Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   d ..."} 
 -- $pattern:getAdr: "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: obj ;         if  ..."} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "Core"  ATd: "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: o ...}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:- 
 -- computeAdr:isLast:E:  "Core" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:- 
 -- rec:  "Core" E:  "Core" 
 -- INV:gen:E.loadArgs "Core" 
 -- $ObjectInvocation_Unary:loadArgs: "Core" >staticOff:0 "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;  ..."} 
 -- $pattern:loadArgs: "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: obj ;         i ..."} 
 -- ptn:loadArgs:E "Core" 
 -- {(ObjectInvocation_Unary; (name: "Core"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "Core" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "Core" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:- 
 -- $ObjectInvocation_Unary:invoke: "Core" >rec:"Core" ATd:"pattern" E:"Core" E.ATd:"Core" unique:"False" 
 -- OI:invoke: "Core" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:Core 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:Core 
 -- OI:invoke:B: "Core" E: "Core"  rec: "Core"  useRtnV: true "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integ ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Core 
 -- $pattern:invoke: "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: obj ;         if  ..."} 
 -- ptn:invoke: "Core" E: "Core" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:Core 
 invoke Core 113 0 1
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:Core 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:Core 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: Core :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:Core 
 -- rec: "C3" dstE: "C3" dstE.ATd: "C3: ref Core" useRtn: false :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- dstDI.isBasicVal: false dstDI.isValObj: false dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- assign:adr.store:A: 
 -- store: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- isValue: false  isAdr: true  descNo:  0 
 rswap 0
 rstoreg  EisNone 4
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -6 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-6,0)=[]
 -- assign:adr.store:B: 
 -- genclass:stmt: "fork(C3)" 
 -- $ObjectGenerator:gen: "fork(C3)" >OGid:"fork" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "fork(C3)" 
 -- OG:before:super.gen: "fork(C3)" 
 -- $Invocation:gen: "fork(C3)" >useRtnV:"False"superAdj: 0 descNo: 121 
 -- INV:gen: "fork(C3)" 
 -- isConstant: "Invocation" "fork(C3)" 
 -- needorigin: "fork(C3)" 
 -- needOrigin:E: "fork(C3)"  E.ATd: "fork: {   %basic 13;   in S: ref Object}" 
 -- doNeedOrigin:Ex: "fork(C3)" 
 -- computeAdr:superAdj: 0 "fork(C3)" 
 -- computeAdr: 1 :rec: "none"  E: "fork(C3)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "fork(C3)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "fork(C3)" >on:4 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "fork(C3)" >ATd.off:0 (isPtn):on:4:superAdj:0"fork: {   %basic 13;   in S: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0  ...} 
 -- $pattern:getAdr: "fork: {   %basic 13;   in S: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fork(C3)":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "fork(C3)"  ATd: "fork: {   %basic 13;   in S: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fork(C3)":rec:- 
 -- computeAdr:isLast:E:  "fork(C3)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fork(C3)":rec:- 
 -- rec:  "fork(C3)" E:  "fork(C3)" 
 -- INV:gen:E.loadArgs "fork(C3)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "fork(C3)" >staticOff:0 "fork: {   %basic 13;   in S: ref Object" superAdj:0arg:"C3"} 
 -- $pattern:loadArgs: "fork: {   %basic 13;   in S: ref Object" >E:"fork(C3)":descNo:121} 
 -- ptn:loadArgs:E "fork(C3)" 
 -- {(ObjectInvocation_KeyWord; (name: "fork"); (Arguments;  (name: "fork");  (name: "(");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "C3");      ...} 
 -- args: "fork(C3)" 
 -- E: "ObjectGenerator" C3 
 -- E.arg: "ref" in S: ref Object 
 -- NonVirt: "fork(C3)" "ObjectInvocation_KeyWord" ActArg:  "C3" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "fork(C3)"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "C3" >OGid:"Core" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "C3" 
 -- OG:before:super.gen: "C3" 
 -- $Invocation:gen: "C3" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "C3" 
 -- isConstant: "Invocation" "C3" 
 -- notConst: C3 C3: ref Core 
 -- needorigin: "C3" 
 -- needOrigin:E: "C3"  E.ATd: "C3: ref Core" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "C3" 
 -- computeAdr: 1 :rec: "none"  E: "C3" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "C3"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "C3" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "init" on: 1 isValueObj: false 
 -- origin: cores origin:isValueObj: false 
 rpushg init$111 1
 -- $ObjectInvocation_Unary:getAdr: "C3" >ATd.off:4:on:1:superAdj:0"C3: ref Core":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"non ..." 
 -- $ref:getAdr: "C3: ref Core" >newOff:4,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "C3"  ATd: "C3: ref Core" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "C3" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "C3" E:  "C3" 
 -- INV:gen:E.loadArgs "C3" 
 -- $ObjectInvocation_Unary:loadArgs: "C3" >staticOff:0 "C3: ref Core" superAdj:0 
 -- $ref:loadArgs: "C3: ref Core" >E:"C3" 
 -- $pattern:loadArgs: "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: obj ;         i ..."} 
 -- ptn:loadArgs:E "C3" 
 -- {(ObjectInvocation_Unary; (name: "C3"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "C3" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "C3" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "C3" >rec:"C3" ATd:"ref" E:"C3" E.ATd:"C3" unique:"False" 
 -- OI:invoke: "C3" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:C3 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:C3 
 -- OI:invoke:B: "C3" E: "C3"  rec: "C3"  useRtnV: true "C3: ref Core" 
 -- OI:invoke:before:ATdx.invoke: ref C3 
 -- $ref:invoke: "C3: ref Core" E: "C3">newOff:4 useRTNv: "True" 
 -- DI:invoke: "C3: ref Core" 
 -- >Object:unique: false 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"C3":rec:C3 
 -- isCompositeValueObj: false E: "C3" "C3: ref Core" false 
 -- E.ATd.isValueObj: false rec: "C3" 
 rpushg cores$73 4
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"C3":rec:C3 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"C3":rec:C3 
 -- 
 -- OI:invoke:C: C3 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"C3":rec:C3 
 -- formalArg:isPtn: "in S: ref Object" :isBasicVal: false :valueObj: false 
 -- :actArg: "C3" :isBasicVal: false 
 -- case:B: C3 ObjectGenerator 64 0 0 false false 
 -- end:loadArgs:NonVirt: "fork(C3)" 
 -- INV:gen:after:E.loadArgs "fork(C3)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "fork(C3)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fork(C3)":re ... 
 -- $ObjectInvocation_KeyWord:invoke: "fork(C3)" >rec:"fork(C3)" ATd:"pattern" E:"fork(C3)" E.ATd:"fork" unique:"False" 
 -- OI:invoke: "fork(C3)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fork(C3)":rec:fork(C3) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fork(C3)":rec:fork(C3) 
 -- OI:invoke:B: "fork(C3)" E: "fork(C3)"  rec: "fork(C3)"  useRtnV: false "fork: {   %basic 13;   in S: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern fork 
 -- $pattern:invoke: "fork: {   %basic 13;   in S: ref Object" E: "fork(C3)" useRTNv: "False"} 
 -- ptn:invoke: "fork" E: "fork(C3)" ptnKind: 0 useRtnV: false 
 %fork 13
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fork(C3)":rec:fork(C3) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fork(C3)":rec:fork(C3) 
 -- 
 -- OI:invoke:C: fork(C3) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fork(C3)":rec:fork(C3) 
 -- genclass:stmt: "C4 := Core" 
 -- $Assign:gen: "C4 := Core"  
 -- assign: "C4 := Core" 
 -- computeAdr:superAdj: 0 "C4" 
 -- computeAdr: 1 :rec: "none"  E: "C4" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "C4"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "C4" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "init" on: 1 isValueObj: false 
 -- origin: cores origin:isValueObj: false 
 rpushg init$111 1
 -- $ObjectInvocation_Unary:getAdr: "C4" >ATd.off:5:on:1:superAdj:0"C4: ref Core{-- should be array         ":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa ...} 
 -- $ref:getAdr: "C4: ref Core{-- should be array         " >newOff:5,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAd ...} 
 -- E.on: 1 
 -- beforeIsValueObj:E: "C4"  ATd: "C4: ref Core{-- should be array         }" 
 -- computeAdr:isFirst: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "C4" 
 -- AssignmentStatement:gen: "C4 := Core" right.label: "ObjectGenerator" "Core" 
 -- $ObjectGenerator:gen: "Core" >OGid:"Core" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "Core" 
 -- OG:before:super.gen: "Core" 
 -- $Invocation:gen: "Core" >useRtnV:"True"superAdj: 0 descNo: 113 
 -- INV:gen: "Core" 
 -- isConstant: "Invocation" "Core" 
 -- needorigin: "Core" 
 -- needOrigin:E: "Core"  E.ATd: "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: obj ; ...}" 
 -- doNeedOrigin:Ex: "Core" 
 -- computeAdr:superAdj: 0 "Core" 
 -- computeAdr: 1 :rec: "none"  E: "Core" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Core"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Core" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "init" on: 2 isValueObj: false 
 -- origin: cores origin:isValueObj: false 
 rpushg init$111 1
 -- items:goOrigin:encOG: "cores" on: 1 isValueObj: false 
 -- origin: BasicSystem origin:isValueObj: false 
 rpushg cores$73 1
 -- $ObjectInvocation_Unary:getAdr: "Core" >ATd.off:0 (isPtn):on:2:superAdj:0"Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   d ..."} 
 -- $pattern:getAdr: "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: obj ;         if  ..."} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "Core"  ATd: "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: o ...}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:- 
 -- computeAdr:isLast:E:  "Core" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:- 
 -- rec:  "Core" E:  "Core" 
 -- INV:gen:E.loadArgs "Core" 
 -- $ObjectInvocation_Unary:loadArgs: "Core" >staticOff:0 "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;  ..."} 
 -- $pattern:loadArgs: "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: obj ;         i ..."} 
 -- ptn:loadArgs:E "Core" 
 -- {(ObjectInvocation_Unary; (name: "Core"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "Core" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "Core" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:- 
 -- $ObjectInvocation_Unary:invoke: "Core" >rec:"Core" ATd:"pattern" E:"Core" E.ATd:"Core" unique:"False" 
 -- OI:invoke: "Core" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:Core 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:Core 
 -- OI:invoke:B: "Core" E: "Core"  rec: "Core"  useRtnV: true "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integ ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Core 
 -- $pattern:invoke: "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: obj ;         if  ..."} 
 -- ptn:invoke: "Core" E: "Core" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:Core 
 invoke Core 113 0 1
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:Core 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:Core 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: Core :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Core":rec:Core 
 -- rec: "C4" dstE: "C4" dstE.ATd: "C4: ref Core{-- should be array         }" useRtn: false :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVa ... 
 -- dstDI.isBasicVal: false dstDI.isValObj: false dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- assign:adr.store:A: 
 -- store: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- isValue: false  isAdr: true  descNo:  0 
 rswap 0
 rstoreg  EisNone 5
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -8 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-8,0)=[]
 -- assign:adr.store:B: 
 -- genclass:stmt: "fork(C4)" 
 -- $ObjectGenerator:gen: "fork(C4)" >OGid:"fork" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "fork(C4)" 
 -- OG:before:super.gen: "fork(C4)" 
 -- $Invocation:gen: "fork(C4)" >useRtnV:"False"superAdj: 0 descNo: 121 
 -- INV:gen: "fork(C4)" 
 -- isConstant: "Invocation" "fork(C4)" 
 -- needorigin: "fork(C4)" 
 -- needOrigin:E: "fork(C4)"  E.ATd: "fork: {   %basic 13;   in S: ref Object}" 
 -- doNeedOrigin:Ex: "fork(C4)" 
 -- computeAdr:superAdj: 0 "fork(C4)" 
 -- computeAdr: 1 :rec: "none"  E: "fork(C4)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "fork(C4)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "fork(C4)" >on:4 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "fork(C4)" >ATd.off:0 (isPtn):on:4:superAdj:0"fork: {   %basic 13;   in S: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0  ...} 
 -- $pattern:getAdr: "fork: {   %basic 13;   in S: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fork(C4)":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "fork(C4)"  ATd: "fork: {   %basic 13;   in S: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fork(C4)":rec:- 
 -- computeAdr:isLast:E:  "fork(C4)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fork(C4)":rec:- 
 -- rec:  "fork(C4)" E:  "fork(C4)" 
 -- INV:gen:E.loadArgs "fork(C4)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "fork(C4)" >staticOff:0 "fork: {   %basic 13;   in S: ref Object" superAdj:0arg:"C4"} 
 -- $pattern:loadArgs: "fork: {   %basic 13;   in S: ref Object" >E:"fork(C4)":descNo:121} 
 -- ptn:loadArgs:E "fork(C4)" 
 -- {(ObjectInvocation_KeyWord; (name: "fork"); (Arguments;  (name: "fork");  (name: "(");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "C4");      ...} 
 -- args: "fork(C4)" 
 -- E: "ObjectGenerator" C4 
 -- E.arg: "ref" in S: ref Object 
 -- NonVirt: "fork(C4)" "ObjectInvocation_KeyWord" ActArg:  "C4" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "fork(C4)"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "C4" >OGid:"Core" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "C4" 
 -- OG:before:super.gen: "C4" 
 -- $Invocation:gen: "C4" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "C4" 
 -- isConstant: "Invocation" "C4" 
 -- notConst: C4 C4: ref Core{-- should be array         } 
 -- needorigin: "C4" 
 -- needOrigin:E: "C4"  E.ATd: "C4: ref Core{-- should be array         }" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "C4" 
 -- computeAdr: 1 :rec: "none"  E: "C4" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "C4"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "C4" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "init" on: 1 isValueObj: false 
 -- origin: cores origin:isValueObj: false 
 rpushg init$111 1
 -- $ObjectInvocation_Unary:getAdr: "C4" >ATd.off:5:on:1:superAdj:0"C4: ref Core{-- should be array         ":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa ...} 
 -- $ref:getAdr: "C4: ref Core{-- should be array         " >newOff:5,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAd ...} 
 -- E.on: 1 
 -- beforeIsValueObj:E: "C4"  ATd: "C4: ref Core{-- should be array         }" 
 -- computeAdr:isFirst: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "C4" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "C4" E:  "C4" 
 -- INV:gen:E.loadArgs "C4" 
 -- $ObjectInvocation_Unary:loadArgs: "C4" >staticOff:0 "C4: ref Core{-- should be array         " superAdj:0} 
 -- $ref:loadArgs: "C4: ref Core{-- should be array         " >E:"C4"} 
 -- $pattern:loadArgs: "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: obj ;         i ..."} 
 -- ptn:loadArgs:E "C4" 
 -- {(ObjectInvocation_Unary; (name: "C4"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "C4" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "C4" :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "C4" >rec:"C4" ATd:"ref" E:"C4" E.ATd:"C4" unique:"False" 
 -- OI:invoke: "C4" 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:C4 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:C4 
 -- OI:invoke:B: "C4" E: "C4"  rec: "C4"  useRtnV: true "C4: ref Core{-- should be array         }" 
 -- OI:invoke:before:ATdx.invoke: ref C4 
 -- $ref:invoke: "C4: ref Core{-- should be array         " E: "C4">newOff:5 useRTNv: "True"} 
 -- DI:invoke: "C4: ref Core{-- should be array         }" 
 -- >Object:unique: false 
 -- load: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"C4":rec:C4 
 -- isCompositeValueObj: false E: "C4" "C4: ref Core{-- should be array         }" false 
 -- E.ATd.isValueObj: false rec: "C4" 
 rpushg cores$73 5
 -- OI:invoke:V: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"C4":rec:C4 
 -- 
 -- OI:invoke:X: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"C4":rec:C4 
 -- 
 -- OI:invoke:C: C4 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 5 
 -- OG:gen:end: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"C4":rec:C4 
 -- formalArg:isPtn: "in S: ref Object" :isBasicVal: false :valueObj: false 
 -- :actArg: "C4" :isBasicVal: false 
 -- case:B: C4 ObjectGenerator 64 0 0 false false 
 -- end:loadArgs:NonVirt: "fork(C4)" 
 -- INV:gen:after:E.loadArgs "fork(C4)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "fork(C4)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fork(C4)":re ... 
 -- $ObjectInvocation_KeyWord:invoke: "fork(C4)" >rec:"fork(C4)" ATd:"pattern" E:"fork(C4)" E.ATd:"fork" unique:"False" 
 -- OI:invoke: "fork(C4)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fork(C4)":rec:fork(C4) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fork(C4)":rec:fork(C4) 
 -- OI:invoke:B: "fork(C4)" E: "fork(C4)"  rec: "fork(C4)"  useRtnV: false "fork: {   %basic 13;   in S: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern fork 
 -- $pattern:invoke: "fork: {   %basic 13;   in S: ref Object" E: "fork(C4)" useRTNv: "False"} 
 -- ptn:invoke: "fork" E: "fork(C4)" ptnKind: 0 useRtnV: false 
 %fork 13
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fork(C4)":rec:fork(C4) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fork(C4)":rec:fork(C4) 
 -- 
 -- OI:invoke:C: fork(C4) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fork(C4)":rec:fork(C4) 
 -- genclass:stmt: "S := Scheduler" 
 -- $Assign:gen: "S := Scheduler"  
 -- assign: "S := Scheduler" 
 -- computeAdr:superAdj: 0 "S" 
 -- computeAdr: 1 :rec: "none"  E: "S" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "S"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "S" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "S" >ATd.off:2:on:0:superAdj:0"S: ref Scheduler":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- $ref:getAdr: "S: ref Scheduler" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "S" 
 -- AssignmentStatement:gen: "S := Scheduler" right.label: "ObjectGenerator" "Scheduler" 
 -- $ObjectGenerator:gen: "Scheduler" >OGid:"Scheduler" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "Scheduler" 
 -- OG:before:super.gen: "Scheduler" 
 -- $Invocation:gen: "Scheduler" >useRtnV:"True"superAdj: 0 descNo: 125 
 -- INV:gen: "Scheduler" 
 -- isConstant: "Invocation" "Scheduler" 
 -- needorigin: "Scheduler" 
 -- needOrigin:E: "Scheduler"  E.ATd: "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB: var Boolean;    ...}" 
 -- doNeedOrigin:Ex: "Scheduler" 
 -- computeAdr:superAdj: 0 "Scheduler" 
 -- computeAdr: 1 :rec: "none"  E: "Scheduler" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Scheduler"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Scheduler" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "init" on: 2 isValueObj: false 
 -- origin: cores origin:isValueObj: false 
 rpushg init$111 1
 -- items:goOrigin:encOG: "cores" on: 1 isValueObj: false 
 -- origin: BasicSystem origin:isValueObj: false 
 rpushg cores$73 1
 -- $ObjectInvocation_Unary:getAdr: "Scheduler" >ATd.off:0 (isPtn):on:2:superAdj:0"Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %P ..."} 
 -- $pattern:getAdr: "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB: var Boolean;   inScheduler: var  ..."} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "Scheduler"  ATd: "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB: var Boolean ...}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec:- 
 -- computeAdr:isLast:E:  "Scheduler" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec:- 
 -- rec:  "Scheduler" E:  "Scheduler" 
 -- INV:gen:E.loadArgs "Scheduler" 
 -- $ObjectInvocation_Unary:loadArgs: "Scheduler" >staticOff:0 "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;  ..."} 
 -- $pattern:loadArgs: "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB: var Boolean;   inScheduler: va ..."} 
 -- ptn:loadArgs:E "Scheduler" 
 -- {(ObjectInvocation_Unary; (name: "Scheduler"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "Scheduler" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "Scheduler" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec ... 
 -- $ObjectInvocation_Unary:invoke: "Scheduler" >rec:"Scheduler" ATd:"pattern" E:"Scheduler" E.ATd:"Scheduler" unique:"False" 
 -- OI:invoke: "Scheduler" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec:Scheduler 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec:Scheduler 
 -- OI:invoke:B: "Scheduler" E: "Scheduler"  rec: "Scheduler"  useRtnV: true "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Scheduler 
 -- $pattern:invoke: "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB: var Boolean;   inScheduler: var  ..."} 
 -- ptn:invoke: "Scheduler" E: "Scheduler" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec:Scheduler 
 invoke Scheduler 125 0 1
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec:Scheduler 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec:Scheduler 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: Scheduler :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec:Scheduler 
 -- rec: "S" dstE: "S" dstE.ATd: "S: ref Scheduler" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- dstDI.isBasicVal: false dstDI.isValObj: false dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- isValue: false  isAdr: true  descNo:  0 
 rswap 0
 rstoreg  EisNone 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -10 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-10,0)=[]
 -- assign:adr.store:B: 
 -- genclass:stmt: "C1.attach(S)" 
 -- $ObjectGenerator:gen: "C1.attach(S)" >OGid:"attach" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "C1.attach(S)" 
 -- OG:before:super.gen: "C1.attach(S)" 
 -- $Invocation:gen: "C1.attach(S)" >useRtnV:"False"superAdj: 0 descNo: 131 
 -- INV:gen: "C1.attach(S)" 
 -- isConstant: "Invocation" "C1.attach(S)" 
 -- notConst: C1 C1: ref Core 
 -- needorigin: "C1.attach(S)" 
 -- needOrigin:E: "attach(S)"  E.ATd: "attach: {   in M: ref Scheduler;   main := M}" 
 -- doNeedOrigin:Ex: "attach(S)" 
 -- computeAdr:superAdj: 0 "C1.attach(S)" 
 -- computeAdr: 1 :rec: "none"  E: "C1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "C1"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "C1" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "init" on: 1 isValueObj: false 
 -- origin: cores origin:isValueObj: false 
 rpushg init$111 1
 -- $ObjectInvocation_Unary:getAdr: "C1" >ATd.off:2:on:1:superAdj:0"C1: ref Core":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"non ..." 
 -- $ref:getAdr: "C1: ref Core" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "C1"  ATd: "C1: ref Core" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "C1"  E: "attach(S)" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:getAdr: "attach(S)" >ATd.off:0 (isPtn):on:0:superAdj:0"attach: {   in M: ref Scheduler;   main := M":Adr:off:2 size:0 isFloat:F isUnitVal:F super ...} 
 -- $pattern:getAdr: "attach: {   in M: ref Scheduler;   main := M" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "C1" >staticOff:0 "C1: ref Core" superAdj:0 
 -- $ref:loadArgs: "C1: ref Core" >E:"C1" 
 -- $pattern:loadArgs: "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: obj ;         i ..."} 
 -- ptn:loadArgs:E "C1" 
 -- {(ObjectInvocation_Unary; (name: "C1"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "C1" >rec:"C1" ATd:"ref" E:"attach(S)" E.ATd:"attach" unique:"False" 
 -- OI:invoke: "C1" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)":rec:C1 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)":rec:C1 
 -- OI:invoke:B: "C1" E: "attach(S)"  rec: "C1"  useRtnV: true "C1: ref Core" 
 -- OI:invoke:before:ATdx.invoke: ref C1 
 -- $ref:invoke: "C1: ref Core" E: "attach(S)">newOff:2 useRTNv: "True" 
 -- DI:invoke: "C1: ref Core" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)":rec:C1 
 rpushg init$111 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)":rec:C1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)":rec:C1 
 -- 
 -- OI:invoke:C: C1 :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "C1" E: "attach(S)" 
 -- arg:other 
 -- computeAdr:isLast:E:  "attach(S)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)":rec:C1 
 -- rec:  "C1" E:  "attach(S)" 
 -- INV:gen:E.loadArgs "attach(S)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "attach(S)" >staticOff:0 "attach: {   in M: ref Scheduler;   main := M" superAdj:0arg:"S"} 
 -- $pattern:loadArgs: "attach: {   in M: ref Scheduler;   main := M" >E:"attach(S)":descNo:131} 
 -- ptn:loadArgs:E "attach(S)" 
 -- {(ObjectInvocation_KeyWord; (name: "attach"); (Arguments;  (name: "attach");  (name: "(");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "S");   ...} 
 -- args: "attach(S)" 
 -- E: "ObjectGenerator" S 
 -- E.arg: "ref" in M: ref Scheduler 
 -- NonVirt: "attach(S)" "ObjectInvocation_KeyWord" ActArg:  "S" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "attach(S)"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "S" >OGid:"Scheduler" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "S" 
 -- OG:before:super.gen: "S" 
 -- $Invocation:gen: "S" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "S" 
 -- isConstant: "Invocation" "S" 
 -- notConst: S S: ref Scheduler 
 -- needorigin: "S" 
 -- needOrigin:E: "S"  E.ATd: "S: ref Scheduler" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "S" 
 -- computeAdr: 1 :rec: "none"  E: "S" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "S"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "S" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "S" >ATd.off:2:on:0:superAdj:0"S: ref Scheduler":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- $ref:getAdr: "S: ref Scheduler" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "S" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "S" E:  "S" 
 -- INV:gen:E.loadArgs "S" 
 -- $ObjectInvocation_Unary:loadArgs: "S" >staticOff:0 "S: ref Scheduler" superAdj:0 
 -- $ref:loadArgs: "S: ref Scheduler" >E:"S" 
 -- $pattern:loadArgs: "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB: var Boolean;   inScheduler: va ..."} 
 -- ptn:loadArgs:E "S" 
 -- {(ObjectInvocation_Unary; (name: "S"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "S" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "S" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "S" >rec:"S" ATd:"ref" E:"S" E.ATd:"S" unique:"False" 
 -- OI:invoke: "S" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:S 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:S 
 -- OI:invoke:B: "S" E: "S"  rec: "S"  useRtnV: true "S: ref Scheduler" 
 -- OI:invoke:before:ATdx.invoke: ref S 
 -- $ref:invoke: "S: ref Scheduler" E: "S">newOff:2 useRTNv: "True" 
 -- DI:invoke: "S: ref Scheduler" 
 -- >Object:unique: false 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"S":rec:S 
 -- isCompositeValueObj: false E: "S" "S: ref Scheduler" false 
 -- E.ATd.isValueObj: false rec: "S" 
 rpushg init$111 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"S":rec:S 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"S":rec:S 
 -- 
 -- OI:invoke:C: S :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"S":rec:S 
 -- formalArg:isPtn: "in M: ref Scheduler" :isBasicVal: false :valueObj: false 
 -- :actArg: "S" :isBasicVal: false 
 -- case:B: S ObjectGenerator 0 0 0 false false 
 -- end:loadArgs:NonVirt: "attach(S)" 
 -- INV:gen:after:E.loadArgs "attach(S)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "attach(S)" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)": ... 
 -- $ObjectInvocation_KeyWord:invoke: "attach(S)" >rec:"C1" ATd:"pattern" E:"attach(S)" E.ATd:"attach" unique:"False" 
 -- OI:invoke: "attach(S)" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)":rec:C1 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)":rec:C1 
 -- OI:invoke:B: "attach(S)" E: "attach(S)"  rec: "C1"  useRtnV: false "attach: {   in M: ref Scheduler;   main := M}" 
 -- OI:invoke:before:ATdx.invoke: pattern attach 
 -- $pattern:invoke: "attach: {   in M: ref Scheduler;   main := M" E: "attach(S)" useRTNv: "False"} 
 -- ptn:invoke: "attach" E: "attach(S)" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)":rec:C1 
 invoke attach 131 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -11 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)":rec:C1 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)":rec:C1 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: attach(S) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)":rec:C1 
 -- genclass:stmt: "S := Scheduler" 
 -- $Assign:gen: "S := Scheduler"  
 -- assign: "S := Scheduler" 
 -- computeAdr:superAdj: 0 "S" 
 -- computeAdr: 1 :rec: "none"  E: "S" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "S"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "S" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "S" >ATd.off:2:on:0:superAdj:0"S: ref Scheduler":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- $ref:getAdr: "S: ref Scheduler" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "S" 
 -- AssignmentStatement:gen: "S := Scheduler" right.label: "ObjectGenerator" "Scheduler" 
 -- $ObjectGenerator:gen: "Scheduler" >OGid:"Scheduler" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "Scheduler" 
 -- OG:before:super.gen: "Scheduler" 
 -- $Invocation:gen: "Scheduler" >useRtnV:"True"superAdj: 0 descNo: 125 
 -- INV:gen: "Scheduler" 
 -- isConstant: "Invocation" "Scheduler" 
 -- needorigin: "Scheduler" 
 -- needOrigin:E: "Scheduler"  E.ATd: "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB: var Boolean;    ...}" 
 -- doNeedOrigin:Ex: "Scheduler" 
 -- computeAdr:superAdj: 0 "Scheduler" 
 -- computeAdr: 1 :rec: "none"  E: "Scheduler" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Scheduler"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Scheduler" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "init" on: 2 isValueObj: false 
 -- origin: cores origin:isValueObj: false 
 rpushg init$111 1
 -- items:goOrigin:encOG: "cores" on: 1 isValueObj: false 
 -- origin: BasicSystem origin:isValueObj: false 
 rpushg cores$73 1
 -- $ObjectInvocation_Unary:getAdr: "Scheduler" >ATd.off:0 (isPtn):on:2:superAdj:0"Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %P ..."} 
 -- $pattern:getAdr: "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB: var Boolean;   inScheduler: var  ..."} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "Scheduler"  ATd: "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB: var Boolean ...}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec:- 
 -- computeAdr:isLast:E:  "Scheduler" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec:- 
 -- rec:  "Scheduler" E:  "Scheduler" 
 -- INV:gen:E.loadArgs "Scheduler" 
 -- $ObjectInvocation_Unary:loadArgs: "Scheduler" >staticOff:0 "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;  ..."} 
 -- $pattern:loadArgs: "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB: var Boolean;   inScheduler: va ..."} 
 -- ptn:loadArgs:E "Scheduler" 
 -- {(ObjectInvocation_Unary; (name: "Scheduler"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "Scheduler" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "Scheduler" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec ... 
 -- $ObjectInvocation_Unary:invoke: "Scheduler" >rec:"Scheduler" ATd:"pattern" E:"Scheduler" E.ATd:"Scheduler" unique:"False" 
 -- OI:invoke: "Scheduler" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec:Scheduler 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec:Scheduler 
 -- OI:invoke:B: "Scheduler" E: "Scheduler"  rec: "Scheduler"  useRtnV: true "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Scheduler 
 -- $pattern:invoke: "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB: var Boolean;   inScheduler: var  ..."} 
 -- ptn:invoke: "Scheduler" E: "Scheduler" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec:Scheduler 
 invoke Scheduler 125 0 1
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec:Scheduler 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec:Scheduler 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: Scheduler :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec:Scheduler 
 -- rec: "S" dstE: "S" dstE.ATd: "S: ref Scheduler" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- dstDI.isBasicVal: false dstDI.isValObj: false dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- isValue: false  isAdr: true  descNo:  0 
 rswap 0
 rstoreg  EisNone 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -13 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-13,0)=[]
 -- assign:adr.store:B: 
 -- genclass:stmt: "C2.attach(S)" 
 -- $ObjectGenerator:gen: "C2.attach(S)" >OGid:"attach" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "C2.attach(S)" 
 -- OG:before:super.gen: "C2.attach(S)" 
 -- $Invocation:gen: "C2.attach(S)" >useRtnV:"False"superAdj: 0 descNo: 131 
 -- INV:gen: "C2.attach(S)" 
 -- isConstant: "Invocation" "C2.attach(S)" 
 -- notConst: C2 C2: ref Core 
 -- needorigin: "C2.attach(S)" 
 -- needOrigin:E: "attach(S)"  E.ATd: "attach: {   in M: ref Scheduler;   main := M}" 
 -- doNeedOrigin:Ex: "attach(S)" 
 -- computeAdr:superAdj: 0 "C2.attach(S)" 
 -- computeAdr: 1 :rec: "none"  E: "C2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "C2"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "C2" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "init" on: 1 isValueObj: false 
 -- origin: cores origin:isValueObj: false 
 rpushg init$111 1
 -- $ObjectInvocation_Unary:getAdr: "C2" >ATd.off:3:on:1:superAdj:0"C2: ref Core":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"non ..." 
 -- $ref:getAdr: "C2: ref Core" >newOff:3,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "C2"  ATd: "C2: ref Core" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "C2"  E: "attach(S)" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:getAdr: "attach(S)" >ATd.off:0 (isPtn):on:0:superAdj:0"attach: {   in M: ref Scheduler;   main := M":Adr:off:3 size:0 isFloat:F isUnitVal:F super ...} 
 -- $pattern:getAdr: "attach: {   in M: ref Scheduler;   main := M" } 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "C2" >staticOff:0 "C2: ref Core" superAdj:0 
 -- $ref:loadArgs: "C2: ref Core" >E:"C2" 
 -- $pattern:loadArgs: "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: obj ;         i ..."} 
 -- ptn:loadArgs:E "C2" 
 -- {(ObjectInvocation_Unary; (name: "C2"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "C2" >rec:"C2" ATd:"ref" E:"attach(S)" E.ATd:"attach" unique:"False" 
 -- OI:invoke: "C2" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)":rec:C2 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)":rec:C2 
 -- OI:invoke:B: "C2" E: "attach(S)"  rec: "C2"  useRtnV: true "C2: ref Core" 
 -- OI:invoke:before:ATdx.invoke: ref C2 
 -- $ref:invoke: "C2: ref Core" E: "attach(S)">newOff:3 useRTNv: "True" 
 -- DI:invoke: "C2: ref Core" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)":rec:C2 
 rpushg init$111 3
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)":rec:C2 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)":rec:C2 
 -- 
 -- OI:invoke:C: C2 :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "C2" E: "attach(S)" 
 -- arg:other 
 -- computeAdr:isLast:E:  "attach(S)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)":rec:C2 
 -- rec:  "C2" E:  "attach(S)" 
 -- INV:gen:E.loadArgs "attach(S)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "attach(S)" >staticOff:0 "attach: {   in M: ref Scheduler;   main := M" superAdj:0arg:"S"} 
 -- $pattern:loadArgs: "attach: {   in M: ref Scheduler;   main := M" >E:"attach(S)":descNo:131} 
 -- ptn:loadArgs:E "attach(S)" 
 -- {(ObjectInvocation_KeyWord; (name: "attach"); (Arguments;  (name: "attach");  (name: "(");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "S");   ...} 
 -- args: "attach(S)" 
 -- E: "ObjectGenerator" S 
 -- E.arg: "ref" in M: ref Scheduler 
 -- NonVirt: "attach(S)" "ObjectInvocation_KeyWord" ActArg:  "S" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "attach(S)"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "S" >OGid:"Scheduler" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "S" 
 -- OG:before:super.gen: "S" 
 -- $Invocation:gen: "S" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "S" 
 -- isConstant: "Invocation" "S" 
 -- notConst: S S: ref Scheduler 
 -- needorigin: "S" 
 -- needOrigin:E: "S"  E.ATd: "S: ref Scheduler" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "S" 
 -- computeAdr: 1 :rec: "none"  E: "S" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "S"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "S" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "S" >ATd.off:2:on:0:superAdj:0"S: ref Scheduler":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- $ref:getAdr: "S: ref Scheduler" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "S" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "S" E:  "S" 
 -- INV:gen:E.loadArgs "S" 
 -- $ObjectInvocation_Unary:loadArgs: "S" >staticOff:0 "S: ref Scheduler" superAdj:0 
 -- $ref:loadArgs: "S: ref Scheduler" >E:"S" 
 -- $pattern:loadArgs: "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB: var Boolean;   inScheduler: va ..."} 
 -- ptn:loadArgs:E "S" 
 -- {(ObjectInvocation_Unary; (name: "S"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "S" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "S" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "S" >rec:"S" ATd:"ref" E:"S" E.ATd:"S" unique:"False" 
 -- OI:invoke: "S" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:S 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:S 
 -- OI:invoke:B: "S" E: "S"  rec: "S"  useRtnV: true "S: ref Scheduler" 
 -- OI:invoke:before:ATdx.invoke: ref S 
 -- $ref:invoke: "S: ref Scheduler" E: "S">newOff:2 useRTNv: "True" 
 -- DI:invoke: "S: ref Scheduler" 
 -- >Object:unique: false 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"S":rec:S 
 -- isCompositeValueObj: false E: "S" "S: ref Scheduler" false 
 -- E.ATd.isValueObj: false rec: "S" 
 rpushg init$111 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"S":rec:S 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"S":rec:S 
 -- 
 -- OI:invoke:C: S :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"S":rec:S 
 -- formalArg:isPtn: "in M: ref Scheduler" :isBasicVal: false :valueObj: false 
 -- :actArg: "S" :isBasicVal: false 
 -- case:B: S ObjectGenerator 0 0 0 false false 
 -- end:loadArgs:NonVirt: "attach(S)" 
 -- INV:gen:after:E.loadArgs "attach(S)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "attach(S)" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)": ... 
 -- $ObjectInvocation_KeyWord:invoke: "attach(S)" >rec:"C2" ATd:"pattern" E:"attach(S)" E.ATd:"attach" unique:"False" 
 -- OI:invoke: "attach(S)" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)":rec:C2 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)":rec:C2 
 -- OI:invoke:B: "attach(S)" E: "attach(S)"  rec: "C2"  useRtnV: false "attach: {   in M: ref Scheduler;   main := M}" 
 -- OI:invoke:before:ATdx.invoke: pattern attach 
 -- $pattern:invoke: "attach: {   in M: ref Scheduler;   main := M" E: "attach(S)" useRTNv: "False"} 
 -- ptn:invoke: "attach" E: "attach(S)" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)":rec:C2 
 invoke attach 131 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -14 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)":rec:C2 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)":rec:C2 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: attach(S) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)":rec:C2 
 -- genclass:stmt: "S := Scheduler" 
 -- $Assign:gen: "S := Scheduler"  
 -- assign: "S := Scheduler" 
 -- computeAdr:superAdj: 0 "S" 
 -- computeAdr: 1 :rec: "none"  E: "S" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "S"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "S" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "S" >ATd.off:2:on:0:superAdj:0"S: ref Scheduler":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- $ref:getAdr: "S: ref Scheduler" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "S" 
 -- AssignmentStatement:gen: "S := Scheduler" right.label: "ObjectGenerator" "Scheduler" 
 -- $ObjectGenerator:gen: "Scheduler" >OGid:"Scheduler" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "Scheduler" 
 -- OG:before:super.gen: "Scheduler" 
 -- $Invocation:gen: "Scheduler" >useRtnV:"True"superAdj: 0 descNo: 125 
 -- INV:gen: "Scheduler" 
 -- isConstant: "Invocation" "Scheduler" 
 -- needorigin: "Scheduler" 
 -- needOrigin:E: "Scheduler"  E.ATd: "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB: var Boolean;    ...}" 
 -- doNeedOrigin:Ex: "Scheduler" 
 -- computeAdr:superAdj: 0 "Scheduler" 
 -- computeAdr: 1 :rec: "none"  E: "Scheduler" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Scheduler"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Scheduler" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "init" on: 2 isValueObj: false 
 -- origin: cores origin:isValueObj: false 
 rpushg init$111 1
 -- items:goOrigin:encOG: "cores" on: 1 isValueObj: false 
 -- origin: BasicSystem origin:isValueObj: false 
 rpushg cores$73 1
 -- $ObjectInvocation_Unary:getAdr: "Scheduler" >ATd.off:0 (isPtn):on:2:superAdj:0"Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %P ..."} 
 -- $pattern:getAdr: "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB: var Boolean;   inScheduler: var  ..."} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "Scheduler"  ATd: "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB: var Boolean ...}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec:- 
 -- computeAdr:isLast:E:  "Scheduler" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec:- 
 -- rec:  "Scheduler" E:  "Scheduler" 
 -- INV:gen:E.loadArgs "Scheduler" 
 -- $ObjectInvocation_Unary:loadArgs: "Scheduler" >staticOff:0 "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;  ..."} 
 -- $pattern:loadArgs: "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB: var Boolean;   inScheduler: va ..."} 
 -- ptn:loadArgs:E "Scheduler" 
 -- {(ObjectInvocation_Unary; (name: "Scheduler"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "Scheduler" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "Scheduler" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec ... 
 -- $ObjectInvocation_Unary:invoke: "Scheduler" >rec:"Scheduler" ATd:"pattern" E:"Scheduler" E.ATd:"Scheduler" unique:"False" 
 -- OI:invoke: "Scheduler" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec:Scheduler 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec:Scheduler 
 -- OI:invoke:B: "Scheduler" E: "Scheduler"  rec: "Scheduler"  useRtnV: true "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Scheduler 
 -- $pattern:invoke: "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB: var Boolean;   inScheduler: var  ..."} 
 -- ptn:invoke: "Scheduler" E: "Scheduler" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec:Scheduler 
 invoke Scheduler 125 0 1
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec:Scheduler 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec:Scheduler 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: Scheduler :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec:Scheduler 
 -- rec: "S" dstE: "S" dstE.ATd: "S: ref Scheduler" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- dstDI.isBasicVal: false dstDI.isValObj: false dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- isValue: false  isAdr: true  descNo:  0 
 rswap 0
 rstoreg  EisNone 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -16 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-16,0)=[]
 -- assign:adr.store:B: 
 -- genclass:stmt: "C3.attach(S)" 
 -- $ObjectGenerator:gen: "C3.attach(S)" >OGid:"attach" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "C3.attach(S)" 
 -- OG:before:super.gen: "C3.attach(S)" 
 -- $Invocation:gen: "C3.attach(S)" >useRtnV:"False"superAdj: 0 descNo: 131 
 -- INV:gen: "C3.attach(S)" 
 -- isConstant: "Invocation" "C3.attach(S)" 
 -- notConst: C3 C3: ref Core 
 -- needorigin: "C3.attach(S)" 
 -- needOrigin:E: "attach(S)"  E.ATd: "attach: {   in M: ref Scheduler;   main := M}" 
 -- doNeedOrigin:Ex: "attach(S)" 
 -- computeAdr:superAdj: 0 "C3.attach(S)" 
 -- computeAdr: 1 :rec: "none"  E: "C3" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "C3"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "C3" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "init" on: 1 isValueObj: false 
 -- origin: cores origin:isValueObj: false 
 rpushg init$111 1
 -- $ObjectInvocation_Unary:getAdr: "C3" >ATd.off:4:on:1:superAdj:0"C3: ref Core":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"non ..." 
 -- $ref:getAdr: "C3: ref Core" >newOff:4,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "C3"  ATd: "C3: ref Core" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "C3"  E: "attach(S)" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:getAdr: "attach(S)" >ATd.off:0 (isPtn):on:0:superAdj:0"attach: {   in M: ref Scheduler;   main := M":Adr:off:4 size:0 isFloat:F isUnitVal:F super ...} 
 -- $pattern:getAdr: "attach: {   in M: ref Scheduler;   main := M" } 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "C3" >staticOff:0 "C3: ref Core" superAdj:0 
 -- $ref:loadArgs: "C3: ref Core" >E:"C3" 
 -- $pattern:loadArgs: "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: obj ;         i ..."} 
 -- ptn:loadArgs:E "C3" 
 -- {(ObjectInvocation_Unary; (name: "C3"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "C3" >rec:"C3" ATd:"ref" E:"attach(S)" E.ATd:"attach" unique:"False" 
 -- OI:invoke: "C3" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)":rec:C3 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)":rec:C3 
 -- OI:invoke:B: "C3" E: "attach(S)"  rec: "C3"  useRtnV: true "C3: ref Core" 
 -- OI:invoke:before:ATdx.invoke: ref C3 
 -- $ref:invoke: "C3: ref Core" E: "attach(S)">newOff:4 useRTNv: "True" 
 -- DI:invoke: "C3: ref Core" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)":rec:C3 
 rpushg init$111 4
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)":rec:C3 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)":rec:C3 
 -- 
 -- OI:invoke:C: C3 :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "C3" E: "attach(S)" 
 -- arg:other 
 -- computeAdr:isLast:E:  "attach(S)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)":rec:C3 
 -- rec:  "C3" E:  "attach(S)" 
 -- INV:gen:E.loadArgs "attach(S)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "attach(S)" >staticOff:0 "attach: {   in M: ref Scheduler;   main := M" superAdj:0arg:"S"} 
 -- $pattern:loadArgs: "attach: {   in M: ref Scheduler;   main := M" >E:"attach(S)":descNo:131} 
 -- ptn:loadArgs:E "attach(S)" 
 -- {(ObjectInvocation_KeyWord; (name: "attach"); (Arguments;  (name: "attach");  (name: "(");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "S");   ...} 
 -- args: "attach(S)" 
 -- E: "ObjectGenerator" S 
 -- E.arg: "ref" in M: ref Scheduler 
 -- NonVirt: "attach(S)" "ObjectInvocation_KeyWord" ActArg:  "S" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "attach(S)"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "S" >OGid:"Scheduler" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "S" 
 -- OG:before:super.gen: "S" 
 -- $Invocation:gen: "S" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "S" 
 -- isConstant: "Invocation" "S" 
 -- notConst: S S: ref Scheduler 
 -- needorigin: "S" 
 -- needOrigin:E: "S"  E.ATd: "S: ref Scheduler" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "S" 
 -- computeAdr: 1 :rec: "none"  E: "S" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "S"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "S" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "S" >ATd.off:2:on:0:superAdj:0"S: ref Scheduler":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- $ref:getAdr: "S: ref Scheduler" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "S" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "S" E:  "S" 
 -- INV:gen:E.loadArgs "S" 
 -- $ObjectInvocation_Unary:loadArgs: "S" >staticOff:0 "S: ref Scheduler" superAdj:0 
 -- $ref:loadArgs: "S: ref Scheduler" >E:"S" 
 -- $pattern:loadArgs: "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB: var Boolean;   inScheduler: va ..."} 
 -- ptn:loadArgs:E "S" 
 -- {(ObjectInvocation_Unary; (name: "S"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "S" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "S" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "S" >rec:"S" ATd:"ref" E:"S" E.ATd:"S" unique:"False" 
 -- OI:invoke: "S" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:S 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:S 
 -- OI:invoke:B: "S" E: "S"  rec: "S"  useRtnV: true "S: ref Scheduler" 
 -- OI:invoke:before:ATdx.invoke: ref S 
 -- $ref:invoke: "S: ref Scheduler" E: "S">newOff:2 useRTNv: "True" 
 -- DI:invoke: "S: ref Scheduler" 
 -- >Object:unique: false 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"S":rec:S 
 -- isCompositeValueObj: false E: "S" "S: ref Scheduler" false 
 -- E.ATd.isValueObj: false rec: "S" 
 rpushg init$111 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"S":rec:S 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"S":rec:S 
 -- 
 -- OI:invoke:C: S :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"S":rec:S 
 -- formalArg:isPtn: "in M: ref Scheduler" :isBasicVal: false :valueObj: false 
 -- :actArg: "S" :isBasicVal: false 
 -- case:B: S ObjectGenerator 0 0 0 false false 
 -- end:loadArgs:NonVirt: "attach(S)" 
 -- INV:gen:after:E.loadArgs "attach(S)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "attach(S)" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)": ... 
 -- $ObjectInvocation_KeyWord:invoke: "attach(S)" >rec:"C3" ATd:"pattern" E:"attach(S)" E.ATd:"attach" unique:"False" 
 -- OI:invoke: "attach(S)" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)":rec:C3 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)":rec:C3 
 -- OI:invoke:B: "attach(S)" E: "attach(S)"  rec: "C3"  useRtnV: false "attach: {   in M: ref Scheduler;   main := M}" 
 -- OI:invoke:before:ATdx.invoke: pattern attach 
 -- $pattern:invoke: "attach: {   in M: ref Scheduler;   main := M" E: "attach(S)" useRTNv: "False"} 
 -- ptn:invoke: "attach" E: "attach(S)" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)":rec:C3 
 invoke attach 131 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -17 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)":rec:C3 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)":rec:C3 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: attach(S) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(S)":rec:C3 
 -- genclass:stmt: "C4.attach(Scheduler)" 
 -- $ObjectGenerator:gen: "C4.attach(Scheduler)" >OGid:"attach" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "C4.attach(Scheduler)" 
 -- OG:before:super.gen: "C4.attach(Scheduler)" 
 -- $Invocation:gen: "C4.attach(Scheduler)" >useRtnV:"False"superAdj: 0 descNo: 131 
 -- INV:gen: "C4.attach(Scheduler)" 
 -- isConstant: "Invocation" "C4.attach(Scheduler)" 
 -- notConst: C4 C4: ref Core{-- should be array         } 
 -- needorigin: "C4.attach(Scheduler)" 
 -- needOrigin:E: "attach(Scheduler)"  E.ATd: "attach: {   in M: ref Scheduler;   main := M}" 
 -- doNeedOrigin:Ex: "attach(Scheduler)" 
 -- computeAdr:superAdj: 0 "C4.attach(Scheduler)" 
 -- computeAdr: 1 :rec: "none"  E: "C4" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "C4"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "C4" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "init" on: 1 isValueObj: false 
 -- origin: cores origin:isValueObj: false 
 rpushg init$111 1
 -- $ObjectInvocation_Unary:getAdr: "C4" >ATd.off:5:on:1:superAdj:0"C4: ref Core{-- should be array         ":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa ...} 
 -- $ref:getAdr: "C4: ref Core{-- should be array         " >newOff:5,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAd ...} 
 -- E.on: 1 
 -- beforeIsValueObj:E: "C4"  ATd: "C4: ref Core{-- should be array         }" 
 -- computeAdr:isFirst: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "C4"  E: "attach(Scheduler)" 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:getAdr: "attach(Scheduler)" >ATd.off:0 (isPtn):on:0:superAdj:0"attach: {   in M: ref Scheduler;   main := M":Adr:off:5 size:0 isFloat:F isUnitVal ...} 
 -- $pattern:getAdr: "attach: {   in M: ref Scheduler;   main := M" } 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(Scheduler)":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "C4" >staticOff:0 "C4: ref Core{-- should be array         " superAdj:0} 
 -- $ref:loadArgs: "C4: ref Core{-- should be array         " >E:"C4"} 
 -- $pattern:loadArgs: "Core: SuperCore{   %Public;   attach: ;      in M: ref Scheduler;      main := M;   %Private;   dummy: var integer;   go: ;      loopX: obj ;         i ..."} 
 -- ptn:loadArgs:E "C4" 
 -- {(ObjectInvocation_Unary; (name: "C4"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "C4" >rec:"C4" ATd:"ref" E:"attach(Scheduler)" E.ATd:"attach" unique:"False" 
 -- OI:invoke: "C4" 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(Scheduler)":rec:C4 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(Scheduler)":rec:C4 
 -- OI:invoke:B: "C4" E: "attach(Scheduler)"  rec: "C4"  useRtnV: true "C4: ref Core{-- should be array         }" 
 -- OI:invoke:before:ATdx.invoke: ref C4 
 -- $ref:invoke: "C4: ref Core{-- should be array         " E: "attach(Scheduler)">newOff:5 useRTNv: "True"} 
 -- DI:invoke: "C4: ref Core{-- should be array         }" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(Scheduler)":rec:C4 
 rpushg init$111 5
 -- OI:invoke:V: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(Scheduler)":rec:C4 
 -- 
 -- OI:invoke:X: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(Scheduler)":rec:C4 
 -- 
 -- OI:invoke:C: C4 :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "C4" E: "attach(Scheduler)" 
 -- arg:other 
 -- computeAdr:isLast:E:  "attach(Scheduler)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(Scheduler)":rec:C4 
 -- rec:  "C4" E:  "attach(Scheduler)" 
 -- INV:gen:E.loadArgs "attach(Scheduler)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "attach(Scheduler)" >staticOff:0 "attach: {   in M: ref Scheduler;   main := M" superAdj:0arg:"Scheduler"} 
 -- $pattern:loadArgs: "attach: {   in M: ref Scheduler;   main := M" >E:"attach(Scheduler)":descNo:131} 
 -- ptn:loadArgs:E "attach(Scheduler)" 
 -- {(ObjectInvocation_KeyWord; (name: "attach"); (Arguments;  (name: "attach");  (name: "(");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "Schedu ..."} 
 -- args: "attach(Scheduler)" 
 -- E: "ObjectGenerator" Scheduler 
 -- E.arg: "ref" in M: ref Scheduler 
 -- NonVirt: "attach(Scheduler)" "ObjectInvocation_KeyWord" ActArg:  "Scheduler" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "attach(Scheduler)"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "Scheduler" >OGid:"Scheduler" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "Scheduler" 
 -- OG:before:super.gen: "Scheduler" 
 -- $Invocation:gen: "Scheduler" >useRtnV:"True"superAdj: 0 descNo: 125 
 -- INV:gen: "Scheduler" 
 -- isConstant: "Invocation" "Scheduler" 
 -- needorigin: "Scheduler" 
 -- needOrigin:E: "Scheduler"  E.ATd: "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB: var Boolean;    ...}" 
 -- doNeedOrigin:Ex: "Scheduler" 
 -- computeAdr:superAdj: 0 "Scheduler" 
 -- computeAdr: 1 :rec: "none"  E: "Scheduler" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Scheduler"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Scheduler" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "init" on: 2 isValueObj: false 
 -- origin: cores origin:isValueObj: false 
 rpushg init$111 1
 -- items:goOrigin:encOG: "cores" on: 1 isValueObj: false 
 -- origin: BasicSystem origin:isValueObj: false 
 rpushg cores$73 1
 -- $ObjectInvocation_Unary:getAdr: "Scheduler" >ATd.off:0 (isPtn):on:2:superAdj:0"Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %P ..."} 
 -- $pattern:getAdr: "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB: var Boolean;   inScheduler: var  ..."} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "Scheduler"  ATd: "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB: var Boolean ...}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec:- 
 -- computeAdr:isLast:E:  "Scheduler" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec:- 
 -- rec:  "Scheduler" E:  "Scheduler" 
 -- INV:gen:E.loadArgs "Scheduler" 
 -- $ObjectInvocation_Unary:loadArgs: "Scheduler" >staticOff:0 "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;  ..."} 
 -- $pattern:loadArgs: "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB: var Boolean;   inScheduler: va ..."} 
 -- ptn:loadArgs:E "Scheduler" 
 -- {(ObjectInvocation_Unary; (name: "Scheduler"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "Scheduler" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "Scheduler" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec ... 
 -- $ObjectInvocation_Unary:invoke: "Scheduler" >rec:"Scheduler" ATd:"pattern" E:"Scheduler" E.ATd:"Scheduler" unique:"False" 
 -- OI:invoke: "Scheduler" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec:Scheduler 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec:Scheduler 
 -- OI:invoke:B: "Scheduler" E: "Scheduler"  rec: "Scheduler"  useRtnV: true "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Scheduler 
 -- $pattern:invoke: "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB: var Boolean;   inScheduler: var  ..."} 
 -- ptn:invoke: "Scheduler" E: "Scheduler" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec:Scheduler 
 invoke Scheduler 125 0 1
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec:Scheduler 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec:Scheduler 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: Scheduler :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Scheduler":rec:Scheduler 
 -- formalArg:isPtn: "in M: ref Scheduler" :isBasicVal: false :valueObj: false 
 -- :actArg: "Scheduler" :isBasicVal: false 
 -- case:B: Scheduler ObjectGenerator 0 0 0 false false 
 -- end:loadArgs:NonVirt: "attach(Scheduler)" 
 -- INV:gen:after:E.loadArgs "attach(Scheduler)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "attach(Scheduler)" :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"att ..." 
 -- $ObjectInvocation_KeyWord:invoke: "attach(Scheduler)" >rec:"C4" ATd:"pattern" E:"attach(Scheduler)" E.ATd:"attach" unique:"False" 
 -- OI:invoke: "attach(Scheduler)" 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(Scheduler)":rec:C4 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(Scheduler)":rec:C4 
 -- OI:invoke:B: "attach(Scheduler)" E: "attach(Scheduler)"  rec: "C4"  useRtnV: false "attach: {   in M: ref Scheduler;   main := M}" 
 -- OI:invoke:before:ATdx.invoke: pattern attach 
 -- $pattern:invoke: "attach: {   in M: ref Scheduler;   main := M" E: "attach(Scheduler)" useRTNv: "False"} 
 -- ptn:invoke: "attach" E: "attach(Scheduler)" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(Scheduler)":rec:C4 
 invoke attach 131 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -18 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(Scheduler)":rec:C4 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(Scheduler)":rec:C4 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: attach(Scheduler) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 5 
 -- OG:gen:end: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(Scheduler)":rec:C4 
 L2:
 -- pushReturn:  "init" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 125 
 -- Items:GenClass: Scheduler descNo: 125 isValue: false 
 -- Items:GenClass: Scheduler descNo: 122 isValue: false 
 -- Items:GenClass: SuperScheduler descNo: 21 isValue: false 

 CLASS Scheduler 125 3 BasicSystem 72
 -- vdtTableCopy: I:1:122 V:2:123 V:3:124 I:4:0
 -- vdtAdd: inx=4 descInx=125 vDescInx=125 vdtTop: 4 
 -- Store itemArgs: thisScheduler::< Scheduler{ProcessType::< BasicProcess;%Public;%Private;dummyB: var Boolean;inScheduler: var Boolean;P: ref BasicProcess;(this(Scheduler)). ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  3 origin
 -- super SuperScheduler
 -- push:super.origin: 
 -- computeAdr:superAdj: 3 "SuperScheduler" 
 -- computeAdr: 1 :rec: "none"  E: "SuperScheduler" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:3 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "SuperScheduler"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "SuperScheduler" >on:2 superAdj:3 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 3 
 rpushg BasicSystem$72 3
 -- items:goOrigin:encOG: "BasicSystem" on: 2 isValueObj: false 
 -- origin: BasicSystemLib origin:isValueObj: false 
 rpushg BasicSystem$72 1
 -- items:goOrigin:encOG: "BasicSystemLib" on: 1 isValueObj: false 
 -- origin: LIB origin:isValueObj: false 
 rpushg BasicSystemLib$38 1
 -- IV:viaIncl:on: 0 "BETA"  org: "%id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--Collectio ...}" 
 -- viaIncl:son:isFirst: true viaIncl<>none: false "BETA" 
 -- items:goOrigin:encOG: "LIB" on: 1 isValueObj: false 
 -- origin: BETAworld origin:isValueObj: false 
 rpushg LIB$33 1
 rpushg BETA 2
 -- $ObjectInvocation_Unary:getAdr: "SuperScheduler" >ATd.off:0 (isPtn):on:2:superAdj:3"SuperScheduler: {   thisScheduler:< Object;   ProcessType:< GeneralProcess;   active: r ..."} 
 -- $pattern:getAdr: "SuperScheduler: {   thisScheduler:< Object;   ProcessType:< GeneralProcess;   active: ref ProcessType;   inner(SuperScheduler)" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:3 isUnique:F isValue:F originIsValue:F:E:"SuperScheduler":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "SuperScheduler"  ATd: "SuperScheduler: {   thisScheduler:< Object;   ProcessType:< GeneralProcess;   active: ref ProcessType;   inner(SuperScheduler)}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:3 isUnique:F isValue:F originIsValue:F:E:"SuperScheduler":rec:- 
 -- computeAdr:isLast:E:  "SuperScheduler" 
 -- genClass:after:pushAddress: "SuperScheduler" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:3 isUnique:F isValue:F originIsValue:F:E:"SuperScheduler":rec:- 
 -- handleSuperArgs:E: "SuperScheduler" theIS: "thisScheduler::< Scheduler{ProcessType::< BasicProcess;%Public;%Private;dummyB: var Boolean;inScheduler: var Boolean;P: ref Bas ...}" 
 -- super.sig:not:none:superAdj: -3 
 -- $ObjectInvocation_Unary:loadArgs: "SuperScheduler" >staticOff:0 "SuperScheduler: {   thisScheduler:< Object;   ProcessType:< GeneralProcess;   active: ref ProcessType;   i ..."} 
 -- $pattern:loadArgs: "SuperScheduler: {   thisScheduler:< Object;   ProcessType:< GeneralProcess;   active: ref ProcessType;   inner(SuperScheduler)" >E:"SuperScheduler":des ...} 
 -- ptn:loadArgs:E "SuperScheduler" 
 -- {(ObjectInvocation_Unary; (name: "SuperScheduler"); (Arguments))} 
 -- args: "" 
 -- hArgOrg:super: SuperScheduler 
 -- Store itemArgs: thisScheduler::< Scheduler{ProcessType::< BasicProcess;%Public;%Private;dummyB: var Boolean;inScheduler: var Boolean;P: ref BasicProcess;(this(Scheduler)). ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=125 vDescInx=122 vdtTop: 4 
 -- $pattern:gen: "thisScheduler:< Object"  
 -- $pattern:gen: "ProcessType:< GeneralProcess"  
 -- $ref:gen: "active: ref ProcessType"  
 -- DI:gen: "active: ref ProcessType" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- $pattern:gen: "thisScheduler::< Scheduler"  
 -- $pattern:gen: "ProcessType::< BasicProcess"  
 -- $Property:gen: "%Public"  
 -- $Property:gen: "%Private"  
 -- $var:gen: "dummyB: var Boolean"  
 -- DI:gen: "dummyB: var Boolean" DI:isConst: false :isBasicValue: true :primNo: 4 
 -- DI:add:BP1:  dummyB 
 -- $var:gen: "inScheduler: var Boolean"  
 -- DI:gen: "inScheduler: var Boolean" DI:isConst: false :isBasicValue: true :primNo: 4 
 -- DI:add:BP1:  inScheduler 
 -- $ref:gen: "P: ref BasicProcess"  
 -- DI:gen: "P: ref BasicProcess" DI:isConst: false :isBasicValue: false :primNo: 0 
 rtnAlloc 1
 toSuper 122
DO:
 mvStack 
 L1:
 -- genclass:stmt: "%Public" 
 -- $Property:gen: "%Public"  
 -- genclass:stmt: "%Private" 
 -- $Property:gen: "%Private"  
 -- genclass:stmt: "(this(Scheduler)).suspend" 
 -- $ObjectGenerator:gen: "(this(Scheduler)).suspend" >OGid:"suspend" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(this(Scheduler)).suspend" 
 -- OG:before:super.gen: "(this(Scheduler)).suspend" 
 -- $Invocation:gen: "(this(Scheduler)).suspend" >useRtnV:"False"superAdj: 0 descNo: 84 
 -- INV:gen: "(this(Scheduler)).suspend" 
 -- isConstant: "Invocation" "(this(Scheduler)).suspend" 
 -- needorigin: "(this(Scheduler)).suspend" 
 -- needOrigin:E: "suspend"  E.ATd: "suspend: {   %basic 111}" 
 -- doNeedOrigin:Ex: "(this(Scheduler))" 
 -- computeAdr:superAdj: 0 "(this(Scheduler)).suspend" 
 -- computeAdr: 1 :rec: "none"  E: "(this(Scheduler))" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(this(Scheduler))"  
 -- $BracketedExp:loadOrigin: "(this(Scheduler))"  
 -- computeAdr:superAdj: 0 "this(Scheduler)" 
 -- computeAdr: 1 :rec: "none"  E: "this(Scheduler)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "this(Scheduler)"  
 pushThis 
 -- $ObjectInvocation_KeyWord:loadOrigin: "this(Scheduler)" >on:3 superAdj:0 isValueObj:"False" 
 -- this_prim: Scheduler :super.on: 1 
 -- $ObjectInvocation_KeyWord:getAdr: "this(Scheduler)" >ATd.off:0 (isPtn):on:3:superAdj:0"this: {   %basic 18;   in this: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal:F s ...} 
 -- $pattern:getAdr: "this: {   %basic 18;   in this: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(Scheduler)":rec:- 
 -- E.on: 3 
 -- beforeIsValueObj:E: "this(Scheduler)"  ATd: "this: {   %basic 18;   in this: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(Scheduler)":rec:- 
 -- computeAdr:isLast:E:  "this(Scheduler)" 
 -- BE:loadOrigin:E: this(Scheduler) 
 -- $ObjectInvocation_KeyWord:getAdr: "this(Scheduler)" >ATd.off:0 (isPtn):on:3:superAdj:0"this: {   %basic 18;   in this: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal:F s ...} 
 -- $pattern:getAdr: "this: {   %basic 18;   in this: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(Scheduler)":rec:- 
 -- E.on: 3 
 -- beforeIsValueObj:E: "this(Scheduler)"  ATd: "this: {   %basic 18;   in this: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(Scheduler)":rec:- 
 -- computeAdr: 2 :rec: "this(Scheduler)"  E: "suspend"  A.E: "this(Scheduler)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(Scheduler)":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "suspend" >ATd.off:0 (isPtn):on:0:superAdj:0"suspend: {   %basic 111":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ...} 
 -- $pattern:getAdr: "suspend: {   %basic 111" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(Scheduler)":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_KeyWord:loadArgs: "this(Scheduler)" >staticOff:0 "this: {   %basic 18;   in this: ref Object" superAdj:0arg:"Scheduler"} 
 -- $pattern:loadArgs: "this: {   %basic 18;   in this: ref Object" >E:"this(Scheduler)":descNo:31} 
 -- $ObjectInvocation_KeyWord:invoke: "this(Scheduler)" >rec:"this(Scheduler)" ATd:"pattern" E:"suspend" E.ATd:"suspend" unique:"False" 
 -- OI:invoke: "this(Scheduler)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(Scheduler)":rec:this(Scheduler) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(Scheduler)":rec:this(Scheduler) 
 -- OI:invoke:B: "this(Scheduler)" E: "suspend"  rec: "this(Scheduler)"  useRtnV: true "this: {   %basic 18;   in this: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern this 
 -- $pattern:invoke: "this: {   %basic 18;   in this: ref Object" E: "suspend" useRTNv: "True"} 
 -- ptn:invoke: "this" E: "suspend" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend":rec:this(Scheduler) 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend":rec:this(Scheduler) 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend":rec:this(Scheduler) 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: this(Scheduler) :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "this(Scheduler)" E: "suspend" 
 -- computeAdr:isLast:E:  "suspend" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend":rec:this(Scheduler) 
 -- rec:  "this(Scheduler)" E:  "suspend" 
 -- INV:gen:E.loadArgs "suspend" 
 -- $ObjectInvocation_Unary:loadArgs: "suspend" >staticOff:0 "suspend: {   %basic 111" superAdj:0} 
 -- $pattern:loadArgs: "suspend: {   %basic 111" >E:"suspend":descNo:84} 
 -- ptn:loadArgs:E "suspend" 
 -- {(ObjectInvocation_Unary; (name: "suspend"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "suspend" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "suspend" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend":rec:th ... 
 -- $ObjectInvocation_Unary:invoke: "suspend" >rec:"this(Scheduler)" ATd:"pattern" E:"suspend" E.ATd:"suspend" unique:"False" 
 -- OI:invoke: "suspend" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend":rec:this(Scheduler) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend":rec:this(Scheduler) 
 -- OI:invoke:B: "suspend" E: "suspend"  rec: "this(Scheduler)"  useRtnV: false "suspend: {   %basic 111}" 
 -- OI:invoke:before:ATdx.invoke: pattern suspend 
 -- $pattern:invoke: "suspend: {   %basic 111" E: "suspend" useRTNv: "False"} 
 -- ptn:invoke: "suspend" E: "suspend" ptnKind: 0 useRtnV: false 
 suspend
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend":rec:this(Scheduler) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend":rec:this(Scheduler) 
 -- 
 -- OI:invoke:C: suspend :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend":rec:this(Scheduler) 
 -- genclass:stmt: "sch.add" 
 -- $ObjectGenerator:gen: "sch.add" >OGid:"add" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "sch.add" 
 -- OG:before:super.gen: "sch.add" 
 -- $Invocation:gen: "sch.add" >useRtnV:"False"superAdj: 0 descNo: 128 
 -- INV:gen: "sch.add" 
 -- isConstant: "Invocation" "sch.add" 
 -- needorigin: "sch.add" 
 -- needOrigin:E: "add"  E.ATd: "add: {   entry;      M := M + 1}" 
 -- doNeedOrigin:Ex: "add" 
 -- computeAdr:superAdj: 0 "sch.add" 
 -- computeAdr: 1 :rec: "none"  E: "sch" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "sch"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "sch" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "Scheduler" on: 1 isValueObj: false 
 -- origin: BasicSystem origin:isValueObj: false 
 rpushg Scheduler$125 3
 -- $ObjectInvocation_Unary:getAdr: "sch" >ATd.off:5:on:1:superAdj:0"sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry ..."} 
 -- $obj:getAdr: "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      entry;         M := M ..."} 
 -- E.on: 1 
 -- beforeIsValueObj:E: "sch"  ATd: "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      en ...}" 
 -- computeAdr:isFirst: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "sch"  E: "add" 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "add" >ATd.off:0 (isPtn):on:0:superAdj:0"add: {   entry;      M := M + 1":Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa ...} 
 -- $pattern:getAdr: "add: {   entry;      M := M + 1" } 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"add":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "sch" >staticOff:0 "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.f ..."} 
 -- $obj:loadArgs: "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      entry;         M := ..."} 
 -- $ObjectInvocation_Unary:invoke: "sch" >rec:"sch" ATd:"obj" E:"add" E.ATd:"add" unique:"False" 
 -- OI:invoke: "sch" 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"add":rec:sch 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"add":rec:sch 
 -- OI:invoke:B: "sch" E: "add"  rec: "sch"  useRtnV: true "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L ...}" 
 -- OI:invoke:before:ATdx.invoke: obj sch 
 -- $obj:invoke: "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      entry;         M := M ..."} 
 -- DI:invoke: "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      entry;         M := M + ...}" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"add":rec:sch 
 rpushg Scheduler$125 5
 -- OI:invoke:V: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"add":rec:sch 
 -- 
 -- OI:invoke:X: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"add":rec:sch 
 -- 
 -- OI:invoke:C: sch :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "sch" E: "add" 
 -- computeAdr:isLast:E:  "add" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"add":rec:sch 
 -- rec:  "sch" E:  "add" 
 -- INV:gen:E.loadArgs "add" 
 -- $ObjectInvocation_Unary:loadArgs: "add" >staticOff:0 "add: {   entry;      M := M + 1" superAdj:0} 
 -- $pattern:loadArgs: "add: {   entry;      M := M + 1" >E:"add":descNo:128} 
 -- ptn:loadArgs:E "add" 
 -- {(ObjectInvocation_Unary; (name: "add"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "add" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "add" :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"add":rec:sch 
 -- $ObjectInvocation_Unary:invoke: "add" >rec:"sch" ATd:"pattern" E:"add" E.ATd:"add" unique:"False" 
 -- OI:invoke: "add" 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"add":rec:sch 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"add":rec:sch 
 -- OI:invoke:B: "add" E: "add"  rec: "sch"  useRtnV: false "add: {   entry;      M := M + 1}" 
 -- OI:invoke:before:ATdx.invoke: pattern add 
 -- $pattern:invoke: "add: {   entry;      M := M + 1" E: "add" useRTNv: "False"} 
 -- ptn:invoke: "add" E: "add" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"add":rec:sch 
 invoke add 128 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"add":rec:sch 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"add":rec:sch 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: add :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 5 
 -- OG:gen:end: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"add":rec:sch 
 -- genclass:stmt: "loop: do {   inScheduler := 1;   active := SQS.removeNext;   if (active =/= none) :then ;      active.status := P_status.ACTIVE;      inScheduler := 0;     ...}" 
 -- $do:gen: "loop: do {   inScheduler := 1;   active := SQS.removeNext;   if (active =/= none) :then ;      active.status := P_status.ACTIVE;      inScheduler := 0;      acti ..."} 
 -- $ObjectGenerator:gen: "inScheduler := 1{   active := SQS.removeNext;   if (active =/= none) :then ;      active.status := P_status.ACTIVE;      inScheduler := 0;      acti ..."} 
 -- OG:gen: "inScheduler := 1{   active := SQS.removeNext;   if (active =/= none) :then ;      active.status := P_status.ACTIVE;      inScheduler := 0;      active.attach(50); ...}" 
 pushThis 
 -- before objTmpStack:add:  165   "loop" 
 invoke loop 165 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 rtnInner  M
 END OSDV:0 objSize:6 isIndexed:0
 -- vdtAdd: inx=2 descInx=125 vDescInx=126 vdtTop: 4 
 -- vdtAdd: inx=3 descInx=125 vDescInx=127 vdtTop: 4 

 CLASS thisScheduler#126 126 3 Scheduler$125 125 isVstub
 -- Load origin:OG.isVirtualArg: false 
 -- items:goOrigin:encOG: "Scheduler" on: 1 isValueObj: false 
 -- origin: BasicSystem origin:isValueObj: false 
 rpushg Scheduler$125 3
 -- OG.super.on/descNo: 1 125 
 invoke Scheduler 125 0 1
 pushThis 
 rstoreg   2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- vdt:a:dNo: 126  newDescNo:  125 

 CLASS ProcessType#127 127 3 Scheduler$125 125 isVstub
 -- Load origin:OG.isVirtualArg: false 
 -- items:goOrigin:encOG: "Scheduler" on: 1 isValueObj: false 
 -- origin: BasicSystem origin:isValueObj: false 
 rpushg Scheduler$125 3
 -- OG.super.on/descNo: 1 83 
 invoke BasicProcess 83 0 1
 pushThis 
 rstoreg   2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- vdt:a:dNo: 127  newDescNo:  125 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 128 
 -- Items:GenClass: add descNo: 128 isValue: false 
 -- Items:GenClass: add descNo: 21 isValue: false 

 CLASS add 128 1 sch 75
 -- Store itemArgs: entry{   M := M + 1} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=128 vDescInx=128 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "entry{   M := M + 1}" 
 -- $ObjectGenerator:gen: "entry{   M := M + 1" >OGid:"entry$130" singular! staticOff=0 descNo=130 superAdj=0} 
 -- OG:gen: "entry{   M := M + 1}" 
 pushThis 
 -- before objTmpStack:add:  130   "entry$130" 
 invoke entry$130 130 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 -- pushReturn:  "add" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 129 
 -- Items:GenClass: entry descNo: 129 isValue: false 
 -- Items:GenClass: entry descNo: 21 isValue: false 

 CLASS entry 129 1 sch 75
 -- Store itemArgs: L.get{inner(entry);L.free} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=129 vDescInx=129 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "L.get" 
 -- $ObjectGenerator:gen: "L.get" >OGid:"get" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L.get" 
 -- OG:before:super.gen: "L.get" 
 -- $Invocation:gen: "L.get" >useRtnV:"False"superAdj: 0 descNo: 96 
 -- INV:gen: "L.get" 
 -- isConstant: "Invocation" "L.get" 
 -- needorigin: "L.get" 
 -- needOrigin:E: "get"  E.ATd: "get: {   loop: obj ;      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);      if (res = 1) :then ;   ...}" 
 -- doNeedOrigin:Ex: "get" 
 -- computeAdr:superAdj: 0 "L.get" 
 -- computeAdr: 1 :rec: "none"  E: "L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "entry" on: 1 isValueObj: false 
 -- origin: sch origin:isValueObj: false 
 rpushg entry$129 1
 -- $ObjectInvocation_Unary:getAdr: "L" >ATd.off:2:on:1:superAdj:0"L: obj Lock("Sch:lock")":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValu ... 
 -- $obj:getAdr: "L: obj Lock("Sch:lock")" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F is ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "L"  ATd: "L: obj Lock("Sch:lock")" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "L"  E: "get" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "get" >ATd.off:0 (isPtn):on:0:superAdj:0"get: {   loop: obj ;      res: var integer;      i: var integer;      --disable;      res := free_ ..."} 
 -- $pattern:getAdr: "get: {   loop: obj ;      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);      if (res = 1) :then ;         slee ..."} 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "L" >staticOff:0 "L: obj Lock("Sch:lock")" superAdj:0 
 -- $obj:loadArgs: "L: obj Lock("Sch:lock")" >E:"L" 
 -- $pattern:loadArgs: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ; ..."} 
 -- ptn:loadArgs:E "L" 
 -- {(ObjectInvocation_Unary; (name: "L"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "L" >rec:"L" ATd:"obj" E:"get" E.ATd:"get" unique:"False" 
 -- OI:invoke: "L" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:L 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:L 
 -- OI:invoke:B: "L" E: "get"  rec: "L"  useRtnV: true "L: obj Lock("Sch:lock")" 
 -- OI:invoke:before:ATdx.invoke: obj L 
 -- $obj:invoke: "L: obj Lock("Sch:lock")" E: "get">newOff:2 useRTNv: "True" 
 -- DI:invoke: "L: obj Lock("Sch:lock")" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:L 
 rpushg entry$129 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:L 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:L 
 -- 
 -- OI:invoke:C: L :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "L" E: "get" 
 -- computeAdr:isLast:E:  "get" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:L 
 -- rec:  "L" E:  "get" 
 -- INV:gen:E.loadArgs "get" 
 -- $ObjectInvocation_Unary:loadArgs: "get" >staticOff:0 "get: {   loop: obj ;      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);    ..."} 
 -- $pattern:loadArgs: "get: {   loop: obj ;      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);      if (res = 1) :then ;         sl ..."} 
 -- ptn:loadArgs:E "get" 
 -- {(ObjectInvocation_Unary; (name: "get"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "get" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "get" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:L 
 -- $ObjectInvocation_Unary:invoke: "get" >rec:"L" ATd:"pattern" E:"get" E.ATd:"get" unique:"False" 
 -- OI:invoke: "get" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:L 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:L 
 -- OI:invoke:B: "get" E: "get"  rec: "L"  useRtnV: false "get: {   loop: obj ;      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);   ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern get 
 -- $pattern:invoke: "get: {   loop: obj ;      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);      if (res = 1) :then ;         slee ..."} 
 -- ptn:invoke: "get" E: "get" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:L 
 invoke get 96 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:L 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:L 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: get :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:L 
 -- genclass:stmt: "inner(entry)" 
 -- $ObjectGenerator:gen: "inner(entry)" >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inner(entry)" 
 -- OG:before:super.gen: "inner(entry)" 
 -- $Invocation:gen: "inner(entry)" >useRtnV:"False"superAdj: 0 descNo: 12 
 -- INV:gen: "inner(entry)" 
 -- isConstant: "Invocation" "inner(entry)" 
 -- needorigin: "inner(entry)" 
 -- needOrigin:E: "inner(entry)"  E.ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- doNeedOrigin:Ex: "inner(entry)" 
 -- computeAdr:superAdj: 0 "inner(entry)" 
 -- computeAdr: 1 :rec: "none"  E: "inner(entry)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "inner(entry)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "inner(entry)" >on:4 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "inner(entry)" >ATd.off:0 (isPtn):on:4:superAdj:0"inner: {   %basic 101;   in inner: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal:F s ...} 
 -- $pattern:getAdr: "inner: {   %basic 101;   in inner: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(entry)":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "inner(entry)"  ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(entry)":rec:- 
 -- computeAdr:isLast:E:  "inner(entry)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(entry)":rec:- 
 -- rec:  "inner(entry)" E:  "inner(entry)" 
 -- INV:gen:E.loadArgs "inner(entry)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "inner(entry)" >staticOff:0 "inner: {   %basic 101;   in inner: ref Object" superAdj:0arg:"entry"} 
 -- $pattern:loadArgs: "inner: {   %basic 101;   in inner: ref Object" >E:"inner(entry)":descNo:12} 
 -- INV:gen:after:E.loadArgs "inner(entry)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(entry)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(en ..." 
 -- $ObjectInvocation_KeyWord:invoke: "inner(entry)" >rec:"inner(entry)" ATd:"pattern" E:"inner(entry)" E.ATd:"inner" unique:"False" 
 -- OI:invoke: "inner(entry)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(entry)":rec:inner(entry) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(entry)":rec:inner(entry) 
 -- OI:invoke:B: "inner(entry)" E: "inner(entry)"  rec: "inner(entry)"  useRtnV: false "inner: {   %basic 101;   in inner: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- $pattern:invoke: "inner: {   %basic 101;   in inner: ref Object" E: "inner(entry)" useRTNv: "False"} 
 -- ptn:invoke: "inner" E: "inner(entry)" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(entry)":rec:inner(entry) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(entry)":rec:inner(entry) 
 -- 
 -- OI:invoke:C: inner(entry) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(entry)":rec:inner(entry) 
 -- genclass:stmt: "L.free" 
 -- $ObjectGenerator:gen: "L.free" >OGid:"free" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L.free" 
 -- OG:before:super.gen: "L.free" 
 -- $Invocation:gen: "L.free" >useRtnV:"False"superAdj: 0 descNo: 109 
 -- INV:gen: "L.free" 
 -- isConstant: "Invocation" "L.free" 
 -- needorigin: "L.free" 
 -- needOrigin:E: "free"  E.ATd: "free: {   free_M := 0}" 
 -- doNeedOrigin:Ex: "free" 
 -- computeAdr:superAdj: 0 "L.free" 
 -- computeAdr: 1 :rec: "none"  E: "L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "entry" on: 1 isValueObj: false 
 -- origin: sch origin:isValueObj: false 
 rpushg entry$129 1
 -- $ObjectInvocation_Unary:getAdr: "L" >ATd.off:2:on:1:superAdj:0"L: obj Lock("Sch:lock")":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValu ... 
 -- $obj:getAdr: "L: obj Lock("Sch:lock")" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F is ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "L"  ATd: "L: obj Lock("Sch:lock")" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "L"  E: "free" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "free" >ATd.off:0 (isPtn):on:0:superAdj:0"free: {   free_M := 0":Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ...} 
 -- $pattern:getAdr: "free: {   free_M := 0" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "L" >staticOff:0 "L: obj Lock("Sch:lock")" superAdj:0 
 -- $obj:loadArgs: "L: obj Lock("Sch:lock")" >E:"L" 
 -- $pattern:loadArgs: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ; ..."} 
 -- ptn:loadArgs:E "L" 
 -- {(ObjectInvocation_Unary; (name: "L"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "L" >rec:"L" ATd:"obj" E:"free" E.ATd:"free" unique:"False" 
 -- OI:invoke: "L" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:L 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:L 
 -- OI:invoke:B: "L" E: "free"  rec: "L"  useRtnV: true "L: obj Lock("Sch:lock")" 
 -- OI:invoke:before:ATdx.invoke: obj L 
 -- $obj:invoke: "L: obj Lock("Sch:lock")" E: "free">newOff:2 useRTNv: "True" 
 -- DI:invoke: "L: obj Lock("Sch:lock")" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:L 
 rpushg entry$129 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:L 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:L 
 -- 
 -- OI:invoke:C: L :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "L" E: "free" 
 -- computeAdr:isLast:E:  "free" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:L 
 -- rec:  "L" E:  "free" 
 -- INV:gen:E.loadArgs "free" 
 -- $ObjectInvocation_Unary:loadArgs: "free" >staticOff:0 "free: {   free_M := 0" superAdj:0} 
 -- $pattern:loadArgs: "free: {   free_M := 0" >E:"free":descNo:109} 
 -- ptn:loadArgs:E "free" 
 -- {(ObjectInvocation_Unary; (name: "free"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "free" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "free" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:L 
 -- $ObjectInvocation_Unary:invoke: "free" >rec:"L" ATd:"pattern" E:"free" E.ATd:"free" unique:"False" 
 -- OI:invoke: "free" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:L 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:L 
 -- OI:invoke:B: "free" E: "free"  rec: "L"  useRtnV: false "free: {   free_M := 0}" 
 -- OI:invoke:before:ATdx.invoke: pattern free 
 -- $pattern:invoke: "free: {   free_M := 0" E: "free" useRTNv: "False"} 
 -- ptn:invoke: "free" E: "free" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:L 
 invoke free 109 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:L 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:L 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: free :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:L 
 L2:
 -- pushReturn:  "entry" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- vdtAdd: inx=2 descInx=129 vDescInx=0 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 130 
 -- Items:GenClass: entry$130 descNo: 130 isValue: false 
 -- Items:GenClass: entry$130 descNo: 129 isValue: false 
 -- Items:GenClass: entry descNo: 21 isValue: false 

 CLASS entry$130 130 2 add 128
 -- vdtTableCopy: I:1:129 I:2:0
 -- vdtAdd: inx=2 descInx=130 vDescInx=130 vdtTop: 2 
 -- Store itemArgs: M := M + 1 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  2 origin
 -- super entry
 -- push:super.origin: 
 -- computeAdr:superAdj: 2 "entry" 
 -- computeAdr: 1 :rec: "none"  E: "entry" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:2 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "entry"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "entry" >on:1 superAdj:2 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 2 
 rpushg add$128 2
 -- items:goOrigin:encOG: "add" on: 1 isValueObj: false 
 -- origin: sch origin:isValueObj: false 
 rpushg add$128 1
 -- $ObjectInvocation_Unary:getAdr: "entry" >ATd.off:0 (isPtn):on:1:superAdj:2"entry: {   L.get;   inner(entry);   L.free":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:2 is ...} 
 -- $pattern:getAdr: "entry: {   L.get;   inner(entry);   L.free" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:2 isUnique:F isValue:F originIsValue:F:E:"entry":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "entry"  ATd: "entry: {   L.get;   inner(entry);   L.free}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:2 isUnique:F isValue:F originIsValue:F:E:"entry":rec:- 
 -- computeAdr:isLast:E:  "entry" 
 -- genClass:after:pushAddress: "entry" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:2 isUnique:F isValue:F originIsValue:F:E:"entry":rec:- 
 -- handleSuperArgs:E: "entry" theIS: "M := M + 1" 
 -- super.sig:none:superAdj: 2 
 -- $ObjectInvocation_Unary:loadArgs: "entry" >staticOff:0 "entry: {   L.get;   inner(entry);   L.free" superAdj:2} 
 -- $pattern:loadArgs: "entry: {   L.get;   inner(entry);   L.free" >E:"entry":descNo:129} 
 -- ptn:loadArgs:E "entry" 
 -- {(ObjectInvocation_Unary; (name: "entry"); (Arguments))} 
 -- args: "" 
 -- hArgOrg:super: entry 
 -- Store itemArgs: M := M + 1 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=130 vDescInx=129 vdtTop: 2 
 rtnAlloc 1
 toSuper 129
DO:
 mvStack 
 L1:
 -- genclass:stmt: "M := M + 1" 
 -- $Assign:gen: "M := M + 1"  
 -- assign: "M := M + 1" 
 -- computeAdr:superAdj: 0 "M" 
 -- computeAdr: 1 :rec: "none"  E: "M" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "M"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "M" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "entry$130" on: 2 isValueObj: false 
 -- origin: add origin:isValueObj: false 
 rpushg entry$130$130 2
 -- items:goOrigin:encOG: "add" on: 1 isValueObj: false 
 -- origin: sch origin:isValueObj: false 
 rpushg add$128 1
 -- $ObjectInvocation_Unary:getAdr: "M" >ATd.off:3:on:2:superAdj:0"M: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "M: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "M: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "M"  ATd: "M: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:- 
 -- computeAdr:isLast:E:  "M" 
 -- AssignmentStatement:gen: "M := M + 1" right.label: "ObjectGenerator" "M + 1" 
 -- $ObjectGenerator:gen: "M + 1" >OGid:"+" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "M + 1" 
 -- OG:before:super.gen: "M + 1" 
 -- $Invocation:gen: "M + 1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "M + 1" 
 -- isConstant: "Invocation" "M + 1" 
 -- needorigin: "M + 1" 
 -- needOrigin:E: "M + 1"  E.ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- doNeedOrigin:Ex: "M + 1" 
 -- computeAdr:superAdj: 0 "M + 1" 
 -- computeAdr: 1 :rec: "none"  E: "M + 1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "M + 1"  
 -- $BinOp:loadOrigin: "M + 1"  
 -- BinaryExp:loadOrigin:empty: "M + 1" superAdj: 0 
 -- $BinOp:getAdr: "M + 1"  
 -- E.on: 2 
 -- beforeIsValueObj:E: "M + 1"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "M + 1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "M + 1" E:  "M + 1" 
 -- INV:gen:E.loadArgs "M + 1" 
 -- $BinOp:loadArgs: "M + 1"  
 -- BinaryExp:loadArgs: "M + 1" superAdj: 0 
 -- $Invocation:gen: "M" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "M" 
 -- isConstant: "Invocation" "M" 
 -- notConst: M M: var integer 
 -- needorigin: "M" 
 -- needOrigin:E: "M"  E.ATd: "M: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "M" 
 -- computeAdr: 1 :rec: "none"  E: "M" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "M"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "M" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "entry$130" on: 2 isValueObj: false 
 -- origin: add origin:isValueObj: false 
 rpushg entry$130$130 2
 -- items:goOrigin:encOG: "add" on: 1 isValueObj: false 
 -- origin: sch origin:isValueObj: false 
 rpushg add$128 1
 -- $ObjectInvocation_Unary:getAdr: "M" >ATd.off:3:on:2:superAdj:0"M: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "M: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "M: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "M"  ATd: "M: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:- 
 -- computeAdr:isLast:E:  "M" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:- 
 -- rec:  "M" E:  "M" 
 -- INV:gen:E.loadArgs "M" 
 -- $ObjectInvocation_Unary:loadArgs: "M" >staticOff:0 "M: var integer" superAdj:0 
 -- $var:loadArgs: "M: var integer" >E:"M" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "M" 
 -- {(ObjectInvocation_Unary; (name: "M"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "M" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "M" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:- 
 -- $ObjectInvocation_Unary:invoke: "M" >rec:"M" ATd:"var" isValueObj E:"M" E.ATd:"M" unique:"False" 
 -- OI:invoke: "M" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- OI:invoke:B: "M" E: "M"  rec: "M"  useRtnV: true "M: var integer" 
 -- OI:invoke:before:ATdx.invoke: var M 
 -- $var:invoke: "M: var integer" E: "M">newOff:3 useRTNv: "True" 
 -- DI:invoke: "M: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- isCompositeValueObj: false E: "M" "M: var integer" true 
 -- E.ATd.isValueObj: false rec: "M" 
 pushg 3 sch$75
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- 
 -- OI:invoke:C: M :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- left:#I "M + 1" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- $pattern:loadArgs: "+  : {   %basic 61;   in V: var integer;   out R: var integer" >E:"+ 1":descNo:49} 
 -- ptn:loadArgs:E "+ 1" 
 -- {(ObjectInvocation_Binary; (name: "+"); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 1));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "1" 
 -- E: "ObjectGenerator" 1 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "+ 1" "ObjectInvocation_Binary" ActArg:  "1" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ 1"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "1" :isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "+ 1" 
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- INV:gen:after:E.loadArgs "M + 1" 
 -- OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- IV:E.invoke:useRtnVal: true E: BinOp "M + 1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- $BinOp:invoke: "M + 1"  
 -- BinaryExp:invoke: "M" rec: "M + 1" 
 -- M: "+ 1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- $ObjectInvocation_Binary:invoke: "+ 1" >rec:"M" ATd:"pattern" E:"+ 1" E.ATd:"+  " unique:"False" 
 -- OI:invoke: "+ 1" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- origin:isValueObj "integer" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- OI:invoke:B: "+ 1" E: "+ 1"  rec: "M"  useRtnV: true "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- $pattern:invoke: "+  : {   %basic 61;   in V: var integer;   out R: var integer" E: "+ 1" useRTNv: "True"} 
 -- ptn:invoke: "+  " E: "+ 1" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "M" E: "+ 1" 
 -- arg:integer 
 plus
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:M 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:M 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: + 1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "M" dstE: "M" dstE.ATd: "M: var integer" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "M + 1" 
 -- isArgOfAssignI2IwithUniValArg "M := M + 1" arg: "M + 1" ObjectGenerator 
 -- arg.super.arg: "M + 1" BinOp 
 -- recx:BinaryExp:recx: "M + 1" 
 -- M: "+ 1" label: "ObjectInvocation_Binary" M.ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- checkInt2IntWithUnitArg:rec: "M" E: "+ 1" 
 -- arg:integer 
 -- M:arg: "1" ObjectGenerator false 
 -- dstDI: "M: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg sch$75 3
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 165 
 -- Items:GenClass: loop descNo: 165 isValue: false 
 -- Items:GenClass: loop descNo: 21 isValue: false 

 CLASS loop 165 1 Scheduler 125
 -- Store itemArgs: inScheduler := 1{active := SQS.removeNext;if (active =/= none) :then ;   active.status := P_status.ACTIVE;   inScheduler := 0;   active.attach(50);   inSch ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=165 vDescInx=165 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "inScheduler := 1" 
 -- $Assign:gen: "inScheduler := 1"  
 -- assign: "inScheduler := 1" 
 -- computeAdr:superAdj: 0 "inScheduler" 
 -- computeAdr: 1 :rec: "none"  E: "inScheduler" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inScheduler"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inScheduler" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: Scheduler origin:isValueObj: false 
 rpushg loop$165 1
 -- $ObjectInvocation_Unary:getAdr: "inScheduler" >ATd.off:5:on:1:superAdj:0"inScheduler: var Boolean":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F o ... 
 -- $var:getAdr: "inScheduler: var Boolean" >newOff:5,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVal ... 
 -- DI:OG: Boolean 
 -- before:floatTest:  "inScheduler: var Boolean" ObjectGenerator 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inScheduler":rec:- 
 -- After:U*U: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inScheduler":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inScheduler"  ATd: "inScheduler: var Boolean" 
 -- computeAdr:isFirst: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inScheduler":rec:- 
 -- computeAdr:isLast:E:  "inScheduler" 
 -- AssignmentStatement:gen: "inScheduler := 1" right.label: "ObjectGenerator" "1" 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "inScheduler" dstE: "inScheduler" dstE.ATd: "inScheduler: var Boolean" useRtn: false :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsV ... 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "1" 
 -- isArgOfAssignI2IwithUniValArg "inScheduler := 1" arg: "1" ObjectGenerator 
 -- arg.super.arg: "1" ConstLiteral 
 -- dstDI: "inScheduler: var Boolean" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inScheduler":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg Scheduler$125 5
 -- assign:adr.store:B: 
 -- genclass:stmt: "active := SQS.removeNext" 
 -- $Assign:gen: "active := SQS.removeNext"  
 -- assign: "active := SQS.removeNext" 
 -- computeAdr:superAdj: 0 "active" 
 -- computeAdr: 1 :rec: "none"  E: "active" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "active"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "active" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: Scheduler origin:isValueObj: false 
 rpushg loop$165 1
 -- $ObjectInvocation_Unary:getAdr: "active" >ATd.off:2:on:1:superAdj:0"active: ref ProcessType":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- $ref:getAdr: "active: ref ProcessType" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F is ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "active"  ATd: "active: ref ProcessType" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "active" 
 -- AssignmentStatement:gen: "active := SQS.removeNext" right.label: "ObjectGenerator" "SQS.removeNext" 
 -- $ObjectGenerator:gen: "SQS.removeNext" >OGid:"removeNext" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "SQS.removeNext" 
 -- OG:before:super.gen: "SQS.removeNext" 
 -- $Invocation:gen: "SQS.removeNext" >useRtnV:"True"superAdj: 0 descNo: 166 
 -- INV:gen: "SQS.removeNext" 
 -- isConstant: "Invocation" "SQS.removeNext" 
 -- needorigin: "SQS.removeNext" 
 -- needOrigin:E: "removeNext"  E.ATd: "removeNext: {   out P: ref BasicProcess;   entry;      P := Q.removeNext}" 
 -- doNeedOrigin:Ex: "removeNext" 
 -- computeAdr:superAdj: 0 "SQS.removeNext" 
 -- computeAdr: 1 :rec: "none"  E: "SQS" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "SQS"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "SQS" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 2 isValueObj: false 
 -- origin: Scheduler origin:isValueObj: false 
 rpushg loop$165 1
 -- items:goOrigin:encOG: "Scheduler" on: 1 isValueObj: false 
 -- origin: BasicSystem origin:isValueObj: false 
 rpushg Scheduler$125 3
 -- $ObjectInvocation_Unary:getAdr: "SQS" >ATd.off:6:on:2:superAdj:0"SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Publi ..."} 
 -- $obj:getAdr: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if  ..."} 
 -- E.on: 2 
 -- beforeIsValueObj:E: "SQS"  ATd: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V ...}" 
 -- computeAdr:isFirst: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "SQS"  E: "removeNext" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "removeNext" >ATd.off:0 (isPtn):on:0:superAdj:0"removeNext: {   out P: ref BasicProcess;   entry;      P := Q.removeNext":Adr:off:6 size:0  ...} 
 -- $pattern:getAdr: "removeNext: {   out P: ref BasicProcess;   entry;      P := Q.removeNext" } 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "SQS" >staticOff:0 "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ..."} 
 -- $obj:loadArgs: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      i ..."} 
 -- $ObjectInvocation_Unary:invoke: "SQS" >rec:"SQS" ATd:"obj" E:"removeNext" E.ATd:"removeNext" unique:"False" 
 -- OI:invoke: "SQS" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:SQS 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:SQS 
 -- OI:invoke:B: "SQS" E: "removeNext"  rec: "SQS"  useRtnV: true "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public; ...}" 
 -- OI:invoke:before:ATdx.invoke: obj SQS 
 -- $obj:invoke: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if  ..."} 
 -- DI:invoke: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if (V ...}" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:SQS 
 rpushg loop$165 6
 -- OI:invoke:V: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:SQS 
 -- 
 -- OI:invoke:X: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:SQS 
 -- 
 -- OI:invoke:C: SQS :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "SQS" E: "removeNext" 
 -- computeAdr:isLast:E:  "removeNext" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:SQS 
 -- rec:  "SQS" E:  "removeNext" 
 -- INV:gen:E.loadArgs "removeNext" 
 -- $ObjectInvocation_Unary:loadArgs: "removeNext" >staticOff:0 "removeNext: {   out P: ref BasicProcess;   entry;      P := Q.removeNext" superAdj:0} 
 -- $pattern:loadArgs: "removeNext: {   out P: ref BasicProcess;   entry;      P := Q.removeNext" >E:"removeNext":descNo:166} 
 -- ptn:loadArgs:E "removeNext" 
 -- {(ObjectInvocation_Unary; (name: "removeNext"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "removeNext" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "removeNext" :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":r ... 
 -- $ObjectInvocation_Unary:invoke: "removeNext" >rec:"SQS" ATd:"pattern" E:"removeNext" E.ATd:"removeNext" unique:"False" 
 -- OI:invoke: "removeNext" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:SQS 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:SQS 
 -- OI:invoke:B: "removeNext" E: "removeNext"  rec: "SQS"  useRtnV: true "removeNext: {   out P: ref BasicProcess;   entry;      P := Q.removeNext}" 
 -- OI:invoke:before:ATdx.invoke: pattern removeNext 
 -- $pattern:invoke: "removeNext: {   out P: ref BasicProcess;   entry;      P := Q.removeNext" E: "removeNext" useRTNv: "True"} 
 -- ptn:invoke: "removeNext" E: "removeNext" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:SQS 
 invoke removeNext 166 0 0
 -- global:pushOut: P off: 2 
 rpushg  2
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:SQS 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:SQS 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:SQS 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:SQS 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:SQS 
 -- OI:invoke:C: removeNext :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:SQS 
 -- rec: "active" dstE: "active" dstE.ATd: "active: ref ProcessType" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"n ..." 
 -- dstDI.isBasicVal: false dstDI.isValObj: false dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- isValue: false  isAdr: true  descNo:  0 
 rswap 0
 rstoreg  EisNone 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- assign:adr.store:B: 
 -- genclass:stmt: "if (active =/= none) :then {   active.status := P_status.ACTIVE;   inScheduler := 0;   active.attach(50);   inScheduler := 1;   if (active.status = P_statu ...}" 
 -- $ObjectGenerator:gen: "if (active =/= none) :then {   active.status := P_status.ACTIVE;   inScheduler := 0;   active.attach(50);   inScheduler := 1;   if (active.status =  ..."} 
 -- OG:gen: "if (active =/= none) :then {   active.status := P_status.ACTIVE;   inScheduler := 0;   active.attach(50);   inScheduler := 1;   if (active.status = P_status.ACTIV ...}" 
 -- OG:before:super.gen: "if (active =/= none) :then {   active.status := P_status.ACTIVE;   inScheduler := 0;   active.attach(50);   inScheduler := 1;   if (active.status = P ...}" 
 -- $Invocation:gen: "if (active =/= none) :then {   active.status := P_status.ACTIVE;   inScheduler := 0;   active.attach(50);   inScheduler := 1;   if (active.status = P_sta ..."} 
 -- INV:gen: "if (active =/= none) :then {   active.status := P_status.ACTIVE;   inScheduler := 0;   active.attach(50);   inScheduler := 1;   if (active.status = P_status.ACTI ...}" 
 -- isConstant: "Invocation" "if (active =/= none) :then {   active.status := P_status.ACTIVE;   inScheduler := 0;   active.attach(50);   inScheduler := 1;   if (active.status ...}" 
 -- needorigin: "if (active =/= none) :then {   active.status := P_status.ACTIVE;   inScheduler := 0;   active.attach(50);   inScheduler := 1;   if (active.status = P_status.A ...}" 
 -- needOrigin:E: "if (active =/= none) :then {   active.status := P_status.ACTIVE;   inScheduler := 0;   active.attach(50);   inScheduler := 1;   if (active.status = P_status ...}"   ... "i ..." 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (active =/= none) :then {   active.status := P_status.ACTIVE;   inScheduler := 0;   active.attach(50);   inScheduler := 1;   if (active.status = P_status.ACTIVE) ...}" E ... "i ..." 
 -- INV:gen:E.loadArgs "if (active =/= none) :then {   active.status := P_status.ACTIVE;   inScheduler := 0;   active.attach(50);   inScheduler := 1;   if (active.status = P_s ...}" 
 -- $IfThen:loadArgs: "if (active =/= none) :then {   active.status := P_status.ACTIVE;   inScheduler := 0;   active.attach(50);   inScheduler := 1;   if (active.status = P_st ..."} 
 -- INV:gen:after:E.loadArgs "if (active =/= none) :then {   active.status := P_status.ACTIVE;   inScheduler := 0;   active.attach(50);   inScheduler := 1;   if (active.status ...}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (active =/= none) :then {   active.status := P_status.ACTIVE;   inScheduler := 0;   active.attach(50);   inScheduler := 1;   if  ...}" 
 -- $IfThen:invoke: "if (active =/= none) :then {   active.status := P_status.ACTIVE;   inScheduler := 0;   active.attach(50);   inScheduler := 1;   if (active.status = P_stat ..."} 
 -- $IfThen:gen: "if (active =/= none) :then {   active.status := P_status.ACTIVE;   inScheduler := 0;   active.attach(50);   inScheduler := 1;   if (active.status = P_status. ..."} 
 -- $ObjectGenerator:gen: "(active =/= none)" >OGid:"=/=" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(active =/= none)" 
 -- OG:before:super.gen: "(active =/= none)" 
 -- $Invocation:gen: "(active =/= none)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(active =/= none)" 
 -- isConstant: "Invocation" "(active =/= none)" 
 -- needorigin: "(active =/= none)" 
 -- needOrigin:E: "(active =/= none)"  E.ATd: "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean}" 
 -- doNeedOrigin:Ex: "(active =/= none)" 
 -- computeAdr:superAdj: 0 "(active =/= none)" 
 -- computeAdr: 1 :rec: "none"  E: "(active =/= none)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(active =/= none)"  
 -- $BracketedExp:loadOrigin: "(active =/= none)"  
 -- computeAdr:superAdj: 0 "active =/= none" 
 -- computeAdr: 1 :rec: "none"  E: "active =/= none" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "active =/= none"  
 -- $BinOp:loadOrigin: "active =/= none"  
 -- BinaryExp:loadOrigin:empty: "active =/= none" superAdj: 0 
 -- $BinOp:getAdr: "active =/= none"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "active =/= none"  ATd: "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "active =/= none" 
 -- BE:loadOrigin:E: active =/= none 
 -- $BinOp:getAdr: "active =/= none"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "active =/= none"  ATd: "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "active =/= none" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "active =/= none" E:  "active =/= none" 
 -- INV:gen:E.loadArgs "active =/= none" 
 -- $BinOp:loadArgs: "active =/= none"  
 -- BinaryExp:loadArgs: "active =/= none" superAdj: 0 
 -- $Invocation:gen: "active" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "active" 
 -- isConstant: "Invocation" "active" 
 -- notConst: active active: ref ProcessType 
 -- needorigin: "active" 
 -- needOrigin:E: "active"  E.ATd: "active: ref ProcessType" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "active" 
 -- computeAdr: 1 :rec: "none"  E: "active" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "active"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "active" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: Scheduler origin:isValueObj: false 
 rpushg loop$165 1
 -- $ObjectInvocation_Unary:getAdr: "active" >ATd.off:2:on:1:superAdj:0"active: ref ProcessType":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- $ref:getAdr: "active: ref ProcessType" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F is ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "active"  ATd: "active: ref ProcessType" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "active" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "active" E:  "active" 
 -- INV:gen:E.loadArgs "active" 
 -- $ObjectInvocation_Unary:loadArgs: "active" >staticOff:0 "active: ref ProcessType" superAdj:0 
 -- $ref:loadArgs: "active: ref ProcessType" >E:"active" 
 -- $pattern:loadArgs: "ProcessType:< GeneralProcess" >E:"active":descNo:0 
 -- ptn:loadArgs:E "active" 
 -- {(ObjectInvocation_Unary; (name: "active"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "active" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "active" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "active" >rec:"active" ATd:"ref" E:"active" E.ATd:"active" unique:"False" 
 -- OI:invoke: "active" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:active 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:active 
 -- OI:invoke:B: "active" E: "active"  rec: "active"  useRtnV: true "active: ref ProcessType" 
 -- OI:invoke:before:ATdx.invoke: ref active 
 -- $ref:invoke: "active: ref ProcessType" E: "active">newOff:2 useRTNv: "True" 
 -- DI:invoke: "active: ref ProcessType" 
 -- >Object:unique: false 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"active":rec:active 
 -- isCompositeValueObj: false E: "active" "active: ref ProcessType" false 
 -- E.ATd.isValueObj: false rec: "active" 
 rpushg Scheduler$125 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"active":rec:active 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"active":rec:active 
 -- 
 -- OI:invoke:C: active :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"active":rec:active 
 -- $pattern:loadArgs: "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean" >E:"=/= none":descNo:117} 
 -- ptn:loadArgs:E "=/= none" 
 -- {(ObjectInvocation_Binary; (name: "=/="); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "none");     (Arguments)));   (Items descNo: ...} 
 -- args: "none" 
 -- E: "ObjectGenerator" none 
 -- E.arg: "ref" in objx: ref Object 
 -- NonVirt: "=/= none" "ObjectInvocation_Binary" ActArg:  "none" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "=/= none"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "none" >OGid:"none" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "none" 
 -- OG:before:super.gen: "none" 
 -- $Invocation:gen: "none" >useRtnV:"True"superAdj: 0 descNo: 116 
 -- INV:gen: "none" 
 -- isConstant: "Invocation" "none" 
 -- needorigin: "none" 
 -- needOrigin:E: "none"  E.ATd: "none: {   %basic 19;   none_x: var integer}" 
 -- doNeedOrigin:Ex: "none" 
 -- computeAdr:superAdj: 0 "none" 
 -- computeAdr: 1 :rec: "none"  E: "none" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "none"  
 -- $ObjectInvocation_Unary:loadOrigin: "none" >on:4 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_Unary:getAdr: "none" >ATd.off:0 (isPtn):on:4:superAdj:0"none: {   %basic 19;   none_x: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU ...} 
 -- $pattern:getAdr: "none: {   %basic 19;   none_x: var integer" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "none"  ATd: "none: {   %basic 19;   none_x: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "none" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "none" E:  "none" 
 -- INV:gen:E.loadArgs "none" 
 -- $ObjectInvocation_Unary:loadArgs: "none" >staticOff:0 "none: {   %basic 19;   none_x: var integer" superAdj:0} 
 -- $pattern:loadArgs: "none: {   %basic 19;   none_x: var integer" >E:"none":descNo:116} 
 -- ptn:loadArgs:E "none" 
 -- {(ObjectInvocation_Unary; (name: "none"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "none" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "none" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "none" >rec:"none" ATd:"pattern" E:"none" E.ATd:"none" unique:"False" 
 -- OI:invoke: "none" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- OI:invoke:B: "none" E: "none"  rec: "none"  useRtnV: true "none: {   %basic 19;   none_x: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern none 
 -- $pattern:invoke: "none: {   %basic 19;   none_x: var integer" E: "none" useRTNv: "True"} 
 -- ptn:invoke: "none" E: "none" ptnKind: 0 useRtnV: true 
 pushNone 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- 
 -- OI:invoke:C: none :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- formalArg:isPtn: "in objx: ref Object" :isBasicVal: false :valueObj: false 
 -- :actArg: "none" :isBasicVal: false 
 -- case:B: none ObjectGenerator 64 19 19 false false 
 -- end:loadArgs:NonVirt: "=/= none" 
 -- BinaryExp:loadArgs:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"active":rec:active 
 -- INV:gen:after:E.loadArgs "active =/= none" 
 -- OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"active":rec:active 
 -- IV:E.invoke:useRtnVal: true E: BinOp "active =/= none" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"active":rec:active 
 -- $BinOp:invoke: "active =/= none"  
 -- BinaryExp:invoke: "active" rec: "active =/= none" 
 -- M: "=/= none" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"active":rec:active 
 -- $ObjectInvocation_Binary:invoke: "=/= none" >rec:"active" ATd:"pattern" E:"=/= none" E.ATd:"=/=  " unique:"False" 
 -- OI:invoke: "=/= none" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"active":rec:active 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"active":rec:active 
 -- OI:invoke:B: "=/= none" E: "=/= none"  rec: "active"  useRtnV: true "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean}" 
 -- OI:invoke:before:ATdx.invoke: pattern =/=   
 -- $pattern:invoke: "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean" E: "=/= none" useRTNv: "True"} 
 -- ptn:invoke: "=/=  " E: "=/= none" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "active" E: "=/= none" 
 -- arg:other 
 rne
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"=/= none":rec:active 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"=/= none":rec:active 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: =/= none :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: "active.status := P_status.ACTIVE{   inScheduler := 0;   active.attach(50);   inScheduler := 1;   if (active.status = P_status.ACTIVE) :then ;      S ..."} 
 -- OG:gen: "active.status := P_status.ACTIVE{   inScheduler := 0;   active.attach(50);   inScheduler := 1;   if (active.status = P_status.ACTIVE) :then ;      SQS.insert(acti ...}" 
 pushThis 
 -- before objTmpStack:add:  172   "$172" 
 invoke $172 172 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "if (SQS.isEmpty) :then {   if (SQS.hasWaiting) :then ;      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) :then ;      sleep(50);      sch. ...}" 
 -- $ObjectGenerator:gen: "if (SQS.isEmpty) :then {   if (SQS.hasWaiting) :then ;      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) :then ;      sleep(50);    ..."} 
 -- OG:gen: "if (SQS.isEmpty) :then {   if (SQS.hasWaiting) :then ;      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) :then ;      sleep(50);      sch.add;    ...}" 
 -- OG:before:super.gen: "if (SQS.isEmpty) :then {   if (SQS.hasWaiting) :then ;      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) :then ;      sleep(50);     ...}" 
 -- $Invocation:gen: "if (SQS.isEmpty) :then {   if (SQS.hasWaiting) :then ;      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) :then ;      sleep(50);      sc ..."} 
 -- INV:gen: "if (SQS.isEmpty) :then {   if (SQS.hasWaiting) :then ;      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) :then ;      sleep(50);      sch.add;   ...}" 
 -- isConstant: "Invocation" "if (SQS.isEmpty) :then {   if (SQS.hasWaiting) :then ;      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) :then ;      sleep(50); ...}" 
 -- needorigin: "if (SQS.isEmpty) :then {   if (SQS.hasWaiting) :then ;      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) :then ;      sleep(50);      sch.add ...}" 
 -- needOrigin:E: "if (SQS.isEmpty) :then {   if (SQS.hasWaiting) :then ;      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) :then ;      sleep(50);      sch.a ...}"   ... "i ..." 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (SQS.isEmpty) :then {   if (SQS.hasWaiting) :then ;      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) :then ;      sleep(50);      sch.add;      ...}" E ... "i ..." 
 -- INV:gen:E.loadArgs "if (SQS.isEmpty) :then {   if (SQS.hasWaiting) :then ;      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) :then ;      sleep(50);       ...}" 
 -- $IfThenElse:loadArgs: "if (SQS.isEmpty) :then {   if (SQS.hasWaiting) :then ;      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) :then ;      sleep(50);    ..."} 
 -- INV:gen:after:E.loadArgs "if (SQS.isEmpty) :then {   if (SQS.hasWaiting) :then ;      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) :then ;      sleep(50); ...}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThenElse "if (SQS.isEmpty) :then {   if (SQS.hasWaiting) :then ;      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) :then ...}" 
 -- $IfThenElse:invoke: "if (SQS.isEmpty) :then {   if (SQS.hasWaiting) :then ;      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) :then ;      sleep(50);      ..."} 
 -- $IfThenElse:gen: "if (SQS.isEmpty) :then {   if (SQS.hasWaiting) :then ;      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) :then ;      sleep(50);      sc ..."} 
 -- $ObjectGenerator:gen: "(SQS.isEmpty)" >OGid:"isEmpty" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(SQS.isEmpty)" 
 -- OG:before:super.gen: "(SQS.isEmpty)" 
 -- $Invocation:gen: "(SQS.isEmpty)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(SQS.isEmpty)" 
 -- isConstant: "Invocation" "(SQS.isEmpty)" 
 -- needorigin: "(SQS.isEmpty)" 
 -- needOrigin:E: "(SQS.isEmpty)"  E.ATd: "isEmpty: {   out B: var Boolean;   entry;      B := Q.isEmpty}" 
 -- doNeedOrigin:Ex: "(SQS.isEmpty)" 
 -- computeAdr:superAdj: 0 "(SQS.isEmpty)" 
 -- computeAdr: 1 :rec: "none"  E: "(SQS.isEmpty)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(SQS.isEmpty)"  
 -- $BracketedExp:loadOrigin: "(SQS.isEmpty)"  
 -- computeAdr:superAdj: 0 "SQS.isEmpty" 
 -- computeAdr: 1 :rec: "none"  E: "SQS" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "SQS"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "SQS" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 2 isValueObj: false 
 -- origin: Scheduler origin:isValueObj: false 
 rpushg loop$165 1
 -- items:goOrigin:encOG: "Scheduler" on: 1 isValueObj: false 
 -- origin: BasicSystem origin:isValueObj: false 
 rpushg Scheduler$125 3
 -- $ObjectInvocation_Unary:getAdr: "SQS" >ATd.off:6:on:2:superAdj:0"SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Publi ..."} 
 -- $obj:getAdr: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if  ..."} 
 -- E.on: 2 
 -- beforeIsValueObj:E: "SQS"  ATd: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V ...}" 
 -- computeAdr:isFirst: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "SQS"  E: "isEmpty" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "isEmpty" >ATd.off:0 (isPtn):on:0:superAdj:0"isEmpty: {   out B: var Boolean;   entry;      B := Q.isEmpty":Adr:off:6 size:0 isFloat:F isUn ...} 
 -- $pattern:getAdr: "isEmpty: {   out B: var Boolean;   entry;      B := Q.isEmpty" } 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isEmpty":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "SQS" >staticOff:0 "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ..."} 
 -- $obj:loadArgs: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      i ..."} 
 -- $ObjectInvocation_Unary:invoke: "SQS" >rec:"SQS" ATd:"obj" E:"isEmpty" E.ATd:"isEmpty" unique:"False" 
 -- OI:invoke: "SQS" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isEmpty":rec:SQS 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isEmpty":rec:SQS 
 -- OI:invoke:B: "SQS" E: "isEmpty"  rec: "SQS"  useRtnV: true "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;    ...}" 
 -- OI:invoke:before:ATdx.invoke: obj SQS 
 -- $obj:invoke: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if  ..."} 
 -- DI:invoke: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if (V ...}" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isEmpty":rec:SQS 
 rpushg loop$165 6
 -- OI:invoke:V: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isEmpty":rec:SQS 
 -- 
 -- OI:invoke:X: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isEmpty":rec:SQS 
 -- 
 -- OI:invoke:C: SQS :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "SQS" E: "isEmpty" 
 -- computeAdr:isLast:E:  "isEmpty" 
 -- BE:loadOrigin:E: isEmpty 
 -- $ObjectInvocation_Unary:getAdr: "isEmpty" >ATd.off:0 (isPtn):on:0:superAdj:0"isEmpty: {   out B: var Boolean;   entry;      B := Q.isEmpty":Adr:off:0 size:0 isFloat:F isUn ...} 
 -- $pattern:getAdr: "isEmpty: {   out B: var Boolean;   entry;      B := Q.isEmpty" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isEmpty":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isEmpty":rec:- 
 -- computeAdr:isLast:E:  "isEmpty" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isEmpty":rec:- 
 -- rec:  "SQS" E:  "isEmpty" 
 -- INV:gen:E.loadArgs "isEmpty" 
 -- $ObjectInvocation_Unary:loadArgs: "isEmpty" >staticOff:0 "isEmpty: {   out B: var Boolean;   entry;      B := Q.isEmpty" superAdj:0} 
 -- $pattern:loadArgs: "isEmpty: {   out B: var Boolean;   entry;      B := Q.isEmpty" >E:"isEmpty":descNo:175} 
 -- ptn:loadArgs:E "isEmpty" 
 -- {(ObjectInvocation_Unary; (name: "isEmpty"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "isEmpty" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "isEmpty" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isEmpty":rec:- 
 -- $ObjectInvocation_Unary:invoke: "isEmpty" >rec:"SQS" ATd:"pattern" E:"isEmpty" E.ATd:"isEmpty" unique:"False" 
 -- OI:invoke: "isEmpty" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isEmpty":rec:SQS 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isEmpty":rec:SQS 
 -- OI:invoke:B: "isEmpty" E: "isEmpty"  rec: "SQS"  useRtnV: true "isEmpty: {   out B: var Boolean;   entry;      B := Q.isEmpty}" 
 -- OI:invoke:before:ATdx.invoke: pattern isEmpty 
 -- $pattern:invoke: "isEmpty: {   out B: var Boolean;   entry;      B := Q.isEmpty" E: "isEmpty" useRTNv: "True"} 
 -- ptn:invoke: "isEmpty" E: "isEmpty" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isEmpty":rec:SQS 
 invoke isEmpty 175 0 0
 -- global:pushOut: B off: 2 
 pushg 2 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -3 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isEmpty":rec:SQS 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isEmpty":rec:SQS 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isEmpty":rec:SQS 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isEmpty":rec:SQS 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isEmpty":rec:SQS 
 -- OI:invoke:C: isEmpty :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isEmpty":rec:SQS 
 jmpFalse  L7
 L6:
 -- $ObjectGenerator:gen: "if (SQS.hasWaiting) :then {      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) :then ;      sleep(50);      sch.add;      restart(lo ..."} 
 -- OG:gen: "if (SQS.hasWaiting) :then {      sleep(100);      restart(Loop);   sch.dcr;   if (sch.running) :then ;      sleep(50);      sch.add;      restart(loop)}" 
 pushThis 
 -- before objTmpStack:add:  178   "$178" 
 invoke $178 178 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L8
 L7:
 -- $ObjectGenerator:gen: "restart(Loop)" >OGid:"$187" singular! staticOff=0 descNo=187 superAdj=0 
 -- OG:gen: "restart(Loop)" 
 pushThis 
 -- before objTmpStack:add:  187   "$187" 
 invoke $187 187 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -5 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L8:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 -- pushReturn:  "loop" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 166 
 -- Items:GenClass: removeNext descNo: 166 isValue: false 
 -- Items:GenClass: removeNext descNo: 21 isValue: false 

 CLASS removeNext 166 1 SQS 77
 -- Store itemArgs: out P: ref BasicProcess{entry;   P := Q.removeNext} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=166 vDescInx=166 vdtTop: 1 
 mvStack 
 -- $ref:gen: "out P: ref BasicProcess"  
 -- DI:gen: "out P: ref BasicProcess" DI:isConst: false :isBasicValue: false :primNo: 0 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "entry{   P := Q.removeNext}" 
 -- $ObjectGenerator:gen: "entry{   P := Q.removeNext" >OGid:"entry$167" singular! staticOff=0 descNo=167 superAdj=0} 
 -- OG:gen: "entry{   P := Q.removeNext}" 
 pushThis 
 -- before objTmpStack:add:  167   "entry$167" 
 invoke entry$167 167 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 -- pushReturn:  "removeNext" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 167 
 -- Items:GenClass: entry$167 descNo: 167 isValue: false 
 -- Items:GenClass: entry$167 descNo: 95 isValue: false 
 -- Items:GenClass: entry descNo: 21 isValue: false 

 CLASS entry$167 167 2 removeNext 166
 -- vdtTableCopy: I:1:95 I:2:0
 -- vdtAdd: inx=2 descInx=167 vDescInx=167 vdtTop: 2 
 -- Store itemArgs: P := Q.removeNext 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  2 origin
 -- super entry
 -- push:super.origin: 
 -- computeAdr:superAdj: 2 "entry" 
 -- computeAdr: 1 :rec: "none"  E: "entry" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:2 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "entry"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "entry" >on:1 superAdj:2 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 2 
 rpushg removeNext$166 2
 -- items:goOrigin:encOG: "removeNext" on: 1 isValueObj: false 
 -- origin: SQS origin:isValueObj: false 
 rpushg removeNext$166 1
 -- $ObjectInvocation_Unary:getAdr: "entry" >ATd.off:0 (isPtn):on:1:superAdj:2"entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1 ..."} 
 -- $pattern:getAdr: "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:2 isUnique:F isValue:F originIsValue:F:E:"entry":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "entry"  ATd: "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:2 isUnique:F isValue:F originIsValue:F:E:"entry":rec:- 
 -- computeAdr:isLast:E:  "entry" 
 -- genClass:after:pushAddress: "entry" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:2 isUnique:F isValue:F originIsValue:F:E:"entry":rec:- 
 -- handleSuperArgs:E: "entry" theIS: "P := Q.removeNext" 
 -- super.sig:none:superAdj: 2 
 -- $ObjectInvocation_Unary:loadArgs: "entry" >staticOff:0 "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free" superAd ...} 
 -- $pattern:loadArgs: "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free" >E:"entry":descNo:95} 
 -- ptn:loadArgs:E "entry" 
 -- {(ObjectInvocation_Unary; (name: "entry"); (Arguments))} 
 -- args: "" 
 -- hArgOrg:super: entry 
 -- Store itemArgs: P := Q.removeNext 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=167 vDescInx=95 vdtTop: 2 
 rtnAlloc 1
 toSuper 95
DO:
 mvStack 
 L1:
 -- genclass:stmt: "P := Q.removeNext" 
 -- $Assign:gen: "P := Q.removeNext"  
 -- assign: "P := Q.removeNext" 
 -- computeAdr:superAdj: 0 "P" 
 -- computeAdr: 1 :rec: "none"  E: "P" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "P"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "P" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "entry$167" on: 1 isValueObj: false 
 -- origin: removeNext origin:isValueObj: false 
 rpushg entry$167$167 2
 -- $ObjectInvocation_Unary:getAdr: "P" >ATd.off:2:on:1:superAdj:0"out P: ref BasicProcess":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValu ... 
 -- $ref:getAdr: "out P: ref BasicProcess" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F is ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "P"  ATd: "out P: ref BasicProcess" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "P" 
 -- AssignmentStatement:gen: "P := Q.removeNext" right.label: "ObjectGenerator" "Q.removeNext" 
 -- $ObjectGenerator:gen: "Q.removeNext" >OGid:"removeNext" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "Q.removeNext" 
 -- OG:before:super.gen: "Q.removeNext" 
 -- $Invocation:gen: "Q.removeNext" >useRtnV:"True"superAdj: 0 descNo: 168 
 -- INV:gen: "Q.removeNext" 
 -- isConstant: "Invocation" "Q.removeNext" 
 -- needorigin: "Q.removeNext" 
 -- needOrigin:E: "removeNext"  E.ATd: "removeNext: {   -- return last element in queue and remove it for queue      out elm: ref Object;   if (last =/= none) :then ;      noO ...}" 
 -- doNeedOrigin:Ex: "removeNext" 
 -- computeAdr:superAdj: 0 "Q.removeNext" 
 -- computeAdr: 1 :rec: "none"  E: "Q" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Q"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Q" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "entry$167" on: 2 isValueObj: false 
 -- origin: removeNext origin:isValueObj: false 
 rpushg entry$167$167 2
 -- items:goOrigin:encOG: "removeNext" on: 1 isValueObj: false 
 -- origin: SQS origin:isValueObj: false 
 rpushg removeNext$166 1
 -- $ObjectInvocation_Unary:getAdr: "Q" >ATd.off:2:on:2:superAdj:0"Q: obj ProcessQueue":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F: ... 
 -- $obj:getAdr: "Q: obj ProcessQueue" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValu ... 
 -- E.on: 2 
 -- beforeIsValueObj:E: "Q"  ATd: "Q: obj ProcessQueue" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "Q"  E: "removeNext" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "removeNext" >ATd.off:0 (isPtn):on:0:superAdj:0"removeNext: {   -- return last element in queue and remove it for queue      out elm: ref O ..."} 
 -- $pattern:getAdr: "removeNext: {   -- return last element in queue and remove it for queue      out elm: ref Object;   if (last =/= none) :then ;      noOfElm := noOfElm -  ..."} 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "Q" >staticOff:0 "Q: obj ProcessQueue" superAdj:0 
 -- $obj:loadArgs: "Q: obj ProcessQueue" >E:"Q" 
 -- $pattern:loadArgs: "ProcessQueue: LIB.Collections.QueueLib.Queue{   %Public;   displayx: ;      put('Q')" >E:"Q":descNo:79} 
 -- ptn:loadArgs:E "Q" 
 -- {(ObjectInvocation_Unary; (name: "Q"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "Q" >rec:"Q" ATd:"obj" E:"removeNext" E.ATd:"removeNext" unique:"False" 
 -- OI:invoke: "Q" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:Q 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:Q 
 -- OI:invoke:B: "Q" E: "removeNext"  rec: "Q"  useRtnV: true "Q: obj ProcessQueue" 
 -- OI:invoke:before:ATdx.invoke: obj Q 
 -- $obj:invoke: "Q: obj ProcessQueue" E: "removeNext">newOff:2 useRTNv: "True" 
 -- DI:invoke: "Q: obj ProcessQueue" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:Q 
 rpushg entry$167$167 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:Q 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:Q 
 -- 
 -- OI:invoke:C: Q :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "Q" E: "removeNext" 
 -- computeAdr:isLast:E:  "removeNext" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:Q 
 -- rec:  "Q" E:  "removeNext" 
 -- INV:gen:E.loadArgs "removeNext" 
 -- $ObjectInvocation_Unary:loadArgs: "removeNext" >staticOff:0 "removeNext: {   -- return last element in queue and remove it for queue      out elm: ref Object;   if (last = ..."} 
 -- $pattern:loadArgs: "removeNext: {   -- return last element in queue and remove it for queue      out elm: ref Object;   if (last =/= none) :then ;      noOfElm := noOfElm  ..."} 
 -- ptn:loadArgs:E "removeNext" 
 -- {(ObjectInvocation_Unary; (name: "removeNext"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "removeNext" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "removeNext" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":r ... 
 -- $ObjectInvocation_Unary:invoke: "removeNext" >rec:"Q" ATd:"pattern" E:"removeNext" E.ATd:"removeNext" unique:"False" 
 -- OI:invoke: "removeNext" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:Q 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:Q 
 -- OI:invoke:B: "removeNext" E: "removeNext"  rec: "Q"  useRtnV: true "removeNext: {   -- return last element in queue and remove it for queue      out elm: ref Object;   if  ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern removeNext 
 -- $pattern:invoke: "removeNext: {   -- return last element in queue and remove it for queue      out elm: ref Object;   if (last =/= none) :then ;      noOfElm := noOfElm -  ..."} 
 -- ptn:invoke: "removeNext" E: "removeNext" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:Q 
 invoke removeNext 168 0 0
 -- global:pushOut: elm off: 2 
 rpushg  2
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:Q 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:Q 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:Q 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:Q 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:Q 
 -- OI:invoke:C: removeNext :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:Q 
 -- rec: "P" dstE: "P" dstE.ATd: "out P: ref BasicProcess" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- ... 
 -- dstDI.isBasicVal: false dstDI.isValObj: false dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- isValue: false  isAdr: true  descNo:  0 
 rswap 0
 rstoreg  EisNone 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 168 
 -- Items:GenClass: removeNext descNo: 168 isValue: false 
 -- Items:GenClass: removeNext descNo: 21 isValue: false 

 CLASS removeNext 168 1 Queue 78
 -- Store itemArgs: -- return last element in queue and remove it for queue      out elm: ref Object{if (last =/= none) :then ;   noOfElm := noOfElm - 1;   elm := last.elm;    ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=168 vDescInx=168 vdtTop: 1 
 mvStack 
 -- $ref:gen: "out elm: ref Object"  
 -- DI:gen: "out elm: ref Object" DI:isConst: false :isBasicValue: false :primNo: 64 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "if (last =/= none) :then {   noOfElm := noOfElm - 1;   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;      last.succ := none;   :else ; ...}" 
 -- $ObjectGenerator:gen: "if (last =/= none) :then {   noOfElm := noOfElm - 1;   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;      last.succ := none;    ..."} 
 -- OG:gen: "if (last =/= none) :then {   noOfElm := noOfElm - 1;   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;      last.succ := none;   :else ;      h ...}" 
 -- OG:before:super.gen: "if (last =/= none) :then {   noOfElm := noOfElm - 1;   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;      last.succ := none;   : ...}" 
 -- $Invocation:gen: "if (last =/= none) :then {   noOfElm := noOfElm - 1;   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;      last.succ := none;   :else ..."} 
 -- INV:gen: "if (last =/= none) :then {   noOfElm := noOfElm - 1;   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;      last.succ := none;   :else ;       ...}" 
 -- isConstant: "Invocation" "if (last =/= none) :then {   noOfElm := noOfElm - 1;   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;      last.succ := none; ...}" 
 -- needorigin: "if (last =/= none) :then {   noOfElm := noOfElm - 1;   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;      last.succ := none;   :else ;    ...}" 
 -- needOrigin:E: "if (last =/= none) :then {   noOfElm := noOfElm - 1;   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;      last.succ := none;   :else ;  ...}"   ... "i ..." 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (last =/= none) :then {   noOfElm := noOfElm - 1;   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;      last.succ := none;   :else ;      hea ...}" E ... "i ..." 
 -- INV:gen:E.loadArgs "if (last =/= none) :then {   noOfElm := noOfElm - 1;   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;      last.succ := none;   :el ...}" 
 -- $IfThen:loadArgs: "if (last =/= none) :then {   noOfElm := noOfElm - 1;   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;      last.succ := none;   :els ..."} 
 -- INV:gen:after:E.loadArgs "if (last =/= none) :then {   noOfElm := noOfElm - 1;   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;      last.succ := none; ...}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (last =/= none) :then {   noOfElm := noOfElm - 1;   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;      last ...}" 
 -- $IfThen:invoke: "if (last =/= none) :then {   noOfElm := noOfElm - 1;   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;      last.succ := none;   :else  ..."} 
 -- $IfThen:gen: "if (last =/= none) :then {   noOfElm := noOfElm - 1;   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;      last.succ := none;   :else ;   ..."} 
 -- $ObjectGenerator:gen: "(last =/= none)" >OGid:"=/=" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(last =/= none)" 
 -- OG:before:super.gen: "(last =/= none)" 
 -- $Invocation:gen: "(last =/= none)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(last =/= none)" 
 -- isConstant: "Invocation" "(last =/= none)" 
 -- needorigin: "(last =/= none)" 
 -- needOrigin:E: "(last =/= none)"  E.ATd: "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean}" 
 -- doNeedOrigin:Ex: "(last =/= none)" 
 -- computeAdr:superAdj: 0 "(last =/= none)" 
 -- computeAdr: 1 :rec: "none"  E: "(last =/= none)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(last =/= none)"  
 -- $BracketedExp:loadOrigin: "(last =/= none)"  
 -- computeAdr:superAdj: 0 "last =/= none" 
 -- computeAdr: 1 :rec: "none"  E: "last =/= none" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "last =/= none"  
 -- $BinOp:loadOrigin: "last =/= none"  
 -- BinaryExp:loadOrigin:empty: "last =/= none" superAdj: 0 
 -- $BinOp:getAdr: "last =/= none"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "last =/= none"  ATd: "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "last =/= none" 
 -- BE:loadOrigin:E: last =/= none 
 -- $BinOp:getAdr: "last =/= none"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "last =/= none"  ATd: "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "last =/= none" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "last =/= none" E:  "last =/= none" 
 -- INV:gen:E.loadArgs "last =/= none" 
 -- $BinOp:loadArgs: "last =/= none"  
 -- BinaryExp:loadArgs: "last =/= none" superAdj: 0 
 -- $Invocation:gen: "last" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "last" 
 -- isConstant: "Invocation" "last" 
 -- notConst: last last: ref Element 
 -- needorigin: "last" 
 -- needOrigin:E: "last"  E.ATd: "last: ref Element" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "last" 
 -- computeAdr: 1 :rec: "none"  E: "last" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "last"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "last" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "removeNext" on: 1 isValueObj: false 
 -- origin: Queue origin:isValueObj: false 
 rpushg removeNext$168 1
 -- $ObjectInvocation_Unary:getAdr: "last" >ATd.off:5:on:1:superAdj:0"last: ref Element":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F ... 
 -- $ref:getAdr: "last: ref Element" >newOff:5,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "last"  ATd: "last: ref Element" 
 -- computeAdr:isFirst: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "last" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "last" E:  "last" 
 -- INV:gen:E.loadArgs "last" 
 -- $ObjectInvocation_Unary:loadArgs: "last" >staticOff:0 "last: ref Element" superAdj:0 
 -- $ref:loadArgs: "last: ref Element" >E:"last" 
 -- $pattern:loadArgs: "Element: {   in elm: ref Object;   out res: ref Element;   id: var integer;   pred: ref Element;   succ: ref Element;   res := this(Element);   idc :=  ..."} 
 -- ptn:loadArgs:E "last" 
 -- {(ObjectInvocation_Unary; (name: "last"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "last" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "last" :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "last" >rec:"last" ATd:"ref" E:"last" E.ATd:"last" unique:"False" 
 -- OI:invoke: "last" 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:last 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:last 
 -- OI:invoke:B: "last" E: "last"  rec: "last"  useRtnV: true "last: ref Element" 
 -- OI:invoke:before:ATdx.invoke: ref last 
 -- $ref:invoke: "last: ref Element" E: "last">newOff:5 useRTNv: "True" 
 -- DI:invoke: "last: ref Element" 
 -- >Object:unique: false 
 -- load: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"last":rec:last 
 -- isCompositeValueObj: false E: "last" "last: ref Element" false 
 -- E.ATd.isValueObj: false rec: "last" 
 rpushg Queue$78 5
 -- OI:invoke:V: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"last":rec:last 
 -- 
 -- OI:invoke:X: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"last":rec:last 
 -- 
 -- OI:invoke:C: last :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 5 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"last":rec:last 
 -- $pattern:loadArgs: "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean" >E:"=/= none":descNo:117} 
 -- ptn:loadArgs:E "=/= none" 
 -- {(ObjectInvocation_Binary; (name: "=/="); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "none");     (Arguments)));   (Items descNo: ...} 
 -- args: "none" 
 -- E: "ObjectGenerator" none 
 -- E.arg: "ref" in objx: ref Object 
 -- NonVirt: "=/= none" "ObjectInvocation_Binary" ActArg:  "none" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "=/= none"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "none" >OGid:"none" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "none" 
 -- OG:before:super.gen: "none" 
 -- $Invocation:gen: "none" >useRtnV:"True"superAdj: 0 descNo: 116 
 -- INV:gen: "none" 
 -- isConstant: "Invocation" "none" 
 -- needorigin: "none" 
 -- needOrigin:E: "none"  E.ATd: "none: {   %basic 19;   none_x: var integer}" 
 -- doNeedOrigin:Ex: "none" 
 -- computeAdr:superAdj: 0 "none" 
 -- computeAdr: 1 :rec: "none"  E: "none" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "none"  
 -- $ObjectInvocation_Unary:loadOrigin: "none" >on:4 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_Unary:getAdr: "none" >ATd.off:0 (isPtn):on:4:superAdj:0"none: {   %basic 19;   none_x: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU ...} 
 -- $pattern:getAdr: "none: {   %basic 19;   none_x: var integer" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "none"  ATd: "none: {   %basic 19;   none_x: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "none" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "none" E:  "none" 
 -- INV:gen:E.loadArgs "none" 
 -- $ObjectInvocation_Unary:loadArgs: "none" >staticOff:0 "none: {   %basic 19;   none_x: var integer" superAdj:0} 
 -- $pattern:loadArgs: "none: {   %basic 19;   none_x: var integer" >E:"none":descNo:116} 
 -- ptn:loadArgs:E "none" 
 -- {(ObjectInvocation_Unary; (name: "none"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "none" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "none" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "none" >rec:"none" ATd:"pattern" E:"none" E.ATd:"none" unique:"False" 
 -- OI:invoke: "none" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- OI:invoke:B: "none" E: "none"  rec: "none"  useRtnV: true "none: {   %basic 19;   none_x: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern none 
 -- $pattern:invoke: "none: {   %basic 19;   none_x: var integer" E: "none" useRTNv: "True"} 
 -- ptn:invoke: "none" E: "none" ptnKind: 0 useRtnV: true 
 pushNone 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- 
 -- OI:invoke:C: none :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- formalArg:isPtn: "in objx: ref Object" :isBasicVal: false :valueObj: false 
 -- :actArg: "none" :isBasicVal: false 
 -- case:B: none ObjectGenerator 64 19 19 false false 
 -- end:loadArgs:NonVirt: "=/= none" 
 -- BinaryExp:loadArgs:end: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"last":rec:last 
 -- INV:gen:after:E.loadArgs "last =/= none" 
 -- OIadr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"last":rec:last 
 -- IV:E.invoke:useRtnVal: true E: BinOp "last =/= none" :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"last":rec:last 
 -- $BinOp:invoke: "last =/= none"  
 -- BinaryExp:invoke: "last" rec: "last =/= none" 
 -- M: "=/= none" :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"last":rec:last 
 -- $ObjectInvocation_Binary:invoke: "=/= none" >rec:"last" ATd:"pattern" E:"=/= none" E.ATd:"=/=  " unique:"False" 
 -- OI:invoke: "=/= none" 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"last":rec:last 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"last":rec:last 
 -- OI:invoke:B: "=/= none" E: "=/= none"  rec: "last"  useRtnV: true "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean}" 
 -- OI:invoke:before:ATdx.invoke: pattern =/=   
 -- $pattern:invoke: "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean" E: "=/= none" useRTNv: "True"} 
 -- ptn:invoke: "=/=  " E: "=/= none" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "last" E: "=/= none" 
 -- arg:other 
 rne
 -- OI:invoke:V: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"=/= none":rec:last 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"=/= none":rec:last 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: =/= none :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: "noOfElm := noOfElm - 1{   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;      last.succ := none;   :else ;      head := none;    ..."} 
 -- OG:gen: "noOfElm := noOfElm - 1{   elm := last.elm;   last := last.pred;   if (last =/= none) :then ;      last.succ := none;   :else ;      head := none;      --"removeNe ..."}" 
 pushThis 
 -- before objTmpStack:add:  169   "$169" 
 invoke $169 169 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 -- pushReturn:  "removeNext" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 169 
 -- Items:GenClass: $169 descNo: 169 isValue: false 
 -- Items:GenClass: $169 descNo: 21 isValue: false 

 CLASS $169 169 1 removeNext 168
 -- Store itemArgs: noOfElm := noOfElm - 1{elm := last.elm;last := last.pred;if (last =/= none) :then ;   last.succ := none;:else ;   head := none;   --"removeNext:".print;    ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=169 vDescInx=169 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "noOfElm := noOfElm - 1" 
 -- $Assign:gen: "noOfElm := noOfElm - 1"  
 -- assign: "noOfElm := noOfElm - 1" 
 -- computeAdr:superAdj: 0 "noOfElm" 
 -- computeAdr: 1 :rec: "none"  E: "noOfElm" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "noOfElm"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "noOfElm" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$169" on: 2 isValueObj: false 
 -- origin: removeNext origin:isValueObj: false 
 rpushg $169$169 1
 -- items:goOrigin:encOG: "removeNext" on: 1 isValueObj: false 
 -- origin: Queue origin:isValueObj: false 
 rpushg removeNext$168 1
 -- $ObjectInvocation_Unary:getAdr: "noOfElm" >ATd.off:3:on:2:superAdj:0"noOfElm: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsV ... 
 -- $var:getAdr: "noOfElm: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: integer 
 -- before:floatTest:  "noOfElm: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "noOfElm"  ATd: "noOfElm: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:- 
 -- computeAdr:isLast:E:  "noOfElm" 
 -- AssignmentStatement:gen: "noOfElm := noOfElm - 1" right.label: "ObjectGenerator" "noOfElm - 1" 
 -- $ObjectGenerator:gen: "noOfElm - 1" >OGid:"-" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "noOfElm - 1" 
 -- OG:before:super.gen: "noOfElm - 1" 
 -- $Invocation:gen: "noOfElm - 1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "noOfElm - 1" 
 -- isConstant: "Invocation" "noOfElm - 1" 
 -- needorigin: "noOfElm - 1" 
 -- needOrigin:E: "noOfElm - 1"  E.ATd: "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- doNeedOrigin:Ex: "noOfElm - 1" 
 -- computeAdr:superAdj: 0 "noOfElm - 1" 
 -- computeAdr: 1 :rec: "none"  E: "noOfElm - 1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "noOfElm - 1"  
 -- $BinOp:loadOrigin: "noOfElm - 1"  
 -- BinaryExp:loadOrigin:empty: "noOfElm - 1" superAdj: 0 
 -- $BinOp:getAdr: "noOfElm - 1"  
 -- E.on: 2 
 -- beforeIsValueObj:E: "noOfElm - 1"  ATd: "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "noOfElm - 1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "noOfElm - 1" E:  "noOfElm - 1" 
 -- INV:gen:E.loadArgs "noOfElm - 1" 
 -- $BinOp:loadArgs: "noOfElm - 1"  
 -- BinaryExp:loadArgs: "noOfElm - 1" superAdj: 0 
 -- $Invocation:gen: "noOfElm" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "noOfElm" 
 -- isConstant: "Invocation" "noOfElm" 
 -- notConst: noOfElm noOfElm: var integer 
 -- needorigin: "noOfElm" 
 -- needOrigin:E: "noOfElm"  E.ATd: "noOfElm: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "noOfElm" 
 -- computeAdr: 1 :rec: "none"  E: "noOfElm" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "noOfElm"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "noOfElm" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$169" on: 2 isValueObj: false 
 -- origin: removeNext origin:isValueObj: false 
 rpushg $169$169 1
 -- items:goOrigin:encOG: "removeNext" on: 1 isValueObj: false 
 -- origin: Queue origin:isValueObj: false 
 rpushg removeNext$168 1
 -- $ObjectInvocation_Unary:getAdr: "noOfElm" >ATd.off:3:on:2:superAdj:0"noOfElm: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsV ... 
 -- $var:getAdr: "noOfElm: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: integer 
 -- before:floatTest:  "noOfElm: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "noOfElm"  ATd: "noOfElm: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:- 
 -- computeAdr:isLast:E:  "noOfElm" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:- 
 -- rec:  "noOfElm" E:  "noOfElm" 
 -- INV:gen:E.loadArgs "noOfElm" 
 -- $ObjectInvocation_Unary:loadArgs: "noOfElm" >staticOff:0 "noOfElm: var integer" superAdj:0 
 -- $var:loadArgs: "noOfElm: var integer" >E:"noOfElm" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "noOfElm" 
 -- {(ObjectInvocation_Unary; (name: "noOfElm"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "noOfElm" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "noOfElm" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:- 
 -- $ObjectInvocation_Unary:invoke: "noOfElm" >rec:"noOfElm" ATd:"var" isValueObj E:"noOfElm" E.ATd:"noOfElm" unique:"False" 
 -- OI:invoke: "noOfElm" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:noOfElm 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:noOfElm 
 -- OI:invoke:B: "noOfElm" E: "noOfElm"  rec: "noOfElm"  useRtnV: true "noOfElm: var integer" 
 -- OI:invoke:before:ATdx.invoke: var noOfElm 
 -- $var:invoke: "noOfElm: var integer" E: "noOfElm">newOff:3 useRTNv: "True" 
 -- DI:invoke: "noOfElm: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:noOfElm 
 -- isCompositeValueObj: false E: "noOfElm" "noOfElm: var integer" true 
 -- E.ATd.isValueObj: false rec: "noOfElm" 
 pushg 3 Queue$78
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:noOfElm 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:noOfElm 
 -- 
 -- OI:invoke:C: noOfElm :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- left:#I "noOfElm - 1" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:noOfElm 
 -- $pattern:loadArgs: "-  : {   %basic 62;   in V: var integer;   out R: var integer" >E:"- 1":descNo:108} 
 -- ptn:loadArgs:E "- 1" 
 -- {(ObjectInvocation_Binary; (name: "-"); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 1));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "1" 
 -- E: "ObjectGenerator" 1 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "- 1" "ObjectInvocation_Binary" ActArg:  "1" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "- 1"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "1" :isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "- 1" 
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:noOfElm 
 -- INV:gen:after:E.loadArgs "noOfElm - 1" 
 -- OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:noOfElm 
 -- IV:E.invoke:useRtnVal: true E: BinOp "noOfElm - 1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:noOfElm 
 -- $BinOp:invoke: "noOfElm - 1"  
 -- BinaryExp:invoke: "noOfElm" rec: "noOfElm - 1" 
 -- M: "- 1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:noOfElm 
 -- $ObjectInvocation_Binary:invoke: "- 1" >rec:"noOfElm" ATd:"pattern" E:"- 1" E.ATd:"-  " unique:"False" 
 -- OI:invoke: "- 1" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:noOfElm 
 -- origin:isValueObj "integer" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:noOfElm 
 -- OI:invoke:B: "- 1" E: "- 1"  rec: "noOfElm"  useRtnV: true "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern -   
 -- $pattern:invoke: "-  : {   %basic 62;   in V: var integer;   out R: var integer" E: "- 1" useRTNv: "True"} 
 -- ptn:invoke: "-  " E: "- 1" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "noOfElm" E: "- 1" 
 -- arg:integer 
 minus
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"- 1":rec:noOfElm 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"- 1":rec:noOfElm 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: - 1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "noOfElm" dstE: "noOfElm" dstE.ATd: "noOfElm: var integer" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"no ..." 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "noOfElm - 1" 
 -- isArgOfAssignI2IwithUniValArg "noOfElm := noOfElm - 1" arg: "noOfElm - 1" ObjectGenerator 
 -- arg.super.arg: "noOfElm - 1" BinOp 
 -- recx:BinaryExp:recx: "noOfElm - 1" 
 -- M: "- 1" label: "ObjectInvocation_Binary" M.ATd: "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- checkInt2IntWithUnitArg:rec: "noOfElm" E: "- 1" 
 -- arg:integer 
 -- M:arg: "1" ObjectGenerator false 
 -- dstDI: "noOfElm: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"noOfElm":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg Queue$78 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "elm := last.elm" 
 -- $Assign:gen: "elm := last.elm"  
 -- assign: "elm := last.elm" 
 -- computeAdr:superAdj: 0 "elm" 
 -- computeAdr: 1 :rec: "none"  E: "elm" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "elm"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "elm" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$169" on: 1 isValueObj: false 
 -- origin: removeNext origin:isValueObj: false 
 rpushg $169$169 1
 -- $ObjectInvocation_Unary:getAdr: "elm" >ATd.off:2:on:1:superAdj:0"out elm: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue: ... 
 -- $ref:getAdr: "out elm: ref Object" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValu ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "elm"  ATd: "out elm: ref Object" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "elm" 
 -- AssignmentStatement:gen: "elm := last.elm" right.label: "ObjectGenerator" "last.elm" 
 -- $ObjectGenerator:gen: "last.elm" >OGid:"Object" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "last.elm" 
 -- OG:before:super.gen: "last.elm" 
 -- $Invocation:gen: "last.elm" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "last.elm" 
 -- isConstant: "Invocation" "last.elm" 
 -- notConst: last last: ref Element 
 -- needorigin: "last.elm" 
 -- needOrigin:E: "elm"  E.ATd: "in elm: ref Object" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "last.elm" 
 -- computeAdr: 1 :rec: "none"  E: "last" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "last"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "last" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$169" on: 2 isValueObj: false 
 -- origin: removeNext origin:isValueObj: false 
 rpushg $169$169 1
 -- items:goOrigin:encOG: "removeNext" on: 1 isValueObj: false 
 -- origin: Queue origin:isValueObj: false 
 rpushg removeNext$168 1
 -- $ObjectInvocation_Unary:getAdr: "last" >ATd.off:5:on:2:superAdj:0"last: ref Element":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F ... 
 -- $ref:getAdr: "last: ref Element" >newOff:5,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- E.on: 2 
 -- beforeIsValueObj:E: "last"  ATd: "last: ref Element" 
 -- computeAdr:isFirst: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "last"  E: "elm" 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "elm" >ATd.off:2:on:0:superAdj:0"in elm: ref Object":Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F ... 
 -- $ref:getAdr: "in elm: ref Object" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue ... 
 -- $ObjectInvocation_Unary:loadArgs: "last" >staticOff:0 "last: ref Element" superAdj:0 
 -- $ref:loadArgs: "last: ref Element" >E:"last" 
 -- $pattern:loadArgs: "Element: {   in elm: ref Object;   out res: ref Element;   id: var integer;   pred: ref Element;   succ: ref Element;   res := this(Element);   idc :=  ..."} 
 -- ptn:loadArgs:E "last" 
 -- {(ObjectInvocation_Unary; (name: "last"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "last" >rec:"last" ATd:"ref" E:"elm" E.ATd:"elm" unique:"False" 
 -- OI:invoke: "last" 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"elm":rec:last 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"elm":rec:last 
 -- OI:invoke:B: "last" E: "elm"  rec: "last"  useRtnV: true "last: ref Element" 
 -- OI:invoke:before:ATdx.invoke: ref last 
 -- $ref:invoke: "last: ref Element" E: "elm">newOff:5 useRTNv: "True" 
 -- DI:invoke: "last: ref Element" 
 -- >Object:unique: false 
 -- load: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"elm":rec:last 
 -- isCompositeValueObj: false E: "elm" "in elm: ref Object" false 
 -- E.ATd.isValueObj: false rec: "last" 
 rpushg $169$169 5
 -- OI:invoke:V: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"elm":rec:last 
 -- 
 -- OI:invoke:X: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"elm":rec:last 
 -- 
 -- OI:invoke:C: last :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "last" E: "elm" 
 -- computeAdr:isLast:E:  "elm" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "last" E:  "elm" 
 -- INV:gen:E.loadArgs "elm" 
 -- $ObjectInvocation_Unary:loadArgs: "elm" >staticOff:0 "in elm: ref Object" superAdj:0 
 -- $ref:loadArgs: "in elm: ref Object" >E:"elm" 
 -- $pattern:loadArgs: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic 57; ..."} 
 -- ptn:loadArgs:E "elm" 
 -- {(ObjectInvocation_Unary; (name: "elm"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "elm" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "elm" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "elm" >rec:"last" ATd:"ref" E:"elm" E.ATd:"elm" unique:"False" 
 -- OI:invoke: "elm" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:last 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:last 
 -- OI:invoke:B: "elm" E: "elm"  rec: "last"  useRtnV: true "in elm: ref Object" 
 -- OI:invoke:before:ATdx.invoke: ref elm 
 -- $ref:invoke: "in elm: ref Object" E: "elm">newOff:2 useRTNv: "True" 
 -- DI:invoke: "in elm: ref Object" 
 -- >Object:unique: false 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"elm":rec:last 
 -- isCompositeValueObj: false E: "elm" "in elm: ref Object" false 
 -- E.ATd.isValueObj: false rec: "last" 
 rpushg $169$169 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"elm":rec:last 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"elm":rec:last 
 -- 
 -- OI:invoke:C: elm :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"elm":rec:last 
 -- rec: "elm" dstE: "elm" dstE.ATd: "out elm: ref Object" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- ... 
 -- dstDI.isBasicVal: false dstDI.isValObj: false dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- isValue: false  isAdr: true  descNo:  0 
 rswap 0
 rstoreg  EisNone 2
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -3 rTopMax: 0 V: 0 R: 
   ;; vTop(1,1)=[0/0] rTop(-3,0)=[]
 -- assign:adr.store:B: 
 -- genclass:stmt: "last := last.pred" 
 -- $Assign:gen: "last := last.pred"  
 -- assign: "last := last.pred" 
 -- computeAdr:superAdj: 0 "last" 
 -- computeAdr: 1 :rec: "none"  E: "last" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "last"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "last" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$169" on: 2 isValueObj: false 
 -- origin: removeNext origin:isValueObj: false 
 rpushg $169$169 1
 -- items:goOrigin:encOG: "removeNext" on: 1 isValueObj: false 
 -- origin: Queue origin:isValueObj: false 
 rpushg removeNext$168 1
 -- $ObjectInvocation_Unary:getAdr: "last" >ATd.off:5:on:2:superAdj:0"last: ref Element":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F ... 
 -- $ref:getAdr: "last: ref Element" >newOff:5,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- E.on: 2 
 -- beforeIsValueObj:E: "last"  ATd: "last: ref Element" 
 -- computeAdr:isFirst: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "last" 
 -- AssignmentStatement:gen: "last := last.pred" right.label: "ObjectGenerator" "last.pred" 
 -- $ObjectGenerator:gen: "last.pred" >OGid:"Element" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "last.pred" 
 -- OG:before:super.gen: "last.pred" 
 -- $Invocation:gen: "last.pred" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "last.pred" 
 -- isConstant: "Invocation" "last.pred" 
 -- notConst: last last: ref Element 
 -- needorigin: "last.pred" 
 -- needOrigin:E: "pred"  E.ATd: "pred: ref Element" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "last.pred" 
 -- computeAdr: 1 :rec: "none"  E: "last" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "last"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "last" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$169" on: 2 isValueObj: false 
 -- origin: removeNext origin:isValueObj: false 
 rpushg $169$169 1
 -- items:goOrigin:encOG: "removeNext" on: 1 isValueObj: false 
 -- origin: Queue origin:isValueObj: false 
 rpushg removeNext$168 1
 -- $ObjectInvocation_Unary:getAdr: "last" >ATd.off:5:on:2:superAdj:0"last: ref Element":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F ... 
 -- $ref:getAdr: "last: ref Element" >newOff:5,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- E.on: 2 
 -- beforeIsValueObj:E: "last"  ATd: "last: ref Element" 
 -- computeAdr:isFirst: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "last"  E: "pred" 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "pred" >ATd.off:5:on:0:superAdj:0"pred: ref Element":Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F ... 
 -- $ref:getAdr: "pred: ref Element" >newOff:5,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- $ObjectInvocation_Unary:loadArgs: "last" >staticOff:0 "last: ref Element" superAdj:0 
 -- $ref:loadArgs: "last: ref Element" >E:"last" 
 -- $pattern:loadArgs: "Element: {   in elm: ref Object;   out res: ref Element;   id: var integer;   pred: ref Element;   succ: ref Element;   res := this(Element);   idc :=  ..."} 
 -- ptn:loadArgs:E "last" 
 -- {(ObjectInvocation_Unary; (name: "last"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "last" >rec:"last" ATd:"ref" E:"pred" E.ATd:"pred" unique:"False" 
 -- OI:invoke: "last" 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"pred":rec:last 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"pred":rec:last 
 -- OI:invoke:B: "last" E: "pred"  rec: "last"  useRtnV: true "last: ref Element" 
 -- OI:invoke:before:ATdx.invoke: ref last 
 -- $ref:invoke: "last: ref Element" E: "pred">newOff:5 useRTNv: "True" 
 -- DI:invoke: "last: ref Element" 
 -- >Object:unique: false 
 -- load: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"pred":rec:last 
 -- isCompositeValueObj: false E: "pred" "pred: ref Element" false 
 -- E.ATd.isValueObj: false rec: "last" 
 rpushg $169$169 5
 -- OI:invoke:V: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"pred":rec:last 
 -- 
 -- OI:invoke:X: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"pred":rec:last 
 -- 
 -- OI:invoke:C: last :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "last" E: "pred" 
 -- computeAdr:isLast:E:  "pred" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "last" E:  "pred" 
 -- INV:gen:E.loadArgs "pred" 
 -- $ObjectInvocation_Unary:loadArgs: "pred" >staticOff:0 "pred: ref Element" superAdj:0 
 -- $ref:loadArgs: "pred: ref Element" >E:"pred" 
 -- $pattern:loadArgs: "Element: {   in elm: ref Object;   out res: ref Element;   id: var integer;   pred: ref Element;   succ: ref Element;   res := this(Element);   idc :=  ..."} 
 -- ptn:loadArgs:E "pred" 
 -- {(ObjectInvocation_Unary; (name: "pred"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "pred" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "pred" :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "pred" >rec:"last" ATd:"ref" E:"pred" E.ATd:"pred" unique:"False" 
 -- OI:invoke: "pred" 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:last 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:last 
 -- OI:invoke:B: "pred" E: "pred"  rec: "last"  useRtnV: true "pred: ref Element" 
 -- OI:invoke:before:ATdx.invoke: ref pred 
 -- $ref:invoke: "pred: ref Element" E: "pred">newOff:5 useRTNv: "True" 
 -- DI:invoke: "pred: ref Element" 
 -- >Object:unique: false 
 -- load: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"pred":rec:last 
 -- isCompositeValueObj: false E: "pred" "pred: ref Element" false 
 -- E.ATd.isValueObj: false rec: "last" 
 rpushg $169$169 5
 -- OI:invoke:V: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"pred":rec:last 
 -- 
 -- OI:invoke:X: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"pred":rec:last 
 -- 
 -- OI:invoke:C: pred :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 5 
 -- OG:gen:end: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"pred":rec:last 
 -- rec: "last" dstE: "last" dstE.ATd: "last: ref Element" useRtn: false :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- ... 
 -- dstDI.isBasicVal: false dstDI.isValObj: false dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- assign:adr.store:A: 
 -- store: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- isValue: false  isAdr: true  descNo:  0 
 rswap 0
 rstoreg  EisNone 5
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -5 rTopMax: 0 V: 0 R: 
   ;; vTop(1,1)=[0/0] rTop(-5,0)=[]
 -- assign:adr.store:B: 
 -- genclass:stmt: "if (last =/= none) :then {   last.succ := none;:else ;   head := none;   --"removeNext:".print;   --idf.print;   --putint(noOfElm);   --newline	 }" 
 -- $ObjectGenerator:gen: "if (last =/= none) :then {   last.succ := none;:else ;   head := none;   --"removeNext:".print;   --idf.print;   --putint(noOfElm);   --newline	 " > ...} 
 -- OG:gen: "if (last =/= none) :then {   last.succ := none;:else ;   head := none;   --"removeNext:".print;   --idf.print;   --putint(noOfElm);   --newline	 }" 
 -- OG:before:super.gen: "if (last =/= none) :then {   last.succ := none;:else ;   head := none;   --"removeNext:".print;   --idf.print;   --putint(noOfElm);   --newline	 }" 
 -- $Invocation:gen: "if (last =/= none) :then {   last.succ := none;:else ;   head := none;   --"removeNext:".print;   --idf.print;   --putint(noOfElm);   --newline	 " >useRt ...} 
 -- INV:gen: "if (last =/= none) :then {   last.succ := none;:else ;   head := none;   --"removeNext:".print;   --idf.print;   --putint(noOfElm);   --newline	 }" 
 -- isConstant: "Invocation" "if (last =/= none) :then {   last.succ := none;:else ;   head := none;   --"removeNext:".print;   --idf.print;   --putint(noOfElm);   --newline	  ...}" 
 -- needorigin: "if (last =/= none) :then {   last.succ := none;:else ;   head := none;   --"removeNext:".print;   --idf.print;   --putint(noOfElm);   --newline	 }" 
 -- needOrigin:E: "if (last =/= none) :then {   last.succ := none;:else ;   head := none;   --"removeNext:".print;   --idf.print;   --putint(noOfElm);   --newline	 }"  E.ATd: "i ..." 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (last =/= none) :then {   last.succ := none;:else ;   head := none;   --"removeNext:".print;   --idf.print;   --putint(noOfElm);   --newline	 }" E:  "if (last =/ ..." 
 -- INV:gen:E.loadArgs "if (last =/= none) :then {   last.succ := none;:else ;   head := none;   --"removeNext:".print;   --idf.print;   --putint(noOfElm);   --newline	 }" 
 -- $IfThenElse:loadArgs: "if (last =/= none) :then {   last.succ := none;:else ;   head := none;   --"removeNext:".print;   --idf.print;   --putint(noOfElm);   --newline	 " } 
 -- INV:gen:after:E.loadArgs "if (last =/= none) :then {   last.succ := none;:else ;   head := none;   --"removeNext:".print;   --idf.print;   --putint(noOfElm);   --newline	  ...}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThenElse "if (last =/= none) :then {   last.succ := none;:else ;   head := none;   --"removeNext:".print;   --idf.print;   --putint(noOfE ...}" 
 -- $IfThenElse:invoke: "if (last =/= none) :then {   last.succ := none;:else ;   head := none;   --"removeNext:".print;   --idf.print;   --putint(noOfElm);   --newline	 " } 
 -- $IfThenElse:gen: "if (last =/= none) :then {   last.succ := none;:else ;   head := none;   --"removeNext:".print;   --idf.print;   --putint(noOfElm);   --newline	 " } 
 -- $ObjectGenerator:gen: "(last =/= none)" >OGid:"=/=" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(last =/= none)" 
 -- OG:before:super.gen: "(last =/= none)" 
 -- $Invocation:gen: "(last =/= none)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(last =/= none)" 
 -- isConstant: "Invocation" "(last =/= none)" 
 -- needorigin: "(last =/= none)" 
 -- needOrigin:E: "(last =/= none)"  E.ATd: "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean}" 
 -- doNeedOrigin:Ex: "(last =/= none)" 
 -- computeAdr:superAdj: 0 "(last =/= none)" 
 -- computeAdr: 1 :rec: "none"  E: "(last =/= none)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(last =/= none)"  
 -- $BracketedExp:loadOrigin: "(last =/= none)"  
 -- computeAdr:superAdj: 0 "last =/= none" 
 -- computeAdr: 1 :rec: "none"  E: "last =/= none" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "last =/= none"  
 -- $BinOp:loadOrigin: "last =/= none"  
 -- BinaryExp:loadOrigin:empty: "last =/= none" superAdj: 0 
 -- $BinOp:getAdr: "last =/= none"  
 -- E.on: 2 
 -- beforeIsValueObj:E: "last =/= none"  ATd: "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "last =/= none" 
 -- BE:loadOrigin:E: last =/= none 
 -- $BinOp:getAdr: "last =/= none"  
 -- E.on: 2 
 -- beforeIsValueObj:E: "last =/= none"  ATd: "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "last =/= none" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "last =/= none" E:  "last =/= none" 
 -- INV:gen:E.loadArgs "last =/= none" 
 -- $BinOp:loadArgs: "last =/= none"  
 -- BinaryExp:loadArgs: "last =/= none" superAdj: 0 
 -- $Invocation:gen: "last" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "last" 
 -- isConstant: "Invocation" "last" 
 -- notConst: last last: ref Element 
 -- needorigin: "last" 
 -- needOrigin:E: "last"  E.ATd: "last: ref Element" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "last" 
 -- computeAdr: 1 :rec: "none"  E: "last" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "last"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "last" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$169" on: 2 isValueObj: false 
 -- origin: removeNext origin:isValueObj: false 
 rpushg $169$169 1
 -- items:goOrigin:encOG: "removeNext" on: 1 isValueObj: false 
 -- origin: Queue origin:isValueObj: false 
 rpushg removeNext$168 1
 -- $ObjectInvocation_Unary:getAdr: "last" >ATd.off:5:on:2:superAdj:0"last: ref Element":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F ... 
 -- $ref:getAdr: "last: ref Element" >newOff:5,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- E.on: 2 
 -- beforeIsValueObj:E: "last"  ATd: "last: ref Element" 
 -- computeAdr:isFirst: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "last" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "last" E:  "last" 
 -- INV:gen:E.loadArgs "last" 
 -- $ObjectInvocation_Unary:loadArgs: "last" >staticOff:0 "last: ref Element" superAdj:0 
 -- $ref:loadArgs: "last: ref Element" >E:"last" 
 -- $pattern:loadArgs: "Element: {   in elm: ref Object;   out res: ref Element;   id: var integer;   pred: ref Element;   succ: ref Element;   res := this(Element);   idc :=  ..."} 
 -- ptn:loadArgs:E "last" 
 -- {(ObjectInvocation_Unary; (name: "last"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "last" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "last" :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "last" >rec:"last" ATd:"ref" E:"last" E.ATd:"last" unique:"False" 
 -- OI:invoke: "last" 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:last 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:last 
 -- OI:invoke:B: "last" E: "last"  rec: "last"  useRtnV: true "last: ref Element" 
 -- OI:invoke:before:ATdx.invoke: ref last 
 -- $ref:invoke: "last: ref Element" E: "last">newOff:5 useRTNv: "True" 
 -- DI:invoke: "last: ref Element" 
 -- >Object:unique: false 
 -- load: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"last":rec:last 
 -- isCompositeValueObj: false E: "last" "last: ref Element" false 
 -- E.ATd.isValueObj: false rec: "last" 
 rpushg Queue$78 5
 -- OI:invoke:V: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"last":rec:last 
 -- 
 -- OI:invoke:X: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"last":rec:last 
 -- 
 -- OI:invoke:C: last :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 5 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"last":rec:last 
 -- $pattern:loadArgs: "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean" >E:"=/= none":descNo:117} 
 -- ptn:loadArgs:E "=/= none" 
 -- {(ObjectInvocation_Binary; (name: "=/="); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "none");     (Arguments)));   (Items descNo: ...} 
 -- args: "none" 
 -- E: "ObjectGenerator" none 
 -- E.arg: "ref" in objx: ref Object 
 -- NonVirt: "=/= none" "ObjectInvocation_Binary" ActArg:  "none" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "=/= none"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "none" >OGid:"none" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "none" 
 -- OG:before:super.gen: "none" 
 -- $Invocation:gen: "none" >useRtnV:"True"superAdj: 0 descNo: 116 
 -- INV:gen: "none" 
 -- isConstant: "Invocation" "none" 
 -- needorigin: "none" 
 -- needOrigin:E: "none"  E.ATd: "none: {   %basic 19;   none_x: var integer}" 
 -- doNeedOrigin:Ex: "none" 
 -- computeAdr:superAdj: 0 "none" 
 -- computeAdr: 1 :rec: "none"  E: "none" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "none"  
 -- $ObjectInvocation_Unary:loadOrigin: "none" >on:5 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_Unary:getAdr: "none" >ATd.off:0 (isPtn):on:5:superAdj:0"none: {   %basic 19;   none_x: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU ...} 
 -- $pattern:getAdr: "none: {   %basic 19;   none_x: var integer" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- E.on: 5 
 -- beforeIsValueObj:E: "none"  ATd: "none: {   %basic 19;   none_x: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "none" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "none" E:  "none" 
 -- INV:gen:E.loadArgs "none" 
 -- $ObjectInvocation_Unary:loadArgs: "none" >staticOff:0 "none: {   %basic 19;   none_x: var integer" superAdj:0} 
 -- $pattern:loadArgs: "none: {   %basic 19;   none_x: var integer" >E:"none":descNo:116} 
 -- ptn:loadArgs:E "none" 
 -- {(ObjectInvocation_Unary; (name: "none"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "none" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "none" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "none" >rec:"none" ATd:"pattern" E:"none" E.ATd:"none" unique:"False" 
 -- OI:invoke: "none" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- OI:invoke:B: "none" E: "none"  rec: "none"  useRtnV: true "none: {   %basic 19;   none_x: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern none 
 -- $pattern:invoke: "none: {   %basic 19;   none_x: var integer" E: "none" useRTNv: "True"} 
 -- ptn:invoke: "none" E: "none" ptnKind: 0 useRtnV: true 
 pushNone 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- 
 -- OI:invoke:C: none :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- formalArg:isPtn: "in objx: ref Object" :isBasicVal: false :valueObj: false 
 -- :actArg: "none" :isBasicVal: false 
 -- case:B: none ObjectGenerator 64 19 19 false false 
 -- end:loadArgs:NonVirt: "=/= none" 
 -- BinaryExp:loadArgs:end: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"last":rec:last 
 -- INV:gen:after:E.loadArgs "last =/= none" 
 -- OIadr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"last":rec:last 
 -- IV:E.invoke:useRtnVal: true E: BinOp "last =/= none" :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"last":rec:last 
 -- $BinOp:invoke: "last =/= none"  
 -- BinaryExp:invoke: "last" rec: "last =/= none" 
 -- M: "=/= none" :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"last":rec:last 
 -- $ObjectInvocation_Binary:invoke: "=/= none" >rec:"last" ATd:"pattern" E:"=/= none" E.ATd:"=/=  " unique:"False" 
 -- OI:invoke: "=/= none" 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"last":rec:last 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"last":rec:last 
 -- OI:invoke:B: "=/= none" E: "=/= none"  rec: "last"  useRtnV: true "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean}" 
 -- OI:invoke:before:ATdx.invoke: pattern =/=   
 -- $pattern:invoke: "=/=  : {   %basic 57;   in objx: ref Object;   out V: var boolean" E: "=/= none" useRTNv: "True"} 
 -- ptn:invoke: "=/=  " E: "=/= none" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "last" E: "=/= none" 
 -- arg:other 
 rne
 -- OI:invoke:V: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"=/= none":rec:last 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"=/= none":rec:last 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: =/= none :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: "last.succ := none" >OGid:"$170" singular! staticOff=0 descNo=170 superAdj=0 
 -- OG:gen: "last.succ := none" 
 pushThis 
 -- before objTmpStack:add:  170   "$170" 
 invoke $170 170 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -5 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L5
 L4:
 -- $ObjectGenerator:gen: "head := none{   --"removeNext:".print;   --idf.print;   --putint(noOfElm);   --newline	 " >OGid:"$171" singular! staticOff=0 descNo=171 superAdj=0} 
 -- OG:gen: "head := none{   --"removeNext:".print;   --idf.print;   --putint(noOfElm);   --newline	 }" 
 pushThis 
 -- before objTmpStack:add:  171   "$171" 
 invoke $171 171 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -6 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L5:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 170 
 -- Items:GenClass: $170 descNo: 170 isValue: false 
 -- Items:GenClass: $170 descNo: 21 isValue: false 

 CLASS $170 170 1 $169 169
 -- Store itemArgs: last.succ := none 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=170 vDescInx=170 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "last.succ := none" 
 -- $Assign:gen: "last.succ := none"  
 -- assign: "last.succ := none" 
 -- computeAdr:superAdj: 0 "last.succ" 
 -- computeAdr: 1 :rec: "none"  E: "last" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "last"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "last" >on:3 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$170" on: 3 isValueObj: false 
 -- origin: $169 origin:isValueObj: false 
 rpushg $170$170 1
 -- items:goOrigin:encOG: "$169" on: 2 isValueObj: false 
 -- origin: removeNext origin:isValueObj: false 
 rpushg $169$169 1
 -- items:goOrigin:encOG: "removeNext" on: 1 isValueObj: false 
 -- origin: Queue origin:isValueObj: false 
 rpushg removeNext$168 1
 -- $ObjectInvocation_Unary:getAdr: "last" >ATd.off:5:on:3:superAdj:0"last: ref Element":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F ... 
 -- $ref:getAdr: "last: ref Element" >newOff:5,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- E.on: 3 
 -- beforeIsValueObj:E: "last"  ATd: "last: ref Element" 
 -- computeAdr:isFirst: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "last"  E: "succ" 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "succ" >ATd.off:6:on:0:superAdj:0"succ: ref Element":Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F ... 
 -- $ref:getAdr: "succ: ref Element" >newOff:6,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- $ObjectInvocation_Unary:loadArgs: "last" >staticOff:0 "last: ref Element" superAdj:0 
 -- $ref:loadArgs: "last: ref Element" >E:"last" 
 -- $pattern:loadArgs: "Element: {   in elm: ref Object;   out res: ref Element;   id: var integer;   pred: ref Element;   succ: ref Element;   res := this(Element);   idc :=  ..."} 
 -- ptn:loadArgs:E "last" 
 -- {(ObjectInvocation_Unary; (name: "last"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "last" >rec:"last" ATd:"ref" E:"succ" E.ATd:"succ" unique:"False" 
 -- OI:invoke: "last" 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"succ":rec:last 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"succ":rec:last 
 -- OI:invoke:B: "last" E: "succ"  rec: "last"  useRtnV: true "last: ref Element" 
 -- OI:invoke:before:ATdx.invoke: ref last 
 -- $ref:invoke: "last: ref Element" E: "succ">newOff:5 useRTNv: "True" 
 -- DI:invoke: "last: ref Element" 
 -- >Object:unique: false 
 -- load: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"succ":rec:last 
 -- isCompositeValueObj: false E: "succ" "succ: ref Element" false 
 -- E.ATd.isValueObj: false rec: "last" 
 rpushg $170$170 5
 -- OI:invoke:V: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"succ":rec:last 
 -- 
 -- OI:invoke:X: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"succ":rec:last 
 -- 
 -- OI:invoke:C: last :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "last" E: "succ" 
 -- computeAdr:isLast:E:  "succ" 
 -- AssignmentStatement:gen: "last.succ := none" right.label: "ObjectGenerator" "none" 
 -- $ObjectGenerator:gen: "none" >OGid:"none" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "none" 
 -- OG:before:super.gen: "none" 
 -- $Invocation:gen: "none" >useRtnV:"True"superAdj: 0 descNo: 116 
 -- INV:gen: "none" 
 -- isConstant: "Invocation" "none" 
 -- needorigin: "none" 
 -- needOrigin:E: "none"  E.ATd: "none: {   %basic 19;   none_x: var integer}" 
 -- doNeedOrigin:Ex: "none" 
 -- computeAdr:superAdj: 0 "none" 
 -- computeAdr: 1 :rec: "none"  E: "none" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "none"  
 -- $ObjectInvocation_Unary:loadOrigin: "none" >on:6 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_Unary:getAdr: "none" >ATd.off:0 (isPtn):on:6:superAdj:0"none: {   %basic 19;   none_x: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU ...} 
 -- $pattern:getAdr: "none: {   %basic 19;   none_x: var integer" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- E.on: 6 
 -- beforeIsValueObj:E: "none"  ATd: "none: {   %basic 19;   none_x: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "none" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "none" E:  "none" 
 -- INV:gen:E.loadArgs "none" 
 -- $ObjectInvocation_Unary:loadArgs: "none" >staticOff:0 "none: {   %basic 19;   none_x: var integer" superAdj:0} 
 -- $pattern:loadArgs: "none: {   %basic 19;   none_x: var integer" >E:"none":descNo:116} 
 -- ptn:loadArgs:E "none" 
 -- {(ObjectInvocation_Unary; (name: "none"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "none" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "none" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "none" >rec:"none" ATd:"pattern" E:"none" E.ATd:"none" unique:"False" 
 -- OI:invoke: "none" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- OI:invoke:B: "none" E: "none"  rec: "none"  useRtnV: true "none: {   %basic 19;   none_x: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern none 
 -- $pattern:invoke: "none: {   %basic 19;   none_x: var integer" E: "none" useRTNv: "True"} 
 -- ptn:invoke: "none" E: "none" ptnKind: 0 useRtnV: true 
 pushNone 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- 
 -- OI:invoke:C: none :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- rec: "last" dstE: "succ" dstE.ATd: "succ: ref Element" useRtn: false :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- ... 
 -- dstDI.isBasicVal: false dstDI.isValObj: false dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- assign:adr.store:A: 
 -- store: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- isValue: false  isAdr: true  descNo:  0 
 rswap 0
 rstoreg  EisNone 6
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 1 V: R: 
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 171 
 -- Items:GenClass: $171 descNo: 171 isValue: false 
 -- Items:GenClass: $171 descNo: 21 isValue: false 

 CLASS $171 171 1 $169 169
 -- Store itemArgs: head := none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 } 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=171 vDescInx=171 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "head := none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- $Assign:gen: "head := none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 " } 
 -- assign: "head := none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- computeAdr:superAdj: 0 "head" 
 -- computeAdr: 1 :rec: "none"  E: "head" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "head"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "head" >on:3 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$171" on: 3 isValueObj: false 
 -- origin: $169 origin:isValueObj: false 
 rpushg $171$171 1
 -- items:goOrigin:encOG: "$169" on: 2 isValueObj: false 
 -- origin: removeNext origin:isValueObj: false 
 rpushg $169$169 1
 -- items:goOrigin:encOG: "removeNext" on: 1 isValueObj: false 
 -- origin: Queue origin:isValueObj: false 
 rpushg removeNext$168 1
 -- $ObjectInvocation_Unary:getAdr: "head" >ATd.off:4:on:3:superAdj:0"head: ref Element":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F ... 
 -- $ref:getAdr: "head: ref Element" >newOff:4,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- E.on: 3 
 -- beforeIsValueObj:E: "head"  ATd: "head: ref Element" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "head" 
 -- AssignmentStatement:gen: "head := none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 }" right.label: "ObjectGenerator" "none{--"removeNext:".print;--idf.p ...}" 
 -- $ObjectGenerator:gen: "none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 " >OGid:"none" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- OG:before:super.gen: "none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- $Invocation:gen: "none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 " >useRtnV:"True"superAdj: 0 descNo: 116} 
 -- INV:gen: "none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- isConstant: "Invocation" "none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- needorigin: "none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- needOrigin:E: "none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 }"  E.ATd: "none: {   %basic 19;   none_x: var integer}" 
 -- doNeedOrigin:Ex: "none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- computeAdr:superAdj: 0 "none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- computeAdr: 1 :rec: "none"  E: "none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 " } 
 -- $ObjectInvocation_Unary:loadOrigin: "none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 " >on:6 superAdj:0 isValueObj:"False"} 
 -- $ObjectInvocation_Unary:getAdr: "none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 " >ATd.off:0 (isPtn):on:6:superAdj:0"none: ;   %basic 19;   none_x: va ..."} 
 -- $pattern:getAdr: "none: {   %basic 19;   none_x: var integer" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 ":rec:-} 
 -- E.on: 6 
 -- beforeIsValueObj:E: "none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 }"  ATd: "none: {   %basic 19;   none_x: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none{--"removeNext:".print;--idf.print;--putint(noOfElm);--n ..."} 
 -- computeAdr:isLast:E:  "none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none{--"removeNext:".print;--idf.print;--putint( ..."} 
 -- rec:  "none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 }" E:  "none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- INV:gen:E.loadArgs "none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- $ObjectInvocation_Unary:loadArgs: "none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 " >staticOff:0 "none: ;   %basic 19;   none_x: var integer" superAdj ...} 
 -- $pattern:loadArgs: "none: {   %basic 19;   none_x: var integer" >E:"none;--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 ":descNo:116} 
 -- ptn:loadArgs:E "none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- {(ObjectInvocation_Unary; (name: "none"); (Arguments --<12>"removeNext:".print;<12>idf.print;<12>putint(noOfElm);<12>newline	 ))} 
 -- args: "--"removeNext:".print{--idf.print;--putint(noOfElm);--newline	 }" 
 -- INV:gen:after:E.loadArgs "none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 }" :Adr:off:0 size:0 isFloat:F isUnitVal:F super ... 
 -- $ObjectInvocation_Unary:invoke: "none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 " >rec:"none;--"removeNext:".print;--idf.print;--putint(noOfElm);--new ..."} 
 -- OI:invoke: "none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 }" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 ":rec:none;- ...} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 ":rec:none;- ...} 
 -- OI:invoke:B: "none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 }" E: "none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 }"  rec: "none ..."   ... true "n ..." 
 -- OI:invoke:before:ATdx.invoke: pattern none 
 -- $pattern:invoke: "none: {   %basic 19;   none_x: var integer" E: "none;--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 " useRTNv: "True"} 
 -- ptn:invoke: "none" E: "none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 }" ptnKind: 0 useRtnV: true 
 pushNone 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none{--"removeNext:".print;--idf.print;--putint(noOfElm);--new ..."} 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none{--"removeNext:".print;--idf.print;--putint(noOfElm);--new ..."} 
 -- 
 -- OI:invoke:C: none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	 } :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none{--"removeNext:".print;--idf.print;--putint(noOfElm);--newline	  ..."} 
 -- rec: "head" dstE: "head" dstE.ATd: "head: ref Element" useRtn: false :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- ... 
 -- dstDI.isBasicVal: false dstDI.isValObj: false dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- assign:adr.store:A: 
 -- store: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- isValue: false  isAdr: true  descNo:  0 
 rswap 0
 rstoreg  EisNone 4
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 1 V: R: 
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 172 
 -- Items:GenClass: $172 descNo: 172 isValue: false 
 -- Items:GenClass: $172 descNo: 21 isValue: false 

 CLASS $172 172 1 loop 165
 -- Store itemArgs: active.status := P_status.ACTIVE{inScheduler := 0;active.attach(50);inScheduler := 1;if (active.status = P_status.ACTIVE) :then ;   SQS.insert(active)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=172 vDescInx=172 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "active.status := P_status.ACTIVE" 
 -- $Assign:gen: "active.status := P_status.ACTIVE"  
 -- assign: "active.status := P_status.ACTIVE" 
 -- computeAdr:superAdj: 0 "active.status" 
 -- computeAdr: 1 :rec: "none"  E: "active" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "active"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "active" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$172" on: 2 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg $172$172 1
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: Scheduler origin:isValueObj: false 
 rpushg loop$165 1
 -- $ObjectInvocation_Unary:getAdr: "active" >ATd.off:2:on:2:superAdj:0"active: ref ProcessType":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- $ref:getAdr: "active: ref ProcessType" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F is ... 
 -- E.on: 2 
 -- beforeIsValueObj:E: "active"  ATd: "active: ref ProcessType" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "active"  E: "status" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "status" >ATd.off:3:on:0:superAdj:0"status: var integer":Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVal ... 
 -- $var:getAdr: "status: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F  ... 
 -- DI:OG: integer 
 -- before:floatTest:  "status: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"status":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"status":rec:- 
 -- $ObjectInvocation_Unary:loadArgs: "active" >staticOff:0 "active: ref ProcessType" superAdj:0 
 -- $ref:loadArgs: "active: ref ProcessType" >E:"active" 
 -- $pattern:loadArgs: "ProcessType:< GeneralProcess" >E:"active":descNo:0 
 -- ptn:loadArgs:E "active" 
 -- {(ObjectInvocation_Unary; (name: "active"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "active" >rec:"active" ATd:"ref" E:"status" E.ATd:"status" unique:"False" 
 -- OI:invoke: "active" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"status":rec:active 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"status":rec:active 
 -- OI:invoke:B: "active" E: "status"  rec: "active"  useRtnV: true "active: ref ProcessType" 
 -- OI:invoke:before:ATdx.invoke: ref active 
 -- $ref:invoke: "active: ref ProcessType" E: "status">newOff:2 useRTNv: "True" 
 -- DI:invoke: "active: ref ProcessType" 
 -- >Object:unique: false 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"status":rec:active 
 -- isCompositeValueObj: false E: "status" "status: var integer" true 
 -- E.ATd.isValueObj: false rec: "active" 
 rpushg $172$172 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"status":rec:active 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"status":rec:active 
 -- 
 -- OI:invoke:C: active :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "active" E: "status" 
 -- computeAdr:isLast:E:  "status" 
 -- AssignmentStatement:gen: "active.status := P_status.ACTIVE" right.label: "ObjectGenerator" "P_status.ACTIVE" 
 -- $ObjectGenerator:gen: "P_status.ACTIVE" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "P_status.ACTIVE" 
 -- OG:before:super.gen: "P_status.ACTIVE" 
 -- $Invocation:gen: "P_status.ACTIVE" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "P_status.ACTIVE" 
 -- isConstant: "Invocation" "P_status.ACTIVE" 
 -- const literal:  1   ConstLiteral 
 pushc 1
 -- OG:gen:end: 
 -- rec: "active" dstE: "status" dstE.ATd: "status: var integer" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"statu ..." 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "P_status.ACTIVE" 
 -- isArgOfAssignI2IwithUniValArg "active.status := P_status.ACTIVE" arg: "P_status.ACTIVE" ObjectGenerator 
 -- arg.super.arg: "P_status" ObjectInvocation_Unary 
 -- arg.super.arg: "ACTIVE" ObjectInvocation_Unary 
 -- recx: "P_status" argx: "ACTIVE" 
 -- checkInt2IntWithUnitArg:rec: "P_status" E: "ACTIVE" 
 -- dstDI: "status: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"status":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg $172$172 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "inScheduler := 0" 
 -- $Assign:gen: "inScheduler := 0"  
 -- assign: "inScheduler := 0" 
 -- computeAdr:superAdj: 0 "inScheduler" 
 -- computeAdr: 1 :rec: "none"  E: "inScheduler" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inScheduler"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inScheduler" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$172" on: 2 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg $172$172 1
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: Scheduler origin:isValueObj: false 
 rpushg loop$165 1
 -- $ObjectInvocation_Unary:getAdr: "inScheduler" >ATd.off:5:on:2:superAdj:0"inScheduler: var Boolean":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F o ... 
 -- $var:getAdr: "inScheduler: var Boolean" >newOff:5,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVal ... 
 -- DI:OG: Boolean 
 -- before:floatTest:  "inScheduler: var Boolean" ObjectGenerator 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inScheduler":rec:- 
 -- After:U*U: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inScheduler":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inScheduler"  ATd: "inScheduler: var Boolean" 
 -- computeAdr:isFirst: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inScheduler":rec:- 
 -- computeAdr:isLast:E:  "inScheduler" 
 -- AssignmentStatement:gen: "inScheduler := 0" right.label: "ObjectGenerator" "0" 
 -- $ObjectGenerator:gen: "0" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "0" 
 -- OG:before:super.gen: "0" 
 -- $Invocation:gen: "0" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "0" 
 -- isConstant: "Invocation" "0" 
 -- needorigin: "0" 
 -- needOrigin:E: "0"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "0" E:  "0" 
 -- INV:gen:E.loadArgs "0" 
 -- $ConstLiteral:loadArgs: "0"  
 -- INV:gen:after:E.loadArgs "0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0" 
 -- $ConstLiteral:invoke: "0"  
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "inScheduler" dstE: "inScheduler" dstE.ATd: "inScheduler: var Boolean" useRtn: false :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsV ... 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "0" 
 -- isArgOfAssignI2IwithUniValArg "inScheduler := 0" arg: "0" ObjectGenerator 
 -- arg.super.arg: "0" ConstLiteral 
 -- dstDI: "inScheduler: var Boolean" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inScheduler":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg Scheduler$125 5
 -- assign:adr.store:B: 
 -- genclass:stmt: "active.attach(50)" 
 -- $ObjectGenerator:gen: "active.attach(50)" >OGid:"attach" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "active.attach(50)" 
 -- OG:before:super.gen: "active.attach(50)" 
 -- $Invocation:gen: "active.attach(50)" >useRtnV:"False"superAdj: 0 descNo: 173 
 -- INV:gen: "active.attach(50)" 
 -- isConstant: "Invocation" "active.attach(50)" 
 -- notConst: active active: ref ProcessType 
 -- needorigin: "active.attach(50)" 
 -- needOrigin:E: "attach(50)"  E.ATd: "attach: {   %basic 10;   in V: var integer}" 
 -- doNeedOrigin:Ex: "attach(50)" 
 -- computeAdr:superAdj: 0 "active.attach(50)" 
 -- computeAdr: 1 :rec: "none"  E: "active" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "active"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "active" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$172" on: 2 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg $172$172 1
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: Scheduler origin:isValueObj: false 
 rpushg loop$165 1
 -- $ObjectInvocation_Unary:getAdr: "active" >ATd.off:2:on:2:superAdj:0"active: ref ProcessType":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- $ref:getAdr: "active: ref ProcessType" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F is ... 
 -- E.on: 2 
 -- beforeIsValueObj:E: "active"  ATd: "active: ref ProcessType" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "active"  E: "attach(50)" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:getAdr: "attach(50)" >ATd.off:0 (isPtn):on:0:superAdj:0"attach: {   %basic 10;   in V: var integer":Adr:off:2 size:0 isFloat:F isUnitVal:F superA ...} 
 -- $pattern:getAdr: "attach: {   %basic 10;   in V: var integer" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(50)":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "active" >staticOff:0 "active: ref ProcessType" superAdj:0 
 -- $ref:loadArgs: "active: ref ProcessType" >E:"active" 
 -- $pattern:loadArgs: "ProcessType:< GeneralProcess" >E:"active":descNo:0 
 -- ptn:loadArgs:E "active" 
 -- {(ObjectInvocation_Unary; (name: "active"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "active" >rec:"active" ATd:"ref" E:"attach(50)" E.ATd:"attach" unique:"False" 
 -- OI:invoke: "active" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(50)":rec:active 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(50)":rec:active 
 -- OI:invoke:B: "active" E: "attach(50)"  rec: "active"  useRtnV: true "active: ref ProcessType" 
 -- OI:invoke:before:ATdx.invoke: ref active 
 -- $ref:invoke: "active: ref ProcessType" E: "attach(50)">newOff:2 useRTNv: "True" 
 -- DI:invoke: "active: ref ProcessType" 
 -- >Object:unique: false 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(50)":rec:active 
 -- isCompositeValueObj: false E: "attach(50)" "attach: {   %basic 10;   in V: var integer}" false 
 -- E.ATd.isValueObj: false rec: "active" 
 rpushg $172$172 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(50)":rec:active 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(50)":rec:active 
 -- 
 -- OI:invoke:C: active :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "active" E: "attach(50)" 
 -- arg:integer 
 -- computeAdr:isLast:E:  "attach(50)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(50)":rec:active 
 -- rec:  "active" E:  "attach(50)" 
 -- INV:gen:E.loadArgs "attach(50)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "attach(50)" >staticOff:0 "attach: {   %basic 10;   in V: var integer" superAdj:0arg:"50"} 
 -- $pattern:loadArgs: "attach: {   %basic 10;   in V: var integer" >E:"attach(50)":descNo:173} 
 -- ptn:loadArgs:E "attach(50)" 
 -- {(ObjectInvocation_KeyWord; (name: "attach"); (Arguments;  (name: "attach");  (name: "(");  (ObjectGenerator;   (Invocation;    (ConstLiteral 50));   (Items descNo: 0 orig ...} 
 -- args: "attach(50)" 
 -- E: "ObjectGenerator" 50 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "attach(50)" "ObjectInvocation_KeyWord" ActArg:  "50" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "attach(50)"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "50" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "50" 
 -- OG:before:super.gen: "50" 
 -- $Invocation:gen: "50" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "50" 
 -- isConstant: "Invocation" "50" 
 -- needorigin: "50" 
 -- needOrigin:E: "50"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "50" E:  "50" 
 -- INV:gen:E.loadArgs "50" 
 -- $ConstLiteral:loadArgs: "50"  
 -- INV:gen:after:E.loadArgs "50" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "50" 
 -- $ConstLiteral:invoke: "50"  
 pushc 50
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "50" :isBasicVal: true 
 -- case:B: 50 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "attach(50)" 
 -- INV:gen:after:E.loadArgs "attach(50)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "attach(50)" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(50) ..." 
 -- $ObjectInvocation_KeyWord:invoke: "attach(50)" >rec:"active" ATd:"pattern" E:"attach(50)" E.ATd:"attach" unique:"False" 
 -- OI:invoke: "attach(50)" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(50)":rec:active 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(50)":rec:active 
 -- OI:invoke:B: "attach(50)" E: "attach(50)"  rec: "active"  useRtnV: false "attach: {   %basic 10;   in V: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern attach 
 -- $pattern:invoke: "attach: {   %basic 10;   in V: var integer" E: "attach(50)" useRTNv: "False"} 
 -- ptn:invoke: "attach" E: "attach(50)" ptnKind: 0 useRtnV: false 
 %attach 10
 D rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(50)":rec:active 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(50)":rec:active 
 -- 
 -- OI:invoke:C: attach(50) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"attach(50)":rec:active 
 -- genclass:stmt: "inScheduler := 1" 
 -- $Assign:gen: "inScheduler := 1"  
 -- assign: "inScheduler := 1" 
 -- computeAdr:superAdj: 0 "inScheduler" 
 -- computeAdr: 1 :rec: "none"  E: "inScheduler" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inScheduler"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inScheduler" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$172" on: 2 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg $172$172 1
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: Scheduler origin:isValueObj: false 
 rpushg loop$165 1
 -- $ObjectInvocation_Unary:getAdr: "inScheduler" >ATd.off:5:on:2:superAdj:0"inScheduler: var Boolean":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F o ... 
 -- $var:getAdr: "inScheduler: var Boolean" >newOff:5,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVal ... 
 -- DI:OG: Boolean 
 -- before:floatTest:  "inScheduler: var Boolean" ObjectGenerator 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inScheduler":rec:- 
 -- After:U*U: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inScheduler":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inScheduler"  ATd: "inScheduler: var Boolean" 
 -- computeAdr:isFirst: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inScheduler":rec:- 
 -- computeAdr:isLast:E:  "inScheduler" 
 -- AssignmentStatement:gen: "inScheduler := 1" right.label: "ObjectGenerator" "1" 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "inScheduler" dstE: "inScheduler" dstE.ATd: "inScheduler: var Boolean" useRtn: false :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsV ... 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "1" 
 -- isArgOfAssignI2IwithUniValArg "inScheduler := 1" arg: "1" ObjectGenerator 
 -- arg.super.arg: "1" ConstLiteral 
 -- dstDI: "inScheduler: var Boolean" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inScheduler":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg Scheduler$125 5
 -- assign:adr.store:B: 
 -- genclass:stmt: "if (active.status = P_status.ACTIVE) :then {   SQS.insert(active)}" 
 -- $ObjectGenerator:gen: "if (active.status = P_status.ACTIVE) :then {   SQS.insert(active)" >OGid:"if:then$0" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "if (active.status = P_status.ACTIVE) :then {   SQS.insert(active)}" 
 -- OG:before:super.gen: "if (active.status = P_status.ACTIVE) :then {   SQS.insert(active)}" 
 -- $Invocation:gen: "if (active.status = P_status.ACTIVE) :then {   SQS.insert(active)" >useRtnV:"False"superAdj: 0} 
 -- INV:gen: "if (active.status = P_status.ACTIVE) :then {   SQS.insert(active)}" 
 -- isConstant: "Invocation" "if (active.status = P_status.ACTIVE) :then {   SQS.insert(active)}" 
 -- needorigin: "if (active.status = P_status.ACTIVE) :then {   SQS.insert(active)}" 
 -- needOrigin:E: "if (active.status = P_status.ACTIVE) :then {   SQS.insert(active)}"  E.ATd: "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal; ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (active.status = P_status.ACTIVE) :then {   SQS.insert(active)}" E:  "if (active.status = P_status.ACTIVE) :then {   SQS.insert(active)}" 
 -- INV:gen:E.loadArgs "if (active.status = P_status.ACTIVE) :then {   SQS.insert(active)}" 
 -- $IfThen:loadArgs: "if (active.status = P_status.ACTIVE) :then {   SQS.insert(active)" } 
 -- INV:gen:after:E.loadArgs "if (active.status = P_status.ACTIVE) :then {   SQS.insert(active)}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (active.status = P_status.ACTIVE) :then {   SQS.insert(active)}" 
 -- $IfThen:invoke: "if (active.status = P_status.ACTIVE) :then {   SQS.insert(active)" } 
 -- $IfThen:gen: "if (active.status = P_status.ACTIVE) :then {   SQS.insert(active)" } 
 -- $ObjectGenerator:gen: "(active.status = P_status.ACTIVE)" >OGid:"=" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(active.status = P_status.ACTIVE)" 
 -- OG:before:super.gen: "(active.status = P_status.ACTIVE)" 
 -- $Invocation:gen: "(active.status = P_status.ACTIVE)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(active.status = P_status.ACTIVE)" 
 -- isConstant: "Invocation" "(active.status = P_status.ACTIVE)" 
 -- needorigin: "(active.status = P_status.ACTIVE)" 
 -- needOrigin:E: "(active.status = P_status.ACTIVE)"  E.ATd: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- doNeedOrigin:Ex: "(active.status = P_status.ACTIVE)" 
 -- computeAdr:superAdj: 0 "(active.status = P_status.ACTIVE)" 
 -- computeAdr: 1 :rec: "none"  E: "(active.status = P_status.ACTIVE)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(active.status = P_status.ACTIVE)"  
 -- $BracketedExp:loadOrigin: "(active.status = P_status.ACTIVE)"  
 -- computeAdr:superAdj: 0 "active.status = P_status.ACTIVE" 
 -- computeAdr: 1 :rec: "none"  E: "active.status = P_status.ACTIVE" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "active.status = P_status.ACTIVE"  
 -- $BinOp:loadOrigin: "active.status = P_status.ACTIVE"  
 -- BinaryExp:loadOrigin:empty: "active.status = P_status.ACTIVE" superAdj: 0 
 -- $BinOp:getAdr: "active.status = P_status.ACTIVE"  
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "active.status = P_status.ACTIVE" 
 -- BE:loadOrigin:E: active.status = P_status.ACTIVE 
 -- $BinOp:getAdr: "active.status = P_status.ACTIVE"  
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "active.status = P_status.ACTIVE" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "active.status = P_status.ACTIVE" E:  "active.status = P_status.ACTIVE" 
 -- INV:gen:E.loadArgs "active.status = P_status.ACTIVE" 
 -- $BinOp:loadArgs: "active.status = P_status.ACTIVE"  
 -- BinaryExp:loadArgs: "active.status = P_status.ACTIVE" superAdj: 0 
 -- $Invocation:gen: "active.status" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "active.status" 
 -- isConstant: "Invocation" "active.status" 
 -- notConst: active active: ref ProcessType 
 -- needorigin: "active.status" 
 -- needOrigin:E: "status"  E.ATd: "status: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "active.status" 
 -- computeAdr: 1 :rec: "none"  E: "active" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "active"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "active" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$172" on: 2 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg $172$172 1
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: Scheduler origin:isValueObj: false 
 rpushg loop$165 1
 -- $ObjectInvocation_Unary:getAdr: "active" >ATd.off:2:on:2:superAdj:0"active: ref ProcessType":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- $ref:getAdr: "active: ref ProcessType" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F is ... 
 -- E.on: 2 
 -- beforeIsValueObj:E: "active"  ATd: "active: ref ProcessType" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "active"  E: "status" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "status" >ATd.off:3:on:0:superAdj:0"status: var integer":Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVal ... 
 -- $var:getAdr: "status: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F  ... 
 -- DI:OG: integer 
 -- before:floatTest:  "status: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"status":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"status":rec:- 
 -- $ObjectInvocation_Unary:loadArgs: "active" >staticOff:0 "active: ref ProcessType" superAdj:0 
 -- $ref:loadArgs: "active: ref ProcessType" >E:"active" 
 -- $pattern:loadArgs: "ProcessType:< GeneralProcess" >E:"active":descNo:0 
 -- ptn:loadArgs:E "active" 
 -- {(ObjectInvocation_Unary; (name: "active"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "active" >rec:"active" ATd:"ref" E:"status" E.ATd:"status" unique:"False" 
 -- OI:invoke: "active" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"status":rec:active 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"status":rec:active 
 -- OI:invoke:B: "active" E: "status"  rec: "active"  useRtnV: true "active: ref ProcessType" 
 -- OI:invoke:before:ATdx.invoke: ref active 
 -- $ref:invoke: "active: ref ProcessType" E: "status">newOff:2 useRTNv: "True" 
 -- DI:invoke: "active: ref ProcessType" 
 -- >Object:unique: false 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"status":rec:active 
 -- isCompositeValueObj: false E: "status" "status: var integer" true 
 -- E.ATd.isValueObj: false rec: "active" 
 rpushg $172$172 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"status":rec:active 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"status":rec:active 
 -- 
 -- OI:invoke:C: active :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "active" E: "status" 
 -- computeAdr:isLast:E:  "status" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"status":rec:- 
 -- rec:  "active" E:  "status" 
 -- INV:gen:E.loadArgs "status" 
 -- $ObjectInvocation_Unary:loadArgs: "status" >staticOff:0 "status: var integer" superAdj:0 
 -- $var:loadArgs: "status: var integer" >E:"status" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "status" 
 -- {(ObjectInvocation_Unary; (name: "status"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "status" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "status" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"status":rec:- 
 -- $ObjectInvocation_Unary:invoke: "status" >rec:"active" ATd:"var" isValueObj E:"status" E.ATd:"status" unique:"False" 
 -- OI:invoke: "status" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"status":rec:active 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"status":rec:active 
 -- OI:invoke:B: "status" E: "status"  rec: "active"  useRtnV: true "status: var integer" 
 -- OI:invoke:before:ATdx.invoke: var status 
 -- $var:invoke: "status: var integer" E: "status">newOff:3 useRTNv: "True" 
 -- DI:invoke: "status: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"status":rec:active 
 -- isCompositeValueObj: false E: "status" "status: var integer" true 
 -- E.ATd.isValueObj: false rec: "active" 
 pushg 3 $172$172
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"status":rec:active 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"status":rec:active 
 -- 
 -- OI:invoke:C: status :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- left:#I "active.status = P_status.ACTIVE" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"status":rec:active 
 -- $pattern:loadArgs: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )" >E:"= P_status.ACTIVE":descNo:11} 
 -- ptn:loadArgs:E "= P_status.ACTIVE" 
 -- {(ObjectInvocation_Binary; (name: "="); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "P_status");     (Arguments));    (ObjectInvoc ...} 
 -- args: "P_status.ACTIVE" 
 -- E: "ObjectGenerator" P_status.ACTIVE 
 -- E.arg: "var" in Veq: var this(Value) 
 -- NonVirt: "= P_status.ACTIVE" "ObjectInvocation_Binary" ActArg:  "P_status.ACTIVE" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "= P_status.ACTIVE"  isCompositeValueObj: true 
 -- $ObjectGenerator:gen: "P_status.ACTIVE" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "P_status.ACTIVE" 
 -- OG:before:super.gen: "P_status.ACTIVE" 
 -- $Invocation:gen: "P_status.ACTIVE" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "P_status.ACTIVE" 
 -- isConstant: "Invocation" "P_status.ACTIVE" 
 -- const literal:  1   ConstLiteral 
 pushc 1
 -- OG:gen:end: 
 -- vEq: 
 -- end:loadArgs:NonVirt: "= P_status.ACTIVE" 
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"status":rec:active 
 -- INV:gen:after:E.loadArgs "active.status = P_status.ACTIVE" 
 -- OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"status":rec:active 
 -- IV:E.invoke:useRtnVal: true E: BinOp "active.status = P_status.ACTIVE" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"status":r ... 
 -- $BinOp:invoke: "active.status = P_status.ACTIVE"  
 -- BinaryExp:invoke: "active.status" rec: "active.status = P_status.ACTIVE" 
 -- M: "= P_status.ACTIVE" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"status":rec:active 
 -- $ObjectInvocation_Binary:invoke: "= P_status.ACTIVE" >rec:"active.status" ATd:"pattern" E:"= P_status.ACTIVE" E.ATd:"=  " unique:"False" 
 -- OI:invoke: "= P_status.ACTIVE" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"status":rec:active.status 
 -- origin:isValueObj "Value" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"status":rec:active.status 
 -- OI:invoke:B: "= P_status.ACTIVE" E: "= P_status.ACTIVE"  rec: "active.status"  useRtnV: true "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inn ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern =   
 -- $pattern:invoke: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )" E: "= P_status.ACTIVE" useRTNv: "True"} 
 -- ptn:invoke: "=  " E: "= P_status.ACTIVE" ptnKind: 1 useRtnV: true 
 -- rec: "active.status" "Invocation" OGx.label: "ObjectGenerator" OGx: integer 
 -- rec.ATd: "status: var integer" 
 -- bobs: 1 OGx: integer 
 eq
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= P_status.ACTIVE":rec:active.status 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= P_status.ACTIVE":rec:active.status 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: = P_status.ACTIVE :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: "SQS.insert(active)" >OGid:"$174" singular! staticOff=0 descNo=174 superAdj=0 
 -- OG:gen: "SQS.insert(active)" 
 pushThis 
 -- before objTmpStack:add:  174   "$174" 
 invoke $174 174 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 174 
 -- Items:GenClass: $174 descNo: 174 isValue: false 
 -- Items:GenClass: $174 descNo: 21 isValue: false 

 CLASS $174 174 1 $172 172
 -- Store itemArgs: SQS.insert(active) 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=174 vDescInx=174 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "SQS.insert(active)" 
 -- $ObjectGenerator:gen: "SQS.insert(active)" >OGid:"insert" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "SQS.insert(active)" 
 -- OG:before:super.gen: "SQS.insert(active)" 
 -- $Invocation:gen: "SQS.insert(active)" >useRtnV:"False"superAdj: 0 descNo: 139 
 -- INV:gen: "SQS.insert(active)" 
 -- isConstant: "Invocation" "SQS.insert(active)" 
 -- needorigin: "SQS.insert(active)" 
 -- needOrigin:E: "insert(active)"  E.ATd: "insert: entry{   in P: ref BasicProcess;   if (Q.has(P).not) :then ;      Q.insert(P)}" 
 -- doNeedOrigin:Ex: "insert(active)" 
 -- computeAdr:superAdj: 0 "SQS.insert(active)" 
 -- computeAdr: 1 :rec: "none"  E: "SQS" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "SQS"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "SQS" >on:4 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$174" on: 4 isValueObj: false 
 -- origin: $172 origin:isValueObj: false 
 rpushg $174$174 1
 -- items:goOrigin:encOG: "$172" on: 3 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg $172$172 1
 -- items:goOrigin:encOG: "loop" on: 2 isValueObj: false 
 -- origin: Scheduler origin:isValueObj: false 
 rpushg loop$165 1
 -- items:goOrigin:encOG: "Scheduler" on: 1 isValueObj: false 
 -- origin: BasicSystem origin:isValueObj: false 
 rpushg Scheduler$125 3
 -- $ObjectInvocation_Unary:getAdr: "SQS" >ATd.off:6:on:4:superAdj:0"SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Publi ..."} 
 -- $obj:getAdr: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if  ..."} 
 -- E.on: 4 
 -- beforeIsValueObj:E: "SQS"  ATd: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V ...}" 
 -- computeAdr:isFirst: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "SQS"  E: "insert(active)" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:getAdr: "insert(active)" >ATd.off:0 (isPtn):on:0:superAdj:0"insert: entry{   in P: ref BasicProcess;   if (Q.has(P).not) :then ;      Q.insert(P) ..."} 
 -- $pattern:getAdr: "insert: entry{   in P: ref BasicProcess;   if (Q.has(P).not) :then ;      Q.insert(P)" } 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(active)":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "SQS" >staticOff:0 "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ..."} 
 -- $obj:loadArgs: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      i ..."} 
 -- $ObjectInvocation_Unary:invoke: "SQS" >rec:"SQS" ATd:"obj" E:"insert(active)" E.ATd:"insert" unique:"False" 
 -- OI:invoke: "SQS" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(active)":rec:SQS 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(active)":rec:SQS 
 -- OI:invoke:B: "SQS" E: "insert(active)"  rec: "SQS"  useRtnV: true "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Pub ...}" 
 -- OI:invoke:before:ATdx.invoke: obj SQS 
 -- $obj:invoke: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if  ..."} 
 -- DI:invoke: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if (V ...}" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(active)":rec:SQS 
 rpushg $174$174 6
 -- OI:invoke:V: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(active)":rec:SQS 
 -- 
 -- OI:invoke:X: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(active)":rec:SQS 
 -- 
 -- OI:invoke:C: SQS :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "SQS" E: "insert(active)" 
 -- arg:other 
 -- computeAdr:isLast:E:  "insert(active)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(active)":rec:SQS 
 -- rec:  "SQS" E:  "insert(active)" 
 -- INV:gen:E.loadArgs "insert(active)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "insert(active)" >staticOff:0 "insert: entry{   in P: ref BasicProcess;   if (Q.has(P).not) :then ;      Q.insert(P)" superAdj:0arg:"ac ..."} 
 -- $pattern:loadArgs: "insert: entry{   in P: ref BasicProcess;   if (Q.has(P).not) :then ;      Q.insert(P)" >E:"insert(active)":descNo:139} 
 -- ptn:loadArgs:E "insert(active)" 
 -- {(ObjectInvocation_KeyWord; (name: "insert"); (Arguments;  (name: "insert");  (name: "(");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "active ..."} 
 -- args: "insert(active)" 
 -- E: "ObjectGenerator" active 
 -- E.arg: "ref" in P: ref BasicProcess 
 -- NonVirt: "insert(active)" "ObjectInvocation_KeyWord" ActArg:  "active" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "insert(active)"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "active" >OGid:"GeneralProcess" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "active" 
 -- OG:before:super.gen: "active" 
 -- $Invocation:gen: "active" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "active" 
 -- isConstant: "Invocation" "active" 
 -- notConst: active active: ref ProcessType 
 -- needorigin: "active" 
 -- needOrigin:E: "active"  E.ATd: "active: ref ProcessType" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "active" 
 -- computeAdr: 1 :rec: "none"  E: "active" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "active"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "active" >on:3 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$174" on: 3 isValueObj: false 
 -- origin: $172 origin:isValueObj: false 
 rpushg $174$174 1
 -- items:goOrigin:encOG: "$172" on: 2 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg $172$172 1
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: Scheduler origin:isValueObj: false 
 rpushg loop$165 1
 -- $ObjectInvocation_Unary:getAdr: "active" >ATd.off:2:on:3:superAdj:0"active: ref ProcessType":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- $ref:getAdr: "active: ref ProcessType" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F is ... 
 -- E.on: 3 
 -- beforeIsValueObj:E: "active"  ATd: "active: ref ProcessType" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "active" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "active" E:  "active" 
 -- INV:gen:E.loadArgs "active" 
 -- $ObjectInvocation_Unary:loadArgs: "active" >staticOff:0 "active: ref ProcessType" superAdj:0 
 -- $ref:loadArgs: "active: ref ProcessType" >E:"active" 
 -- $pattern:loadArgs: "ProcessType:< GeneralProcess" >E:"active":descNo:0 
 -- ptn:loadArgs:E "active" 
 -- {(ObjectInvocation_Unary; (name: "active"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "active" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "active" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "active" >rec:"active" ATd:"ref" E:"active" E.ATd:"active" unique:"False" 
 -- OI:invoke: "active" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:active 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:active 
 -- OI:invoke:B: "active" E: "active"  rec: "active"  useRtnV: true "active: ref ProcessType" 
 -- OI:invoke:before:ATdx.invoke: ref active 
 -- $ref:invoke: "active: ref ProcessType" E: "active">newOff:2 useRTNv: "True" 
 -- DI:invoke: "active: ref ProcessType" 
 -- >Object:unique: false 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"active":rec:active 
 -- isCompositeValueObj: false E: "active" "active: ref ProcessType" false 
 -- E.ATd.isValueObj: false rec: "active" 
 rpushg Scheduler$125 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"active":rec:active 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"active":rec:active 
 -- 
 -- OI:invoke:C: active :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"active":rec:active 
 -- formalArg:isPtn: "in P: ref BasicProcess" :isBasicVal: false :valueObj: false 
 -- :actArg: "active" :isBasicVal: false 
 -- case:B: active ObjectGenerator 0 0 0 false false 
 -- end:loadArgs:NonVirt: "insert(active)" 
 -- INV:gen:after:E.loadArgs "insert(active)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "insert(active)" :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert ..." 
 -- $ObjectInvocation_KeyWord:invoke: "insert(active)" >rec:"SQS" ATd:"pattern" E:"insert(active)" E.ATd:"insert" unique:"False" 
 -- OI:invoke: "insert(active)" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(active)":rec:SQS 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(active)":rec:SQS 
 -- OI:invoke:B: "insert(active)" E: "insert(active)"  rec: "SQS"  useRtnV: false "insert: entry{   in P: ref BasicProcess;   if (Q.has(P).not) :then ;      Q.insert(P)}" 
 -- OI:invoke:before:ATdx.invoke: pattern insert 
 -- $pattern:invoke: "insert: entry{   in P: ref BasicProcess;   if (Q.has(P).not) :then ;      Q.insert(P)" E: "insert(active)" useRTNv: "False"} 
 -- ptn:invoke: "insert" E: "insert(active)" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(active)":rec:SQS 
 invoke insert 139 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(active)":rec:SQS 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(active)":rec:SQS 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: insert(active) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 6 
 -- OG:gen:end: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(active)":rec:SQS 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 175 
 -- Items:GenClass: isEmpty descNo: 175 isValue: false 
 -- Items:GenClass: isEmpty descNo: 21 isValue: false 

 CLASS isEmpty 175 1 SQS 77
 -- Store itemArgs: out B: var Boolean{entry;   B := Q.isEmpty} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=175 vDescInx=175 vdtTop: 1 
 mvStack 
 -- $var:gen: "out B: var Boolean"  
 -- DI:gen: "out B: var Boolean" DI:isConst: false :isBasicValue: true :primNo: 4 
 -- DI:add:BP1:  B 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "entry{   B := Q.isEmpty}" 
 -- $ObjectGenerator:gen: "entry{   B := Q.isEmpty" >OGid:"entry$176" singular! staticOff=0 descNo=176 superAdj=0} 
 -- OG:gen: "entry{   B := Q.isEmpty}" 
 pushThis 
 -- before objTmpStack:add:  176   "entry$176" 
 invoke entry$176 176 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 -- pushReturn:  "isEmpty" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 176 
 -- Items:GenClass: entry$176 descNo: 176 isValue: false 
 -- Items:GenClass: entry$176 descNo: 95 isValue: false 
 -- Items:GenClass: entry descNo: 21 isValue: false 

 CLASS entry$176 176 2 isEmpty 175
 -- vdtTableCopy: I:1:95 I:2:0
 -- vdtAdd: inx=2 descInx=176 vDescInx=176 vdtTop: 2 
 -- Store itemArgs: B := Q.isEmpty 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  2 origin
 -- super entry
 -- push:super.origin: 
 -- computeAdr:superAdj: 2 "entry" 
 -- computeAdr: 1 :rec: "none"  E: "entry" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:2 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "entry"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "entry" >on:1 superAdj:2 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 2 
 rpushg isEmpty$175 2
 -- items:goOrigin:encOG: "isEmpty" on: 1 isValueObj: false 
 -- origin: SQS origin:isValueObj: false 
 rpushg isEmpty$175 1
 -- $ObjectInvocation_Unary:getAdr: "entry" >ATd.off:0 (isPtn):on:1:superAdj:2"entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1 ..."} 
 -- $pattern:getAdr: "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:2 isUnique:F isValue:F originIsValue:F:E:"entry":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "entry"  ATd: "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:2 isUnique:F isValue:F originIsValue:F:E:"entry":rec:- 
 -- computeAdr:isLast:E:  "entry" 
 -- genClass:after:pushAddress: "entry" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:2 isUnique:F isValue:F originIsValue:F:E:"entry":rec:- 
 -- handleSuperArgs:E: "entry" theIS: "B := Q.isEmpty" 
 -- super.sig:none:superAdj: 2 
 -- $ObjectInvocation_Unary:loadArgs: "entry" >staticOff:0 "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free" superAd ...} 
 -- $pattern:loadArgs: "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free" >E:"entry":descNo:95} 
 -- ptn:loadArgs:E "entry" 
 -- {(ObjectInvocation_Unary; (name: "entry"); (Arguments))} 
 -- args: "" 
 -- hArgOrg:super: entry 
 -- Store itemArgs: B := Q.isEmpty 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=176 vDescInx=95 vdtTop: 2 
 rtnAlloc 1
 toSuper 95
DO:
 mvStack 
 L1:
 -- genclass:stmt: "B := Q.isEmpty" 
 -- $Assign:gen: "B := Q.isEmpty"  
 -- assign: "B := Q.isEmpty" 
 -- computeAdr:superAdj: 0 "B" 
 -- computeAdr: 1 :rec: "none"  E: "B" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "B"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "B" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "entry$176" on: 1 isValueObj: false 
 -- origin: isEmpty origin:isValueObj: false 
 rpushg entry$176$176 2
 -- $ObjectInvocation_Unary:getAdr: "B" >ATd.off:2:on:1:superAdj:0"out B: var Boolean":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "out B: var Boolean" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F o ... 
 -- DI:OG: Boolean 
 -- before:floatTest:  "out B: var Boolean" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "B"  ATd: "out B: var Boolean" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- computeAdr:isLast:E:  "B" 
 -- AssignmentStatement:gen: "B := Q.isEmpty" right.label: "ObjectGenerator" "Q.isEmpty" 
 -- $ObjectGenerator:gen: "Q.isEmpty" >OGid:"isEmpty" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "Q.isEmpty" 
 -- OG:before:super.gen: "Q.isEmpty" 
 -- $Invocation:gen: "Q.isEmpty" >useRtnV:"True"superAdj: 0 descNo: 177 
 -- INV:gen: "Q.isEmpty" 
 -- isConstant: "Invocation" "Q.isEmpty" 
 -- needorigin: "Q.isEmpty" 
 -- needOrigin:E: "isEmpty"  E.ATd: "isEmpty: {   out B: var Boolean;   B := head == none}" 
 -- doNeedOrigin:Ex: "isEmpty" 
 -- computeAdr:superAdj: 0 "Q.isEmpty" 
 -- computeAdr: 1 :rec: "none"  E: "Q" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Q"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Q" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "entry$176" on: 2 isValueObj: false 
 -- origin: isEmpty origin:isValueObj: false 
 rpushg entry$176$176 2
 -- items:goOrigin:encOG: "isEmpty" on: 1 isValueObj: false 
 -- origin: SQS origin:isValueObj: false 
 rpushg isEmpty$175 1
 -- $ObjectInvocation_Unary:getAdr: "Q" >ATd.off:2:on:2:superAdj:0"Q: obj ProcessQueue":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F: ... 
 -- $obj:getAdr: "Q: obj ProcessQueue" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValu ... 
 -- E.on: 2 
 -- beforeIsValueObj:E: "Q"  ATd: "Q: obj ProcessQueue" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "Q"  E: "isEmpty" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "isEmpty" >ATd.off:0 (isPtn):on:0:superAdj:0"isEmpty: {   out B: var Boolean;   B := head == none":Adr:off:2 size:0 isFloat:F isUnitVal:F s ...} 
 -- $pattern:getAdr: "isEmpty: {   out B: var Boolean;   B := head == none" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isEmpty":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "Q" >staticOff:0 "Q: obj ProcessQueue" superAdj:0 
 -- $obj:loadArgs: "Q: obj ProcessQueue" >E:"Q" 
 -- $pattern:loadArgs: "ProcessQueue: LIB.Collections.QueueLib.Queue{   %Public;   displayx: ;      put('Q')" >E:"Q":descNo:79} 
 -- ptn:loadArgs:E "Q" 
 -- {(ObjectInvocation_Unary; (name: "Q"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "Q" >rec:"Q" ATd:"obj" E:"isEmpty" E.ATd:"isEmpty" unique:"False" 
 -- OI:invoke: "Q" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isEmpty":rec:Q 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isEmpty":rec:Q 
 -- OI:invoke:B: "Q" E: "isEmpty"  rec: "Q"  useRtnV: true "Q: obj ProcessQueue" 
 -- OI:invoke:before:ATdx.invoke: obj Q 
 -- $obj:invoke: "Q: obj ProcessQueue" E: "isEmpty">newOff:2 useRTNv: "True" 
 -- DI:invoke: "Q: obj ProcessQueue" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isEmpty":rec:Q 
 rpushg entry$176$176 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isEmpty":rec:Q 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isEmpty":rec:Q 
 -- 
 -- OI:invoke:C: Q :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "Q" E: "isEmpty" 
 -- computeAdr:isLast:E:  "isEmpty" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isEmpty":rec:Q 
 -- rec:  "Q" E:  "isEmpty" 
 -- INV:gen:E.loadArgs "isEmpty" 
 -- $ObjectInvocation_Unary:loadArgs: "isEmpty" >staticOff:0 "isEmpty: {   out B: var Boolean;   B := head == none" superAdj:0} 
 -- $pattern:loadArgs: "isEmpty: {   out B: var Boolean;   B := head == none" >E:"isEmpty":descNo:177} 
 -- ptn:loadArgs:E "isEmpty" 
 -- {(ObjectInvocation_Unary; (name: "isEmpty"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "isEmpty" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "isEmpty" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isEmpty":rec:Q 
 -- $ObjectInvocation_Unary:invoke: "isEmpty" >rec:"Q" ATd:"pattern" E:"isEmpty" E.ATd:"isEmpty" unique:"False" 
 -- OI:invoke: "isEmpty" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isEmpty":rec:Q 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isEmpty":rec:Q 
 -- OI:invoke:B: "isEmpty" E: "isEmpty"  rec: "Q"  useRtnV: true "isEmpty: {   out B: var Boolean;   B := head == none}" 
 -- OI:invoke:before:ATdx.invoke: pattern isEmpty 
 -- $pattern:invoke: "isEmpty: {   out B: var Boolean;   B := head == none" E: "isEmpty" useRTNv: "True"} 
 -- ptn:invoke: "isEmpty" E: "isEmpty" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isEmpty":rec:Q 
 invoke isEmpty 177 0 0
 -- global:pushOut: B off: 2 
 pushg 2 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isEmpty":rec:Q 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isEmpty":rec:Q 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isEmpty":rec:Q 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isEmpty":rec:Q 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isEmpty":rec:Q 
 -- OI:invoke:C: isEmpty :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isEmpty":rec:Q 
 -- rec: "B" dstE: "B" dstE.ATd: "out B: var Boolean" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right: "Q.isEmpty" 
 -- isArgOfAssignI2IwithUniValArg "B := Q.isEmpty" arg: "Q.isEmpty" ObjectGenerator 
 -- arg.super.arg: "Q" ObjectInvocation_Unary 
 -- arg.super.arg: "isEmpty" ObjectInvocation_Unary 
 -- recx: "Q" argx: "isEmpty" 
 -- checkInt2IntWithUnitArg:rec: "Q" E: "isEmpty" 
 -- dstDI: "out B: var Boolean" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg isEmpty$175 2
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 177 
 -- Items:GenClass: isEmpty descNo: 177 isValue: false 
 -- Items:GenClass: isEmpty descNo: 21 isValue: false 

 CLASS isEmpty 177 1 Queue 78
 -- Store itemArgs: out B: var Boolean{B := head == none} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=177 vDescInx=177 vdtTop: 1 
 mvStack 
 -- $var:gen: "out B: var Boolean"  
 -- DI:gen: "out B: var Boolean" DI:isConst: false :isBasicValue: true :primNo: 4 
 -- DI:add:BP1:  B 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "B := head == none" 
 -- $Assign:gen: "B := head == none"  
 -- assign: "B := head == none" 
 -- computeAdr:superAdj: 0 "B" 
 -- computeAdr: 1 :rec: "none"  E: "B" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "B"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "B" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "B" >ATd.off:2:on:0:superAdj:0"out B: var Boolean":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "out B: var Boolean" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F o ... 
 -- DI:OG: Boolean 
 -- before:floatTest:  "out B: var Boolean" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- computeAdr:isLast:E:  "B" 
 -- AssignmentStatement:gen: "B := head == none" right.label: "ObjectGenerator" "head == none" 
 -- $ObjectGenerator:gen: "head == none" >OGid:"==" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "head == none" 
 -- OG:before:super.gen: "head == none" 
 -- $Invocation:gen: "head == none" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "head == none" 
 -- isConstant: "Invocation" "head == none" 
 -- needorigin: "head == none" 
 -- needOrigin:E: "head == none"  E.ATd: "==  : {   %basic 56;   in objx: ref Object;   out V: var boolean}" 
 -- doNeedOrigin:Ex: "head == none" 
 -- computeAdr:superAdj: 0 "head == none" 
 -- computeAdr: 1 :rec: "none"  E: "head == none" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "head == none"  
 -- $BinOp:loadOrigin: "head == none"  
 -- BinaryExp:loadOrigin:empty: "head == none" superAdj: 0 
 -- $BinOp:getAdr: "head == none"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "head == none"  ATd: "==  : {   %basic 56;   in objx: ref Object;   out V: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "head == none" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "head == none" E:  "head == none" 
 -- INV:gen:E.loadArgs "head == none" 
 -- $BinOp:loadArgs: "head == none"  
 -- BinaryExp:loadArgs: "head == none" superAdj: 0 
 -- $Invocation:gen: "head" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "head" 
 -- isConstant: "Invocation" "head" 
 -- notConst: head head: ref Element 
 -- needorigin: "head" 
 -- needOrigin:E: "head"  E.ATd: "head: ref Element" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "head" 
 -- computeAdr: 1 :rec: "none"  E: "head" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "head"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "head" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "isEmpty" on: 1 isValueObj: false 
 -- origin: Queue origin:isValueObj: false 
 rpushg isEmpty$177 1
 -- $ObjectInvocation_Unary:getAdr: "head" >ATd.off:4:on:1:superAdj:0"head: ref Element":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F ... 
 -- $ref:getAdr: "head: ref Element" >newOff:4,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "head"  ATd: "head: ref Element" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "head" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "head" E:  "head" 
 -- INV:gen:E.loadArgs "head" 
 -- $ObjectInvocation_Unary:loadArgs: "head" >staticOff:0 "head: ref Element" superAdj:0 
 -- $ref:loadArgs: "head: ref Element" >E:"head" 
 -- $pattern:loadArgs: "Element: {   in elm: ref Object;   out res: ref Element;   id: var integer;   pred: ref Element;   succ: ref Element;   res := this(Element);   idc :=  ..."} 
 -- ptn:loadArgs:E "head" 
 -- {(ObjectInvocation_Unary; (name: "head"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "head" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "head" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "head" >rec:"head" ATd:"ref" E:"head" E.ATd:"head" unique:"False" 
 -- OI:invoke: "head" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:head 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:head 
 -- OI:invoke:B: "head" E: "head"  rec: "head"  useRtnV: true "head: ref Element" 
 -- OI:invoke:before:ATdx.invoke: ref head 
 -- $ref:invoke: "head: ref Element" E: "head">newOff:4 useRTNv: "True" 
 -- DI:invoke: "head: ref Element" 
 -- >Object:unique: false 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- isCompositeValueObj: false E: "head" "head: ref Element" false 
 -- E.ATd.isValueObj: false rec: "head" 
 rpushg Queue$78 4
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- 
 -- OI:invoke:C: head :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- $pattern:loadArgs: "==  : {   %basic 56;   in objx: ref Object;   out V: var boolean" >E:"== none":descNo:144} 
 -- ptn:loadArgs:E "== none" 
 -- {(ObjectInvocation_Binary; (name: "=="); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "none");     (Arguments)));   (Items descNo:  ...} 
 -- args: "none" 
 -- E: "ObjectGenerator" none 
 -- E.arg: "ref" in objx: ref Object 
 -- NonVirt: "== none" "ObjectInvocation_Binary" ActArg:  "none" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "== none"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "none" >OGid:"none" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "none" 
 -- OG:before:super.gen: "none" 
 -- $Invocation:gen: "none" >useRtnV:"True"superAdj: 0 descNo: 116 
 -- INV:gen: "none" 
 -- isConstant: "Invocation" "none" 
 -- needorigin: "none" 
 -- needOrigin:E: "none"  E.ATd: "none: {   %basic 19;   none_x: var integer}" 
 -- doNeedOrigin:Ex: "none" 
 -- computeAdr:superAdj: 0 "none" 
 -- computeAdr: 1 :rec: "none"  E: "none" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "none"  
 -- $ObjectInvocation_Unary:loadOrigin: "none" >on:4 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_Unary:getAdr: "none" >ATd.off:0 (isPtn):on:4:superAdj:0"none: {   %basic 19;   none_x: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU ...} 
 -- $pattern:getAdr: "none: {   %basic 19;   none_x: var integer" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "none"  ATd: "none: {   %basic 19;   none_x: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "none" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "none" E:  "none" 
 -- INV:gen:E.loadArgs "none" 
 -- $ObjectInvocation_Unary:loadArgs: "none" >staticOff:0 "none: {   %basic 19;   none_x: var integer" superAdj:0} 
 -- $pattern:loadArgs: "none: {   %basic 19;   none_x: var integer" >E:"none":descNo:116} 
 -- ptn:loadArgs:E "none" 
 -- {(ObjectInvocation_Unary; (name: "none"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "none" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "none" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "none" >rec:"none" ATd:"pattern" E:"none" E.ATd:"none" unique:"False" 
 -- OI:invoke: "none" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- OI:invoke:B: "none" E: "none"  rec: "none"  useRtnV: true "none: {   %basic 19;   none_x: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern none 
 -- $pattern:invoke: "none: {   %basic 19;   none_x: var integer" E: "none" useRTNv: "True"} 
 -- ptn:invoke: "none" E: "none" ptnKind: 0 useRtnV: true 
 pushNone 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- 
 -- OI:invoke:C: none :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- formalArg:isPtn: "in objx: ref Object" :isBasicVal: false :valueObj: false 
 -- :actArg: "none" :isBasicVal: false 
 -- case:B: none ObjectGenerator 64 19 19 false false 
 -- end:loadArgs:NonVirt: "== none" 
 -- BinaryExp:loadArgs:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- INV:gen:after:E.loadArgs "head == none" 
 -- OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- IV:E.invoke:useRtnVal: true E: BinOp "head == none" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- $BinOp:invoke: "head == none"  
 -- BinaryExp:invoke: "head" rec: "head == none" 
 -- M: "== none" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- $ObjectInvocation_Binary:invoke: "== none" >rec:"head" ATd:"pattern" E:"== none" E.ATd:"==  " unique:"False" 
 -- OI:invoke: "== none" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- OI:invoke:B: "== none" E: "== none"  rec: "head"  useRtnV: true "==  : {   %basic 56;   in objx: ref Object;   out V: var boolean}" 
 -- OI:invoke:before:ATdx.invoke: pattern ==   
 -- $pattern:invoke: "==  : {   %basic 56;   in objx: ref Object;   out V: var boolean" E: "== none" useRTNv: "True"} 
 -- ptn:invoke: "==  " E: "== none" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "head" E: "== none" 
 -- arg:other 
 req
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"== none":rec:head 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"== none":rec:head 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: == none :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "B" dstE: "B" dstE.ATd: "out B: var Boolean" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right: "head == none" 
 -- isArgOfAssignI2IwithUniValArg "B := head == none" arg: "head == none" ObjectGenerator 
 -- arg.super.arg: "head == none" BinOp 
 -- recx:BinaryExp:recx: "head == none" 
 -- M: "== none" label: "ObjectInvocation_Binary" M.ATd: "==  : {   %basic 56;   in objx: ref Object;   out V: var boolean}" 
 -- checkInt2IntWithUnitArg:rec: "head" E: "== none" 
 -- arg:other 
 -- M:arg: "none" ObjectGenerator false 
 -- dstDI: "out B: var Boolean" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg isEmpty$177 2
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  "isEmpty" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 178 
 -- Items:GenClass: $178 descNo: 178 isValue: false 
 -- Items:GenClass: $178 descNo: 21 isValue: false 

 CLASS $178 178 1 loop 165
 -- Store itemArgs: if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop);sch.dcr;if (sch.running) :then ;   sleep(50);   sch.add;   restart(loop)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=178 vDescInx=178 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop)}" 
 -- $ObjectGenerator:gen: "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop)" >OGid:"if:then$0" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop)}" 
 -- OG:before:super.gen: "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop)}" 
 -- $Invocation:gen: "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop)" >useRtnV:"False"superAdj: 0} 
 -- INV:gen: "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop)}" 
 -- isConstant: "Invocation" "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop)}" 
 -- needorigin: "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop)}" 
 -- needOrigin:E: "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop)}"  E.ATd: "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basi ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop)}" E:  "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop)}" 
 -- INV:gen:E.loadArgs "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop)}" 
 -- $IfThen:loadArgs: "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop)" } 
 -- INV:gen:after:E.loadArgs "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop)}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop)}" 
 -- $IfThen:invoke: "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop)" } 
 -- $IfThen:gen: "if (SQS.hasWaiting) :then {   sleep(100);   restart(Loop)" } 
 -- $ObjectGenerator:gen: "(SQS.hasWaiting)" >OGid:"hasWaiting" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(SQS.hasWaiting)" 
 -- OG:before:super.gen: "(SQS.hasWaiting)" 
 -- $Invocation:gen: "(SQS.hasWaiting)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(SQS.hasWaiting)" 
 -- isConstant: "Invocation" "(SQS.hasWaiting)" 
 -- needorigin: "(SQS.hasWaiting)" 
 -- needOrigin:E: "(SQS.hasWaiting)"  E.ATd: "hasWaiting: {   out B: var boolean;   entry;      B := W > 0}" 
 -- doNeedOrigin:Ex: "(SQS.hasWaiting)" 
 -- computeAdr:superAdj: 0 "(SQS.hasWaiting)" 
 -- computeAdr: 1 :rec: "none"  E: "(SQS.hasWaiting)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(SQS.hasWaiting)"  
 -- $BracketedExp:loadOrigin: "(SQS.hasWaiting)"  
 -- computeAdr:superAdj: 0 "SQS.hasWaiting" 
 -- computeAdr: 1 :rec: "none"  E: "SQS" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "SQS"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "SQS" >on:3 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$178" on: 3 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg $178$178 1
 -- items:goOrigin:encOG: "loop" on: 2 isValueObj: false 
 -- origin: Scheduler origin:isValueObj: false 
 rpushg loop$165 1
 -- items:goOrigin:encOG: "Scheduler" on: 1 isValueObj: false 
 -- origin: BasicSystem origin:isValueObj: false 
 rpushg Scheduler$125 3
 -- $ObjectInvocation_Unary:getAdr: "SQS" >ATd.off:6:on:3:superAdj:0"SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Publi ..."} 
 -- $obj:getAdr: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if  ..."} 
 -- E.on: 3 
 -- beforeIsValueObj:E: "SQS"  ATd: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V ...}" 
 -- computeAdr:isFirst: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "SQS"  E: "hasWaiting" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "hasWaiting" >ATd.off:0 (isPtn):on:0:superAdj:0"hasWaiting: {   out B: var boolean;   entry;      B := W > 0":Adr:off:6 size:0 isFloat:F is ...} 
 -- $pattern:getAdr: "hasWaiting: {   out B: var boolean;   entry;      B := W > 0" } 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"hasWaiting":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "SQS" >staticOff:0 "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ..."} 
 -- $obj:loadArgs: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      i ..."} 
 -- $ObjectInvocation_Unary:invoke: "SQS" >rec:"SQS" ATd:"obj" E:"hasWaiting" E.ATd:"hasWaiting" unique:"False" 
 -- OI:invoke: "SQS" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"hasWaiting":rec:SQS 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"hasWaiting":rec:SQS 
 -- OI:invoke:B: "SQS" E: "hasWaiting"  rec: "SQS"  useRtnV: true "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public; ...}" 
 -- OI:invoke:before:ATdx.invoke: obj SQS 
 -- $obj:invoke: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if  ..."} 
 -- DI:invoke: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if (V ...}" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"hasWaiting":rec:SQS 
 rpushg $178$178 6
 -- OI:invoke:V: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"hasWaiting":rec:SQS 
 -- 
 -- OI:invoke:X: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"hasWaiting":rec:SQS 
 -- 
 -- OI:invoke:C: SQS :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "SQS" E: "hasWaiting" 
 -- computeAdr:isLast:E:  "hasWaiting" 
 -- BE:loadOrigin:E: hasWaiting 
 -- $ObjectInvocation_Unary:getAdr: "hasWaiting" >ATd.off:0 (isPtn):on:0:superAdj:0"hasWaiting: {   out B: var boolean;   entry;      B := W > 0":Adr:off:0 size:0 isFloat:F is ...} 
 -- $pattern:getAdr: "hasWaiting: {   out B: var boolean;   entry;      B := W > 0" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"hasWaiting":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"hasWaiting":rec:- 
 -- computeAdr:isLast:E:  "hasWaiting" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"hasWaiting":rec:- 
 -- rec:  "SQS" E:  "hasWaiting" 
 -- INV:gen:E.loadArgs "hasWaiting" 
 -- $ObjectInvocation_Unary:loadArgs: "hasWaiting" >staticOff:0 "hasWaiting: {   out B: var boolean;   entry;      B := W > 0" superAdj:0} 
 -- $pattern:loadArgs: "hasWaiting: {   out B: var boolean;   entry;      B := W > 0" >E:"hasWaiting":descNo:179} 
 -- ptn:loadArgs:E "hasWaiting" 
 -- {(ObjectInvocation_Unary; (name: "hasWaiting"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "hasWaiting" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "hasWaiting" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"hasWaiting":r ... 
 -- $ObjectInvocation_Unary:invoke: "hasWaiting" >rec:"SQS" ATd:"pattern" E:"hasWaiting" E.ATd:"hasWaiting" unique:"False" 
 -- OI:invoke: "hasWaiting" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"hasWaiting":rec:SQS 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"hasWaiting":rec:SQS 
 -- OI:invoke:B: "hasWaiting" E: "hasWaiting"  rec: "SQS"  useRtnV: true "hasWaiting: {   out B: var boolean;   entry;      B := W > 0}" 
 -- OI:invoke:before:ATdx.invoke: pattern hasWaiting 
 -- $pattern:invoke: "hasWaiting: {   out B: var boolean;   entry;      B := W > 0" E: "hasWaiting" useRTNv: "True"} 
 -- ptn:invoke: "hasWaiting" E: "hasWaiting" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"hasWaiting":rec:SQS 
 invoke hasWaiting 179 0 0
 -- global:pushOut: B off: 2 
 pushg 2 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"hasWaiting":rec:SQS 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"hasWaiting":rec:SQS 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"hasWaiting":rec:SQS 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"hasWaiting":rec:SQS 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"hasWaiting":rec:SQS 
 -- OI:invoke:C: hasWaiting :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"hasWaiting":rec:SQS 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: "sleep(100){   restart(Loop)" >OGid:"$181" singular! staticOff=0 descNo=181 superAdj=0} 
 -- OG:gen: "sleep(100){   restart(Loop)}" 
 pushThis 
 -- before objTmpStack:add:  181   "$181" 
 invoke $181 181 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "sch.dcr" 
 -- $ObjectGenerator:gen: "sch.dcr" >OGid:"dcr" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "sch.dcr" 
 -- OG:before:super.gen: "sch.dcr" 
 -- $Invocation:gen: "sch.dcr" >useRtnV:"False"superAdj: 0 descNo: 182 
 -- INV:gen: "sch.dcr" 
 -- isConstant: "Invocation" "sch.dcr" 
 -- needorigin: "sch.dcr" 
 -- needOrigin:E: "dcr"  E.ATd: "dcr: {   entry;      M := M - 1}" 
 -- doNeedOrigin:Ex: "dcr" 
 -- computeAdr:superAdj: 0 "sch.dcr" 
 -- computeAdr: 1 :rec: "none"  E: "sch" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "sch"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "sch" >on:3 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$178" on: 3 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg $178$178 1
 -- items:goOrigin:encOG: "loop" on: 2 isValueObj: false 
 -- origin: Scheduler origin:isValueObj: false 
 rpushg loop$165 1
 -- items:goOrigin:encOG: "Scheduler" on: 1 isValueObj: false 
 -- origin: BasicSystem origin:isValueObj: false 
 rpushg Scheduler$125 3
 -- $ObjectInvocation_Unary:getAdr: "sch" >ATd.off:5:on:3:superAdj:0"sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry ..."} 
 -- $obj:getAdr: "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      entry;         M := M ..."} 
 -- E.on: 3 
 -- beforeIsValueObj:E: "sch"  ATd: "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      en ...}" 
 -- computeAdr:isFirst: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "sch"  E: "dcr" 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "dcr" >ATd.off:0 (isPtn):on:0:superAdj:0"dcr: {   entry;      M := M - 1":Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa ...} 
 -- $pattern:getAdr: "dcr: {   entry;      M := M - 1" } 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"dcr":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "sch" >staticOff:0 "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.f ..."} 
 -- $obj:loadArgs: "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      entry;         M := ..."} 
 -- $ObjectInvocation_Unary:invoke: "sch" >rec:"sch" ATd:"obj" E:"dcr" E.ATd:"dcr" unique:"False" 
 -- OI:invoke: "sch" 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"dcr":rec:sch 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"dcr":rec:sch 
 -- OI:invoke:B: "sch" E: "dcr"  rec: "sch"  useRtnV: true "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L ...}" 
 -- OI:invoke:before:ATdx.invoke: obj sch 
 -- $obj:invoke: "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      entry;         M := M ..."} 
 -- DI:invoke: "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      entry;         M := M + ...}" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"dcr":rec:sch 
 rpushg $178$178 5
 -- OI:invoke:V: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"dcr":rec:sch 
 -- 
 -- OI:invoke:X: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"dcr":rec:sch 
 -- 
 -- OI:invoke:C: sch :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "sch" E: "dcr" 
 -- computeAdr:isLast:E:  "dcr" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"dcr":rec:sch 
 -- rec:  "sch" E:  "dcr" 
 -- INV:gen:E.loadArgs "dcr" 
 -- $ObjectInvocation_Unary:loadArgs: "dcr" >staticOff:0 "dcr: {   entry;      M := M - 1" superAdj:0} 
 -- $pattern:loadArgs: "dcr: {   entry;      M := M - 1" >E:"dcr":descNo:182} 
 -- ptn:loadArgs:E "dcr" 
 -- {(ObjectInvocation_Unary; (name: "dcr"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "dcr" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "dcr" :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"dcr":rec:sch 
 -- $ObjectInvocation_Unary:invoke: "dcr" >rec:"sch" ATd:"pattern" E:"dcr" E.ATd:"dcr" unique:"False" 
 -- OI:invoke: "dcr" 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"dcr":rec:sch 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"dcr":rec:sch 
 -- OI:invoke:B: "dcr" E: "dcr"  rec: "sch"  useRtnV: false "dcr: {   entry;      M := M - 1}" 
 -- OI:invoke:before:ATdx.invoke: pattern dcr 
 -- $pattern:invoke: "dcr: {   entry;      M := M - 1" E: "dcr" useRTNv: "False"} 
 -- ptn:invoke: "dcr" E: "dcr" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"dcr":rec:sch 
 invoke dcr 182 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"dcr":rec:sch 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"dcr":rec:sch 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: dcr :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 5 
 -- OG:gen:end: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"dcr":rec:sch 
 -- genclass:stmt: "if (sch.running) :then {   sleep(50);   sch.add;   restart(loop)}" 
 -- $ObjectGenerator:gen: "if (sch.running) :then {   sleep(50);   sch.add;   restart(loop)" >OGid:"if:then$0" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "if (sch.running) :then {   sleep(50);   sch.add;   restart(loop)}" 
 -- OG:before:super.gen: "if (sch.running) :then {   sleep(50);   sch.add;   restart(loop)}" 
 -- $Invocation:gen: "if (sch.running) :then {   sleep(50);   sch.add;   restart(loop)" >useRtnV:"False"superAdj: 0} 
 -- INV:gen: "if (sch.running) :then {   sleep(50);   sch.add;   restart(loop)}" 
 -- isConstant: "Invocation" "if (sch.running) :then {   sleep(50);   sch.add;   restart(loop)}" 
 -- needorigin: "if (sch.running) :then {   sleep(50);   sch.add;   restart(loop)}" 
 -- needOrigin:E: "if (sch.running) :then {   sleep(50);   sch.add;   restart(loop)}"  E.ATd: "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (sch.running) :then {   sleep(50);   sch.add;   restart(loop)}" E:  "if (sch.running) :then {   sleep(50);   sch.add;   restart(loop)}" 
 -- INV:gen:E.loadArgs "if (sch.running) :then {   sleep(50);   sch.add;   restart(loop)}" 
 -- $IfThen:loadArgs: "if (sch.running) :then {   sleep(50);   sch.add;   restart(loop)" } 
 -- INV:gen:after:E.loadArgs "if (sch.running) :then {   sleep(50);   sch.add;   restart(loop)}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (sch.running) :then {   sleep(50);   sch.add;   restart(loop)}" 
 -- $IfThen:invoke: "if (sch.running) :then {   sleep(50);   sch.add;   restart(loop)" } 
 -- $IfThen:gen: "if (sch.running) :then {   sleep(50);   sch.add;   restart(loop)" } 
 -- $ObjectGenerator:gen: "(sch.running)" >OGid:"running" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(sch.running)" 
 -- OG:before:super.gen: "(sch.running)" 
 -- $Invocation:gen: "(sch.running)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(sch.running)" 
 -- isConstant: "Invocation" "(sch.running)" 
 -- needorigin: "(sch.running)" 
 -- needOrigin:E: "(sch.running)"  E.ATd: "running: {   out B: var Boolean;   entry;      B := M > 0}" 
 -- doNeedOrigin:Ex: "(sch.running)" 
 -- computeAdr:superAdj: 0 "(sch.running)" 
 -- computeAdr: 1 :rec: "none"  E: "(sch.running)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(sch.running)"  
 -- $BracketedExp:loadOrigin: "(sch.running)"  
 -- computeAdr:superAdj: 0 "sch.running" 
 -- computeAdr: 1 :rec: "none"  E: "sch" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "sch"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "sch" >on:3 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$178" on: 3 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg $178$178 1
 -- items:goOrigin:encOG: "loop" on: 2 isValueObj: false 
 -- origin: Scheduler origin:isValueObj: false 
 rpushg loop$165 1
 -- items:goOrigin:encOG: "Scheduler" on: 1 isValueObj: false 
 -- origin: BasicSystem origin:isValueObj: false 
 rpushg Scheduler$125 3
 -- $ObjectInvocation_Unary:getAdr: "sch" >ATd.off:5:on:3:superAdj:0"sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry ..."} 
 -- $obj:getAdr: "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      entry;         M := M ..."} 
 -- E.on: 3 
 -- beforeIsValueObj:E: "sch"  ATd: "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      en ...}" 
 -- computeAdr:isFirst: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "sch"  E: "running" 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "running" >ATd.off:0 (isPtn):on:0:superAdj:0"running: {   out B: var Boolean;   entry;      B := M > 0":Adr:off:5 size:0 isFloat:F isUnitVa ...} 
 -- $pattern:getAdr: "running: {   out B: var Boolean;   entry;      B := M > 0" } 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"running":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "sch" >staticOff:0 "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.f ..."} 
 -- $obj:loadArgs: "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      entry;         M := ..."} 
 -- $ObjectInvocation_Unary:invoke: "sch" >rec:"sch" ATd:"obj" E:"running" E.ATd:"running" unique:"False" 
 -- OI:invoke: "sch" 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"running":rec:sch 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"running":rec:sch 
 -- OI:invoke:B: "sch" E: "running"  rec: "sch"  useRtnV: true "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);    ...}" 
 -- OI:invoke:before:ATdx.invoke: obj sch 
 -- $obj:invoke: "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      entry;         M := M ..."} 
 -- DI:invoke: "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      entry;         M := M + ...}" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"running":rec:sch 
 rpushg $178$178 5
 -- OI:invoke:V: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"running":rec:sch 
 -- 
 -- OI:invoke:X: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"running":rec:sch 
 -- 
 -- OI:invoke:C: sch :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "sch" E: "running" 
 -- computeAdr:isLast:E:  "running" 
 -- BE:loadOrigin:E: running 
 -- $ObjectInvocation_Unary:getAdr: "running" >ATd.off:0 (isPtn):on:0:superAdj:0"running: {   out B: var Boolean;   entry;      B := M > 0":Adr:off:0 size:0 isFloat:F isUnitVa ...} 
 -- $pattern:getAdr: "running: {   out B: var Boolean;   entry;      B := M > 0" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"running":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"running":rec:- 
 -- computeAdr:isLast:E:  "running" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"running":rec:- 
 -- rec:  "sch" E:  "running" 
 -- INV:gen:E.loadArgs "running" 
 -- $ObjectInvocation_Unary:loadArgs: "running" >staticOff:0 "running: {   out B: var Boolean;   entry;      B := M > 0" superAdj:0} 
 -- $pattern:loadArgs: "running: {   out B: var Boolean;   entry;      B := M > 0" >E:"running":descNo:184} 
 -- ptn:loadArgs:E "running" 
 -- {(ObjectInvocation_Unary; (name: "running"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "running" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "running" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"running":rec:- 
 -- $ObjectInvocation_Unary:invoke: "running" >rec:"sch" ATd:"pattern" E:"running" E.ATd:"running" unique:"False" 
 -- OI:invoke: "running" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"running":rec:sch 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"running":rec:sch 
 -- OI:invoke:B: "running" E: "running"  rec: "sch"  useRtnV: true "running: {   out B: var Boolean;   entry;      B := M > 0}" 
 -- OI:invoke:before:ATdx.invoke: pattern running 
 -- $pattern:invoke: "running: {   out B: var Boolean;   entry;      B := M > 0" E: "running" useRTNv: "True"} 
 -- ptn:invoke: "running" E: "running" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"running":rec:sch 
 invoke running 184 0 0
 -- global:pushOut: B off: 2 
 pushg 2 
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -4 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -4 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"running":rec:sch 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"running":rec:sch 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"running":rec:sch 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"running":rec:sch 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"running":rec:sch 
 -- OI:invoke:C: running :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"running":rec:sch 
 jmpFalse  L7
 L6:
 -- $ObjectGenerator:gen: "sleep(50){   sch.add;   restart(loop)" >OGid:"$186" singular! staticOff=0 descNo=186 superAdj=0} 
 -- OG:gen: "sleep(50){   sch.add;   restart(loop)}" 
 pushThis 
 -- before objTmpStack:add:  186   "$186" 
 invoke $186 186 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -5 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L7:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 179 
 -- Items:GenClass: hasWaiting descNo: 179 isValue: false 
 -- Items:GenClass: hasWaiting descNo: 21 isValue: false 

 CLASS hasWaiting 179 1 SQS 77
 -- Store itemArgs: out B: var boolean{entry;   B := W > 0} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=179 vDescInx=179 vdtTop: 1 
 mvStack 
 -- $var:gen: "out B: var boolean"  
 -- DI:gen: "out B: var boolean" DI:isConst: false :isBasicValue: true :primNo: 4 
 -- DI:add:BP1:  B 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "entry{   B := W > 0}" 
 -- $ObjectGenerator:gen: "entry{   B := W > 0" >OGid:"entry$180" singular! staticOff=0 descNo=180 superAdj=0} 
 -- OG:gen: "entry{   B := W > 0}" 
 pushThis 
 -- before objTmpStack:add:  180   "entry$180" 
 invoke entry$180 180 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 -- pushReturn:  "hasWaiting" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 180 
 -- Items:GenClass: entry$180 descNo: 180 isValue: false 
 -- Items:GenClass: entry$180 descNo: 95 isValue: false 
 -- Items:GenClass: entry descNo: 21 isValue: false 

 CLASS entry$180 180 2 hasWaiting 179
 -- vdtTableCopy: I:1:95 I:2:0
 -- vdtAdd: inx=2 descInx=180 vDescInx=180 vdtTop: 2 
 -- Store itemArgs: B := W > 0 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  2 origin
 -- super entry
 -- push:super.origin: 
 -- computeAdr:superAdj: 2 "entry" 
 -- computeAdr: 1 :rec: "none"  E: "entry" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:2 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "entry"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "entry" >on:1 superAdj:2 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 2 
 rpushg hasWaiting$179 2
 -- items:goOrigin:encOG: "hasWaiting" on: 1 isValueObj: false 
 -- origin: SQS origin:isValueObj: false 
 rpushg hasWaiting$179 1
 -- $ObjectInvocation_Unary:getAdr: "entry" >ATd.off:0 (isPtn):on:1:superAdj:2"entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1 ..."} 
 -- $pattern:getAdr: "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:2 isUnique:F isValue:F originIsValue:F:E:"entry":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "entry"  ATd: "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:2 isUnique:F isValue:F originIsValue:F:E:"entry":rec:- 
 -- computeAdr:isLast:E:  "entry" 
 -- genClass:after:pushAddress: "entry" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:2 isUnique:F isValue:F originIsValue:F:E:"entry":rec:- 
 -- handleSuperArgs:E: "entry" theIS: "B := W > 0" 
 -- super.sig:none:superAdj: 2 
 -- $ObjectInvocation_Unary:loadArgs: "entry" >staticOff:0 "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free" superAd ...} 
 -- $pattern:loadArgs: "entry: {   L.get;   V := V + 1;   if (V > 1) :then ;      put('V');   inner(entry);   V := V - 1;   L.free" >E:"entry":descNo:95} 
 -- ptn:loadArgs:E "entry" 
 -- {(ObjectInvocation_Unary; (name: "entry"); (Arguments))} 
 -- args: "" 
 -- hArgOrg:super: entry 
 -- Store itemArgs: B := W > 0 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=180 vDescInx=95 vdtTop: 2 
 rtnAlloc 1
 toSuper 95
DO:
 mvStack 
 L1:
 -- genclass:stmt: "B := W > 0" 
 -- $Assign:gen: "B := W > 0"  
 -- assign: "B := W > 0" 
 -- computeAdr:superAdj: 0 "B" 
 -- computeAdr: 1 :rec: "none"  E: "B" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "B"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "B" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "entry$180" on: 1 isValueObj: false 
 -- origin: hasWaiting origin:isValueObj: false 
 rpushg entry$180$180 2
 -- $ObjectInvocation_Unary:getAdr: "B" >ATd.off:2:on:1:superAdj:0"out B: var boolean":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "out B: var boolean" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F o ... 
 -- DI:OG: boolean 
 -- before:floatTest:  "out B: var boolean" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "B"  ATd: "out B: var boolean" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- computeAdr:isLast:E:  "B" 
 -- AssignmentStatement:gen: "B := W > 0" right.label: "ObjectGenerator" "W > 0" 
 -- $ObjectGenerator:gen: "W > 0" >OGid:">" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "W > 0" 
 -- OG:before:super.gen: "W > 0" 
 -- $Invocation:gen: "W > 0" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "W > 0" 
 -- isConstant: "Invocation" "W > 0" 
 -- needorigin: "W > 0" 
 -- needOrigin:E: "W > 0"  E.ATd: ">  : {   %basic 53;   in V: var integer;   out B: var boolean}" 
 -- doNeedOrigin:Ex: "W > 0" 
 -- computeAdr:superAdj: 0 "W > 0" 
 -- computeAdr: 1 :rec: "none"  E: "W > 0" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "W > 0"  
 -- $BinOp:loadOrigin: "W > 0"  
 -- BinaryExp:loadOrigin:empty: "W > 0" superAdj: 0 
 -- $BinOp:getAdr: "W > 0"  
 -- E.on: 2 
 -- beforeIsValueObj:E: "W > 0"  ATd: ">  : {   %basic 53;   in V: var integer;   out B: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "W > 0" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "W > 0" E:  "W > 0" 
 -- INV:gen:E.loadArgs "W > 0" 
 -- $BinOp:loadArgs: "W > 0"  
 -- BinaryExp:loadArgs: "W > 0" superAdj: 0 
 -- $Invocation:gen: "W" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "W" 
 -- isConstant: "Invocation" "W" 
 -- notConst: W W: var integer 
 -- needorigin: "W" 
 -- needOrigin:E: "W"  E.ATd: "W: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "W" 
 -- computeAdr: 1 :rec: "none"  E: "W" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "W"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "W" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "entry$180" on: 2 isValueObj: false 
 -- origin: hasWaiting origin:isValueObj: false 
 rpushg entry$180$180 2
 -- items:goOrigin:encOG: "hasWaiting" on: 1 isValueObj: false 
 -- origin: SQS origin:isValueObj: false 
 rpushg hasWaiting$179 1
 -- $ObjectInvocation_Unary:getAdr: "W" >ATd.off:5:on:2:superAdj:0"W: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "W: var integer" >newOff:5,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "W: var integer" ObjectGenerator 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"W":rec:- 
 -- After:U*U: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"W":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "W"  ATd: "W: var integer" 
 -- computeAdr:isFirst: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"W":rec:- 
 -- computeAdr:isLast:E:  "W" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"W":rec:- 
 -- rec:  "W" E:  "W" 
 -- INV:gen:E.loadArgs "W" 
 -- $ObjectInvocation_Unary:loadArgs: "W" >staticOff:0 "W: var integer" superAdj:0 
 -- $var:loadArgs: "W: var integer" >E:"W" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "W" 
 -- {(ObjectInvocation_Unary; (name: "W"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "W" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "W" :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"W":rec:- 
 -- $ObjectInvocation_Unary:invoke: "W" >rec:"W" ATd:"var" isValueObj E:"W" E.ATd:"W" unique:"False" 
 -- OI:invoke: "W" 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"W":rec:W 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"W":rec:W 
 -- OI:invoke:B: "W" E: "W"  rec: "W"  useRtnV: true "W: var integer" 
 -- OI:invoke:before:ATdx.invoke: var W 
 -- $var:invoke: "W: var integer" E: "W">newOff:5 useRTNv: "True" 
 -- DI:invoke: "W: var integer" 
 -- load: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"W":rec:W 
 -- isCompositeValueObj: false E: "W" "W: var integer" true 
 -- E.ATd.isValueObj: false rec: "W" 
 pushg 5 SQS$77
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"W":rec:W 
 -- 
 -- OI:invoke:X: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"W":rec:W 
 -- 
 -- OI:invoke:C: W :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 5 
 -- left:#I "W > 0" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"W":rec:W 
 -- $pattern:loadArgs: ">  : {   %basic 53;   in V: var integer;   out B: var boolean" >E:"> 0":descNo:101} 
 -- ptn:loadArgs:E "> 0" 
 -- {(ObjectInvocation_Binary; (name: ">"); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 0));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "0" 
 -- E: "ObjectGenerator" 0 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "> 0" "ObjectInvocation_Binary" ActArg:  "0" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "> 0"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "0" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "0" 
 -- OG:before:super.gen: "0" 
 -- $Invocation:gen: "0" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "0" 
 -- isConstant: "Invocation" "0" 
 -- needorigin: "0" 
 -- needOrigin:E: "0"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "0" E:  "0" 
 -- INV:gen:E.loadArgs "0" 
 -- $ConstLiteral:loadArgs: "0"  
 -- INV:gen:after:E.loadArgs "0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0" 
 -- $ConstLiteral:invoke: "0"  
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "0" :isBasicVal: true 
 -- case:B: 0 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "> 0" 
 -- BinaryExp:loadArgs:end: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"W":rec:W 
 -- INV:gen:after:E.loadArgs "W > 0" 
 -- OIadr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"W":rec:W 
 -- IV:E.invoke:useRtnVal: true E: BinOp "W > 0" :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"W":rec:W 
 -- $BinOp:invoke: "W > 0"  
 -- BinaryExp:invoke: "W" rec: "W > 0" 
 -- M: "> 0" :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"W":rec:W 
 -- $ObjectInvocation_Binary:invoke: "> 0" >rec:"W" ATd:"pattern" E:"> 0" E.ATd:">  " unique:"False" 
 -- OI:invoke: "> 0" 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"W":rec:W 
 -- origin:isValueObj "integer" 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"W":rec:W 
 -- OI:invoke:B: "> 0" E: "> 0"  rec: "W"  useRtnV: true ">  : {   %basic 53;   in V: var integer;   out B: var boolean}" 
 -- OI:invoke:before:ATdx.invoke: pattern >   
 -- $pattern:invoke: ">  : {   %basic 53;   in V: var integer;   out B: var boolean" E: "> 0" useRTNv: "True"} 
 -- ptn:invoke: ">  " E: "> 0" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "W" E: "> 0" 
 -- arg:integer 
 gt
 -- OI:invoke:V: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"> 0":rec:W 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"> 0":rec:W 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: > 0 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "B" dstE: "B" dstE.ATd: "out B: var boolean" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right: "W > 0" 
 -- isArgOfAssignI2IwithUniValArg "B := W > 0" arg: "W > 0" ObjectGenerator 
 -- arg.super.arg: "W > 0" BinOp 
 -- recx:BinaryExp:recx: "W > 0" 
 -- M: "> 0" label: "ObjectInvocation_Binary" M.ATd: ">  : {   %basic 53;   in V: var integer;   out B: var boolean}" 
 -- checkInt2IntWithUnitArg:rec: "W" E: "> 0" 
 -- arg:integer 
 -- M:arg: "0" ObjectGenerator false 
 -- dstDI: "out B: var boolean" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg hasWaiting$179 2
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 181 
 -- Items:GenClass: $181 descNo: 181 isValue: false 
 -- Items:GenClass: $181 descNo: 21 isValue: false 

 CLASS $181 181 1 $178 178
 -- Store itemArgs: sleep(100){restart(Loop)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=181 vDescInx=181 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "sleep(100)" 
 -- $ObjectGenerator:gen: "sleep(100)" >OGid:"sleep" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "sleep(100)" 
 -- OG:before:super.gen: "sleep(100)" 
 -- $Invocation:gen: "sleep(100)" >useRtnV:"False"superAdj: 0 descNo: 100 
 -- INV:gen: "sleep(100)" 
 -- isConstant: "Invocation" "sleep(100)" 
 -- needorigin: "sleep(100)" 
 -- needOrigin:E: "sleep(100)"  E.ATd: "sleep: {   %basic 15;   in V: var integer}" 
 -- doNeedOrigin:Ex: "sleep(100)" 
 -- computeAdr:superAdj: 0 "sleep(100)" 
 -- computeAdr: 1 :rec: "none"  E: "sleep(100)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "sleep(100)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "sleep(100)" >on:6 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "sleep(100)" >ATd.off:0 (isPtn):on:6:superAdj:0"sleep: {   %basic 15;   in V: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAd ...} 
 -- $pattern:getAdr: "sleep: {   %basic 15;   in V: var integer" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sleep(100)":rec:- 
 -- E.on: 6 
 -- beforeIsValueObj:E: "sleep(100)"  ATd: "sleep: {   %basic 15;   in V: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sleep(100)":rec:- 
 -- computeAdr:isLast:E:  "sleep(100)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sleep(100)":rec:- 
 -- rec:  "sleep(100)" E:  "sleep(100)" 
 -- INV:gen:E.loadArgs "sleep(100)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "sleep(100)" >staticOff:0 "sleep: {   %basic 15;   in V: var integer" superAdj:0arg:"100"} 
 -- $pattern:loadArgs: "sleep: {   %basic 15;   in V: var integer" >E:"sleep(100)":descNo:100} 
 -- ptn:loadArgs:E "sleep(100)" 
 -- {(ObjectInvocation_KeyWord; (name: "sleep"); (Arguments;  (name: "sleep");  (name: "(");  (ObjectGenerator;   (Invocation;    (ConstLiteral 100));   (Items descNo: 0 origD ...} 
 -- args: "sleep(100)" 
 -- E: "ObjectGenerator" 100 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "sleep(100)" "ObjectInvocation_KeyWord" ActArg:  "100" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "sleep(100)"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "100" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "100" 
 -- OG:before:super.gen: "100" 
 -- $Invocation:gen: "100" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "100" 
 -- isConstant: "Invocation" "100" 
 -- needorigin: "100" 
 -- needOrigin:E: "100"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: va ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "100" E:  "100" 
 -- INV:gen:E.loadArgs "100" 
 -- $ConstLiteral:loadArgs: "100"  
 -- INV:gen:after:E.loadArgs "100" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "100" 
 -- $ConstLiteral:invoke: "100"  
 pushc 100
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "100" :isBasicVal: true 
 -- case:B: 100 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "sleep(100)" 
 -- INV:gen:after:E.loadArgs "sleep(100)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "sleep(100)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sleep(100) ..." 
 -- $ObjectInvocation_KeyWord:invoke: "sleep(100)" >rec:"sleep(100)" ATd:"pattern" E:"sleep(100)" E.ATd:"sleep" unique:"False" 
 -- OI:invoke: "sleep(100)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sleep(100)":rec:sleep(100) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sleep(100)":rec:sleep(100) 
 -- OI:invoke:B: "sleep(100)" E: "sleep(100)"  rec: "sleep(100)"  useRtnV: false "sleep: {   %basic 15;   in V: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern sleep 
 -- $pattern:invoke: "sleep: {   %basic 15;   in V: var integer" E: "sleep(100)" useRTNv: "False"} 
 -- ptn:invoke: "sleep" E: "sleep(100)" ptnKind: 0 useRtnV: false 
 %sleep 15
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sleep(100)":rec:sleep(100) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sleep(100)":rec:sleep(100) 
 -- 
 -- OI:invoke:C: sleep(100) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sleep(100)":rec:sleep(100) 
 -- genclass:stmt: "restart(Loop)" 
 -- $ObjectGenerator:gen: "restart(Loop)" >OGid:"restart" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "restart(Loop)" 
 -- OG:before:super.gen: "restart(Loop)" 
 -- $Invocation:gen: "restart(Loop)" >useRtnV:"False"superAdj: 0 descNo: 50 
 -- INV:gen: "restart(Loop)" 
 -- isConstant: "Invocation" "restart(Loop)" 
 -- needorigin: "restart(Loop)" 
 -- needOrigin:E: "restart(Loop)"  E.ATd: "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- doNeedOrigin:Ex: "restart(Loop)" 
 -- computeAdr:superAdj: 0 "restart(Loop)" 
 -- computeAdr: 1 :rec: "none"  E: "restart(Loop)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "restart(Loop)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "restart(Loop)" >on:6 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "restart(Loop)" >ATd.off:0 (isPtn):on:6:superAdj:0"restart(V: var integer):  -- odd parameter type!{   %basic 102":Adr:off:0 size:0 isFlo ...} 
 -- $pattern:getAdr: "restart(V: var integer):  -- odd parameter type!{   %basic 102" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(Loop)":rec:- 
 -- E.on: 6 
 -- beforeIsValueObj:E: "restart(Loop)"  ATd: "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(Loop)":rec:- 
 -- computeAdr:isLast:E:  "restart(Loop)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(Loop)":rec:- 
 -- rec:  "restart(Loop)" E:  "restart(Loop)" 
 -- INV:gen:E.loadArgs "restart(Loop)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "restart(Loop)" >staticOff:0 "restart(V: var integer):  -- odd parameter type!{   %basic 102" superAdj:0arg:"Loop"} 
 -- $pattern:loadArgs: "restart(V: var integer):  -- odd parameter type!{   %basic 102" >E:"restart(Loop)":descNo:50} 
 -- INV:gen:after:E.loadArgs "restart(Loop)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "restart(Loop)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart ..." 
 -- $ObjectInvocation_KeyWord:invoke: "restart(Loop)" >rec:"restart(Loop)" ATd:"pattern" E:"restart(Loop)" E.ATd:"restart(V: var integer)" unique:"False" 
 -- OI:invoke: "restart(Loop)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(Loop)":rec:restart(Loop) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(Loop)":rec:restart(Loop) 
 -- OI:invoke:B: "restart(Loop)" E: "restart(Loop)"  rec: "restart(Loop)"  useRtnV: false "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- OI:invoke:before:ATdx.invoke: pattern restart(V: var integer) 
 -- $pattern:invoke: "restart(V: var integer):  -- odd parameter type!{   %basic 102" E: "restart(Loop)" useRTNv: "False"} 
 -- ptn:invoke: "restart(V: var integer)" E: "restart(Loop)" ptnKind: 0 useRtnV: false 
 break  2 1 165 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(Loop)":rec:restart(Loop) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(Loop)":rec:restart(Loop) 
 -- 
 -- OI:invoke:C: restart(Loop) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(Loop)":rec:restart(Loop) 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 182 
 -- Items:GenClass: dcr descNo: 182 isValue: false 
 -- Items:GenClass: dcr descNo: 21 isValue: false 

 CLASS dcr 182 1 sch 75
 -- Store itemArgs: entry{   M := M - 1} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=182 vDescInx=182 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "entry{   M := M - 1}" 
 -- $ObjectGenerator:gen: "entry{   M := M - 1" >OGid:"entry$183" singular! staticOff=0 descNo=183 superAdj=0} 
 -- OG:gen: "entry{   M := M - 1}" 
 pushThis 
 -- before objTmpStack:add:  183   "entry$183" 
 invoke entry$183 183 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 -- pushReturn:  "dcr" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 183 
 -- Items:GenClass: entry$183 descNo: 183 isValue: false 
 -- Items:GenClass: entry$183 descNo: 129 isValue: false 
 -- Items:GenClass: entry descNo: 21 isValue: false 

 CLASS entry$183 183 2 dcr 182
 -- vdtTableCopy: I:1:129 I:2:0
 -- vdtAdd: inx=2 descInx=183 vDescInx=183 vdtTop: 2 
 -- Store itemArgs: M := M - 1 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  2 origin
 -- super entry
 -- push:super.origin: 
 -- computeAdr:superAdj: 2 "entry" 
 -- computeAdr: 1 :rec: "none"  E: "entry" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:2 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "entry"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "entry" >on:1 superAdj:2 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 2 
 rpushg dcr$182 2
 -- items:goOrigin:encOG: "dcr" on: 1 isValueObj: false 
 -- origin: sch origin:isValueObj: false 
 rpushg dcr$182 1
 -- $ObjectInvocation_Unary:getAdr: "entry" >ATd.off:0 (isPtn):on:1:superAdj:2"entry: {   L.get;   inner(entry);   L.free":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:2 is ...} 
 -- $pattern:getAdr: "entry: {   L.get;   inner(entry);   L.free" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:2 isUnique:F isValue:F originIsValue:F:E:"entry":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "entry"  ATd: "entry: {   L.get;   inner(entry);   L.free}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:2 isUnique:F isValue:F originIsValue:F:E:"entry":rec:- 
 -- computeAdr:isLast:E:  "entry" 
 -- genClass:after:pushAddress: "entry" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:2 isUnique:F isValue:F originIsValue:F:E:"entry":rec:- 
 -- handleSuperArgs:E: "entry" theIS: "M := M - 1" 
 -- super.sig:none:superAdj: 2 
 -- $ObjectInvocation_Unary:loadArgs: "entry" >staticOff:0 "entry: {   L.get;   inner(entry);   L.free" superAdj:2} 
 -- $pattern:loadArgs: "entry: {   L.get;   inner(entry);   L.free" >E:"entry":descNo:129} 
 -- ptn:loadArgs:E "entry" 
 -- {(ObjectInvocation_Unary; (name: "entry"); (Arguments))} 
 -- args: "" 
 -- hArgOrg:super: entry 
 -- Store itemArgs: M := M - 1 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=183 vDescInx=129 vdtTop: 2 
 rtnAlloc 1
 toSuper 129
DO:
 mvStack 
 L1:
 -- genclass:stmt: "M := M - 1" 
 -- $Assign:gen: "M := M - 1"  
 -- assign: "M := M - 1" 
 -- computeAdr:superAdj: 0 "M" 
 -- computeAdr: 1 :rec: "none"  E: "M" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "M"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "M" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "entry$183" on: 2 isValueObj: false 
 -- origin: dcr origin:isValueObj: false 
 rpushg entry$183$183 2
 -- items:goOrigin:encOG: "dcr" on: 1 isValueObj: false 
 -- origin: sch origin:isValueObj: false 
 rpushg dcr$182 1
 -- $ObjectInvocation_Unary:getAdr: "M" >ATd.off:3:on:2:superAdj:0"M: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "M: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "M: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "M"  ATd: "M: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:- 
 -- computeAdr:isLast:E:  "M" 
 -- AssignmentStatement:gen: "M := M - 1" right.label: "ObjectGenerator" "M - 1" 
 -- $ObjectGenerator:gen: "M - 1" >OGid:"-" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "M - 1" 
 -- OG:before:super.gen: "M - 1" 
 -- $Invocation:gen: "M - 1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "M - 1" 
 -- isConstant: "Invocation" "M - 1" 
 -- needorigin: "M - 1" 
 -- needOrigin:E: "M - 1"  E.ATd: "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- doNeedOrigin:Ex: "M - 1" 
 -- computeAdr:superAdj: 0 "M - 1" 
 -- computeAdr: 1 :rec: "none"  E: "M - 1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "M - 1"  
 -- $BinOp:loadOrigin: "M - 1"  
 -- BinaryExp:loadOrigin:empty: "M - 1" superAdj: 0 
 -- $BinOp:getAdr: "M - 1"  
 -- E.on: 2 
 -- beforeIsValueObj:E: "M - 1"  ATd: "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "M - 1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "M - 1" E:  "M - 1" 
 -- INV:gen:E.loadArgs "M - 1" 
 -- $BinOp:loadArgs: "M - 1"  
 -- BinaryExp:loadArgs: "M - 1" superAdj: 0 
 -- $Invocation:gen: "M" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "M" 
 -- isConstant: "Invocation" "M" 
 -- notConst: M M: var integer 
 -- needorigin: "M" 
 -- needOrigin:E: "M"  E.ATd: "M: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "M" 
 -- computeAdr: 1 :rec: "none"  E: "M" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "M"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "M" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "entry$183" on: 2 isValueObj: false 
 -- origin: dcr origin:isValueObj: false 
 rpushg entry$183$183 2
 -- items:goOrigin:encOG: "dcr" on: 1 isValueObj: false 
 -- origin: sch origin:isValueObj: false 
 rpushg dcr$182 1
 -- $ObjectInvocation_Unary:getAdr: "M" >ATd.off:3:on:2:superAdj:0"M: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "M: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "M: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "M"  ATd: "M: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:- 
 -- computeAdr:isLast:E:  "M" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:- 
 -- rec:  "M" E:  "M" 
 -- INV:gen:E.loadArgs "M" 
 -- $ObjectInvocation_Unary:loadArgs: "M" >staticOff:0 "M: var integer" superAdj:0 
 -- $var:loadArgs: "M: var integer" >E:"M" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "M" 
 -- {(ObjectInvocation_Unary; (name: "M"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "M" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "M" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:- 
 -- $ObjectInvocation_Unary:invoke: "M" >rec:"M" ATd:"var" isValueObj E:"M" E.ATd:"M" unique:"False" 
 -- OI:invoke: "M" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- OI:invoke:B: "M" E: "M"  rec: "M"  useRtnV: true "M: var integer" 
 -- OI:invoke:before:ATdx.invoke: var M 
 -- $var:invoke: "M: var integer" E: "M">newOff:3 useRTNv: "True" 
 -- DI:invoke: "M: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- isCompositeValueObj: false E: "M" "M: var integer" true 
 -- E.ATd.isValueObj: false rec: "M" 
 pushg 3 sch$75
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- 
 -- OI:invoke:C: M :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- left:#I "M - 1" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- $pattern:loadArgs: "-  : {   %basic 62;   in V: var integer;   out R: var integer" >E:"- 1":descNo:108} 
 -- ptn:loadArgs:E "- 1" 
 -- {(ObjectInvocation_Binary; (name: "-"); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 1));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "1" 
 -- E: "ObjectGenerator" 1 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "- 1" "ObjectInvocation_Binary" ActArg:  "1" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "- 1"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "1" :isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "- 1" 
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- INV:gen:after:E.loadArgs "M - 1" 
 -- OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- IV:E.invoke:useRtnVal: true E: BinOp "M - 1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- $BinOp:invoke: "M - 1"  
 -- BinaryExp:invoke: "M" rec: "M - 1" 
 -- M: "- 1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- $ObjectInvocation_Binary:invoke: "- 1" >rec:"M" ATd:"pattern" E:"- 1" E.ATd:"-  " unique:"False" 
 -- OI:invoke: "- 1" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- origin:isValueObj "integer" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- OI:invoke:B: "- 1" E: "- 1"  rec: "M"  useRtnV: true "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern -   
 -- $pattern:invoke: "-  : {   %basic 62;   in V: var integer;   out R: var integer" E: "- 1" useRTNv: "True"} 
 -- ptn:invoke: "-  " E: "- 1" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "M" E: "- 1" 
 -- arg:integer 
 minus
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"- 1":rec:M 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"- 1":rec:M 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: - 1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "M" dstE: "M" dstE.ATd: "M: var integer" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "M - 1" 
 -- isArgOfAssignI2IwithUniValArg "M := M - 1" arg: "M - 1" ObjectGenerator 
 -- arg.super.arg: "M - 1" BinOp 
 -- recx:BinaryExp:recx: "M - 1" 
 -- M: "- 1" label: "ObjectInvocation_Binary" M.ATd: "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- checkInt2IntWithUnitArg:rec: "M" E: "- 1" 
 -- arg:integer 
 -- M:arg: "1" ObjectGenerator false 
 -- dstDI: "M: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg sch$75 3
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 184 
 -- Items:GenClass: running descNo: 184 isValue: false 
 -- Items:GenClass: running descNo: 21 isValue: false 

 CLASS running 184 1 sch 75
 -- Store itemArgs: out B: var Boolean{entry;   B := M > 0} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=184 vDescInx=184 vdtTop: 1 
 mvStack 
 -- $var:gen: "out B: var Boolean"  
 -- DI:gen: "out B: var Boolean" DI:isConst: false :isBasicValue: true :primNo: 4 
 -- DI:add:BP1:  B 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "entry{   B := M > 0}" 
 -- $ObjectGenerator:gen: "entry{   B := M > 0" >OGid:"entry$185" singular! staticOff=0 descNo=185 superAdj=0} 
 -- OG:gen: "entry{   B := M > 0}" 
 pushThis 
 -- before objTmpStack:add:  185   "entry$185" 
 invoke entry$185 185 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 -- pushReturn:  "running" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 185 
 -- Items:GenClass: entry$185 descNo: 185 isValue: false 
 -- Items:GenClass: entry$185 descNo: 129 isValue: false 
 -- Items:GenClass: entry descNo: 21 isValue: false 

 CLASS entry$185 185 2 running 184
 -- vdtTableCopy: I:1:129 I:2:0
 -- vdtAdd: inx=2 descInx=185 vDescInx=185 vdtTop: 2 
 -- Store itemArgs: B := M > 0 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  2 origin
 -- super entry
 -- push:super.origin: 
 -- computeAdr:superAdj: 2 "entry" 
 -- computeAdr: 1 :rec: "none"  E: "entry" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:2 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "entry"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "entry" >on:1 superAdj:2 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 2 
 rpushg running$184 2
 -- items:goOrigin:encOG: "running" on: 1 isValueObj: false 
 -- origin: sch origin:isValueObj: false 
 rpushg running$184 1
 -- $ObjectInvocation_Unary:getAdr: "entry" >ATd.off:0 (isPtn):on:1:superAdj:2"entry: {   L.get;   inner(entry);   L.free":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:2 is ...} 
 -- $pattern:getAdr: "entry: {   L.get;   inner(entry);   L.free" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:2 isUnique:F isValue:F originIsValue:F:E:"entry":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "entry"  ATd: "entry: {   L.get;   inner(entry);   L.free}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:2 isUnique:F isValue:F originIsValue:F:E:"entry":rec:- 
 -- computeAdr:isLast:E:  "entry" 
 -- genClass:after:pushAddress: "entry" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:2 isUnique:F isValue:F originIsValue:F:E:"entry":rec:- 
 -- handleSuperArgs:E: "entry" theIS: "B := M > 0" 
 -- super.sig:none:superAdj: 2 
 -- $ObjectInvocation_Unary:loadArgs: "entry" >staticOff:0 "entry: {   L.get;   inner(entry);   L.free" superAdj:2} 
 -- $pattern:loadArgs: "entry: {   L.get;   inner(entry);   L.free" >E:"entry":descNo:129} 
 -- ptn:loadArgs:E "entry" 
 -- {(ObjectInvocation_Unary; (name: "entry"); (Arguments))} 
 -- args: "" 
 -- hArgOrg:super: entry 
 -- Store itemArgs: B := M > 0 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=185 vDescInx=129 vdtTop: 2 
 rtnAlloc 1
 toSuper 129
DO:
 mvStack 
 L1:
 -- genclass:stmt: "B := M > 0" 
 -- $Assign:gen: "B := M > 0"  
 -- assign: "B := M > 0" 
 -- computeAdr:superAdj: 0 "B" 
 -- computeAdr: 1 :rec: "none"  E: "B" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "B"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "B" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "entry$185" on: 1 isValueObj: false 
 -- origin: running origin:isValueObj: false 
 rpushg entry$185$185 2
 -- $ObjectInvocation_Unary:getAdr: "B" >ATd.off:2:on:1:superAdj:0"out B: var Boolean":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "out B: var Boolean" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F o ... 
 -- DI:OG: Boolean 
 -- before:floatTest:  "out B: var Boolean" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "B"  ATd: "out B: var Boolean" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- computeAdr:isLast:E:  "B" 
 -- AssignmentStatement:gen: "B := M > 0" right.label: "ObjectGenerator" "M > 0" 
 -- $ObjectGenerator:gen: "M > 0" >OGid:">" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "M > 0" 
 -- OG:before:super.gen: "M > 0" 
 -- $Invocation:gen: "M > 0" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "M > 0" 
 -- isConstant: "Invocation" "M > 0" 
 -- needorigin: "M > 0" 
 -- needOrigin:E: "M > 0"  E.ATd: ">  : {   %basic 53;   in V: var integer;   out B: var boolean}" 
 -- doNeedOrigin:Ex: "M > 0" 
 -- computeAdr:superAdj: 0 "M > 0" 
 -- computeAdr: 1 :rec: "none"  E: "M > 0" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "M > 0"  
 -- $BinOp:loadOrigin: "M > 0"  
 -- BinaryExp:loadOrigin:empty: "M > 0" superAdj: 0 
 -- $BinOp:getAdr: "M > 0"  
 -- E.on: 2 
 -- beforeIsValueObj:E: "M > 0"  ATd: ">  : {   %basic 53;   in V: var integer;   out B: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "M > 0" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "M > 0" E:  "M > 0" 
 -- INV:gen:E.loadArgs "M > 0" 
 -- $BinOp:loadArgs: "M > 0"  
 -- BinaryExp:loadArgs: "M > 0" superAdj: 0 
 -- $Invocation:gen: "M" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "M" 
 -- isConstant: "Invocation" "M" 
 -- notConst: M M: var integer 
 -- needorigin: "M" 
 -- needOrigin:E: "M"  E.ATd: "M: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "M" 
 -- computeAdr: 1 :rec: "none"  E: "M" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "M"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "M" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "entry$185" on: 2 isValueObj: false 
 -- origin: running origin:isValueObj: false 
 rpushg entry$185$185 2
 -- items:goOrigin:encOG: "running" on: 1 isValueObj: false 
 -- origin: sch origin:isValueObj: false 
 rpushg running$184 1
 -- $ObjectInvocation_Unary:getAdr: "M" >ATd.off:3:on:2:superAdj:0"M: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "M: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "M: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "M"  ATd: "M: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:- 
 -- computeAdr:isLast:E:  "M" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:- 
 -- rec:  "M" E:  "M" 
 -- INV:gen:E.loadArgs "M" 
 -- $ObjectInvocation_Unary:loadArgs: "M" >staticOff:0 "M: var integer" superAdj:0 
 -- $var:loadArgs: "M: var integer" >E:"M" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "M" 
 -- {(ObjectInvocation_Unary; (name: "M"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "M" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "M" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:- 
 -- $ObjectInvocation_Unary:invoke: "M" >rec:"M" ATd:"var" isValueObj E:"M" E.ATd:"M" unique:"False" 
 -- OI:invoke: "M" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- OI:invoke:B: "M" E: "M"  rec: "M"  useRtnV: true "M: var integer" 
 -- OI:invoke:before:ATdx.invoke: var M 
 -- $var:invoke: "M: var integer" E: "M">newOff:3 useRTNv: "True" 
 -- DI:invoke: "M: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- isCompositeValueObj: false E: "M" "M: var integer" true 
 -- E.ATd.isValueObj: false rec: "M" 
 pushg 3 sch$75
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- 
 -- OI:invoke:C: M :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- left:#I "M > 0" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- $pattern:loadArgs: ">  : {   %basic 53;   in V: var integer;   out B: var boolean" >E:"> 0":descNo:101} 
 -- ptn:loadArgs:E "> 0" 
 -- {(ObjectInvocation_Binary; (name: ">"); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 0));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "0" 
 -- E: "ObjectGenerator" 0 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "> 0" "ObjectInvocation_Binary" ActArg:  "0" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "> 0"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "0" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "0" 
 -- OG:before:super.gen: "0" 
 -- $Invocation:gen: "0" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "0" 
 -- isConstant: "Invocation" "0" 
 -- needorigin: "0" 
 -- needOrigin:E: "0"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "0" E:  "0" 
 -- INV:gen:E.loadArgs "0" 
 -- $ConstLiteral:loadArgs: "0"  
 -- INV:gen:after:E.loadArgs "0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0" 
 -- $ConstLiteral:invoke: "0"  
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "0" :isBasicVal: true 
 -- case:B: 0 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "> 0" 
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- INV:gen:after:E.loadArgs "M > 0" 
 -- OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- IV:E.invoke:useRtnVal: true E: BinOp "M > 0" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- $BinOp:invoke: "M > 0"  
 -- BinaryExp:invoke: "M" rec: "M > 0" 
 -- M: "> 0" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- $ObjectInvocation_Binary:invoke: "> 0" >rec:"M" ATd:"pattern" E:"> 0" E.ATd:">  " unique:"False" 
 -- OI:invoke: "> 0" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- origin:isValueObj "integer" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- OI:invoke:B: "> 0" E: "> 0"  rec: "M"  useRtnV: true ">  : {   %basic 53;   in V: var integer;   out B: var boolean}" 
 -- OI:invoke:before:ATdx.invoke: pattern >   
 -- $pattern:invoke: ">  : {   %basic 53;   in V: var integer;   out B: var boolean" E: "> 0" useRTNv: "True"} 
 -- ptn:invoke: ">  " E: "> 0" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "M" E: "> 0" 
 -- arg:integer 
 gt
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"> 0":rec:M 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"> 0":rec:M 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: > 0 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "B" dstE: "B" dstE.ATd: "out B: var Boolean" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right: "M > 0" 
 -- isArgOfAssignI2IwithUniValArg "B := M > 0" arg: "M > 0" ObjectGenerator 
 -- arg.super.arg: "M > 0" BinOp 
 -- recx:BinaryExp:recx: "M > 0" 
 -- M: "> 0" label: "ObjectInvocation_Binary" M.ATd: ">  : {   %basic 53;   in V: var integer;   out B: var boolean}" 
 -- checkInt2IntWithUnitArg:rec: "M" E: "> 0" 
 -- arg:integer 
 -- M:arg: "0" ObjectGenerator false 
 -- dstDI: "out B: var Boolean" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg running$184 2
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 186 
 -- Items:GenClass: $186 descNo: 186 isValue: false 
 -- Items:GenClass: $186 descNo: 21 isValue: false 

 CLASS $186 186 1 $178 178
 -- Store itemArgs: sleep(50){sch.add;restart(loop)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=186 vDescInx=186 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "sleep(50)" 
 -- $ObjectGenerator:gen: "sleep(50)" >OGid:"sleep" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "sleep(50)" 
 -- OG:before:super.gen: "sleep(50)" 
 -- $Invocation:gen: "sleep(50)" >useRtnV:"False"superAdj: 0 descNo: 100 
 -- INV:gen: "sleep(50)" 
 -- isConstant: "Invocation" "sleep(50)" 
 -- needorigin: "sleep(50)" 
 -- needOrigin:E: "sleep(50)"  E.ATd: "sleep: {   %basic 15;   in V: var integer}" 
 -- doNeedOrigin:Ex: "sleep(50)" 
 -- computeAdr:superAdj: 0 "sleep(50)" 
 -- computeAdr: 1 :rec: "none"  E: "sleep(50)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "sleep(50)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "sleep(50)" >on:6 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "sleep(50)" >ATd.off:0 (isPtn):on:6:superAdj:0"sleep: {   %basic 15;   in V: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj ...} 
 -- $pattern:getAdr: "sleep: {   %basic 15;   in V: var integer" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sleep(50)":rec:- 
 -- E.on: 6 
 -- beforeIsValueObj:E: "sleep(50)"  ATd: "sleep: {   %basic 15;   in V: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sleep(50)":rec:- 
 -- computeAdr:isLast:E:  "sleep(50)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sleep(50)":rec:- 
 -- rec:  "sleep(50)" E:  "sleep(50)" 
 -- INV:gen:E.loadArgs "sleep(50)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "sleep(50)" >staticOff:0 "sleep: {   %basic 15;   in V: var integer" superAdj:0arg:"50"} 
 -- $pattern:loadArgs: "sleep: {   %basic 15;   in V: var integer" >E:"sleep(50)":descNo:100} 
 -- ptn:loadArgs:E "sleep(50)" 
 -- {(ObjectInvocation_KeyWord; (name: "sleep"); (Arguments;  (name: "sleep");  (name: "(");  (ObjectGenerator;   (Invocation;    (ConstLiteral 50));   (Items descNo: 0 origDe ...} 
 -- args: "sleep(50)" 
 -- E: "ObjectGenerator" 50 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "sleep(50)" "ObjectInvocation_KeyWord" ActArg:  "50" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "sleep(50)"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "50" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "50" 
 -- OG:before:super.gen: "50" 
 -- $Invocation:gen: "50" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "50" 
 -- isConstant: "Invocation" "50" 
 -- needorigin: "50" 
 -- needOrigin:E: "50"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "50" E:  "50" 
 -- INV:gen:E.loadArgs "50" 
 -- $ConstLiteral:loadArgs: "50"  
 -- INV:gen:after:E.loadArgs "50" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "50" 
 -- $ConstLiteral:invoke: "50"  
 pushc 50
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "50" :isBasicVal: true 
 -- case:B: 50 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "sleep(50)" 
 -- INV:gen:after:E.loadArgs "sleep(50)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "sleep(50)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sleep(50)": ... 
 -- $ObjectInvocation_KeyWord:invoke: "sleep(50)" >rec:"sleep(50)" ATd:"pattern" E:"sleep(50)" E.ATd:"sleep" unique:"False" 
 -- OI:invoke: "sleep(50)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sleep(50)":rec:sleep(50) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sleep(50)":rec:sleep(50) 
 -- OI:invoke:B: "sleep(50)" E: "sleep(50)"  rec: "sleep(50)"  useRtnV: false "sleep: {   %basic 15;   in V: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern sleep 
 -- $pattern:invoke: "sleep: {   %basic 15;   in V: var integer" E: "sleep(50)" useRTNv: "False"} 
 -- ptn:invoke: "sleep" E: "sleep(50)" ptnKind: 0 useRtnV: false 
 %sleep 15
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sleep(50)":rec:sleep(50) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sleep(50)":rec:sleep(50) 
 -- 
 -- OI:invoke:C: sleep(50) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sleep(50)":rec:sleep(50) 
 -- genclass:stmt: "sch.add" 
 -- $ObjectGenerator:gen: "sch.add" >OGid:"add" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "sch.add" 
 -- OG:before:super.gen: "sch.add" 
 -- $Invocation:gen: "sch.add" >useRtnV:"False"superAdj: 0 descNo: 128 
 -- INV:gen: "sch.add" 
 -- isConstant: "Invocation" "sch.add" 
 -- needorigin: "sch.add" 
 -- needOrigin:E: "add"  E.ATd: "add: {   entry;      M := M + 1}" 
 -- doNeedOrigin:Ex: "add" 
 -- computeAdr:superAdj: 0 "sch.add" 
 -- computeAdr: 1 :rec: "none"  E: "sch" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "sch"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "sch" >on:4 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$186" on: 4 isValueObj: false 
 -- origin: $178 origin:isValueObj: false 
 rpushg $186$186 1
 -- items:goOrigin:encOG: "$178" on: 3 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg $178$178 1
 -- items:goOrigin:encOG: "loop" on: 2 isValueObj: false 
 -- origin: Scheduler origin:isValueObj: false 
 rpushg loop$165 1
 -- items:goOrigin:encOG: "Scheduler" on: 1 isValueObj: false 
 -- origin: BasicSystem origin:isValueObj: false 
 rpushg Scheduler$125 3
 -- $ObjectInvocation_Unary:getAdr: "sch" >ATd.off:5:on:4:superAdj:0"sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry ..."} 
 -- $obj:getAdr: "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      entry;         M := M ..."} 
 -- E.on: 4 
 -- beforeIsValueObj:E: "sch"  ATd: "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      en ...}" 
 -- computeAdr:isFirst: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "sch"  E: "add" 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "add" >ATd.off:0 (isPtn):on:0:superAdj:0"add: {   entry;      M := M + 1":Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa ...} 
 -- $pattern:getAdr: "add: {   entry;      M := M + 1" } 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"add":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "sch" >staticOff:0 "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.f ..."} 
 -- $obj:loadArgs: "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      entry;         M := ..."} 
 -- $ObjectInvocation_Unary:invoke: "sch" >rec:"sch" ATd:"obj" E:"add" E.ATd:"add" unique:"False" 
 -- OI:invoke: "sch" 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"add":rec:sch 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"add":rec:sch 
 -- OI:invoke:B: "sch" E: "add"  rec: "sch"  useRtnV: true "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L ...}" 
 -- OI:invoke:before:ATdx.invoke: obj sch 
 -- $obj:invoke: "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      entry;         M := M ..."} 
 -- DI:invoke: "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      entry;         M := M + ...}" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"add":rec:sch 
 rpushg $186$186 5
 -- OI:invoke:V: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"add":rec:sch 
 -- 
 -- OI:invoke:X: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"add":rec:sch 
 -- 
 -- OI:invoke:C: sch :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "sch" E: "add" 
 -- computeAdr:isLast:E:  "add" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"add":rec:sch 
 -- rec:  "sch" E:  "add" 
 -- INV:gen:E.loadArgs "add" 
 -- $ObjectInvocation_Unary:loadArgs: "add" >staticOff:0 "add: {   entry;      M := M + 1" superAdj:0} 
 -- $pattern:loadArgs: "add: {   entry;      M := M + 1" >E:"add":descNo:128} 
 -- ptn:loadArgs:E "add" 
 -- {(ObjectInvocation_Unary; (name: "add"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "add" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "add" :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"add":rec:sch 
 -- $ObjectInvocation_Unary:invoke: "add" >rec:"sch" ATd:"pattern" E:"add" E.ATd:"add" unique:"False" 
 -- OI:invoke: "add" 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"add":rec:sch 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"add":rec:sch 
 -- OI:invoke:B: "add" E: "add"  rec: "sch"  useRtnV: false "add: {   entry;      M := M + 1}" 
 -- OI:invoke:before:ATdx.invoke: pattern add 
 -- $pattern:invoke: "add: {   entry;      M := M + 1" E: "add" useRTNv: "False"} 
 -- ptn:invoke: "add" E: "add" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"add":rec:sch 
 invoke add 128 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"add":rec:sch 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"add":rec:sch 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: add :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 5 
 -- OG:gen:end: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"add":rec:sch 
 -- genclass:stmt: "restart(loop)" 
 -- $ObjectGenerator:gen: "restart(loop)" >OGid:"restart" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "restart(loop)" 
 -- OG:before:super.gen: "restart(loop)" 
 -- $Invocation:gen: "restart(loop)" >useRtnV:"False"superAdj: 0 descNo: 50 
 -- INV:gen: "restart(loop)" 
 -- isConstant: "Invocation" "restart(loop)" 
 -- needorigin: "restart(loop)" 
 -- needOrigin:E: "restart(loop)"  E.ATd: "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- doNeedOrigin:Ex: "restart(loop)" 
 -- computeAdr:superAdj: 0 "restart(loop)" 
 -- computeAdr: 1 :rec: "none"  E: "restart(loop)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "restart(loop)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "restart(loop)" >on:6 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "restart(loop)" >ATd.off:0 (isPtn):on:6:superAdj:0"restart(V: var integer):  -- odd parameter type!{   %basic 102":Adr:off:0 size:0 isFlo ...} 
 -- $pattern:getAdr: "restart(V: var integer):  -- odd parameter type!{   %basic 102" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:- 
 -- E.on: 6 
 -- beforeIsValueObj:E: "restart(loop)"  ATd: "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:- 
 -- computeAdr:isLast:E:  "restart(loop)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:- 
 -- rec:  "restart(loop)" E:  "restart(loop)" 
 -- INV:gen:E.loadArgs "restart(loop)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "restart(loop)" >staticOff:0 "restart(V: var integer):  -- odd parameter type!{   %basic 102" superAdj:0arg:"loop"} 
 -- $pattern:loadArgs: "restart(V: var integer):  -- odd parameter type!{   %basic 102" >E:"restart(loop)":descNo:50} 
 -- INV:gen:after:E.loadArgs "restart(loop)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "restart(loop)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart ..." 
 -- $ObjectInvocation_KeyWord:invoke: "restart(loop)" >rec:"restart(loop)" ATd:"pattern" E:"restart(loop)" E.ATd:"restart(V: var integer)" unique:"False" 
 -- OI:invoke: "restart(loop)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- OI:invoke:B: "restart(loop)" E: "restart(loop)"  rec: "restart(loop)"  useRtnV: false "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- OI:invoke:before:ATdx.invoke: pattern restart(V: var integer) 
 -- $pattern:invoke: "restart(V: var integer):  -- odd parameter type!{   %basic 102" E: "restart(loop)" useRTNv: "False"} 
 -- ptn:invoke: "restart(V: var integer)" E: "restart(loop)" ptnKind: 0 useRtnV: false 
 break  2 1 165 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- 
 -- OI:invoke:C: restart(loop) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 187 
 -- Items:GenClass: $187 descNo: 187 isValue: false 
 -- Items:GenClass: $187 descNo: 21 isValue: false 

 CLASS $187 187 1 loop 165
 -- Store itemArgs: restart(Loop) 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=187 vDescInx=187 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "restart(Loop)" 
 -- $ObjectGenerator:gen: "restart(Loop)" >OGid:"restart" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "restart(Loop)" 
 -- OG:before:super.gen: "restart(Loop)" 
 -- $Invocation:gen: "restart(Loop)" >useRtnV:"False"superAdj: 0 descNo: 50 
 -- INV:gen: "restart(Loop)" 
 -- isConstant: "Invocation" "restart(Loop)" 
 -- needorigin: "restart(Loop)" 
 -- needOrigin:E: "restart(Loop)"  E.ATd: "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- doNeedOrigin:Ex: "restart(Loop)" 
 -- computeAdr:superAdj: 0 "restart(Loop)" 
 -- computeAdr: 1 :rec: "none"  E: "restart(Loop)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "restart(Loop)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "restart(Loop)" >on:5 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "restart(Loop)" >ATd.off:0 (isPtn):on:5:superAdj:0"restart(V: var integer):  -- odd parameter type!{   %basic 102":Adr:off:0 size:0 isFlo ...} 
 -- $pattern:getAdr: "restart(V: var integer):  -- odd parameter type!{   %basic 102" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(Loop)":rec:- 
 -- E.on: 5 
 -- beforeIsValueObj:E: "restart(Loop)"  ATd: "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(Loop)":rec:- 
 -- computeAdr:isLast:E:  "restart(Loop)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(Loop)":rec:- 
 -- rec:  "restart(Loop)" E:  "restart(Loop)" 
 -- INV:gen:E.loadArgs "restart(Loop)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "restart(Loop)" >staticOff:0 "restart(V: var integer):  -- odd parameter type!{   %basic 102" superAdj:0arg:"Loop"} 
 -- $pattern:loadArgs: "restart(V: var integer):  -- odd parameter type!{   %basic 102" >E:"restart(Loop)":descNo:50} 
 -- INV:gen:after:E.loadArgs "restart(Loop)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "restart(Loop)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart ..." 
 -- $ObjectInvocation_KeyWord:invoke: "restart(Loop)" >rec:"restart(Loop)" ATd:"pattern" E:"restart(Loop)" E.ATd:"restart(V: var integer)" unique:"False" 
 -- OI:invoke: "restart(Loop)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(Loop)":rec:restart(Loop) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(Loop)":rec:restart(Loop) 
 -- OI:invoke:B: "restart(Loop)" E: "restart(Loop)"  rec: "restart(Loop)"  useRtnV: false "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- OI:invoke:before:ATdx.invoke: pattern restart(V: var integer) 
 -- $pattern:invoke: "restart(V: var integer):  -- odd parameter type!{   %basic 102" E: "restart(Loop)" useRTNv: "False"} 
 -- ptn:invoke: "restart(V: var integer)" E: "restart(Loop)" ptnKind: 0 useRtnV: false 
 break  1 1 165 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(Loop)":rec:restart(Loop) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(Loop)":rec:restart(Loop) 
 -- 
 -- OI:invoke:C: restart(Loop) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(Loop)":rec:restart(Loop) 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 131 
 -- Items:GenClass: attach descNo: 131 isValue: false 
 -- Items:GenClass: attach descNo: 21 isValue: false 

 CLASS attach 131 1 Core 113
 -- Store itemArgs: in M: ref Scheduler{main := M} 
 -- in M: ref Scheduler true 0 
 -- DI:store: "M" 
 pushThis 
 rstoreg  M 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=131 vDescInx=131 vdtTop: 1 
 mvStack 
 -- $ref:gen: "in M: ref Scheduler"  
 -- DI:gen: "in M: ref Scheduler" DI:isConst: false :isBasicValue: false :primNo: 0 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "main := M" 
 -- $Assign:gen: "main := M"  
 -- assign: "main := M" 
 -- computeAdr:superAdj: 0 "main" 
 -- computeAdr: 1 :rec: "none"  E: "main" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "main"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "main" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "attach" on: 1 isValueObj: false 
 -- origin: Core origin:isValueObj: false 
 rpushg attach$131 1
 -- $ObjectInvocation_Unary:getAdr: "main" >ATd.off:2:on:1:superAdj:0"main: ref SuperScheduler":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIs ... 
 -- $ref:getAdr: "main: ref SuperScheduler" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F i ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "main"  ATd: "main: ref SuperScheduler" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "main" 
 -- AssignmentStatement:gen: "main := M" right.label: "ObjectGenerator" "M" 
 -- $ObjectGenerator:gen: "M" >OGid:"Scheduler" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "M" 
 -- OG:before:super.gen: "M" 
 -- $Invocation:gen: "M" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "M" 
 -- isConstant: "Invocation" "M" 
 -- notConst: M in M: ref Scheduler 
 -- needorigin: "M" 
 -- needOrigin:E: "M"  E.ATd: "in M: ref Scheduler" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "M" 
 -- computeAdr: 1 :rec: "none"  E: "M" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "M"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "M" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "M" >ATd.off:2:on:0:superAdj:0"in M: ref Scheduler":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F: ... 
 -- $ref:getAdr: "in M: ref Scheduler" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValu ... 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "M" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "M" E:  "M" 
 -- INV:gen:E.loadArgs "M" 
 -- $ObjectInvocation_Unary:loadArgs: "M" >staticOff:0 "in M: ref Scheduler" superAdj:0 
 -- $ref:loadArgs: "in M: ref Scheduler" >E:"M" 
 -- $pattern:loadArgs: "Scheduler: SuperScheduler{   thisScheduler::< Scheduler;   ProcessType::< BasicProcess;   %Public;   %Private;   dummyB: var Boolean;   inScheduler: va ..."} 
 -- ptn:loadArgs:E "M" 
 -- {(ObjectInvocation_Unary; (name: "M"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "M" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "M" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "M" >rec:"M" ATd:"ref" E:"M" E.ATd:"M" unique:"False" 
 -- OI:invoke: "M" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:M 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:M 
 -- OI:invoke:B: "M" E: "M"  rec: "M"  useRtnV: true "in M: ref Scheduler" 
 -- OI:invoke:before:ATdx.invoke: ref M 
 -- $ref:invoke: "in M: ref Scheduler" E: "M">newOff:2 useRTNv: "True" 
 -- DI:invoke: "in M: ref Scheduler" 
 -- >Object:unique: false 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"M":rec:M 
 -- isCompositeValueObj: false E: "M" "in M: ref Scheduler" false 
 -- E.ATd.isValueObj: false rec: "M" 
 rpushg attach$131 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"M":rec:M 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"M":rec:M 
 -- 
 -- OI:invoke:C: M :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"M":rec:M 
 -- rec: "main" dstE: "main" dstE.ATd: "main: ref SuperScheduler" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none ..." 
 -- dstDI.isBasicVal: false dstDI.isValObj: false dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- isValue: false  isAdr: true  descNo:  0 
 rswap 0
 rstoreg  EisNone 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-4,0)=[]
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  "attach" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 188 
 -- Items:GenClass: MonitorSystem descNo: 188 isValue: false 
 -- Items:GenClass: MonitorSystem descNo: 72 isValue: false 
 -- Items:GenClass: BasicSystem descNo: 21 isValue: false 

 CLASS MonitorSystem 188 10 MonitorSystemLib 43
 -- vdtTableCopy: I:1:72 I:2:0
 -- vdtAdd: inx=2 descInx=188 vDescInx=188 vdtTop: 2 
 -- Store itemArgs: %public{MonitorProcess: BasicProcess;   %globals Monitor, MonitorProcess(""), immutable, console;   -- we need to find out how to restrict Process to have  ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  10 origin
 -- super BasicSystem
 -- push:super.origin: 
 -- computeAdr:superAdj: 10 "LIB.BasicSystemLib.BasicSystem" 
 -- computeAdr: 1 :rec: "none"  E: "LIB" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:10 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "LIB"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "LIB" >on:2 superAdj:10 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 10 
 rpushg MonitorSystemLib$43 10
 -- items:goOrigin:encOG: "MonitorSystemLib" on: 2 isValueObj: false 
 -- origin: LIB origin:isValueObj: false 
 rpushg MonitorSystemLib$43 1
 -- items:goOrigin:encOG: "LIB" on: 1 isValueObj: false 
 -- origin: BETAworld origin:isValueObj: false 
 rpushg LIB$33 1
 -- $ObjectInvocation_Unary:getAdr: "LIB" >ATd.off:0 (isPtn):on:2:superAdj:10"--LIB{":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:10 isUnique:F isValue:F originIsValue:F:E ...} 
 -- $ModuleItem:getAdr: "--LIB{" } 
 -- $obj:getAdr: "LIB: obj {   %id "LIB";   %module BETA;   %Include BETA;   x_dummy_LIB: var integer;   --AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--C ..."} 
 -- E.on: 2 
 -- beforeIsValueObj:E: "LIB"  ATd: "--LIB{}" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "LIB"  E: "BasicSystemLib" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "BasicSystemLib" >ATd.off:0 (isPtn):on:0:superAdj:0"--BasicSystemLib{":Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue ...} 
 -- $ModuleItem:getAdr: "--BasicSystemLib{" } 
 -- $obj:getAdr: "BasicSystemLib: obj {   %module Collections, LIB.StringLib, LIB.Collections.QueueLib;   %include Collections, LIB.StringLib;   %public;   Lock: ;      %globa ..."} 
 -- $ObjectInvocation_Unary:loadArgs: "LIB" >staticOff:0 "--LIB{" superAdj:10} 
 -- $ModuleItem:loadArgs: "--LIB{" } 
 -- $ObjectInvocation_Unary:invoke: "LIB" >rec:"LIB" ATd:"ModuleItem" E:"BasicSystemLib" E.ATd:"BasicSystemLib" unique:"False" 
 -- OI:invoke: "LIB" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"BasicSystemLib":rec:LIB 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"BasicSystemLib":rec:LIB 
 -- OI:invoke:B: "LIB" E: "BasicSystemLib"  rec: "LIB"  useRtnV: true "--LIB{}" 
 -- OI:invoke:before:ATdx.invoke: ModuleItem LIB 
 -- $ModuleItem:invoke: "--LIB{" E: "BasicSystemLib" useRTNv: "True"} 
 -- ModuleItem:invoke: 
 -- $obj:invoke: "LIB: obj {   %id "LIB";   %module BETA;   %Include BETA;   x_dummy_LIB: var integer;   --AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--C ..."} 
 -- Module:invoke:adr<>none: false 
 rpushg LIB 3
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"BasicSystemLib":rec:LIB 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"BasicSystemLib":rec:LIB 
 -- 
 -- OI:invoke:C: LIB :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "LIB" E: "BasicSystemLib" 
 -- computeAdr: 3 :rec: "BasicSystemLib"  E: "BasicSystem" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "BasicSystem" >ATd.off:0 (isPtn):on:0:superAdj:0"BasicSystem: {   %public;   BasicProcess: GeneralProcess;      mkActive::< ;         statu ..."} 
 -- $pattern:getAdr: "BasicSystem: {   %public;   BasicProcess: GeneralProcess;      mkActive::< ;         status := p_status.ACTIVE;         SQS.insert(this(BasicProcess));   ..."} 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"BasicSystem":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "BasicSystemLib" >staticOff:0 "--BasicSystemLib{" superAdj:10} 
 -- $ModuleItem:loadArgs: "--BasicSystemLib{" } 
 -- $ObjectInvocation_Unary:invoke: "BasicSystemLib" >rec:"LIB" ATd:"ModuleItem" E:"BasicSystem" E.ATd:"BasicSystem" unique:"False" 
 -- OI:invoke: "BasicSystemLib" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"BasicSystem":rec:LIB 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"BasicSystem":rec:LIB 
 -- OI:invoke:B: "BasicSystemLib" E: "BasicSystem"  rec: "LIB"  useRtnV: true "--BasicSystemLib{}" 
 -- OI:invoke:before:ATdx.invoke: ModuleItem BasicSystemLib 
 -- $ModuleItem:invoke: "--BasicSystemLib{" E: "BasicSystem" useRTNv: "True"} 
 -- ModuleItem:invoke: 
 -- $obj:invoke: "BasicSystemLib: obj {   %module Collections, LIB.StringLib, LIB.Collections.QueueLib;   %include Collections, LIB.StringLib;   %public;   Lock: ;      %globa ..."} 
 -- Module:invoke:adr<>none: false 
 rpushg BasicSystemLib 4
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"BasicSystem":rec:LIB 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"BasicSystem":rec:LIB 
 -- 
 -- OI:invoke:C: BasicSystemLib :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "LIB" E: "BasicSystem" 
 -- computeAdr:isLast:E:  "BasicSystem" 
 -- genClass:after:pushAddress: "BasicSystem" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"BasicSystem":rec:LIB 
 -- handleSuperArgs:E: "BasicSystem" theIS: "%public{MonitorProcess: BasicProcess;   %globals Monitor, MonitorProcess(""), immutable, console;   -- we need to find out how to  ...}" 
 -- super.sig:not:none:superAdj: -10 
 -- $ObjectInvocation_Unary:loadArgs: "BasicSystem" >staticOff:0 "BasicSystem: {   %public;   BasicProcess: GeneralProcess;      mkActive::< ;         status := p_status.ACTIV ..."} 
 -- $pattern:loadArgs: "BasicSystem: {   %public;   BasicProcess: GeneralProcess;      mkActive::< ;         status := p_status.ACTIVE;         SQS.insert(this(BasicProcess)); ..."} 
 -- ptn:loadArgs:E "BasicSystem" 
 -- {(ObjectInvocation_Unary; (name: "BasicSystem"); (Arguments))} 
 -- args: "" 
 -- hArgOrg:super: BasicSystem 
 -- Store itemArgs: %public{MonitorProcess: BasicProcess;   %globals Monitor, MonitorProcess(""), immutable, console;   -- we need to find out how to restrict Process to have  ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=188 vDescInx=72 vdtTop: 2 
 -- $Property:gen: "%public"  
 -- $val:gen: "noOfCores: val 4"  
 -- DI:gen: "noOfCores: val 4" DI:isConst: true :isBasicValue: true :primNo: 1 
 -- DI:add:BP2:  noOfCores 
 -- $ObjectGenerator:gen: "4" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "4" 
 -- OG:before:super.gen: "4" 
 -- $Invocation:gen: "4" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "4" 
 -- isConstant: "Invocation" "4" 
 -- needorigin: "4" 
 -- needOrigin:E: "4"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "4" E:  "4" 
 -- INV:gen:E.loadArgs "4" 
 -- $ConstLiteral:loadArgs: "4"  
 -- INV:gen:after:E.loadArgs "4" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "4" 
 -- $ConstLiteral:invoke: "4"  
 pushc 4
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- dataItem:store:basicValue: off: 1  NewOff: 2 
 pushThis 
 storeg noOfCores 2
 -- $obj:gen: "cores: obj {   C1: ref Core;   C2: ref Core;   C3: ref Core;   C4: ref Core;   -- should be array         ;   init: ;      S: ref Scheduler;      C1 := Core;    ..."} 
 -- DI:gen: "cores: obj {   C1: ref Core;   C2: ref Core;   C3: ref Core;   C4: ref Core;   -- should be array         ;   init: ;      S: ref Scheduler;      C1 := Core;      ...}" D ... true : ... false : ... 0 
 -- DI:add:BP4:  cores 
 -- $ObjectGenerator:gen: "C1: ref Core{   C2: ref Core;   C3: ref Core;   C4: ref Core;   -- should be array         ;   init: ;      S: ref Scheduler;      C1 := Core;       ..."} 
 -- OG:gen: "C1: ref Core{   C2: ref Core;   C3: ref Core;   C4: ref Core;   -- should be array         ;   init: ;      S: ref Scheduler;      C1 := Core;      fork(C1);      ...}" 
 pushThis 
 -- before objTmpStack:add:  73   "cores" 
 invoke cores 73 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $obj:gen: "P_status: obj {   %globals;   %Public;   ACTIVE: val 1;   WAITING: val 2;   TERMINATED: val 3" } 
 -- DI:gen: "P_status: obj {   %globals;   %Public;   ACTIVE: val 1;   WAITING: val 2;   TERMINATED: val 3}" DI:isConst: true :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  P_status 
 -- $ObjectGenerator:gen: "%globals{   %Public;   ACTIVE: val 1;   WAITING: val 2;   TERMINATED: val 3" >OGid:"P_status" singular! staticOff=4 descNo=74 superAdj=0} 
 -- OG:gen: "%globals{   %Public;   ACTIVE: val 1;   WAITING: val 2;   TERMINATED: val 3}" 
 pushThis 
 -- before objTmpStack:add:  74   "P_status" 
 invoke P_status 74 4 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $obj:gen: "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      entry;         M := M +  ..."} 
 -- DI:gen: "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      entry;         M := M + 1; ...}" D ... true : ... false : ... 0 
 -- DI:add:BP4:  sch 
 -- $ObjectGenerator:gen: "L: obj Lock("Sch:lock"){   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      entry;         M := M + 1 ..."} 
 -- OG:gen: "L: obj Lock("Sch:lock"){   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      entry;         M := M + 1;   dcr: ;     ...}" 
 pushThis 
 -- before objTmpStack:add:  75   "sch" 
 invoke sch 75 5 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $obj:gen: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if (V  ..."} 
 -- DI:gen: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if (V >  ...}" D ... true : ... false : ... 0 
 -- DI:add:BP4:  SQS 
 -- $ObjectGenerator:gen: "Q: obj ProcessQueue{   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if (V > ..."} 
 -- OG:gen: "Q: obj ProcessQueue{   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if (V > 1) :then ;    ...}" 
 pushThis 
 -- before objTmpStack:add:  77   "SQS" 
 invoke SQS 77 6 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $obj:gen: "coreLock: obj Lock("CoreLock")"  
 -- DI:gen: "coreLock: obj Lock("CoreLock")" DI:isConst: true :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  coreLock 
 -- $ObjectGenerator:gen: "Lock("CoreLock")" >OGid:"Lock" IS.isempty! staticOff=7 descNo=0 superAdj=0 
 -- OG:gen: "Lock("CoreLock")" 
 -- OG:before:super.gen: "Lock("CoreLock")" 
 -- $Invocation:gen: "Lock("CoreLock")" >useRtnV:"False"superAdj: 0 descNo: 76 
 -- INV:gen: "Lock("CoreLock")" 
 -- isConstant: "Invocation" "Lock("CoreLock")" 
 -- needorigin: "Lock("CoreLock")" 
 -- needOrigin:E: "Lock("CoreLock")"  E.ATd: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   g ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%globals{   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ; ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "Lock("CoreLock")" E:  "Lock("CoreLock")" 
 -- INV:gen:E.loadArgs "Lock("CoreLock")" 
 -- $ObjectInvocation_KeyWord:loadArgs: "Lock("CoreLock")" >staticOff:0 "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   in ..."} 
 -- $pattern:loadArgs: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ; ..."} 
 -- ptn:loadArgs:E "Lock("CoreLock")" 
 -- {(ObjectInvocation_KeyWord; (name: "Lock"); (Arguments;  (name: "Lock");  (name: "(");  (ObjectGenerator;   (Invocation;    (String: CoreLock));   (Items descNo: 0 origDes ...} 
 -- args: "Lock("CoreLock")" 
 -- E: "ObjectGenerator" "CoreLock" 
 -- E.arg: "var" in id: var String 
 -- NonVirt: "Lock("CoreLock")" "ObjectInvocation_KeyWord" ActArg:  ""CoreLock"" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "Lock("CoreLock")"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: ""CoreLock"" >OGid:"String" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: ""CoreLock"" 
 -- OG:before:super.gen: ""CoreLock"" 
 -- $Invocation:gen: ""CoreLock"" >useRtnV:"True"superAdj: 0 
 -- INV:gen: ""CoreLock"" 
 -- isConstant: "Invocation" ""CoreLock"" 
 -- needorigin: ""CoreLock"" 
 -- needOrigin:E: ""CoreLock""  E.ATd: "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V : ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  ""CoreLock"" E:  ""CoreLock"" 
 -- INV:gen:E.loadArgs ""CoreLock"" 
 -- $String::loadArgs: ""CoreLock""  
 -- INV:gen:after:E.loadArgs ""CoreLock"" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: String: ""CoreLock"" 
 -- $String::invoke: ""CoreLock""  
 pushText "CoreLock"
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in id: var String" :isBasicVal: false :valueObj: false 
 -- :actArg: ""CoreLock"" :isBasicVal: false 
 -- case:B: "CoreLock" ObjectGenerator 5 5 5 false false 
 -- end:loadArgs:NonVirt: "Lock("CoreLock")" 
 -- INV:gen:after:E.loadArgs "Lock("CoreLock")" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "Lock("CoreLock")" 
 -- $ObjectInvocation_KeyWord:invoke: "Lock("CoreLock")" >rec:"Lock("CoreLock")" ATd:"pattern" E:"Lock("CoreLock")" E.ATd:"Lock" unique:"False" 
 -- OI:invoke: "Lock("CoreLock")" 
 -- 
 -- OI:invoke:B: "Lock("CoreLock")" E: "Lock("CoreLock")"  rec: "Lock("CoreLock")"  useRtnV: false "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: v ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Lock 
 -- $pattern:invoke: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ;   ..."} 
 -- ptn:invoke: "Lock" E: "Lock("CoreLock")" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 7 adr:none 
 invoke Lock 76 7 1
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: Lock("CoreLock") :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- $obj:gen: "console: obj {   L: obj Lock("Console:lock");   %public;   display: ;      L.get;      inner(display);      L.free;   L.init" } 
 -- DI:gen: "console: obj {   L: obj Lock("Console:lock");   %public;   display: ;      L.get;      inner(display);      L.free;   L.init}" DI:isConst: true :isBasicValue: false : ... 0 
 -- DI:add:BP4:  console 
 -- $ObjectGenerator:gen: "L: obj Lock("Console:lock"){   %public;   display: ;      L.get;      inner(display);      L.free;   L.init" >OGid:"console" singular! staticOff=8 d ...} 
 -- OG:gen: "L: obj Lock("Console:lock"){   %public;   display: ;      L.get;      inner(display);      L.free;   L.init}" 
 pushThis 
 -- before objTmpStack:add:  80   "console" 
 invoke console 80 8 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -5 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $obj:gen: "keyboard: obj BasicProcess("Keyboard"){   B: obj Indexed(100,integer);   next: var integer;   top: var integer;   echo: var Boolean;   %Public;   Kscan: ;       ..."} 
 -- DI:gen: "keyboard: obj BasicProcess("Keyboard"){   B: obj Indexed(100,integer);   next: var integer;   top: var integer;   echo: var Boolean;   %Public;   Kscan: ;      lo ...}" D ... true : ... false : ... 0 
 -- DI:add:BP4:  keyboard 
 -- $ObjectGenerator:gen: "BasicProcess("Keyboard"){   B: obj Indexed(100,integer);   next: var integer;   top: var integer;   echo: var Boolean;   %Public;   Kscan: ;      lo ..."} 
 -- OG:gen: "BasicProcess("Keyboard"){   B: obj Indexed(100,integer);   next: var integer;   top: var integer;   echo: var Boolean;   %Public;   Kscan: ;      loopB: obj ;     ...}" 
 pushThis 
 -- before objTmpStack:add:  85   "keyboard" 
 invoke keyboard 85 9 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -6 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $Property:gen: "%public"  
 rtnAlloc 1
 toSuper 72
DO:
 mvStack 
 L1:
 -- genclass:stmt: "%public" 
 -- $Property:gen: "%public"  
 -- genclass:stmt: "inner(MonitorSystem)" 
 -- $ObjectGenerator:gen: "inner(MonitorSystem)" >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inner(MonitorSystem)" 
 -- OG:before:super.gen: "inner(MonitorSystem)" 
 -- $Invocation:gen: "inner(MonitorSystem)" >useRtnV:"False"superAdj: 0 descNo: 12 
 -- INV:gen: "inner(MonitorSystem)" 
 -- isConstant: "Invocation" "inner(MonitorSystem)" 
 -- needorigin: "inner(MonitorSystem)" 
 -- needOrigin:E: "inner(MonitorSystem)"  E.ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- doNeedOrigin:Ex: "inner(MonitorSystem)" 
 -- computeAdr:superAdj: 0 "inner(MonitorSystem)" 
 -- computeAdr: 1 :rec: "none"  E: "inner(MonitorSystem)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "inner(MonitorSystem)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "inner(MonitorSystem)" >on:2 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "inner(MonitorSystem)" >ATd.off:0 (isPtn):on:2:superAdj:0"inner: {   %basic 101;   in inner: ref Object":Adr:off:0 size:0 isFloat:F isUni ...} 
 -- $pattern:getAdr: "inner: {   %basic 101;   in inner: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(MonitorSystem)":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inner(MonitorSystem)"  ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(MonitorSystem)":rec:- 
 -- computeAdr:isLast:E:  "inner(MonitorSystem)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(MonitorSystem)":rec:- 
 -- rec:  "inner(MonitorSystem)" E:  "inner(MonitorSystem)" 
 -- INV:gen:E.loadArgs "inner(MonitorSystem)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "inner(MonitorSystem)" >staticOff:0 "inner: {   %basic 101;   in inner: ref Object" superAdj:0arg:"MonitorSystem"} 
 -- $pattern:loadArgs: "inner: {   %basic 101;   in inner: ref Object" >E:"inner(MonitorSystem)":descNo:12} 
 -- INV:gen:after:E.loadArgs "inner(MonitorSystem)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(MonitorSystem)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- $ObjectInvocation_KeyWord:invoke: "inner(MonitorSystem)" >rec:"inner(MonitorSystem)" ATd:"pattern" E:"inner(MonitorSystem)" E.ATd:"inner" unique:"False" 
 -- OI:invoke: "inner(MonitorSystem)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(MonitorSystem)":rec:inner(MonitorSystem) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(MonitorSystem)":rec:inner(MonitorSystem) 
 -- OI:invoke:B: "inner(MonitorSystem)" E: "inner(MonitorSystem)"  rec: "inner(MonitorSystem)"  useRtnV: false "inner: {   %basic 101;   in inner: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- $pattern:invoke: "inner: {   %basic 101;   in inner: ref Object" E: "inner(MonitorSystem)" useRTNv: "False"} 
 -- ptn:invoke: "inner" E: "inner(MonitorSystem)" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  3
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(MonitorSystem)":rec:inner(MonitorSystem) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(MonitorSystem)":rec:inner(MonitorSystem) 
 -- 
 -- OI:invoke:C: inner(MonitorSystem) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(MonitorSystem)":rec:inner(MonitorSystem) 
 L2:
 rtnInner  M
 END OSDV:0 objSize:10 isIndexed:0
 -- vdtAdd: inx=3 descInx=188 vDescInx=0 vdtTop: 3 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 189 
 -- Items:GenClass: MonitorDemo descNo: 189 isValue: false 
 -- Items:GenClass: MonitorDemo descNo: 188 isValue: false 
 -- Items:GenClass: MonitorSystem descNo: 72 isValue: false 
 -- Items:GenClass: BasicSystem descNo: 21 isValue: false 

 CLASS MonitorDemo 189 11 demo 71
 -- vdtTableCopy: I:1:72 I:2:188 I:3:0
 -- vdtAdd: inx=3 descInx=189 vDescInx=189 vdtTop: 3 
 -- Store itemArgs: %requires MonitorSystemLib{%include LIB.StringLib;P1: obj MonitorProcess("PP1");   fac(V: var integer): ;      out res: var integer;      if (V = 1) :then  ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  11 origin
 -- super MonitorSystem
 -- push:super.origin: 
 -- computeAdr:superAdj: 11 "LIB.MonitorSystemLib.MonitorSystem" 
 -- computeAdr: 1 :rec: "none"  E: "LIB" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:11 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "LIB"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "LIB" >on:2 superAdj:11 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 11 
 rpushg demo$71 11
 -- items:goOrigin:encOG: "demo" on: 2 isValueObj: false 
 -- origin: workspace origin:isValueObj: false 
 rpushg demo$71 1
 -- items:goOrigin:encOG: "workspace" on: 1 isValueObj: false 
 -- origin: BETAworld origin:isValueObj: false 
 rpushg workspace$70 1
 -- $ObjectInvocation_Unary:getAdr: "LIB" >ATd.off:0 (isPtn):on:2:superAdj:11"--LIB{":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:11 isUnique:F isValue:F originIsValue:F:E ...} 
 -- $ModuleItem:getAdr: "--LIB{" } 
 -- $obj:getAdr: "LIB: obj {   %id "LIB";   %module BETA;   %Include BETA;   x_dummy_LIB: var integer;   --AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--C ..."} 
 -- E.on: 2 
 -- beforeIsValueObj:E: "LIB"  ATd: "--LIB{}" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "LIB"  E: "MonitorSystemLib" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "MonitorSystemLib" >ATd.off:0 (isPtn):on:0:superAdj:0"--MonitorSystemLib{":Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV ...} 
 -- $ModuleItem:getAdr: "--MonitorSystemLib{" } 
 -- $obj:getAdr: "MonitorSystemLib: obj {   %domain_boundary;   %visible LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib;   %module LIB.BasicSystemLib, LIB.BasicSystemLib. ..."} 
 -- $ObjectInvocation_Unary:loadArgs: "LIB" >staticOff:0 "--LIB{" superAdj:11} 
 -- $ModuleItem:loadArgs: "--LIB{" } 
 -- $ObjectInvocation_Unary:invoke: "LIB" >rec:"LIB" ATd:"ModuleItem" E:"MonitorSystemLib" E.ATd:"MonitorSystemLib" unique:"False" 
 -- OI:invoke: "LIB" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"MonitorSystemLib":rec:LIB 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"MonitorSystemLib":rec:LIB 
 -- OI:invoke:B: "LIB" E: "MonitorSystemLib"  rec: "LIB"  useRtnV: true "--LIB{}" 
 -- OI:invoke:before:ATdx.invoke: ModuleItem LIB 
 -- $ModuleItem:invoke: "--LIB{" E: "MonitorSystemLib" useRTNv: "True"} 
 -- ModuleItem:invoke: 
 -- $obj:invoke: "LIB: obj {   %id "LIB";   %module BETA;   %Include BETA;   x_dummy_LIB: var integer;   --AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--C ..."} 
 -- Module:invoke:adr<>none: false 
 rpushg LIB 3
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"MonitorSystemLib":rec:LIB 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"MonitorSystemLib":rec:LIB 
 -- 
 -- OI:invoke:C: LIB :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "LIB" E: "MonitorSystemLib" 
 -- computeAdr: 3 :rec: "MonitorSystemLib"  E: "MonitorSystem" 
 -- :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "MonitorSystem" >ATd.off:0 (isPtn):on:0:superAdj:0"MonitorSystem: LIB.BasicSystemLib.BasicSystem{   %public;   MonitorProcess: BasicProcess ..."} 
 -- $pattern:getAdr: "MonitorSystem: LIB.BasicSystemLib.BasicSystem{   %public;   MonitorProcess: BasicProcess;      %globals Monitor, MonitorProcess(""), immutable, console;  ..."} 
 -- :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"MonitorSystem":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "MonitorSystemLib" >staticOff:0 "--MonitorSystemLib{" superAdj:11} 
 -- $ModuleItem:loadArgs: "--MonitorSystemLib{" } 
 -- $ObjectInvocation_Unary:invoke: "MonitorSystemLib" >rec:"LIB" ATd:"ModuleItem" E:"MonitorSystem" E.ATd:"MonitorSystem" unique:"False" 
 -- OI:invoke: "MonitorSystemLib" 
 -- :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"MonitorSystem":rec:LIB 
 -- :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"MonitorSystem":rec:LIB 
 -- OI:invoke:B: "MonitorSystemLib" E: "MonitorSystem"  rec: "LIB"  useRtnV: true "--MonitorSystemLib{}" 
 -- OI:invoke:before:ATdx.invoke: ModuleItem MonitorSystemLib 
 -- $ModuleItem:invoke: "--MonitorSystemLib{" E: "MonitorSystem" useRTNv: "True"} 
 -- ModuleItem:invoke: 
 -- $obj:invoke: "MonitorSystemLib: obj {   %domain_boundary;   %visible LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib;   %module LIB.BasicSystemLib, LIB.BasicSystemLib. ..."} 
 -- Module:invoke:adr<>none: false 
 rpushg MonitorSystemLib 7
 -- OI:invoke:V: adr: :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"MonitorSystem":rec:LIB 
 -- 
 -- OI:invoke:X: adr: :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"MonitorSystem":rec:LIB 
 -- 
 -- OI:invoke:C: MonitorSystemLib :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "LIB" E: "MonitorSystem" 
 -- computeAdr:isLast:E:  "MonitorSystem" 
 -- genClass:after:pushAddress: "MonitorSystem" :Adr:off:7 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"MonitorSystem":rec:LIB 
 -- handleSuperArgs:E: "MonitorSystem" theIS: "%requires MonitorSystemLib{%include LIB.StringLib;P1: obj MonitorProcess("PP1");   fac(V: var integer): ;      out res: var inte ...}" 
 -- super.sig:not:none:superAdj: -11 
 -- $ObjectInvocation_Unary:loadArgs: "MonitorSystem" >staticOff:0 "MonitorSystem: LIB.BasicSystemLib.BasicSystem{   %public;   MonitorProcess: BasicProcess;      %globals Mon ..."} 
 -- $pattern:loadArgs: "MonitorSystem: LIB.BasicSystemLib.BasicSystem{   %public;   MonitorProcess: BasicProcess;      %globals Monitor, MonitorProcess(""), immutable, console ..."} 
 -- ptn:loadArgs:E "MonitorSystem" 
 -- {(ObjectInvocation_Unary; (name: "MonitorSystem"); (Arguments))} 
 -- args: "" 
 -- hArgOrg:super: MonitorSystem 
 -- Store itemArgs: %requires MonitorSystemLib{%include LIB.StringLib;P1: obj MonitorProcess("PP1");   fac(V: var integer): ;      out res: var integer;      if (V = 1) :then  ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  10 origin
 -- super MonitorSystem
 -- push:super.origin: 
 -- computeAdr:superAdj: 10 "LIB.BasicSystemLib.BasicSystem" 
 -- computeAdr: 1 :rec: "none"  E: "LIB" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:10 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "LIB"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "LIB" >on:2 superAdj:10 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 10 
 rpushg MonitorSystemLib$43 10
 -- items:goOrigin:encOG: "MonitorSystemLib" on: 2 isValueObj: false 
 -- origin: LIB origin:isValueObj: false 
 rpushg MonitorSystemLib$43 1
 -- items:goOrigin:encOG: "LIB" on: 1 isValueObj: false 
 -- origin: BETAworld origin:isValueObj: false 
 rpushg LIB$33 1
 -- $ObjectInvocation_Unary:getAdr: "LIB" >ATd.off:0 (isPtn):on:2:superAdj:10"--LIB{":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:10 isUnique:F isValue:F originIsValue:F:E ...} 
 -- $ModuleItem:getAdr: "--LIB{" } 
 -- $obj:getAdr: "LIB: obj {   %id "LIB";   %module BETA;   %Include BETA;   x_dummy_LIB: var integer;   --AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--C ..."} 
 -- E.on: 2 
 -- beforeIsValueObj:E: "LIB"  ATd: "--LIB{}" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "LIB"  E: "BasicSystemLib" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "BasicSystemLib" >ATd.off:0 (isPtn):on:0:superAdj:0"--BasicSystemLib{":Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue ...} 
 -- $ModuleItem:getAdr: "--BasicSystemLib{" } 
 -- $obj:getAdr: "BasicSystemLib: obj {   %module Collections, LIB.StringLib, LIB.Collections.QueueLib;   %include Collections, LIB.StringLib;   %public;   Lock: ;      %globa ..."} 
 -- $ObjectInvocation_Unary:loadArgs: "LIB" >staticOff:0 "--LIB{" superAdj:10} 
 -- $ModuleItem:loadArgs: "--LIB{" } 
 -- $ObjectInvocation_Unary:invoke: "LIB" >rec:"LIB" ATd:"ModuleItem" E:"BasicSystemLib" E.ATd:"BasicSystemLib" unique:"False" 
 -- OI:invoke: "LIB" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"BasicSystemLib":rec:LIB 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"BasicSystemLib":rec:LIB 
 -- OI:invoke:B: "LIB" E: "BasicSystemLib"  rec: "LIB"  useRtnV: true "--LIB{}" 
 -- OI:invoke:before:ATdx.invoke: ModuleItem LIB 
 -- $ModuleItem:invoke: "--LIB{" E: "BasicSystemLib" useRTNv: "True"} 
 -- ModuleItem:invoke: 
 -- $obj:invoke: "LIB: obj {   %id "LIB";   %module BETA;   %Include BETA;   x_dummy_LIB: var integer;   --AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--C ..."} 
 -- Module:invoke:adr<>none: false 
 rpushg LIB 3
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"BasicSystemLib":rec:LIB 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"BasicSystemLib":rec:LIB 
 -- 
 -- OI:invoke:C: LIB :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "LIB" E: "BasicSystemLib" 
 -- computeAdr: 3 :rec: "BasicSystemLib"  E: "BasicSystem" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "BasicSystem" >ATd.off:0 (isPtn):on:0:superAdj:0"BasicSystem: {   %public;   BasicProcess: GeneralProcess;      mkActive::< ;         statu ..."} 
 -- $pattern:getAdr: "BasicSystem: {   %public;   BasicProcess: GeneralProcess;      mkActive::< ;         status := p_status.ACTIVE;         SQS.insert(this(BasicProcess));   ..."} 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"BasicSystem":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "BasicSystemLib" >staticOff:0 "--BasicSystemLib{" superAdj:10} 
 -- $ModuleItem:loadArgs: "--BasicSystemLib{" } 
 -- $ObjectInvocation_Unary:invoke: "BasicSystemLib" >rec:"LIB" ATd:"ModuleItem" E:"BasicSystem" E.ATd:"BasicSystem" unique:"False" 
 -- OI:invoke: "BasicSystemLib" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"BasicSystem":rec:LIB 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"BasicSystem":rec:LIB 
 -- OI:invoke:B: "BasicSystemLib" E: "BasicSystem"  rec: "LIB"  useRtnV: true "--BasicSystemLib{}" 
 -- OI:invoke:before:ATdx.invoke: ModuleItem BasicSystemLib 
 -- $ModuleItem:invoke: "--BasicSystemLib{" E: "BasicSystem" useRTNv: "True"} 
 -- ModuleItem:invoke: 
 -- $obj:invoke: "BasicSystemLib: obj {   %module Collections, LIB.StringLib, LIB.Collections.QueueLib;   %include Collections, LIB.StringLib;   %public;   Lock: ;      %globa ..."} 
 -- Module:invoke:adr<>none: false 
 rpushg BasicSystemLib 4
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"BasicSystem":rec:LIB 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"BasicSystem":rec:LIB 
 -- 
 -- OI:invoke:C: BasicSystemLib :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "LIB" E: "BasicSystem" 
 -- computeAdr:isLast:E:  "BasicSystem" 
 -- genClass:after:pushAddress: "BasicSystem" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"BasicSystem":rec:LIB 
 -- handleSuperArgs:E: "BasicSystem" theIS: "%public{MonitorProcess: BasicProcess;   %globals Monitor, MonitorProcess(""), immutable, console;   -- we need to find out how to  ...}" 
 -- super.sig:not:none:superAdj: -11 
 -- $ObjectInvocation_Unary:loadArgs: "BasicSystem" >staticOff:0 "BasicSystem: {   %public;   BasicProcess: GeneralProcess;      mkActive::< ;         status := p_status.ACTIV ..."} 
 -- $pattern:loadArgs: "BasicSystem: {   %public;   BasicProcess: GeneralProcess;      mkActive::< ;         status := p_status.ACTIVE;         SQS.insert(this(BasicProcess)); ..."} 
 -- ptn:loadArgs:E "BasicSystem" 
 -- {(ObjectInvocation_Unary; (name: "BasicSystem"); (Arguments))} 
 -- args: "" 
 -- hArgOrg:super: BasicSystem 
 -- Store itemArgs: %requires MonitorSystemLib{%include LIB.StringLib;P1: obj MonitorProcess("PP1");   fac(V: var integer): ;      out res: var integer;      if (V = 1) :then  ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=189 vDescInx=72 vdtTop: 3 
 -- $Property:gen: "%public"  
 -- $val:gen: "noOfCores: val 4"  
 -- DI:gen: "noOfCores: val 4" DI:isConst: true :isBasicValue: true :primNo: 1 
 -- DI:add:BP2:  noOfCores 
 -- $ObjectGenerator:gen: "4" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "4" 
 -- OG:before:super.gen: "4" 
 -- $Invocation:gen: "4" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "4" 
 -- isConstant: "Invocation" "4" 
 -- needorigin: "4" 
 -- needOrigin:E: "4"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "4" E:  "4" 
 -- INV:gen:E.loadArgs "4" 
 -- $ConstLiteral:loadArgs: "4"  
 -- INV:gen:after:E.loadArgs "4" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "4" 
 -- $ConstLiteral:invoke: "4"  
 pushc 4
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- dataItem:store:basicValue: off: 1  NewOff: 2 
 pushThis 
 storeg noOfCores 2
 -- $obj:gen: "cores: obj {   C1: ref Core;   C2: ref Core;   C3: ref Core;   C4: ref Core;   -- should be array         ;   init: ;      S: ref Scheduler;      C1 := Core;    ..."} 
 -- DI:gen: "cores: obj {   C1: ref Core;   C2: ref Core;   C3: ref Core;   C4: ref Core;   -- should be array         ;   init: ;      S: ref Scheduler;      C1 := Core;      ...}" D ... true : ... false : ... 0 
 -- DI:add:BP4:  cores 
 -- $ObjectGenerator:gen: "C1: ref Core{   C2: ref Core;   C3: ref Core;   C4: ref Core;   -- should be array         ;   init: ;      S: ref Scheduler;      C1 := Core;       ..."} 
 -- OG:gen: "C1: ref Core{   C2: ref Core;   C3: ref Core;   C4: ref Core;   -- should be array         ;   init: ;      S: ref Scheduler;      C1 := Core;      fork(C1);      ...}" 
 pushThis 
 -- before objTmpStack:add:  73   "cores" 
 invoke cores 73 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $obj:gen: "P_status: obj {   %globals;   %Public;   ACTIVE: val 1;   WAITING: val 2;   TERMINATED: val 3" } 
 -- DI:gen: "P_status: obj {   %globals;   %Public;   ACTIVE: val 1;   WAITING: val 2;   TERMINATED: val 3}" DI:isConst: true :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  P_status 
 -- $ObjectGenerator:gen: "%globals{   %Public;   ACTIVE: val 1;   WAITING: val 2;   TERMINATED: val 3" >OGid:"P_status" singular! staticOff=4 descNo=74 superAdj=0} 
 -- OG:gen: "%globals{   %Public;   ACTIVE: val 1;   WAITING: val 2;   TERMINATED: val 3}" 
 pushThis 
 -- before objTmpStack:add:  74   "P_status" 
 invoke P_status 74 4 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $obj:gen: "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      entry;         M := M +  ..."} 
 -- DI:gen: "sch: obj {   L: obj Lock("Sch:lock");   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      entry;         M := M + 1; ...}" D ... true : ... false : ... 0 
 -- DI:add:BP4:  sch 
 -- $ObjectGenerator:gen: "L: obj Lock("Sch:lock"){   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      entry;         M := M + 1 ..."} 
 -- OG:gen: "L: obj Lock("Sch:lock"){   M: var integer;   %Public;   entry: ;      L.get;      inner(entry);      L.free;   add: ;      entry;         M := M + 1;   dcr: ;     ...}" 
 pushThis 
 -- before objTmpStack:add:  75   "sch" 
 invoke sch 75 5 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $obj:gen: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if (V  ..."} 
 -- DI:gen: "SQS: obj {   Q: obj ProcessQueue;   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if (V >  ...}" D ... true : ... false : ... 0 
 -- DI:add:BP4:  SQS 
 -- $ObjectGenerator:gen: "Q: obj ProcessQueue{   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if (V > ..."} 
 -- OG:gen: "Q: obj ProcessQueue{   L: obj Lock("SQS:Lock:");   V: var integer;   W: var integer;   %Public;   entry: ;      L.get;      V := V + 1;      if (V > 1) :then ;    ...}" 
 pushThis 
 -- before objTmpStack:add:  77   "SQS" 
 invoke SQS 77 6 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $obj:gen: "coreLock: obj Lock("CoreLock")"  
 -- DI:gen: "coreLock: obj Lock("CoreLock")" DI:isConst: true :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  coreLock 
 -- $ObjectGenerator:gen: "Lock("CoreLock")" >OGid:"Lock" IS.isempty! staticOff=7 descNo=0 superAdj=0 
 -- OG:gen: "Lock("CoreLock")" 
 -- OG:before:super.gen: "Lock("CoreLock")" 
 -- $Invocation:gen: "Lock("CoreLock")" >useRtnV:"False"superAdj: 0 descNo: 76 
 -- INV:gen: "Lock("CoreLock")" 
 -- isConstant: "Invocation" "Lock("CoreLock")" 
 -- needorigin: "Lock("CoreLock")" 
 -- needOrigin:E: "Lock("CoreLock")"  E.ATd: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   g ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%globals{   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ; ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "Lock("CoreLock")" E:  "Lock("CoreLock")" 
 -- INV:gen:E.loadArgs "Lock("CoreLock")" 
 -- $ObjectInvocation_KeyWord:loadArgs: "Lock("CoreLock")" >staticOff:0 "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   in ..."} 
 -- $pattern:loadArgs: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ; ..."} 
 -- ptn:loadArgs:E "Lock("CoreLock")" 
 -- {(ObjectInvocation_KeyWord; (name: "Lock"); (Arguments;  (name: "Lock");  (name: "(");  (ObjectGenerator;   (Invocation;    (String: CoreLock));   (Items descNo: 0 origDes ...} 
 -- args: "Lock("CoreLock")" 
 -- E: "ObjectGenerator" "CoreLock" 
 -- E.arg: "var" in id: var String 
 -- NonVirt: "Lock("CoreLock")" "ObjectInvocation_KeyWord" ActArg:  ""CoreLock"" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "Lock("CoreLock")"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: ""CoreLock"" >OGid:"String" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: ""CoreLock"" 
 -- OG:before:super.gen: ""CoreLock"" 
 -- $Invocation:gen: ""CoreLock"" >useRtnV:"True"superAdj: 0 
 -- INV:gen: ""CoreLock"" 
 -- isConstant: "Invocation" ""CoreLock"" 
 -- needorigin: ""CoreLock"" 
 -- needOrigin:E: ""CoreLock""  E.ATd: "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V : ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  ""CoreLock"" E:  ""CoreLock"" 
 -- INV:gen:E.loadArgs ""CoreLock"" 
 -- $String::loadArgs: ""CoreLock""  
 -- INV:gen:after:E.loadArgs ""CoreLock"" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: String: ""CoreLock"" 
 -- $String::invoke: ""CoreLock""  
 pushText "CoreLock"
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in id: var String" :isBasicVal: false :valueObj: false 
 -- :actArg: ""CoreLock"" :isBasicVal: false 
 -- case:B: "CoreLock" ObjectGenerator 5 5 5 false false 
 -- end:loadArgs:NonVirt: "Lock("CoreLock")" 
 -- INV:gen:after:E.loadArgs "Lock("CoreLock")" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "Lock("CoreLock")" 
 -- $ObjectInvocation_KeyWord:invoke: "Lock("CoreLock")" >rec:"Lock("CoreLock")" ATd:"pattern" E:"Lock("CoreLock")" E.ATd:"Lock" unique:"False" 
 -- OI:invoke: "Lock("CoreLock")" 
 -- 
 -- OI:invoke:B: "Lock("CoreLock")" E: "Lock("CoreLock")"  rec: "Lock("CoreLock")"  useRtnV: false "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: v ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Lock 
 -- $pattern:invoke: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ;   ..."} 
 -- ptn:invoke: "Lock" E: "Lock("CoreLock")" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 7 adr:none 
 invoke Lock 76 7 1
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: Lock("CoreLock") :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- $obj:gen: "console: obj {   L: obj Lock("Console:lock");   %public;   display: ;      L.get;      inner(display);      L.free;   L.init" } 
 -- DI:gen: "console: obj {   L: obj Lock("Console:lock");   %public;   display: ;      L.get;      inner(display);      L.free;   L.init}" DI:isConst: true :isBasicValue: false : ... 0 
 -- DI:add:BP4:  console 
 -- $ObjectGenerator:gen: "L: obj Lock("Console:lock"){   %public;   display: ;      L.get;      inner(display);      L.free;   L.init" >OGid:"console" singular! staticOff=8 d ...} 
 -- OG:gen: "L: obj Lock("Console:lock"){   %public;   display: ;      L.get;      inner(display);      L.free;   L.init}" 
 pushThis 
 -- before objTmpStack:add:  80   "console" 
 invoke console 80 8 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -5 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $obj:gen: "keyboard: obj BasicProcess("Keyboard"){   B: obj Indexed(100,integer);   next: var integer;   top: var integer;   echo: var Boolean;   %Public;   Kscan: ;       ..."} 
 -- DI:gen: "keyboard: obj BasicProcess("Keyboard"){   B: obj Indexed(100,integer);   next: var integer;   top: var integer;   echo: var Boolean;   %Public;   Kscan: ;      lo ...}" D ... true : ... false : ... 0 
 -- DI:add:BP4:  keyboard 
 -- $ObjectGenerator:gen: "BasicProcess("Keyboard"){   B: obj Indexed(100,integer);   next: var integer;   top: var integer;   echo: var Boolean;   %Public;   Kscan: ;      lo ..."} 
 -- OG:gen: "BasicProcess("Keyboard"){   B: obj Indexed(100,integer);   next: var integer;   top: var integer;   echo: var Boolean;   %Public;   Kscan: ;      loopB: obj ;     ...}" 
 pushThis 
 -- before objTmpStack:add:  85   "keyboard" 
 invoke keyboard 85 9 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -6 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $Property:gen: "%public"  
 -- $Property:gen: "%requires MonitorSystemLib"  
 -- $Property:gen: "%include LIB.StringLib"  
 -- $obj:gen: "P1: obj MonitorProcess("PP1"){   fac(V: var integer): ;      out res: var integer;      if (V = 1) :then ;         res := 1;      :else ;         res := V * fac ..."} 
 -- DI:gen: "P1: obj MonitorProcess("PP1"){   fac(V: var integer): ;      out res: var integer;      if (V = 1) :then ;         res := 1;      :else ;         res := V * fac(V ...}" D ... true : ... false : ... 0 
 -- DI:add:BP4:  P1 
 -- $ObjectGenerator:gen: "MonitorProcess("PP1"){   fac(V: var integer): ;      out res: var integer;      if (V = 1) :then ;         res := 1;      :else ;         res := V * ..."} 
 -- OG:gen: "MonitorProcess("PP1"){   fac(V: var integer): ;      out res: var integer;      if (V = 1) :then ;         res := 1;      :else ;         res := V * fac(V - 1);   ...}" 
 pushThis 
 -- before objTmpStack:add:  191   "P1" 
 invoke P1 191 12 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -7 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $obj:gen: "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var integer): entry;      put(10);      ..."} 
 -- DI:gen: "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var integer): entry;      put(10);      p ...}" D ... true : ... false : ... 0 
 -- DI:add:BP4:  myM 
 -- $ObjectGenerator:gen: "Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var integer): entry;      put(10);   ..."} 
 -- OG:gen: "Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var integer): entry;      put(10);      put('<');  ...}" 
 pushThis 
 -- before objTmpStack:add:  217   "myM" 
 invoke myM 217 13 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -8 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $obj:gen: "P2: obj MonitorProcess("PP2"){   sum(V: var integer): ;      out res: var integer;      for(1):to(10):repeat;         res := res + V;      ;   myM.print("P2 res ...} 
 -- DI:gen: "P2: obj MonitorProcess("PP2"){   sum(V: var integer): ;      out res: var integer;      for(1):to(10):repeat;         res := res + V;      ;   myM.print("P2 resum ..."}" D ... true : ... false : ... 0 
 -- DI:add:BP4:  P2 
 -- $ObjectGenerator:gen: "MonitorProcess("PP2"){   sum(V: var integer): ;      out res: var integer;      for(1):to(10):repeat;         res := res + V;      ;   myM.print("P2 ...} 
 -- OG:gen: "MonitorProcess("PP2"){   sum(V: var integer): ;      out res: var integer;      for(1):to(10):repeat;         res := res + V;      ;   myM.print("P2 resumed\n");  ...}" 
 pushThis 
 -- before objTmpStack:add:  218   "P2" 
 invoke P2 218 14 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -9 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
 toSuper 72
DO:
 mvStack 
 L1:
 -- genclass:stmt: "%requires MonitorSystemLib" 
 -- $Property:gen: "%requires MonitorSystemLib"  
 -- genclass:stmt: "%include LIB.StringLib" 
 -- $Property:gen: "%include LIB.StringLib"  
 -- genclass:stmt: "myM.init" 
 -- $ObjectGenerator:gen: "myM.init" >OGid:"init" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "myM.init" 
 -- OG:before:super.gen: "myM.init" 
 -- $Invocation:gen: "myM.init" >useRtnV:"False"superAdj: 0 descNo: 224 
 -- INV:gen: "myM.init" 
 -- isConstant: "Invocation" "myM.init" 
 -- needorigin: "myM.init" 
 -- needOrigin:E: "init"  E.ATd: "init:< entry{   "Monitor:init\n".print;   inner(init)}" 
 -- doNeedOrigin:Ex: "init" 
 -- computeAdr:superAdj: 0 "myM.init" 
 -- computeAdr: 1 :rec: "none"  E: "myM" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "myM"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "myM" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "myM" >ATd.off:13:on:0:superAdj:0"myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var in ..."} 
 -- $obj:getAdr: "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var integer): entry;      put(10);   ..."} 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "myM"  E: "init" 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "init" >ATd.off:0 (isPtn):on:0:superAdj:0"init:< entry{   "Monitor:init\n".print;   inner(init)":Adr:off:13 size:0 isFloat:F isUnitVal:F su ...} 
 -- $pattern:getAdr: "init:< entry{   "Monitor:init\n".print;   inner(init)" } 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "myM" >staticOff:0 "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(r ..."} 
 -- $obj:loadArgs: "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var integer): entry;      put(10); ..."} 
 -- $ObjectInvocation_Unary:invoke: "myM" >rec:"myM" ATd:"obj" E:"init" E.ATd:"init" unique:"False" 
 -- OI:invoke: "myM" 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:myM 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:myM 
 -- OI:invoke:B: "myM" E: "init"  rec: "myM"  useRtnV: true "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):re ...}" 
 -- OI:invoke:before:ATdx.invoke: obj myM 
 -- $obj:invoke: "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var integer): entry;      put(10);   ..."} 
 -- DI:invoke: "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var integer): entry;      put(10);     ...}" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:myM 
 rpushg MonitorDemo$189 13
 -- OI:invoke:V: adr: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:myM 
 -- 
 -- OI:invoke:X: adr: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:myM 
 -- 
 -- OI:invoke:C: myM :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "myM" E: "init" 
 -- computeAdr:isLast:E:  "init" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:myM 
 -- rec:  "myM" E:  "init" 
 -- INV:gen:E.loadArgs "init" 
 -- $ObjectInvocation_Unary:loadArgs: "init" >staticOff:0 "init:< entry{   "Monitor:init\n".print;   inner(init)" superAdj:0} 
 -- $pattern:loadArgs: "init:< entry{   "Monitor:init\n".print;   inner(init)" >E:"init":descNo:224} 
 -- ptn:loadArgs:E "init" 
 -- {(ObjectInvocation_Unary; (name: "init"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "init" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "init" :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:myM 
 -- $ObjectInvocation_Unary:invoke: "init" >rec:"myM" ATd:"pattern" E:"init" E.ATd:"init" unique:"False" 
 -- OI:invoke: "init" 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:myM 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:myM 
 -- OI:invoke:B: "init" E: "init"  rec: "myM"  useRtnV: false "init:< entry{   "Monitor:init\n".print;   inner(init)}" 
 -- OI:invoke:before:ATdx.invoke: pattern init 
 -- $pattern:invoke: "init:< entry{   "Monitor:init\n".print;   inner(init)" E: "init" useRTNv: "False"} 
 -- ptn:invoke: "init" E: "init" ptnKind: 1 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 1 staticOff: 0 :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:myM 
 -- isDI 
 -- isStatic: true rec: "myM" 
 invoke init 224 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -10 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:myM 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:myM 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: init :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 13 
 -- OG:gen:end: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"init":rec:myM 
 -- genclass:stmt: "P1.start" 
 -- $ObjectGenerator:gen: "P1.start" >OGid:"start" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "P1.start" 
 -- OG:before:super.gen: "P1.start" 
 -- $Invocation:gen: "P1.start" >useRtnV:"False"superAdj: 0 descNo: 225 
 -- INV:gen: "P1.start" 
 -- isConstant: "Invocation" "P1.start" 
 -- needorigin: "P1.start" 
 -- needOrigin:E: "start"  E.ATd: "start:: {   --P: ref Process;   --P := this(MonitorProcess);   --("starting: " + id + "\n").print;   --SQS.insert(P)}" 
 -- doNeedOrigin:Ex: "start" 
 -- computeAdr:superAdj: 0 "P1.start" 
 -- computeAdr: 1 :rec: "none"  E: "P1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "P1"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "P1" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "P1" >ATd.off:12:on:0:superAdj:0"P1: obj MonitorProcess("PP1"){   fac(V: var integer): ;      out res: var integer;      if (V = 1) :then ; ..."} 
 -- $obj:getAdr: "P1: obj MonitorProcess("PP1"){   fac(V: var integer): ;      out res: var integer;      if (V = 1) :then ;         res := 1;      :else ;         res := V *  ..."} 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:12 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "P1"  E: "start" 
 -- :Adr:off:12 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "start" >ATd.off:0 (isPtn):on:0:superAdj:0"start:: {   --P: ref Process;   --P := this(MonitorProcess);   --("starting: " + id + "\n").prin ..."} 
 -- $pattern:getAdr: "start:: {   --P: ref Process;   --P := this(MonitorProcess);   --("starting: " + id + "\n").print;   --SQS.insert(P)" } 
 -- :Adr:off:12 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"start":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "P1" >staticOff:0 "P1: obj MonitorProcess("PP1"){   fac(V: var integer): ;      out res: var integer;      if (V = 1) :then ;         res ..."} 
 -- $obj:loadArgs: "P1: obj MonitorProcess("PP1"){   fac(V: var integer): ;      out res: var integer;      if (V = 1) :then ;         res := 1;      :else ;         res := V  ..."} 
 -- $ObjectInvocation_Unary:invoke: "P1" >rec:"P1" ATd:"obj" E:"start" E.ATd:"start" unique:"False" 
 -- OI:invoke: "P1" 
 -- :Adr:off:12 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"start":rec:P1 
 -- :Adr:off:12 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"start":rec:P1 
 -- OI:invoke:B: "P1" E: "start"  rec: "P1"  useRtnV: true "P1: obj MonitorProcess("PP1"){   fac(V: var integer): ;      out res: var integer;      if (V = 1) :then ;          ...}" 
 -- OI:invoke:before:ATdx.invoke: obj P1 
 -- $obj:invoke: "P1: obj MonitorProcess("PP1"){   fac(V: var integer): ;      out res: var integer;      if (V = 1) :then ;         res := 1;      :else ;         res := V *  ..."} 
 -- DI:invoke: "P1: obj MonitorProcess("PP1"){   fac(V: var integer): ;      out res: var integer;      if (V = 1) :then ;         res := 1;      :else ;         res := V * fa ...}" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:12 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"start":rec:P1 
 rpushg MonitorDemo$189 12
 -- OI:invoke:V: adr: :Adr:off:12 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"start":rec:P1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:12 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"start":rec:P1 
 -- 
 -- OI:invoke:C: P1 :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "P1" E: "start" 
 -- computeAdr:isLast:E:  "start" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:12 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"start":rec:P1 
 -- rec:  "P1" E:  "start" 
 -- INV:gen:E.loadArgs "start" 
 -- $ObjectInvocation_Unary:loadArgs: "start" >staticOff:0 "start:: {   --P: ref Process;   --P := this(MonitorProcess);   --("starting: " + id + "\n").print;   --SQS.insert(P ..."} 
 -- $pattern:loadArgs: "start:: {   --P: ref Process;   --P := this(MonitorProcess);   --("starting: " + id + "\n").print;   --SQS.insert(P)" >E:"start":descNo:225} 
 -- ptn:loadArgs:E "start" 
 -- {(ObjectInvocation_Unary; (name: "start"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "start" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "start" :Adr:off:12 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"start":rec:P1 
 -- $ObjectInvocation_Unary:invoke: "start" >rec:"P1" ATd:"pattern" E:"start" E.ATd:"start" unique:"False" 
 -- OI:invoke: "start" 
 -- :Adr:off:12 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"start":rec:P1 
 -- :Adr:off:12 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"start":rec:P1 
 -- OI:invoke:B: "start" E: "start"  rec: "P1"  useRtnV: false "start:: {   --P: ref Process;   --P := this(MonitorProcess);   --("starting: " + id + "\n").print;   --SQS.inse ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern start 
 -- $pattern:invoke: "start:: {   --P: ref Process;   --P := this(MonitorProcess);   --("starting: " + id + "\n").print;   --SQS.insert(P)" E: "start" useRTNv: "False"} 
 -- ptn:invoke: "start" E: "start" ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 :Adr:off:12 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"start":rec:P1 
 -- isDI 
 -- isStatic: true rec: "P1" 
 invoke start 225 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -11 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:12 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"start":rec:P1 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:12 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"start":rec:P1 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: start :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 12 
 -- OG:gen:end: :Adr:off:12 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"start":rec:P1 
 -- genclass:stmt: "P2.start" 
 -- $ObjectGenerator:gen: "P2.start" >OGid:"start" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "P2.start" 
 -- OG:before:super.gen: "P2.start" 
 -- $Invocation:gen: "P2.start" >useRtnV:"False"superAdj: 0 descNo: 225 
 -- INV:gen: "P2.start" 
 -- isConstant: "Invocation" "P2.start" 
 -- needorigin: "P2.start" 
 -- needOrigin:E: "start"  E.ATd: "start:: {   --P: ref Process;   --P := this(MonitorProcess);   --("starting: " + id + "\n").print;   --SQS.insert(P)}" 
 -- doNeedOrigin:Ex: "start" 
 -- computeAdr:superAdj: 0 "P2.start" 
 -- computeAdr: 1 :rec: "none"  E: "P2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "P2"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "P2" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "P2" >ATd.off:14:on:0:superAdj:0"P2: obj MonitorProcess("PP2"){   sum(V: var integer): ;      out res: var integer;      for(1):to(10):repe ..."} 
 -- $obj:getAdr: "P2: obj MonitorProcess("PP2"){   sum(V: var integer): ;      out res: var integer;      for(1):to(10):repeat;         res := res + V;      ;   myM.print("P2  ...} 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:14 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "P2"  E: "start" 
 -- :Adr:off:14 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "start" >ATd.off:0 (isPtn):on:0:superAdj:0"start:: {   --P: ref Process;   --P := this(MonitorProcess);   --("starting: " + id + "\n").prin ..."} 
 -- $pattern:getAdr: "start:: {   --P: ref Process;   --P := this(MonitorProcess);   --("starting: " + id + "\n").print;   --SQS.insert(P)" } 
 -- :Adr:off:14 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"start":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "P2" >staticOff:0 "P2: obj MonitorProcess("PP2"){   sum(V: var integer): ;      out res: var integer;      for(1):to(10):repeat;          ..."} 
 -- $obj:loadArgs: "P2: obj MonitorProcess("PP2"){   sum(V: var integer): ;      out res: var integer;      for(1):to(10):repeat;         res := res + V;      ;   myM.print("P ...} 
 -- $ObjectInvocation_Unary:invoke: "P2" >rec:"P2" ATd:"obj" E:"start" E.ATd:"start" unique:"False" 
 -- OI:invoke: "P2" 
 -- :Adr:off:14 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"start":rec:P2 
 -- :Adr:off:14 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"start":rec:P2 
 -- OI:invoke:B: "P2" E: "start"  rec: "P2"  useRtnV: true "P2: obj MonitorProcess("PP2"){   sum(V: var integer): ;      out res: var integer;      for(1):to(10):repeat;       ...}" 
 -- OI:invoke:before:ATdx.invoke: obj P2 
 -- $obj:invoke: "P2: obj MonitorProcess("PP2"){   sum(V: var integer): ;      out res: var integer;      for(1):to(10):repeat;         res := res + V;      ;   myM.print("P2  ...} 
 -- DI:invoke: "P2: obj MonitorProcess("PP2"){   sum(V: var integer): ;      out res: var integer;      for(1):to(10):repeat;         res := res + V;      ;   myM.print("P2 re ..."}" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:14 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"start":rec:P2 
 rpushg MonitorDemo$189 14
 -- OI:invoke:V: adr: :Adr:off:14 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"start":rec:P2 
 -- 
 -- OI:invoke:X: adr: :Adr:off:14 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"start":rec:P2 
 -- 
 -- OI:invoke:C: P2 :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "P2" E: "start" 
 -- computeAdr:isLast:E:  "start" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:14 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"start":rec:P2 
 -- rec:  "P2" E:  "start" 
 -- INV:gen:E.loadArgs "start" 
 -- $ObjectInvocation_Unary:loadArgs: "start" >staticOff:0 "start:: {   --P: ref Process;   --P := this(MonitorProcess);   --("starting: " + id + "\n").print;   --SQS.insert(P ..."} 
 -- $pattern:loadArgs: "start:: {   --P: ref Process;   --P := this(MonitorProcess);   --("starting: " + id + "\n").print;   --SQS.insert(P)" >E:"start":descNo:225} 
 -- ptn:loadArgs:E "start" 
 -- {(ObjectInvocation_Unary; (name: "start"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "start" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "start" :Adr:off:14 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"start":rec:P2 
 -- $ObjectInvocation_Unary:invoke: "start" >rec:"P2" ATd:"pattern" E:"start" E.ATd:"start" unique:"False" 
 -- OI:invoke: "start" 
 -- :Adr:off:14 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"start":rec:P2 
 -- :Adr:off:14 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"start":rec:P2 
 -- OI:invoke:B: "start" E: "start"  rec: "P2"  useRtnV: false "start:: {   --P: ref Process;   --P := this(MonitorProcess);   --("starting: " + id + "\n").print;   --SQS.inse ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern start 
 -- $pattern:invoke: "start:: {   --P: ref Process;   --P := this(MonitorProcess);   --("starting: " + id + "\n").print;   --SQS.insert(P)" E: "start" useRTNv: "False"} 
 -- ptn:invoke: "start" E: "start" ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 :Adr:off:14 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"start":rec:P2 
 -- isDI 
 -- isStatic: true rec: "P2" 
 invoke start 225 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -12 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:14 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"start":rec:P2 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:14 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"start":rec:P2 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: start :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 14 
 -- OG:gen:end: :Adr:off:14 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"start":rec:P2 
 L2:
 rtnInner  M
 END OSDV:0 objSize:14 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 190 
 -- Items:GenClass: MonitorProcess descNo: 190 isValue: false 
 -- Items:GenClass: MonitorProcess descNo: 83 isValue: false 
 -- Items:GenClass: BasicProcess descNo: 82 isValue: false 
 -- Items:GenClass: GeneralProcess descNo: 21 isValue: false 

 CLASS MonitorProcess 190 4 MonitorSystem 188
 -- vdtTableCopy: I:1:82 V:2:160 V:3:138 V:4:161 V:5:162 V:6:164 I:7:83 I:8:0
 -- vdtAdd: inx=8 descInx=190 vDescInx=190 vdtTop: 8 
 -- Store itemArgs: %globals Monitor, MonitorProcess(""), immutable, console{-- we need to find out how to restrict Process to have no;-- visible interface. Perhaps rethink th ...} 
 -- Store:Origin: 0 
 rShiftUp  1
 tstOriginIsNone 
 rstore  4 origin
 -- super BasicProcess
 -- push:super.origin: 
 -- computeAdr:superAdj: 4 "BasicProcess" 
 -- computeAdr: 1 :rec: "none"  E: "BasicProcess" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "BasicProcess"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "BasicProcess" >on:0 superAdj:4 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 4 
 rpushg MonitorSystem$188 4
 -- $ObjectInvocation_Unary:getAdr: "BasicProcess" >ATd.off:0 (isPtn):on:0:superAdj:4"BasicProcess: GeneralProcess{   mkActive::< ;      status := p_status.ACTIVE;      SQS.in ..."} 
 -- $pattern:getAdr: "BasicProcess: GeneralProcess{   mkActive::< ;      status := p_status.ACTIVE;      SQS.insert(this(BasicProcess));   %Public;   start::<  -- need id as a ..."} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"BasicProcess":rec:- 
 -- E.on: 0 
 -- beforeIsValueObj:E: "BasicProcess"  ATd: "BasicProcess: GeneralProcess{   mkActive::< ;      status := p_status.ACTIVE;      SQS.insert(this(BasicProcess));   %Public;   s ...}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"BasicProcess":rec:- 
 -- computeAdr:isLast:E:  "BasicProcess" 
 -- genClass:after:pushAddress: "BasicProcess" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"BasicProcess":rec:- 
 -- handleSuperArgs:E: "BasicProcess" theIS: "%globals Monitor, MonitorProcess(""), immutable, console{-- we need to find out how to restrict Process to have no;-- visible int ...}" 
 -- super.sig:not:none:superAdj: -4 
 -- $ObjectInvocation_Unary:loadArgs: "BasicProcess" >staticOff:0 "BasicProcess: GeneralProcess{   mkActive::< ;      status := p_status.ACTIVE;      SQS.insert(this(BasicProc ..."} 
 -- $pattern:loadArgs: "BasicProcess: GeneralProcess{   mkActive::< ;      status := p_status.ACTIVE;      SQS.insert(this(BasicProcess));   %Public;   start::<  -- need id as ..."} 
 -- ptn:loadArgs:E "BasicProcess" 
 -- {(ObjectInvocation_Unary; (name: "BasicProcess"); (Arguments))} 
 -- args: "" 
 rShiftDown  1
 -- hArgOrg:super: BasicProcess 
 -- Store itemArgs: %globals Monitor, MonitorProcess(""), immutable, console{-- we need to find out how to restrict Process to have no;-- visible interface. Perhaps rethink th ...} 
 -- Store:Origin: 0 
 rShiftUp  1
 tstOriginIsNone 
 rstore  4 origin
 -- super BasicProcess
 -- push:super.origin: 
 -- computeAdr:superAdj: 4 "GeneralProcess" 
 -- computeAdr: 1 :rec: "none"  E: "GeneralProcess" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "GeneralProcess"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "GeneralProcess" >on:2 superAdj:4 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 4 
 rpushg BasicSystem$72 4
 -- items:goOrigin:encOG: "BasicSystem" on: 2 isValueObj: false 
 -- origin: BasicSystemLib origin:isValueObj: false 
 rpushg BasicSystem$72 1
 -- items:goOrigin:encOG: "BasicSystemLib" on: 1 isValueObj: false 
 -- origin: LIB origin:isValueObj: false 
 rpushg BasicSystemLib$38 1
 -- IV:viaIncl:on: 0 "BETA"  org: "%id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--Collectio ...}" 
 -- viaIncl:son:isFirst: true viaIncl<>none: false "BETA" 
 -- items:goOrigin:encOG: "LIB" on: 1 isValueObj: false 
 -- origin: BETAworld origin:isValueObj: false 
 rpushg LIB$33 1
 rpushg BETA 2
 -- $ObjectInvocation_Unary:getAdr: "GeneralProcess" >ATd.off:0 (isPtn):on:2:superAdj:4"GeneralProcess(id: var LIB.StringLib.String): {   start:< ;      inner(start);   mkActi ..."} 
 -- $pattern:getAdr: "GeneralProcess(id: var LIB.StringLib.String): {   start:< ;      inner(start);   mkActive:< ;      inner(mkActive);   addWaiting:< ;      inner(addWaitin ..."} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"GeneralProcess":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "GeneralProcess"  ATd: "GeneralProcess(id: var LIB.StringLib.String): {   start:< ;      inner(start);   mkActive:< ;      inner(mkActive);   addWaitin ...}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"GeneralProcess":rec:- 
 -- computeAdr:isLast:E:  "GeneralProcess" 
 -- genClass:after:pushAddress: "GeneralProcess" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"GeneralProcess":rec:- 
 -- handleSuperArgs:E: "GeneralProcess" theIS: "mkActive::< {   status := p_status.ACTIVE;   SQS.insert(this(BasicProcess));%Public;start::<  -- need id as argument;   status  ...}" 
 -- super.sig:not:none:superAdj: -4 
 -- $ObjectInvocation_Unary:loadArgs: "GeneralProcess" >staticOff:0 "GeneralProcess(id: var LIB.StringLib.String): {   start:< ;      inner(start);   mkActive:< ;      inner(m ..."} 
 -- $pattern:loadArgs: "GeneralProcess(id: var LIB.StringLib.String): {   start:< ;      inner(start);   mkActive:< ;      inner(mkActive);   addWaiting:< ;      inner(addWait ..."} 
 -- ptn:loadArgs:E "GeneralProcess" 
 -- {(ObjectInvocation_Unary; (name: "GeneralProcess"); (Arguments))} 
 -- args: "" 
 rShiftDown  1
 -- hArgOrg:super: GeneralProcess 
 -- Store itemArgs: %globals Monitor, MonitorProcess(""), immutable, console{-- we need to find out how to restrict Process to have no;-- visible interface. Perhaps rethink th ...} 
 -- id: var LIB.StringLib.String true 5 
 pushThis 
 rstoreg  id 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=190 vDescInx=82 vdtTop: 8 
 -- $pattern:gen: "start:< {   inner(start)" } 
 -- $pattern:gen: "mkActive:< {   inner(mkActive)" } 
 -- $pattern:gen: "addWaiting:< {   inner(addWaiting);   --put('R')" } 
 -- $pattern:gen: "dcrWaiting:< {   inner(dcrWaiting)" } 
 -- $pattern:gen: "display:< {   "\n---GP:---".print;   inner(display)" } 
 -- $var:gen: "status: var integer"  
 -- DI:gen: "status: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  status 
 -- $pattern:gen: "mkActive::< {   status := p_status.ACTIVE;   SQS.insert(this(BasicProcess))" } 
 -- $Property:gen: "%Public"  
 -- $pattern:gen: "start::<  -- need id as argument{   status := p_status.ACTIVE;   SQS.insert(this(BasicProcess));   inner(start)" } 
 -- $pattern:gen: "addWaiting::< {   --SQS.addWaitingstatus := P_status.WAITING" } 
 -- $pattern:gen: "dcrWaiting::< {   SQS.dcrWaiting" } 
 -- $pattern:gen: "display::< {   "\n---BP:---\n".print;   --(id + ":A:").print	 " } 
 -- $Property:gen: "%globals Monitor, MonitorProcess(""), immutable, console{-- we need to find out how to restrict Process to have no;-- visible interface. Perhaps rethink th ..."} 
 -- $Property:gen: "%public"  
 -- $pattern:gen: "start:: {   --P: ref Process;   --P := this(MonitorProcess);   --("starting: " + id + "\n").print;   --SQS.insert(P)" } 
 rtnAlloc 1
 toSuper 82
DO:
 mvStack 
 L1:
 -- genclass:stmt: "%globals Monitor, MonitorProcess(""), immutable, console{-- we need to find out how to restrict Process to have no;-- visible interface. Perhaps rethink th ...}" 
 -- $Property:gen: "%globals Monitor, MonitorProcess(""), immutable, console{-- we need to find out how to restrict Process to have no;-- visible interface. Perhaps rethink th ..."} 
 -- genclass:stmt: "%public" 
 -- $Property:gen: "%public"  
 -- genclass:stmt: "inner(MonitorProcess)" 
 -- $ObjectGenerator:gen: "inner(MonitorProcess)" >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inner(MonitorProcess)" 
 -- OG:before:super.gen: "inner(MonitorProcess)" 
 -- $Invocation:gen: "inner(MonitorProcess)" >useRtnV:"False"superAdj: 0 descNo: 12 
 -- INV:gen: "inner(MonitorProcess)" 
 -- isConstant: "Invocation" "inner(MonitorProcess)" 
 -- needorigin: "inner(MonitorProcess)" 
 -- needOrigin:E: "inner(MonitorProcess)"  E.ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- doNeedOrigin:Ex: "inner(MonitorProcess)" 
 -- computeAdr:superAdj: 0 "inner(MonitorProcess)" 
 -- computeAdr: 1 :rec: "none"  E: "inner(MonitorProcess)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "inner(MonitorProcess)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "inner(MonitorProcess)" >on:3 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "inner(MonitorProcess)" >ATd.off:0 (isPtn):on:3:superAdj:0"inner: {   %basic 101;   in inner: ref Object":Adr:off:0 size:0 isFloat:F isUn ...} 
 -- $pattern:getAdr: "inner: {   %basic 101;   in inner: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(MonitorProcess)":rec:- 
 -- E.on: 3 
 -- beforeIsValueObj:E: "inner(MonitorProcess)"  ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(MonitorProcess)":rec:- 
 -- computeAdr:isLast:E:  "inner(MonitorProcess)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(MonitorProcess)":rec:- 
 -- rec:  "inner(MonitorProcess)" E:  "inner(MonitorProcess)" 
 -- INV:gen:E.loadArgs "inner(MonitorProcess)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "inner(MonitorProcess)" >staticOff:0 "inner: {   %basic 101;   in inner: ref Object" superAdj:0arg:"MonitorProcess"} 
 -- $pattern:loadArgs: "inner: {   %basic 101;   in inner: ref Object" >E:"inner(MonitorProcess)":descNo:12} 
 -- INV:gen:after:E.loadArgs "inner(MonitorProcess)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(MonitorProcess)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E: ... 
 -- $ObjectInvocation_KeyWord:invoke: "inner(MonitorProcess)" >rec:"inner(MonitorProcess)" ATd:"pattern" E:"inner(MonitorProcess)" E.ATd:"inner" unique:"False" 
 -- OI:invoke: "inner(MonitorProcess)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(MonitorProcess)":rec:inner(MonitorProcess) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(MonitorProcess)":rec:inner(MonitorProcess) 
 -- OI:invoke:B: "inner(MonitorProcess)" E: "inner(MonitorProcess)"  rec: "inner(MonitorProcess)"  useRtnV: false "inner: {   %basic 101;   in inner: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- $pattern:invoke: "inner: {   %basic 101;   in inner: ref Object" E: "inner(MonitorProcess)" useRTNv: "False"} 
 -- ptn:invoke: "inner" E: "inner(MonitorProcess)" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  9
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(MonitorProcess)":rec:inner(MonitorProcess) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(MonitorProcess)":rec:inner(MonitorProcess) 
 -- 
 -- OI:invoke:C: inner(MonitorProcess) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(MonitorProcess)":rec:inner(MonitorProcess) 
 L2:
 rtnInner  M
 END OSDV:0 objSize:4 isIndexed:0
 -- vdtAdd: inx=9 descInx=190 vDescInx=0 vdtTop: 9 
 -- vdtAdd: inx=2 descInx=190 vDescInx=225 vdtTop: 9 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 225 
 -- Items:GenClass: start descNo: 225 isValue: false 
 -- Items:GenClass: start descNo: 160 isValue: false 
 -- Items:GenClass: start descNo: 132 isValue: false 
 -- Items:GenClass: start descNo: 21 isValue: false 

 CLASS start 225 1 MonitorProcess 190
 -- vdtTableCopy: I:1:132 I:2:160 I:3:0
 -- vdtAdd: inx=3 descInx=225 vDescInx=225 vdtTop: 3 
 -- Store itemArgs: --P: ref Process{--P := this(MonitorProcess);--("starting: " + id + "\n").print;--SQS.insert(P)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 -- super start
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 -- handleSuperArgs:E: "" theIS: "--P: ref Process{--P := this(MonitorProcess);--("starting: " + id + "\n").print;--SQS.insert(P)}" 
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs: ""  
 -- hArgOrg:super: start 
 -- Store itemArgs: --P: ref Process{--P := this(MonitorProcess);--("starting: " + id + "\n").print;--SQS.insert(P)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 -- super start
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 -- handleSuperArgs:E: "" theIS: "status := p_status.ACTIVE{SQS.insert(this(BasicProcess));inner(start)}" 
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs: ""  
 -- hArgOrg:super: start 
 -- Store itemArgs: --P: ref Process{--P := this(MonitorProcess);--("starting: " + id + "\n").print;--SQS.insert(P)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=225 vDescInx=132 vdtTop: 3 
 rtnAlloc 1
 toSuper 132
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 191 
 -- Items:GenClass: P1 descNo: 191 isValue: false 
 -- Items:GenClass: P1 descNo: 190 isValue: false 
 -- Items:GenClass: MonitorProcess descNo: 83 isValue: false 
 -- Items:GenClass: BasicProcess descNo: 82 isValue: false 
 -- Items:GenClass: GeneralProcess descNo: 21 isValue: false 

 CLASS P1 191 4 MonitorDemo 189
 -- vdtTableCopy: I:1:82 V:2:225 V:3:138 V:4:161 V:5:162 V:6:164 I:7:83 I:8:190 I:9:0
 -- vdtAdd: inx=9 descInx=191 vDescInx=191 vdtTop: 9 
 -- Store itemArgs: fac(V: var integer): {   out res: var integer;   if (V = 1) :then ;      res := 1;   :else ;      res := V * fac(V - 1);myM.print("P1 resumed\n");for(1):to ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  4 origin
 -- super MonitorProcess
 -- push:super.origin: 
 -- computeAdr:superAdj: 4 "MonitorProcess("PP1")" 
 -- computeAdr: 1 :rec: "none"  E: "MonitorProcess("PP1")" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "MonitorProcess("PP1")"  
 pushThis 
 -- $ObjectInvocation_KeyWord:loadOrigin: "MonitorProcess("PP1")" >on:0 superAdj:4 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 4 
 rpushg MonitorDemo$189 4
 -- $ObjectInvocation_KeyWord:getAdr: "MonitorProcess("PP1")" >ATd.off:0 (isPtn):on:0:superAdj:4"MonitorProcess: BasicProcess{   %globals Monitor, MonitorProcess(""), immutabl ..."} 
 -- $pattern:getAdr: "MonitorProcess: BasicProcess{   %globals Monitor, MonitorProcess(""), immutable, console;   -- we need to find out how to restrict Process to have no;    ..."} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"MonitorProcess("PP1")":rec:- 
 -- E.on: 0 
 -- beforeIsValueObj:E: "MonitorProcess("PP1")"  ATd: "MonitorProcess: BasicProcess{   %globals Monitor, MonitorProcess(""), immutable, console;   -- we need to find out how t ...}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"MonitorProcess("PP1")":rec:- 
 -- computeAdr:isLast:E:  "MonitorProcess("PP1")" 
 -- genClass:after:pushAddress: "MonitorProcess("PP1")" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"MonitorProcess("PP1")":rec:- ... 
 -- handleSuperArgs:E: "MonitorProcess("PP1")" theIS: "fac(V: var integer): {   out res: var integer;   if (V = 1) :then ;      res := 1;   :else ;      res := V * fac(V - 1); ...}" 
 -- super.sig:none:superAdj: 4 
 -- $ObjectInvocation_KeyWord:loadArgs: "MonitorProcess("PP1")" >staticOff:0 "MonitorProcess: BasicProcess{   %globals Monitor, MonitorProcess(""), immutable, console;   -- we ..."} 
 -- $pattern:loadArgs: "MonitorProcess: BasicProcess{   %globals Monitor, MonitorProcess(""), immutable, console;   -- we need to find out how to restrict Process to have no;  ..."} 
 -- ptn:loadArgs:E "MonitorProcess("PP1")" 
 -- {(ObjectInvocation_KeyWord; (name: "MonitorProcess"); (Arguments;  (name: "MonitorProcess");  (name: "(");  (ObjectGenerator;   (Invocation;    (String: PP1));   (Items de ...} 
 -- args: "MonitorProcess("PP1")" 
 -- E: "ObjectGenerator" "PP1" 
 -- E.arg: "var" id: var LIB.StringLib.String 
 -- NonVirt: "MonitorProcess("PP1")" "ObjectInvocation_KeyWord" ActArg:  ""PP1"" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "MonitorProcess("PP1")"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: ""PP1"" >OGid:"String" IS.isempty! staticOff=0 descNo=0 superAdj=4 
 -- OG:gen: ""PP1"" 
 -- OG:before:super.gen: ""PP1"" 
 -- $Invocation:gen: ""PP1"" >useRtnV:"True"superAdj: 4 
 -- INV:gen: ""PP1"" 
 -- isConstant: "Invocation" ""PP1"" 
 -- needorigin: ""PP1"" 
 -- needOrigin:E: ""PP1""  E.ATd: "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 4 
 -- rec:  ""PP1"" E:  ""PP1"" 
 -- INV:gen:E.loadArgs ""PP1"" 
 -- $String::loadArgs: ""PP1""  
 -- INV:gen:after:E.loadArgs ""PP1"" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: String: ""PP1"" 
 -- $String::invoke: ""PP1""  
 pushText "PP1"
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "id: var LIB.StringLib.String" :isBasicVal: false :valueObj: false 
 -- :actArg: ""PP1"" :isBasicVal: false 
 -- case:B: "PP1" ObjectGenerator 5 5 5 false false 
 -- end:loadArgs:NonVirt: "MonitorProcess("PP1")" 
 -- hArgOrg:super: MonitorProcess 
 -- Store itemArgs: fac(V: var integer): {   out res: var integer;   if (V = 1) :then ;      res := 1;   :else ;      res := V * fac(V - 1);myM.print("P1 resumed\n");for(1):to ...} 
 -- Store:Origin: 0 
 rShiftUp  1
 tstOriginIsNone 
 rstore  4 origin
 -- super MonitorProcess
 -- push:super.origin: 
 -- computeAdr:superAdj: 4 "BasicProcess" 
 -- computeAdr: 1 :rec: "none"  E: "BasicProcess" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "BasicProcess"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "BasicProcess" >on:0 superAdj:4 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 4 
 rpushg MonitorSystem$188 4
 -- $ObjectInvocation_Unary:getAdr: "BasicProcess" >ATd.off:0 (isPtn):on:0:superAdj:4"BasicProcess: GeneralProcess{   mkActive::< ;      status := p_status.ACTIVE;      SQS.in ..."} 
 -- $pattern:getAdr: "BasicProcess: GeneralProcess{   mkActive::< ;      status := p_status.ACTIVE;      SQS.insert(this(BasicProcess));   %Public;   start::<  -- need id as a ..."} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"BasicProcess":rec:- 
 -- E.on: 0 
 -- beforeIsValueObj:E: "BasicProcess"  ATd: "BasicProcess: GeneralProcess{   mkActive::< ;      status := p_status.ACTIVE;      SQS.insert(this(BasicProcess));   %Public;   s ...}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"BasicProcess":rec:- 
 -- computeAdr:isLast:E:  "BasicProcess" 
 -- genClass:after:pushAddress: "BasicProcess" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"BasicProcess":rec:- 
 -- handleSuperArgs:E: "BasicProcess" theIS: "%globals Monitor, MonitorProcess(""), immutable, console{-- we need to find out how to restrict Process to have no;-- visible int ...}" 
 -- super.sig:not:none:superAdj: -4 
 -- $ObjectInvocation_Unary:loadArgs: "BasicProcess" >staticOff:0 "BasicProcess: GeneralProcess{   mkActive::< ;      status := p_status.ACTIVE;      SQS.insert(this(BasicProc ..."} 
 -- $pattern:loadArgs: "BasicProcess: GeneralProcess{   mkActive::< ;      status := p_status.ACTIVE;      SQS.insert(this(BasicProcess));   %Public;   start::<  -- need id as ..."} 
 -- ptn:loadArgs:E "BasicProcess" 
 -- {(ObjectInvocation_Unary; (name: "BasicProcess"); (Arguments))} 
 -- args: "" 
 rShiftDown  1
 -- hArgOrg:super: BasicProcess 
 -- Store itemArgs: fac(V: var integer): {   out res: var integer;   if (V = 1) :then ;      res := 1;   :else ;      res := V * fac(V - 1);myM.print("P1 resumed\n");for(1):to ...} 
 -- Store:Origin: 0 
 rShiftUp  1
 tstOriginIsNone 
 rstore  4 origin
 -- super MonitorProcess
 -- push:super.origin: 
 -- computeAdr:superAdj: 4 "GeneralProcess" 
 -- computeAdr: 1 :rec: "none"  E: "GeneralProcess" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "GeneralProcess"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "GeneralProcess" >on:2 superAdj:4 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 4 
 rpushg BasicSystem$72 4
 -- items:goOrigin:encOG: "BasicSystem" on: 2 isValueObj: false 
 -- origin: BasicSystemLib origin:isValueObj: false 
 rpushg BasicSystem$72 1
 -- items:goOrigin:encOG: "BasicSystemLib" on: 1 isValueObj: false 
 -- origin: LIB origin:isValueObj: false 
 rpushg BasicSystemLib$38 1
 -- IV:viaIncl:on: 0 "BETA"  org: "%id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--Collectio ...}" 
 -- viaIncl:son:isFirst: true viaIncl<>none: false "BETA" 
 -- items:goOrigin:encOG: "LIB" on: 1 isValueObj: false 
 -- origin: BETAworld origin:isValueObj: false 
 rpushg LIB$33 1
 rpushg BETA 2
 -- $ObjectInvocation_Unary:getAdr: "GeneralProcess" >ATd.off:0 (isPtn):on:2:superAdj:4"GeneralProcess(id: var LIB.StringLib.String): {   start:< ;      inner(start);   mkActi ..."} 
 -- $pattern:getAdr: "GeneralProcess(id: var LIB.StringLib.String): {   start:< ;      inner(start);   mkActive:< ;      inner(mkActive);   addWaiting:< ;      inner(addWaitin ..."} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"GeneralProcess":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "GeneralProcess"  ATd: "GeneralProcess(id: var LIB.StringLib.String): {   start:< ;      inner(start);   mkActive:< ;      inner(mkActive);   addWaitin ...}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"GeneralProcess":rec:- 
 -- computeAdr:isLast:E:  "GeneralProcess" 
 -- genClass:after:pushAddress: "GeneralProcess" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"GeneralProcess":rec:- 
 -- handleSuperArgs:E: "GeneralProcess" theIS: "mkActive::< {   status := p_status.ACTIVE;   SQS.insert(this(BasicProcess));%Public;start::<  -- need id as argument;   status  ...}" 
 -- super.sig:not:none:superAdj: -4 
 -- $ObjectInvocation_Unary:loadArgs: "GeneralProcess" >staticOff:0 "GeneralProcess(id: var LIB.StringLib.String): {   start:< ;      inner(start);   mkActive:< ;      inner(m ..."} 
 -- $pattern:loadArgs: "GeneralProcess(id: var LIB.StringLib.String): {   start:< ;      inner(start);   mkActive:< ;      inner(mkActive);   addWaiting:< ;      inner(addWait ..."} 
 -- ptn:loadArgs:E "GeneralProcess" 
 -- {(ObjectInvocation_Unary; (name: "GeneralProcess"); (Arguments))} 
 -- args: "" 
 rShiftDown  1
 -- hArgOrg:super: GeneralProcess 
 -- Store itemArgs: fac(V: var integer): {   out res: var integer;   if (V = 1) :then ;      res := 1;   :else ;      res := V * fac(V - 1);myM.print("P1 resumed\n");for(1):to ...} 
 -- id: var LIB.StringLib.String true 5 
 pushThis 
 rstoreg  id 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 1 V: R: 
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=191 vDescInx=82 vdtTop: 9 
 -- $pattern:gen: "start:< {   inner(start)" } 
 -- $pattern:gen: "mkActive:< {   inner(mkActive)" } 
 -- $pattern:gen: "addWaiting:< {   inner(addWaiting);   --put('R')" } 
 -- $pattern:gen: "dcrWaiting:< {   inner(dcrWaiting)" } 
 -- $pattern:gen: "display:< {   "\n---GP:---".print;   inner(display)" } 
 -- $var:gen: "status: var integer"  
 -- DI:gen: "status: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  status 
 -- $pattern:gen: "mkActive::< {   status := p_status.ACTIVE;   SQS.insert(this(BasicProcess))" } 
 -- $Property:gen: "%Public"  
 -- $pattern:gen: "start::<  -- need id as argument{   status := p_status.ACTIVE;   SQS.insert(this(BasicProcess));   inner(start)" } 
 -- $pattern:gen: "addWaiting::< {   --SQS.addWaitingstatus := P_status.WAITING" } 
 -- $pattern:gen: "dcrWaiting::< {   SQS.dcrWaiting" } 
 -- $pattern:gen: "display::< {   "\n---BP:---\n".print;   --(id + ":A:").print	 " } 
 -- $Property:gen: "%globals Monitor, MonitorProcess(""), immutable, console{-- we need to find out how to restrict Process to have no;-- visible interface. Perhaps rethink th ..."} 
 -- $Property:gen: "%public"  
 -- $pattern:gen: "start:: {   --P: ref Process;   --P := this(MonitorProcess);   --("starting: " + id + "\n").print;   --SQS.insert(P)" } 
 rtnAlloc 1
 toSuper 82
DO:
 mvStack 
 L1:
 -- genclass:stmt: "myM.print("P1 resumed\n")" 
 -- $ObjectGenerator:gen: "myM.print("P1 resumed\n")" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "myM.print("P1 resumed\n")" 
 -- OG:before:super.gen: "myM.print("P1 resumed\n")" 
 -- $Invocation:gen: "myM.print("P1 resumed\n")" >useRtnV:"False"superAdj: 0 descNo: 200 
 -- INV:gen: "myM.print("P1 resumed\n")" 
 -- isConstant: "Invocation" "myM.print("P1 resumed\n")" 
 -- needorigin: "myM.print("P1 resumed\n")" 
 -- needOrigin:E: "print("P1 resumed\n")"  E.ATd: "print(S: var String): entry{   S.print}" 
 -- doNeedOrigin:Ex: "print("P1 resumed\n")" 
 -- computeAdr:superAdj: 0 "myM.print("P1 resumed\n")" 
 -- computeAdr: 1 :rec: "none"  E: "myM" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "myM"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "myM" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "P1" on: 1 isValueObj: false 
 -- origin: MonitorDemo origin:isValueObj: false 
 rpushg P1$191 4
 -- $ObjectInvocation_Unary:getAdr: "myM" >ATd.off:13:on:1:superAdj:0"myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var in ..."} 
 -- $obj:getAdr: "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var integer): entry;      put(10);   ..."} 
 -- E.on: 1 
 -- beforeIsValueObj:E: "myM"  ATd: "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var integer): ent ...}" 
 -- computeAdr:isFirst: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "myM"  E: "print("P1 resumed\n")" 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:getAdr: "print("P1 resumed\n")" >ATd.off:0 (isPtn):on:0:superAdj:0"print(S: var String): entry{   S.print":Adr:off:13 size:0 isFloat:F isUnitVal: ...} 
 -- $pattern:getAdr: "print(S: var String): entry{   S.print" } 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print("P1 resumed\n")":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "myM" >staticOff:0 "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(r ..."} 
 -- $obj:loadArgs: "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var integer): entry;      put(10); ..."} 
 -- $ObjectInvocation_Unary:invoke: "myM" >rec:"myM" ATd:"obj" E:"print("P1 resumed\n")" E.ATd:"print(S: var String)" unique:"False" 
 -- OI:invoke: "myM" 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print("P1 resumed\n")":rec:myM 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print("P1 resumed\n")":rec:myM 
 -- OI:invoke:B: "myM" E: "print("P1 resumed\n")"  rec: "myM"  useRtnV: true "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V ...}" 
 -- OI:invoke:before:ATdx.invoke: obj myM 
 -- $obj:invoke: "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var integer): entry;      put(10);   ..."} 
 -- DI:invoke: "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var integer): entry;      put(10);     ...}" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print("P1 resumed\n")":rec:myM 
 rpushg P1$191 13
 -- OI:invoke:V: adr: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print("P1 resumed\n")":rec:myM 
 -- 
 -- OI:invoke:X: adr: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print("P1 resumed\n")":rec:myM 
 -- 
 -- OI:invoke:C: myM :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "myM" E: "print("P1 resumed\n")" 
 -- arg:other 
 -- computeAdr:isLast:E:  "print("P1 resumed\n")" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print("P1 resumed\n")":rec:myM 
 -- rec:  "myM" E:  "print("P1 resumed\n")" 
 -- INV:gen:E.loadArgs "print("P1 resumed\n")" 
 -- $ObjectInvocation_KeyWord:loadArgs: "print("P1 resumed\n")" >staticOff:0 "print(S: var String): entry{   S.print" superAdj:0arg:""P1 resumed\n""} 
 -- $pattern:loadArgs: "print(S: var String): entry{   S.print" >E:"print("P1 resumed\n")":descNo:200} 
 -- ptn:loadArgs:E "print("P1 resumed\n")" 
 -- {(ObjectInvocation_KeyWord; (name: "print"); (Arguments;  (name: "print");  (name: "(");  (ObjectGenerator;   (Invocation;    (String: P1 resumed\n));   (Items descNo: 0 o ...} 
 -- args: "print("P1 resumed\n")" 
 -- E: "ObjectGenerator" "P1 resumed\n" 
 -- E.arg: "var" S: var String 
 -- NonVirt: "print("P1 resumed\n")" "ObjectInvocation_KeyWord" ActArg:  ""P1 resumed\n"" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "print("P1 resumed\n")"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: ""P1 resumed\n"" >OGid:"String" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: ""P1 resumed\n"" 
 -- OG:before:super.gen: ""P1 resumed\n"" 
 -- $Invocation:gen: ""P1 resumed\n"" >useRtnV:"True"superAdj: 0 
 -- INV:gen: ""P1 resumed\n"" 
 -- isConstant: "Invocation" ""P1 resumed\n"" 
 -- needorigin: ""P1 resumed\n"" 
 -- needOrigin:E: ""P1 resumed\n""  E.ATd: "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  ""P1 resumed\n"" E:  ""P1 resumed\n"" 
 -- INV:gen:E.loadArgs ""P1 resumed\n"" 
 -- $String::loadArgs: ""P1 resumed\n""  
 -- INV:gen:after:E.loadArgs ""P1 resumed\n"" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: String: ""P1 resumed\n"" 
 -- $String::invoke: ""P1 resumed\n""  
 pushText "P1 resumed\n"
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "S: var String" :isBasicVal: false :valueObj: false 
 -- :actArg: ""P1 resumed\n"" :isBasicVal: false 
 -- case:B: "P1 resumed\n" ObjectGenerator 5 5 5 false false 
 -- end:loadArgs:NonVirt: "print("P1 resumed\n")" 
 -- INV:gen:after:E.loadArgs "print("P1 resumed\n")" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "print("P1 resumed\n")" :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $ObjectInvocation_KeyWord:invoke: "print("P1 resumed\n")" >rec:"myM" ATd:"pattern" E:"print("P1 resumed\n")" E.ATd:"print(S: var String)" unique:"False" 
 -- OI:invoke: "print("P1 resumed\n")" 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print("P1 resumed\n")":rec:myM 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print("P1 resumed\n")":rec:myM 
 -- OI:invoke:B: "print("P1 resumed\n")" E: "print("P1 resumed\n")"  rec: "myM"  useRtnV: false "print(S: var String): entry{   S.print}" 
 -- OI:invoke:before:ATdx.invoke: pattern print(S: var String) 
 -- $pattern:invoke: "print(S: var String): entry{   S.print" E: "print("P1 resumed\n")" useRTNv: "False"} 
 -- ptn:invoke: "print(S: var String)" E: "print("P1 resumed\n")" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print("P1 resumed\n")":rec:myM 
 invoke print 200 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 1 V: R: 
 -- OI:invoke:V: adr: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print("P1 resumed\n")":rec:myM 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print("P1 resumed\n")":rec:myM 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print("P1 resumed\n") :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 13 
 -- OG:gen:end: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print("P1 resumed\n")":rec:myM 
 -- genclass:stmt: "for(1):to(5):repeat{   myM.putItem("Fac: "):value(inx):res(fac(inx));}" 
 -- $ObjectGenerator:gen: "for(1):to(5):repeat{   myM.putItem("Fac: "):value(inx):res(fac(inx));" >OGid:"for:to:repeat$214" IS.isempty! staticOff=0 descNo=214 superAdj=0} 
 -- OG:gen: "for(1):to(5):repeat{   myM.putItem("Fac: "):value(inx):res(fac(inx));}" 
 pushThis 
 -- before objTmpStack:add:  214   "for:to:repeat$214" 
 invoke for:to:repeat$214 214 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 1 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 rtnInner  M
 END OSDV:0 objSize:4 isIndexed:0
 -- Handle VB: "fac(V: var integer): {   out res: var integer;   if (V = 1) :then ;      res := 1;   :else ;      res := V * fac(V - 1);myM.print("P1 resumed\n");for(1):to(5): ...}" E ... "M ..." 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 215 
 -- Items:GenClass: Monitor descNo: 215 isValue: false 
 -- Items:GenClass: Monitor descNo: 21 isValue: false 

 CLASS Monitor 215 1 MonitorSystem 188
 -- Store itemArgs: %globals P_status, SQS, BasicSystemLib, Monitor, console, immutable, #MonitorProcess{%interface entry;mutex: obj BasicSystemLib.SemaphoreLib.Semaphore(1);_ ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=215 vDescInx=215 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%globals P_status, SQS, BasicSystemLib, Monitor, console, immutable, #MonitorProcess"  
 -- $Property:gen: "%interface entry"  
 -- $obj:gen: "mutex: obj BasicSystemLib.SemaphoreLib.Semaphore(1)"  
 -- DI:gen: "mutex: obj BasicSystemLib.SemaphoreLib.Semaphore(1)" DI:isConst: true :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  mutex 
 -- $ObjectGenerator:gen: "BasicSystemLib.SemaphoreLib.Semaphore(1)" >OGid:"Semaphore" IS.isempty! staticOff=2 descNo=0 superAdj=0 
 -- OG:gen: "BasicSystemLib.SemaphoreLib.Semaphore(1)" 
 -- OG:before:super.gen: "BasicSystemLib.SemaphoreLib.Semaphore(1)" 
 -- $Invocation:gen: "BasicSystemLib.SemaphoreLib.Semaphore(1)" >useRtnV:"False"superAdj: 0 descNo: 216 
 -- INV:gen: "BasicSystemLib.SemaphoreLib.Semaphore(1)" 
 -- isConstant: "Invocation" "BasicSystemLib.SemaphoreLib.Semaphore(1)" 
 -- needorigin: "BasicSystemLib.SemaphoreLib.Semaphore(1)" 
 -- needOrigin:E: "Semaphore(1)"  E.ATd: "Semaphore(cnt: var integer): {   -- Implementation of a counting semaphores;   -- cnt is the initial value of the semaphore;   -- req ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "-- Implementation of a counting semaphores{   -- cnt is the initial value of the semaphore;   -- requires: cnt > 0%globals;   %public;   wait ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "SemaphoreLib" E:  "Semaphore(1)" 
 -- INV:gen:E.loadArgs "Semaphore(1)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "Semaphore(1)" >staticOff:0 "Semaphore(cnt: var integer): {   -- Implementation of a counting semaphores;   -- cnt is the initial value ..."} 
 -- $pattern:loadArgs: "Semaphore(cnt: var integer): {   -- Implementation of a counting semaphores;   -- cnt is the initial value of the semaphore;   -- requires: cnt > 0%glo ..."} 
 -- ptn:loadArgs:E "Semaphore(1)" 
 -- {(ObjectInvocation_KeyWord; (name: "Semaphore"); (Arguments;  (name: "Semaphore");  (name: "(");  (ObjectGenerator;   (Invocation;    (ConstLiteral 1));   (Items descNo: 0 ...} 
 -- args: "Semaphore(1)" 
 -- E: "ObjectGenerator" 1 
 -- E.arg: "var" cnt: var integer 
 -- NonVirt: "Semaphore(1)" "ObjectInvocation_KeyWord" ActArg:  "1" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "Semaphore(1)"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "cnt: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "1" :isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "Semaphore(1)" 
 -- INV:gen:after:E.loadArgs "Semaphore(1)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "Semaphore(1)" 
 -- $ObjectInvocation_KeyWord:invoke: "Semaphore(1)" >rec:"SemaphoreLib" ATd:"pattern" E:"Semaphore(1)" E.ATd:"Semaphore(cnt: var integer)" unique:"False" 
 -- OI:invoke: "Semaphore(1)" 
 -- 
 -- OI:invoke:B: "Semaphore(1)" E: "Semaphore(1)"  rec: "SemaphoreLib"  useRtnV: false "Semaphore(cnt: var integer): {   -- Implementation of a counting semaphores;   -- cnt i ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Semaphore(cnt: var integer) 
 -- $pattern:invoke: "Semaphore(cnt: var integer): {   -- Implementation of a counting semaphores;   -- cnt is the initial value of the semaphore;   -- requires: cnt > 0%globa ..."} 
 -- ptn:invoke: "Semaphore(cnt: var integer)" E: "Semaphore(1)" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 2 adr:none 
 invoke Semaphore 216 2 1
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: Semaphore(1) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- $var:gen: "_V: var integer"  
 -- DI:gen: "_V: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  _V 
 -- $Property:gen: "%public"  
 -- $pattern:gen: "init:< entry{   "Monitor:init\n".print;   inner(init)" } 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%globals P_status, SQS, BasicSystemLib, Monitor, console, immutable, #MonitorProcess" 
 -- $Property:gen: "%globals P_status, SQS, BasicSystemLib, Monitor, console, immutable, #MonitorProcess"  
 -- genclass:stmt: "%interface entry" 
 -- $Property:gen: "%interface entry"  
 -- genclass:stmt: "%public" 
 -- $Property:gen: "%public"  
 -- genclass:stmt: "inner(Monitor)" 
 -- $ObjectGenerator:gen: "inner(Monitor)" >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inner(Monitor)" 
 -- OG:before:super.gen: "inner(Monitor)" 
 -- $Invocation:gen: "inner(Monitor)" >useRtnV:"False"superAdj: 0 descNo: 12 
 -- INV:gen: "inner(Monitor)" 
 -- isConstant: "Invocation" "inner(Monitor)" 
 -- needorigin: "inner(Monitor)" 
 -- needOrigin:E: "inner(Monitor)"  E.ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- doNeedOrigin:Ex: "inner(Monitor)" 
 -- computeAdr:superAdj: 0 "inner(Monitor)" 
 -- computeAdr: 1 :rec: "none"  E: "inner(Monitor)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "inner(Monitor)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "inner(Monitor)" >on:3 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "inner(Monitor)" >ATd.off:0 (isPtn):on:3:superAdj:0"inner: {   %basic 101;   in inner: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal:F ...} 
 -- $pattern:getAdr: "inner: {   %basic 101;   in inner: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Monitor)":rec:- 
 -- E.on: 3 
 -- beforeIsValueObj:E: "inner(Monitor)"  ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Monitor)":rec:- 
 -- computeAdr:isLast:E:  "inner(Monitor)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Monitor)":rec:- 
 -- rec:  "inner(Monitor)" E:  "inner(Monitor)" 
 -- INV:gen:E.loadArgs "inner(Monitor)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "inner(Monitor)" >staticOff:0 "inner: {   %basic 101;   in inner: ref Object" superAdj:0arg:"Monitor"} 
 -- $pattern:loadArgs: "inner: {   %basic 101;   in inner: ref Object" >E:"inner(Monitor)":descNo:12} 
 -- INV:gen:after:E.loadArgs "inner(Monitor)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(Monitor)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner( ..." 
 -- $ObjectInvocation_KeyWord:invoke: "inner(Monitor)" >rec:"inner(Monitor)" ATd:"pattern" E:"inner(Monitor)" E.ATd:"inner" unique:"False" 
 -- OI:invoke: "inner(Monitor)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Monitor)":rec:inner(Monitor) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Monitor)":rec:inner(Monitor) 
 -- OI:invoke:B: "inner(Monitor)" E: "inner(Monitor)"  rec: "inner(Monitor)"  useRtnV: false "inner: {   %basic 101;   in inner: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- $pattern:invoke: "inner: {   %basic 101;   in inner: ref Object" E: "inner(Monitor)" useRTNv: "False"} 
 -- ptn:invoke: "inner" E: "inner(Monitor)" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  3
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Monitor)":rec:inner(Monitor) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Monitor)":rec:inner(Monitor) 
 -- 
 -- OI:invoke:C: inner(Monitor) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Monitor)":rec:inner(Monitor) 
 L2:
 -- pushReturn:  "Monitor" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- vdtAdd: inx=3 descInx=215 vDescInx=0 vdtTop: 3 
 -- vdtAdd: inx=2 descInx=215 vDescInx=224 vdtTop: 3 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 216 
 -- Items:GenClass: Semaphore descNo: 216 isValue: false 
 -- Items:GenClass: Semaphore descNo: 21 isValue: false 

 CLASS Semaphore 216 0 SemaphoreLib 39
 -- Store itemArgs: -- Implementation of a counting semaphores{-- cnt is the initial value of the semaphore;-- requires: cnt > 0%globals;%public;wait: ;   theActive: ref Gener ...} 
 -- cnt: var integer true 1 
 -- DI:store: "cnt" 
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- vdtAdd: inx=1 descInx=216 vDescInx=216 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%globals"  
 -- $Property:gen: "%public"  
 -- $Property:gen: "%private"  
 -- $obj:gen: "M: obj Lock("M:Lock")"  
 -- DI:gen: "M: obj Lock("M:Lock")" DI:isConst: true :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  M 
 -- $ObjectGenerator:gen: "Lock("M:Lock")" >OGid:"Lock" IS.isempty! staticOff=2 descNo=0 superAdj=0 
 -- OG:gen: "Lock("M:Lock")" 
 -- OG:before:super.gen: "Lock("M:Lock")" 
 -- $Invocation:gen: "Lock("M:Lock")" >useRtnV:"False"superAdj: 0 descNo: 76 
 -- INV:gen: "Lock("M:Lock")" 
 -- isConstant: "Invocation" "Lock("M:Lock")" 
 -- needorigin: "Lock("M:Lock")" 
 -- needOrigin:E: "Lock("M:Lock")"  E.ATd: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%globals{   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ; ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "Lock("M:Lock")" E:  "Lock("M:Lock")" 
 -- INV:gen:E.loadArgs "Lock("M:Lock")" 
 -- $ObjectInvocation_KeyWord:loadArgs: "Lock("M:Lock")" >staticOff:0 "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init ..."} 
 -- $pattern:loadArgs: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ; ..."} 
 -- ptn:loadArgs:E "Lock("M:Lock")" 
 -- {(ObjectInvocation_KeyWord; (name: "Lock"); (Arguments;  (name: "Lock");  (name: "(");  (ObjectGenerator;   (Invocation;    (String: M:Lock));   (Items descNo: 0 origDescN ...} 
 -- args: "Lock("M:Lock")" 
 -- E: "ObjectGenerator" "M:Lock" 
 -- E.arg: "var" in id: var String 
 -- NonVirt: "Lock("M:Lock")" "ObjectInvocation_KeyWord" ActArg:  ""M:Lock"" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "Lock("M:Lock")"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: ""M:Lock"" >OGid:"String" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: ""M:Lock"" 
 -- OG:before:super.gen: ""M:Lock"" 
 -- $Invocation:gen: ""M:Lock"" >useRtnV:"True"superAdj: 0 
 -- INV:gen: ""M:Lock"" 
 -- isConstant: "Invocation" ""M:Lock"" 
 -- needorigin: ""M:Lock"" 
 -- needOrigin:E: ""M:Lock""  E.ATd: "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V :=  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  ""M:Lock"" E:  ""M:Lock"" 
 -- INV:gen:E.loadArgs ""M:Lock"" 
 -- $String::loadArgs: ""M:Lock""  
 -- INV:gen:after:E.loadArgs ""M:Lock"" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: String: ""M:Lock"" 
 -- $String::invoke: ""M:Lock""  
 pushText "M:Lock"
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in id: var String" :isBasicVal: false :valueObj: false 
 -- :actArg: ""M:Lock"" :isBasicVal: false 
 -- case:B: "M:Lock" ObjectGenerator 5 5 5 false false 
 -- end:loadArgs:NonVirt: "Lock("M:Lock")" 
 -- INV:gen:after:E.loadArgs "Lock("M:Lock")" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "Lock("M:Lock")" 
 -- $ObjectInvocation_KeyWord:invoke: "Lock("M:Lock")" >rec:"Lock("M:Lock")" ATd:"pattern" E:"Lock("M:Lock")" E.ATd:"Lock" unique:"False" 
 -- OI:invoke: "Lock("M:Lock")" 
 -- 
 -- OI:invoke:B: "Lock("M:Lock")" E: "Lock("M:Lock")"  rec: "Lock("M:Lock")"  useRtnV: false "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var int ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Lock 
 -- $pattern:invoke: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ;   ..."} 
 -- ptn:invoke: "Lock" E: "Lock("M:Lock")" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 2 adr:none 
 invoke Lock 76 2 1
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: Lock("M:Lock") :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- $obj:gen: "Q: obj LIB.Collections.QueueLib.Queue"  
 -- DI:gen: "Q: obj LIB.Collections.QueueLib.Queue" DI:isConst: true :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  Q 
 -- $ObjectGenerator:gen: "LIB.Collections.QueueLib.Queue" >OGid:"Queue" IS.isempty! staticOff=3 descNo=0 superAdj=0 
 -- OG:gen: "LIB.Collections.QueueLib.Queue" 
 -- OG:before:super.gen: "LIB.Collections.QueueLib.Queue" 
 -- $Invocation:gen: "LIB.Collections.QueueLib.Queue" >useRtnV:"False"superAdj: 0 descNo: 78 
 -- INV:gen: "LIB.Collections.QueueLib.Queue" 
 -- isConstant: "Invocation" "LIB.Collections.QueueLib.Queue" 
 -- needorigin: "LIB.Collections.QueueLib.Queue" 
 -- needOrigin:E: "Queue"  E.ATd: "Queue: {   %globals;   idf: var LIB.StringLib.String;   idc: var integer;   noOfElm: var integer;   Element: ;      in elm: ref Object;      ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%globals{   idf: var LIB.StringLib.String;   idc: var integer;   noOfElm: var integer;   Element: ;      in elm: ref Object;      out res: re ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "QueueLib" E:  "Queue" 
 -- INV:gen:E.loadArgs "Queue" 
 -- $ObjectInvocation_Unary:loadArgs: "Queue" >staticOff:0 "Queue: {   %globals;   idf: var LIB.StringLib.String;   idc: var integer;   noOfElm: var integer;   Element: ;      ..."} 
 -- $pattern:loadArgs: "Queue: {   %globals;   idf: var LIB.StringLib.String;   idc: var integer;   noOfElm: var integer;   Element: ;      in elm: ref Object;      out res: r ..."} 
 -- ptn:loadArgs:E "Queue" 
 -- {(ObjectInvocation_Unary; (name: "Queue"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "Queue" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "Queue" 
 -- $ObjectInvocation_Unary:invoke: "Queue" >rec:"QueueLib" ATd:"pattern" E:"Queue" E.ATd:"Queue" unique:"False" 
 -- OI:invoke: "Queue" 
 -- 
 -- OI:invoke:B: "Queue" E: "Queue"  rec: "QueueLib"  useRtnV: false "Queue: {   %globals;   idf: var LIB.StringLib.String;   idc: var integer;   noOfElm: var integer;   Eleme ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Queue 
 -- $pattern:invoke: "Queue: {   %globals;   idf: var LIB.StringLib.String;   idc: var integer;   noOfElm: var integer;   Element: ;      in elm: ref Object;      out res: ref ..."} 
 -- ptn:invoke: "Queue" E: "Queue" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 3 adr:none 
 invoke Queue 78 3 1
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 1 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: Queue :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%globals" 
 -- $Property:gen: "%globals"  
 -- genclass:stmt: "%public" 
 -- $Property:gen: "%public"  
 -- genclass:stmt: "%private" 
 -- $Property:gen: "%private"  
 -- genclass:stmt: "Q.idf := "Sem:"" 
 -- $Assign:gen: "Q.idf := "Sem:""  
 -- assign: "Q.idf := "Sem:"" 
 -- computeAdr:superAdj: 0 "Q.idf" 
 -- computeAdr: 1 :rec: "none"  E: "Q" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Q"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Q" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "Q" >ATd.off:3:on:0:superAdj:0"Q: obj LIB.Collections.QueueLib.Queue":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- $obj:getAdr: "Q: obj LIB.Collections.QueueLib.Queue" >newOff:3,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 ... 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "Q"  E: "idf" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "idf" >ATd.off:1:on:0:superAdj:0"idf: var LIB.StringLib.String":Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F orig ... 
 -- PING:String 0 -- Implementation of a counting semaphores{   -- cnt is the initial value of the semaphore;   -- requires: cnt > 0%globals;   %public;   wait: ;      theActi ...} 
 -- BOBS:ATd: "idf: var LIB.StringLib.String" 
 -- $var:getAdr: "idf: var LIB.StringLib.String" >newOff:1,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUniqu ... 
 -- $ObjectInvocation_Unary:loadArgs: "Q" >staticOff:0 "Q: obj LIB.Collections.QueueLib.Queue" superAdj:0 
 -- $obj:loadArgs: "Q: obj LIB.Collections.QueueLib.Queue" >E:"Q" 
 -- $pattern:loadArgs: "Queue: {   %globals;   idf: var LIB.StringLib.String;   idc: var integer;   noOfElm: var integer;   Element: ;      in elm: ref Object;      out res: r ..."} 
 -- ptn:loadArgs:E "Q" 
 -- {(ObjectInvocation_Unary; (name: "Q"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "Q" >rec:"Q" ATd:"obj" E:"idf" E.ATd:"idf" unique:"False" 
 -- OI:invoke: "Q" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"idf":rec:Q 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"idf":rec:Q 
 -- OI:invoke:B: "Q" E: "idf"  rec: "Q"  useRtnV: true "Q: obj LIB.Collections.QueueLib.Queue" 
 -- OI:invoke:before:ATdx.invoke: obj Q 
 -- $obj:invoke: "Q: obj LIB.Collections.QueueLib.Queue" E: "idf">newOff:3 useRTNv: "True" 
 -- DI:invoke: "Q: obj LIB.Collections.QueueLib.Queue" 
 -- >Object:unique: false 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"idf":rec:Q 
 -- isCompositeValueObj: false E: "idf" "idf: var LIB.StringLib.String" false 
 -- E.ATd.isValueObj: false rec: "Q" 
 rpushg Semaphore$216 3
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"idf":rec:Q 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"idf":rec:Q 
 -- 
 -- OI:invoke:C: Q :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "Q" E: "idf" 
 -- computeAdr:isLast:E:  "idf" 
 -- AssignmentStatement:gen: "Q.idf := "Sem:"" right.label: "ObjectGenerator" ""Sem:"" 
 -- $ObjectGenerator:gen: ""Sem:"" >OGid:"String" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: ""Sem:"" 
 -- OG:before:super.gen: ""Sem:"" 
 -- $Invocation:gen: ""Sem:"" >useRtnV:"True"superAdj: 0 
 -- INV:gen: ""Sem:"" 
 -- isConstant: "Invocation" ""Sem:"" 
 -- needorigin: ""Sem:"" 
 -- needOrigin:E: ""Sem:""  E.ATd: "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := ge ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  ""Sem:"" E:  ""Sem:"" 
 -- INV:gen:E.loadArgs ""Sem:"" 
 -- $String::loadArgs: ""Sem:""  
 -- INV:gen:after:E.loadArgs ""Sem:"" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: String: ""Sem:"" 
 -- $String::invoke: ""Sem:""  
 pushText "Sem:"
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "Q" dstE: "idf" dstE.ATd: "idf: var LIB.StringLib.String" useRtn: false :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"non ..." 
 -- dstDI.isBasicVal: false dstDI.isValObj: false dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- assign:adr.store:A: 
 -- store: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- isValue: false  isAdr: true  descNo:  0 
 rswap 0
 rstoreg  EisNone 1
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 1 V: R: 
   ;; vTop(0,0)=[] rTop(-2,1)=[]
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  "Semaphore" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 192 
 -- Items:GenClass: entry descNo: 192 isValue: false 
 -- Items:GenClass: entry descNo: 21 isValue: false 

 CLASS entry 192 1 Monitor 215
 -- Store itemArgs: %kind method{%arguments value, immutable;mutex.wait;_V := _V + 1;inner(entry);mutex.signal} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=192 vDescInx=192 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%kind method"  
 -- $Property:gen: "%arguments value, immutable"  
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%kind method" 
 -- $Property:gen: "%kind method"  
 -- genclass:stmt: "%arguments value, immutable" 
 -- $Property:gen: "%arguments value, immutable"  
 -- genclass:stmt: "mutex.wait" 
 -- $ObjectGenerator:gen: "mutex.wait" >OGid:"wait" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "mutex.wait" 
 -- OG:before:super.gen: "mutex.wait" 
 -- $Invocation:gen: "mutex.wait" >useRtnV:"False"superAdj: 0 descNo: 193 
 -- INV:gen: "mutex.wait" 
 -- isConstant: "Invocation" "mutex.wait" 
 -- needorigin: "mutex.wait" 
 -- needOrigin:E: "wait"  E.ATd: "wait: {   theActive: ref GeneralProcess;   M.get;   cnt := cnt - 1;   if (cnt < 0) :then ;      disable;      theActive := thisCore.main.acti ...}" 
 -- doNeedOrigin:Ex: "wait" 
 -- computeAdr:superAdj: 0 "mutex.wait" 
 -- computeAdr: 1 :rec: "none"  E: "mutex" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "mutex"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "mutex" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "entry" on: 1 isValueObj: false 
 -- origin: Monitor origin:isValueObj: false 
 rpushg entry$192 1
 -- $ObjectInvocation_Unary:getAdr: "mutex" >ATd.off:2:on:1:superAdj:0"mutex: obj BasicSystemLib.SemaphoreLib.Semaphore(1)":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 i ... 
 -- $obj:getAdr: "mutex: obj BasicSystemLib.SemaphoreLib.Semaphore(1)" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVa ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "mutex"  ATd: "mutex: obj BasicSystemLib.SemaphoreLib.Semaphore(1)" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "mutex"  E: "wait" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "wait" >ATd.off:0 (isPtn):on:0:superAdj:0"wait: {   theActive: ref GeneralProcess;   M.get;   cnt := cnt - 1;   if (cnt < 0) :then ;      d ..."} 
 -- $pattern:getAdr: "wait: {   theActive: ref GeneralProcess;   M.get;   cnt := cnt - 1;   if (cnt < 0) :then ;      disable;      theActive := thisCore.main.active;      Q.i ..."} 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"wait":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "mutex" >staticOff:0 "mutex: obj BasicSystemLib.SemaphoreLib.Semaphore(1)" superAdj:0 
 -- $obj:loadArgs: "mutex: obj BasicSystemLib.SemaphoreLib.Semaphore(1)" >E:"mutex" 
 -- $pattern:loadArgs: "Semaphore(cnt: var integer): {   -- Implementation of a counting semaphores;   -- cnt is the initial value of the semaphore;   -- requires: cnt > 0%glo ..."} 
 -- ptn:loadArgs:E "mutex" 
 -- {(ObjectInvocation_Unary; (name: "mutex"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "mutex" >rec:"mutex" ATd:"obj" E:"wait" E.ATd:"wait" unique:"False" 
 -- OI:invoke: "mutex" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"wait":rec:mutex 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"wait":rec:mutex 
 -- OI:invoke:B: "mutex" E: "wait"  rec: "mutex"  useRtnV: true "mutex: obj BasicSystemLib.SemaphoreLib.Semaphore(1)" 
 -- OI:invoke:before:ATdx.invoke: obj mutex 
 -- $obj:invoke: "mutex: obj BasicSystemLib.SemaphoreLib.Semaphore(1)" E: "wait">newOff:2 useRTNv: "True" 
 -- DI:invoke: "mutex: obj BasicSystemLib.SemaphoreLib.Semaphore(1)" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"wait":rec:mutex 
 rpushg entry$192 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"wait":rec:mutex 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"wait":rec:mutex 
 -- 
 -- OI:invoke:C: mutex :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "mutex" E: "wait" 
 -- computeAdr:isLast:E:  "wait" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"wait":rec:mutex 
 -- rec:  "mutex" E:  "wait" 
 -- INV:gen:E.loadArgs "wait" 
 -- $ObjectInvocation_Unary:loadArgs: "wait" >staticOff:0 "wait: {   theActive: ref GeneralProcess;   M.get;   cnt := cnt - 1;   if (cnt < 0) :then ;      disable;      theAct ..."} 
 -- $pattern:loadArgs: "wait: {   theActive: ref GeneralProcess;   M.get;   cnt := cnt - 1;   if (cnt < 0) :then ;      disable;      theActive := thisCore.main.active;      Q ..."} 
 -- ptn:loadArgs:E "wait" 
 -- {(ObjectInvocation_Unary; (name: "wait"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "wait" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "wait" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"wait":rec:mutex 
 -- $ObjectInvocation_Unary:invoke: "wait" >rec:"mutex" ATd:"pattern" E:"wait" E.ATd:"wait" unique:"False" 
 -- OI:invoke: "wait" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"wait":rec:mutex 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"wait":rec:mutex 
 -- OI:invoke:B: "wait" E: "wait"  rec: "mutex"  useRtnV: false "wait: {   theActive: ref GeneralProcess;   M.get;   cnt := cnt - 1;   if (cnt < 0) :then ;      disable;       ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern wait 
 -- $pattern:invoke: "wait: {   theActive: ref GeneralProcess;   M.get;   cnt := cnt - 1;   if (cnt < 0) :then ;      disable;      theActive := thisCore.main.active;      Q.i ..."} 
 -- ptn:invoke: "wait" E: "wait" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"wait":rec:mutex 
 invoke wait 193 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"wait":rec:mutex 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"wait":rec:mutex 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: wait :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"wait":rec:mutex 
 -- genclass:stmt: "_V := _V + 1" 
 -- $Assign:gen: "_V := _V + 1"  
 -- assign: "_V := _V + 1" 
 -- computeAdr:superAdj: 0 "_V" 
 -- computeAdr: 1 :rec: "none"  E: "_V" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "_V"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "_V" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "entry" on: 1 isValueObj: false 
 -- origin: Monitor origin:isValueObj: false 
 rpushg entry$192 1
 -- $ObjectInvocation_Unary:getAdr: "_V" >ATd.off:3:on:1:superAdj:0"_V: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- $var:getAdr: "_V: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F orig ... 
 -- DI:OG: integer 
 -- before:floatTest:  "_V: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"_V":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"_V":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "_V"  ATd: "_V: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"_V":rec:- 
 -- computeAdr:isLast:E:  "_V" 
 -- AssignmentStatement:gen: "_V := _V + 1" right.label: "ObjectGenerator" "_V + 1" 
 -- $ObjectGenerator:gen: "_V + 1" >OGid:"+" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "_V + 1" 
 -- OG:before:super.gen: "_V + 1" 
 -- $Invocation:gen: "_V + 1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "_V + 1" 
 -- isConstant: "Invocation" "_V + 1" 
 -- needorigin: "_V + 1" 
 -- needOrigin:E: "_V + 1"  E.ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- doNeedOrigin:Ex: "_V + 1" 
 -- computeAdr:superAdj: 0 "_V + 1" 
 -- computeAdr: 1 :rec: "none"  E: "_V + 1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "_V + 1"  
 -- $BinOp:loadOrigin: "_V + 1"  
 -- BinaryExp:loadOrigin:empty: "_V + 1" superAdj: 0 
 -- $BinOp:getAdr: "_V + 1"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "_V + 1"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "_V + 1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "_V + 1" E:  "_V + 1" 
 -- INV:gen:E.loadArgs "_V + 1" 
 -- $BinOp:loadArgs: "_V + 1"  
 -- BinaryExp:loadArgs: "_V + 1" superAdj: 0 
 -- $Invocation:gen: "_V" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "_V" 
 -- isConstant: "Invocation" "_V" 
 -- notConst: _V _V: var integer 
 -- needorigin: "_V" 
 -- needOrigin:E: "_V"  E.ATd: "_V: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "_V" 
 -- computeAdr: 1 :rec: "none"  E: "_V" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "_V"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "_V" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "entry" on: 1 isValueObj: false 
 -- origin: Monitor origin:isValueObj: false 
 rpushg entry$192 1
 -- $ObjectInvocation_Unary:getAdr: "_V" >ATd.off:3:on:1:superAdj:0"_V: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- $var:getAdr: "_V: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F orig ... 
 -- DI:OG: integer 
 -- before:floatTest:  "_V: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"_V":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"_V":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "_V"  ATd: "_V: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"_V":rec:- 
 -- computeAdr:isLast:E:  "_V" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"_V":rec:- 
 -- rec:  "_V" E:  "_V" 
 -- INV:gen:E.loadArgs "_V" 
 -- $ObjectInvocation_Unary:loadArgs: "_V" >staticOff:0 "_V: var integer" superAdj:0 
 -- $var:loadArgs: "_V: var integer" >E:"_V" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "_V" 
 -- {(ObjectInvocation_Unary; (name: "_V"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "_V" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "_V" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"_V":rec:- 
 -- $ObjectInvocation_Unary:invoke: "_V" >rec:"_V" ATd:"var" isValueObj E:"_V" E.ATd:"_V" unique:"False" 
 -- OI:invoke: "_V" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"_V":rec:_V 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"_V":rec:_V 
 -- OI:invoke:B: "_V" E: "_V"  rec: "_V"  useRtnV: true "_V: var integer" 
 -- OI:invoke:before:ATdx.invoke: var _V 
 -- $var:invoke: "_V: var integer" E: "_V">newOff:3 useRTNv: "True" 
 -- DI:invoke: "_V: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"_V":rec:_V 
 -- isCompositeValueObj: false E: "_V" "_V: var integer" true 
 -- E.ATd.isValueObj: false rec: "_V" 
 pushg 3 Monitor$215
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"_V":rec:_V 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"_V":rec:_V 
 -- 
 -- OI:invoke:C: _V :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- left:#I "_V + 1" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"_V":rec:_V 
 -- $pattern:loadArgs: "+  : {   %basic 61;   in V: var integer;   out R: var integer" >E:"+ 1":descNo:49} 
 -- ptn:loadArgs:E "+ 1" 
 -- {(ObjectInvocation_Binary; (name: "+"); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 1));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "1" 
 -- E: "ObjectGenerator" 1 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "+ 1" "ObjectInvocation_Binary" ActArg:  "1" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ 1"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "1" :isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "+ 1" 
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"_V":rec:_V 
 -- INV:gen:after:E.loadArgs "_V + 1" 
 -- OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"_V":rec:_V 
 -- IV:E.invoke:useRtnVal: true E: BinOp "_V + 1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"_V":rec:_V 
 -- $BinOp:invoke: "_V + 1"  
 -- BinaryExp:invoke: "_V" rec: "_V + 1" 
 -- M: "+ 1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"_V":rec:_V 
 -- $ObjectInvocation_Binary:invoke: "+ 1" >rec:"_V" ATd:"pattern" E:"+ 1" E.ATd:"+  " unique:"False" 
 -- OI:invoke: "+ 1" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"_V":rec:_V 
 -- origin:isValueObj "integer" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"_V":rec:_V 
 -- OI:invoke:B: "+ 1" E: "+ 1"  rec: "_V"  useRtnV: true "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- $pattern:invoke: "+  : {   %basic 61;   in V: var integer;   out R: var integer" E: "+ 1" useRTNv: "True"} 
 -- ptn:invoke: "+  " E: "+ 1" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "_V" E: "+ 1" 
 -- arg:integer 
 plus
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:_V 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:_V 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: + 1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "_V" dstE: "_V" dstE.ATd: "_V: var integer" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"_V":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "_V + 1" 
 -- isArgOfAssignI2IwithUniValArg "_V := _V + 1" arg: "_V + 1" ObjectGenerator 
 -- arg.super.arg: "_V + 1" BinOp 
 -- recx:BinaryExp:recx: "_V + 1" 
 -- M: "+ 1" label: "ObjectInvocation_Binary" M.ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- checkInt2IntWithUnitArg:rec: "_V" E: "+ 1" 
 -- arg:integer 
 -- M:arg: "1" ObjectGenerator false 
 -- dstDI: "_V: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"_V":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg Monitor$215 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "inner(entry)" 
 -- $ObjectGenerator:gen: "inner(entry)" >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inner(entry)" 
 -- OG:before:super.gen: "inner(entry)" 
 -- $Invocation:gen: "inner(entry)" >useRtnV:"False"superAdj: 0 descNo: 12 
 -- INV:gen: "inner(entry)" 
 -- isConstant: "Invocation" "inner(entry)" 
 -- needorigin: "inner(entry)" 
 -- needOrigin:E: "inner(entry)"  E.ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- doNeedOrigin:Ex: "inner(entry)" 
 -- computeAdr:superAdj: 0 "inner(entry)" 
 -- computeAdr: 1 :rec: "none"  E: "inner(entry)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "inner(entry)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "inner(entry)" >on:4 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "inner(entry)" >ATd.off:0 (isPtn):on:4:superAdj:0"inner: {   %basic 101;   in inner: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal:F s ...} 
 -- $pattern:getAdr: "inner: {   %basic 101;   in inner: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(entry)":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "inner(entry)"  ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(entry)":rec:- 
 -- computeAdr:isLast:E:  "inner(entry)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(entry)":rec:- 
 -- rec:  "inner(entry)" E:  "inner(entry)" 
 -- INV:gen:E.loadArgs "inner(entry)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "inner(entry)" >staticOff:0 "inner: {   %basic 101;   in inner: ref Object" superAdj:0arg:"entry"} 
 -- $pattern:loadArgs: "inner: {   %basic 101;   in inner: ref Object" >E:"inner(entry)":descNo:12} 
 -- INV:gen:after:E.loadArgs "inner(entry)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(entry)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(en ..." 
 -- $ObjectInvocation_KeyWord:invoke: "inner(entry)" >rec:"inner(entry)" ATd:"pattern" E:"inner(entry)" E.ATd:"inner" unique:"False" 
 -- OI:invoke: "inner(entry)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(entry)":rec:inner(entry) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(entry)":rec:inner(entry) 
 -- OI:invoke:B: "inner(entry)" E: "inner(entry)"  rec: "inner(entry)"  useRtnV: false "inner: {   %basic 101;   in inner: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- $pattern:invoke: "inner: {   %basic 101;   in inner: ref Object" E: "inner(entry)" useRTNv: "False"} 
 -- ptn:invoke: "inner" E: "inner(entry)" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(entry)":rec:inner(entry) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(entry)":rec:inner(entry) 
 -- 
 -- OI:invoke:C: inner(entry) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(entry)":rec:inner(entry) 
 -- genclass:stmt: "mutex.signal" 
 -- $ObjectGenerator:gen: "mutex.signal" >OGid:"signal" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "mutex.signal" 
 -- OG:before:super.gen: "mutex.signal" 
 -- $Invocation:gen: "mutex.signal" >useRtnV:"False"superAdj: 0 descNo: 198 
 -- INV:gen: "mutex.signal" 
 -- isConstant: "Invocation" "mutex.signal" 
 -- needorigin: "mutex.signal" 
 -- needOrigin:E: "signal"  E.ATd: "signal: {   P: ref GeneralProcess;   M.get;   cnt := cnt + 1;   if (cnt <= 0) :then ;      disable;      P := Q.removeNext;      P.mkActive ...}" 
 -- doNeedOrigin:Ex: "signal" 
 -- computeAdr:superAdj: 0 "mutex.signal" 
 -- computeAdr: 1 :rec: "none"  E: "mutex" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "mutex"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "mutex" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "entry" on: 1 isValueObj: false 
 -- origin: Monitor origin:isValueObj: false 
 rpushg entry$192 1
 -- $ObjectInvocation_Unary:getAdr: "mutex" >ATd.off:2:on:1:superAdj:0"mutex: obj BasicSystemLib.SemaphoreLib.Semaphore(1)":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 i ... 
 -- $obj:getAdr: "mutex: obj BasicSystemLib.SemaphoreLib.Semaphore(1)" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVa ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "mutex"  ATd: "mutex: obj BasicSystemLib.SemaphoreLib.Semaphore(1)" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "mutex"  E: "signal" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "signal" >ATd.off:0 (isPtn):on:0:superAdj:0"signal: {   P: ref GeneralProcess;   M.get;   cnt := cnt + 1;   if (cnt <= 0) :then ;      disa ..."} 
 -- $pattern:getAdr: "signal: {   P: ref GeneralProcess;   M.get;   cnt := cnt + 1;   if (cnt <= 0) :then ;      disable;      P := Q.removeNext;      P.mkActive;      --P.dcr ..."} 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"signal":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "mutex" >staticOff:0 "mutex: obj BasicSystemLib.SemaphoreLib.Semaphore(1)" superAdj:0 
 -- $obj:loadArgs: "mutex: obj BasicSystemLib.SemaphoreLib.Semaphore(1)" >E:"mutex" 
 -- $pattern:loadArgs: "Semaphore(cnt: var integer): {   -- Implementation of a counting semaphores;   -- cnt is the initial value of the semaphore;   -- requires: cnt > 0%glo ..."} 
 -- ptn:loadArgs:E "mutex" 
 -- {(ObjectInvocation_Unary; (name: "mutex"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "mutex" >rec:"mutex" ATd:"obj" E:"signal" E.ATd:"signal" unique:"False" 
 -- OI:invoke: "mutex" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"signal":rec:mutex 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"signal":rec:mutex 
 -- OI:invoke:B: "mutex" E: "signal"  rec: "mutex"  useRtnV: true "mutex: obj BasicSystemLib.SemaphoreLib.Semaphore(1)" 
 -- OI:invoke:before:ATdx.invoke: obj mutex 
 -- $obj:invoke: "mutex: obj BasicSystemLib.SemaphoreLib.Semaphore(1)" E: "signal">newOff:2 useRTNv: "True" 
 -- DI:invoke: "mutex: obj BasicSystemLib.SemaphoreLib.Semaphore(1)" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"signal":rec:mutex 
 rpushg entry$192 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"signal":rec:mutex 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"signal":rec:mutex 
 -- 
 -- OI:invoke:C: mutex :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "mutex" E: "signal" 
 -- computeAdr:isLast:E:  "signal" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"signal":rec:mutex 
 -- rec:  "mutex" E:  "signal" 
 -- INV:gen:E.loadArgs "signal" 
 -- $ObjectInvocation_Unary:loadArgs: "signal" >staticOff:0 "signal: {   P: ref GeneralProcess;   M.get;   cnt := cnt + 1;   if (cnt <= 0) :then ;      disable;      P := Q.re ..."} 
 -- $pattern:loadArgs: "signal: {   P: ref GeneralProcess;   M.get;   cnt := cnt + 1;   if (cnt <= 0) :then ;      disable;      P := Q.removeNext;      P.mkActive;      --P.d ..."} 
 -- ptn:loadArgs:E "signal" 
 -- {(ObjectInvocation_Unary; (name: "signal"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "signal" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "signal" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"signal":rec:mute ... 
 -- $ObjectInvocation_Unary:invoke: "signal" >rec:"mutex" ATd:"pattern" E:"signal" E.ATd:"signal" unique:"False" 
 -- OI:invoke: "signal" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"signal":rec:mutex 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"signal":rec:mutex 
 -- OI:invoke:B: "signal" E: "signal"  rec: "mutex"  useRtnV: false "signal: {   P: ref GeneralProcess;   M.get;   cnt := cnt + 1;   if (cnt <= 0) :then ;      disable;      P ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern signal 
 -- $pattern:invoke: "signal: {   P: ref GeneralProcess;   M.get;   cnt := cnt + 1;   if (cnt <= 0) :then ;      disable;      P := Q.removeNext;      P.mkActive;      --P.dcr ..."} 
 -- ptn:invoke: "signal" E: "signal" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"signal":rec:mutex 
 invoke signal 198 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"signal":rec:mutex 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"signal":rec:mutex 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: signal :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"signal":rec:mutex 
 L2:
 -- pushReturn:  "entry" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- vdtAdd: inx=2 descInx=192 vDescInx=0 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 193 
 -- Items:GenClass: wait descNo: 193 isValue: false 
 -- Items:GenClass: wait descNo: 21 isValue: false 

 CLASS wait 193 1 Semaphore 216
 -- Store itemArgs: theActive: ref GeneralProcess{M.get;cnt := cnt - 1;if (cnt < 0) :then ;   disable;   theActive := thisCore.main.active;   Q.insert(theActive);   enable;    ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=193 vDescInx=193 vdtTop: 1 
 mvStack 
 -- $ref:gen: "theActive: ref GeneralProcess"  
 -- DI:gen: "theActive: ref GeneralProcess" DI:isConst: false :isBasicValue: false :primNo: 0 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "M.get" 
 -- $ObjectGenerator:gen: "M.get" >OGid:"get" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "M.get" 
 -- OG:before:super.gen: "M.get" 
 -- $Invocation:gen: "M.get" >useRtnV:"False"superAdj: 0 descNo: 96 
 -- INV:gen: "M.get" 
 -- isConstant: "Invocation" "M.get" 
 -- needorigin: "M.get" 
 -- needOrigin:E: "get"  E.ATd: "get: {   loop: obj ;      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);      if (res = 1) :then ;   ...}" 
 -- doNeedOrigin:Ex: "get" 
 -- computeAdr:superAdj: 0 "M.get" 
 -- computeAdr: 1 :rec: "none"  E: "M" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "M"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "M" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "wait" on: 1 isValueObj: false 
 -- origin: Semaphore origin:isValueObj: false 
 rpushg wait$193 1
 -- $ObjectInvocation_Unary:getAdr: "M" >ATd.off:2:on:1:superAdj:0"M: obj Lock("M:Lock")":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue: ... 
 -- $obj:getAdr: "M: obj Lock("M:Lock")" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "M"  ATd: "M: obj Lock("M:Lock")" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "M"  E: "get" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "get" >ATd.off:0 (isPtn):on:0:superAdj:0"get: {   loop: obj ;      res: var integer;      i: var integer;      --disable;      res := free_ ..."} 
 -- $pattern:getAdr: "get: {   loop: obj ;      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);      if (res = 1) :then ;         slee ..."} 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "M" >staticOff:0 "M: obj Lock("M:Lock")" superAdj:0 
 -- $obj:loadArgs: "M: obj Lock("M:Lock")" >E:"M" 
 -- $pattern:loadArgs: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ; ..."} 
 -- ptn:loadArgs:E "M" 
 -- {(ObjectInvocation_Unary; (name: "M"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "M" >rec:"M" ATd:"obj" E:"get" E.ATd:"get" unique:"False" 
 -- OI:invoke: "M" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:M 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:M 
 -- OI:invoke:B: "M" E: "get"  rec: "M"  useRtnV: true "M: obj Lock("M:Lock")" 
 -- OI:invoke:before:ATdx.invoke: obj M 
 -- $obj:invoke: "M: obj Lock("M:Lock")" E: "get">newOff:2 useRTNv: "True" 
 -- DI:invoke: "M: obj Lock("M:Lock")" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:M 
 rpushg wait$193 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:M 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:M 
 -- 
 -- OI:invoke:C: M :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "M" E: "get" 
 -- computeAdr:isLast:E:  "get" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:M 
 -- rec:  "M" E:  "get" 
 -- INV:gen:E.loadArgs "get" 
 -- $ObjectInvocation_Unary:loadArgs: "get" >staticOff:0 "get: {   loop: obj ;      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);    ..."} 
 -- $pattern:loadArgs: "get: {   loop: obj ;      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);      if (res = 1) :then ;         sl ..."} 
 -- ptn:loadArgs:E "get" 
 -- {(ObjectInvocation_Unary; (name: "get"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "get" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "get" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:M 
 -- $ObjectInvocation_Unary:invoke: "get" >rec:"M" ATd:"pattern" E:"get" E.ATd:"get" unique:"False" 
 -- OI:invoke: "get" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:M 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:M 
 -- OI:invoke:B: "get" E: "get"  rec: "M"  useRtnV: false "get: {   loop: obj ;      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);   ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern get 
 -- $pattern:invoke: "get: {   loop: obj ;      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);      if (res = 1) :then ;         slee ..."} 
 -- ptn:invoke: "get" E: "get" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:M 
 invoke get 96 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:M 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:M 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: get :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:M 
 -- genclass:stmt: "cnt := cnt - 1" 
 -- $Assign:gen: "cnt := cnt - 1"  
 -- assign: "cnt := cnt - 1" 
 -- computeAdr:superAdj: 0 "cnt" 
 -- computeAdr: 1 :rec: "none"  E: "cnt" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "cnt"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "cnt" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "wait" on: 1 isValueObj: false 
 -- origin: Semaphore origin:isValueObj: false 
 rpushg wait$193 1
 -- $ObjectInvocation_Unary:getAdr: "cnt" >ATd.off:1:on:1:superAdj:0"cnt: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "cnt: var integer" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "cnt: var integer" ObjectGenerator 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:- 
 -- After:U*U: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "cnt"  ATd: "cnt: var integer" 
 -- computeAdr:isFirst: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:- 
 -- computeAdr:isLast:E:  "cnt" 
 -- AssignmentStatement:gen: "cnt := cnt - 1" right.label: "ObjectGenerator" "cnt - 1" 
 -- $ObjectGenerator:gen: "cnt - 1" >OGid:"-" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "cnt - 1" 
 -- OG:before:super.gen: "cnt - 1" 
 -- $Invocation:gen: "cnt - 1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "cnt - 1" 
 -- isConstant: "Invocation" "cnt - 1" 
 -- needorigin: "cnt - 1" 
 -- needOrigin:E: "cnt - 1"  E.ATd: "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- doNeedOrigin:Ex: "cnt - 1" 
 -- computeAdr:superAdj: 0 "cnt - 1" 
 -- computeAdr: 1 :rec: "none"  E: "cnt - 1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "cnt - 1"  
 -- $BinOp:loadOrigin: "cnt - 1"  
 -- BinaryExp:loadOrigin:empty: "cnt - 1" superAdj: 0 
 -- $BinOp:getAdr: "cnt - 1"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "cnt - 1"  ATd: "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "cnt - 1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "cnt - 1" E:  "cnt - 1" 
 -- INV:gen:E.loadArgs "cnt - 1" 
 -- $BinOp:loadArgs: "cnt - 1"  
 -- BinaryExp:loadArgs: "cnt - 1" superAdj: 0 
 -- $Invocation:gen: "cnt" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "cnt" 
 -- isConstant: "Invocation" "cnt" 
 -- notConst: cnt cnt: var integer 
 -- needorigin: "cnt" 
 -- needOrigin:E: "cnt"  E.ATd: "cnt: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "cnt" 
 -- computeAdr: 1 :rec: "none"  E: "cnt" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "cnt"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "cnt" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "wait" on: 1 isValueObj: false 
 -- origin: Semaphore origin:isValueObj: false 
 rpushg wait$193 1
 -- $ObjectInvocation_Unary:getAdr: "cnt" >ATd.off:1:on:1:superAdj:0"cnt: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "cnt: var integer" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "cnt: var integer" ObjectGenerator 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:- 
 -- After:U*U: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "cnt"  ATd: "cnt: var integer" 
 -- computeAdr:isFirst: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:- 
 -- computeAdr:isLast:E:  "cnt" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:- 
 -- rec:  "cnt" E:  "cnt" 
 -- INV:gen:E.loadArgs "cnt" 
 -- $ObjectInvocation_Unary:loadArgs: "cnt" >staticOff:0 "cnt: var integer" superAdj:0 
 -- $var:loadArgs: "cnt: var integer" >E:"cnt" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "cnt" 
 -- {(ObjectInvocation_Unary; (name: "cnt"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "cnt" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "cnt" :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:- 
 -- $ObjectInvocation_Unary:invoke: "cnt" >rec:"cnt" ATd:"var" isValueObj E:"cnt" E.ATd:"cnt" unique:"False" 
 -- OI:invoke: "cnt" 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- OI:invoke:B: "cnt" E: "cnt"  rec: "cnt"  useRtnV: true "cnt: var integer" 
 -- OI:invoke:before:ATdx.invoke: var cnt 
 -- $var:invoke: "cnt: var integer" E: "cnt">newOff:1 useRTNv: "True" 
 -- DI:invoke: "cnt: var integer" 
 -- load: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- isCompositeValueObj: false E: "cnt" "cnt: var integer" true 
 -- E.ATd.isValueObj: false rec: "cnt" 
 pushg 1 Semaphore$216
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- 
 -- OI:invoke:C: cnt :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 1 
 -- left:#I "cnt - 1" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- $pattern:loadArgs: "-  : {   %basic 62;   in V: var integer;   out R: var integer" >E:"- 1":descNo:108} 
 -- ptn:loadArgs:E "- 1" 
 -- {(ObjectInvocation_Binary; (name: "-"); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 1));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "1" 
 -- E: "ObjectGenerator" 1 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "- 1" "ObjectInvocation_Binary" ActArg:  "1" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "- 1"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "1" :isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "- 1" 
 -- BinaryExp:loadArgs:end: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- INV:gen:after:E.loadArgs "cnt - 1" 
 -- OIadr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- IV:E.invoke:useRtnVal: true E: BinOp "cnt - 1" :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- $BinOp:invoke: "cnt - 1"  
 -- BinaryExp:invoke: "cnt" rec: "cnt - 1" 
 -- M: "- 1" :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- $ObjectInvocation_Binary:invoke: "- 1" >rec:"cnt" ATd:"pattern" E:"- 1" E.ATd:"-  " unique:"False" 
 -- OI:invoke: "- 1" 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- origin:isValueObj "integer" 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- OI:invoke:B: "- 1" E: "- 1"  rec: "cnt"  useRtnV: true "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern -   
 -- $pattern:invoke: "-  : {   %basic 62;   in V: var integer;   out R: var integer" E: "- 1" useRTNv: "True"} 
 -- ptn:invoke: "-  " E: "- 1" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "cnt" E: "- 1" 
 -- arg:integer 
 minus
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"- 1":rec:cnt 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"- 1":rec:cnt 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: - 1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "cnt" dstE: "cnt" dstE.ATd: "cnt: var integer" useRtn: false :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "cnt - 1" 
 -- isArgOfAssignI2IwithUniValArg "cnt := cnt - 1" arg: "cnt - 1" ObjectGenerator 
 -- arg.super.arg: "cnt - 1" BinOp 
 -- recx:BinaryExp:recx: "cnt - 1" 
 -- M: "- 1" label: "ObjectInvocation_Binary" M.ATd: "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- checkInt2IntWithUnitArg:rec: "cnt" E: "- 1" 
 -- arg:integer 
 -- M:arg: "1" ObjectGenerator false 
 -- dstDI: "cnt: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg Semaphore$216 1
 -- assign:adr.store:B: 
 -- genclass:stmt: "if (cnt < 0) :then {   disable;   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive.addWaiting -- sets status = WAI ...}" 
 -- $ObjectGenerator:gen: "if (cnt < 0) :then {   disable;   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive.addWaiting -- sets statu ..."} 
 -- OG:gen: "if (cnt < 0) :then {   disable;   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive.addWaiting -- sets status = WAITING;   ...}" 
 -- OG:before:super.gen: "if (cnt < 0) :then {   disable;   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive.addWaiting -- sets status ...}" 
 -- $Invocation:gen: "if (cnt < 0) :then {   disable;   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive.addWaiting -- sets status = W ..."} 
 -- INV:gen: "if (cnt < 0) :then {   disable;   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive.addWaiting -- sets status = WAITING;  ...}" 
 -- isConstant: "Invocation" "if (cnt < 0) :then {   disable;   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive.addWaiting -- sets st ...}" 
 -- needorigin: "if (cnt < 0) :then {   disable;   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive.addWaiting -- sets status = WAITIN ...}" 
 -- needOrigin:E: "if (cnt < 0) :then {   disable;   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive.addWaiting -- sets status = WAIT ...}"   ... "i ..." 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (cnt < 0) :then {   disable;   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive.addWaiting -- sets status = WAITING;   t ...}" E ... "i ..." 
 -- INV:gen:E.loadArgs "if (cnt < 0) :then {   disable;   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive.addWaiting -- sets status = ...}" 
 -- $IfThenElse:loadArgs: "if (cnt < 0) :then {   disable;   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive.addWaiting -- sets statu ..."} 
 -- INV:gen:after:E.loadArgs "if (cnt < 0) :then {   disable;   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive.addWaiting -- sets st ...}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThenElse "if (cnt < 0) :then {   disable;   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive.add ...}" 
 -- $IfThenElse:invoke: "if (cnt < 0) :then {   disable;   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive.addWaiting -- sets status  ..."} 
 -- $IfThenElse:gen: "if (cnt < 0) :then {   disable;   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive.addWaiting -- sets status = W ..."} 
 -- $ObjectGenerator:gen: "(cnt < 0)" >OGid:"<" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(cnt < 0)" 
 -- OG:before:super.gen: "(cnt < 0)" 
 -- $Invocation:gen: "(cnt < 0)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(cnt < 0)" 
 -- isConstant: "Invocation" "(cnt < 0)" 
 -- needorigin: "(cnt < 0)" 
 -- needOrigin:E: "(cnt < 0)"  E.ATd: "<  : {   %basic 51;   in V: var integer;   out B: var boolean}" 
 -- doNeedOrigin:Ex: "(cnt < 0)" 
 -- computeAdr:superAdj: 0 "(cnt < 0)" 
 -- computeAdr: 1 :rec: "none"  E: "(cnt < 0)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(cnt < 0)"  
 -- $BracketedExp:loadOrigin: "(cnt < 0)"  
 -- computeAdr:superAdj: 0 "cnt < 0" 
 -- computeAdr: 1 :rec: "none"  E: "cnt < 0" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "cnt < 0"  
 -- $BinOp:loadOrigin: "cnt < 0"  
 -- BinaryExp:loadOrigin:empty: "cnt < 0" superAdj: 0 
 -- $BinOp:getAdr: "cnt < 0"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "cnt < 0"  ATd: "<  : {   %basic 51;   in V: var integer;   out B: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "cnt < 0" 
 -- BE:loadOrigin:E: cnt < 0 
 -- $BinOp:getAdr: "cnt < 0"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "cnt < 0"  ATd: "<  : {   %basic 51;   in V: var integer;   out B: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "cnt < 0" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "cnt < 0" E:  "cnt < 0" 
 -- INV:gen:E.loadArgs "cnt < 0" 
 -- $BinOp:loadArgs: "cnt < 0"  
 -- BinaryExp:loadArgs: "cnt < 0" superAdj: 0 
 -- $Invocation:gen: "cnt" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "cnt" 
 -- isConstant: "Invocation" "cnt" 
 -- notConst: cnt cnt: var integer 
 -- needorigin: "cnt" 
 -- needOrigin:E: "cnt"  E.ATd: "cnt: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "cnt" 
 -- computeAdr: 1 :rec: "none"  E: "cnt" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "cnt"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "cnt" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "wait" on: 1 isValueObj: false 
 -- origin: Semaphore origin:isValueObj: false 
 rpushg wait$193 1
 -- $ObjectInvocation_Unary:getAdr: "cnt" >ATd.off:1:on:1:superAdj:0"cnt: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "cnt: var integer" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "cnt: var integer" ObjectGenerator 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:- 
 -- After:U*U: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "cnt"  ATd: "cnt: var integer" 
 -- computeAdr:isFirst: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:- 
 -- computeAdr:isLast:E:  "cnt" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:- 
 -- rec:  "cnt" E:  "cnt" 
 -- INV:gen:E.loadArgs "cnt" 
 -- $ObjectInvocation_Unary:loadArgs: "cnt" >staticOff:0 "cnt: var integer" superAdj:0 
 -- $var:loadArgs: "cnt: var integer" >E:"cnt" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "cnt" 
 -- {(ObjectInvocation_Unary; (name: "cnt"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "cnt" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "cnt" :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:- 
 -- $ObjectInvocation_Unary:invoke: "cnt" >rec:"cnt" ATd:"var" isValueObj E:"cnt" E.ATd:"cnt" unique:"False" 
 -- OI:invoke: "cnt" 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- OI:invoke:B: "cnt" E: "cnt"  rec: "cnt"  useRtnV: true "cnt: var integer" 
 -- OI:invoke:before:ATdx.invoke: var cnt 
 -- $var:invoke: "cnt: var integer" E: "cnt">newOff:1 useRTNv: "True" 
 -- DI:invoke: "cnt: var integer" 
 -- load: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- isCompositeValueObj: false E: "cnt" "cnt: var integer" true 
 -- E.ATd.isValueObj: false rec: "cnt" 
 pushg 1 Semaphore$216
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -3 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- 
 -- OI:invoke:C: cnt :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 1 
 -- left:#I "cnt < 0" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- $pattern:loadArgs: "<  : {   %basic 51;   in V: var integer;   out B: var boolean" >E:"< 0":descNo:54} 
 -- ptn:loadArgs:E "< 0" 
 -- {(ObjectInvocation_Binary; (name: "<"); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 0));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "0" 
 -- E: "ObjectGenerator" 0 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "< 0" "ObjectInvocation_Binary" ActArg:  "0" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "< 0"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "0" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "0" 
 -- OG:before:super.gen: "0" 
 -- $Invocation:gen: "0" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "0" 
 -- isConstant: "Invocation" "0" 
 -- needorigin: "0" 
 -- needOrigin:E: "0"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "0" E:  "0" 
 -- INV:gen:E.loadArgs "0" 
 -- $ConstLiteral:loadArgs: "0"  
 -- INV:gen:after:E.loadArgs "0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0" 
 -- $ConstLiteral:invoke: "0"  
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "0" :isBasicVal: true 
 -- case:B: 0 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "< 0" 
 -- BinaryExp:loadArgs:end: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- INV:gen:after:E.loadArgs "cnt < 0" 
 -- OIadr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- IV:E.invoke:useRtnVal: true E: BinOp "cnt < 0" :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- $BinOp:invoke: "cnt < 0"  
 -- BinaryExp:invoke: "cnt" rec: "cnt < 0" 
 -- M: "< 0" :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- $ObjectInvocation_Binary:invoke: "< 0" >rec:"cnt" ATd:"pattern" E:"< 0" E.ATd:"<  " unique:"False" 
 -- OI:invoke: "< 0" 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- origin:isValueObj "integer" 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- OI:invoke:B: "< 0" E: "< 0"  rec: "cnt"  useRtnV: true "<  : {   %basic 51;   in V: var integer;   out B: var boolean}" 
 -- OI:invoke:before:ATdx.invoke: pattern <   
 -- $pattern:invoke: "<  : {   %basic 51;   in V: var integer;   out B: var boolean" E: "< 0" useRTNv: "True"} 
 -- ptn:invoke: "<  " E: "< 0" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "cnt" E: "< 0" 
 -- arg:integer 
 lt
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< 0":rec:cnt 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< 0":rec:cnt 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: < 0 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: "disable{   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive.addWaiting -- sets status = WAITING;   theActiv ..."} 
 -- OG:gen: "disable{   theActive := thisCore.main.active;   Q.insert(theActive);   enable;   M.free;   theActive.addWaiting -- sets status = WAITING;   theActive.suspend}" 
 pushThis 
 -- before objTmpStack:add:  194   "$194" 
 invoke $194 194 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L5
 L4:
 -- $ObjectGenerator:gen: "M.free" >OGid:"$197" singular! staticOff=0 descNo=197 superAdj=0 
 -- OG:gen: "M.free" 
 pushThis 
 -- before objTmpStack:add:  197   "$197" 
 invoke $197 197 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -5 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L5:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 -- pushReturn:  "wait" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 194 
 -- Items:GenClass: $194 descNo: 194 isValue: false 
 -- Items:GenClass: $194 descNo: 21 isValue: false 

 CLASS $194 194 1 wait 193
 -- Store itemArgs: disable{theActive := thisCore.main.active;Q.insert(theActive);enable;M.free;theActive.addWaiting -- sets status = WAITING;theActive.suspend} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=194 vDescInx=194 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "disable" 
 -- $ObjectGenerator:gen: "disable" >OGid:"disable" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "disable" 
 -- OG:before:super.gen: "disable" 
 -- $Invocation:gen: "disable" >useRtnV:"False"superAdj: 0 descNo: 195 
 -- INV:gen: "disable" 
 -- isConstant: "Invocation" "disable" 
 -- needorigin: "disable" 
 -- needOrigin:E: "disable"  E.ATd: "disable: {   %basic 11}" 
 -- doNeedOrigin:Ex: "disable" 
 -- computeAdr:superAdj: 0 "disable" 
 -- computeAdr: 1 :rec: "none"  E: "disable" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "disable"  
 -- $ObjectInvocation_Unary:loadOrigin: "disable" >on:5 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_Unary:getAdr: "disable" >ATd.off:0 (isPtn):on:5:superAdj:0"disable: {   %basic 11":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ...} 
 -- $pattern:getAdr: "disable: {   %basic 11" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"disable":rec:- 
 -- E.on: 5 
 -- beforeIsValueObj:E: "disable"  ATd: "disable: {   %basic 11}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"disable":rec:- 
 -- computeAdr:isLast:E:  "disable" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"disable":rec:- 
 -- rec:  "disable" E:  "disable" 
 -- INV:gen:E.loadArgs "disable" 
 -- $ObjectInvocation_Unary:loadArgs: "disable" >staticOff:0 "disable: {   %basic 11" superAdj:0} 
 -- $pattern:loadArgs: "disable: {   %basic 11" >E:"disable":descNo:195} 
 -- ptn:loadArgs:E "disable" 
 -- {(ObjectInvocation_Unary; (name: "disable"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "disable" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "disable" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"disable":rec:- 
 -- $ObjectInvocation_Unary:invoke: "disable" >rec:"disable" ATd:"pattern" E:"disable" E.ATd:"disable" unique:"False" 
 -- OI:invoke: "disable" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"disable":rec:disable 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"disable":rec:disable 
 -- OI:invoke:B: "disable" E: "disable"  rec: "disable"  useRtnV: false "disable: {   %basic 11}" 
 -- OI:invoke:before:ATdx.invoke: pattern disable 
 -- $pattern:invoke: "disable: {   %basic 11" E: "disable" useRTNv: "False"} 
 -- ptn:invoke: "disable" E: "disable" ptnKind: 0 useRtnV: false 
 %disable 11
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"disable":rec:disable 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"disable":rec:disable 
 -- 
 -- OI:invoke:C: disable :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"disable":rec:disable 
 -- genclass:stmt: "theActive := thisCore.main.active" 
 -- $Assign:gen: "theActive := thisCore.main.active"  
 -- assign: "theActive := thisCore.main.active" 
 -- computeAdr:superAdj: 0 "theActive" 
 -- computeAdr: 1 :rec: "none"  E: "theActive" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "theActive"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "theActive" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$194" on: 1 isValueObj: false 
 -- origin: wait origin:isValueObj: false 
 rpushg $194$194 1
 -- $ObjectInvocation_Unary:getAdr: "theActive" >ATd.off:2:on:1:superAdj:0"theActive: ref GeneralProcess":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- $ref:getAdr: "theActive: ref GeneralProcess" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUniqu ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "theActive"  ATd: "theActive: ref GeneralProcess" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "theActive" 
 -- AssignmentStatement:gen: "theActive := thisCore.main.active" right.label: "ObjectGenerator" "thisCore.main.active" 
 -- $ObjectGenerator:gen: "thisCore.main.active" >OGid:"GeneralProcess" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "thisCore.main.active" 
 -- OG:before:super.gen: "thisCore.main.active" 
 -- $Invocation:gen: "thisCore.main.active" >useRtnV:"True"superAdj: 0 descNo: 0 
 -- INV:gen: "thisCore.main.active" 
 -- isConstant: "Invocation" "thisCore.main.active" 
 -- needorigin: "thisCore.main.active" 
 -- needOrigin:E: "active"  E.ATd: "active: ref ProcessType" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "thisCore.main.active" 
 -- computeAdr: 1 :rec: "none"  E: "thisCore" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "thisCore"  
 -- $ObjectInvocation_Unary:loadOrigin: "thisCore" >on:5 superAdj:0 isValueObj:"False" 
 %thisCore 17
 -- $ObjectInvocation_Unary:getAdr: "thisCore" >ATd.off:0 (isPtn):on:5:superAdj:0"thisCore: {   -- BasicSystem:: Core should be moved to here!%basic 17;   out C: ref SuperCore ..."} 
 -- $pattern:getAdr: "thisCore: {   -- BasicSystem:: Core should be moved to here!%basic 17;   out C: ref SuperCore;   C := SuperCore" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"thisCore":rec:- 
 -- E.on: 5 
 -- beforeIsValueObj:E: "thisCore"  ATd: "thisCore: {   -- BasicSystem:: Core should be moved to here!%basic 17;   out C: ref SuperCore;   C := SuperCore}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"thisCore":rec:- 
 -- computeAdr: 2 :rec: "thisCore"  E: "main"  A.E: "thisCore" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"thisCore":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "main" >ATd.off:2:on:0:superAdj:0"main: ref SuperScheduler":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIs ... 
 -- $ref:getAdr: "main: ref SuperScheduler" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F i ... 
 -- $ObjectInvocation_Unary:loadArgs: "thisCore" >staticOff:0 "thisCore: {   -- BasicSystem:: Core should be moved to here!%basic 17;   out C: ref SuperCore;   C := SuperCore" ...} 
 -- $pattern:loadArgs: "thisCore: {   -- BasicSystem:: Core should be moved to here!%basic 17;   out C: ref SuperCore;   C := SuperCore" >E:"thisCore":descNo:0} 
 -- ptn:loadArgs:E "thisCore" 
 -- {(ObjectInvocation_Unary; (name: "thisCore"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "thisCore" >rec:"thisCore" ATd:"pattern" E:"main" E.ATd:"main" unique:"False" 
 -- OI:invoke: "thisCore" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"thisCore":rec:thisCore 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"thisCore":rec:thisCore 
 -- OI:invoke:B: "thisCore" E: "main"  rec: "thisCore"  useRtnV: true "thisCore: {   -- BasicSystem:: Core should be moved to here!%basic 17;   out C: ref SuperCore;   C := Su ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern thisCore 
 -- $pattern:invoke: "thisCore: {   -- BasicSystem:: Core should be moved to here!%basic 17;   out C: ref SuperCore;   C := SuperCore" E: "main" useRTNv: "True"} 
 -- ptn:invoke: "thisCore" E: "main" ptnKind: 0 useRtnV: true 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"main":rec:thisCore 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"main":rec:thisCore 
 -- 
 -- OI:invoke:C: thisCore :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "thisCore" E: "main" 
 -- computeAdr: 3 :rec: "main"  E: "active" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "active" >ATd.off:2:on:0:superAdj:0"active: ref ProcessType":Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- $ref:getAdr: "active: ref ProcessType" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F is ... 
 -- $ObjectInvocation_Unary:loadArgs: "main" >staticOff:0 "main: ref SuperScheduler" superAdj:0 
 -- $ref:loadArgs: "main: ref SuperScheduler" >E:"main" 
 -- $pattern:loadArgs: "SuperScheduler: {   thisScheduler:< Object;   ProcessType:< GeneralProcess;   active: ref ProcessType;   inner(SuperScheduler)" >E:"main":descNo:122} 
 -- ptn:loadArgs:E "main" 
 -- {(ObjectInvocation_Unary; (name: "main"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "main" >rec:"thisCore" ATd:"ref" E:"active" E.ATd:"active" unique:"False" 
 -- OI:invoke: "main" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"active":rec:thisCore 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"active":rec:thisCore 
 -- OI:invoke:B: "main" E: "active"  rec: "thisCore"  useRtnV: true "main: ref SuperScheduler" 
 -- OI:invoke:before:ATdx.invoke: ref main 
 -- $ref:invoke: "main: ref SuperScheduler" E: "active">newOff:2 useRTNv: "True" 
 -- DI:invoke: "main: ref SuperScheduler" 
 -- >Object:unique: false 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"active":rec:thisCore 
 -- isCompositeValueObj: false E: "active" "active: ref ProcessType" false 
 -- E.ATd.isValueObj: false rec: "thisCore" 
 rpushg $194$194 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"active":rec:thisCore 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"active":rec:thisCore 
 -- 
 -- OI:invoke:C: main :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "thisCore" E: "active" 
 -- computeAdr:isLast:E:  "active" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "main" E:  "active" 
 -- INV:gen:E.loadArgs "active" 
 -- $ObjectInvocation_Unary:loadArgs: "active" >staticOff:0 "active: ref ProcessType" superAdj:0 
 -- $ref:loadArgs: "active: ref ProcessType" >E:"active" 
 -- $pattern:loadArgs: "ProcessType:< GeneralProcess" >E:"active":descNo:0 
 -- ptn:loadArgs:E "active" 
 -- {(ObjectInvocation_Unary; (name: "active"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "active" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "active" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "active" >rec:"main" ATd:"ref" E:"active" E.ATd:"active" unique:"False" 
 -- OI:invoke: "active" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:main 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:main 
 -- OI:invoke:B: "active" E: "active"  rec: "main"  useRtnV: true "active: ref ProcessType" 
 -- OI:invoke:before:ATdx.invoke: ref active 
 -- $ref:invoke: "active: ref ProcessType" E: "active">newOff:2 useRTNv: "True" 
 -- DI:invoke: "active: ref ProcessType" 
 -- >Object:unique: false 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"active":rec:main 
 -- isCompositeValueObj: false E: "active" "active: ref ProcessType" false 
 -- E.ATd.isValueObj: false rec: "main" 
 rpushg $194$194 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"active":rec:main 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"active":rec:main 
 -- 
 -- OI:invoke:C: active :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"active":rec:main 
 -- rec: "theActive" dstE: "theActive" dstE.ATd: "theActive: ref GeneralProcess" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIs ... 
 -- dstDI.isBasicVal: false dstDI.isValObj: false dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- isValue: false  isAdr: true  descNo:  0 
 rswap 0
 rstoreg  EisNone 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- assign:adr.store:B: 
 -- genclass:stmt: "Q.insert(theActive)" 
 -- $ObjectGenerator:gen: "Q.insert(theActive)" >OGid:"insert" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "Q.insert(theActive)" 
 -- OG:before:super.gen: "Q.insert(theActive)" 
 -- $Invocation:gen: "Q.insert(theActive)" >useRtnV:"False"superAdj: 0 descNo: 142 
 -- INV:gen: "Q.insert(theActive)" 
 -- isConstant: "Invocation" "Q.insert(theActive)" 
 -- needorigin: "Q.insert(theActive)" 
 -- needOrigin:E: "insert(theActive)"  E.ATd: "insert: {   in elm: ref Object;   E: ref Element;   b: var BOOLEAN;   B := ELM =/= NONE;   --if (has(elm)) :then;   --    "inser ..."}" 
 -- doNeedOrigin:Ex: "insert(theActive)" 
 -- computeAdr:superAdj: 0 "Q.insert(theActive)" 
 -- computeAdr: 1 :rec: "none"  E: "Q" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Q"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Q" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$194" on: 2 isValueObj: false 
 -- origin: wait origin:isValueObj: false 
 rpushg $194$194 1
 -- items:goOrigin:encOG: "wait" on: 1 isValueObj: false 
 -- origin: Semaphore origin:isValueObj: false 
 rpushg wait$193 1
 -- $ObjectInvocation_Unary:getAdr: "Q" >ATd.off:3:on:2:superAdj:0"Q: obj LIB.Collections.QueueLib.Queue":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- $obj:getAdr: "Q: obj LIB.Collections.QueueLib.Queue" >newOff:3,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 ... 
 -- E.on: 2 
 -- beforeIsValueObj:E: "Q"  ATd: "Q: obj LIB.Collections.QueueLib.Queue" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "Q"  E: "insert(theActive)" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:getAdr: "insert(theActive)" >ATd.off:0 (isPtn):on:0:superAdj:0"insert: {   in elm: ref Object;   E: ref Element;   b: var BOOLEAN;   B := ELM =/= ..."} 
 -- $pattern:getAdr: "insert: {   in elm: ref Object;   E: ref Element;   b: var BOOLEAN;   B := ELM =/= NONE;   --if (has(elm)) :then;   --    "insert:leave\n".print;   --    ..."} 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(theActive)":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "Q" >staticOff:0 "Q: obj LIB.Collections.QueueLib.Queue" superAdj:0 
 -- $obj:loadArgs: "Q: obj LIB.Collections.QueueLib.Queue" >E:"Q" 
 -- $pattern:loadArgs: "Queue: {   %globals;   idf: var LIB.StringLib.String;   idc: var integer;   noOfElm: var integer;   Element: ;      in elm: ref Object;      out res: r ..."} 
 -- ptn:loadArgs:E "Q" 
 -- {(ObjectInvocation_Unary; (name: "Q"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "Q" >rec:"Q" ATd:"obj" E:"insert(theActive)" E.ATd:"insert" unique:"False" 
 -- OI:invoke: "Q" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(theActive)":rec:Q 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(theActive)":rec:Q 
 -- OI:invoke:B: "Q" E: "insert(theActive)"  rec: "Q"  useRtnV: true "Q: obj LIB.Collections.QueueLib.Queue" 
 -- OI:invoke:before:ATdx.invoke: obj Q 
 -- $obj:invoke: "Q: obj LIB.Collections.QueueLib.Queue" E: "insert(theActive)">newOff:3 useRTNv: "True" 
 -- DI:invoke: "Q: obj LIB.Collections.QueueLib.Queue" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(theActive)":rec:Q 
 rpushg $194$194 3
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(theActive)":rec:Q 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(theActive)":rec:Q 
 -- 
 -- OI:invoke:C: Q :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "Q" E: "insert(theActive)" 
 -- arg:other 
 -- computeAdr:isLast:E:  "insert(theActive)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(theActive)":rec:Q 
 -- rec:  "Q" E:  "insert(theActive)" 
 -- INV:gen:E.loadArgs "insert(theActive)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "insert(theActive)" >staticOff:0 "insert: {   in elm: ref Object;   E: ref Element;   b: var BOOLEAN;   B := ELM =/= NONE;   --if (has( ..."} 
 -- $pattern:loadArgs: "insert: {   in elm: ref Object;   E: ref Element;   b: var BOOLEAN;   B := ELM =/= NONE;   --if (has(elm)) :then;   --    "insert:leave\n".print;   --  ..."} 
 -- ptn:loadArgs:E "insert(theActive)" 
 -- {(ObjectInvocation_KeyWord; (name: "insert"); (Arguments;  (name: "insert");  (name: "(");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "theAct ..."} 
 -- args: "insert(theActive)" 
 -- E: "ObjectGenerator" theActive 
 -- E.arg: "ref" in elm: ref Object 
 -- NonVirt: "insert(theActive)" "ObjectInvocation_KeyWord" ActArg:  "theActive" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "insert(theActive)"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "theActive" >OGid:"GeneralProcess" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "theActive" 
 -- OG:before:super.gen: "theActive" 
 -- $Invocation:gen: "theActive" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "theActive" 
 -- isConstant: "Invocation" "theActive" 
 -- notConst: theActive theActive: ref GeneralProcess 
 -- needorigin: "theActive" 
 -- needOrigin:E: "theActive"  E.ATd: "theActive: ref GeneralProcess" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "theActive" 
 -- computeAdr: 1 :rec: "none"  E: "theActive" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "theActive"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "theActive" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$194" on: 1 isValueObj: false 
 -- origin: wait origin:isValueObj: false 
 rpushg $194$194 1
 -- $ObjectInvocation_Unary:getAdr: "theActive" >ATd.off:2:on:1:superAdj:0"theActive: ref GeneralProcess":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- $ref:getAdr: "theActive: ref GeneralProcess" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUniqu ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "theActive"  ATd: "theActive: ref GeneralProcess" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "theActive" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "theActive" E:  "theActive" 
 -- INV:gen:E.loadArgs "theActive" 
 -- $ObjectInvocation_Unary:loadArgs: "theActive" >staticOff:0 "theActive: ref GeneralProcess" superAdj:0 
 -- $ref:loadArgs: "theActive: ref GeneralProcess" >E:"theActive" 
 -- $pattern:loadArgs: "GeneralProcess(id: var LIB.StringLib.String): {   start:< ;      inner(start);   mkActive:< ;      inner(mkActive);   addWaiting:< ;      inner(addWait ..."} 
 -- ptn:loadArgs:E "theActive" 
 -- {(ObjectInvocation_Unary; (name: "theActive"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "theActive" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "theActive" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:invoke: "theActive" >rec:"theActive" ATd:"ref" E:"theActive" E.ATd:"theActive" unique:"False" 
 -- OI:invoke: "theActive" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:theActive 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:theActive 
 -- OI:invoke:B: "theActive" E: "theActive"  rec: "theActive"  useRtnV: true "theActive: ref GeneralProcess" 
 -- OI:invoke:before:ATdx.invoke: ref theActive 
 -- $ref:invoke: "theActive: ref GeneralProcess" E: "theActive">newOff:2 useRTNv: "True" 
 -- DI:invoke: "theActive: ref GeneralProcess" 
 -- >Object:unique: false 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"theActive":rec:theActive 
 -- isCompositeValueObj: false E: "theActive" "theActive: ref GeneralProcess" false 
 -- E.ATd.isValueObj: false rec: "theActive" 
 rpushg wait$193 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"theActive":rec:theActive 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"theActive":rec:theActive 
 -- 
 -- OI:invoke:C: theActive :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"theActive":rec:theActive 
 -- formalArg:isPtn: "in elm: ref Object" :isBasicVal: false :valueObj: false 
 -- :actArg: "theActive" :isBasicVal: false 
 -- case:B: theActive ObjectGenerator 64 0 0 false false 
 -- end:loadArgs:NonVirt: "insert(theActive)" 
 -- INV:gen:after:E.loadArgs "insert(theActive)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "insert(theActive)" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"ins ..." 
 -- $ObjectInvocation_KeyWord:invoke: "insert(theActive)" >rec:"Q" ATd:"pattern" E:"insert(theActive)" E.ATd:"insert" unique:"False" 
 -- OI:invoke: "insert(theActive)" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(theActive)":rec:Q 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(theActive)":rec:Q 
 -- OI:invoke:B: "insert(theActive)" E: "insert(theActive)"  rec: "Q"  useRtnV: false "insert: {   in elm: ref Object;   E: ref Element;   b: var BOOLEAN;   B := ELM =/= NONE; ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern insert 
 -- $pattern:invoke: "insert: {   in elm: ref Object;   E: ref Element;   b: var BOOLEAN;   B := ELM =/= NONE;   --if (has(elm)) :then;   --    "insert:leave\n".print;   --    ..."} 
 -- ptn:invoke: "insert" E: "insert(theActive)" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(theActive)":rec:Q 
 invoke insert 142 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(theActive)":rec:Q 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(theActive)":rec:Q 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: insert(theActive) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(theActive)":rec:Q 
 -- genclass:stmt: "enable" 
 -- $ObjectGenerator:gen: "enable" >OGid:"enable" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "enable" 
 -- OG:before:super.gen: "enable" 
 -- $Invocation:gen: "enable" >useRtnV:"False"superAdj: 0 descNo: 196 
 -- INV:gen: "enable" 
 -- isConstant: "Invocation" "enable" 
 -- needorigin: "enable" 
 -- needOrigin:E: "enable"  E.ATd: "enable: {   %basic 12}" 
 -- doNeedOrigin:Ex: "enable" 
 -- computeAdr:superAdj: 0 "enable" 
 -- computeAdr: 1 :rec: "none"  E: "enable" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "enable"  
 -- $ObjectInvocation_Unary:loadOrigin: "enable" >on:5 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_Unary:getAdr: "enable" >ATd.off:0 (isPtn):on:5:superAdj:0"enable: {   %basic 12":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F o ...} 
 -- $pattern:getAdr: "enable: {   %basic 12" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"enable":rec:- 
 -- E.on: 5 
 -- beforeIsValueObj:E: "enable"  ATd: "enable: {   %basic 12}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"enable":rec:- 
 -- computeAdr:isLast:E:  "enable" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"enable":rec:- 
 -- rec:  "enable" E:  "enable" 
 -- INV:gen:E.loadArgs "enable" 
 -- $ObjectInvocation_Unary:loadArgs: "enable" >staticOff:0 "enable: {   %basic 12" superAdj:0} 
 -- $pattern:loadArgs: "enable: {   %basic 12" >E:"enable":descNo:196} 
 -- ptn:loadArgs:E "enable" 
 -- {(ObjectInvocation_Unary; (name: "enable"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "enable" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "enable" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"enable":rec:- 
 -- $ObjectInvocation_Unary:invoke: "enable" >rec:"enable" ATd:"pattern" E:"enable" E.ATd:"enable" unique:"False" 
 -- OI:invoke: "enable" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"enable":rec:enable 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"enable":rec:enable 
 -- OI:invoke:B: "enable" E: "enable"  rec: "enable"  useRtnV: false "enable: {   %basic 12}" 
 -- OI:invoke:before:ATdx.invoke: pattern enable 
 -- $pattern:invoke: "enable: {   %basic 12" E: "enable" useRTNv: "False"} 
 -- ptn:invoke: "enable" E: "enable" ptnKind: 0 useRtnV: false 
 %enable 12
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"enable":rec:enable 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"enable":rec:enable 
 -- 
 -- OI:invoke:C: enable :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"enable":rec:enable 
 -- genclass:stmt: "M.free" 
 -- $ObjectGenerator:gen: "M.free" >OGid:"free" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "M.free" 
 -- OG:before:super.gen: "M.free" 
 -- $Invocation:gen: "M.free" >useRtnV:"False"superAdj: 0 descNo: 109 
 -- INV:gen: "M.free" 
 -- isConstant: "Invocation" "M.free" 
 -- needorigin: "M.free" 
 -- needOrigin:E: "free"  E.ATd: "free: {   free_M := 0}" 
 -- doNeedOrigin:Ex: "free" 
 -- computeAdr:superAdj: 0 "M.free" 
 -- computeAdr: 1 :rec: "none"  E: "M" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "M"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "M" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$194" on: 2 isValueObj: false 
 -- origin: wait origin:isValueObj: false 
 rpushg $194$194 1
 -- items:goOrigin:encOG: "wait" on: 1 isValueObj: false 
 -- origin: Semaphore origin:isValueObj: false 
 rpushg wait$193 1
 -- $ObjectInvocation_Unary:getAdr: "M" >ATd.off:2:on:2:superAdj:0"M: obj Lock("M:Lock")":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue: ... 
 -- $obj:getAdr: "M: obj Lock("M:Lock")" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa ... 
 -- E.on: 2 
 -- beforeIsValueObj:E: "M"  ATd: "M: obj Lock("M:Lock")" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "M"  E: "free" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "free" >ATd.off:0 (isPtn):on:0:superAdj:0"free: {   free_M := 0":Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ...} 
 -- $pattern:getAdr: "free: {   free_M := 0" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "M" >staticOff:0 "M: obj Lock("M:Lock")" superAdj:0 
 -- $obj:loadArgs: "M: obj Lock("M:Lock")" >E:"M" 
 -- $pattern:loadArgs: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ; ..."} 
 -- ptn:loadArgs:E "M" 
 -- {(ObjectInvocation_Unary; (name: "M"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "M" >rec:"M" ATd:"obj" E:"free" E.ATd:"free" unique:"False" 
 -- OI:invoke: "M" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:M 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:M 
 -- OI:invoke:B: "M" E: "free"  rec: "M"  useRtnV: true "M: obj Lock("M:Lock")" 
 -- OI:invoke:before:ATdx.invoke: obj M 
 -- $obj:invoke: "M: obj Lock("M:Lock")" E: "free">newOff:2 useRTNv: "True" 
 -- DI:invoke: "M: obj Lock("M:Lock")" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:M 
 rpushg $194$194 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:M 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:M 
 -- 
 -- OI:invoke:C: M :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "M" E: "free" 
 -- computeAdr:isLast:E:  "free" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:M 
 -- rec:  "M" E:  "free" 
 -- INV:gen:E.loadArgs "free" 
 -- $ObjectInvocation_Unary:loadArgs: "free" >staticOff:0 "free: {   free_M := 0" superAdj:0} 
 -- $pattern:loadArgs: "free: {   free_M := 0" >E:"free":descNo:109} 
 -- ptn:loadArgs:E "free" 
 -- {(ObjectInvocation_Unary; (name: "free"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "free" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "free" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:M 
 -- $ObjectInvocation_Unary:invoke: "free" >rec:"M" ATd:"pattern" E:"free" E.ATd:"free" unique:"False" 
 -- OI:invoke: "free" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:M 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:M 
 -- OI:invoke:B: "free" E: "free"  rec: "M"  useRtnV: false "free: {   free_M := 0}" 
 -- OI:invoke:before:ATdx.invoke: pattern free 
 -- $pattern:invoke: "free: {   free_M := 0" E: "free" useRTNv: "False"} 
 -- ptn:invoke: "free" E: "free" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:M 
 invoke free 109 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:M 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:M 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: free :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:M 
 -- genclass:stmt: "theActive.addWaiting -- sets status = WAITING" 
 -- $ObjectGenerator:gen: "theActive.addWaiting -- sets status = WAITING" >OGid:"addWaiting" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "theActive.addWaiting -- sets status = WAITING" 
 -- OG:before:super.gen: "theActive.addWaiting -- sets status = WAITING" 
 -- $Invocation:gen: "theActive.addWaiting -- sets status = WAITING" >useRtnV:"False"superAdj: 0 descNo: 134 
 -- INV:gen: "theActive.addWaiting -- sets status = WAITING" 
 -- isConstant: "Invocation" "theActive.addWaiting -- sets status = WAITING" 
 -- notConst: theActive theActive: ref GeneralProcess 
 -- needorigin: "theActive.addWaiting -- sets status = WAITING" 
 -- needOrigin:E: "addWaiting -- sets status = WAITING"  E.ATd: "addWaiting:< {   inner(addWaiting);   --put('R')}" 
 -- doNeedOrigin:Ex: "addWaiting -- sets status = WAITING" 
 -- computeAdr:superAdj: 0 "theActive.addWaiting -- sets status = WAITING" 
 -- computeAdr: 1 :rec: "none"  E: "theActive" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "theActive"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "theActive" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$194" on: 1 isValueObj: false 
 -- origin: wait origin:isValueObj: false 
 rpushg $194$194 1
 -- $ObjectInvocation_Unary:getAdr: "theActive" >ATd.off:2:on:1:superAdj:0"theActive: ref GeneralProcess":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- $ref:getAdr: "theActive: ref GeneralProcess" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUniqu ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "theActive"  ATd: "theActive: ref GeneralProcess" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "theActive"  E: "addWaiting -- sets status = WAITING" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "addWaiting -- sets status = WAITING" >ATd.off:0 (isPtn):on:0:superAdj:0"addWaiting:< {   inner(addWaiting);   --put('R')":Adr:off:2 size:0 ...} 
 -- $pattern:getAdr: "addWaiting:< {   inner(addWaiting);   --put('R')" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"addWaiting -- sets status = WAITING":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "theActive" >staticOff:0 "theActive: ref GeneralProcess" superAdj:0 
 -- $ref:loadArgs: "theActive: ref GeneralProcess" >E:"theActive" 
 -- $pattern:loadArgs: "GeneralProcess(id: var LIB.StringLib.String): {   start:< ;      inner(start);   mkActive:< ;      inner(mkActive);   addWaiting:< ;      inner(addWait ..."} 
 -- ptn:loadArgs:E "theActive" 
 -- {(ObjectInvocation_Unary; (name: "theActive"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "theActive" >rec:"theActive" ATd:"ref" E:"addWaiting -- sets status = WAITING" E.ATd:"addWaiting" unique:"False" 
 -- OI:invoke: "theActive" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"addWaiting -- sets status = WAITING":rec:theActive 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"addWaiting -- sets status = WAITING":rec:theActive 
 -- OI:invoke:B: "theActive" E: "addWaiting -- sets status = WAITING"  rec: "theActive"  useRtnV: true "theActive: ref GeneralProcess" 
 -- OI:invoke:before:ATdx.invoke: ref theActive 
 -- $ref:invoke: "theActive: ref GeneralProcess" E: "addWaiting -- sets status = WAITING">newOff:2 useRTNv: "True" 
 -- DI:invoke: "theActive: ref GeneralProcess" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"addWaiting -- sets status = WAITING":rec:theActive 
 rpushg $194$194 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"addWaiting -- sets status = WAITING":rec:theActive 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"addWaiting -- sets status = WAITING":rec:theActive 
 -- 
 -- OI:invoke:C: theActive :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "theActive" E: "addWaiting -- sets status = WAITING" 
 -- computeAdr:isLast:E:  "addWaiting -- sets status = WAITING" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"addWaiting -- sets status = WAITING":rec:theActi ... 
 -- rec:  "theActive" E:  "addWaiting -- sets status = WAITING" 
 -- INV:gen:E.loadArgs "addWaiting -- sets status = WAITING" 
 -- $ObjectInvocation_Unary:loadArgs: "addWaiting -- sets status = WAITING" >staticOff:0 "addWaiting:< {   inner(addWaiting);   --put('R')" superAdj:0} 
 -- $pattern:loadArgs: "addWaiting:< {   inner(addWaiting);   --put('R')" >E:"addWaiting -- sets status = WAITING":descNo:134} 
 -- ptn:loadArgs:E "addWaiting -- sets status = WAITING" 
 -- {(ObjectInvocation_Unary; (name: "addWaiting"); (Arguments --36> sets status = WAITING))} 
 -- args: "-- sets status = WAITING" 
 -- INV:gen:after:E.loadArgs "addWaiting -- sets status = WAITING" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "addWaiting -- sets status = WAITING" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origin ... 
 -- $ObjectInvocation_Unary:invoke: "addWaiting -- sets status = WAITING" >rec:"theActive" ATd:"pattern" E:"addWaiting -- sets status = WAITING" E.ATd:"addWaiting" unique:"Fal ..." 
 -- OI:invoke: "addWaiting -- sets status = WAITING" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"addWaiting -- sets status = WAITING":rec:theActive 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"addWaiting -- sets status = WAITING":rec:theActive 
 -- OI:invoke:B: "addWaiting -- sets status = WAITING" E: "addWaiting -- sets status = WAITING"  rec: "theActive"  useRtnV: false "addWaiting:< {   inner(addWaiting);   --put( ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern addWaiting 
 -- $pattern:invoke: "addWaiting:< {   inner(addWaiting);   --put('R')" E: "addWaiting -- sets status = WAITING" useRTNv: "False"} 
 -- ptn:invoke: "addWaiting" E: "addWaiting -- sets status = WAITING" ptnKind: 1 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 1 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"addWaiting -- sets status = WAITING":r ... 
 -- isDI 
 -- isStatic: false rec: "theActive" 
 invokev 4 0 addWaiting$134 0
 -- GeneralPTN:invoke:after:pushOut: 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -5 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"addWaiting -- sets status = WAITING":rec:theActive 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"addWaiting -- sets status = WAITING":rec:theActive 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: addWaiting -- sets status = WAITING :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"addWaiting -- sets status = WAITING":rec:theActive 
 -- genclass:stmt: "theActive.suspend" 
 -- $ObjectGenerator:gen: "theActive.suspend" >OGid:"suspend" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "theActive.suspend" 
 -- OG:before:super.gen: "theActive.suspend" 
 -- $Invocation:gen: "theActive.suspend" >useRtnV:"False"superAdj: 0 descNo: 84 
 -- INV:gen: "theActive.suspend" 
 -- isConstant: "Invocation" "theActive.suspend" 
 -- notConst: theActive theActive: ref GeneralProcess 
 -- needorigin: "theActive.suspend" 
 -- needOrigin:E: "suspend"  E.ATd: "suspend: {   %basic 111}" 
 -- doNeedOrigin:Ex: "suspend" 
 -- computeAdr:superAdj: 0 "theActive.suspend" 
 -- computeAdr: 1 :rec: "none"  E: "theActive" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "theActive"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "theActive" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$194" on: 1 isValueObj: false 
 -- origin: wait origin:isValueObj: false 
 rpushg $194$194 1
 -- $ObjectInvocation_Unary:getAdr: "theActive" >ATd.off:2:on:1:superAdj:0"theActive: ref GeneralProcess":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- $ref:getAdr: "theActive: ref GeneralProcess" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUniqu ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "theActive"  ATd: "theActive: ref GeneralProcess" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "theActive"  E: "suspend" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "suspend" >ATd.off:0 (isPtn):on:0:superAdj:0"suspend: {   %basic 111":Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ...} 
 -- $pattern:getAdr: "suspend: {   %basic 111" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "theActive" >staticOff:0 "theActive: ref GeneralProcess" superAdj:0 
 -- $ref:loadArgs: "theActive: ref GeneralProcess" >E:"theActive" 
 -- $pattern:loadArgs: "GeneralProcess(id: var LIB.StringLib.String): {   start:< ;      inner(start);   mkActive:< ;      inner(mkActive);   addWaiting:< ;      inner(addWait ..."} 
 -- ptn:loadArgs:E "theActive" 
 -- {(ObjectInvocation_Unary; (name: "theActive"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "theActive" >rec:"theActive" ATd:"ref" E:"suspend" E.ATd:"suspend" unique:"False" 
 -- OI:invoke: "theActive" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend":rec:theActive 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend":rec:theActive 
 -- OI:invoke:B: "theActive" E: "suspend"  rec: "theActive"  useRtnV: true "theActive: ref GeneralProcess" 
 -- OI:invoke:before:ATdx.invoke: ref theActive 
 -- $ref:invoke: "theActive: ref GeneralProcess" E: "suspend">newOff:2 useRTNv: "True" 
 -- DI:invoke: "theActive: ref GeneralProcess" 
 -- >Object:unique: false 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend":rec:theActive 
 -- isCompositeValueObj: false E: "suspend" "suspend: {   %basic 111}" false 
 -- E.ATd.isValueObj: false rec: "theActive" 
 rpushg $194$194 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend":rec:theActive 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend":rec:theActive 
 -- 
 -- OI:invoke:C: theActive :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "theActive" E: "suspend" 
 -- computeAdr:isLast:E:  "suspend" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend":rec:theActive 
 -- rec:  "theActive" E:  "suspend" 
 -- INV:gen:E.loadArgs "suspend" 
 -- $ObjectInvocation_Unary:loadArgs: "suspend" >staticOff:0 "suspend: {   %basic 111" superAdj:0} 
 -- $pattern:loadArgs: "suspend: {   %basic 111" >E:"suspend":descNo:84} 
 -- ptn:loadArgs:E "suspend" 
 -- {(ObjectInvocation_Unary; (name: "suspend"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "suspend" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "suspend" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend":rec:th ... 
 -- $ObjectInvocation_Unary:invoke: "suspend" >rec:"theActive" ATd:"pattern" E:"suspend" E.ATd:"suspend" unique:"False" 
 -- OI:invoke: "suspend" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend":rec:theActive 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend":rec:theActive 
 -- OI:invoke:B: "suspend" E: "suspend"  rec: "theActive"  useRtnV: false "suspend: {   %basic 111}" 
 -- OI:invoke:before:ATdx.invoke: pattern suspend 
 -- $pattern:invoke: "suspend: {   %basic 111" E: "suspend" useRTNv: "False"} 
 -- ptn:invoke: "suspend" E: "suspend" ptnKind: 0 useRtnV: false 
 suspend
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend":rec:theActive 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend":rec:theActive 
 -- 
 -- OI:invoke:C: suspend :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"suspend":rec:theActive 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 197 
 -- Items:GenClass: $197 descNo: 197 isValue: false 
 -- Items:GenClass: $197 descNo: 21 isValue: false 

 CLASS $197 197 1 wait 193
 -- Store itemArgs: M.free 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=197 vDescInx=197 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "M.free" 
 -- $ObjectGenerator:gen: "M.free" >OGid:"free" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "M.free" 
 -- OG:before:super.gen: "M.free" 
 -- $Invocation:gen: "M.free" >useRtnV:"False"superAdj: 0 descNo: 109 
 -- INV:gen: "M.free" 
 -- isConstant: "Invocation" "M.free" 
 -- needorigin: "M.free" 
 -- needOrigin:E: "free"  E.ATd: "free: {   free_M := 0}" 
 -- doNeedOrigin:Ex: "free" 
 -- computeAdr:superAdj: 0 "M.free" 
 -- computeAdr: 1 :rec: "none"  E: "M" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "M"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "M" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$197" on: 2 isValueObj: false 
 -- origin: wait origin:isValueObj: false 
 rpushg $197$197 1
 -- items:goOrigin:encOG: "wait" on: 1 isValueObj: false 
 -- origin: Semaphore origin:isValueObj: false 
 rpushg wait$193 1
 -- $ObjectInvocation_Unary:getAdr: "M" >ATd.off:2:on:2:superAdj:0"M: obj Lock("M:Lock")":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue: ... 
 -- $obj:getAdr: "M: obj Lock("M:Lock")" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa ... 
 -- E.on: 2 
 -- beforeIsValueObj:E: "M"  ATd: "M: obj Lock("M:Lock")" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "M"  E: "free" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "free" >ATd.off:0 (isPtn):on:0:superAdj:0"free: {   free_M := 0":Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ...} 
 -- $pattern:getAdr: "free: {   free_M := 0" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "M" >staticOff:0 "M: obj Lock("M:Lock")" superAdj:0 
 -- $obj:loadArgs: "M: obj Lock("M:Lock")" >E:"M" 
 -- $pattern:loadArgs: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ; ..."} 
 -- ptn:loadArgs:E "M" 
 -- {(ObjectInvocation_Unary; (name: "M"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "M" >rec:"M" ATd:"obj" E:"free" E.ATd:"free" unique:"False" 
 -- OI:invoke: "M" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:M 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:M 
 -- OI:invoke:B: "M" E: "free"  rec: "M"  useRtnV: true "M: obj Lock("M:Lock")" 
 -- OI:invoke:before:ATdx.invoke: obj M 
 -- $obj:invoke: "M: obj Lock("M:Lock")" E: "free">newOff:2 useRTNv: "True" 
 -- DI:invoke: "M: obj Lock("M:Lock")" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:M 
 rpushg $197$197 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:M 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:M 
 -- 
 -- OI:invoke:C: M :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "M" E: "free" 
 -- computeAdr:isLast:E:  "free" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:M 
 -- rec:  "M" E:  "free" 
 -- INV:gen:E.loadArgs "free" 
 -- $ObjectInvocation_Unary:loadArgs: "free" >staticOff:0 "free: {   free_M := 0" superAdj:0} 
 -- $pattern:loadArgs: "free: {   free_M := 0" >E:"free":descNo:109} 
 -- ptn:loadArgs:E "free" 
 -- {(ObjectInvocation_Unary; (name: "free"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "free" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "free" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:M 
 -- $ObjectInvocation_Unary:invoke: "free" >rec:"M" ATd:"pattern" E:"free" E.ATd:"free" unique:"False" 
 -- OI:invoke: "free" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:M 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:M 
 -- OI:invoke:B: "free" E: "free"  rec: "M"  useRtnV: false "free: {   free_M := 0}" 
 -- OI:invoke:before:ATdx.invoke: pattern free 
 -- $pattern:invoke: "free: {   free_M := 0" E: "free" useRTNv: "False"} 
 -- ptn:invoke: "free" E: "free" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:M 
 invoke free 109 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:M 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:M 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: free :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:M 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 198 
 -- Items:GenClass: signal descNo: 198 isValue: false 
 -- Items:GenClass: signal descNo: 21 isValue: false 

 CLASS signal 198 1 Semaphore 216
 -- Store itemArgs: P: ref GeneralProcess{M.get;cnt := cnt + 1;if (cnt <= 0) :then ;   disable;   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=198 vDescInx=198 vdtTop: 1 
 mvStack 
 -- $ref:gen: "P: ref GeneralProcess"  
 -- DI:gen: "P: ref GeneralProcess" DI:isConst: false :isBasicValue: false :primNo: 0 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "M.get" 
 -- $ObjectGenerator:gen: "M.get" >OGid:"get" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "M.get" 
 -- OG:before:super.gen: "M.get" 
 -- $Invocation:gen: "M.get" >useRtnV:"False"superAdj: 0 descNo: 96 
 -- INV:gen: "M.get" 
 -- isConstant: "Invocation" "M.get" 
 -- needorigin: "M.get" 
 -- needOrigin:E: "get"  E.ATd: "get: {   loop: obj ;      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);      if (res = 1) :then ;   ...}" 
 -- doNeedOrigin:Ex: "get" 
 -- computeAdr:superAdj: 0 "M.get" 
 -- computeAdr: 1 :rec: "none"  E: "M" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "M"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "M" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "signal" on: 1 isValueObj: false 
 -- origin: Semaphore origin:isValueObj: false 
 rpushg signal$198 1
 -- $ObjectInvocation_Unary:getAdr: "M" >ATd.off:2:on:1:superAdj:0"M: obj Lock("M:Lock")":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue: ... 
 -- $obj:getAdr: "M: obj Lock("M:Lock")" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "M"  ATd: "M: obj Lock("M:Lock")" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "M"  E: "get" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "get" >ATd.off:0 (isPtn):on:0:superAdj:0"get: {   loop: obj ;      res: var integer;      i: var integer;      --disable;      res := free_ ..."} 
 -- $pattern:getAdr: "get: {   loop: obj ;      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);      if (res = 1) :then ;         slee ..."} 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "M" >staticOff:0 "M: obj Lock("M:Lock")" superAdj:0 
 -- $obj:loadArgs: "M: obj Lock("M:Lock")" >E:"M" 
 -- $pattern:loadArgs: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ; ..."} 
 -- ptn:loadArgs:E "M" 
 -- {(ObjectInvocation_Unary; (name: "M"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "M" >rec:"M" ATd:"obj" E:"get" E.ATd:"get" unique:"False" 
 -- OI:invoke: "M" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:M 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:M 
 -- OI:invoke:B: "M" E: "get"  rec: "M"  useRtnV: true "M: obj Lock("M:Lock")" 
 -- OI:invoke:before:ATdx.invoke: obj M 
 -- $obj:invoke: "M: obj Lock("M:Lock")" E: "get">newOff:2 useRTNv: "True" 
 -- DI:invoke: "M: obj Lock("M:Lock")" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:M 
 rpushg signal$198 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:M 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:M 
 -- 
 -- OI:invoke:C: M :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "M" E: "get" 
 -- computeAdr:isLast:E:  "get" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:M 
 -- rec:  "M" E:  "get" 
 -- INV:gen:E.loadArgs "get" 
 -- $ObjectInvocation_Unary:loadArgs: "get" >staticOff:0 "get: {   loop: obj ;      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);    ..."} 
 -- $pattern:loadArgs: "get: {   loop: obj ;      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);      if (res = 1) :then ;         sl ..."} 
 -- ptn:loadArgs:E "get" 
 -- {(ObjectInvocation_Unary; (name: "get"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "get" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "get" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:M 
 -- $ObjectInvocation_Unary:invoke: "get" >rec:"M" ATd:"pattern" E:"get" E.ATd:"get" unique:"False" 
 -- OI:invoke: "get" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:M 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:M 
 -- OI:invoke:B: "get" E: "get"  rec: "M"  useRtnV: false "get: {   loop: obj ;      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);   ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern get 
 -- $pattern:invoke: "get: {   loop: obj ;      res: var integer;      i: var integer;      --disable;      res := free_M.cmpAndSwap(1);      if (res = 1) :then ;         slee ..."} 
 -- ptn:invoke: "get" E: "get" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:M 
 invoke get 96 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:M 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:M 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: get :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get":rec:M 
 -- genclass:stmt: "cnt := cnt + 1" 
 -- $Assign:gen: "cnt := cnt + 1"  
 -- assign: "cnt := cnt + 1" 
 -- computeAdr:superAdj: 0 "cnt" 
 -- computeAdr: 1 :rec: "none"  E: "cnt" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "cnt"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "cnt" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "signal" on: 1 isValueObj: false 
 -- origin: Semaphore origin:isValueObj: false 
 rpushg signal$198 1
 -- $ObjectInvocation_Unary:getAdr: "cnt" >ATd.off:1:on:1:superAdj:0"cnt: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "cnt: var integer" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "cnt: var integer" ObjectGenerator 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:- 
 -- After:U*U: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "cnt"  ATd: "cnt: var integer" 
 -- computeAdr:isFirst: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:- 
 -- computeAdr:isLast:E:  "cnt" 
 -- AssignmentStatement:gen: "cnt := cnt + 1" right.label: "ObjectGenerator" "cnt + 1" 
 -- $ObjectGenerator:gen: "cnt + 1" >OGid:"+" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "cnt + 1" 
 -- OG:before:super.gen: "cnt + 1" 
 -- $Invocation:gen: "cnt + 1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "cnt + 1" 
 -- isConstant: "Invocation" "cnt + 1" 
 -- needorigin: "cnt + 1" 
 -- needOrigin:E: "cnt + 1"  E.ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- doNeedOrigin:Ex: "cnt + 1" 
 -- computeAdr:superAdj: 0 "cnt + 1" 
 -- computeAdr: 1 :rec: "none"  E: "cnt + 1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "cnt + 1"  
 -- $BinOp:loadOrigin: "cnt + 1"  
 -- BinaryExp:loadOrigin:empty: "cnt + 1" superAdj: 0 
 -- $BinOp:getAdr: "cnt + 1"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "cnt + 1"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "cnt + 1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "cnt + 1" E:  "cnt + 1" 
 -- INV:gen:E.loadArgs "cnt + 1" 
 -- $BinOp:loadArgs: "cnt + 1"  
 -- BinaryExp:loadArgs: "cnt + 1" superAdj: 0 
 -- $Invocation:gen: "cnt" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "cnt" 
 -- isConstant: "Invocation" "cnt" 
 -- notConst: cnt cnt: var integer 
 -- needorigin: "cnt" 
 -- needOrigin:E: "cnt"  E.ATd: "cnt: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "cnt" 
 -- computeAdr: 1 :rec: "none"  E: "cnt" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "cnt"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "cnt" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "signal" on: 1 isValueObj: false 
 -- origin: Semaphore origin:isValueObj: false 
 rpushg signal$198 1
 -- $ObjectInvocation_Unary:getAdr: "cnt" >ATd.off:1:on:1:superAdj:0"cnt: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "cnt: var integer" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "cnt: var integer" ObjectGenerator 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:- 
 -- After:U*U: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "cnt"  ATd: "cnt: var integer" 
 -- computeAdr:isFirst: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:- 
 -- computeAdr:isLast:E:  "cnt" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:- 
 -- rec:  "cnt" E:  "cnt" 
 -- INV:gen:E.loadArgs "cnt" 
 -- $ObjectInvocation_Unary:loadArgs: "cnt" >staticOff:0 "cnt: var integer" superAdj:0 
 -- $var:loadArgs: "cnt: var integer" >E:"cnt" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "cnt" 
 -- {(ObjectInvocation_Unary; (name: "cnt"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "cnt" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "cnt" :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:- 
 -- $ObjectInvocation_Unary:invoke: "cnt" >rec:"cnt" ATd:"var" isValueObj E:"cnt" E.ATd:"cnt" unique:"False" 
 -- OI:invoke: "cnt" 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- OI:invoke:B: "cnt" E: "cnt"  rec: "cnt"  useRtnV: true "cnt: var integer" 
 -- OI:invoke:before:ATdx.invoke: var cnt 
 -- $var:invoke: "cnt: var integer" E: "cnt">newOff:1 useRTNv: "True" 
 -- DI:invoke: "cnt: var integer" 
 -- load: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- isCompositeValueObj: false E: "cnt" "cnt: var integer" true 
 -- E.ATd.isValueObj: false rec: "cnt" 
 pushg 1 Semaphore$216
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- 
 -- OI:invoke:C: cnt :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 1 
 -- left:#I "cnt + 1" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- $pattern:loadArgs: "+  : {   %basic 61;   in V: var integer;   out R: var integer" >E:"+ 1":descNo:49} 
 -- ptn:loadArgs:E "+ 1" 
 -- {(ObjectInvocation_Binary; (name: "+"); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 1));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "1" 
 -- E: "ObjectGenerator" 1 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "+ 1" "ObjectInvocation_Binary" ActArg:  "1" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ 1"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "1" :isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "+ 1" 
 -- BinaryExp:loadArgs:end: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- INV:gen:after:E.loadArgs "cnt + 1" 
 -- OIadr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- IV:E.invoke:useRtnVal: true E: BinOp "cnt + 1" :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- $BinOp:invoke: "cnt + 1"  
 -- BinaryExp:invoke: "cnt" rec: "cnt + 1" 
 -- M: "+ 1" :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- $ObjectInvocation_Binary:invoke: "+ 1" >rec:"cnt" ATd:"pattern" E:"+ 1" E.ATd:"+  " unique:"False" 
 -- OI:invoke: "+ 1" 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- origin:isValueObj "integer" 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- OI:invoke:B: "+ 1" E: "+ 1"  rec: "cnt"  useRtnV: true "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- $pattern:invoke: "+  : {   %basic 61;   in V: var integer;   out R: var integer" E: "+ 1" useRTNv: "True"} 
 -- ptn:invoke: "+  " E: "+ 1" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "cnt" E: "+ 1" 
 -- arg:integer 
 plus
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:cnt 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:cnt 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: + 1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "cnt" dstE: "cnt" dstE.ATd: "cnt: var integer" useRtn: false :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "cnt + 1" 
 -- isArgOfAssignI2IwithUniValArg "cnt := cnt + 1" arg: "cnt + 1" ObjectGenerator 
 -- arg.super.arg: "cnt + 1" BinOp 
 -- recx:BinaryExp:recx: "cnt + 1" 
 -- M: "+ 1" label: "ObjectInvocation_Binary" M.ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- checkInt2IntWithUnitArg:rec: "cnt" E: "+ 1" 
 -- arg:integer 
 -- M:arg: "1" ObjectGenerator false 
 -- dstDI: "cnt: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg Semaphore$216 1
 -- assign:adr.store:B: 
 -- genclass:stmt: "if (cnt <= 0) :then {   disable;   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable}" 
 -- $ObjectGenerator:gen: "if (cnt <= 0) :then {   disable;   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable" >OGid:"if:then$0" IS.isempty! stat ...} 
 -- OG:gen: "if (cnt <= 0) :then {   disable;   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable}" 
 -- OG:before:super.gen: "if (cnt <= 0) :then {   disable;   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable}" 
 -- $Invocation:gen: "if (cnt <= 0) :then {   disable;   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable" >useRtnV:"False"superAdj: 0} 
 -- INV:gen: "if (cnt <= 0) :then {   disable;   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable}" 
 -- isConstant: "Invocation" "if (cnt <= 0) :then {   disable;   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable}" 
 -- needorigin: "if (cnt <= 0) :then {   disable;   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable}" 
 -- needOrigin:E: "if (cnt <= 0) :then {   disable;   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable}"  E.ATd: "if(cond: var boolean):then{thenP ..." 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (cnt <= 0) :then {   disable;   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable}" E:  "if (cnt <= 0) :then {   disable;   P := Q.re ...}" 
 -- INV:gen:E.loadArgs "if (cnt <= 0) :then {   disable;   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable}" 
 -- $IfThen:loadArgs: "if (cnt <= 0) :then {   disable;   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable" } 
 -- INV:gen:after:E.loadArgs "if (cnt <= 0) :then {   disable;   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (cnt <= 0) :then {   disable;   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable}" 
 -- $IfThen:invoke: "if (cnt <= 0) :then {   disable;   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable" } 
 -- $IfThen:gen: "if (cnt <= 0) :then {   disable;   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable" } 
 -- $ObjectGenerator:gen: "(cnt <= 0)" >OGid:"<=" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(cnt <= 0)" 
 -- OG:before:super.gen: "(cnt <= 0)" 
 -- $Invocation:gen: "(cnt <= 0)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(cnt <= 0)" 
 -- isConstant: "Invocation" "(cnt <= 0)" 
 -- needorigin: "(cnt <= 0)" 
 -- needOrigin:E: "(cnt <= 0)"  E.ATd: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- doNeedOrigin:Ex: "(cnt <= 0)" 
 -- computeAdr:superAdj: 0 "(cnt <= 0)" 
 -- computeAdr: 1 :rec: "none"  E: "(cnt <= 0)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(cnt <= 0)"  
 -- $BracketedExp:loadOrigin: "(cnt <= 0)"  
 -- computeAdr:superAdj: 0 "cnt <= 0" 
 -- computeAdr: 1 :rec: "none"  E: "cnt <= 0" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "cnt <= 0"  
 -- $BinOp:loadOrigin: "cnt <= 0"  
 -- BinaryExp:loadOrigin:empty: "cnt <= 0" superAdj: 0 
 -- $BinOp:getAdr: "cnt <= 0"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "cnt <= 0"  ATd: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "cnt <= 0" 
 -- BE:loadOrigin:E: cnt <= 0 
 -- $BinOp:getAdr: "cnt <= 0"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "cnt <= 0"  ATd: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "cnt <= 0" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "cnt <= 0" E:  "cnt <= 0" 
 -- INV:gen:E.loadArgs "cnt <= 0" 
 -- $BinOp:loadArgs: "cnt <= 0"  
 -- BinaryExp:loadArgs: "cnt <= 0" superAdj: 0 
 -- $Invocation:gen: "cnt" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "cnt" 
 -- isConstant: "Invocation" "cnt" 
 -- notConst: cnt cnt: var integer 
 -- needorigin: "cnt" 
 -- needOrigin:E: "cnt"  E.ATd: "cnt: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "cnt" 
 -- computeAdr: 1 :rec: "none"  E: "cnt" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "cnt"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "cnt" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "signal" on: 1 isValueObj: false 
 -- origin: Semaphore origin:isValueObj: false 
 rpushg signal$198 1
 -- $ObjectInvocation_Unary:getAdr: "cnt" >ATd.off:1:on:1:superAdj:0"cnt: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "cnt: var integer" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "cnt: var integer" ObjectGenerator 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:- 
 -- After:U*U: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "cnt"  ATd: "cnt: var integer" 
 -- computeAdr:isFirst: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:- 
 -- computeAdr:isLast:E:  "cnt" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:- 
 -- rec:  "cnt" E:  "cnt" 
 -- INV:gen:E.loadArgs "cnt" 
 -- $ObjectInvocation_Unary:loadArgs: "cnt" >staticOff:0 "cnt: var integer" superAdj:0 
 -- $var:loadArgs: "cnt: var integer" >E:"cnt" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "cnt" 
 -- {(ObjectInvocation_Unary; (name: "cnt"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "cnt" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "cnt" :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:- 
 -- $ObjectInvocation_Unary:invoke: "cnt" >rec:"cnt" ATd:"var" isValueObj E:"cnt" E.ATd:"cnt" unique:"False" 
 -- OI:invoke: "cnt" 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- OI:invoke:B: "cnt" E: "cnt"  rec: "cnt"  useRtnV: true "cnt: var integer" 
 -- OI:invoke:before:ATdx.invoke: var cnt 
 -- $var:invoke: "cnt: var integer" E: "cnt">newOff:1 useRTNv: "True" 
 -- DI:invoke: "cnt: var integer" 
 -- load: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- isCompositeValueObj: false E: "cnt" "cnt: var integer" true 
 -- E.ATd.isValueObj: false rec: "cnt" 
 pushg 1 Semaphore$216
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -3 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- 
 -- OI:invoke:C: cnt :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 1 
 -- left:#I "cnt <= 0" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- $pattern:loadArgs: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean" >E:"<= 0":descNo:47} 
 -- ptn:loadArgs:E "<= 0" 
 -- {(ObjectInvocation_Binary; (name: "<="); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 0));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "0" 
 -- E: "ObjectGenerator" 0 
 -- E.arg: "var" in Veq: var this(Value) 
 -- NonVirt: "<= 0" "ObjectInvocation_Binary" ActArg:  "0" isValue:  true 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "<= 0"  isCompositeValueObj: true 
 -- $ObjectGenerator:gen: "0" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "0" 
 -- OG:before:super.gen: "0" 
 -- $Invocation:gen: "0" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "0" 
 -- isConstant: "Invocation" "0" 
 -- needorigin: "0" 
 -- needOrigin:E: "0"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "0" E:  "0" 
 -- INV:gen:E.loadArgs "0" 
 -- $ConstLiteral:loadArgs: "0"  
 -- INV:gen:after:E.loadArgs "0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0" 
 -- $ConstLiteral:invoke: "0"  
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- vEq: 
 -- end:loadArgs:NonVirt: "<= 0" 
 -- BinaryExp:loadArgs:end: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- INV:gen:after:E.loadArgs "cnt <= 0" 
 -- OIadr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- IV:E.invoke:useRtnVal: true E: BinOp "cnt <= 0" :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- $BinOp:invoke: "cnt <= 0"  
 -- BinaryExp:invoke: "cnt" rec: "cnt <= 0" 
 -- M: "<= 0" :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- $ObjectInvocation_Binary:invoke: "<= 0" >rec:"cnt" ATd:"pattern" E:"<= 0" E.ATd:"<=  " unique:"False" 
 -- OI:invoke: "<= 0" 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- origin:isValueObj "Value" 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"cnt":rec:cnt 
 -- OI:invoke:B: "<= 0" E: "<= 0"  rec: "cnt"  useRtnV: true "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- OI:invoke:before:ATdx.invoke: pattern <=   
 -- $pattern:invoke: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean" E: "<= 0" useRTNv: "True"} 
 -- ptn:invoke: "<=  " E: "<= 0" ptnKind: 1 useRtnV: true 
 -- rec: "cnt" "Invocation" OGx.label: "ObjectGenerator" OGx: integer 
 -- rec.ATd: "cnt: var integer" 
 -- bobs: 1 OGx: integer 
 le
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<= 0":rec:cnt 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<= 0":rec:cnt 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: <= 0 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: "disable{   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable" >OGid:"$199" singular! staticOff=0 descNo=199 superAdj=0} 
 -- OG:gen: "disable{   P := Q.removeNext;   P.mkActive;   --P.dcrWaiting -- SQS.dcrWaiting;   enable}" 
 pushThis 
 -- before objTmpStack:add:  199   "$199" 
 invoke $199 199 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "M.free" 
 -- $ObjectGenerator:gen: "M.free" >OGid:"free" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "M.free" 
 -- OG:before:super.gen: "M.free" 
 -- $Invocation:gen: "M.free" >useRtnV:"False"superAdj: 0 descNo: 109 
 -- INV:gen: "M.free" 
 -- isConstant: "Invocation" "M.free" 
 -- needorigin: "M.free" 
 -- needOrigin:E: "free"  E.ATd: "free: {   free_M := 0}" 
 -- doNeedOrigin:Ex: "free" 
 -- computeAdr:superAdj: 0 "M.free" 
 -- computeAdr: 1 :rec: "none"  E: "M" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "M"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "M" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "signal" on: 1 isValueObj: false 
 -- origin: Semaphore origin:isValueObj: false 
 rpushg signal$198 1
 -- $ObjectInvocation_Unary:getAdr: "M" >ATd.off:2:on:1:superAdj:0"M: obj Lock("M:Lock")":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue: ... 
 -- $obj:getAdr: "M: obj Lock("M:Lock")" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "M"  ATd: "M: obj Lock("M:Lock")" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "M"  E: "free" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "free" >ATd.off:0 (isPtn):on:0:superAdj:0"free: {   free_M := 0":Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ...} 
 -- $pattern:getAdr: "free: {   free_M := 0" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "M" >staticOff:0 "M: obj Lock("M:Lock")" superAdj:0 
 -- $obj:loadArgs: "M: obj Lock("M:Lock")" >E:"M" 
 -- $pattern:loadArgs: "Lock: {   %globals;   %Public;   in id: var String;   %private;   free_M: var integer;   %public;   init: ;      free_M := 0;   get: ;      loop: obj ; ..."} 
 -- ptn:loadArgs:E "M" 
 -- {(ObjectInvocation_Unary; (name: "M"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "M" >rec:"M" ATd:"obj" E:"free" E.ATd:"free" unique:"False" 
 -- OI:invoke: "M" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:M 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:M 
 -- OI:invoke:B: "M" E: "free"  rec: "M"  useRtnV: true "M: obj Lock("M:Lock")" 
 -- OI:invoke:before:ATdx.invoke: obj M 
 -- $obj:invoke: "M: obj Lock("M:Lock")" E: "free">newOff:2 useRTNv: "True" 
 -- DI:invoke: "M: obj Lock("M:Lock")" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:M 
 rpushg signal$198 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:M 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:M 
 -- 
 -- OI:invoke:C: M :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "M" E: "free" 
 -- computeAdr:isLast:E:  "free" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:M 
 -- rec:  "M" E:  "free" 
 -- INV:gen:E.loadArgs "free" 
 -- $ObjectInvocation_Unary:loadArgs: "free" >staticOff:0 "free: {   free_M := 0" superAdj:0} 
 -- $pattern:loadArgs: "free: {   free_M := 0" >E:"free":descNo:109} 
 -- ptn:loadArgs:E "free" 
 -- {(ObjectInvocation_Unary; (name: "free"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "free" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "free" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:M 
 -- $ObjectInvocation_Unary:invoke: "free" >rec:"M" ATd:"pattern" E:"free" E.ATd:"free" unique:"False" 
 -- OI:invoke: "free" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:M 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:M 
 -- OI:invoke:B: "free" E: "free"  rec: "M"  useRtnV: false "free: {   free_M := 0}" 
 -- OI:invoke:before:ATdx.invoke: pattern free 
 -- $pattern:invoke: "free: {   free_M := 0" E: "free" useRTNv: "False"} 
 -- ptn:invoke: "free" E: "free" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:M 
 invoke free 109 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -5 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:M 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:M 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: free :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"free":rec:M 
 L2:
 -- pushReturn:  "signal" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 199 
 -- Items:GenClass: $199 descNo: 199 isValue: false 
 -- Items:GenClass: $199 descNo: 21 isValue: false 

 CLASS $199 199 1 signal 198
 -- Store itemArgs: disable{P := Q.removeNext;P.mkActive;--P.dcrWaiting -- SQS.dcrWaiting;enable} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=199 vDescInx=199 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "disable" 
 -- $ObjectGenerator:gen: "disable" >OGid:"disable" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "disable" 
 -- OG:before:super.gen: "disable" 
 -- $Invocation:gen: "disable" >useRtnV:"False"superAdj: 0 descNo: 195 
 -- INV:gen: "disable" 
 -- isConstant: "Invocation" "disable" 
 -- needorigin: "disable" 
 -- needOrigin:E: "disable"  E.ATd: "disable: {   %basic 11}" 
 -- doNeedOrigin:Ex: "disable" 
 -- computeAdr:superAdj: 0 "disable" 
 -- computeAdr: 1 :rec: "none"  E: "disable" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "disable"  
 -- $ObjectInvocation_Unary:loadOrigin: "disable" >on:5 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_Unary:getAdr: "disable" >ATd.off:0 (isPtn):on:5:superAdj:0"disable: {   %basic 11":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ...} 
 -- $pattern:getAdr: "disable: {   %basic 11" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"disable":rec:- 
 -- E.on: 5 
 -- beforeIsValueObj:E: "disable"  ATd: "disable: {   %basic 11}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"disable":rec:- 
 -- computeAdr:isLast:E:  "disable" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"disable":rec:- 
 -- rec:  "disable" E:  "disable" 
 -- INV:gen:E.loadArgs "disable" 
 -- $ObjectInvocation_Unary:loadArgs: "disable" >staticOff:0 "disable: {   %basic 11" superAdj:0} 
 -- $pattern:loadArgs: "disable: {   %basic 11" >E:"disable":descNo:195} 
 -- ptn:loadArgs:E "disable" 
 -- {(ObjectInvocation_Unary; (name: "disable"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "disable" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "disable" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"disable":rec:- 
 -- $ObjectInvocation_Unary:invoke: "disable" >rec:"disable" ATd:"pattern" E:"disable" E.ATd:"disable" unique:"False" 
 -- OI:invoke: "disable" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"disable":rec:disable 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"disable":rec:disable 
 -- OI:invoke:B: "disable" E: "disable"  rec: "disable"  useRtnV: false "disable: {   %basic 11}" 
 -- OI:invoke:before:ATdx.invoke: pattern disable 
 -- $pattern:invoke: "disable: {   %basic 11" E: "disable" useRTNv: "False"} 
 -- ptn:invoke: "disable" E: "disable" ptnKind: 0 useRtnV: false 
 %disable 11
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"disable":rec:disable 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"disable":rec:disable 
 -- 
 -- OI:invoke:C: disable :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"disable":rec:disable 
 -- genclass:stmt: "P := Q.removeNext" 
 -- $Assign:gen: "P := Q.removeNext"  
 -- assign: "P := Q.removeNext" 
 -- computeAdr:superAdj: 0 "P" 
 -- computeAdr: 1 :rec: "none"  E: "P" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "P"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "P" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$199" on: 1 isValueObj: false 
 -- origin: signal origin:isValueObj: false 
 rpushg $199$199 1
 -- $ObjectInvocation_Unary:getAdr: "P" >ATd.off:2:on:1:superAdj:0"P: ref GeneralProcess":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue: ... 
 -- $ref:getAdr: "P: ref GeneralProcess" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "P"  ATd: "P: ref GeneralProcess" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "P" 
 -- AssignmentStatement:gen: "P := Q.removeNext" right.label: "ObjectGenerator" "Q.removeNext" 
 -- $ObjectGenerator:gen: "Q.removeNext" >OGid:"removeNext" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "Q.removeNext" 
 -- OG:before:super.gen: "Q.removeNext" 
 -- $Invocation:gen: "Q.removeNext" >useRtnV:"True"superAdj: 0 descNo: 168 
 -- INV:gen: "Q.removeNext" 
 -- isConstant: "Invocation" "Q.removeNext" 
 -- needorigin: "Q.removeNext" 
 -- needOrigin:E: "removeNext"  E.ATd: "removeNext: {   out elm: ref Object;   if (last =/= none) :then ;      noOfElm := noOfElm - 1;      elm := last.elm;      last := last. ...}" 
 -- doNeedOrigin:Ex: "removeNext" 
 -- computeAdr:superAdj: 0 "Q.removeNext" 
 -- computeAdr: 1 :rec: "none"  E: "Q" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Q"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Q" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$199" on: 2 isValueObj: false 
 -- origin: signal origin:isValueObj: false 
 rpushg $199$199 1
 -- items:goOrigin:encOG: "signal" on: 1 isValueObj: false 
 -- origin: Semaphore origin:isValueObj: false 
 rpushg signal$198 1
 -- $ObjectInvocation_Unary:getAdr: "Q" >ATd.off:3:on:2:superAdj:0"Q: obj LIB.Collections.QueueLib.Queue":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- $obj:getAdr: "Q: obj LIB.Collections.QueueLib.Queue" >newOff:3,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 ... 
 -- E.on: 2 
 -- beforeIsValueObj:E: "Q"  ATd: "Q: obj LIB.Collections.QueueLib.Queue" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "Q"  E: "removeNext" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "removeNext" >ATd.off:0 (isPtn):on:0:superAdj:0"removeNext: {   out elm: ref Object;   if (last =/= none) :then ;      noOfElm := noOfElm - ..."} 
 -- $pattern:getAdr: "removeNext: {   out elm: ref Object;   if (last =/= none) :then ;      noOfElm := noOfElm - 1;      elm := last.elm;      last := last.pred;      if (las ..."} 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "Q" >staticOff:0 "Q: obj LIB.Collections.QueueLib.Queue" superAdj:0 
 -- $obj:loadArgs: "Q: obj LIB.Collections.QueueLib.Queue" >E:"Q" 
 -- $pattern:loadArgs: "Queue: {   %globals;   idf: var LIB.StringLib.String;   idc: var integer;   noOfElm: var integer;   Element: ;      in elm: ref Object;      out res: r ..."} 
 -- ptn:loadArgs:E "Q" 
 -- {(ObjectInvocation_Unary; (name: "Q"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "Q" >rec:"Q" ATd:"obj" E:"removeNext" E.ATd:"removeNext" unique:"False" 
 -- OI:invoke: "Q" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:Q 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:Q 
 -- OI:invoke:B: "Q" E: "removeNext"  rec: "Q"  useRtnV: true "Q: obj LIB.Collections.QueueLib.Queue" 
 -- OI:invoke:before:ATdx.invoke: obj Q 
 -- $obj:invoke: "Q: obj LIB.Collections.QueueLib.Queue" E: "removeNext">newOff:3 useRTNv: "True" 
 -- DI:invoke: "Q: obj LIB.Collections.QueueLib.Queue" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:Q 
 rpushg $199$199 3
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:Q 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:Q 
 -- 
 -- OI:invoke:C: Q :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "Q" E: "removeNext" 
 -- computeAdr:isLast:E:  "removeNext" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:Q 
 -- rec:  "Q" E:  "removeNext" 
 -- INV:gen:E.loadArgs "removeNext" 
 -- $ObjectInvocation_Unary:loadArgs: "removeNext" >staticOff:0 "removeNext: {   out elm: ref Object;   if (last =/= none) :then ;      noOfElm := noOfElm - 1;      elm := las ..."} 
 -- $pattern:loadArgs: "removeNext: {   out elm: ref Object;   if (last =/= none) :then ;      noOfElm := noOfElm - 1;      elm := last.elm;      last := last.pred;      if (l ..."} 
 -- ptn:loadArgs:E "removeNext" 
 -- {(ObjectInvocation_Unary; (name: "removeNext"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "removeNext" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "removeNext" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":r ... 
 -- $ObjectInvocation_Unary:invoke: "removeNext" >rec:"Q" ATd:"pattern" E:"removeNext" E.ATd:"removeNext" unique:"False" 
 -- OI:invoke: "removeNext" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:Q 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:Q 
 -- OI:invoke:B: "removeNext" E: "removeNext"  rec: "Q"  useRtnV: true "removeNext: {   out elm: ref Object;   if (last =/= none) :then ;      noOfElm := noOfElm - 1;      elm ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern removeNext 
 -- $pattern:invoke: "removeNext: {   out elm: ref Object;   if (last =/= none) :then ;      noOfElm := noOfElm - 1;      elm := last.elm;      last := last.pred;      if (las ..."} 
 -- ptn:invoke: "removeNext" E: "removeNext" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:Q 
 invoke removeNext 168 0 0
 -- global:pushOut: elm off: 2 
 rpushg  2
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:Q 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:Q 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:Q 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:Q 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:Q 
 -- OI:invoke:C: removeNext :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"removeNext":rec:Q 
 -- rec: "P" dstE: "P" dstE.ATd: "P: ref GeneralProcess" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- dstDI.isBasicVal: false dstDI.isValObj: false dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- isValue: false  isAdr: true  descNo:  0 
 rswap 0
 rstoreg  EisNone 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- assign:adr.store:B: 
 -- genclass:stmt: "P.mkActive{--P.dcrWaiting -- SQS.dcrWaiting}" 
 -- $ObjectGenerator:gen: "P.mkActive{--P.dcrWaiting -- SQS.dcrWaiting" >OGid:"mkActive" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "P.mkActive{--P.dcrWaiting -- SQS.dcrWaiting}" 
 -- OG:before:super.gen: "P.mkActive{--P.dcrWaiting -- SQS.dcrWaiting}" 
 -- $Invocation:gen: "P.mkActive{--P.dcrWaiting -- SQS.dcrWaiting" >useRtnV:"False"superAdj: 0 descNo: 133} 
 -- INV:gen: "P.mkActive{--P.dcrWaiting -- SQS.dcrWaiting}" 
 -- isConstant: "Invocation" "P.mkActive{--P.dcrWaiting -- SQS.dcrWaiting}" 
 -- notConst: P P: ref GeneralProcess 
 -- needorigin: "P.mkActive{--P.dcrWaiting -- SQS.dcrWaiting}" 
 -- needOrigin:E: "mkActive{--P.dcrWaiting -- SQS.dcrWaiting}"  E.ATd: "mkActive:< {   inner(mkActive)}" 
 -- doNeedOrigin:Ex: "mkActive{--P.dcrWaiting -- SQS.dcrWaiting}" 
 -- computeAdr:superAdj: 0 "P.mkActive{--P.dcrWaiting -- SQS.dcrWaiting}" 
 -- computeAdr: 1 :rec: "none"  E: "P" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "P"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "P" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$199" on: 1 isValueObj: false 
 -- origin: signal origin:isValueObj: false 
 rpushg $199$199 1
 -- $ObjectInvocation_Unary:getAdr: "P" >ATd.off:2:on:1:superAdj:0"P: ref GeneralProcess":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue: ... 
 -- $ref:getAdr: "P: ref GeneralProcess" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "P"  ATd: "P: ref GeneralProcess" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "P"  E: "mkActive{--P.dcrWaiting -- SQS.dcrWaiting}" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "mkActive{--P.dcrWaiting -- SQS.dcrWaiting" >ATd.off:0 (isPtn):on:0:superAdj:0"mkActive:< ;   inner(mkActive)":Adr:off:2 size:0 isFloat:F i ...} 
 -- $pattern:getAdr: "mkActive:< {   inner(mkActive)" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mkActive{--P.dcrWaiting -- SQS.dcrWaiting":rec:-} 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "P" >staticOff:0 "P: ref GeneralProcess" superAdj:0 
 -- $ref:loadArgs: "P: ref GeneralProcess" >E:"P" 
 -- $pattern:loadArgs: "GeneralProcess(id: var LIB.StringLib.String): {   start:< ;      inner(start);   mkActive:< ;      inner(mkActive);   addWaiting:< ;      inner(addWait ..."} 
 -- ptn:loadArgs:E "P" 
 -- {(ObjectInvocation_Unary; (name: "P"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "P" >rec:"P" ATd:"ref" E:"mkActive{--P.dcrWaiting -- SQS.dcrWaiting" E.ATd:"mkActive" unique:"False"} 
 -- OI:invoke: "P" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mkActive{--P.dcrWaiting -- SQS.dcrWaiting":rec:P} 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mkActive{--P.dcrWaiting -- SQS.dcrWaiting":rec:P} 
 -- OI:invoke:B: "P" E: "mkActive{--P.dcrWaiting -- SQS.dcrWaiting}"  rec: "P"  useRtnV: true "P: ref GeneralProcess" 
 -- OI:invoke:before:ATdx.invoke: ref P 
 -- $ref:invoke: "P: ref GeneralProcess" E: "mkActive{--P.dcrWaiting -- SQS.dcrWaiting">newOff:2 useRTNv: "True"} 
 -- DI:invoke: "P: ref GeneralProcess" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mkActive{--P.dcrWaiting -- SQS.dcrWaiting":rec:P} 
 rpushg $199$199 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mkActive{--P.dcrWaiting -- SQS.dcrWaiting":rec:P} 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mkActive{--P.dcrWaiting -- SQS.dcrWaiting":rec:P} 
 -- 
 -- OI:invoke:C: P :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "P" E: "mkActive{--P.dcrWaiting -- SQS.dcrWaiting}" 
 -- computeAdr:isLast:E:  "mkActive{--P.dcrWaiting -- SQS.dcrWaiting}" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mkActive{--P.dcrWaiting -- SQS.dcrWaiting":rec:P ...} 
 -- rec:  "P" E:  "mkActive{--P.dcrWaiting -- SQS.dcrWaiting}" 
 -- INV:gen:E.loadArgs "mkActive{--P.dcrWaiting -- SQS.dcrWaiting}" 
 -- $ObjectInvocation_Unary:loadArgs: "mkActive{--P.dcrWaiting -- SQS.dcrWaiting" >staticOff:0 "mkActive:< ;   inner(mkActive)" superAdj:0} 
 -- $pattern:loadArgs: "mkActive:< {   inner(mkActive)" >E:"mkActive;--P.dcrWaiting -- SQS.dcrWaiting":descNo:133} 
 -- ptn:loadArgs:E "mkActive{--P.dcrWaiting -- SQS.dcrWaiting}" 
 -- {(ObjectInvocation_Unary; (name: "mkActive"); (Arguments --<15>P.dcrWaiting -- SQS.dcrWaiting))} 
 -- args: "--P.dcrWaiting -- SQS.dcrWaiting" 
 -- INV:gen:after:E.loadArgs "mkActive{--P.dcrWaiting -- SQS.dcrWaiting}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "mkActive{--P.dcrWaiting -- SQS.dcrWaiting}" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- $ObjectInvocation_Unary:invoke: "mkActive{--P.dcrWaiting -- SQS.dcrWaiting" >rec:"P" ATd:"pattern" E:"mkActive;--P.dcrWaiting -- SQS.dcrWaiting" E.ATd:"mkActive" unique:"F ..."} 
 -- OI:invoke: "mkActive{--P.dcrWaiting -- SQS.dcrWaiting}" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mkActive{--P.dcrWaiting -- SQS.dcrWaiting":rec:P} 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mkActive{--P.dcrWaiting -- SQS.dcrWaiting":rec:P} 
 -- OI:invoke:B: "mkActive{--P.dcrWaiting -- SQS.dcrWaiting}" E: "mkActive{--P.dcrWaiting -- SQS.dcrWaiting}"  rec: "P"  useRtnV: false "mkActive:< {   inner(mkActive)}" 
 -- OI:invoke:before:ATdx.invoke: pattern mkActive 
 -- $pattern:invoke: "mkActive:< {   inner(mkActive)" E: "mkActive;--P.dcrWaiting -- SQS.dcrWaiting" useRTNv: "False"} 
 -- ptn:invoke: "mkActive" E: "mkActive{--P.dcrWaiting -- SQS.dcrWaiting}" ptnKind: 1 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 1 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mkActive{--P.dcrWaiting -- SQS.dcrWait ..."} 
 -- isDI 
 -- isStatic: false rec: "P" 
 invokev 3 0 mkActive$133 0
 -- GeneralPTN:invoke:after:pushOut: 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mkActive{--P.dcrWaiting -- SQS.dcrWaiting":rec:P} 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mkActive{--P.dcrWaiting -- SQS.dcrWaiting":rec:P} 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: mkActive{--P.dcrWaiting -- SQS.dcrWaiting} :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mkActive{--P.dcrWaiting -- SQS.dcrWaiting":rec:P} 
 -- genclass:stmt: "enable" 
 -- $ObjectGenerator:gen: "enable" >OGid:"enable" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "enable" 
 -- OG:before:super.gen: "enable" 
 -- $Invocation:gen: "enable" >useRtnV:"False"superAdj: 0 descNo: 196 
 -- INV:gen: "enable" 
 -- isConstant: "Invocation" "enable" 
 -- needorigin: "enable" 
 -- needOrigin:E: "enable"  E.ATd: "enable: {   %basic 12}" 
 -- doNeedOrigin:Ex: "enable" 
 -- computeAdr:superAdj: 0 "enable" 
 -- computeAdr: 1 :rec: "none"  E: "enable" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "enable"  
 -- $ObjectInvocation_Unary:loadOrigin: "enable" >on:5 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_Unary:getAdr: "enable" >ATd.off:0 (isPtn):on:5:superAdj:0"enable: {   %basic 12":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F o ...} 
 -- $pattern:getAdr: "enable: {   %basic 12" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"enable":rec:- 
 -- E.on: 5 
 -- beforeIsValueObj:E: "enable"  ATd: "enable: {   %basic 12}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"enable":rec:- 
 -- computeAdr:isLast:E:  "enable" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"enable":rec:- 
 -- rec:  "enable" E:  "enable" 
 -- INV:gen:E.loadArgs "enable" 
 -- $ObjectInvocation_Unary:loadArgs: "enable" >staticOff:0 "enable: {   %basic 12" superAdj:0} 
 -- $pattern:loadArgs: "enable: {   %basic 12" >E:"enable":descNo:196} 
 -- ptn:loadArgs:E "enable" 
 -- {(ObjectInvocation_Unary; (name: "enable"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "enable" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "enable" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"enable":rec:- 
 -- $ObjectInvocation_Unary:invoke: "enable" >rec:"enable" ATd:"pattern" E:"enable" E.ATd:"enable" unique:"False" 
 -- OI:invoke: "enable" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"enable":rec:enable 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"enable":rec:enable 
 -- OI:invoke:B: "enable" E: "enable"  rec: "enable"  useRtnV: false "enable: {   %basic 12}" 
 -- OI:invoke:before:ATdx.invoke: pattern enable 
 -- $pattern:invoke: "enable: {   %basic 12" E: "enable" useRTNv: "False"} 
 -- ptn:invoke: "enable" E: "enable" ptnKind: 0 useRtnV: false 
 %enable 12
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"enable":rec:enable 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"enable":rec:enable 
 -- 
 -- OI:invoke:C: enable :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"enable":rec:enable 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 224 
 -- Items:GenClass: init descNo: 224 isValue: false 
 -- Items:GenClass: init descNo: 192 isValue: false 
 -- Items:GenClass: entry descNo: 21 isValue: false 

 CLASS init 224 1 Monitor 215
 -- vdtTableCopy: I:1:192 I:2:0
 -- vdtAdd: inx=2 descInx=224 vDescInx=224 vdtTop: 2 
 -- Store itemArgs: "Monitor:init\n".print{inner(init)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 -- super entry
 -- push:super.origin: 
 -- computeAdr:superAdj: 1 "entry" 
 -- computeAdr: 1 :rec: "none"  E: "entry" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "entry"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "entry" >on:0 superAdj:1 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 1 
 rpushg Monitor$215 1
 -- $ObjectInvocation_Unary:getAdr: "entry" >ATd.off:0 (isPtn):on:0:superAdj:1"entry: {   %kind method;   %arguments value, immutable;   mutex.wait;   _V := _V + 1;   inner(en ..."} 
 -- $pattern:getAdr: "entry: {   %kind method;   %arguments value, immutable;   mutex.wait;   _V := _V + 1;   inner(entry);   mutex.signal" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"entry":rec:- 
 -- E.on: 0 
 -- beforeIsValueObj:E: "entry"  ATd: "entry: {   %kind method;   %arguments value, immutable;   mutex.wait;   _V := _V + 1;   inner(entry);   mutex.signal}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"entry":rec:- 
 -- computeAdr:isLast:E:  "entry" 
 -- genClass:after:pushAddress: "entry" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"entry":rec:- 
 -- handleSuperArgs:E: "entry" theIS: ""Monitor:init\n".print{inner(init)}" 
 -- super.sig:not:none:superAdj: -1 
 -- $ObjectInvocation_Unary:loadArgs: "entry" >staticOff:0 "entry: {   %kind method;   %arguments value, immutable;   mutex.wait;   _V := _V + 1;   inner(entry);   mutex.signa ..."} 
 -- $pattern:loadArgs: "entry: {   %kind method;   %arguments value, immutable;   mutex.wait;   _V := _V + 1;   inner(entry);   mutex.signal" >E:"entry":descNo:192} 
 -- ptn:loadArgs:E "entry" 
 -- {(ObjectInvocation_Unary; (name: "entry"); (Arguments))} 
 -- args: "" 
 -- hArgOrg:super: entry 
 -- Store itemArgs: "Monitor:init\n".print{inner(init)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=224 vDescInx=192 vdtTop: 2 
 -- $Property:gen: "%kind method"  
 -- $Property:gen: "%arguments value, immutable"  
 rtnAlloc 1
 toSuper 192
DO:
 mvStack 
 L1:
 -- genclass:stmt: ""Monitor:init\n".print" 
 -- $ObjectGenerator:gen: ""Monitor:init\n".print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: ""Monitor:init\n".print" 
 -- OG:before:super.gen: ""Monitor:init\n".print" 
 -- $Invocation:gen: ""Monitor:init\n".print" >useRtnV:"False"superAdj: 0 descNo: 103 
 -- INV:gen: ""Monitor:init\n".print" 
 -- isConstant: "Invocation" ""Monitor:init\n".print" 
 -- needorigin: ""Monitor:init\n".print" 
 -- needOrigin:E: "print"  E.ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  ""Monitor:init\n"" E:  ""Monitor:init\n"" 
 -- INV:gen:E.loadArgs ""Monitor:init\n"" 
 -- $String::loadArgs: ""Monitor:init\n""  
 -- INV:gen:after:E.loadArgs ""Monitor:init\n"" 
 -- OIadr: 
 -- $String::invoke: ""Monitor:init\n""  
 pushText "Monitor:init\n"
 -- IV:gen:checkTail: ""Monitor:init\n".print" E: ""Monitor:init\n"" tail: "print"  not isLast: false 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " superAdj:0} 
 -- $pattern:loadArgs: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " >E:"print":descNo:103} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:""Monitor:init\n"" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- 
 -- OI:invoke:B: "print" E: "print"  rec: ""Monitor:init\n""  useRtnV: false "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke print 103 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "inner(init)" 
 -- $ObjectGenerator:gen: "inner(init)" >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inner(init)" 
 -- OG:before:super.gen: "inner(init)" 
 -- $Invocation:gen: "inner(init)" >useRtnV:"False"superAdj: 0 descNo: 12 
 -- INV:gen: "inner(init)" 
 -- isConstant: "Invocation" "inner(init)" 
 -- needorigin: "inner(init)" 
 -- needOrigin:E: "inner(init)"  E.ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- doNeedOrigin:Ex: "inner(init)" 
 -- computeAdr:superAdj: 0 "inner(init)" 
 -- computeAdr: 1 :rec: "none"  E: "inner(init)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "inner(init)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "inner(init)" >on:4 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "inner(init)" >ATd.off:0 (isPtn):on:4:superAdj:0"inner: {   %basic 101;   in inner: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal:F su ...} 
 -- $pattern:getAdr: "inner: {   %basic 101;   in inner: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(init)":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "inner(init)"  ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(init)":rec:- 
 -- computeAdr:isLast:E:  "inner(init)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(init)":rec:- 
 -- rec:  "inner(init)" E:  "inner(init)" 
 -- INV:gen:E.loadArgs "inner(init)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "inner(init)" >staticOff:0 "inner: {   %basic 101;   in inner: ref Object" superAdj:0arg:"init"} 
 -- $pattern:loadArgs: "inner: {   %basic 101;   in inner: ref Object" >E:"inner(init)":descNo:12} 
 -- INV:gen:after:E.loadArgs "inner(init)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(init)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(ini ..." 
 -- $ObjectInvocation_KeyWord:invoke: "inner(init)" >rec:"inner(init)" ATd:"pattern" E:"inner(init)" E.ATd:"inner" unique:"False" 
 -- OI:invoke: "inner(init)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(init)":rec:inner(init) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(init)":rec:inner(init) 
 -- OI:invoke:B: "inner(init)" E: "inner(init)"  rec: "inner(init)"  useRtnV: false "inner: {   %basic 101;   in inner: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- $pattern:invoke: "inner: {   %basic 101;   in inner: ref Object" E: "inner(init)" useRTNv: "False"} 
 -- ptn:invoke: "inner" E: "inner(init)" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  1
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(init)":rec:inner(init) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(init)":rec:inner(init) 
 -- 
 -- OI:invoke:C: inner(init) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(init)":rec:inner(init) 
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0
 -- vdtAdd: inx=1 descInx=224 vDescInx=0 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 217 
 -- Items:GenClass: myM descNo: 217 isValue: false 
 -- Items:GenClass: myM descNo: 215 isValue: false 
 -- Items:GenClass: Monitor descNo: 21 isValue: false 

 CLASS myM 217 1 MonitorDemo 189
 -- vdtTableCopy: I:1:215 V:2:224 I:3:0
 -- vdtAdd: inx=3 descInx=217 vDescInx=217 vdtTop: 3 
 -- Store itemArgs: print(S: var String): entry{   S.print;putItem(msg: var String):value(V: var integer):res(res: var integer): entry;   put(10);   put('<');   msg.print;   p ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 -- super Monitor
 -- push:super.origin: 
 -- computeAdr:superAdj: 1 "Monitor" 
 -- computeAdr: 1 :rec: "none"  E: "Monitor" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Monitor"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Monitor" >on:0 superAdj:1 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 1 
 rpushg MonitorDemo$189 1
 -- $ObjectInvocation_Unary:getAdr: "Monitor" >ATd.off:0 (isPtn):on:0:superAdj:1"Monitor: {   %globals P_status, SQS, BasicSystemLib, Monitor, console, immutable, #MonitorProc ..."} 
 -- $pattern:getAdr: "Monitor: {   %globals P_status, SQS, BasicSystemLib, Monitor, console, immutable, #MonitorProcess;   %interface entry;   mutex: obj BasicSystemLib.Semaph ..."} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"Monitor":rec:- 
 -- E.on: 0 
 -- beforeIsValueObj:E: "Monitor"  ATd: "Monitor: {   %globals P_status, SQS, BasicSystemLib, Monitor, console, immutable, #MonitorProcess;   %interface entry;   mutex: obj Ba ...}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"Monitor":rec:- 
 -- computeAdr:isLast:E:  "Monitor" 
 -- genClass:after:pushAddress: "Monitor" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"Monitor":rec:- 
 -- handleSuperArgs:E: "Monitor" theIS: "print(S: var String): entry{   S.print;putItem(msg: var String):value(V: var integer):res(res: var integer): entry;   put(10);   put(' ...}" 
 -- super.sig:none:superAdj: 1 
 -- $ObjectInvocation_Unary:loadArgs: "Monitor" >staticOff:0 "Monitor: {   %globals P_status, SQS, BasicSystemLib, Monitor, console, immutable, #MonitorProcess;   %interface e ..."} 
 -- $pattern:loadArgs: "Monitor: {   %globals P_status, SQS, BasicSystemLib, Monitor, console, immutable, #MonitorProcess;   %interface entry;   mutex: obj BasicSystemLib.Sema ..."} 
 -- ptn:loadArgs:E "Monitor" 
 -- {(ObjectInvocation_Unary; (name: "Monitor"); (Arguments))} 
 -- args: "" 
 -- hArgOrg:super: Monitor 
 -- Store itemArgs: print(S: var String): entry{   S.print;putItem(msg: var String):value(V: var integer):res(res: var integer): entry;   put(10);   put('<');   msg.print;   p ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=217 vDescInx=215 vdtTop: 3 
 -- $Property:gen: "%globals P_status, SQS, BasicSystemLib, Monitor, console, immutable, #MonitorProcess"  
 -- $Property:gen: "%interface entry"  
 -- $obj:gen: "mutex: obj BasicSystemLib.SemaphoreLib.Semaphore(1)"  
 -- DI:gen: "mutex: obj BasicSystemLib.SemaphoreLib.Semaphore(1)" DI:isConst: true :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  mutex 
 -- $ObjectGenerator:gen: "BasicSystemLib.SemaphoreLib.Semaphore(1)" >OGid:"Semaphore" IS.isempty! staticOff=2 descNo=0 superAdj=0 
 -- OG:gen: "BasicSystemLib.SemaphoreLib.Semaphore(1)" 
 -- OG:before:super.gen: "BasicSystemLib.SemaphoreLib.Semaphore(1)" 
 -- $Invocation:gen: "BasicSystemLib.SemaphoreLib.Semaphore(1)" >useRtnV:"False"superAdj: 0 descNo: 216 
 -- INV:gen: "BasicSystemLib.SemaphoreLib.Semaphore(1)" 
 -- isConstant: "Invocation" "BasicSystemLib.SemaphoreLib.Semaphore(1)" 
 -- needorigin: "BasicSystemLib.SemaphoreLib.Semaphore(1)" 
 -- needOrigin:E: "Semaphore(1)"  E.ATd: "Semaphore(cnt: var integer): {   %globals;   %public;   wait: ;      theActive: ref GeneralProcess;      M.get;      cnt := cnt - 1;  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%globals{   %public;   wait: ;      theActive: ref GeneralProcess;      M.get;      cnt := cnt - 1;      if (cnt < 0) :then ;         disable ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "SemaphoreLib" E:  "Semaphore(1)" 
 -- INV:gen:E.loadArgs "Semaphore(1)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "Semaphore(1)" >staticOff:0 "Semaphore(cnt: var integer): {   %globals;   %public;   wait: ;      theActive: ref GeneralProcess;      M ..."} 
 -- $pattern:loadArgs: "Semaphore(cnt: var integer): {   %globals;   %public;   wait: ;      theActive: ref GeneralProcess;      M.get;      cnt := cnt - 1;      if (cnt < 0)  ..."} 
 -- ptn:loadArgs:E "Semaphore(1)" 
 -- {(ObjectInvocation_KeyWord; (name: "Semaphore"); (Arguments;  (name: "Semaphore");  (name: "(");  (ObjectGenerator;   (Invocation;    (ConstLiteral 1));   (Items descNo: 0 ...} 
 -- args: "Semaphore(1)" 
 -- E: "ObjectGenerator" 1 
 -- E.arg: "var" cnt: var integer 
 -- NonVirt: "Semaphore(1)" "ObjectInvocation_KeyWord" ActArg:  "1" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "Semaphore(1)"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "cnt: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "1" :isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "Semaphore(1)" 
 -- INV:gen:after:E.loadArgs "Semaphore(1)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "Semaphore(1)" 
 -- $ObjectInvocation_KeyWord:invoke: "Semaphore(1)" >rec:"SemaphoreLib" ATd:"pattern" E:"Semaphore(1)" E.ATd:"Semaphore(cnt: var integer)" unique:"False" 
 -- OI:invoke: "Semaphore(1)" 
 -- 
 -- OI:invoke:B: "Semaphore(1)" E: "Semaphore(1)"  rec: "SemaphoreLib"  useRtnV: false "Semaphore(cnt: var integer): {   %globals;   %public;   wait: ;      theActive: ref Gen ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Semaphore(cnt: var integer) 
 -- $pattern:invoke: "Semaphore(cnt: var integer): {   %globals;   %public;   wait: ;      theActive: ref GeneralProcess;      M.get;      cnt := cnt - 1;      if (cnt < 0) :t ..."} 
 -- ptn:invoke: "Semaphore(cnt: var integer)" E: "Semaphore(1)" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 2 adr:none 
 invoke Semaphore 216 2 1
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: Semaphore(1) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- $var:gen: "_V: var integer"  
 -- DI:gen: "_V: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  _V 
 -- $Property:gen: "%public"  
 -- $pattern:gen: "init:< entry{   "Monitor:init\n".print;   inner(init)" } 
 rtnAlloc 1
 toSuper 215
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:0 objSize:3 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 200 
 -- Items:GenClass: print descNo: 200 isValue: false 
 -- Items:GenClass: print descNo: 192 isValue: false 
 -- Items:GenClass: entry descNo: 21 isValue: false 

 CLASS print 200 1 myM 217
 -- vdtTableCopy: I:1:192 I:2:0
 -- vdtAdd: inx=2 descInx=200 vDescInx=200 vdtTop: 2 
 -- Store itemArgs: S.print 
 -- S: var String true 5 
 pushThis 
 rstoreg  S 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 -- super entry
 -- push:super.origin: 
 -- computeAdr:superAdj: 1 "entry" 
 -- computeAdr: 1 :rec: "none"  E: "entry" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "entry"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "entry" >on:0 superAdj:1 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 1 
 rpushg myM$217 1
 -- $ObjectInvocation_Unary:getAdr: "entry" >ATd.off:0 (isPtn):on:0:superAdj:1"entry: {   %kind method;   %arguments value, immutable;   mutex.wait;   _V := _V + 1;   inner(en ..."} 
 -- $pattern:getAdr: "entry: {   %kind method;   %arguments value, immutable;   mutex.wait;   _V := _V + 1;   inner(entry);   mutex.signal" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"entry":rec:- 
 -- E.on: 0 
 -- beforeIsValueObj:E: "entry"  ATd: "entry: {   %kind method;   %arguments value, immutable;   mutex.wait;   _V := _V + 1;   inner(entry);   mutex.signal}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"entry":rec:- 
 -- computeAdr:isLast:E:  "entry" 
 -- genClass:after:pushAddress: "entry" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"entry":rec:- 
 -- handleSuperArgs:E: "entry" theIS: "S.print" 
 -- super.sig:not:none:superAdj: -1 
 -- $ObjectInvocation_Unary:loadArgs: "entry" >staticOff:0 "entry: {   %kind method;   %arguments value, immutable;   mutex.wait;   _V := _V + 1;   inner(entry);   mutex.signa ..."} 
 -- $pattern:loadArgs: "entry: {   %kind method;   %arguments value, immutable;   mutex.wait;   _V := _V + 1;   inner(entry);   mutex.signal" >E:"entry":descNo:192} 
 -- ptn:loadArgs:E "entry" 
 -- {(ObjectInvocation_Unary; (name: "entry"); (Arguments))} 
 -- args: "" 
 -- hArgOrg:super: entry 
 -- Store itemArgs: S.print 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=200 vDescInx=192 vdtTop: 2 
 -- $Property:gen: "%kind method"  
 -- $Property:gen: "%arguments value, immutable"  
 rtnAlloc 1
 toSuper 192
DO:
 mvStack 
 L1:
 -- genclass:stmt: "S.print" 
 -- $ObjectGenerator:gen: "S.print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "S.print" 
 -- OG:before:super.gen: "S.print" 
 -- $Invocation:gen: "S.print" >useRtnV:"False"superAdj: 0 descNo: 103 
 -- INV:gen: "S.print" 
 -- isConstant: "Invocation" "S.print" 
 -- notConst: S S: var String 
 -- needorigin: "S.print" 
 -- needOrigin:E: "print"  E.ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- doNeedOrigin:Ex: "print" 
 -- computeAdr:superAdj: 0 "S.print" 
 -- computeAdr: 1 :rec: "none"  E: "S" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "S"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "S" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "S" >ATd.off:2:on:0:superAdj:0"S: var String":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"non ..." 
 -- PING:String 0 entry{   S.print} 
 -- BOBS:ATd: "S: var String" 
 -- Is not: in Veq: var this(Value) 
 -- $var:getAdr: "S: var String" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F or ... 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "S"  E: "print" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "print" >ATd.off:0 (isPtn):on:0:superAdj:0"print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   ":Adr: ...} 
 -- $pattern:getAdr: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "S" >staticOff:0 "S: var String" superAdj:0 
 -- $var:loadArgs: "S: var String" >E:"S" 
 -- $pattern:loadArgs: "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- actu ..."} 
 -- ptn:loadArgs:E "S" 
 -- {(ObjectInvocation_Unary; (name: "S"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "S" >rec:"S" ATd:"var" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "S" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:S 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:S 
 -- OI:invoke:B: "S" E: "print"  rec: "S"  useRtnV: true "S: var String" 
 -- OI:invoke:before:ATdx.invoke: var S 
 -- $var:invoke: "S: var String" E: "print">newOff:2 useRTNv: "True" 
 -- DI:invoke: "S: var String" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:S 
 rpushg print$200 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:S 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:S 
 -- 
 -- OI:invoke:C: S :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "S" E: "print" 
 -- computeAdr:isLast:E:  "print" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:S 
 -- rec:  "S" E:  "print" 
 -- INV:gen:E.loadArgs "print" 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " superAdj:0} 
 -- $pattern:loadArgs: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " >E:"print":descNo:103} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "print" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:S 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:"S" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:S 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:S 
 -- OI:invoke:B: "print" E: "print"  rec: "S"  useRtnV: false "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:S 
 invoke print 103 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:S 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:S 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:S 
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 201 
 -- Items:GenClass: repeat$201 descNo: 201 isValue: false 
 -- Items:GenClass: repeat$201 descNo: 21 isValue: false 

 CLASS repeat$201 201 1 for:to:repeat$214 214
 -- Store itemArgs: myM.putItem("Fac: "):value(inx):res(fac(inx)) 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=201 vDescInx=201 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "myM.putItem("Fac: "):value(inx):res(fac(inx))" 
 -- $ObjectGenerator:gen: "myM.putItem("Fac: "):value(inx):res(fac(inx))" >OGid:"putItem:value:res" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "myM.putItem("Fac: "):value(inx):res(fac(inx))" 
 -- OG:before:super.gen: "myM.putItem("Fac: "):value(inx):res(fac(inx))" 
 -- $Invocation:gen: "myM.putItem("Fac: "):value(inx):res(fac(inx))" >useRtnV:"False"superAdj: 0 descNo: 206 
 -- INV:gen: "myM.putItem("Fac: "):value(inx):res(fac(inx))" 
 -- isConstant: "Invocation" "myM.putItem("Fac: "):value(inx):res(fac(inx))" 
 -- needorigin: "myM.putItem("Fac: "):value(inx):res(fac(inx))" 
 -- needOrigin:E: "putItem("Fac: "):value(inx):res(fac(inx))"  E.ATd: "putItem(msg: var String):value(V: var integer):res(res: var integer): entry{   put(10);   put('<');   ms ...}" 
 -- doNeedOrigin:Ex: "putItem("Fac: "):value(inx):res(fac(inx))" 
 -- computeAdr:superAdj: 0 "myM.putItem("Fac: "):value(inx):res(fac(inx))" 
 -- computeAdr: 1 :rec: "none"  E: "myM" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "myM"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "myM" >on:3 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$201" on: 3 isValueObj: false 
 -- origin: for:to:repeat$214 origin:isValueObj: false 
 rpushg repeat$201$201 1
 -- items:goOrigin:encOG: "for:to:repeat$214" on: 2 isValueObj: false 
 -- origin: P1 origin:isValueObj: false 
 rpushg for:to:repeat$214$214 4
 -- items:goOrigin:encOG: "P1" on: 1 isValueObj: false 
 -- origin: MonitorDemo origin:isValueObj: false 
 rpushg P1$191 4
 -- $ObjectInvocation_Unary:getAdr: "myM" >ATd.off:13:on:3:superAdj:0"myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var in ..."} 
 -- $obj:getAdr: "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var integer): entry;      put(10);   ..."} 
 -- E.on: 3 
 -- beforeIsValueObj:E: "myM"  ATd: "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var integer): ent ...}" 
 -- computeAdr:isFirst: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "myM"  E: "putItem("Fac: "):value(inx):res(fac(inx))" 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:getAdr: "putItem("Fac: "):value(inx):res(fac(inx))" >ATd.off:0 (isPtn):on:0:superAdj:0"putItem(msg: var String):value(V: var integer):res(res: va ..." 
 -- $pattern:getAdr: "putItem(msg: var String):value(V: var integer):res(res: var integer): entry{   put(10);   put('<');   msg.print;   putint(V);   " = ".print;   putint(res ..."} 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putItem("Fac: "):value(inx):res(fac(inx))":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "myM" >staticOff:0 "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(r ..."} 
 -- $obj:loadArgs: "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var integer): entry;      put(10); ..."} 
 -- $ObjectInvocation_Unary:invoke: "myM" >rec:"myM" ATd:"obj" E:"putItem("Fac: "):value(inx):res(fac(inx))" E.ATd:"putItem(msg: var String):value(V: var integer):res(res: var ..." 
 -- OI:invoke: "myM" 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putItem("Fac: "):value(inx):res(fac(inx))":rec:myM 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putItem("Fac: "):value(inx):res(fac(inx))":rec:myM 
 -- OI:invoke:B: "myM" E: "putItem("Fac: "):value(inx):res(fac(inx))"  rec: "myM"  useRtnV: true "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: ...}" 
 -- OI:invoke:before:ATdx.invoke: obj myM 
 -- $obj:invoke: "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var integer): entry;      put(10);   ..."} 
 -- DI:invoke: "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var integer): entry;      put(10);     ...}" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putItem("Fac: "):value(inx):res(fac(inx))":rec:myM 
 rpushg repeat$201$201 13
 -- OI:invoke:V: adr: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putItem("Fac: "):value(inx):res(fac(inx))":rec:myM 
 -- 
 -- OI:invoke:X: adr: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putItem("Fac: "):value(inx):res(fac(inx))":rec:myM 
 -- 
 -- OI:invoke:C: myM :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "myM" E: "putItem("Fac: "):value(inx):res(fac(inx))" 
 -- arg:other 
 -- computeAdr:isLast:E:  "putItem("Fac: "):value(inx):res(fac(inx))" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putItem("Fac: "):value(inx):res(fac(inx))":rec: ... 
 -- rec:  "myM" E:  "putItem("Fac: "):value(inx):res(fac(inx))" 
 -- INV:gen:E.loadArgs "putItem("Fac: "):value(inx):res(fac(inx))" 
 -- $ObjectInvocation_KeyWord:loadArgs: "putItem("Fac: "):value(inx):res(fac(inx))" >staticOff:0 "putItem(msg: var String):value(V: var integer):res(res: var integer): entry{  ..."} 
 -- $pattern:loadArgs: "putItem(msg: var String):value(V: var integer):res(res: var integer): entry{   put(10);   put('<');   msg.print;   putint(V);   " = ".print;   putint(r ..."} 
 -- ptn:loadArgs:E "putItem("Fac: "):value(inx):res(fac(inx))" 
 -- {(ObjectInvocation_KeyWord; (name: "putItem:value:res"); (Arguments;  (name: "putItem");  (name: "(");  (ObjectGenerator;   (Invocation;    (String: Fac: ));   (Items desc ...} 
 -- args: "putItem("Fac: "):value(inx):res(fac(inx))" 
 -- E: "ObjectGenerator" "Fac: " 
 -- E: "ObjectGenerator" inx 
 -- E: "ObjectGenerator" fac(inx) 
 -- E.arg: "var" msg: var String 
 -- NonVirt: "putItem("Fac: "):value(inx):res(fac(inx))" "ObjectInvocation_KeyWord" ActArg:  ""Fac: "" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "putItem("Fac: "):value(inx):res(fac(inx))"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: ""Fac: "" >OGid:"String" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: ""Fac: "" 
 -- OG:before:super.gen: ""Fac: "" 
 -- $Invocation:gen: ""Fac: "" >useRtnV:"True"superAdj: 0 
 -- INV:gen: ""Fac: "" 
 -- isConstant: "Invocation" ""Fac: "" 
 -- needorigin: ""Fac: "" 
 -- needOrigin:E: ""Fac: ""  E.ATd: "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := g ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  ""Fac: "" E:  ""Fac: "" 
 -- INV:gen:E.loadArgs ""Fac: "" 
 -- $String::loadArgs: ""Fac: ""  
 -- INV:gen:after:E.loadArgs ""Fac: "" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: String: ""Fac: "" 
 -- $String::invoke: ""Fac: ""  
 pushText "Fac: "
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "msg: var String" :isBasicVal: false :valueObj: false 
 -- :actArg: ""Fac: "" :isBasicVal: false 
 -- case:B: "Fac: " ObjectGenerator 5 5 5 false false 
 -- end:loadArgs:NonVirt: "putItem("Fac: "):value(inx):res(fac(inx))" 
 -- E.arg: "var" V: var integer 
 -- NonVirt: "putItem("Fac: "):value(inx):res(fac(inx))" "ObjectInvocation_KeyWord" ActArg:  "inx" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "putItem("Fac: "):value(inx):res(fac(inx))"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "inx" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inx" 
 -- OG:before:super.gen: "inx" 
 -- $Invocation:gen: "inx" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "inx" 
 -- isConstant: "Invocation" "inx" 
 -- notConst: inx inx: var integer 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$201" on: 1 isValueObj: false 
 -- origin: for:to:repeat$214 origin:isValueObj: false 
 rpushg repeat$201$201 1
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:3:on:1:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- $ObjectInvocation_Unary:loadArgs: "inx" >staticOff:0 "inx: var integer" superAdj:0 
 -- $var:loadArgs: "inx: var integer" >E:"inx" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "inx" 
 -- {(ObjectInvocation_Unary; (name: "inx"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: "inx" >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:"inx" unique:"False" 
 -- OI:invoke: "inx" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx" E: "inx"  rec: "inx"  useRtnV: true "inx: var integer" 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: "inx: var integer" E: "inx">newOff:3 useRTNv: "True" 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- isCompositeValueObj: false E: "inx" "inx: var integer" true 
 -- E.ATd.isValueObj: false rec: "inx" 
 pushg 3 for:to:repeat$214$214
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: 0 rTopMax: 1 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:C: inx :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- formalArg:isPtn: "V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "inx" :isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "putItem("Fac: "):value(inx):res(fac(inx))" 
 -- E.arg: "var" res: var integer 
 -- NonVirt: "putItem("Fac: "):value(inx):res(fac(inx))" "ObjectInvocation_KeyWord" ActArg:  "fac(inx)" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "putItem("Fac: "):value(inx):res(fac(inx))"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "fac(inx)" >OGid:"fac" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "fac(inx)" 
 -- OG:before:super.gen: "fac(inx)" 
 -- $Invocation:gen: "fac(inx)" >useRtnV:"True"superAdj: 0 descNo: 202 
 -- INV:gen: "fac(inx)" 
 -- isConstant: "Invocation" "fac(inx)" 
 -- needorigin: "fac(inx)" 
 -- needOrigin:E: "fac(inx)"  E.ATd: "fac(V: var integer): {   out res: var integer;   if (V = 1) :then ;      res := 1;   :else ;      res := V * fac(V - 1)}" 
 -- doNeedOrigin:Ex: "fac(inx)" 
 -- computeAdr:superAdj: 0 "fac(inx)" 
 -- computeAdr: 1 :rec: "none"  E: "fac(inx)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "fac(inx)"  
 pushThis 
 -- $ObjectInvocation_KeyWord:loadOrigin: "fac(inx)" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$201" on: 2 isValueObj: false 
 -- origin: for:to:repeat$214 origin:isValueObj: false 
 rpushg repeat$201$201 1
 -- items:goOrigin:encOG: "for:to:repeat$214" on: 1 isValueObj: false 
 -- origin: P1 origin:isValueObj: false 
 rpushg for:to:repeat$214$214 4
 -- $ObjectInvocation_KeyWord:getAdr: "fac(inx)" >ATd.off:0 (isPtn):on:2:superAdj:0"fac(V: var integer): {   out res: var integer;   if (V = 1) :then ;      res := 1;   :else  ..."} 
 -- $pattern:getAdr: "fac(V: var integer): {   out res: var integer;   if (V = 1) :then ;      res := 1;   :else ;      res := V * fac(V - 1)" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fac(inx)":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "fac(inx)"  ATd: "fac(V: var integer): {   out res: var integer;   if (V = 1) :then ;      res := 1;   :else ;      res := V * fac(V - 1)}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fac(inx)":rec:- 
 -- computeAdr:isLast:E:  "fac(inx)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fac(inx)":rec:- 
 -- rec:  "fac(inx)" E:  "fac(inx)" 
 -- INV:gen:E.loadArgs "fac(inx)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "fac(inx)" >staticOff:0 "fac(V: var integer): {   out res: var integer;   if (V = 1) :then ;      res := 1;   :else ;      res := V * f ..."} 
 -- $pattern:loadArgs: "fac(V: var integer): {   out res: var integer;   if (V = 1) :then ;      res := 1;   :else ;      res := V * fac(V - 1)" >E:"fac(inx)":descNo:202} 
 -- ptn:loadArgs:E "fac(inx)" 
 -- {(ObjectInvocation_KeyWord; (name: "fac"); (Arguments;  (name: "fac");  (name: "(");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "inx");     ( ...} 
 -- args: "fac(inx)" 
 -- E: "ObjectGenerator" inx 
 -- E.arg: "var" V: var integer 
 -- NonVirt: "fac(inx)" "ObjectInvocation_KeyWord" ActArg:  "inx" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "fac(inx)"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "inx" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inx" 
 -- OG:before:super.gen: "inx" 
 -- $Invocation:gen: "inx" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "inx" 
 -- isConstant: "Invocation" "inx" 
 -- notConst: inx inx: var integer 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$201" on: 1 isValueObj: false 
 -- origin: for:to:repeat$214 origin:isValueObj: false 
 rpushg repeat$201$201 1
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:3:on:1:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- $ObjectInvocation_Unary:loadArgs: "inx" >staticOff:0 "inx: var integer" superAdj:0 
 -- $var:loadArgs: "inx: var integer" >E:"inx" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "inx" 
 -- {(ObjectInvocation_Unary; (name: "inx"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: "inx" >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:"inx" unique:"False" 
 -- OI:invoke: "inx" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx" E: "inx"  rec: "inx"  useRtnV: true "inx: var integer" 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: "inx: var integer" E: "inx">newOff:3 useRTNv: "True" 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- isCompositeValueObj: false E: "inx" "inx: var integer" true 
 -- E.ATd.isValueObj: false rec: "inx" 
 pushg 3 for:to:repeat$214$214
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 1 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -1 rTopMax: 1 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:C: inx :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- formalArg:isPtn: "V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "inx" :isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "fac(inx)" 
 -- INV:gen:after:E.loadArgs "fac(inx)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "fac(inx)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fac(inx)":rec ... 
 -- $ObjectInvocation_KeyWord:invoke: "fac(inx)" >rec:"fac(inx)" ATd:"pattern" E:"fac(inx)" E.ATd:"fac(V: var integer)" unique:"False" 
 -- OI:invoke: "fac(inx)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fac(inx)":rec:fac(inx) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fac(inx)":rec:fac(inx) 
 -- OI:invoke:B: "fac(inx)" E: "fac(inx)"  rec: "fac(inx)"  useRtnV: true "fac(V: var integer): {   out res: var integer;   if (V = 1) :then ;      res := 1;   :else ;      re ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern fac(V: var integer) 
 -- $pattern:invoke: "fac(V: var integer): {   out res: var integer;   if (V = 1) :then ;      res := 1;   :else ;      res := V * fac(V - 1)" E: "fac(inx)" useRTNv: "True"} 
 -- ptn:invoke: "fac(V: var integer)" E: "fac(inx)" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fac(inx)":rec:fac(inx) 
 invoke fac 202 0 0
 -- global:pushOut: res off: 3 
 pushg 3 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 1 V: 0 R: 
 -- stack: vpush : vTop: 3 vTopMax: 3 rTop: -2 rTopMax: 1 V: 0 R: 
 -- callInvoke:after:pushOut: 3 
 -- GeneralPTN:invoke:after:callInvoke: 3 
 -- GeneralPTN:invoke:end: 3 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fac(inx)":rec:fac(inx) 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fac(inx)":rec:fac(inx) 
 -- adrx: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fac(inx)":rec:fac(inx) 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fac(inx)":rec:fac(inx) 
 -- adrx: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fac(inx)":rec:fac(inx) 
 -- OI:invoke:C: fac(inx) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fac(inx)":rec:fac(inx) 
 -- formalArg:isPtn: "res: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "fac(inx)" :isBasicVal: true 
 -- case:B: fac(inx) ObjectGenerator 1 0 0 false false 
 -- end:loadArgs:NonVirt: "putItem("Fac: "):value(inx):res(fac(inx))" 
 -- INV:gen:after:E.loadArgs "putItem("Fac: "):value(inx):res(fac(inx))" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "putItem("Fac: "):value(inx):res(fac(inx))" :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue ... 
 -- $ObjectInvocation_KeyWord:invoke: "putItem("Fac: "):value(inx):res(fac(inx))" >rec:"myM" ATd:"pattern" E:"putItem("Fac: "):value(inx):res(fac(inx))" E.ATd:"putItem(msg: va ..." 
 -- OI:invoke: "putItem("Fac: "):value(inx):res(fac(inx))" 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putItem("Fac: "):value(inx):res(fac(inx))":rec:myM 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putItem("Fac: "):value(inx):res(fac(inx))":rec:myM 
 -- OI:invoke:B: "putItem("Fac: "):value(inx):res(fac(inx))" E: "putItem("Fac: "):value(inx):res(fac(inx))"  rec: "myM"  useRtnV: false "putItem(msg: var String):value(V: var  ..." 
 -- OI:invoke:before:ATdx.invoke: pattern putItem(msg: var String):value(V: var integer):res(res: var integer) 
 -- $pattern:invoke: "putItem(msg: var String):value(V: var integer):res(res: var integer): entry{   put(10);   put('<');   msg.print;   putint(V);   " = ".print;   putint(res ..."} 
 -- ptn:invoke: "putItem(msg: var String):value(V: var integer):res(res: var integer)" E: "putItem("Fac: "):value(inx):res(fac(inx))" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putItem("Fac: "):value(inx):res(fac(i ..." 
 invoke putItem:value:res 206 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 3 vTopMax: 3 rTop: -3 rTopMax: 1 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putItem("Fac: "):value(inx):res(fac(inx))":rec:myM 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putItem("Fac: "):value(inx):res(fac(inx))":rec:myM 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: putItem("Fac: "):value(inx):res(fac(inx)) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 13 
 -- OG:gen:end: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putItem("Fac: "):value(inx):res(fac(inx))":rec:myM 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 206 
 -- Items:GenClass: putItem:value:res descNo: 206 isValue: false 
 -- Items:GenClass: putItem:value:res descNo: 192 isValue: false 
 -- Items:GenClass: entry descNo: 21 isValue: false 

 CLASS putItem:value:res 206 1 myM 217
 -- vdtTableCopy: I:1:192 I:2:0
 -- vdtAdd: inx=2 descInx=206 vDescInx=206 vdtTop: 2 
 -- Store itemArgs: put(10){put('<');msg.print;putint(V);" = ".print;putint(res);put('>')} 
 -- res: var integer true 1 
 -- DI:store: "res" 
 pushThis 
 storeg integer$5 4
 -- V: var integer true 1 
 -- DI:store: "V" 
 pushThis 
 storeg integer$5 3
 -- msg: var String true 5 
 pushThis 
 rstoreg  msg 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 -- super entry
 -- push:super.origin: 
 -- computeAdr:superAdj: 1 "entry" 
 -- computeAdr: 1 :rec: "none"  E: "entry" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "entry"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "entry" >on:0 superAdj:1 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 1 
 rpushg myM$217 1
 -- $ObjectInvocation_Unary:getAdr: "entry" >ATd.off:0 (isPtn):on:0:superAdj:1"entry: {   %kind method;   %arguments value, immutable;   mutex.wait;   _V := _V + 1;   inner(en ..."} 
 -- $pattern:getAdr: "entry: {   %kind method;   %arguments value, immutable;   mutex.wait;   _V := _V + 1;   inner(entry);   mutex.signal" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"entry":rec:- 
 -- E.on: 0 
 -- beforeIsValueObj:E: "entry"  ATd: "entry: {   %kind method;   %arguments value, immutable;   mutex.wait;   _V := _V + 1;   inner(entry);   mutex.signal}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"entry":rec:- 
 -- computeAdr:isLast:E:  "entry" 
 -- genClass:after:pushAddress: "entry" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"entry":rec:- 
 -- handleSuperArgs:E: "entry" theIS: "put(10){put('<');msg.print;putint(V);" = ".print;putint(res);put('>')}" 
 -- super.sig:not:none:superAdj: -1 
 -- $ObjectInvocation_Unary:loadArgs: "entry" >staticOff:0 "entry: {   %kind method;   %arguments value, immutable;   mutex.wait;   _V := _V + 1;   inner(entry);   mutex.signa ..."} 
 -- $pattern:loadArgs: "entry: {   %kind method;   %arguments value, immutable;   mutex.wait;   _V := _V + 1;   inner(entry);   mutex.signal" >E:"entry":descNo:192} 
 -- ptn:loadArgs:E "entry" 
 -- {(ObjectInvocation_Unary; (name: "entry"); (Arguments))} 
 -- args: "" 
 -- hArgOrg:super: entry 
 -- Store itemArgs: put(10){put('<');msg.print;putint(V);" = ".print;putint(res);put('>')} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=206 vDescInx=192 vdtTop: 2 
 -- $Property:gen: "%kind method"  
 -- $Property:gen: "%arguments value, immutable"  
 rtnAlloc 1
 toSuper 192
DO:
 mvStack 
 L1:
 -- genclass:stmt: "put(10)" 
 -- $ObjectGenerator:gen: "put(10)" >OGid:"put" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "put(10)" 
 -- OG:before:super.gen: "put(10)" 
 -- $Invocation:gen: "put(10)" >useRtnV:"False"superAdj: 0 descNo: 105 
 -- INV:gen: "put(10)" 
 -- isConstant: "Invocation" "put(10)" 
 -- needorigin: "put(10)" 
 -- needOrigin:E: "put(10)"  E.ATd: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- Ex:loadOrign:no:loadOrigin:  "-- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "put(10)" E:  "put(10)" 
 -- INV:gen:E.loadArgs "put(10)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "put(10)" >staticOff:0 "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char" superAdj:0arg:"10"} 
 -- $pattern:loadArgs: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char" >E:"put(10)":descNo:105} 
 -- ptn:loadArgs:E "put(10)" 
 -- {(ObjectInvocation_KeyWord; (name: "put"); (Arguments;  (name: "put");  (name: "(");  (ObjectGenerator;   (Invocation;    (ConstLiteral 10));   (Items descNo: 0 origDescNo ...} 
 -- args: "put(10)" 
 -- E: "ObjectGenerator" 10 
 -- E.arg: "val" in ch: val char 
 -- NonVirt: "put(10)" "ObjectInvocation_KeyWord" ActArg:  "10" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(10)"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "10" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "10" 
 -- OG:before:super.gen: "10" 
 -- $Invocation:gen: "10" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "10" 
 -- isConstant: "Invocation" "10" 
 -- needorigin: "10" 
 -- needOrigin:E: "10"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "10" E:  "10" 
 -- INV:gen:E.loadArgs "10" 
 -- $ConstLiteral:loadArgs: "10"  
 -- INV:gen:after:E.loadArgs "10" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "10" 
 -- $ConstLiteral:invoke: "10"  
 pushc 10
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in ch: val char" :isBasicVal: true :valueObj: true 
 -- :actArg: "10" :isBasicVal: true 
 -- case:B: 10 ObjectGenerator 3 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "put(10)" 
 -- INV:gen:after:E.loadArgs "put(10)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(10)" 
 -- $ObjectInvocation_KeyWord:invoke: "put(10)" >rec:"put(10)" ATd:"pattern" E:"put(10)" E.ATd:"put" unique:"False" 
 -- OI:invoke: "put(10)" 
 -- 
 -- OI:invoke:B: "put(10)" E: "put(10)"  rec: "put(10)"  useRtnV: false "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- $pattern:invoke: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char" E: "put(10)" useRTNv: "False"} 
 -- ptn:invoke: "put" E: "put(10)" ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- OI:invoke:C: put(10) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "put('<')" 
 -- $ObjectGenerator:gen: "put('<')" >OGid:"put" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "put('<')" 
 -- OG:before:super.gen: "put('<')" 
 -- $Invocation:gen: "put('<')" >useRtnV:"False"superAdj: 0 descNo: 105 
 -- INV:gen: "put('<')" 
 -- isConstant: "Invocation" "put('<')" 
 -- needorigin: "put('<')" 
 -- needOrigin:E: "put('<')"  E.ATd: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- Ex:loadOrign:no:loadOrigin:  "-- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "put('<')" E:  "put('<')" 
 -- INV:gen:E.loadArgs "put('<')" 
 -- $ObjectInvocation_KeyWord:loadArgs: "put('<')" >staticOff:0 "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char" superAdj:0arg:"'<'"} 
 -- $pattern:loadArgs: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char" >E:"put('<')":descNo:105} 
 -- ptn:loadArgs:E "put('<')" 
 -- {(ObjectInvocation_KeyWord; (name: "put"); (Arguments;  (name: "put");  (name: "(");  (ObjectGenerator;   (Invocation;    (Char: '<'));   (Items descNo: 0 origDescNo: 0)); ...} 
 -- args: "put('<')" 
 -- E: "ObjectGenerator" '<' 
 -- E.arg: "val" in ch: val char 
 -- NonVirt: "put('<')" "ObjectInvocation_KeyWord" ActArg:  "'<'" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put('<')"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "'<'" >OGid:"char" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "'<'" 
 -- OG:before:super.gen: "'<'" 
 -- $Invocation:gen: "'<'" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "'<'" 
 -- isConstant: "Invocation" "'<'" 
 -- needorigin: "'<'" 
 -- needOrigin:E: "'<'"  E.ATd: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var ch ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;   ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "'<'" E:  "'<'" 
 -- INV:gen:E.loadArgs "'<'" 
 -- $Char::loadArgs: "'<'"  
 -- INV:gen:after:E.loadArgs "'<'" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "'<'" 
 -- $Char::invoke: "'<'"  
 pushc 60
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in ch: val char" :isBasicVal: true :valueObj: true 
 -- :actArg: "'<'" :isBasicVal: true 
 -- case:B: '<' ObjectGenerator 3 3 3 false true 
 -- end:loadArgs:NonVirt: "put('<')" 
 -- INV:gen:after:E.loadArgs "put('<')" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put('<')" 
 -- $ObjectInvocation_KeyWord:invoke: "put('<')" >rec:"put('<')" ATd:"pattern" E:"put('<')" E.ATd:"put" unique:"False" 
 -- OI:invoke: "put('<')" 
 -- 
 -- OI:invoke:B: "put('<')" E: "put('<')"  rec: "put('<')"  useRtnV: false "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- $pattern:invoke: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char" E: "put('<')" useRTNv: "False"} 
 -- ptn:invoke: "put" E: "put('<')" ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- OI:invoke:C: put('<') :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "msg.print" 
 -- $ObjectGenerator:gen: "msg.print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "msg.print" 
 -- OG:before:super.gen: "msg.print" 
 -- $Invocation:gen: "msg.print" >useRtnV:"False"superAdj: 0 descNo: 103 
 -- INV:gen: "msg.print" 
 -- isConstant: "Invocation" "msg.print" 
 -- notConst: msg msg: var String 
 -- needorigin: "msg.print" 
 -- needOrigin:E: "print"  E.ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- doNeedOrigin:Ex: "print" 
 -- computeAdr:superAdj: 0 "msg.print" 
 -- computeAdr: 1 :rec: "none"  E: "msg" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "msg"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "msg" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "msg" >ATd.off:2:on:0:superAdj:0"msg: var String":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E: ... 
 -- PING:String 0 entry{   put(10);   put('<');   msg.print;   putint(V);   " = ".print;   putint(res);   put('>')} 
 -- BOBS:ATd: "msg: var String" 
 -- Is not: in Veq: var this(Value) 
 -- $var:getAdr: "msg: var String" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F  ... 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "msg"  E: "print" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "print" >ATd.off:0 (isPtn):on:0:superAdj:0"print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   ":Adr: ...} 
 -- $pattern:getAdr: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "msg" >staticOff:0 "msg: var String" superAdj:0 
 -- $var:loadArgs: "msg: var String" >E:"msg" 
 -- $pattern:loadArgs: "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- actu ..."} 
 -- ptn:loadArgs:E "msg" 
 -- {(ObjectInvocation_Unary; (name: "msg"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "msg" >rec:"msg" ATd:"var" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "msg" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:msg 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:msg 
 -- OI:invoke:B: "msg" E: "print"  rec: "msg"  useRtnV: true "msg: var String" 
 -- OI:invoke:before:ATdx.invoke: var msg 
 -- $var:invoke: "msg: var String" E: "print">newOff:2 useRTNv: "True" 
 -- DI:invoke: "msg: var String" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:msg 
 rpushg putItem:value:res$206 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:msg 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:msg 
 -- 
 -- OI:invoke:C: msg :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "msg" E: "print" 
 -- computeAdr:isLast:E:  "print" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:msg 
 -- rec:  "msg" E:  "print" 
 -- INV:gen:E.loadArgs "print" 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " superAdj:0} 
 -- $pattern:loadArgs: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " >E:"print":descNo:103} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "print" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:msg 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:"msg" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:msg 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:msg 
 -- OI:invoke:B: "print" E: "print"  rec: "msg"  useRtnV: false "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:msg 
 invoke print 103 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:msg 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:msg 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:msg 
 -- genclass:stmt: "putint(V)" 
 -- $ObjectGenerator:gen: "putint(V)" >OGid:"putint" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "putint(V)" 
 -- OG:before:super.gen: "putint(V)" 
 -- $Invocation:gen: "putint(V)" >useRtnV:"False"superAdj: 0 descNo: 207 
 -- INV:gen: "putint(V)" 
 -- isConstant: "Invocation" "putint(V)" 
 -- needorigin: "putint(V)" 
 -- needOrigin:E: "putint(V)"  E.ATd: "putint: {   %globals;   in V: var integer;   D: obj Indexed(20,#integer);   L: var integer;   isNeg: var Boolean;   isNeg := V < 0;   if ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%globals{   in V: var integer;   D: obj Indexed(20,#integer);   L: var integer;   isNeg: var Boolean;   isNeg := V < 0;   if (isNeg) :then ;  ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "putint(V)" E:  "putint(V)" 
 -- INV:gen:E.loadArgs "putint(V)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "putint(V)" >staticOff:0 "putint: {   %globals;   in V: var integer;   D: obj Indexed(20,#integer);   L: var integer;   isNeg: var Bool ..."} 
 -- $pattern:loadArgs: "putint: {   %globals;   in V: var integer;   D: obj Indexed(20,#integer);   L: var integer;   isNeg: var Boolean;   isNeg := V < 0;   if (isNeg) :then  ..."} 
 -- ptn:loadArgs:E "putint(V)" 
 -- {(ObjectInvocation_KeyWord; (name: "putint"); (Arguments;  (name: "putint");  (name: "(");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "V");   ...} 
 -- args: "putint(V)" 
 -- E: "ObjectGenerator" V 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "putint(V)" "ObjectInvocation_KeyWord" ActArg:  "V" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "putint(V)"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "V" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "V" 
 -- OG:before:super.gen: "V" 
 -- $Invocation:gen: "V" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "V" 
 -- isConstant: "Invocation" "V" 
 -- notConst: V V: var integer 
 -- needorigin: "V" 
 -- needOrigin:E: "V"  E.ATd: "V: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "V" 
 -- computeAdr: 1 :rec: "none"  E: "V" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "V"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "V" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "V" >ATd.off:3:on:0:superAdj:0"V: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "V: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "V: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- computeAdr:isLast:E:  "V" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- rec:  "V" E:  "V" 
 -- INV:gen:E.loadArgs "V" 
 -- $ObjectInvocation_Unary:loadArgs: "V" >staticOff:0 "V: var integer" superAdj:0 
 -- $var:loadArgs: "V: var integer" >E:"V" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "V" 
 -- {(ObjectInvocation_Unary; (name: "V"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "V" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "V" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- $ObjectInvocation_Unary:invoke: "V" >rec:"V" ATd:"var" isValueObj E:"V" E.ATd:"V" unique:"False" 
 -- OI:invoke: "V" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "V" E: "V"  rec: "V"  useRtnV: true "V: var integer" 
 -- OI:invoke:before:ATdx.invoke: var V 
 -- $var:invoke: "V: var integer" E: "V">newOff:3 useRTNv: "True" 
 -- DI:invoke: "V: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- isCompositeValueObj: false E: "V" "V: var integer" true 
 -- E.ATd.isValueObj: false rec: "V" 
 pushg 3 putItem:value:res$206
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- 
 -- OI:invoke:C: V :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "V" :isBasicVal: true 
 -- case:B: V ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "putint(V)" 
 -- INV:gen:after:E.loadArgs "putint(V)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "putint(V)" 
 -- $ObjectInvocation_KeyWord:invoke: "putint(V)" >rec:"putint(V)" ATd:"pattern" E:"putint(V)" E.ATd:"putint" unique:"False" 
 -- OI:invoke: "putint(V)" 
 -- 
 -- OI:invoke:B: "putint(V)" E: "putint(V)"  rec: "putint(V)"  useRtnV: false "putint: {   %globals;   in V: var integer;   D: obj Indexed(20,#integer);   L: var integer;   is ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern putint 
 -- $pattern:invoke: "putint: {   %globals;   in V: var integer;   D: obj Indexed(20,#integer);   L: var integer;   isNeg: var Boolean;   isNeg := V < 0;   if (isNeg) :then ;  ..."} 
 -- ptn:invoke: "putint" E: "putint(V)" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke putint 207 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -5 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: putint(V) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "" = ".print" 
 -- $ObjectGenerator:gen: "" = ".print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "" = ".print" 
 -- OG:before:super.gen: "" = ".print" 
 -- $Invocation:gen: "" = ".print" >useRtnV:"False"superAdj: 0 descNo: 103 
 -- INV:gen: "" = ".print" 
 -- isConstant: "Invocation" "" = ".print" 
 -- needorigin: "" = ".print" 
 -- needOrigin:E: "print"  E.ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "" = "" E:  "" = "" 
 -- INV:gen:E.loadArgs "" = "" 
 -- $String::loadArgs: "" = ""  
 -- INV:gen:after:E.loadArgs "" = "" 
 -- OIadr: 
 -- $String::invoke: "" = ""  
 pushText " = "
 -- IV:gen:checkTail: "" = ".print" E: "" = "" tail: "print"  not isLast: false 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " superAdj:0} 
 -- $pattern:loadArgs: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " >E:"print":descNo:103} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:"" = "" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- 
 -- OI:invoke:B: "print" E: "print"  rec: "" = ""  useRtnV: false "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke print 103 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -5 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "putint(res)" 
 -- $ObjectGenerator:gen: "putint(res)" >OGid:"putint" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "putint(res)" 
 -- OG:before:super.gen: "putint(res)" 
 -- $Invocation:gen: "putint(res)" >useRtnV:"False"superAdj: 0 descNo: 207 
 -- INV:gen: "putint(res)" 
 -- isConstant: "Invocation" "putint(res)" 
 -- needorigin: "putint(res)" 
 -- needOrigin:E: "putint(res)"  E.ATd: "putint: {   %globals;   in V: var integer;   D: obj Indexed(20,#integer);   L: var integer;   isNeg: var Boolean;   isNeg := V < 0;    ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%globals{   in V: var integer;   D: obj Indexed(20,#integer);   L: var integer;   isNeg: var Boolean;   isNeg := V < 0;   if (isNeg) :then ;  ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "putint(res)" E:  "putint(res)" 
 -- INV:gen:E.loadArgs "putint(res)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "putint(res)" >staticOff:0 "putint: {   %globals;   in V: var integer;   D: obj Indexed(20,#integer);   L: var integer;   isNeg: var Bo ..."} 
 -- $pattern:loadArgs: "putint: {   %globals;   in V: var integer;   D: obj Indexed(20,#integer);   L: var integer;   isNeg: var Boolean;   isNeg := V < 0;   if (isNeg) :then  ..."} 
 -- ptn:loadArgs:E "putint(res)" 
 -- {(ObjectInvocation_KeyWord; (name: "putint"); (Arguments;  (name: "putint");  (name: "(");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "res"); ...} 
 -- args: "putint(res)" 
 -- E: "ObjectGenerator" res 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "putint(res)" "ObjectInvocation_KeyWord" ActArg:  "res" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "putint(res)"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "res" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "res" 
 -- OG:before:super.gen: "res" 
 -- $Invocation:gen: "res" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "res" 
 -- isConstant: "Invocation" "res" 
 -- notConst: res res: var integer 
 -- needorigin: "res" 
 -- needOrigin:E: "res"  E.ATd: "res: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "res" 
 -- computeAdr: 1 :rec: "none"  E: "res" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "res"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "res" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "res" >ATd.off:4:on:0:superAdj:0"res: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "res: var integer" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "res: var integer" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:- 
 -- computeAdr:isLast:E:  "res" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:- 
 -- rec:  "res" E:  "res" 
 -- INV:gen:E.loadArgs "res" 
 -- $ObjectInvocation_Unary:loadArgs: "res" >staticOff:0 "res: var integer" superAdj:0 
 -- $var:loadArgs: "res: var integer" >E:"res" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "res" 
 -- {(ObjectInvocation_Unary; (name: "res"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "res" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "res" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:- 
 -- $ObjectInvocation_Unary:invoke: "res" >rec:"res" ATd:"var" isValueObj E:"res" E.ATd:"res" unique:"False" 
 -- OI:invoke: "res" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:res 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:res 
 -- OI:invoke:B: "res" E: "res"  rec: "res"  useRtnV: true "res: var integer" 
 -- OI:invoke:before:ATdx.invoke: var res 
 -- $var:invoke: "res: var integer" E: "res">newOff:4 useRTNv: "True" 
 -- DI:invoke: "res: var integer" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:res 
 -- isCompositeValueObj: false E: "res" "res: var integer" true 
 -- E.ATd.isValueObj: false rec: "res" 
 pushg 4 putItem:value:res$206
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -6 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -6 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:res 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:res 
 -- 
 -- OI:invoke:C: res :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:res 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "res" :isBasicVal: true 
 -- case:B: res ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "putint(res)" 
 -- INV:gen:after:E.loadArgs "putint(res)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "putint(res)" 
 -- $ObjectInvocation_KeyWord:invoke: "putint(res)" >rec:"putint(res)" ATd:"pattern" E:"putint(res)" E.ATd:"putint" unique:"False" 
 -- OI:invoke: "putint(res)" 
 -- 
 -- OI:invoke:B: "putint(res)" E: "putint(res)"  rec: "putint(res)"  useRtnV: false "putint: {   %globals;   in V: var integer;   D: obj Indexed(20,#integer);   L: var integer ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern putint 
 -- $pattern:invoke: "putint: {   %globals;   in V: var integer;   D: obj Indexed(20,#integer);   L: var integer;   isNeg: var Boolean;   isNeg := V < 0;   if (isNeg) :then ;  ..."} 
 -- ptn:invoke: "putint" E: "putint(res)" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke putint 207 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -7 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: putint(res) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "put('>')" 
 -- $ObjectGenerator:gen: "put('>')" >OGid:"put" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "put('>')" 
 -- OG:before:super.gen: "put('>')" 
 -- $Invocation:gen: "put('>')" >useRtnV:"False"superAdj: 0 descNo: 105 
 -- INV:gen: "put('>')" 
 -- isConstant: "Invocation" "put('>')" 
 -- needorigin: "put('>')" 
 -- needOrigin:E: "put('>')"  E.ATd: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- Ex:loadOrign:no:loadOrigin:  "-- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "put('>')" E:  "put('>')" 
 -- INV:gen:E.loadArgs "put('>')" 
 -- $ObjectInvocation_KeyWord:loadArgs: "put('>')" >staticOff:0 "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char" superAdj:0arg:"'>'"} 
 -- $pattern:loadArgs: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char" >E:"put('>')":descNo:105} 
 -- ptn:loadArgs:E "put('>')" 
 -- {(ObjectInvocation_KeyWord; (name: "put"); (Arguments;  (name: "put");  (name: "(");  (ObjectGenerator;   (Invocation;    (Char: '>'));   (Items descNo: 0 origDescNo: 0)); ...} 
 -- args: "put('>')" 
 -- E: "ObjectGenerator" '>' 
 -- E.arg: "val" in ch: val char 
 -- NonVirt: "put('>')" "ObjectInvocation_KeyWord" ActArg:  "'>'" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put('>')"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "'>'" >OGid:"char" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "'>'" 
 -- OG:before:super.gen: "'>'" 
 -- $Invocation:gen: "'>'" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "'>'" 
 -- isConstant: "Invocation" "'>'" 
 -- needorigin: "'>'" 
 -- needOrigin:E: "'>'"  E.ATd: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var ch ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;   ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "'>'" E:  "'>'" 
 -- INV:gen:E.loadArgs "'>'" 
 -- $Char::loadArgs: "'>'"  
 -- INV:gen:after:E.loadArgs "'>'" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "'>'" 
 -- $Char::invoke: "'>'"  
 pushc 62
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in ch: val char" :isBasicVal: true :valueObj: true 
 -- :actArg: "'>'" :isBasicVal: true 
 -- case:B: '>' ObjectGenerator 3 3 3 false true 
 -- end:loadArgs:NonVirt: "put('>')" 
 -- INV:gen:after:E.loadArgs "put('>')" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put('>')" 
 -- $ObjectInvocation_KeyWord:invoke: "put('>')" >rec:"put('>')" ATd:"pattern" E:"put('>')" E.ATd:"put" unique:"False" 
 -- OI:invoke: "put('>')" 
 -- 
 -- OI:invoke:B: "put('>')" E: "put('>')"  rec: "put('>')"  useRtnV: false "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- $pattern:invoke: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char" E: "put('>')" useRTNv: "False"} 
 -- ptn:invoke: "put" E: "put('>')" ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- OI:invoke:C: put('>') :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:4 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 207 
 -- Items:GenClass: putint descNo: 207 isValue: false 
 -- Items:GenClass: putint descNo: 21 isValue: false 

 CLASS putint 207 0 BETA 2
 -- Store itemArgs: %globals{in V: var integer;D: obj Indexed(20,#integer);L: var integer;isNeg: var Boolean;isNeg := V < 0;if (isNeg) :then ;   V := 0 - V;loop: do ;   L := L ...} 
 -- in V: var integer true 1 
 -- DI:store: "V" 
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- vdtAdd: inx=1 descInx=207 vDescInx=207 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%globals"  
 -- $var:gen: "in V: var integer"  
 -- DI:gen: "in V: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  V 
 -- $obj:gen: "D: obj Indexed(20,#integer)"  
 -- DI:gen: "D: obj Indexed(20,#integer)" DI:isConst: true :isBasicValue: false :primNo: 114 
 -- DI:add:BP4:  D 
 -- $ObjectGenerator:gen: "Indexed(20,#integer)" >OGid:"D" IS.isempty! staticOff=2 descNo=0 superAdj=0 
 -- OG:gen: "Indexed(20,#integer)" 
 -- OG:before:super.gen: "Indexed(20,#integer)" 
 -- $Invocation:gen: "Indexed(20,#integer)" >useRtnV:"False"superAdj: 0 descNo: 86 
 -- INV:gen: "Indexed(20,#integer)" 
 -- isConstant: "Invocation" "Indexed(20,#integer)" 
 -- needorigin: "Indexed(20,#integer)" 
 -- needOrigin:E: "Indexed(20,#integer)"  E.ATd: "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var int ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%globals{   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];   p ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "Indexed(20,#integer)" E:  "Indexed(20,#integer)" 
 -- INV:gen:E.loadArgs "Indexed(20,#integer)" 
 -- $ObjectInvocation_Function:loadArgs: "Indexed(20,#integer)" >staticOff:0 "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   len ..."} 
 -- $pattern:loadArgs: "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];  ..."} 
 -- ptn:loadArgs:E "Indexed(20,#integer)" 
 -- {(ObjectInvocation_Function; (name: "Indexed"); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 20));   (Items descNo: 0 origDescNo: 0));  (ObjectGenerator; ...} 
 -- args: "(20,#integer)" 
 -- E: "ObjectGenerator" 20 
 -- E: "ObjectGenerator" #integer 
 -- E.arg: "var" in range: var Integer 
 -- NonVirt: "Indexed(20,#integer)" "ObjectInvocation_Function" ActArg:  "20" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "Indexed(20,#integer)"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "20" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "20" 
 -- OG:before:super.gen: "20" 
 -- $Invocation:gen: "20" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "20" 
 -- isConstant: "Invocation" "20" 
 -- needorigin: "20" 
 -- needOrigin:E: "20"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "20" E:  "20" 
 -- INV:gen:E.loadArgs "20" 
 -- $ConstLiteral:loadArgs: "20"  
 -- INV:gen:after:E.loadArgs "20" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "20" 
 -- $ConstLiteral:invoke: "20"  
 pushc 20
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in range: var Integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "20" :isBasicVal: true 
 -- case:B: 20 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "Indexed(20,#integer)" 
 -- INV:gen:after:E.loadArgs "Indexed(20,#integer)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Function "Indexed(20,#integer)" 
 -- $ObjectInvocation_Function:invoke: "Indexed(20,#integer)" >rec:"Indexed(20,#integer)" ATd:"pattern" E:"Indexed(20,#integer)" E.ATd:"Indexed" unique:"False" 
 -- OI:invoke: "Indexed(20,#integer)" 
 -- 
 -- OI:invoke:B: "Indexed(20,#integer)" E: "Indexed(20,#integer)"  rec: "Indexed(20,#integer)"  useRtnV: false "Indexed: {   %globals;   %basic 114;   %public;   in range: var ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Indexed 
 -- $pattern:invoke: "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];    ..."} 
 -- ptn:invoke: "Indexed" E: "Indexed(20,#integer)" ptnKind: 0 useRtnV: false 
 pushThis 
 -- ObjTmpStack:add: "Indexed" : "%globals{   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];   p ...}" 
 pushc 1
 allocIndexed putint$207 86 1 0
 pushThis 
 rstoreg  putint$207 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- OI:invoke:C: Indexed(20,#integer) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- $var:gen: "L: var integer"  
 -- DI:gen: "L: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  L 
 -- $var:gen: "isNeg: var Boolean"  
 -- DI:gen: "isNeg: var Boolean" DI:isConst: false :isBasicValue: true :primNo: 4 
 -- DI:add:BP1:  isNeg 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%globals" 
 -- $Property:gen: "%globals"  
 -- genclass:stmt: "isNeg := V < 0" 
 -- $Assign:gen: "isNeg := V < 0"  
 -- assign: "isNeg := V < 0" 
 -- computeAdr:superAdj: 0 "isNeg" 
 -- computeAdr: 1 :rec: "none"  E: "isNeg" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "isNeg"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "isNeg" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "isNeg" >ATd.off:4:on:0:superAdj:0"isNeg: var Boolean":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ... 
 -- $var:getAdr: "isNeg: var Boolean" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F o ... 
 -- DI:OG: Boolean 
 -- before:floatTest:  "isNeg: var Boolean" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 -- computeAdr:isLast:E:  "isNeg" 
 -- AssignmentStatement:gen: "isNeg := V < 0" right.label: "ObjectGenerator" "V < 0" 
 -- $ObjectGenerator:gen: "V < 0" >OGid:"<" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "V < 0" 
 -- OG:before:super.gen: "V < 0" 
 -- $Invocation:gen: "V < 0" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "V < 0" 
 -- isConstant: "Invocation" "V < 0" 
 -- needorigin: "V < 0" 
 -- needOrigin:E: "V < 0"  E.ATd: "<  : {   %basic 51;   in V: var integer;   out B: var boolean}" 
 -- doNeedOrigin:Ex: "V < 0" 
 -- computeAdr:superAdj: 0 "V < 0" 
 -- computeAdr: 1 :rec: "none"  E: "V < 0" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "V < 0"  
 -- $BinOp:loadOrigin: "V < 0"  
 -- BinaryExp:loadOrigin:empty: "V < 0" superAdj: 0 
 -- $BinOp:getAdr: "V < 0"  
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "V < 0" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "V < 0" E:  "V < 0" 
 -- INV:gen:E.loadArgs "V < 0" 
 -- $BinOp:loadArgs: "V < 0"  
 -- BinaryExp:loadArgs: "V < 0" superAdj: 0 
 -- $Invocation:gen: "V" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "V" 
 -- isConstant: "Invocation" "V" 
 -- notConst: V in V: var integer 
 -- needorigin: "V" 
 -- needOrigin:E: "V"  E.ATd: "in V: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "V" 
 -- computeAdr: 1 :rec: "none"  E: "V" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "V"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "V" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "V" >ATd.off:1:on:0:superAdj:0"in V: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E: ... 
 -- $var:getAdr: "in V: var integer" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F or ... 
 -- DI:OG: integer 
 -- before:floatTest:  "in V: var integer" ObjectGenerator 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- computeAdr:isLast:E:  "V" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- rec:  "V" E:  "V" 
 -- INV:gen:E.loadArgs "V" 
 -- $ObjectInvocation_Unary:loadArgs: "V" >staticOff:0 "in V: var integer" superAdj:0 
 -- $var:loadArgs: "in V: var integer" >E:"V" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "V" 
 -- {(ObjectInvocation_Unary; (name: "V"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "V" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "V" :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- $ObjectInvocation_Unary:invoke: "V" >rec:"V" ATd:"var" isValueObj E:"V" E.ATd:"V" unique:"False" 
 -- OI:invoke: "V" 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "V" E: "V"  rec: "V"  useRtnV: true "in V: var integer" 
 -- OI:invoke:before:ATdx.invoke: var V 
 -- $var:invoke: "in V: var integer" E: "V">newOff:1 useRTNv: "True" 
 -- DI:invoke: "in V: var integer" 
 -- load: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- isCompositeValueObj: false E: "V" "in V: var integer" true 
 -- E.ATd.isValueObj: false rec: "V" 
 pushg 1 putint$207
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- 
 -- OI:invoke:C: V :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 1 
 -- left:#I "V < 0" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- $pattern:loadArgs: "<  : {   %basic 51;   in V: var integer;   out B: var boolean" >E:"< 0":descNo:54} 
 -- ptn:loadArgs:E "< 0" 
 -- {(ObjectInvocation_Binary; (name: "<"); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 0));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "0" 
 -- E: "ObjectGenerator" 0 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "< 0" "ObjectInvocation_Binary" ActArg:  "0" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "< 0"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "0" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "0" 
 -- OG:before:super.gen: "0" 
 -- $Invocation:gen: "0" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "0" 
 -- isConstant: "Invocation" "0" 
 -- needorigin: "0" 
 -- needOrigin:E: "0"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "0" E:  "0" 
 -- INV:gen:E.loadArgs "0" 
 -- $ConstLiteral:loadArgs: "0"  
 -- INV:gen:after:E.loadArgs "0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0" 
 -- $ConstLiteral:invoke: "0"  
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "0" :isBasicVal: true 
 -- case:B: 0 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "< 0" 
 -- BinaryExp:loadArgs:end: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- INV:gen:after:E.loadArgs "V < 0" 
 -- OIadr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- IV:E.invoke:useRtnVal: true E: BinOp "V < 0" :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- $BinOp:invoke: "V < 0"  
 -- BinaryExp:invoke: "V" rec: "V < 0" 
 -- M: "< 0" :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- $ObjectInvocation_Binary:invoke: "< 0" >rec:"V" ATd:"pattern" E:"< 0" E.ATd:"<  " unique:"False" 
 -- OI:invoke: "< 0" 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- origin:isValueObj "integer" 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "< 0" E: "< 0"  rec: "V"  useRtnV: true "<  : {   %basic 51;   in V: var integer;   out B: var boolean}" 
 -- OI:invoke:before:ATdx.invoke: pattern <   
 -- $pattern:invoke: "<  : {   %basic 51;   in V: var integer;   out B: var boolean" E: "< 0" useRTNv: "True"} 
 -- ptn:invoke: "<  " E: "< 0" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "V" E: "< 0" 
 -- arg:integer 
 lt
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< 0":rec:V 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< 0":rec:V 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: < 0 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "isNeg" dstE: "isNeg" dstE.ATd: "isNeg: var Boolean" useRtn: false :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":r ... 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right: "V < 0" 
 -- isArgOfAssignI2IwithUniValArg "isNeg := V < 0" arg: "V < 0" ObjectGenerator 
 -- arg.super.arg: "V < 0" BinOp 
 -- recx:BinaryExp:recx: "V < 0" 
 -- M: "< 0" label: "ObjectInvocation_Binary" M.ATd: "<  : {   %basic 51;   in V: var integer;   out B: var boolean}" 
 -- checkInt2IntWithUnitArg:rec: "V" E: "< 0" 
 -- arg:integer 
 -- M:arg: "0" ObjectGenerator false 
 -- dstDI: "isNeg: var Boolean" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg putint$207 4
 -- assign:adr.store:B: 
 -- genclass:stmt: "if (isNeg) :then {   V := 0 - V}" 
 -- $ObjectGenerator:gen: "if (isNeg) :then {   V := 0 - V" >OGid:"if:then$0" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "if (isNeg) :then {   V := 0 - V}" 
 -- OG:before:super.gen: "if (isNeg) :then {   V := 0 - V}" 
 -- $Invocation:gen: "if (isNeg) :then {   V := 0 - V" >useRtnV:"False"superAdj: 0} 
 -- INV:gen: "if (isNeg) :then {   V := 0 - V}" 
 -- isConstant: "Invocation" "if (isNeg) :then {   V := 0 - V}" 
 -- needorigin: "if (isNeg) :then {   V := 0 - V}" 
 -- needOrigin:E: "if (isNeg) :then {   V := 0 - V}"  E.ATd: "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (isNeg) :then {   V := 0 - V}" E:  "if (isNeg) :then {   V := 0 - V}" 
 -- INV:gen:E.loadArgs "if (isNeg) :then {   V := 0 - V}" 
 -- $IfThen:loadArgs: "if (isNeg) :then {   V := 0 - V" } 
 -- INV:gen:after:E.loadArgs "if (isNeg) :then {   V := 0 - V}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (isNeg) :then {   V := 0 - V}" 
 -- $IfThen:invoke: "if (isNeg) :then {   V := 0 - V" } 
 -- $IfThen:gen: "if (isNeg) :then {   V := 0 - V" } 
 -- $ObjectGenerator:gen: "(isNeg)" >OGid:"Boolean" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(isNeg)" 
 -- OG:before:super.gen: "(isNeg)" 
 -- $Invocation:gen: "(isNeg)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(isNeg)" 
 -- isConstant: "Invocation" "(isNeg)" 
 -- notConst: (isNeg) isNeg: var Boolean 
 -- needorigin: "(isNeg)" 
 -- needOrigin:E: "(isNeg)"  E.ATd: "isNeg: var Boolean" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "(isNeg)" 
 -- computeAdr: 1 :rec: "none"  E: "(isNeg)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(isNeg)"  
 -- $BracketedExp:loadOrigin: "(isNeg)"  
 -- computeAdr:superAdj: 0 "isNeg" 
 -- computeAdr: 1 :rec: "none"  E: "isNeg" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "isNeg"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "isNeg" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "isNeg" >ATd.off:4:on:0:superAdj:0"isNeg: var Boolean":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ... 
 -- $var:getAdr: "isNeg: var Boolean" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F o ... 
 -- DI:OG: Boolean 
 -- before:floatTest:  "isNeg: var Boolean" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 -- computeAdr:isLast:E:  "isNeg" 
 -- BE:loadOrigin:E: isNeg 
 -- $ObjectInvocation_Unary:getAdr: "isNeg" >ATd.off:4:on:0:superAdj:0"isNeg: var Boolean":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ... 
 -- $var:getAdr: "isNeg: var Boolean" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F o ... 
 -- DI:OG: Boolean 
 -- before:floatTest:  "isNeg: var Boolean" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 -- computeAdr:isLast:E:  "isNeg" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 -- rec:  "isNeg" E:  "isNeg" 
 -- INV:gen:E.loadArgs "isNeg" 
 -- $ObjectInvocation_Unary:loadArgs: "isNeg" >staticOff:0 "isNeg: var Boolean" superAdj:0 
 -- $var:loadArgs: "isNeg: var Boolean" >E:"isNeg" 
 -- $pattern:loadArgs: "Boolean: value{   %id "Boolean";   %globals inSub;   %basic 4, 8;   %public;   _thisBasicValue: var Universal;   &&  : ;      %basic 70;      in B: var ..."} 
 -- ptn:loadArgs:E "isNeg" 
 -- {(ObjectInvocation_Unary; (name: "isNeg"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "isNeg" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "isNeg" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 -- $ObjectInvocation_Unary:invoke: "isNeg" >rec:"isNeg" ATd:"var" isValueObj E:"isNeg" E.ATd:"isNeg" unique:"False" 
 -- OI:invoke: "isNeg" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:isNeg 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:isNeg 
 -- OI:invoke:B: "isNeg" E: "isNeg"  rec: "isNeg"  useRtnV: true "isNeg: var Boolean" 
 -- OI:invoke:before:ATdx.invoke: var isNeg 
 -- $var:invoke: "isNeg: var Boolean" E: "isNeg">newOff:4 useRTNv: "True" 
 -- DI:invoke: "isNeg: var Boolean" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:isNeg 
 -- isCompositeValueObj: false E: "isNeg" "isNeg: var Boolean" true 
 -- E.ATd.isValueObj: false rec: "isNeg" 
 pushg 4 putint$207
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -4 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:isNeg 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:isNeg 
 -- 
 -- OI:invoke:C: isNeg :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:isNeg 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: "V := 0 - V" >OGid:"$208" singular! staticOff=0 descNo=208 superAdj=0 
 -- OG:gen: "V := 0 - V" 
 pushThis 
 -- before objTmpStack:add:  208   "$208" 
 invoke $208 208 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -5 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "loop: do {   L := L + 1;   D.put(V /% 10):at[L];   V := V // 10;   if (V > 0) :then ;      restart(loop)}" 
 -- $do:gen: "loop: do {   L := L + 1;   D.put(V /% 10):at[L];   V := V // 10;   if (V > 0) :then ;      restart(loop)" } 
 -- $ObjectGenerator:gen: "L := L + 1{   D.put(V /% 10):at[L];   V := V // 10;   if (V > 0) :then ;      restart(loop)" >OGid:"loop" singular! staticOff=0 descNo=226 superAdj= ...} 
 -- OG:gen: "L := L + 1{   D.put(V /% 10):at[L];   V := V // 10;   if (V > 0) :then ;      restart(loop)}" 
 pushThis 
 -- before objTmpStack:add:  226   "loop" 
 invoke loop 226 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -6 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- genclass:stmt: "if (isNeg) :then {   put('-')}" 
 -- $ObjectGenerator:gen: "if (isNeg) :then {   put('-')" >OGid:"if:then$0" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "if (isNeg) :then {   put('-')}" 
 -- OG:before:super.gen: "if (isNeg) :then {   put('-')}" 
 -- $Invocation:gen: "if (isNeg) :then {   put('-')" >useRtnV:"False"superAdj: 0} 
 -- INV:gen: "if (isNeg) :then {   put('-')}" 
 -- isConstant: "Invocation" "if (isNeg) :then {   put('-')}" 
 -- needorigin: "if (isNeg) :then {   put('-')}" 
 -- needOrigin:E: "if (isNeg) :then {   put('-')}"  E.ATd: "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (isNeg) :then {   put('-')}" E:  "if (isNeg) :then {   put('-')}" 
 -- INV:gen:E.loadArgs "if (isNeg) :then {   put('-')}" 
 -- $IfThen:loadArgs: "if (isNeg) :then {   put('-')" } 
 -- INV:gen:after:E.loadArgs "if (isNeg) :then {   put('-')}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (isNeg) :then {   put('-')}" 
 -- $IfThen:invoke: "if (isNeg) :then {   put('-')" } 
 -- $IfThen:gen: "if (isNeg) :then {   put('-')" } 
 -- $ObjectGenerator:gen: "(isNeg)" >OGid:"Boolean" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(isNeg)" 
 -- OG:before:super.gen: "(isNeg)" 
 -- $Invocation:gen: "(isNeg)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(isNeg)" 
 -- isConstant: "Invocation" "(isNeg)" 
 -- notConst: (isNeg) isNeg: var Boolean 
 -- needorigin: "(isNeg)" 
 -- needOrigin:E: "(isNeg)"  E.ATd: "isNeg: var Boolean" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "(isNeg)" 
 -- computeAdr: 1 :rec: "none"  E: "(isNeg)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(isNeg)"  
 -- $BracketedExp:loadOrigin: "(isNeg)"  
 -- computeAdr:superAdj: 0 "isNeg" 
 -- computeAdr: 1 :rec: "none"  E: "isNeg" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "isNeg"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "isNeg" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "isNeg" >ATd.off:4:on:0:superAdj:0"isNeg: var Boolean":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ... 
 -- $var:getAdr: "isNeg: var Boolean" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F o ... 
 -- DI:OG: Boolean 
 -- before:floatTest:  "isNeg: var Boolean" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 -- computeAdr:isLast:E:  "isNeg" 
 -- BE:loadOrigin:E: isNeg 
 -- $ObjectInvocation_Unary:getAdr: "isNeg" >ATd.off:4:on:0:superAdj:0"isNeg: var Boolean":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ... 
 -- $var:getAdr: "isNeg: var Boolean" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F o ... 
 -- DI:OG: Boolean 
 -- before:floatTest:  "isNeg: var Boolean" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 -- computeAdr:isLast:E:  "isNeg" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 -- rec:  "isNeg" E:  "isNeg" 
 -- INV:gen:E.loadArgs "isNeg" 
 -- $ObjectInvocation_Unary:loadArgs: "isNeg" >staticOff:0 "isNeg: var Boolean" superAdj:0 
 -- $var:loadArgs: "isNeg: var Boolean" >E:"isNeg" 
 -- $pattern:loadArgs: "Boolean: value{   %id "Boolean";   %globals inSub;   %basic 4, 8;   %public;   _thisBasicValue: var Universal;   &&  : ;      %basic 70;      in B: var ..."} 
 -- ptn:loadArgs:E "isNeg" 
 -- {(ObjectInvocation_Unary; (name: "isNeg"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "isNeg" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "isNeg" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 -- $ObjectInvocation_Unary:invoke: "isNeg" >rec:"isNeg" ATd:"var" isValueObj E:"isNeg" E.ATd:"isNeg" unique:"False" 
 -- OI:invoke: "isNeg" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:isNeg 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:isNeg 
 -- OI:invoke:B: "isNeg" E: "isNeg"  rec: "isNeg"  useRtnV: true "isNeg: var Boolean" 
 -- OI:invoke:before:ATdx.invoke: var isNeg 
 -- $var:invoke: "isNeg: var Boolean" E: "isNeg">newOff:4 useRTNv: "True" 
 -- DI:invoke: "isNeg: var Boolean" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:isNeg 
 -- isCompositeValueObj: false E: "isNeg" "isNeg: var Boolean" true 
 -- E.ATd.isValueObj: false rec: "isNeg" 
 pushg 4 putint$207
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -7 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 3 vTopMax: 3 rTop: -7 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:isNeg 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:isNeg 
 -- 
 -- OI:invoke:C: isNeg :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:isNeg 
 jmpFalse  L7
 L6:
 -- $ObjectGenerator:gen: "put('-')" >OGid:"$209" singular! staticOff=0 descNo=209 superAdj=0 
 -- OG:gen: "put('-')" 
 pushThis 
 -- before objTmpStack:add:  209   "$209" 
 invoke $209 209 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 3 vTopMax: 3 rTop: -8 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L7:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "for(1):to(L):repeat{   i: var integer;   i := L + 1 - inx;   put('0' + D.get[i]);}" 
 -- $ObjectGenerator:gen: "for(1):to(L):repeat{   i: var integer;   i := L + 1 - inx;   put('0' + D.get[i]);" >OGid:"for:to:repeat$213" IS.isempty! staticOff=0 descNo=213 supe ...} 
 -- OG:gen: "for(1):to(L):repeat{   i: var integer;   i := L + 1 - inx;   put('0' + D.get[i]);}" 
 pushThis 
 -- before objTmpStack:add:  213   "for:to:repeat$213" 
 invoke for:to:repeat$213 213 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 3 vTopMax: 3 rTop: -9 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 -- pushReturn:  "putint" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 208 
 -- Items:GenClass: $208 descNo: 208 isValue: false 
 -- Items:GenClass: $208 descNo: 21 isValue: false 

 CLASS $208 208 1 putint 207
 -- Store itemArgs: V := 0 - V 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=208 vDescInx=208 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "V := 0 - V" 
 -- $Assign:gen: "V := 0 - V"  
 -- assign: "V := 0 - V" 
 -- computeAdr:superAdj: 0 "V" 
 -- computeAdr: 1 :rec: "none"  E: "V" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "V"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "V" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$208" on: 1 isValueObj: false 
 -- origin: putint origin:isValueObj: false 
 rpushg $208$208 1
 -- $ObjectInvocation_Unary:getAdr: "V" >ATd.off:1:on:1:superAdj:0"in V: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E: ... 
 -- $var:getAdr: "in V: var integer" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F or ... 
 -- DI:OG: integer 
 -- before:floatTest:  "in V: var integer" ObjectGenerator 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "V"  ATd: "in V: var integer" 
 -- computeAdr:isFirst: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- computeAdr:isLast:E:  "V" 
 -- AssignmentStatement:gen: "V := 0 - V" right.label: "ObjectGenerator" "0 - V" 
 -- $ObjectGenerator:gen: "0 - V" >OGid:"-" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "0 - V" 
 -- OG:before:super.gen: "0 - V" 
 -- $Invocation:gen: "0 - V" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "0 - V" 
 -- isConstant: "Invocation" "0 - V" 
 -- needorigin: "0 - V" 
 -- needOrigin:E: "0 - V"  E.ATd: "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- doNeedOrigin:Ex: "0 - V" 
 -- computeAdr:superAdj: 0 "0 - V" 
 -- computeAdr: 1 :rec: "none"  E: "0 - V" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "0 - V"  
 -- $BinOp:loadOrigin: "0 - V"  
 -- BinaryExp:loadOrigin:empty: "0 - V" superAdj: 0 
 -- $BinOp:getAdr: "0 - V"  
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "0 - V" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "0 - V" E:  "0 - V" 
 -- INV:gen:E.loadArgs "0 - V" 
 -- $BinOp:loadArgs: "0 - V"  
 -- BinaryExp:loadArgs: "0 - V" superAdj: 0 
 -- $Invocation:gen: "0" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "0" 
 -- isConstant: "Invocation" "0" 
 -- needorigin: "0" 
 -- needOrigin:E: "0"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "0" E:  "0" 
 -- INV:gen:E.loadArgs "0" 
 -- $ConstLiteral:loadArgs: "0"  
 -- INV:gen:after:E.loadArgs "0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0" 
 -- $ConstLiteral:invoke: "0"  
 pushc 0
 -- INV:gen:end:off: 
 -- left:#I "0 - V" 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 -- $pattern:loadArgs: "-  : {   %basic 62;   in V: var integer;   out R: var integer" >E:"- V":descNo:108} 
 -- ptn:loadArgs:E "- V" 
 -- {(ObjectInvocation_Binary; (name: "-"); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "V");     (Arguments)));   (Items descNo: 0 or ...} 
 -- args: "V" 
 -- E: "ObjectGenerator" V 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "- V" "ObjectInvocation_Binary" ActArg:  "V" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "- V"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "V" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "V" 
 -- OG:before:super.gen: "V" 
 -- $Invocation:gen: "V" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "V" 
 -- isConstant: "Invocation" "V" 
 -- notConst: V in V: var integer 
 -- needorigin: "V" 
 -- needOrigin:E: "V"  E.ATd: "in V: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "V" 
 -- computeAdr: 1 :rec: "none"  E: "V" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "V"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "V" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$208" on: 1 isValueObj: false 
 -- origin: putint origin:isValueObj: false 
 rpushg $208$208 1
 -- $ObjectInvocation_Unary:getAdr: "V" >ATd.off:1:on:1:superAdj:0"in V: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E: ... 
 -- $var:getAdr: "in V: var integer" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F or ... 
 -- DI:OG: integer 
 -- before:floatTest:  "in V: var integer" ObjectGenerator 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "V"  ATd: "in V: var integer" 
 -- computeAdr:isFirst: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- computeAdr:isLast:E:  "V" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- rec:  "V" E:  "V" 
 -- INV:gen:E.loadArgs "V" 
 -- $ObjectInvocation_Unary:loadArgs: "V" >staticOff:0 "in V: var integer" superAdj:0 
 -- $var:loadArgs: "in V: var integer" >E:"V" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "V" 
 -- {(ObjectInvocation_Unary; (name: "V"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "V" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "V" :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- $ObjectInvocation_Unary:invoke: "V" >rec:"V" ATd:"var" isValueObj E:"V" E.ATd:"V" unique:"False" 
 -- OI:invoke: "V" 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "V" E: "V"  rec: "V"  useRtnV: true "in V: var integer" 
 -- OI:invoke:before:ATdx.invoke: var V 
 -- $var:invoke: "in V: var integer" E: "V">newOff:1 useRTNv: "True" 
 -- DI:invoke: "in V: var integer" 
 -- load: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- isCompositeValueObj: false E: "V" "in V: var integer" true 
 -- E.ATd.isValueObj: false rec: "V" 
 pushg 1 putint$207
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- 
 -- OI:invoke:C: V :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 1 
 -- OG:gen:end: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "V" :isBasicVal: true 
 -- case:B: V ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "- V" 
 -- BinaryExp:loadArgs:end: 
 -- INV:gen:after:E.loadArgs "0 - V" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: BinOp "0 - V" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:invoke: "0 - V"  
 -- BinaryExp:invoke: "0" rec: "0 - V" 
 -- M: "- V" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Binary:invoke: "- V" >rec:"0" ATd:"pattern" E:"- V" E.ATd:"-  " unique:"False" 
 -- OI:invoke: "- V" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:0 
 -- origin:isValueObj "integer" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:0 
 -- OI:invoke:B: "- V" E: "- V"  rec: "0"  useRtnV: true "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern -   
 -- $pattern:invoke: "-  : {   %basic 62;   in V: var integer;   out R: var integer" E: "- V" useRTNv: "True"} 
 -- ptn:invoke: "-  " E: "- V" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "0" E: "- V" 
 -- arg:other 
 minus
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"- V":rec:0 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"- V":rec:0 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: - V :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "V" dstE: "V" dstE.ATd: "in V: var integer" useRtn: false :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "0 - V" 
 -- isArgOfAssignI2IwithUniValArg "V := 0 - V" arg: "0 - V" ObjectGenerator 
 -- arg.super.arg: "0 - V" BinOp 
 -- recx:BinaryExp:recx: "0 - V" 
 -- M: "- V" label: "ObjectInvocation_Binary" M.ATd: "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- checkInt2IntWithUnitArg:rec: "0" E: "- V" 
 -- arg:other 
 -- M:arg: "V" ObjectGenerator false 
 -- dstDI: "in V: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg putint$207 1
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 226 
 -- Items:GenClass: loop descNo: 226 isValue: false 
 -- Items:GenClass: loop descNo: 21 isValue: false 

 CLASS loop 226 1 putint 207
 -- Store itemArgs: L := L + 1{D.put(V /% 10):at[L];V := V // 10;if (V > 0) :then ;   restart(loop)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=226 vDescInx=226 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "L := L + 1" 
 -- $Assign:gen: "L := L + 1"  
 -- assign: "L := L + 1" 
 -- computeAdr:superAdj: 0 "L" 
 -- computeAdr: 1 :rec: "none"  E: "L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: putint origin:isValueObj: false 
 rpushg loop$226 1
 -- $ObjectInvocation_Unary:getAdr: "L" >ATd.off:3:on:1:superAdj:0"L: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "L: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "L"  ATd: "L: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdr:isLast:E:  "L" 
 -- AssignmentStatement:gen: "L := L + 1" right.label: "ObjectGenerator" "L + 1" 
 -- $ObjectGenerator:gen: "L + 1" >OGid:"+" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L + 1" 
 -- OG:before:super.gen: "L + 1" 
 -- $Invocation:gen: "L + 1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L + 1" 
 -- isConstant: "Invocation" "L + 1" 
 -- needorigin: "L + 1" 
 -- needOrigin:E: "L + 1"  E.ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- doNeedOrigin:Ex: "L + 1" 
 -- computeAdr:superAdj: 0 "L + 1" 
 -- computeAdr: 1 :rec: "none"  E: "L + 1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "L + 1"  
 -- $BinOp:loadOrigin: "L + 1"  
 -- BinaryExp:loadOrigin:empty: "L + 1" superAdj: 0 
 -- $BinOp:getAdr: "L + 1"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "L + 1"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "L + 1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "L + 1" E:  "L + 1" 
 -- INV:gen:E.loadArgs "L + 1" 
 -- $BinOp:loadArgs: "L + 1"  
 -- BinaryExp:loadArgs: "L + 1" superAdj: 0 
 -- $Invocation:gen: "L" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L" 
 -- isConstant: "Invocation" "L" 
 -- notConst: L L: var integer 
 -- needorigin: "L" 
 -- needOrigin:E: "L"  E.ATd: "L: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L" 
 -- computeAdr: 1 :rec: "none"  E: "L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: putint origin:isValueObj: false 
 rpushg loop$226 1
 -- $ObjectInvocation_Unary:getAdr: "L" >ATd.off:3:on:1:superAdj:0"L: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "L: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "L"  ATd: "L: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdr:isLast:E:  "L" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- rec:  "L" E:  "L" 
 -- INV:gen:E.loadArgs "L" 
 -- $ObjectInvocation_Unary:loadArgs: "L" >staticOff:0 "L: var integer" superAdj:0 
 -- $var:loadArgs: "L: var integer" >E:"L" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "L" 
 -- {(ObjectInvocation_Unary; (name: "L"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L" >rec:"L" ATd:"var" isValueObj E:"L" E.ATd:"L" unique:"False" 
 -- OI:invoke: "L" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "L" E: "L"  rec: "L"  useRtnV: true "L: var integer" 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- $var:invoke: "L: var integer" E: "L">newOff:3 useRTNv: "True" 
 -- DI:invoke: "L: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- isCompositeValueObj: false E: "L" "L: var integer" true 
 -- E.ATd.isValueObj: false rec: "L" 
 pushg 3 putint$207
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- OI:invoke:C: L :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- left:#I "L + 1" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- $pattern:loadArgs: "+  : {   %basic 61;   in V: var integer;   out R: var integer" >E:"+ 1":descNo:49} 
 -- ptn:loadArgs:E "+ 1" 
 -- {(ObjectInvocation_Binary; (name: "+"); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 1));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "1" 
 -- E: "ObjectGenerator" 1 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "+ 1" "ObjectInvocation_Binary" ActArg:  "1" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ 1"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "1" :isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "+ 1" 
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:after:E.loadArgs "L + 1" 
 -- OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L + 1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- $BinOp:invoke: "L + 1"  
 -- BinaryExp:invoke: "L" rec: "L + 1" 
 -- M: "+ 1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- $ObjectInvocation_Binary:invoke: "+ 1" >rec:"L" ATd:"pattern" E:"+ 1" E.ATd:"+  " unique:"False" 
 -- OI:invoke: "+ 1" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- origin:isValueObj "integer" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "+ 1" E: "+ 1"  rec: "L"  useRtnV: true "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- $pattern:invoke: "+  : {   %basic 61;   in V: var integer;   out R: var integer" E: "+ 1" useRTNv: "True"} 
 -- ptn:invoke: "+  " E: "+ 1" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "L" E: "+ 1" 
 -- arg:integer 
 plus
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:L 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:L 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: + 1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "L" dstE: "L" dstE.ATd: "L: var integer" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "L + 1" 
 -- isArgOfAssignI2IwithUniValArg "L := L + 1" arg: "L + 1" ObjectGenerator 
 -- arg.super.arg: "L + 1" BinOp 
 -- recx:BinaryExp:recx: "L + 1" 
 -- M: "+ 1" label: "ObjectInvocation_Binary" M.ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- checkInt2IntWithUnitArg:rec: "L" E: "+ 1" 
 -- arg:integer 
 -- M:arg: "1" ObjectGenerator false 
 -- dstDI: "L: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg putint$207 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "D.put(V /% 10):at[L]" 
 -- $ObjectGenerator:gen: "D.put(V /% 10):at[L]" >OGid:"put:at" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "D.put(V /% 10):at[L]" 
 -- OG:before:super.gen: "D.put(V /% 10):at[L]" 
 -- $Invocation:gen: "D.put(V /% 10):at[L]" >useRtnV:"False"superAdj: 0 descNo: 93 
 -- INV:gen: "D.put(V /% 10):at[L]" 
 -- isConstant: "Invocation" "D.put(V /% 10):at[L]" 
 -- needorigin: "D.put(V /% 10):at[L]" 
 -- needOrigin:E: "put(V /% 10):at[L]"  E.ATd: "put(V: var integer):at[inx: var integer]: {   %basic 115}" 
 -- doNeedOrigin:Ex: "put(V /% 10):at[L]" 
 -- computeAdr:superAdj: 0 "D.put(V /% 10):at[L]" 
 -- computeAdr: 1 :rec: "none"  E: "D" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "D"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "D" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: putint origin:isValueObj: false 
 rpushg loop$226 1
 -- $ObjectInvocation_Unary:getAdr: "D" >ATd.off:2:on:1:superAdj:0"D: obj Indexed(20,#integer)":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIs ... 
 -- $obj:getAdr: "D: obj Indexed(20,#integer)" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique: ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "D"  ATd: "D: obj Indexed(20,#integer)" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "D"  E: "put(V /% 10):at[L]" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:getAdr: "put(V /% 10):at[L]" >ATd.off:0 (isPtn):on:0:superAdj:0"put(V: var integer):at[inx: var integer]: {   %basic 115":Adr:off:2 size:0 isFloa ...} 
 -- $pattern:getAdr: "put(V: var integer):at[inx: var integer]: {   %basic 115" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(V /% 10):at[L]":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "D" >staticOff:0 "D: obj Indexed(20,#integer)" superAdj:0 
 -- $obj:loadArgs: "D: obj Indexed(20,#integer)" >E:"D" 
 -- $pattern:loadArgs: "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];  ..."} 
 -- ptn:loadArgs:E "D" 
 -- {(ObjectInvocation_Unary; (name: "D"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "D" >rec:"D" ATd:"obj" E:"put(V /% 10):at[L]" E.ATd:"put(V: var integer):at[inx: var integer]" unique:"False" 
 -- OI:invoke: "D" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(V /% 10):at[L]":rec:D 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(V /% 10):at[L]":rec:D 
 -- OI:invoke:B: "D" E: "put(V /% 10):at[L]"  rec: "D"  useRtnV: true "D: obj Indexed(20,#integer)" 
 -- OI:invoke:before:ATdx.invoke: obj D 
 -- $obj:invoke: "D: obj Indexed(20,#integer)" E: "put(V /% 10):at[L]">newOff:2 useRTNv: "True" 
 -- DI:invoke: "D: obj Indexed(20,#integer)" 
 -- >Object:unique: false 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(V /% 10):at[L]":rec:D 
 -- isCompositeValueObj: false E: "put(V /% 10):at[L]" "put(V: var integer):at[inx: var integer]: {   %basic 115}" false 
 -- E.ATd.isValueObj: false rec: "D" 
 rpushg loop$226 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(V /% 10):at[L]":rec:D 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(V /% 10):at[L]":rec:D 
 -- 
 -- OI:invoke:C: D :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "D" E: "put(V /% 10):at[L]" 
 -- arg:other 
 -- computeAdr:isLast:E:  "put(V /% 10):at[L]" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(V /% 10):at[L]":rec:D 
 -- rec:  "D" E:  "put(V /% 10):at[L]" 
 -- INV:gen:E.loadArgs "put(V /% 10):at[L]" 
 -- $ObjectInvocation_KeyWord:loadArgs: "put(V /% 10):at[L]" >staticOff:0 "put(V: var integer):at[inx: var integer]: {   %basic 115" superAdj:0arg:"V /% 10"arg:"L"} 
 -- $pattern:loadArgs: "put(V: var integer):at[inx: var integer]: {   %basic 115" >E:"put(V /% 10):at[L]":descNo:93} 
 -- ptn:loadArgs:E "put(V /% 10):at[L]" 
 -- {(ObjectInvocation_KeyWord; (name: "put:at"); (Arguments;  (name: "put");  (name: "(");  (ObjectGenerator;   (Invocation;    (BinOp:/%;     (Invocation;      (ObjectInvoca ...} 
 -- args: "put(V /% 10):at[L]" 
 -- E: "ObjectGenerator" V /% 10 
 -- E: "ObjectGenerator" L 
 -- E.arg: "var" V: var integer 
 -- NonVirt: "put(V /% 10):at[L]" "ObjectInvocation_KeyWord" ActArg:  "V /% 10" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(V /% 10):at[L]"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "V /% 10" >OGid:"/%" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "V /% 10" 
 -- OG:before:super.gen: "V /% 10" 
 -- $Invocation:gen: "V /% 10" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "V /% 10" 
 -- isConstant: "Invocation" "V /% 10" 
 -- needorigin: "V /% 10" 
 -- needOrigin:E: "V /% 10"  E.ATd: "/%  : {   %basic 69;   in V: var integer;   out R: var integer}" 
 -- doNeedOrigin:Ex: "V /% 10" 
 -- computeAdr:superAdj: 0 "V /% 10" 
 -- computeAdr: 1 :rec: "none"  E: "V /% 10" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "V /% 10"  
 -- $BinOp:loadOrigin: "V /% 10"  
 -- BinaryExp:loadOrigin:empty: "V /% 10" superAdj: 0 
 -- $BinOp:getAdr: "V /% 10"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "V /% 10"  ATd: "/%  : {   %basic 69;   in V: var integer;   out R: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "V /% 10" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "V /% 10" E:  "V /% 10" 
 -- INV:gen:E.loadArgs "V /% 10" 
 -- $BinOp:loadArgs: "V /% 10"  
 -- BinaryExp:loadArgs: "V /% 10" superAdj: 0 
 -- $Invocation:gen: "V" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "V" 
 -- isConstant: "Invocation" "V" 
 -- notConst: V in V: var integer 
 -- needorigin: "V" 
 -- needOrigin:E: "V"  E.ATd: "in V: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "V" 
 -- computeAdr: 1 :rec: "none"  E: "V" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "V"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "V" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: putint origin:isValueObj: false 
 rpushg loop$226 1
 -- $ObjectInvocation_Unary:getAdr: "V" >ATd.off:1:on:1:superAdj:0"in V: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E: ... 
 -- $var:getAdr: "in V: var integer" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F or ... 
 -- DI:OG: integer 
 -- before:floatTest:  "in V: var integer" ObjectGenerator 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "V"  ATd: "in V: var integer" 
 -- computeAdr:isFirst: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- computeAdr:isLast:E:  "V" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- rec:  "V" E:  "V" 
 -- INV:gen:E.loadArgs "V" 
 -- $ObjectInvocation_Unary:loadArgs: "V" >staticOff:0 "in V: var integer" superAdj:0 
 -- $var:loadArgs: "in V: var integer" >E:"V" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "V" 
 -- {(ObjectInvocation_Unary; (name: "V"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "V" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "V" :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- $ObjectInvocation_Unary:invoke: "V" >rec:"V" ATd:"var" isValueObj E:"V" E.ATd:"V" unique:"False" 
 -- OI:invoke: "V" 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "V" E: "V"  rec: "V"  useRtnV: true "in V: var integer" 
 -- OI:invoke:before:ATdx.invoke: var V 
 -- $var:invoke: "in V: var integer" E: "V">newOff:1 useRTNv: "True" 
 -- DI:invoke: "in V: var integer" 
 -- load: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- isCompositeValueObj: false E: "V" "in V: var integer" true 
 -- E.ATd.isValueObj: false rec: "V" 
 pushg 1 putint$207
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- 
 -- OI:invoke:C: V :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 1 
 -- left:#I "V /% 10" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- $pattern:loadArgs: "/%  : {   %basic 69;   in V: var integer;   out R: var integer" >E:"/% 10":descNo:227} 
 -- ptn:loadArgs:E "/% 10" 
 -- {(ObjectInvocation_Binary; (name: "/%"); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 10));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "10" 
 -- E: "ObjectGenerator" 10 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "/% 10" "ObjectInvocation_Binary" ActArg:  "10" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "/% 10"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "10" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "10" 
 -- OG:before:super.gen: "10" 
 -- $Invocation:gen: "10" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "10" 
 -- isConstant: "Invocation" "10" 
 -- needorigin: "10" 
 -- needOrigin:E: "10"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "10" E:  "10" 
 -- INV:gen:E.loadArgs "10" 
 -- $ConstLiteral:loadArgs: "10"  
 -- INV:gen:after:E.loadArgs "10" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "10" 
 -- $ConstLiteral:invoke: "10"  
 pushc 10
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "10" :isBasicVal: true 
 -- case:B: 10 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "/% 10" 
 -- BinaryExp:loadArgs:end: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- INV:gen:after:E.loadArgs "V /% 10" 
 -- OIadr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- IV:E.invoke:useRtnVal: true E: BinOp "V /% 10" :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- $BinOp:invoke: "V /% 10"  
 -- BinaryExp:invoke: "V" rec: "V /% 10" 
 -- M: "/% 10" :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- $ObjectInvocation_Binary:invoke: "/% 10" >rec:"V" ATd:"pattern" E:"/% 10" E.ATd:"/%  " unique:"False" 
 -- OI:invoke: "/% 10" 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- origin:isValueObj "integer" 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "/% 10" E: "/% 10"  rec: "V"  useRtnV: true "/%  : {   %basic 69;   in V: var integer;   out R: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern /%   
 -- $pattern:invoke: "/%  : {   %basic 69;   in V: var integer;   out R: var integer" E: "/% 10" useRTNv: "True"} 
 -- ptn:invoke: "/%  " E: "/% 10" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "V" E: "/% 10" 
 -- arg:integer 
 modd
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"/% 10":rec:V 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"/% 10":rec:V 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: /% 10 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "V /% 10" :isBasicVal: true 
 -- case:B: V /% 10 ObjectGenerator 1 69 69 false false 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "put(V /% 10):at[L]" 
 -- E.arg: "var" inx: var integer 
 -- NonVirt: "put(V /% 10):at[L]" "ObjectInvocation_KeyWord" ActArg:  "L" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(V /% 10):at[L]"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "L" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L" 
 -- OG:before:super.gen: "L" 
 -- $Invocation:gen: "L" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L" 
 -- isConstant: "Invocation" "L" 
 -- notConst: L L: var integer 
 -- needorigin: "L" 
 -- needOrigin:E: "L"  E.ATd: "L: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L" 
 -- computeAdr: 1 :rec: "none"  E: "L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: putint origin:isValueObj: false 
 rpushg loop$226 1
 -- $ObjectInvocation_Unary:getAdr: "L" >ATd.off:3:on:1:superAdj:0"L: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "L: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "L"  ATd: "L: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdr:isLast:E:  "L" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- rec:  "L" E:  "L" 
 -- INV:gen:E.loadArgs "L" 
 -- $ObjectInvocation_Unary:loadArgs: "L" >staticOff:0 "L: var integer" superAdj:0 
 -- $var:loadArgs: "L: var integer" >E:"L" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "L" 
 -- {(ObjectInvocation_Unary; (name: "L"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L" >rec:"L" ATd:"var" isValueObj E:"L" E.ATd:"L" unique:"False" 
 -- OI:invoke: "L" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "L" E: "L"  rec: "L"  useRtnV: true "L: var integer" 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- $var:invoke: "L: var integer" E: "L">newOff:3 useRTNv: "True" 
 -- DI:invoke: "L: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- isCompositeValueObj: false E: "L" "L: var integer" true 
 -- E.ATd.isValueObj: false rec: "L" 
 pushg 3 putint$207
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 3 vTopMax: 3 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- OI:invoke:C: L :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- formalArg:isPtn: "inx: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "L" :isBasicVal: true 
 -- case:B: L ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "put(V /% 10):at[L]" 
 -- INV:gen:after:E.loadArgs "put(V /% 10):at[L]" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(V /% 10):at[L]" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"pu ..." 
 -- $ObjectInvocation_KeyWord:invoke: "put(V /% 10):at[L]" >rec:"D" ATd:"pattern" E:"put(V /% 10):at[L]" E.ATd:"put(V: var integer):at[inx: var integer]" unique:"False" 
 -- OI:invoke: "put(V /% 10):at[L]" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(V /% 10):at[L]":rec:D 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(V /% 10):at[L]":rec:D 
 -- OI:invoke:B: "put(V /% 10):at[L]" E: "put(V /% 10):at[L]"  rec: "D"  useRtnV: false "put(V: var integer):at[inx: var integer]: {   %basic 115}" 
 -- OI:invoke:before:ATdx.invoke: pattern put(V: var integer):at[inx: var integer] 
 -- $pattern:invoke: "put(V: var integer):at[inx: var integer]: {   %basic 115" E: "put(V /% 10):at[L]" useRTNv: "False"} 
 -- ptn:invoke: "put(V: var integer):at[inx: var integer]" E: "put(V /% 10):at[L]" ptnKind: 0 useRtnV: false 
 xstoreg  inx 1 0 1
 -- stack: rpop : vTop: 3 vTopMax: 3 rTop: -4 rTopMax: 0 V: 0 R: 
 -- stack: vpop : vTop: 1 vTopMax: 3 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(V /% 10):at[L]":rec:D 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(V /% 10):at[L]":rec:D 
 -- 
 -- OI:invoke:C: put(V /% 10):at[L] :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(V /% 10):at[L]":rec:D 
 -- genclass:stmt: "V := V // 10" 
 -- $Assign:gen: "V := V // 10"  
 -- assign: "V := V // 10" 
 -- computeAdr:superAdj: 0 "V" 
 -- computeAdr: 1 :rec: "none"  E: "V" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "V"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "V" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: putint origin:isValueObj: false 
 rpushg loop$226 1
 -- $ObjectInvocation_Unary:getAdr: "V" >ATd.off:1:on:1:superAdj:0"in V: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E: ... 
 -- $var:getAdr: "in V: var integer" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F or ... 
 -- DI:OG: integer 
 -- before:floatTest:  "in V: var integer" ObjectGenerator 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "V"  ATd: "in V: var integer" 
 -- computeAdr:isFirst: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- computeAdr:isLast:E:  "V" 
 -- AssignmentStatement:gen: "V := V // 10" right.label: "ObjectGenerator" "V // 10" 
 -- $ObjectGenerator:gen: "V // 10" >OGid:"//" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "V // 10" 
 -- OG:before:super.gen: "V // 10" 
 -- $Invocation:gen: "V // 10" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "V // 10" 
 -- isConstant: "Invocation" "V // 10" 
 -- needorigin: "V // 10" 
 -- needOrigin:E: "V // 10"  E.ATd: "//  : {   %basic 68;   in V: var integer;   out B: var integer}" 
 -- doNeedOrigin:Ex: "V // 10" 
 -- computeAdr:superAdj: 0 "V // 10" 
 -- computeAdr: 1 :rec: "none"  E: "V // 10" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "V // 10"  
 -- $BinOp:loadOrigin: "V // 10"  
 -- BinaryExp:loadOrigin:empty: "V // 10" superAdj: 0 
 -- $BinOp:getAdr: "V // 10"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "V // 10"  ATd: "//  : {   %basic 68;   in V: var integer;   out B: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "V // 10" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "V // 10" E:  "V // 10" 
 -- INV:gen:E.loadArgs "V // 10" 
 -- $BinOp:loadArgs: "V // 10"  
 -- BinaryExp:loadArgs: "V // 10" superAdj: 0 
 -- $Invocation:gen: "V" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "V" 
 -- isConstant: "Invocation" "V" 
 -- notConst: V in V: var integer 
 -- needorigin: "V" 
 -- needOrigin:E: "V"  E.ATd: "in V: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "V" 
 -- computeAdr: 1 :rec: "none"  E: "V" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "V"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "V" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: putint origin:isValueObj: false 
 rpushg loop$226 1
 -- $ObjectInvocation_Unary:getAdr: "V" >ATd.off:1:on:1:superAdj:0"in V: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E: ... 
 -- $var:getAdr: "in V: var integer" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F or ... 
 -- DI:OG: integer 
 -- before:floatTest:  "in V: var integer" ObjectGenerator 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "V"  ATd: "in V: var integer" 
 -- computeAdr:isFirst: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- computeAdr:isLast:E:  "V" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- rec:  "V" E:  "V" 
 -- INV:gen:E.loadArgs "V" 
 -- $ObjectInvocation_Unary:loadArgs: "V" >staticOff:0 "in V: var integer" superAdj:0 
 -- $var:loadArgs: "in V: var integer" >E:"V" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "V" 
 -- {(ObjectInvocation_Unary; (name: "V"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "V" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "V" :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- $ObjectInvocation_Unary:invoke: "V" >rec:"V" ATd:"var" isValueObj E:"V" E.ATd:"V" unique:"False" 
 -- OI:invoke: "V" 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "V" E: "V"  rec: "V"  useRtnV: true "in V: var integer" 
 -- OI:invoke:before:ATdx.invoke: var V 
 -- $var:invoke: "in V: var integer" E: "V">newOff:1 useRTNv: "True" 
 -- DI:invoke: "in V: var integer" 
 -- load: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- isCompositeValueObj: false E: "V" "in V: var integer" true 
 -- E.ATd.isValueObj: false rec: "V" 
 pushg 1 putint$207
 -- stack: rpop : vTop: 1 vTopMax: 3 rTop: -5 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 3 rTop: -5 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- 
 -- OI:invoke:C: V :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 1 
 -- left:#I "V // 10" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- $pattern:loadArgs: "//  : {   %basic 68;   in V: var integer;   out B: var integer" >E:"// 10":descNo:228} 
 -- ptn:loadArgs:E "// 10" 
 -- {(ObjectInvocation_Binary; (name: "//"); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 10));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "10" 
 -- E: "ObjectGenerator" 10 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "// 10" "ObjectInvocation_Binary" ActArg:  "10" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "// 10"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "10" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "10" 
 -- OG:before:super.gen: "10" 
 -- $Invocation:gen: "10" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "10" 
 -- isConstant: "Invocation" "10" 
 -- needorigin: "10" 
 -- needOrigin:E: "10"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "10" E:  "10" 
 -- INV:gen:E.loadArgs "10" 
 -- $ConstLiteral:loadArgs: "10"  
 -- INV:gen:after:E.loadArgs "10" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "10" 
 -- $ConstLiteral:invoke: "10"  
 pushc 10
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "10" :isBasicVal: true 
 -- case:B: 10 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "// 10" 
 -- BinaryExp:loadArgs:end: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- INV:gen:after:E.loadArgs "V // 10" 
 -- OIadr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- IV:E.invoke:useRtnVal: true E: BinOp "V // 10" :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- $BinOp:invoke: "V // 10"  
 -- BinaryExp:invoke: "V" rec: "V // 10" 
 -- M: "// 10" :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- $ObjectInvocation_Binary:invoke: "// 10" >rec:"V" ATd:"pattern" E:"// 10" E.ATd:"//  " unique:"False" 
 -- OI:invoke: "// 10" 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- origin:isValueObj "integer" 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "// 10" E: "// 10"  rec: "V"  useRtnV: true "//  : {   %basic 68;   in V: var integer;   out B: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern //   
 -- $pattern:invoke: "//  : {   %basic 68;   in V: var integer;   out B: var integer" E: "// 10" useRTNv: "True"} 
 -- ptn:invoke: "//  " E: "// 10" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "V" E: "// 10" 
 -- arg:integer 
 idiv
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"// 10":rec:V 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"// 10":rec:V 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: // 10 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "V" dstE: "V" dstE.ATd: "in V: var integer" useRtn: false :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "V // 10" 
 -- isArgOfAssignI2IwithUniValArg "V := V // 10" arg: "V // 10" ObjectGenerator 
 -- arg.super.arg: "V // 10" BinOp 
 -- recx:BinaryExp:recx: "V // 10" 
 -- M: "// 10" label: "ObjectInvocation_Binary" M.ATd: "//  : {   %basic 68;   in V: var integer;   out B: var integer}" 
 -- checkInt2IntWithUnitArg:rec: "V" E: "// 10" 
 -- arg:integer 
 -- M:arg: "10" ObjectGenerator false 
 -- dstDI: "in V: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg putint$207 1
 -- assign:adr.store:B: 
 -- genclass:stmt: "if (V > 0) :then {   restart(loop)}" 
 -- $ObjectGenerator:gen: "if (V > 0) :then {   restart(loop)" >OGid:"if:then$0" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "if (V > 0) :then {   restart(loop)}" 
 -- OG:before:super.gen: "if (V > 0) :then {   restart(loop)}" 
 -- $Invocation:gen: "if (V > 0) :then {   restart(loop)" >useRtnV:"False"superAdj: 0} 
 -- INV:gen: "if (V > 0) :then {   restart(loop)}" 
 -- isConstant: "Invocation" "if (V > 0) :then {   restart(loop)}" 
 -- needorigin: "if (V > 0) :then {   restart(loop)}" 
 -- needOrigin:E: "if (V > 0) :then {   restart(loop)}"  E.ATd: "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (V > 0) :then {   restart(loop)}" E:  "if (V > 0) :then {   restart(loop)}" 
 -- INV:gen:E.loadArgs "if (V > 0) :then {   restart(loop)}" 
 -- $IfThen:loadArgs: "if (V > 0) :then {   restart(loop)" } 
 -- INV:gen:after:E.loadArgs "if (V > 0) :then {   restart(loop)}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (V > 0) :then {   restart(loop)}" 
 -- $IfThen:invoke: "if (V > 0) :then {   restart(loop)" } 
 -- $IfThen:gen: "if (V > 0) :then {   restart(loop)" } 
 -- $ObjectGenerator:gen: "(V > 0)" >OGid:">" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(V > 0)" 
 -- OG:before:super.gen: "(V > 0)" 
 -- $Invocation:gen: "(V > 0)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(V > 0)" 
 -- isConstant: "Invocation" "(V > 0)" 
 -- needorigin: "(V > 0)" 
 -- needOrigin:E: "(V > 0)"  E.ATd: ">  : {   %basic 53;   in V: var integer;   out B: var boolean}" 
 -- doNeedOrigin:Ex: "(V > 0)" 
 -- computeAdr:superAdj: 0 "(V > 0)" 
 -- computeAdr: 1 :rec: "none"  E: "(V > 0)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(V > 0)"  
 -- $BracketedExp:loadOrigin: "(V > 0)"  
 -- computeAdr:superAdj: 0 "V > 0" 
 -- computeAdr: 1 :rec: "none"  E: "V > 0" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "V > 0"  
 -- $BinOp:loadOrigin: "V > 0"  
 -- BinaryExp:loadOrigin:empty: "V > 0" superAdj: 0 
 -- $BinOp:getAdr: "V > 0"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "V > 0"  ATd: ">  : {   %basic 53;   in V: var integer;   out B: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "V > 0" 
 -- BE:loadOrigin:E: V > 0 
 -- $BinOp:getAdr: "V > 0"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "V > 0"  ATd: ">  : {   %basic 53;   in V: var integer;   out B: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "V > 0" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "V > 0" E:  "V > 0" 
 -- INV:gen:E.loadArgs "V > 0" 
 -- $BinOp:loadArgs: "V > 0"  
 -- BinaryExp:loadArgs: "V > 0" superAdj: 0 
 -- $Invocation:gen: "V" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "V" 
 -- isConstant: "Invocation" "V" 
 -- notConst: V in V: var integer 
 -- needorigin: "V" 
 -- needOrigin:E: "V"  E.ATd: "in V: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "V" 
 -- computeAdr: 1 :rec: "none"  E: "V" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "V"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "V" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: putint origin:isValueObj: false 
 rpushg loop$226 1
 -- $ObjectInvocation_Unary:getAdr: "V" >ATd.off:1:on:1:superAdj:0"in V: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E: ... 
 -- $var:getAdr: "in V: var integer" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F or ... 
 -- DI:OG: integer 
 -- before:floatTest:  "in V: var integer" ObjectGenerator 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "V"  ATd: "in V: var integer" 
 -- computeAdr:isFirst: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- computeAdr:isLast:E:  "V" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- rec:  "V" E:  "V" 
 -- INV:gen:E.loadArgs "V" 
 -- $ObjectInvocation_Unary:loadArgs: "V" >staticOff:0 "in V: var integer" superAdj:0 
 -- $var:loadArgs: "in V: var integer" >E:"V" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "V" 
 -- {(ObjectInvocation_Unary; (name: "V"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "V" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "V" :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- $ObjectInvocation_Unary:invoke: "V" >rec:"V" ATd:"var" isValueObj E:"V" E.ATd:"V" unique:"False" 
 -- OI:invoke: "V" 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "V" E: "V"  rec: "V"  useRtnV: true "in V: var integer" 
 -- OI:invoke:before:ATdx.invoke: var V 
 -- $var:invoke: "in V: var integer" E: "V">newOff:1 useRTNv: "True" 
 -- DI:invoke: "in V: var integer" 
 -- load: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- isCompositeValueObj: false E: "V" "in V: var integer" true 
 -- E.ATd.isValueObj: false rec: "V" 
 pushg 1 putint$207
 -- stack: rpop : vTop: 2 vTopMax: 3 rTop: -6 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 3 vTopMax: 3 rTop: -6 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- 
 -- OI:invoke:C: V :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 1 
 -- left:#I "V > 0" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- $pattern:loadArgs: ">  : {   %basic 53;   in V: var integer;   out B: var boolean" >E:"> 0":descNo:101} 
 -- ptn:loadArgs:E "> 0" 
 -- {(ObjectInvocation_Binary; (name: ">"); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 0));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "0" 
 -- E: "ObjectGenerator" 0 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "> 0" "ObjectInvocation_Binary" ActArg:  "0" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "> 0"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "0" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "0" 
 -- OG:before:super.gen: "0" 
 -- $Invocation:gen: "0" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "0" 
 -- isConstant: "Invocation" "0" 
 -- needorigin: "0" 
 -- needOrigin:E: "0"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "0" E:  "0" 
 -- INV:gen:E.loadArgs "0" 
 -- $ConstLiteral:loadArgs: "0"  
 -- INV:gen:after:E.loadArgs "0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0" 
 -- $ConstLiteral:invoke: "0"  
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "0" :isBasicVal: true 
 -- case:B: 0 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "> 0" 
 -- BinaryExp:loadArgs:end: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- INV:gen:after:E.loadArgs "V > 0" 
 -- OIadr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- IV:E.invoke:useRtnVal: true E: BinOp "V > 0" :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- $BinOp:invoke: "V > 0"  
 -- BinaryExp:invoke: "V" rec: "V > 0" 
 -- M: "> 0" :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- $ObjectInvocation_Binary:invoke: "> 0" >rec:"V" ATd:"pattern" E:"> 0" E.ATd:">  " unique:"False" 
 -- OI:invoke: "> 0" 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- origin:isValueObj "integer" 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "> 0" E: "> 0"  rec: "V"  useRtnV: true ">  : {   %basic 53;   in V: var integer;   out B: var boolean}" 
 -- OI:invoke:before:ATdx.invoke: pattern >   
 -- $pattern:invoke: ">  : {   %basic 53;   in V: var integer;   out B: var boolean" E: "> 0" useRTNv: "True"} 
 -- ptn:invoke: ">  " E: "> 0" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "V" E: "> 0" 
 -- arg:integer 
 gt
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"> 0":rec:V 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"> 0":rec:V 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: > 0 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: "restart(loop)" >OGid:"$229" singular! staticOff=0 descNo=229 superAdj=0 
 -- OG:gen: "restart(loop)" 
 pushThis 
 -- before objTmpStack:add:  229   "$229" 
 invoke $229 229 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 3 vTopMax: 3 rTop: -7 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 -- pushReturn:  "loop" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 229 
 -- Items:GenClass: $229 descNo: 229 isValue: false 
 -- Items:GenClass: $229 descNo: 21 isValue: false 

 CLASS $229 229 1 loop 226
 -- Store itemArgs: restart(loop) 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=229 vDescInx=229 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "restart(loop)" 
 -- $ObjectGenerator:gen: "restart(loop)" >OGid:"restart" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "restart(loop)" 
 -- OG:before:super.gen: "restart(loop)" 
 -- $Invocation:gen: "restart(loop)" >useRtnV:"False"superAdj: 0 descNo: 50 
 -- INV:gen: "restart(loop)" 
 -- isConstant: "Invocation" "restart(loop)" 
 -- needorigin: "restart(loop)" 
 -- needOrigin:E: "restart(loop)"  E.ATd: "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- doNeedOrigin:Ex: "restart(loop)" 
 -- computeAdr:superAdj: 0 "restart(loop)" 
 -- computeAdr: 1 :rec: "none"  E: "restart(loop)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "restart(loop)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "restart(loop)" >on:3 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "restart(loop)" >ATd.off:0 (isPtn):on:3:superAdj:0"restart(V: var integer):  -- odd parameter type!{   %basic 102":Adr:off:0 size:0 isFlo ...} 
 -- $pattern:getAdr: "restart(V: var integer):  -- odd parameter type!{   %basic 102" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:- 
 -- E.on: 3 
 -- beforeIsValueObj:E: "restart(loop)"  ATd: "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:- 
 -- computeAdr:isLast:E:  "restart(loop)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:- 
 -- rec:  "restart(loop)" E:  "restart(loop)" 
 -- INV:gen:E.loadArgs "restart(loop)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "restart(loop)" >staticOff:0 "restart(V: var integer):  -- odd parameter type!{   %basic 102" superAdj:0arg:"loop"} 
 -- $pattern:loadArgs: "restart(V: var integer):  -- odd parameter type!{   %basic 102" >E:"restart(loop)":descNo:50} 
 -- INV:gen:after:E.loadArgs "restart(loop)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "restart(loop)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart ..." 
 -- $ObjectInvocation_KeyWord:invoke: "restart(loop)" >rec:"restart(loop)" ATd:"pattern" E:"restart(loop)" E.ATd:"restart(V: var integer)" unique:"False" 
 -- OI:invoke: "restart(loop)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- OI:invoke:B: "restart(loop)" E: "restart(loop)"  rec: "restart(loop)"  useRtnV: false "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- OI:invoke:before:ATdx.invoke: pattern restart(V: var integer) 
 -- $pattern:invoke: "restart(V: var integer):  -- odd parameter type!{   %basic 102" E: "restart(loop)" useRTNv: "False"} 
 -- ptn:invoke: "restart(V: var integer)" E: "restart(loop)" ptnKind: 0 useRtnV: false 
 break  1 1 226 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- 
 -- OI:invoke:C: restart(loop) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 209 
 -- Items:GenClass: $209 descNo: 209 isValue: false 
 -- Items:GenClass: $209 descNo: 21 isValue: false 

 CLASS $209 209 1 putint 207
 -- Store itemArgs: put('-') 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=209 vDescInx=209 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "put('-')" 
 -- $ObjectGenerator:gen: "put('-')" >OGid:"put" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "put('-')" 
 -- OG:before:super.gen: "put('-')" 
 -- $Invocation:gen: "put('-')" >useRtnV:"False"superAdj: 0 descNo: 105 
 -- INV:gen: "put('-')" 
 -- isConstant: "Invocation" "put('-')" 
 -- needorigin: "put('-')" 
 -- needOrigin:E: "put('-')"  E.ATd: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- Ex:loadOrign:no:loadOrigin:  "-- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "put('-')" E:  "put('-')" 
 -- INV:gen:E.loadArgs "put('-')" 
 -- $ObjectInvocation_KeyWord:loadArgs: "put('-')" >staticOff:0 "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char" superAdj:0arg:"'-'"} 
 -- $pattern:loadArgs: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char" >E:"put('-')":descNo:105} 
 -- ptn:loadArgs:E "put('-')" 
 -- {(ObjectInvocation_KeyWord; (name: "put"); (Arguments;  (name: "put");  (name: "(");  (ObjectGenerator;   (Invocation;    (Char: '-'));   (Items descNo: 0 origDescNo: 0)); ...} 
 -- args: "put('-')" 
 -- E: "ObjectGenerator" '-' 
 -- E.arg: "val" in ch: val char 
 -- NonVirt: "put('-')" "ObjectInvocation_KeyWord" ActArg:  "'-'" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put('-')"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "'-'" >OGid:"char" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "'-'" 
 -- OG:before:super.gen: "'-'" 
 -- $Invocation:gen: "'-'" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "'-'" 
 -- isConstant: "Invocation" "'-'" 
 -- needorigin: "'-'" 
 -- needOrigin:E: "'-'"  E.ATd: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var ch ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;   ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "'-'" E:  "'-'" 
 -- INV:gen:E.loadArgs "'-'" 
 -- $Char::loadArgs: "'-'"  
 -- INV:gen:after:E.loadArgs "'-'" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "'-'" 
 -- $Char::invoke: "'-'"  
 pushc 45
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in ch: val char" :isBasicVal: true :valueObj: true 
 -- :actArg: "'-'" :isBasicVal: true 
 -- case:B: '-' ObjectGenerator 3 3 3 false true 
 -- end:loadArgs:NonVirt: "put('-')" 
 -- INV:gen:after:E.loadArgs "put('-')" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put('-')" 
 -- $ObjectInvocation_KeyWord:invoke: "put('-')" >rec:"put('-')" ATd:"pattern" E:"put('-')" E.ATd:"put" unique:"False" 
 -- OI:invoke: "put('-')" 
 -- 
 -- OI:invoke:B: "put('-')" E: "put('-')"  rec: "put('-')"  useRtnV: false "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- $pattern:invoke: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char" E: "put('-')" useRTNv: "False"} 
 -- ptn:invoke: "put" E: "put('-')" ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- OI:invoke:C: put('-') :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 210 
 -- Items:GenClass: repeat$210 descNo: 210 isValue: false 
 -- Items:GenClass: repeat$210 descNo: 21 isValue: false 

 CLASS repeat$210 210 1 for:to:repeat$213 213
 -- Store itemArgs: i: var integer{i := L + 1 - inx;put('0' + D.get[i])} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=210 vDescInx=210 vdtTop: 1 
 mvStack 
 -- $var:gen: "i: var integer"  
 -- DI:gen: "i: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  i 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "i := L + 1 - inx" 
 -- $Assign:gen: "i := L + 1 - inx"  
 -- assign: "i := L + 1 - inx" 
 -- computeAdr:superAdj: 0 "i" 
 -- computeAdr: 1 :rec: "none"  E: "i" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "i"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "i" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "i" >ATd.off:2:on:0:superAdj:0"i: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "i: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "i: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- computeAdr:isLast:E:  "i" 
 -- AssignmentStatement:gen: "i := L + 1 - inx" right.label: "ObjectGenerator" "L + 1 - inx" 
 -- $ObjectGenerator:gen: "L + 1 - inx" >OGid:"-" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L + 1 - inx" 
 -- OG:before:super.gen: "L + 1 - inx" 
 -- $Invocation:gen: "L + 1 - inx" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L + 1 - inx" 
 -- isConstant: "Invocation" "L + 1 - inx" 
 -- needorigin: "L + 1 - inx" 
 -- needOrigin:E: "L + 1 - inx"  E.ATd: "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- doNeedOrigin:Ex: "L + 1 - inx" 
 -- computeAdr:superAdj: 0 "L + 1 - inx" 
 -- computeAdr: 1 :rec: "none"  E: "L + 1 - inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "L + 1 - inx"  
 -- $BinOp:loadOrigin: "L + 1 - inx"  
 -- BinaryExp:loadOrigin:empty: "L + 1 - inx" superAdj: 0 
 -- $BinOp:getAdr: "L + 1 - inx"  
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "L + 1 - inx" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "L + 1 - inx" E:  "L + 1 - inx" 
 -- INV:gen:E.loadArgs "L + 1 - inx" 
 -- $BinOp:loadArgs: "L + 1 - inx"  
 -- BinaryExp:loadArgs: "L + 1 - inx" superAdj: 0 
 -- $BinOp:gen: "L + 1"  
 -- BinaryExp:gen: "L + 1" 
 -- $Invocation:gen: "L" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L" 
 -- isConstant: "Invocation" "L" 
 -- notConst: L L: var integer 
 -- needorigin: "L" 
 -- needOrigin:E: "L"  E.ATd: "L: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L" 
 -- computeAdr: 1 :rec: "none"  E: "L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$210" on: 2 isValueObj: false 
 -- origin: for:to:repeat$213 origin:isValueObj: false 
 rpushg repeat$210$210 1
 -- items:goOrigin:encOG: "for:to:repeat$213" on: 1 isValueObj: false 
 -- origin: putint origin:isValueObj: false 
 rpushg for:to:repeat$213$213 4
 -- $ObjectInvocation_Unary:getAdr: "L" >ATd.off:3:on:2:superAdj:0"L: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "L: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "L"  ATd: "L: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdr:isLast:E:  "L" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- rec:  "L" E:  "L" 
 -- INV:gen:E.loadArgs "L" 
 -- $ObjectInvocation_Unary:loadArgs: "L" >staticOff:0 "L: var integer" superAdj:0 
 -- $var:loadArgs: "L: var integer" >E:"L" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "L" 
 -- {(ObjectInvocation_Unary; (name: "L"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L" >rec:"L" ATd:"var" isValueObj E:"L" E.ATd:"L" unique:"False" 
 -- OI:invoke: "L" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "L" E: "L"  rec: "L"  useRtnV: true "L: var integer" 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- $var:invoke: "L: var integer" E: "L">newOff:3 useRTNv: "True" 
 -- DI:invoke: "L: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- isCompositeValueObj: false E: "L" "L: var integer" true 
 -- E.ATd.isValueObj: false rec: "L" 
 pushg 3 putint$207
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- OI:invoke:C: L :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- BinaryExp:gen:before:loadargs "L + 1" 
 -- A: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- $pattern:loadArgs: "+  : {   %basic 61;   in V: var integer;   out R: var integer" >E:"+ 1":descNo:49} 
 -- ptn:loadArgs:E "+ 1" 
 -- {(ObjectInvocation_Binary; (name: "+"); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 1));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "1" 
 -- E: "ObjectGenerator" 1 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "+ 1" "ObjectInvocation_Binary" ActArg:  "1" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ 1"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "1" :isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "+ 1" 
 -- $ObjectInvocation_Binary:invoke: "+ 1" >rec:"+ 1" ATd:"pattern" E:"+ 1" E.ATd:"+  " unique:"False" 
 -- OI:invoke: "+ 1" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:+ 1 
 -- origin:isValueObj "integer" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:+ 1 
 -- OI:invoke:B: "+ 1" E: "+ 1"  rec: "+ 1"  useRtnV: true "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- $pattern:invoke: "+  : {   %basic 61;   in V: var integer;   out R: var integer" E: "+ 1" useRTNv: "True"} 
 -- ptn:invoke: "+  " E: "+ 1" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "+ 1" E: "+ 1" 
 -- arg:integer 
 plus
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:+ 1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:+ 1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: + 1 :unit:  -none-  convFactor:  0.000000
 -- BinaryExp:gen:before:end "L + 1" 
 -- Madr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:+ 1 
 -- left:#I "L + 1 - inx" 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 -- $pattern:loadArgs: "-  : {   %basic 62;   in V: var integer;   out R: var integer" >E:"- inx":descNo:108} 
 -- ptn:loadArgs:E "- inx" 
 -- {(ObjectInvocation_Binary; (name: "-"); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "inx");     (Arguments)));   (Items descNo: 0  ...} 
 -- args: "inx" 
 -- E: "ObjectGenerator" inx 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "- inx" "ObjectInvocation_Binary" ActArg:  "inx" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "- inx"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "inx" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inx" 
 -- OG:before:super.gen: "inx" 
 -- $Invocation:gen: "inx" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "inx" 
 -- isConstant: "Invocation" "inx" 
 -- notConst: inx inx: var integer 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$210" on: 1 isValueObj: false 
 -- origin: for:to:repeat$213 origin:isValueObj: false 
 rpushg repeat$210$210 1
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:3:on:1:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- $ObjectInvocation_Unary:loadArgs: "inx" >staticOff:0 "inx: var integer" superAdj:0 
 -- $var:loadArgs: "inx: var integer" >E:"inx" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "inx" 
 -- {(ObjectInvocation_Unary; (name: "inx"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: "inx" >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:"inx" unique:"False" 
 -- OI:invoke: "inx" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx" E: "inx"  rec: "inx"  useRtnV: true "inx: var integer" 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: "inx: var integer" E: "inx">newOff:3 useRTNv: "True" 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- isCompositeValueObj: false E: "inx" "inx: var integer" true 
 -- E.ATd.isValueObj: false rec: "inx" 
 pushg 3 for:to:repeat$213$213
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:C: inx :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "inx" :isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "- inx" 
 -- BinaryExp:loadArgs:end: 
 -- INV:gen:after:E.loadArgs "L + 1 - inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L + 1 - inx" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:invoke: "L + 1 - inx"  
 -- BinaryExp:invoke: "L + 1" rec: "L + 1 - inx" 
 -- M: "- inx" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Binary:invoke: "- inx" >rec:"L + 1" ATd:"pattern" E:"- inx" E.ATd:"-  " unique:"False" 
 -- OI:invoke: "- inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:L + 1 
 -- origin:isValueObj "integer" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:L + 1 
 -- OI:invoke:B: "- inx" E: "- inx"  rec: "L + 1"  useRtnV: true "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern -   
 -- $pattern:invoke: "-  : {   %basic 62;   in V: var integer;   out R: var integer" E: "- inx" useRTNv: "True"} 
 -- ptn:invoke: "-  " E: "- inx" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "L + 1" E: "- inx" 
 -- arg:other 
 minus
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"- inx":rec:L + 1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"- inx":rec:L + 1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: - inx :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "i" dstE: "i" dstE.ATd: "i: var integer" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "L + 1 - inx" 
 -- isArgOfAssignI2IwithUniValArg "i := L + 1 - inx" arg: "L + 1 - inx" ObjectGenerator 
 -- arg.super.arg: "L + 1 - inx" BinOp 
 -- recx:BinaryExp:recx: "L + 1 - inx" 
 -- M: "- inx" label: "ObjectInvocation_Binary" M.ATd: "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- checkInt2IntWithUnitArg:rec: "L + 1" E: "- inx" 
 -- arg:other 
 -- M:arg: "inx" ObjectGenerator false 
 -- dstDI: "i: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg repeat$210$210 2
 -- assign:adr.store:B: 
 -- genclass:stmt: "put('0' + D.get[i])" 
 -- $ObjectGenerator:gen: "put('0' + D.get[i])" >OGid:"put" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "put('0' + D.get[i])" 
 -- OG:before:super.gen: "put('0' + D.get[i])" 
 -- $Invocation:gen: "put('0' + D.get[i])" >useRtnV:"False"superAdj: 0 descNo: 105 
 -- INV:gen: "put('0' + D.get[i])" 
 -- isConstant: "Invocation" "put('0' + D.get[i])" 
 -- needorigin: "put('0' + D.get[i])" 
 -- needOrigin:E: "put('0' + D.get[i])"  E.ATd: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- Ex:loadOrign:no:loadOrigin:  "-- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "put('0' + D.get[i])" E:  "put('0' + D.get[i])" 
 -- INV:gen:E.loadArgs "put('0' + D.get[i])" 
 -- $ObjectInvocation_KeyWord:loadArgs: "put('0' + D.get[i])" >staticOff:0 "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char" superAdj:0arg:"'0' + D.get[i] ..."} 
 -- $pattern:loadArgs: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char" >E:"put('0' + D.get[i])":descNo:105} 
 -- ptn:loadArgs:E "put('0' + D.get[i])" 
 -- {(ObjectInvocation_KeyWord; (name: "put"); (Arguments;  (name: "put");  (name: "(");  (ObjectGenerator;   (Invocation;    (BinOp:+;     (Invocation;      (Char: '0'));     ...} 
 -- args: "put('0' + D.get[i])" 
 -- E: "ObjectGenerator" '0' + D.get[i] 
 -- E.arg: "val" in ch: val char 
 -- NonVirt: "put('0' + D.get[i])" "ObjectInvocation_KeyWord" ActArg:  "'0' + D.get[i]" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put('0' + D.get[i])"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "'0' + D.get[i]" >OGid:"+" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "'0' + D.get[i]" 
 -- OG:before:super.gen: "'0' + D.get[i]" 
 -- $Invocation:gen: "'0' + D.get[i]" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "'0' + D.get[i]" 
 -- isConstant: "Invocation" "'0' + D.get[i]" 
 -- needorigin: "'0' + D.get[i]" 
 -- needOrigin:E: "'0' + D.get[i]"  E.ATd: "+  : {   %basic 61;   in V: var char;   out R: var char}" 
 -- doNeedOrigin:Ex: "'0' + D.get[i]" 
 -- computeAdr:superAdj: 0 "'0' + D.get[i]" 
 -- computeAdr: 1 :rec: "none"  E: "'0' + D.get[i]" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "'0' + D.get[i]"  
 -- $BinOp:loadOrigin: "'0' + D.get[i]"  
 -- BinaryExp:loadOrigin:empty: "'0' + D.get[i]" superAdj: 0 
 -- $BinOp:getAdr: "'0' + D.get[i]"  
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "'0' + D.get[i]" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "'0' + D.get[i]" E:  "'0' + D.get[i]" 
 -- INV:gen:E.loadArgs "'0' + D.get[i]" 
 -- $BinOp:loadArgs: "'0' + D.get[i]"  
 -- BinaryExp:loadArgs: "'0' + D.get[i]" superAdj: 0 
 -- $Invocation:gen: "'0'" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "'0'" 
 -- isConstant: "Invocation" "'0'" 
 -- needorigin: "'0'" 
 -- needOrigin:E: "'0'"  E.ATd: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var ch ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;   ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "'0'" E:  "'0'" 
 -- INV:gen:E.loadArgs "'0'" 
 -- $Char::loadArgs: "'0'"  
 -- INV:gen:after:E.loadArgs "'0'" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "'0'" 
 -- $Char::invoke: "'0'"  
 pushc 48
 -- INV:gen:end:off: 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 -- $pattern:loadArgs: "+  : {   %basic 61;   in V: var char;   out R: var char" >E:"+ D.get[i]":descNo:212} 
 -- ptn:loadArgs:E "+ D.get[i]" 
 -- {(ObjectInvocation_Binary; (name: "+"); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "D");     (Arguments));    (ObjectInvocation_K ...} 
 -- args: "D.get[i]" 
 -- E: "ObjectGenerator" D.get[i] 
 -- E.arg: "var" in V: var char 
 -- NonVirt: "+ D.get[i]" "ObjectInvocation_Binary" ActArg:  "D.get[i]" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ D.get[i]"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "D.get[i]" >OGid:"get" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "D.get[i]" 
 -- OG:before:super.gen: "D.get[i]" 
 -- $Invocation:gen: "D.get[i]" >useRtnV:"True"superAdj: 0 descNo: 211 
 -- INV:gen: "D.get[i]" 
 -- isConstant: "Invocation" "D.get[i]" 
 -- needorigin: "D.get[i]" 
 -- needOrigin:E: "get[i]"  E.ATd: "get[inx: var integer]: {   %basic 116;   out V: var integer}" 
 -- doNeedOrigin:Ex: "get[i]" 
 -- computeAdr:superAdj: 0 "D.get[i]" 
 -- computeAdr: 1 :rec: "none"  E: "D" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "D"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "D" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$210" on: 2 isValueObj: false 
 -- origin: for:to:repeat$213 origin:isValueObj: false 
 rpushg repeat$210$210 1
 -- items:goOrigin:encOG: "for:to:repeat$213" on: 1 isValueObj: false 
 -- origin: putint origin:isValueObj: false 
 rpushg for:to:repeat$213$213 4
 -- $ObjectInvocation_Unary:getAdr: "D" >ATd.off:2:on:2:superAdj:0"D: obj Indexed(20,#integer)":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIs ... 
 -- $obj:getAdr: "D: obj Indexed(20,#integer)" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique: ... 
 -- E.on: 2 
 -- beforeIsValueObj:E: "D"  ATd: "D: obj Indexed(20,#integer)" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "D"  E: "get[i]" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:getAdr: "get[i]" >ATd.off:0 (isPtn):on:0:superAdj:0"get[inx: var integer]: {   %basic 116;   out V: var integer":Adr:off:2 size:0 isFloat:F isUni ...} 
 -- $pattern:getAdr: "get[inx: var integer]: {   %basic 116;   out V: var integer" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[i]":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "D" >staticOff:0 "D: obj Indexed(20,#integer)" superAdj:0 
 -- $obj:loadArgs: "D: obj Indexed(20,#integer)" >E:"D" 
 -- $pattern:loadArgs: "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];  ..."} 
 -- ptn:loadArgs:E "D" 
 -- {(ObjectInvocation_Unary; (name: "D"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "D" >rec:"D" ATd:"obj" E:"get[i]" E.ATd:"get[inx: var integer]" unique:"False" 
 -- OI:invoke: "D" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[i]":rec:D 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[i]":rec:D 
 -- OI:invoke:B: "D" E: "get[i]"  rec: "D"  useRtnV: true "D: obj Indexed(20,#integer)" 
 -- OI:invoke:before:ATdx.invoke: obj D 
 -- $obj:invoke: "D: obj Indexed(20,#integer)" E: "get[i]">newOff:2 useRTNv: "True" 
 -- DI:invoke: "D: obj Indexed(20,#integer)" 
 -- >Object:unique: false 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[i]":rec:D 
 -- isCompositeValueObj: false E: "get[i]" "get[inx: var integer]: {   %basic 116;   out V: var integer}" false 
 -- E.ATd.isValueObj: false rec: "D" 
 rpushg repeat$210$210 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[i]":rec:D 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[i]":rec:D 
 -- 
 -- OI:invoke:C: D :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "D" E: "get[i]" 
 -- arg:other 
 -- computeAdr:isLast:E:  "get[i]" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[i]":rec:D 
 -- rec:  "D" E:  "get[i]" 
 -- INV:gen:E.loadArgs "get[i]" 
 -- $ObjectInvocation_KeyWord:loadArgs: "get[i]" >staticOff:0 "get[inx: var integer]: {   %basic 116;   out V: var integer" superAdj:0arg:"i"} 
 -- $pattern:loadArgs: "get[inx: var integer]: {   %basic 116;   out V: var integer" >E:"get[i]":descNo:211} 
 -- ptn:loadArgs:E "get[i]" 
 -- {(ObjectInvocation_KeyWord; (name: "get"); (Arguments;  (name: "get");  (name: "[");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "i");     (Ar ...} 
 -- args: "get[i]" 
 -- E: "ObjectGenerator" i 
 -- E.arg: "var" inx: var integer 
 -- NonVirt: "get[i]" "ObjectInvocation_KeyWord" ActArg:  "i" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[i]"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "i" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "i" 
 -- OG:before:super.gen: "i" 
 -- $Invocation:gen: "i" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "i" 
 -- isConstant: "Invocation" "i" 
 -- notConst: i i: var integer 
 -- needorigin: "i" 
 -- needOrigin:E: "i"  E.ATd: "i: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "i" 
 -- computeAdr: 1 :rec: "none"  E: "i" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "i"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "i" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "i" >ATd.off:2:on:0:superAdj:0"i: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "i: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "i: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- computeAdr:isLast:E:  "i" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- rec:  "i" E:  "i" 
 -- INV:gen:E.loadArgs "i" 
 -- $ObjectInvocation_Unary:loadArgs: "i" >staticOff:0 "i: var integer" superAdj:0 
 -- $var:loadArgs: "i: var integer" >E:"i" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "i" 
 -- {(ObjectInvocation_Unary; (name: "i"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "i" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "i" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- $ObjectInvocation_Unary:invoke: "i" >rec:"i" ATd:"var" isValueObj E:"i" E.ATd:"i" unique:"False" 
 -- OI:invoke: "i" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- OI:invoke:B: "i" E: "i"  rec: "i"  useRtnV: true "i: var integer" 
 -- OI:invoke:before:ATdx.invoke: var i 
 -- $var:invoke: "i: var integer" E: "i">newOff:2 useRTNv: "True" 
 -- DI:invoke: "i: var integer" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- isCompositeValueObj: false E: "i" "i: var integer" true 
 -- E.ATd.isValueObj: false rec: "i" 
 pushg 2 repeat$210$210
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 3 vTopMax: 3 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- 
 -- OI:invoke:C: i :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- formalArg:isPtn: "inx: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "i" :isBasicVal: true 
 -- case:B: i ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "get[i]" 
 -- INV:gen:after:E.loadArgs "get[i]" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[i]" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[i]":rec:D 
 -- $ObjectInvocation_KeyWord:invoke: "get[i]" >rec:"D" ATd:"pattern" E:"get[i]" E.ATd:"get[inx: var integer]" unique:"False" 
 -- OI:invoke: "get[i]" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[i]":rec:D 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[i]":rec:D 
 -- OI:invoke:B: "get[i]" E: "get[i]"  rec: "D"  useRtnV: true "get[inx: var integer]: {   %basic 116;   out V: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- $pattern:invoke: "get[inx: var integer]: {   %basic 116;   out V: var integer" E: "get[i]" useRTNv: "True"} 
 -- ptn:invoke: "get[inx: var integer]" E: "get[i]" ptnKind: 0 useRtnV: true 
 xpushg  inx 1 0 1
 -- stack: rpop : vTop: 3 vTopMax: 3 rTop: -4 rTopMax: 0 V: 0 R: 
 -- stack: vpop : vTop: 2 vTopMax: 3 rTop: -4 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 3 vTopMax: 3 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[i]":rec:D 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[i]":rec:D 
 -- 
 -- OI:invoke:C: get[i] :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[i]":rec:D 
 -- formalArg:isPtn: "in V: var char" :isBasicVal: true :valueObj: true 
 -- :actArg: "D.get[i]" :isBasicVal: true 
 -- case:B: D.get[i] ObjectGenerator 3 116 116 false false 
 -- end:loadArgs:NonVirt: "+ D.get[i]" 
 -- BinaryExp:loadArgs:end: 
 -- INV:gen:after:E.loadArgs "'0' + D.get[i]" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: BinOp "'0' + D.get[i]" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:invoke: "'0' + D.get[i]"  
 -- BinaryExp:invoke: "'0'" rec: "'0' + D.get[i]" 
 -- M: "+ D.get[i]" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Binary:invoke: "+ D.get[i]" >rec:"'0'" ATd:"pattern" E:"+ D.get[i]" E.ATd:"+  " unique:"False" 
 -- OI:invoke: "+ D.get[i]" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:'0' 
 -- origin:isValueObj "char" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:'0' 
 -- OI:invoke:B: "+ D.get[i]" E: "+ D.get[i]"  rec: "'0'"  useRtnV: true "+  : {   %basic 61;   in V: var char;   out R: var char}" 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- $pattern:invoke: "+  : {   %basic 61;   in V: var char;   out R: var char" E: "+ D.get[i]" useRTNv: "True"} 
 -- ptn:invoke: "+  " E: "+ D.get[i]" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "'0'" E: "+ D.get[i]" 
 -- arg:other 
 plus
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"+ D.get[i]":rec:'0' 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"+ D.get[i]":rec:'0' 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: + D.get[i] :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in ch: val char" :isBasicVal: true :valueObj: true 
 -- :actArg: "'0' + D.get[i]" :isBasicVal: true 
 -- case:B: '0' + D.get[i] ObjectGenerator 3 61 61 false false 
 -- end:loadArgs:NonVirt: "put('0' + D.get[i])" 
 -- INV:gen:after:E.loadArgs "put('0' + D.get[i])" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put('0' + D.get[i])" 
 -- $ObjectInvocation_KeyWord:invoke: "put('0' + D.get[i])" >rec:"put('0' + D.get[i])" ATd:"pattern" E:"put('0' + D.get[i])" E.ATd:"put" unique:"False" 
 -- OI:invoke: "put('0' + D.get[i])" 
 -- 
 -- OI:invoke:B: "put('0' + D.get[i])" E: "put('0' + D.get[i])"  rec: "put('0' + D.get[i])"  useRtnV: false "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val ch ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- $pattern:invoke: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char" E: "put('0' + D.get[i])" useRTNv: "False"} 
 -- ptn:invoke: "put" E: "put('0' + D.get[i])" ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- OI:invoke:C: put('0' + D.get[i]) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 213 
 -- Items:GenClass: for:to:repeat$213 descNo: 213 isValue: false 
 -- Items:GenClass: for:to:repeat$213 descNo: 28 isValue: false 
 -- Items:GenClass: for:to:repeat descNo: 21 isValue: false 

 CLASS for:to:repeat$213 213 4 putint 207
 -- vdtTableCopy: I:1:28 V:2:29
 -- Store itemArgs:  
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- push:super.origin: 
 -- handleSuperArgs:E: "for(1):to(L):repeat{   i: var integer;   i := L + 1 - inx;   put('0' + D.get[i]);}" theIS: "" 
 -- super.sig:none:superAdj: 4 
 -- $ObjectInvocation_KeyWord:loadArgs: "for(1):to(L):repeat{   i: var integer;   i := L + 1 - inx;   put('0' + D.get[i]);" >staticOff:0 "for(first: var integer):to(last: var  ..."} 
 -- $pattern:loadArgs: "for(first: var integer):to(last: var integer):repeat{repeat:< object}: {   %OSDvisibility skipInternal;   %globals inSub;   inx: var integer;   inx :=  ..."} 
 -- ptn:loadArgs:E "for(1):to(L):repeat{   i: var integer;   i := L + 1 - inx;   put('0' + D.get[i]);}" 
 -- {(ObjectInvocation_KeyWord; (name: "for:to:repeat"); (Arguments;  (name: "for");  (name: "(");  (ObjectGenerator;   (Invocation;    (ConstLiteral 1));   (Items descNo: 0 o ...} 
 -- args: "for(1):to(L):repeat{   i: var integer;   i := L + 1 - inx;   put('0' + D.get[i]);}" 
 -- E: "ObjectGenerator" 1 
 -- E: "ObjectGenerator" L 
 -- E: "ObjectGenerator" i: var integer{   i := L + 1 - inx;   put('0' + D.get[i])} 
 -- E.arg: "var" first: var integer 
 -- NonVirt: "for(1):to(L):repeat{   i: var integer;   i := L + 1 - inx;   put('0' + D.get[i]);}" "ObjectInvocation_KeyWord" ActArg:  "1" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "for(1):to(L):repeat{   i: var integer;   i := L + 1 - inx;   put('0' + D.get[i]);}"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=4 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 4 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 4 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "first: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "1" :isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "for(1):to(L):repeat{   i: var integer;   i := L + 1 - inx;   put('0' + D.get[i]);}" 
 -- E.arg: "var" last: var integer 
 -- NonVirt: "for(1):to(L):repeat{   i: var integer;   i := L + 1 - inx;   put('0' + D.get[i]);}" "ObjectInvocation_KeyWord" ActArg:  "L" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "for(1):to(L):repeat{   i: var integer;   i := L + 1 - inx;   put('0' + D.get[i]);}"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "L" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=4 
 -- OG:gen: "L" 
 -- OG:before:super.gen: "L" 
 -- $Invocation:gen: "L" >useRtnV:"True"superAdj: 4 
 -- INV:gen: "L" 
 -- isConstant: "Invocation" "L" 
 -- notConst: L L: var integer 
 -- needorigin: "L" 
 -- needOrigin:E: "L"  E.ATd: "L: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 4 "L" 
 -- computeAdr: 1 :rec: "none"  E: "L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L" >on:0 superAdj:4 isValueObj:"True" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 4 
 rpushg putint$207 4
 -- $ObjectInvocation_Unary:getAdr: "L" >ATd.off:3:on:0:superAdj:4"L: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "L: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdr:isLast:E:  "L" 
 -- IV:after:computeAdr:superAdj: 4 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- rec:  "L" E:  "L" 
 -- INV:gen:E.loadArgs "L" 
 -- $ObjectInvocation_Unary:loadArgs: "L" >staticOff:0 "L: var integer" superAdj:4 
 -- $var:loadArgs: "L: var integer" >E:"L" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "L" 
 -- {(ObjectInvocation_Unary; (name: "L"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L" >rec:"L" ATd:"var" isValueObj E:"L" E.ATd:"L" unique:"False" 
 -- OI:invoke: "L" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "L" E: "L"  rec: "L"  useRtnV: true "L: var integer" 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- $var:invoke: "L: var integer" E: "L">newOff:3 useRTNv: "True" 
 -- DI:invoke: "L: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- isCompositeValueObj: false E: "L" "L: var integer" true 
 -- E.ATd.isValueObj: false rec: "L" 
 pushg 3 putint$207
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- OI:invoke:C: L :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- formalArg:isPtn: "last: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "L" :isBasicVal: true 
 -- case:B: L ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "for(1):to(L):repeat{   i: var integer;   i := L + 1 - inx;   put('0' + D.get[i]);}" 
 -- args:  "repeat:< object" "i: var integer{   i := L + 1 - inx;   put('0' + D.get[i])}" for:to:repeat 
 -- hArgOrg:super: for:to:repeat 
 -- Store itemArgs:  
 -- last: var integer true 1 
 -- DI:store: "last" 
 pushThis 
 storeg integer$5 2
 -- first: var integer true 1 
 -- DI:store: "first" 
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- vdtAdd: inx=1 descInx=213 vDescInx=28 vdtTop: 2 
 -- $Property:gen: "%OSDvisibility skipInternal"  
 -- $Property:gen: "%globals inSub"  
 -- $var:gen: "inx: var integer"  
 -- DI:gen: "inx: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  inx 
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0
 -- Handle VB: "" E: "for(1):to(L):repeat{   i: var integer;   i := L + 1 - inx;   put('0' + D.get[i]);}" 
 -- vdtAdd: inx=2 descInx=213 vDescInx=210 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 202 
 -- Items:GenClass: fac descNo: 202 isValue: false 
 -- Items:GenClass: fac descNo: 21 isValue: false 

 CLASS fac 202 1 P1 191
 -- Store itemArgs: out res: var integer{if (V = 1) :then ;   res := 1;:else ;   res := V * fac(V - 1)} 
 -- V: var integer true 1 
 -- DI:store: "V" 
 pushThis 
 storeg integer$5 2
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=202 vDescInx=202 vdtTop: 1 
 mvStack 
 -- $var:gen: "out res: var integer"  
 -- DI:gen: "out res: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  res 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "if (V = 1) :then {   res := 1;:else ;   res := V * fac(V - 1)}" 
 -- $ObjectGenerator:gen: "if (V = 1) :then {   res := 1;:else ;   res := V * fac(V - 1)" >OGid:"if:then$0" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "if (V = 1) :then {   res := 1;:else ;   res := V * fac(V - 1)}" 
 -- OG:before:super.gen: "if (V = 1) :then {   res := 1;:else ;   res := V * fac(V - 1)}" 
 -- $Invocation:gen: "if (V = 1) :then {   res := 1;:else ;   res := V * fac(V - 1)" >useRtnV:"False"superAdj: 0} 
 -- INV:gen: "if (V = 1) :then {   res := 1;:else ;   res := V * fac(V - 1)}" 
 -- isConstant: "Invocation" "if (V = 1) :then {   res := 1;:else ;   res := V * fac(V - 1)}" 
 -- needorigin: "if (V = 1) :then {   res := 1;:else ;   res := V * fac(V - 1)}" 
 -- needOrigin:E: "if (V = 1) :then {   res := 1;:else ;   res := V * fac(V - 1)}"  E.ATd: "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   % ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (V = 1) :then {   res := 1;:else ;   res := V * fac(V - 1)}" E:  "if (V = 1) :then {   res := 1;:else ;   res := V * fac(V - 1)}" 
 -- INV:gen:E.loadArgs "if (V = 1) :then {   res := 1;:else ;   res := V * fac(V - 1)}" 
 -- $IfThenElse:loadArgs: "if (V = 1) :then {   res := 1;:else ;   res := V * fac(V - 1)" } 
 -- INV:gen:after:E.loadArgs "if (V = 1) :then {   res := 1;:else ;   res := V * fac(V - 1)}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThenElse "if (V = 1) :then {   res := 1;:else ;   res := V * fac(V - 1)}" 
 -- $IfThenElse:invoke: "if (V = 1) :then {   res := 1;:else ;   res := V * fac(V - 1)" } 
 -- $IfThenElse:gen: "if (V = 1) :then {   res := 1;:else ;   res := V * fac(V - 1)" } 
 -- $ObjectGenerator:gen: "(V = 1)" >OGid:"=" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(V = 1)" 
 -- OG:before:super.gen: "(V = 1)" 
 -- $Invocation:gen: "(V = 1)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(V = 1)" 
 -- isConstant: "Invocation" "(V = 1)" 
 -- needorigin: "(V = 1)" 
 -- needOrigin:E: "(V = 1)"  E.ATd: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- doNeedOrigin:Ex: "(V = 1)" 
 -- computeAdr:superAdj: 0 "(V = 1)" 
 -- computeAdr: 1 :rec: "none"  E: "(V = 1)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(V = 1)"  
 -- $BracketedExp:loadOrigin: "(V = 1)"  
 -- computeAdr:superAdj: 0 "V = 1" 
 -- computeAdr: 1 :rec: "none"  E: "V = 1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "V = 1"  
 -- $BinOp:loadOrigin: "V = 1"  
 -- BinaryExp:loadOrigin:empty: "V = 1" superAdj: 0 
 -- $BinOp:getAdr: "V = 1"  
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "V = 1" 
 -- BE:loadOrigin:E: V = 1 
 -- $BinOp:getAdr: "V = 1"  
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "V = 1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "V = 1" E:  "V = 1" 
 -- INV:gen:E.loadArgs "V = 1" 
 -- $BinOp:loadArgs: "V = 1"  
 -- BinaryExp:loadArgs: "V = 1" superAdj: 0 
 -- $Invocation:gen: "V" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "V" 
 -- isConstant: "Invocation" "V" 
 -- notConst: V V: var integer 
 -- needorigin: "V" 
 -- needOrigin:E: "V"  E.ATd: "V: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "V" 
 -- computeAdr: 1 :rec: "none"  E: "V" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "V"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "V" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "V" >ATd.off:2:on:0:superAdj:0"V: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "V: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "V: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- computeAdr:isLast:E:  "V" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- rec:  "V" E:  "V" 
 -- INV:gen:E.loadArgs "V" 
 -- $ObjectInvocation_Unary:loadArgs: "V" >staticOff:0 "V: var integer" superAdj:0 
 -- $var:loadArgs: "V: var integer" >E:"V" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "V" 
 -- {(ObjectInvocation_Unary; (name: "V"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "V" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "V" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- $ObjectInvocation_Unary:invoke: "V" >rec:"V" ATd:"var" isValueObj E:"V" E.ATd:"V" unique:"False" 
 -- OI:invoke: "V" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "V" E: "V"  rec: "V"  useRtnV: true "V: var integer" 
 -- OI:invoke:before:ATdx.invoke: var V 
 -- $var:invoke: "V: var integer" E: "V">newOff:2 useRTNv: "True" 
 -- DI:invoke: "V: var integer" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- isCompositeValueObj: false E: "V" "V: var integer" true 
 -- E.ATd.isValueObj: false rec: "V" 
 pushg 2 fac$202
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- 
 -- OI:invoke:C: V :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- left:#I "V = 1" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- $pattern:loadArgs: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )" >E:"= 1":descNo:11} 
 -- ptn:loadArgs:E "= 1" 
 -- {(ObjectInvocation_Binary; (name: "="); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 1));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "1" 
 -- E: "ObjectGenerator" 1 
 -- E.arg: "var" in Veq: var this(Value) 
 -- NonVirt: "= 1" "ObjectInvocation_Binary" ActArg:  "1" isValue:  true 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "= 1"  isCompositeValueObj: true 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- vEq: 
 -- end:loadArgs:NonVirt: "= 1" 
 -- BinaryExp:loadArgs:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- INV:gen:after:E.loadArgs "V = 1" 
 -- OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- IV:E.invoke:useRtnVal: true E: BinOp "V = 1" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- $BinOp:invoke: "V = 1"  
 -- BinaryExp:invoke: "V" rec: "V = 1" 
 -- M: "= 1" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- $ObjectInvocation_Binary:invoke: "= 1" >rec:"V" ATd:"pattern" E:"= 1" E.ATd:"=  " unique:"False" 
 -- OI:invoke: "= 1" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- origin:isValueObj "Value" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "= 1" E: "= 1"  rec: "V"  useRtnV: true "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OI:invoke:before:ATdx.invoke: pattern =   
 -- $pattern:invoke: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )" E: "= 1" useRTNv: "True"} 
 -- ptn:invoke: "=  " E: "= 1" ptnKind: 1 useRtnV: true 
 -- rec: "V" "Invocation" OGx.label: "ObjectGenerator" OGx: integer 
 -- rec.ATd: "V: var integer" 
 -- bobs: 1 OGx: integer 
 eq
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= 1":rec:V 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= 1":rec:V 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: = 1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: "res := 1" >OGid:"$203" singular! staticOff=0 descNo=203 superAdj=0 
 -- OG:gen: "res := 1" 
 pushThis 
 -- before objTmpStack:add:  203   "$203" 
 invoke $203 203 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L5
 L4:
 -- $ObjectGenerator:gen: "res := V * fac(V - 1)" >OGid:"$204" singular! staticOff=0 descNo=204 superAdj=0 
 -- OG:gen: "res := V * fac(V - 1)" 
 pushThis 
 -- before objTmpStack:add:  204   "$204" 
 invoke $204 204 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L5:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 -- pushReturn:  "fac" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 203 
 -- Items:GenClass: $203 descNo: 203 isValue: false 
 -- Items:GenClass: $203 descNo: 21 isValue: false 

 CLASS $203 203 1 fac 202
 -- Store itemArgs: res := 1 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=203 vDescInx=203 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "res := 1" 
 -- $Assign:gen: "res := 1"  
 -- assign: "res := 1" 
 -- computeAdr:superAdj: 0 "res" 
 -- computeAdr: 1 :rec: "none"  E: "res" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "res"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "res" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$203" on: 1 isValueObj: false 
 -- origin: fac origin:isValueObj: false 
 rpushg $203$203 1
 -- $ObjectInvocation_Unary:getAdr: "res" >ATd.off:3:on:1:superAdj:0"out res: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ... 
 -- $var:getAdr: "out res: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: integer 
 -- before:floatTest:  "out res: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "res"  ATd: "out res: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:- 
 -- computeAdr:isLast:E:  "res" 
 -- AssignmentStatement:gen: "res := 1" right.label: "ObjectGenerator" "1" 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "res" dstE: "res" dstE.ATd: "out res: var integer" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:- ... 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "1" 
 -- isArgOfAssignI2IwithUniValArg "res := 1" arg: "1" ObjectGenerator 
 -- arg.super.arg: "1" ConstLiteral 
 -- dstDI: "out res: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg fac$202 3
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 204 
 -- Items:GenClass: $204 descNo: 204 isValue: false 
 -- Items:GenClass: $204 descNo: 21 isValue: false 

 CLASS $204 204 1 fac 202
 -- Store itemArgs: res := V * fac(V - 1) 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=204 vDescInx=204 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "res := V * fac(V - 1)" 
 -- $Assign:gen: "res := V * fac(V - 1)"  
 -- assign: "res := V * fac(V - 1)" 
 -- computeAdr:superAdj: 0 "res" 
 -- computeAdr: 1 :rec: "none"  E: "res" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "res"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "res" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$204" on: 1 isValueObj: false 
 -- origin: fac origin:isValueObj: false 
 rpushg $204$204 1
 -- $ObjectInvocation_Unary:getAdr: "res" >ATd.off:3:on:1:superAdj:0"out res: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ... 
 -- $var:getAdr: "out res: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: integer 
 -- before:floatTest:  "out res: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "res"  ATd: "out res: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:- 
 -- computeAdr:isLast:E:  "res" 
 -- AssignmentStatement:gen: "res := V * fac(V - 1)" right.label: "ObjectGenerator" "V * fac(V - 1)" 
 -- $ObjectGenerator:gen: "V * fac(V - 1)" >OGid:"*" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "V * fac(V - 1)" 
 -- OG:before:super.gen: "V * fac(V - 1)" 
 -- $Invocation:gen: "V * fac(V - 1)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "V * fac(V - 1)" 
 -- isConstant: "Invocation" "V * fac(V - 1)" 
 -- needorigin: "V * fac(V - 1)" 
 -- needOrigin:E: "V * fac(V - 1)"  E.ATd: "*  : {   %basic 66;   in V: var integer;   out R: var integer}" 
 -- doNeedOrigin:Ex: "V * fac(V - 1)" 
 -- computeAdr:superAdj: 0 "V * fac(V - 1)" 
 -- computeAdr: 1 :rec: "none"  E: "V * fac(V - 1)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "V * fac(V - 1)"  
 -- $BinOp:loadOrigin: "V * fac(V - 1)"  
 -- BinaryExp:loadOrigin:empty: "V * fac(V - 1)" superAdj: 0 
 -- $BinOp:getAdr: "V * fac(V - 1)"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "V * fac(V - 1)"  ATd: "*  : {   %basic 66;   in V: var integer;   out R: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "V * fac(V - 1)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "V * fac(V - 1)" E:  "V * fac(V - 1)" 
 -- INV:gen:E.loadArgs "V * fac(V - 1)" 
 -- $BinOp:loadArgs: "V * fac(V - 1)"  
 -- BinaryExp:loadArgs: "V * fac(V - 1)" superAdj: 0 
 -- $Invocation:gen: "V" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "V" 
 -- isConstant: "Invocation" "V" 
 -- notConst: V V: var integer 
 -- needorigin: "V" 
 -- needOrigin:E: "V"  E.ATd: "V: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "V" 
 -- computeAdr: 1 :rec: "none"  E: "V" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "V"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "V" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$204" on: 1 isValueObj: false 
 -- origin: fac origin:isValueObj: false 
 rpushg $204$204 1
 -- $ObjectInvocation_Unary:getAdr: "V" >ATd.off:2:on:1:superAdj:0"V: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "V: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "V: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "V"  ATd: "V: var integer" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- computeAdr:isLast:E:  "V" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- rec:  "V" E:  "V" 
 -- INV:gen:E.loadArgs "V" 
 -- $ObjectInvocation_Unary:loadArgs: "V" >staticOff:0 "V: var integer" superAdj:0 
 -- $var:loadArgs: "V: var integer" >E:"V" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "V" 
 -- {(ObjectInvocation_Unary; (name: "V"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "V" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "V" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- $ObjectInvocation_Unary:invoke: "V" >rec:"V" ATd:"var" isValueObj E:"V" E.ATd:"V" unique:"False" 
 -- OI:invoke: "V" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "V" E: "V"  rec: "V"  useRtnV: true "V: var integer" 
 -- OI:invoke:before:ATdx.invoke: var V 
 -- $var:invoke: "V: var integer" E: "V">newOff:2 useRTNv: "True" 
 -- DI:invoke: "V: var integer" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- isCompositeValueObj: false E: "V" "V: var integer" true 
 -- E.ATd.isValueObj: false rec: "V" 
 pushg 2 fac$202
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- 
 -- OI:invoke:C: V :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- left:#I "V * fac(V - 1)" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- $pattern:loadArgs: "*  : {   %basic 66;   in V: var integer;   out R: var integer" >E:"* fac(V - 1)":descNo:205} 
 -- ptn:loadArgs:E "* fac(V - 1)" 
 -- {(ObjectInvocation_Binary; (name: "*"); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_KeyWord;     (name: "fac");     (Arguments;      (name: "fac");  ...} 
 -- args: "fac(V - 1)" 
 -- E: "ObjectGenerator" fac(V - 1) 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "* fac(V - 1)" "ObjectInvocation_Binary" ActArg:  "fac(V - 1)" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "* fac(V - 1)"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "fac(V - 1)" >OGid:"fac" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "fac(V - 1)" 
 -- OG:before:super.gen: "fac(V - 1)" 
 -- $Invocation:gen: "fac(V - 1)" >useRtnV:"True"superAdj: 0 descNo: 202 
 -- INV:gen: "fac(V - 1)" 
 -- isConstant: "Invocation" "fac(V - 1)" 
 -- needorigin: "fac(V - 1)" 
 -- needOrigin:E: "fac(V - 1)"  E.ATd: "fac(V: var integer): {   out res: var integer;   if (V = 1) :then ;      res := 1;   :else ;      res := V * fac(V - 1)}" 
 -- doNeedOrigin:Ex: "fac(V - 1)" 
 -- computeAdr:superAdj: 0 "fac(V - 1)" 
 -- computeAdr: 1 :rec: "none"  E: "fac(V - 1)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "fac(V - 1)"  
 pushThis 
 -- $ObjectInvocation_KeyWord:loadOrigin: "fac(V - 1)" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$204" on: 2 isValueObj: false 
 -- origin: fac origin:isValueObj: false 
 rpushg $204$204 1
 -- items:goOrigin:encOG: "fac" on: 1 isValueObj: false 
 -- origin: P1 origin:isValueObj: false 
 rpushg fac$202 1
 -- $ObjectInvocation_KeyWord:getAdr: "fac(V - 1)" >ATd.off:0 (isPtn):on:2:superAdj:0"fac(V: var integer): {   out res: var integer;   if (V = 1) :then ;      res := 1;   :els ..."} 
 -- $pattern:getAdr: "fac(V: var integer): {   out res: var integer;   if (V = 1) :then ;      res := 1;   :else ;      res := V * fac(V - 1)" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fac(V - 1)":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "fac(V - 1)"  ATd: "fac(V: var integer): {   out res: var integer;   if (V = 1) :then ;      res := 1;   :else ;      res := V * fac(V - 1)}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fac(V - 1)":rec:- 
 -- computeAdr:isLast:E:  "fac(V - 1)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fac(V - 1)":rec:- 
 -- rec:  "fac(V - 1)" E:  "fac(V - 1)" 
 -- INV:gen:E.loadArgs "fac(V - 1)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "fac(V - 1)" >staticOff:0 "fac(V: var integer): {   out res: var integer;   if (V = 1) :then ;      res := 1;   :else ;      res := V * ..."} 
 -- $pattern:loadArgs: "fac(V: var integer): {   out res: var integer;   if (V = 1) :then ;      res := 1;   :else ;      res := V * fac(V - 1)" >E:"fac(V - 1)":descNo:202} 
 -- ptn:loadArgs:E "fac(V - 1)" 
 -- {(ObjectInvocation_KeyWord; (name: "fac"); (Arguments;  (name: "fac");  (name: "(");  (ObjectGenerator;   (Invocation;    (BinOp:-;     (Invocation;      (ObjectInvocation ...} 
 -- args: "fac(V - 1)" 
 -- E: "ObjectGenerator" V - 1 
 -- E.arg: "var" V: var integer 
 -- NonVirt: "fac(V - 1)" "ObjectInvocation_KeyWord" ActArg:  "V - 1" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "fac(V - 1)"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "V - 1" >OGid:"-" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "V - 1" 
 -- OG:before:super.gen: "V - 1" 
 -- $Invocation:gen: "V - 1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "V - 1" 
 -- isConstant: "Invocation" "V - 1" 
 -- needorigin: "V - 1" 
 -- needOrigin:E: "V - 1"  E.ATd: "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- doNeedOrigin:Ex: "V - 1" 
 -- computeAdr:superAdj: 0 "V - 1" 
 -- computeAdr: 1 :rec: "none"  E: "V - 1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "V - 1"  
 -- $BinOp:loadOrigin: "V - 1"  
 -- BinaryExp:loadOrigin:empty: "V - 1" superAdj: 0 
 -- $BinOp:getAdr: "V - 1"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "V - 1"  ATd: "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "V - 1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "V - 1" E:  "V - 1" 
 -- INV:gen:E.loadArgs "V - 1" 
 -- $BinOp:loadArgs: "V - 1"  
 -- BinaryExp:loadArgs: "V - 1" superAdj: 0 
 -- $Invocation:gen: "V" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "V" 
 -- isConstant: "Invocation" "V" 
 -- notConst: V V: var integer 
 -- needorigin: "V" 
 -- needOrigin:E: "V"  E.ATd: "V: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "V" 
 -- computeAdr: 1 :rec: "none"  E: "V" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "V"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "V" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$204" on: 1 isValueObj: false 
 -- origin: fac origin:isValueObj: false 
 rpushg $204$204 1
 -- $ObjectInvocation_Unary:getAdr: "V" >ATd.off:2:on:1:superAdj:0"V: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "V: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "V: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "V"  ATd: "V: var integer" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- computeAdr:isLast:E:  "V" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- rec:  "V" E:  "V" 
 -- INV:gen:E.loadArgs "V" 
 -- $ObjectInvocation_Unary:loadArgs: "V" >staticOff:0 "V: var integer" superAdj:0 
 -- $var:loadArgs: "V: var integer" >E:"V" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "V" 
 -- {(ObjectInvocation_Unary; (name: "V"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "V" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "V" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- $ObjectInvocation_Unary:invoke: "V" >rec:"V" ATd:"var" isValueObj E:"V" E.ATd:"V" unique:"False" 
 -- OI:invoke: "V" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "V" E: "V"  rec: "V"  useRtnV: true "V: var integer" 
 -- OI:invoke:before:ATdx.invoke: var V 
 -- $var:invoke: "V: var integer" E: "V">newOff:2 useRTNv: "True" 
 -- DI:invoke: "V: var integer" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- isCompositeValueObj: false E: "V" "V: var integer" true 
 -- E.ATd.isValueObj: false rec: "V" 
 pushg 2 fac$202
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- 
 -- OI:invoke:C: V :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- left:#I "V - 1" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- $pattern:loadArgs: "-  : {   %basic 62;   in V: var integer;   out R: var integer" >E:"- 1":descNo:108} 
 -- ptn:loadArgs:E "- 1" 
 -- {(ObjectInvocation_Binary; (name: "-"); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 1));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "1" 
 -- E: "ObjectGenerator" 1 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "- 1" "ObjectInvocation_Binary" ActArg:  "1" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "- 1"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "1" :isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "- 1" 
 -- BinaryExp:loadArgs:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- INV:gen:after:E.loadArgs "V - 1" 
 -- OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- IV:E.invoke:useRtnVal: true E: BinOp "V - 1" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- $BinOp:invoke: "V - 1"  
 -- BinaryExp:invoke: "V" rec: "V - 1" 
 -- M: "- 1" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- $ObjectInvocation_Binary:invoke: "- 1" >rec:"V" ATd:"pattern" E:"- 1" E.ATd:"-  " unique:"False" 
 -- OI:invoke: "- 1" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- origin:isValueObj "integer" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "- 1" E: "- 1"  rec: "V"  useRtnV: true "-  : {   %basic 62;   in V: var integer;   out R: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern -   
 -- $pattern:invoke: "-  : {   %basic 62;   in V: var integer;   out R: var integer" E: "- 1" useRTNv: "True"} 
 -- ptn:invoke: "-  " E: "- 1" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "V" E: "- 1" 
 -- arg:integer 
 minus
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"- 1":rec:V 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"- 1":rec:V 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: - 1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "V - 1" :isBasicVal: true 
 -- case:B: V - 1 ObjectGenerator 1 62 62 false false 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "fac(V - 1)" 
 -- INV:gen:after:E.loadArgs "fac(V - 1)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "fac(V - 1)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fac(V - 1)" ... 
 -- $ObjectInvocation_KeyWord:invoke: "fac(V - 1)" >rec:"fac(V - 1)" ATd:"pattern" E:"fac(V - 1)" E.ATd:"fac(V: var integer)" unique:"False" 
 -- OI:invoke: "fac(V - 1)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fac(V - 1)":rec:fac(V - 1) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fac(V - 1)":rec:fac(V - 1) 
 -- OI:invoke:B: "fac(V - 1)" E: "fac(V - 1)"  rec: "fac(V - 1)"  useRtnV: true "fac(V: var integer): {   out res: var integer;   if (V = 1) :then ;      res := 1;   :else ;   ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern fac(V: var integer) 
 -- $pattern:invoke: "fac(V: var integer): {   out res: var integer;   if (V = 1) :then ;      res := 1;   :else ;      res := V * fac(V - 1)" E: "fac(V - 1)" useRTNv: "True"} 
 -- ptn:invoke: "fac(V: var integer)" E: "fac(V - 1)" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fac(V - 1)":rec:fac(V - 1) 
 invoke fac 202 0 0
 -- global:pushOut: res off: 3 
 pushg 3 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 3 vTopMax: 3 rTop: -3 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 3 
 -- GeneralPTN:invoke:after:callInvoke: 3 
 -- GeneralPTN:invoke:end: 3 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fac(V - 1)":rec:fac(V - 1) 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fac(V - 1)":rec:fac(V - 1) 
 -- adrx: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fac(V - 1)":rec:fac(V - 1) 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fac(V - 1)":rec:fac(V - 1) 
 -- adrx: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fac(V - 1)":rec:fac(V - 1) 
 -- OI:invoke:C: fac(V - 1) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"fac(V - 1)":rec:fac(V - 1) 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "fac(V - 1)" :isBasicVal: true 
 -- case:B: fac(V - 1) ObjectGenerator 1 0 0 false false 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "* fac(V - 1)" 
 -- BinaryExp:loadArgs:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- INV:gen:after:E.loadArgs "V * fac(V - 1)" 
 -- OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- IV:E.invoke:useRtnVal: true E: BinOp "V * fac(V - 1)" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- $BinOp:invoke: "V * fac(V - 1)"  
 -- BinaryExp:invoke: "V" rec: "V * fac(V - 1)" 
 -- M: "* fac(V - 1)" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- $ObjectInvocation_Binary:invoke: "* fac(V - 1)" >rec:"V" ATd:"pattern" E:"* fac(V - 1)" E.ATd:"*  " unique:"False" 
 -- OI:invoke: "* fac(V - 1)" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- origin:isValueObj "integer" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "* fac(V - 1)" E: "* fac(V - 1)"  rec: "V"  useRtnV: true "*  : {   %basic 66;   in V: var integer;   out R: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern *   
 -- $pattern:invoke: "*  : {   %basic 66;   in V: var integer;   out R: var integer" E: "* fac(V - 1)" useRTNv: "True"} 
 -- ptn:invoke: "*  " E: "* fac(V - 1)" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "V" E: "* fac(V - 1)" 
 -- arg:other 
 mult
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* fac(V - 1)":rec:V 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* fac(V - 1)":rec:V 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: * fac(V - 1) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "res" dstE: "res" dstE.ATd: "out res: var integer" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:- ... 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "V * fac(V - 1)" 
 -- isArgOfAssignI2IwithUniValArg "res := V * fac(V - 1)" arg: "V * fac(V - 1)" ObjectGenerator 
 -- arg.super.arg: "V * fac(V - 1)" BinOp 
 -- recx:BinaryExp:recx: "V * fac(V - 1)" 
 -- M: "* fac(V - 1)" label: "ObjectInvocation_Binary" M.ATd: "*  : {   %basic 66;   in V: var integer;   out R: var integer}" 
 -- checkInt2IntWithUnitArg:rec: "V" E: "* fac(V - 1)" 
 -- arg:other 
 -- M:arg: "fac(V - 1)" ObjectGenerator false 
 -- dstDI: "out res: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg fac$202 3
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 214 
 -- Items:GenClass: for:to:repeat$214 descNo: 214 isValue: false 
 -- Items:GenClass: for:to:repeat$214 descNo: 28 isValue: false 
 -- Items:GenClass: for:to:repeat descNo: 21 isValue: false 

 CLASS for:to:repeat$214 214 4 P1 191
 -- vdtTableCopy: I:1:28 V:2:29
 -- Store itemArgs:  
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- push:super.origin: 
 -- handleSuperArgs:E: "for(1):to(5):repeat{   myM.putItem("Fac: "):value(inx):res(fac(inx));}" theIS: "" 
 -- super.sig:none:superAdj: 4 
 -- $ObjectInvocation_KeyWord:loadArgs: "for(1):to(5):repeat{   myM.putItem("Fac: "):value(inx):res(fac(inx));" >staticOff:0 "for(first: var integer):to(last: var integer):rep ..."} 
 -- $pattern:loadArgs: "for(first: var integer):to(last: var integer):repeat{repeat:< object}: {   %OSDvisibility skipInternal;   %globals inSub;   inx: var integer;   inx :=  ..."} 
 -- ptn:loadArgs:E "for(1):to(5):repeat{   myM.putItem("Fac: "):value(inx):res(fac(inx));}" 
 -- {(ObjectInvocation_KeyWord; (name: "for:to:repeat"); (Arguments;  (name: "for");  (name: "(");  (ObjectGenerator;   (Invocation;    (ConstLiteral 1));   (Items descNo: 0 o ...} 
 -- args: "for(1):to(5):repeat{   myM.putItem("Fac: "):value(inx):res(fac(inx));}" 
 -- E: "ObjectGenerator" 1 
 -- E: "ObjectGenerator" 5 
 -- E: "ObjectGenerator" myM.putItem("Fac: "):value(inx):res(fac(inx)) 
 -- E.arg: "var" first: var integer 
 -- NonVirt: "for(1):to(5):repeat{   myM.putItem("Fac: "):value(inx):res(fac(inx));}" "ObjectInvocation_KeyWord" ActArg:  "1" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "for(1):to(5):repeat{   myM.putItem("Fac: "):value(inx):res(fac(inx));}"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=4 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 4 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 4 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "first: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "1" :isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "for(1):to(5):repeat{   myM.putItem("Fac: "):value(inx):res(fac(inx));}" 
 -- E.arg: "var" last: var integer 
 -- NonVirt: "for(1):to(5):repeat{   myM.putItem("Fac: "):value(inx):res(fac(inx));}" "ObjectInvocation_KeyWord" ActArg:  "5" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "for(1):to(5):repeat{   myM.putItem("Fac: "):value(inx):res(fac(inx));}"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "5" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=4 
 -- OG:gen: "5" 
 -- OG:before:super.gen: "5" 
 -- $Invocation:gen: "5" >useRtnV:"True"superAdj: 4 
 -- INV:gen: "5" 
 -- isConstant: "Invocation" "5" 
 -- needorigin: "5" 
 -- needOrigin:E: "5"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 4 
 -- rec:  "5" E:  "5" 
 -- INV:gen:E.loadArgs "5" 
 -- $ConstLiteral:loadArgs: "5"  
 -- INV:gen:after:E.loadArgs "5" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "5" 
 -- $ConstLiteral:invoke: "5"  
 pushc 5
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "last: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "5" :isBasicVal: true 
 -- case:B: 5 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "for(1):to(5):repeat{   myM.putItem("Fac: "):value(inx):res(fac(inx));}" 
 -- args:  "repeat:< object" "myM.putItem("Fac: "):value(inx):res(fac(inx))" for:to:repeat 
 -- hArgOrg:super: for:to:repeat 
 -- Store itemArgs:  
 -- last: var integer true 1 
 -- DI:store: "last" 
 pushThis 
 storeg integer$5 2
 -- first: var integer true 1 
 -- DI:store: "first" 
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- vdtAdd: inx=1 descInx=214 vDescInx=28 vdtTop: 2 
 -- $Property:gen: "%OSDvisibility skipInternal"  
 -- $Property:gen: "%globals inSub"  
 -- $var:gen: "inx: var integer"  
 -- DI:gen: "inx: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  inx 
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0
 -- Handle VB: "" E: "for(1):to(5):repeat{   myM.putItem("Fac: "):value(inx):res(fac(inx));}" 
 -- vdtAdd: inx=2 descInx=214 vDescInx=201 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 218 
 -- Items:GenClass: P2 descNo: 218 isValue: false 
 -- Items:GenClass: P2 descNo: 190 isValue: false 
 -- Items:GenClass: MonitorProcess descNo: 83 isValue: false 
 -- Items:GenClass: BasicProcess descNo: 82 isValue: false 
 -- Items:GenClass: GeneralProcess descNo: 21 isValue: false 

 CLASS P2 218 4 MonitorDemo 189
 -- vdtTableCopy: I:1:82 V:2:225 V:3:138 V:4:161 V:5:162 V:6:164 I:7:83 I:8:190 I:9:0
 -- vdtAdd: inx=9 descInx=218 vDescInx=218 vdtTop: 9 
 -- Store itemArgs: sum(V: var integer): {   out res: var integer;   for(1):to(10):repeat;      res := res + V;   ;myM.print("P2 resumed\n");for(1):to(6):repeat;   myM.putItem ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  4 origin
 -- super MonitorProcess
 -- push:super.origin: 
 -- computeAdr:superAdj: 4 "MonitorProcess("PP2")" 
 -- computeAdr: 1 :rec: "none"  E: "MonitorProcess("PP2")" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "MonitorProcess("PP2")"  
 pushThis 
 -- $ObjectInvocation_KeyWord:loadOrigin: "MonitorProcess("PP2")" >on:0 superAdj:4 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 4 
 rpushg MonitorDemo$189 4
 -- $ObjectInvocation_KeyWord:getAdr: "MonitorProcess("PP2")" >ATd.off:0 (isPtn):on:0:superAdj:4"MonitorProcess: BasicProcess{   %globals Monitor, MonitorProcess(""), immutabl ..."} 
 -- $pattern:getAdr: "MonitorProcess: BasicProcess{   %globals Monitor, MonitorProcess(""), immutable, console;   -- we need to find out how to restrict Process to have no;    ..."} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"MonitorProcess("PP2")":rec:- 
 -- E.on: 0 
 -- beforeIsValueObj:E: "MonitorProcess("PP2")"  ATd: "MonitorProcess: BasicProcess{   %globals Monitor, MonitorProcess(""), immutable, console;   -- we need to find out how t ...}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"MonitorProcess("PP2")":rec:- 
 -- computeAdr:isLast:E:  "MonitorProcess("PP2")" 
 -- genClass:after:pushAddress: "MonitorProcess("PP2")" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"MonitorProcess("PP2")":rec:- ... 
 -- handleSuperArgs:E: "MonitorProcess("PP2")" theIS: "sum(V: var integer): {   out res: var integer;   for(1):to(10):repeat;      res := res + V;   ;myM.print("P2 resumed\n") ...}" 
 -- super.sig:none:superAdj: 4 
 -- $ObjectInvocation_KeyWord:loadArgs: "MonitorProcess("PP2")" >staticOff:0 "MonitorProcess: BasicProcess{   %globals Monitor, MonitorProcess(""), immutable, console;   -- we ..."} 
 -- $pattern:loadArgs: "MonitorProcess: BasicProcess{   %globals Monitor, MonitorProcess(""), immutable, console;   -- we need to find out how to restrict Process to have no;  ..."} 
 -- ptn:loadArgs:E "MonitorProcess("PP2")" 
 -- {(ObjectInvocation_KeyWord; (name: "MonitorProcess"); (Arguments;  (name: "MonitorProcess");  (name: "(");  (ObjectGenerator;   (Invocation;    (String: PP2));   (Items de ...} 
 -- args: "MonitorProcess("PP2")" 
 -- E: "ObjectGenerator" "PP2" 
 -- E.arg: "var" id: var LIB.StringLib.String 
 -- NonVirt: "MonitorProcess("PP2")" "ObjectInvocation_KeyWord" ActArg:  ""PP2"" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "MonitorProcess("PP2")"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: ""PP2"" >OGid:"String" IS.isempty! staticOff=0 descNo=0 superAdj=4 
 -- OG:gen: ""PP2"" 
 -- OG:before:super.gen: ""PP2"" 
 -- $Invocation:gen: ""PP2"" >useRtnV:"True"superAdj: 4 
 -- INV:gen: ""PP2"" 
 -- isConstant: "Invocation" ""PP2"" 
 -- needorigin: ""PP2"" 
 -- needOrigin:E: ""PP2""  E.ATd: "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 4 
 -- rec:  ""PP2"" E:  ""PP2"" 
 -- INV:gen:E.loadArgs ""PP2"" 
 -- $String::loadArgs: ""PP2""  
 -- INV:gen:after:E.loadArgs ""PP2"" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: String: ""PP2"" 
 -- $String::invoke: ""PP2""  
 pushText "PP2"
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "id: var LIB.StringLib.String" :isBasicVal: false :valueObj: false 
 -- :actArg: ""PP2"" :isBasicVal: false 
 -- case:B: "PP2" ObjectGenerator 5 5 5 false false 
 -- end:loadArgs:NonVirt: "MonitorProcess("PP2")" 
 -- hArgOrg:super: MonitorProcess 
 -- Store itemArgs: sum(V: var integer): {   out res: var integer;   for(1):to(10):repeat;      res := res + V;   ;myM.print("P2 resumed\n");for(1):to(6):repeat;   myM.putItem ...} 
 -- Store:Origin: 0 
 rShiftUp  1
 tstOriginIsNone 
 rstore  4 origin
 -- super MonitorProcess
 -- push:super.origin: 
 -- computeAdr:superAdj: 4 "BasicProcess" 
 -- computeAdr: 1 :rec: "none"  E: "BasicProcess" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "BasicProcess"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "BasicProcess" >on:0 superAdj:4 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 4 
 rpushg MonitorSystem$188 4
 -- $ObjectInvocation_Unary:getAdr: "BasicProcess" >ATd.off:0 (isPtn):on:0:superAdj:4"BasicProcess: GeneralProcess{   mkActive::< ;      status := p_status.ACTIVE;      SQS.in ..."} 
 -- $pattern:getAdr: "BasicProcess: GeneralProcess{   mkActive::< ;      status := p_status.ACTIVE;      SQS.insert(this(BasicProcess));   %Public;   start::<  -- need id as a ..."} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"BasicProcess":rec:- 
 -- E.on: 0 
 -- beforeIsValueObj:E: "BasicProcess"  ATd: "BasicProcess: GeneralProcess{   mkActive::< ;      status := p_status.ACTIVE;      SQS.insert(this(BasicProcess));   %Public;   s ...}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"BasicProcess":rec:- 
 -- computeAdr:isLast:E:  "BasicProcess" 
 -- genClass:after:pushAddress: "BasicProcess" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"BasicProcess":rec:- 
 -- handleSuperArgs:E: "BasicProcess" theIS: "%globals Monitor, MonitorProcess(""), immutable, console{-- we need to find out how to restrict Process to have no;-- visible int ...}" 
 -- super.sig:not:none:superAdj: -4 
 -- $ObjectInvocation_Unary:loadArgs: "BasicProcess" >staticOff:0 "BasicProcess: GeneralProcess{   mkActive::< ;      status := p_status.ACTIVE;      SQS.insert(this(BasicProc ..."} 
 -- $pattern:loadArgs: "BasicProcess: GeneralProcess{   mkActive::< ;      status := p_status.ACTIVE;      SQS.insert(this(BasicProcess));   %Public;   start::<  -- need id as ..."} 
 -- ptn:loadArgs:E "BasicProcess" 
 -- {(ObjectInvocation_Unary; (name: "BasicProcess"); (Arguments))} 
 -- args: "" 
 rShiftDown  1
 -- hArgOrg:super: BasicProcess 
 -- Store itemArgs: sum(V: var integer): {   out res: var integer;   for(1):to(10):repeat;      res := res + V;   ;myM.print("P2 resumed\n");for(1):to(6):repeat;   myM.putItem ...} 
 -- Store:Origin: 0 
 rShiftUp  1
 tstOriginIsNone 
 rstore  4 origin
 -- super MonitorProcess
 -- push:super.origin: 
 -- computeAdr:superAdj: 4 "GeneralProcess" 
 -- computeAdr: 1 :rec: "none"  E: "GeneralProcess" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "GeneralProcess"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "GeneralProcess" >on:2 superAdj:4 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 4 
 rpushg BasicSystem$72 4
 -- items:goOrigin:encOG: "BasicSystem" on: 2 isValueObj: false 
 -- origin: BasicSystemLib origin:isValueObj: false 
 rpushg BasicSystem$72 1
 -- items:goOrigin:encOG: "BasicSystemLib" on: 1 isValueObj: false 
 -- origin: LIB origin:isValueObj: false 
 rpushg BasicSystemLib$38 1
 -- IV:viaIncl:on: 0 "BETA"  org: "%id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--Collectio ...}" 
 -- viaIncl:son:isFirst: true viaIncl<>none: false "BETA" 
 -- items:goOrigin:encOG: "LIB" on: 1 isValueObj: false 
 -- origin: BETAworld origin:isValueObj: false 
 rpushg LIB$33 1
 rpushg BETA 2
 -- $ObjectInvocation_Unary:getAdr: "GeneralProcess" >ATd.off:0 (isPtn):on:2:superAdj:4"GeneralProcess(id: var LIB.StringLib.String): {   start:< ;      inner(start);   mkActi ..."} 
 -- $pattern:getAdr: "GeneralProcess(id: var LIB.StringLib.String): {   start:< ;      inner(start);   mkActive:< ;      inner(mkActive);   addWaiting:< ;      inner(addWaitin ..."} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"GeneralProcess":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "GeneralProcess"  ATd: "GeneralProcess(id: var LIB.StringLib.String): {   start:< ;      inner(start);   mkActive:< ;      inner(mkActive);   addWaitin ...}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"GeneralProcess":rec:- 
 -- computeAdr:isLast:E:  "GeneralProcess" 
 -- genClass:after:pushAddress: "GeneralProcess" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"GeneralProcess":rec:- 
 -- handleSuperArgs:E: "GeneralProcess" theIS: "mkActive::< {   status := p_status.ACTIVE;   SQS.insert(this(BasicProcess));%Public;start::<  -- need id as argument;   status  ...}" 
 -- super.sig:not:none:superAdj: -4 
 -- $ObjectInvocation_Unary:loadArgs: "GeneralProcess" >staticOff:0 "GeneralProcess(id: var LIB.StringLib.String): {   start:< ;      inner(start);   mkActive:< ;      inner(m ..."} 
 -- $pattern:loadArgs: "GeneralProcess(id: var LIB.StringLib.String): {   start:< ;      inner(start);   mkActive:< ;      inner(mkActive);   addWaiting:< ;      inner(addWait ..."} 
 -- ptn:loadArgs:E "GeneralProcess" 
 -- {(ObjectInvocation_Unary; (name: "GeneralProcess"); (Arguments))} 
 -- args: "" 
 rShiftDown  1
 -- hArgOrg:super: GeneralProcess 
 -- Store itemArgs: sum(V: var integer): {   out res: var integer;   for(1):to(10):repeat;      res := res + V;   ;myM.print("P2 resumed\n");for(1):to(6):repeat;   myM.putItem ...} 
 -- id: var LIB.StringLib.String true 5 
 pushThis 
 rstoreg  id 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 1 V: R: 
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=218 vDescInx=82 vdtTop: 9 
 -- $pattern:gen: "start:< {   inner(start)" } 
 -- $pattern:gen: "mkActive:< {   inner(mkActive)" } 
 -- $pattern:gen: "addWaiting:< {   inner(addWaiting);   --put('R')" } 
 -- $pattern:gen: "dcrWaiting:< {   inner(dcrWaiting)" } 
 -- $pattern:gen: "display:< {   "\n---GP:---".print;   inner(display)" } 
 -- $var:gen: "status: var integer"  
 -- DI:gen: "status: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  status 
 -- $pattern:gen: "mkActive::< {   status := p_status.ACTIVE;   SQS.insert(this(BasicProcess))" } 
 -- $Property:gen: "%Public"  
 -- $pattern:gen: "start::<  -- need id as argument{   status := p_status.ACTIVE;   SQS.insert(this(BasicProcess));   inner(start)" } 
 -- $pattern:gen: "addWaiting::< {   --SQS.addWaitingstatus := P_status.WAITING" } 
 -- $pattern:gen: "dcrWaiting::< {   SQS.dcrWaiting" } 
 -- $pattern:gen: "display::< {   "\n---BP:---\n".print;   --(id + ":A:").print	 " } 
 -- $Property:gen: "%globals Monitor, MonitorProcess(""), immutable, console{-- we need to find out how to restrict Process to have no;-- visible interface. Perhaps rethink th ..."} 
 -- $Property:gen: "%public"  
 -- $pattern:gen: "start:: {   --P: ref Process;   --P := this(MonitorProcess);   --("starting: " + id + "\n").print;   --SQS.insert(P)" } 
 rtnAlloc 1
 toSuper 82
DO:
 mvStack 
 L1:
 -- genclass:stmt: "myM.print("P2 resumed\n")" 
 -- $ObjectGenerator:gen: "myM.print("P2 resumed\n")" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "myM.print("P2 resumed\n")" 
 -- OG:before:super.gen: "myM.print("P2 resumed\n")" 
 -- $Invocation:gen: "myM.print("P2 resumed\n")" >useRtnV:"False"superAdj: 0 descNo: 200 
 -- INV:gen: "myM.print("P2 resumed\n")" 
 -- isConstant: "Invocation" "myM.print("P2 resumed\n")" 
 -- needorigin: "myM.print("P2 resumed\n")" 
 -- needOrigin:E: "print("P2 resumed\n")"  E.ATd: "print(S: var String): entry{   S.print}" 
 -- doNeedOrigin:Ex: "print("P2 resumed\n")" 
 -- computeAdr:superAdj: 0 "myM.print("P2 resumed\n")" 
 -- computeAdr: 1 :rec: "none"  E: "myM" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "myM"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "myM" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "P2" on: 1 isValueObj: false 
 -- origin: MonitorDemo origin:isValueObj: false 
 rpushg P2$218 4
 -- $ObjectInvocation_Unary:getAdr: "myM" >ATd.off:13:on:1:superAdj:0"myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var in ..."} 
 -- $obj:getAdr: "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var integer): entry;      put(10);   ..."} 
 -- E.on: 1 
 -- beforeIsValueObj:E: "myM"  ATd: "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var integer): ent ...}" 
 -- computeAdr:isFirst: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "myM"  E: "print("P2 resumed\n")" 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:getAdr: "print("P2 resumed\n")" >ATd.off:0 (isPtn):on:0:superAdj:0"print(S: var String): entry{   S.print":Adr:off:13 size:0 isFloat:F isUnitVal: ...} 
 -- $pattern:getAdr: "print(S: var String): entry{   S.print" } 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print("P2 resumed\n")":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "myM" >staticOff:0 "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(r ..."} 
 -- $obj:loadArgs: "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var integer): entry;      put(10); ..."} 
 -- $ObjectInvocation_Unary:invoke: "myM" >rec:"myM" ATd:"obj" E:"print("P2 resumed\n")" E.ATd:"print(S: var String)" unique:"False" 
 -- OI:invoke: "myM" 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print("P2 resumed\n")":rec:myM 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print("P2 resumed\n")":rec:myM 
 -- OI:invoke:B: "myM" E: "print("P2 resumed\n")"  rec: "myM"  useRtnV: true "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V ...}" 
 -- OI:invoke:before:ATdx.invoke: obj myM 
 -- $obj:invoke: "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var integer): entry;      put(10);   ..."} 
 -- DI:invoke: "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var integer): entry;      put(10);     ...}" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print("P2 resumed\n")":rec:myM 
 rpushg P2$218 13
 -- OI:invoke:V: adr: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print("P2 resumed\n")":rec:myM 
 -- 
 -- OI:invoke:X: adr: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print("P2 resumed\n")":rec:myM 
 -- 
 -- OI:invoke:C: myM :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "myM" E: "print("P2 resumed\n")" 
 -- arg:other 
 -- computeAdr:isLast:E:  "print("P2 resumed\n")" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print("P2 resumed\n")":rec:myM 
 -- rec:  "myM" E:  "print("P2 resumed\n")" 
 -- INV:gen:E.loadArgs "print("P2 resumed\n")" 
 -- $ObjectInvocation_KeyWord:loadArgs: "print("P2 resumed\n")" >staticOff:0 "print(S: var String): entry{   S.print" superAdj:0arg:""P2 resumed\n""} 
 -- $pattern:loadArgs: "print(S: var String): entry{   S.print" >E:"print("P2 resumed\n")":descNo:200} 
 -- ptn:loadArgs:E "print("P2 resumed\n")" 
 -- {(ObjectInvocation_KeyWord; (name: "print"); (Arguments;  (name: "print");  (name: "(");  (ObjectGenerator;   (Invocation;    (String: P2 resumed\n));   (Items descNo: 0 o ...} 
 -- args: "print("P2 resumed\n")" 
 -- E: "ObjectGenerator" "P2 resumed\n" 
 -- E.arg: "var" S: var String 
 -- NonVirt: "print("P2 resumed\n")" "ObjectInvocation_KeyWord" ActArg:  ""P2 resumed\n"" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "print("P2 resumed\n")"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: ""P2 resumed\n"" >OGid:"String" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: ""P2 resumed\n"" 
 -- OG:before:super.gen: ""P2 resumed\n"" 
 -- $Invocation:gen: ""P2 resumed\n"" >useRtnV:"True"superAdj: 0 
 -- INV:gen: ""P2 resumed\n"" 
 -- isConstant: "Invocation" ""P2 resumed\n"" 
 -- needorigin: ""P2 resumed\n"" 
 -- needOrigin:E: ""P2 resumed\n""  E.ATd: "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  ""P2 resumed\n"" E:  ""P2 resumed\n"" 
 -- INV:gen:E.loadArgs ""P2 resumed\n"" 
 -- $String::loadArgs: ""P2 resumed\n""  
 -- INV:gen:after:E.loadArgs ""P2 resumed\n"" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: String: ""P2 resumed\n"" 
 -- $String::invoke: ""P2 resumed\n""  
 pushText "P2 resumed\n"
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "S: var String" :isBasicVal: false :valueObj: false 
 -- :actArg: ""P2 resumed\n"" :isBasicVal: false 
 -- case:B: "P2 resumed\n" ObjectGenerator 5 5 5 false false 
 -- end:loadArgs:NonVirt: "print("P2 resumed\n")" 
 -- INV:gen:after:E.loadArgs "print("P2 resumed\n")" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "print("P2 resumed\n")" :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $ObjectInvocation_KeyWord:invoke: "print("P2 resumed\n")" >rec:"myM" ATd:"pattern" E:"print("P2 resumed\n")" E.ATd:"print(S: var String)" unique:"False" 
 -- OI:invoke: "print("P2 resumed\n")" 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print("P2 resumed\n")":rec:myM 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print("P2 resumed\n")":rec:myM 
 -- OI:invoke:B: "print("P2 resumed\n")" E: "print("P2 resumed\n")"  rec: "myM"  useRtnV: false "print(S: var String): entry{   S.print}" 
 -- OI:invoke:before:ATdx.invoke: pattern print(S: var String) 
 -- $pattern:invoke: "print(S: var String): entry{   S.print" E: "print("P2 resumed\n")" useRTNv: "False"} 
 -- ptn:invoke: "print(S: var String)" E: "print("P2 resumed\n")" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print("P2 resumed\n")":rec:myM 
 invoke print 200 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 1 V: R: 
 -- OI:invoke:V: adr: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print("P2 resumed\n")":rec:myM 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print("P2 resumed\n")":rec:myM 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print("P2 resumed\n") :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 13 
 -- OG:gen:end: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print("P2 resumed\n")":rec:myM 
 -- genclass:stmt: "for(1):to(6):repeat{   myM.putItem("Sum: "):value(inx):res(sum(inx));}" 
 -- $ObjectGenerator:gen: "for(1):to(6):repeat{   myM.putItem("Sum: "):value(inx):res(sum(inx));" >OGid:"for:to:repeat$223" IS.isempty! staticOff=0 descNo=223 superAdj=0} 
 -- OG:gen: "for(1):to(6):repeat{   myM.putItem("Sum: "):value(inx):res(sum(inx));}" 
 pushThis 
 -- before objTmpStack:add:  223   "for:to:repeat$223" 
 invoke for:to:repeat$223 223 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 1 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 rtnInner  M
 END OSDV:0 objSize:4 isIndexed:0
 -- Handle VB: "sum(V: var integer): {   out res: var integer;   for(1):to(10):repeat;      res := res + V;   ;myM.print("P2 resumed\n");for(1):to(6):repeat;   myM.putItem("Su ..."}" E ... "M ..." 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 219 
 -- Items:GenClass: repeat$219 descNo: 219 isValue: false 
 -- Items:GenClass: repeat$219 descNo: 21 isValue: false 

 CLASS repeat$219 219 1 for:to:repeat$223 223
 -- Store itemArgs: myM.putItem("Sum: "):value(inx):res(sum(inx)) 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=219 vDescInx=219 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "myM.putItem("Sum: "):value(inx):res(sum(inx))" 
 -- $ObjectGenerator:gen: "myM.putItem("Sum: "):value(inx):res(sum(inx))" >OGid:"putItem:value:res" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "myM.putItem("Sum: "):value(inx):res(sum(inx))" 
 -- OG:before:super.gen: "myM.putItem("Sum: "):value(inx):res(sum(inx))" 
 -- $Invocation:gen: "myM.putItem("Sum: "):value(inx):res(sum(inx))" >useRtnV:"False"superAdj: 0 descNo: 206 
 -- INV:gen: "myM.putItem("Sum: "):value(inx):res(sum(inx))" 
 -- isConstant: "Invocation" "myM.putItem("Sum: "):value(inx):res(sum(inx))" 
 -- needorigin: "myM.putItem("Sum: "):value(inx):res(sum(inx))" 
 -- needOrigin:E: "putItem("Sum: "):value(inx):res(sum(inx))"  E.ATd: "putItem(msg: var String):value(V: var integer):res(res: var integer): entry{   put(10);   put('<');   ms ...}" 
 -- doNeedOrigin:Ex: "putItem("Sum: "):value(inx):res(sum(inx))" 
 -- computeAdr:superAdj: 0 "myM.putItem("Sum: "):value(inx):res(sum(inx))" 
 -- computeAdr: 1 :rec: "none"  E: "myM" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "myM"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "myM" >on:3 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$219" on: 3 isValueObj: false 
 -- origin: for:to:repeat$223 origin:isValueObj: false 
 rpushg repeat$219$219 1
 -- items:goOrigin:encOG: "for:to:repeat$223" on: 2 isValueObj: false 
 -- origin: P2 origin:isValueObj: false 
 rpushg for:to:repeat$223$223 4
 -- items:goOrigin:encOG: "P2" on: 1 isValueObj: false 
 -- origin: MonitorDemo origin:isValueObj: false 
 rpushg P2$218 4
 -- $ObjectInvocation_Unary:getAdr: "myM" >ATd.off:13:on:3:superAdj:0"myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var in ..."} 
 -- $obj:getAdr: "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var integer): entry;      put(10);   ..."} 
 -- E.on: 3 
 -- beforeIsValueObj:E: "myM"  ATd: "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var integer): ent ...}" 
 -- computeAdr:isFirst: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "myM"  E: "putItem("Sum: "):value(inx):res(sum(inx))" 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:getAdr: "putItem("Sum: "):value(inx):res(sum(inx))" >ATd.off:0 (isPtn):on:0:superAdj:0"putItem(msg: var String):value(V: var integer):res(res: va ..." 
 -- $pattern:getAdr: "putItem(msg: var String):value(V: var integer):res(res: var integer): entry{   put(10);   put('<');   msg.print;   putint(V);   " = ".print;   putint(res ..."} 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putItem("Sum: "):value(inx):res(sum(inx))":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "myM" >staticOff:0 "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(r ..."} 
 -- $obj:loadArgs: "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var integer): entry;      put(10); ..."} 
 -- $ObjectInvocation_Unary:invoke: "myM" >rec:"myM" ATd:"obj" E:"putItem("Sum: "):value(inx):res(sum(inx))" E.ATd:"putItem(msg: var String):value(V: var integer):res(res: var ..." 
 -- OI:invoke: "myM" 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putItem("Sum: "):value(inx):res(sum(inx))":rec:myM 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putItem("Sum: "):value(inx):res(sum(inx))":rec:myM 
 -- OI:invoke:B: "myM" E: "putItem("Sum: "):value(inx):res(sum(inx))"  rec: "myM"  useRtnV: true "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: ...}" 
 -- OI:invoke:before:ATdx.invoke: obj myM 
 -- $obj:invoke: "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var integer): entry;      put(10);   ..."} 
 -- DI:invoke: "myM: obj Monitor{   print(S: var String): entry;      S.print;   putItem(msg: var String):value(V: var integer):res(res: var integer): entry;      put(10);     ...}" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putItem("Sum: "):value(inx):res(sum(inx))":rec:myM 
 rpushg repeat$219$219 13
 -- OI:invoke:V: adr: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putItem("Sum: "):value(inx):res(sum(inx))":rec:myM 
 -- 
 -- OI:invoke:X: adr: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putItem("Sum: "):value(inx):res(sum(inx))":rec:myM 
 -- 
 -- OI:invoke:C: myM :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "myM" E: "putItem("Sum: "):value(inx):res(sum(inx))" 
 -- arg:other 
 -- computeAdr:isLast:E:  "putItem("Sum: "):value(inx):res(sum(inx))" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putItem("Sum: "):value(inx):res(sum(inx))":rec: ... 
 -- rec:  "myM" E:  "putItem("Sum: "):value(inx):res(sum(inx))" 
 -- INV:gen:E.loadArgs "putItem("Sum: "):value(inx):res(sum(inx))" 
 -- $ObjectInvocation_KeyWord:loadArgs: "putItem("Sum: "):value(inx):res(sum(inx))" >staticOff:0 "putItem(msg: var String):value(V: var integer):res(res: var integer): entry{  ..."} 
 -- $pattern:loadArgs: "putItem(msg: var String):value(V: var integer):res(res: var integer): entry{   put(10);   put('<');   msg.print;   putint(V);   " = ".print;   putint(r ..."} 
 -- ptn:loadArgs:E "putItem("Sum: "):value(inx):res(sum(inx))" 
 -- {(ObjectInvocation_KeyWord; (name: "putItem:value:res"); (Arguments;  (name: "putItem");  (name: "(");  (ObjectGenerator;   (Invocation;    (String: Sum: ));   (Items desc ...} 
 -- args: "putItem("Sum: "):value(inx):res(sum(inx))" 
 -- E: "ObjectGenerator" "Sum: " 
 -- E: "ObjectGenerator" inx 
 -- E: "ObjectGenerator" sum(inx) 
 -- E.arg: "var" msg: var String 
 -- NonVirt: "putItem("Sum: "):value(inx):res(sum(inx))" "ObjectInvocation_KeyWord" ActArg:  ""Sum: "" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "putItem("Sum: "):value(inx):res(sum(inx))"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: ""Sum: "" >OGid:"String" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: ""Sum: "" 
 -- OG:before:super.gen: ""Sum: "" 
 -- $Invocation:gen: ""Sum: "" >useRtnV:"True"superAdj: 0 
 -- INV:gen: ""Sum: "" 
 -- isConstant: "Invocation" ""Sum: "" 
 -- needorigin: ""Sum: "" 
 -- needOrigin:E: ""Sum: ""  E.ATd: "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := g ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  ""Sum: "" E:  ""Sum: "" 
 -- INV:gen:E.loadArgs ""Sum: "" 
 -- $String::loadArgs: ""Sum: ""  
 -- INV:gen:after:E.loadArgs ""Sum: "" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: String: ""Sum: "" 
 -- $String::invoke: ""Sum: ""  
 pushText "Sum: "
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "msg: var String" :isBasicVal: false :valueObj: false 
 -- :actArg: ""Sum: "" :isBasicVal: false 
 -- case:B: "Sum: " ObjectGenerator 5 5 5 false false 
 -- end:loadArgs:NonVirt: "putItem("Sum: "):value(inx):res(sum(inx))" 
 -- E.arg: "var" V: var integer 
 -- NonVirt: "putItem("Sum: "):value(inx):res(sum(inx))" "ObjectInvocation_KeyWord" ActArg:  "inx" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "putItem("Sum: "):value(inx):res(sum(inx))"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "inx" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inx" 
 -- OG:before:super.gen: "inx" 
 -- $Invocation:gen: "inx" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "inx" 
 -- isConstant: "Invocation" "inx" 
 -- notConst: inx inx: var integer 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$219" on: 1 isValueObj: false 
 -- origin: for:to:repeat$223 origin:isValueObj: false 
 rpushg repeat$219$219 1
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:3:on:1:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- $ObjectInvocation_Unary:loadArgs: "inx" >staticOff:0 "inx: var integer" superAdj:0 
 -- $var:loadArgs: "inx: var integer" >E:"inx" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "inx" 
 -- {(ObjectInvocation_Unary; (name: "inx"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: "inx" >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:"inx" unique:"False" 
 -- OI:invoke: "inx" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx" E: "inx"  rec: "inx"  useRtnV: true "inx: var integer" 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: "inx: var integer" E: "inx">newOff:3 useRTNv: "True" 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- isCompositeValueObj: false E: "inx" "inx: var integer" true 
 -- E.ATd.isValueObj: false rec: "inx" 
 pushg 3 for:to:repeat$223$223
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: 0 rTopMax: 1 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:C: inx :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- formalArg:isPtn: "V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "inx" :isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "putItem("Sum: "):value(inx):res(sum(inx))" 
 -- E.arg: "var" res: var integer 
 -- NonVirt: "putItem("Sum: "):value(inx):res(sum(inx))" "ObjectInvocation_KeyWord" ActArg:  "sum(inx)" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "putItem("Sum: "):value(inx):res(sum(inx))"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "sum(inx)" >OGid:"sum" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "sum(inx)" 
 -- OG:before:super.gen: "sum(inx)" 
 -- $Invocation:gen: "sum(inx)" >useRtnV:"True"superAdj: 0 descNo: 220 
 -- INV:gen: "sum(inx)" 
 -- isConstant: "Invocation" "sum(inx)" 
 -- needorigin: "sum(inx)" 
 -- needOrigin:E: "sum(inx)"  E.ATd: "sum(V: var integer): {   out res: var integer;   for(1):to(10):repeat;      res := res + V;   }" 
 -- doNeedOrigin:Ex: "sum(inx)" 
 -- computeAdr:superAdj: 0 "sum(inx)" 
 -- computeAdr: 1 :rec: "none"  E: "sum(inx)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "sum(inx)"  
 pushThis 
 -- $ObjectInvocation_KeyWord:loadOrigin: "sum(inx)" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$219" on: 2 isValueObj: false 
 -- origin: for:to:repeat$223 origin:isValueObj: false 
 rpushg repeat$219$219 1
 -- items:goOrigin:encOG: "for:to:repeat$223" on: 1 isValueObj: false 
 -- origin: P2 origin:isValueObj: false 
 rpushg for:to:repeat$223$223 4
 -- $ObjectInvocation_KeyWord:getAdr: "sum(inx)" >ATd.off:0 (isPtn):on:2:superAdj:0"sum(V: var integer): {   out res: var integer;   for(1):to(10):repeat;      res := res + V; ..."} 
 -- $pattern:getAdr: "sum(V: var integer): {   out res: var integer;   for(1):to(10):repeat;      res := res + V;   " } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sum(inx)":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "sum(inx)"  ATd: "sum(V: var integer): {   out res: var integer;   for(1):to(10):repeat;      res := res + V;   }" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sum(inx)":rec:- 
 -- computeAdr:isLast:E:  "sum(inx)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sum(inx)":rec:- 
 -- rec:  "sum(inx)" E:  "sum(inx)" 
 -- INV:gen:E.loadArgs "sum(inx)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "sum(inx)" >staticOff:0 "sum(V: var integer): {   out res: var integer;   for(1):to(10):repeat;      res := res + V;   " superAdj:0arg: ...} 
 -- $pattern:loadArgs: "sum(V: var integer): {   out res: var integer;   for(1):to(10):repeat;      res := res + V;   " >E:"sum(inx)":descNo:220} 
 -- ptn:loadArgs:E "sum(inx)" 
 -- {(ObjectInvocation_KeyWord; (name: "sum"); (Arguments;  (name: "sum");  (name: "(");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "inx");     ( ...} 
 -- args: "sum(inx)" 
 -- E: "ObjectGenerator" inx 
 -- E.arg: "var" V: var integer 
 -- NonVirt: "sum(inx)" "ObjectInvocation_KeyWord" ActArg:  "inx" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "sum(inx)"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "inx" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inx" 
 -- OG:before:super.gen: "inx" 
 -- $Invocation:gen: "inx" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "inx" 
 -- isConstant: "Invocation" "inx" 
 -- notConst: inx inx: var integer 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$219" on: 1 isValueObj: false 
 -- origin: for:to:repeat$223 origin:isValueObj: false 
 rpushg repeat$219$219 1
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:3:on:1:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- $ObjectInvocation_Unary:loadArgs: "inx" >staticOff:0 "inx: var integer" superAdj:0 
 -- $var:loadArgs: "inx: var integer" >E:"inx" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "inx" 
 -- {(ObjectInvocation_Unary; (name: "inx"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: "inx" >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:"inx" unique:"False" 
 -- OI:invoke: "inx" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx" E: "inx"  rec: "inx"  useRtnV: true "inx: var integer" 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: "inx: var integer" E: "inx">newOff:3 useRTNv: "True" 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- isCompositeValueObj: false E: "inx" "inx: var integer" true 
 -- E.ATd.isValueObj: false rec: "inx" 
 pushg 3 for:to:repeat$223$223
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 1 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -1 rTopMax: 1 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:C: inx :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- formalArg:isPtn: "V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "inx" :isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "sum(inx)" 
 -- INV:gen:after:E.loadArgs "sum(inx)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "sum(inx)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sum(inx)":rec ... 
 -- $ObjectInvocation_KeyWord:invoke: "sum(inx)" >rec:"sum(inx)" ATd:"pattern" E:"sum(inx)" E.ATd:"sum(V: var integer)" unique:"False" 
 -- OI:invoke: "sum(inx)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sum(inx)":rec:sum(inx) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sum(inx)":rec:sum(inx) 
 -- OI:invoke:B: "sum(inx)" E: "sum(inx)"  rec: "sum(inx)"  useRtnV: true "sum(V: var integer): {   out res: var integer;   for(1):to(10):repeat;      res := res + V;   }" 
 -- OI:invoke:before:ATdx.invoke: pattern sum(V: var integer) 
 -- $pattern:invoke: "sum(V: var integer): {   out res: var integer;   for(1):to(10):repeat;      res := res + V;   " E: "sum(inx)" useRTNv: "True"} 
 -- ptn:invoke: "sum(V: var integer)" E: "sum(inx)" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sum(inx)":rec:sum(inx) 
 invoke sum 220 0 0
 -- global:pushOut: res off: 3 
 pushg 3 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 1 V: 0 R: 
 -- stack: vpush : vTop: 3 vTopMax: 3 rTop: -2 rTopMax: 1 V: 0 R: 
 -- callInvoke:after:pushOut: 3 
 -- GeneralPTN:invoke:after:callInvoke: 3 
 -- GeneralPTN:invoke:end: 3 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sum(inx)":rec:sum(inx) 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sum(inx)":rec:sum(inx) 
 -- adrx: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sum(inx)":rec:sum(inx) 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sum(inx)":rec:sum(inx) 
 -- adrx: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sum(inx)":rec:sum(inx) 
 -- OI:invoke:C: sum(inx) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"sum(inx)":rec:sum(inx) 
 -- formalArg:isPtn: "res: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "sum(inx)" :isBasicVal: true 
 -- case:B: sum(inx) ObjectGenerator 1 0 0 false false 
 -- end:loadArgs:NonVirt: "putItem("Sum: "):value(inx):res(sum(inx))" 
 -- INV:gen:after:E.loadArgs "putItem("Sum: "):value(inx):res(sum(inx))" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "putItem("Sum: "):value(inx):res(sum(inx))" :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue ... 
 -- $ObjectInvocation_KeyWord:invoke: "putItem("Sum: "):value(inx):res(sum(inx))" >rec:"myM" ATd:"pattern" E:"putItem("Sum: "):value(inx):res(sum(inx))" E.ATd:"putItem(msg: va ..." 
 -- OI:invoke: "putItem("Sum: "):value(inx):res(sum(inx))" 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putItem("Sum: "):value(inx):res(sum(inx))":rec:myM 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putItem("Sum: "):value(inx):res(sum(inx))":rec:myM 
 -- OI:invoke:B: "putItem("Sum: "):value(inx):res(sum(inx))" E: "putItem("Sum: "):value(inx):res(sum(inx))"  rec: "myM"  useRtnV: false "putItem(msg: var String):value(V: var  ..." 
 -- OI:invoke:before:ATdx.invoke: pattern putItem(msg: var String):value(V: var integer):res(res: var integer) 
 -- $pattern:invoke: "putItem(msg: var String):value(V: var integer):res(res: var integer): entry{   put(10);   put('<');   msg.print;   putint(V);   " = ".print;   putint(res ..."} 
 -- ptn:invoke: "putItem(msg: var String):value(V: var integer):res(res: var integer)" E: "putItem("Sum: "):value(inx):res(sum(inx))" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putItem("Sum: "):value(inx):res(sum(i ..." 
 invoke putItem:value:res 206 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 3 vTopMax: 3 rTop: -3 rTopMax: 1 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putItem("Sum: "):value(inx):res(sum(inx))":rec:myM 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putItem("Sum: "):value(inx):res(sum(inx))":rec:myM 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: putItem("Sum: "):value(inx):res(sum(inx)) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 13 
 -- OG:gen:end: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putItem("Sum: "):value(inx):res(sum(inx))":rec:myM 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 220 
 -- Items:GenClass: sum descNo: 220 isValue: false 
 -- Items:GenClass: sum descNo: 21 isValue: false 

 CLASS sum 220 1 P2 218
 -- Store itemArgs: out res: var integer{for(1):to(10):repeat;   res := res + V;} 
 -- V: var integer true 1 
 -- DI:store: "V" 
 pushThis 
 storeg integer$5 2
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=220 vDescInx=220 vdtTop: 1 
 mvStack 
 -- $var:gen: "out res: var integer"  
 -- DI:gen: "out res: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  res 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "for(1):to(10):repeat{   res := res + V;}" 
 -- $ObjectGenerator:gen: "for(1):to(10):repeat{   res := res + V;" >OGid:"for:to:repeat$222" IS.isempty! staticOff=0 descNo=222 superAdj=0} 
 -- OG:gen: "for(1):to(10):repeat{   res := res + V;}" 
 pushThis 
 -- before objTmpStack:add:  222   "for:to:repeat$222" 
 invoke for:to:repeat$222 222 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 -- pushReturn:  "sum" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 221 
 -- Items:GenClass: repeat$221 descNo: 221 isValue: false 
 -- Items:GenClass: repeat$221 descNo: 21 isValue: false 

 CLASS repeat$221 221 1 for:to:repeat$222 222
 -- Store itemArgs: res := res + V 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=221 vDescInx=221 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "res := res + V" 
 -- $Assign:gen: "res := res + V"  
 -- assign: "res := res + V" 
 -- computeAdr:superAdj: 0 "res" 
 -- computeAdr: 1 :rec: "none"  E: "res" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "res"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "res" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$221" on: 2 isValueObj: false 
 -- origin: for:to:repeat$222 origin:isValueObj: false 
 rpushg repeat$221$221 1
 -- items:goOrigin:encOG: "for:to:repeat$222" on: 1 isValueObj: false 
 -- origin: sum origin:isValueObj: false 
 rpushg for:to:repeat$222$222 4
 -- $ObjectInvocation_Unary:getAdr: "res" >ATd.off:3:on:2:superAdj:0"out res: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ... 
 -- $var:getAdr: "out res: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: integer 
 -- before:floatTest:  "out res: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "res"  ATd: "out res: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:- 
 -- computeAdr:isLast:E:  "res" 
 -- AssignmentStatement:gen: "res := res + V" right.label: "ObjectGenerator" "res + V" 
 -- $ObjectGenerator:gen: "res + V" >OGid:"+" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "res + V" 
 -- OG:before:super.gen: "res + V" 
 -- $Invocation:gen: "res + V" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "res + V" 
 -- isConstant: "Invocation" "res + V" 
 -- needorigin: "res + V" 
 -- needOrigin:E: "res + V"  E.ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- doNeedOrigin:Ex: "res + V" 
 -- computeAdr:superAdj: 0 "res + V" 
 -- computeAdr: 1 :rec: "none"  E: "res + V" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "res + V"  
 -- $BinOp:loadOrigin: "res + V"  
 -- BinaryExp:loadOrigin:empty: "res + V" superAdj: 0 
 -- $BinOp:getAdr: "res + V"  
 -- E.on: 2 
 -- beforeIsValueObj:E: "res + V"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "res + V" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "res + V" E:  "res + V" 
 -- INV:gen:E.loadArgs "res + V" 
 -- $BinOp:loadArgs: "res + V"  
 -- BinaryExp:loadArgs: "res + V" superAdj: 0 
 -- $Invocation:gen: "res" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "res" 
 -- isConstant: "Invocation" "res" 
 -- notConst: res out res: var integer 
 -- needorigin: "res" 
 -- needOrigin:E: "res"  E.ATd: "out res: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "res" 
 -- computeAdr: 1 :rec: "none"  E: "res" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "res"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "res" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$221" on: 2 isValueObj: false 
 -- origin: for:to:repeat$222 origin:isValueObj: false 
 rpushg repeat$221$221 1
 -- items:goOrigin:encOG: "for:to:repeat$222" on: 1 isValueObj: false 
 -- origin: sum origin:isValueObj: false 
 rpushg for:to:repeat$222$222 4
 -- $ObjectInvocation_Unary:getAdr: "res" >ATd.off:3:on:2:superAdj:0"out res: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ... 
 -- $var:getAdr: "out res: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: integer 
 -- before:floatTest:  "out res: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "res"  ATd: "out res: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:- 
 -- computeAdr:isLast:E:  "res" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:- 
 -- rec:  "res" E:  "res" 
 -- INV:gen:E.loadArgs "res" 
 -- $ObjectInvocation_Unary:loadArgs: "res" >staticOff:0 "out res: var integer" superAdj:0 
 -- $var:loadArgs: "out res: var integer" >E:"res" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "res" 
 -- {(ObjectInvocation_Unary; (name: "res"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "res" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "res" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:- 
 -- $ObjectInvocation_Unary:invoke: "res" >rec:"res" ATd:"var" isValueObj E:"res" E.ATd:"res" unique:"False" 
 -- OI:invoke: "res" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:res 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:res 
 -- OI:invoke:B: "res" E: "res"  rec: "res"  useRtnV: true "out res: var integer" 
 -- OI:invoke:before:ATdx.invoke: var res 
 -- $var:invoke: "out res: var integer" E: "res">newOff:3 useRTNv: "True" 
 -- DI:invoke: "out res: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:res 
 -- isCompositeValueObj: false E: "res" "out res: var integer" true 
 -- E.ATd.isValueObj: false rec: "res" 
 pushg 3 sum$220
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:res 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:res 
 -- 
 -- OI:invoke:C: res :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- left:#I "res + V" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:res 
 -- $pattern:loadArgs: "+  : {   %basic 61;   in V: var integer;   out R: var integer" >E:"+ V":descNo:49} 
 -- ptn:loadArgs:E "+ V" 
 -- {(ObjectInvocation_Binary; (name: "+"); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "V");     (Arguments)));   (Items descNo: 0 or ...} 
 -- args: "V" 
 -- E: "ObjectGenerator" V 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "+ V" "ObjectInvocation_Binary" ActArg:  "V" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ V"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "V" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "V" 
 -- OG:before:super.gen: "V" 
 -- $Invocation:gen: "V" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "V" 
 -- isConstant: "Invocation" "V" 
 -- notConst: V V: var integer 
 -- needorigin: "V" 
 -- needOrigin:E: "V"  E.ATd: "V: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "V" 
 -- computeAdr: 1 :rec: "none"  E: "V" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "V"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "V" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$221" on: 2 isValueObj: false 
 -- origin: for:to:repeat$222 origin:isValueObj: false 
 rpushg repeat$221$221 1
 -- items:goOrigin:encOG: "for:to:repeat$222" on: 1 isValueObj: false 
 -- origin: sum origin:isValueObj: false 
 rpushg for:to:repeat$222$222 4
 -- $ObjectInvocation_Unary:getAdr: "V" >ATd.off:2:on:2:superAdj:0"V: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "V: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "V: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "V"  ATd: "V: var integer" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- computeAdr:isLast:E:  "V" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- rec:  "V" E:  "V" 
 -- INV:gen:E.loadArgs "V" 
 -- $ObjectInvocation_Unary:loadArgs: "V" >staticOff:0 "V: var integer" superAdj:0 
 -- $var:loadArgs: "V: var integer" >E:"V" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "V" 
 -- {(ObjectInvocation_Unary; (name: "V"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "V" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "V" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- $ObjectInvocation_Unary:invoke: "V" >rec:"V" ATd:"var" isValueObj E:"V" E.ATd:"V" unique:"False" 
 -- OI:invoke: "V" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "V" E: "V"  rec: "V"  useRtnV: true "V: var integer" 
 -- OI:invoke:before:ATdx.invoke: var V 
 -- $var:invoke: "V: var integer" E: "V">newOff:2 useRTNv: "True" 
 -- DI:invoke: "V: var integer" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- isCompositeValueObj: false E: "V" "V: var integer" true 
 -- E.ATd.isValueObj: false rec: "V" 
 pushg 2 sum$220
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- 
 -- OI:invoke:C: V :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "V" :isBasicVal: true 
 -- case:B: V ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "+ V" 
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:res 
 -- INV:gen:after:E.loadArgs "res + V" 
 -- OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:res 
 -- IV:E.invoke:useRtnVal: true E: BinOp "res + V" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:res 
 -- $BinOp:invoke: "res + V"  
 -- BinaryExp:invoke: "res" rec: "res + V" 
 -- M: "+ V" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:res 
 -- $ObjectInvocation_Binary:invoke: "+ V" >rec:"res" ATd:"pattern" E:"+ V" E.ATd:"+  " unique:"False" 
 -- OI:invoke: "+ V" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:res 
 -- origin:isValueObj "integer" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:res 
 -- OI:invoke:B: "+ V" E: "+ V"  rec: "res"  useRtnV: true "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- $pattern:invoke: "+  : {   %basic 61;   in V: var integer;   out R: var integer" E: "+ V" useRTNv: "True"} 
 -- ptn:invoke: "+  " E: "+ V" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "res" E: "+ V" 
 -- arg:other 
 plus
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ V":rec:res 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ V":rec:res 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: + V :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "res" dstE: "res" dstE.ATd: "out res: var integer" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:- ... 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "res + V" 
 -- isArgOfAssignI2IwithUniValArg "res := res + V" arg: "res + V" ObjectGenerator 
 -- arg.super.arg: "res + V" BinOp 
 -- recx:BinaryExp:recx: "res + V" 
 -- M: "+ V" label: "ObjectInvocation_Binary" M.ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- checkInt2IntWithUnitArg:rec: "res" E: "+ V" 
 -- arg:other 
 -- M:arg: "V" ObjectGenerator false 
 -- dstDI: "out res: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"res":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg sum$220 3
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 222 
 -- Items:GenClass: for:to:repeat$222 descNo: 222 isValue: false 
 -- Items:GenClass: for:to:repeat$222 descNo: 28 isValue: false 
 -- Items:GenClass: for:to:repeat descNo: 21 isValue: false 

 CLASS for:to:repeat$222 222 4 sum 220
 -- vdtTableCopy: I:1:28 V:2:29
 -- Store itemArgs:  
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- push:super.origin: 
 -- handleSuperArgs:E: "for(1):to(10):repeat{   res := res + V;}" theIS: "" 
 -- super.sig:none:superAdj: 4 
 -- $ObjectInvocation_KeyWord:loadArgs: "for(1):to(10):repeat{   res := res + V;" >staticOff:0 "for(first: var integer):to(last: var integer):repeat{repeat:< object}: ;   %OSD ..."} 
 -- $pattern:loadArgs: "for(first: var integer):to(last: var integer):repeat{repeat:< object}: {   %OSDvisibility skipInternal;   %globals inSub;   inx: var integer;   inx :=  ..."} 
 -- ptn:loadArgs:E "for(1):to(10):repeat{   res := res + V;}" 
 -- {(ObjectInvocation_KeyWord; (name: "for:to:repeat"); (Arguments;  (name: "for");  (name: "(");  (ObjectGenerator;   (Invocation;    (ConstLiteral 1));   (Items descNo: 0 o ...} 
 -- args: "for(1):to(10):repeat{   res := res + V;}" 
 -- E: "ObjectGenerator" 1 
 -- E: "ObjectGenerator" 10 
 -- E: "ObjectGenerator" res := res + V 
 -- E.arg: "var" first: var integer 
 -- NonVirt: "for(1):to(10):repeat{   res := res + V;}" "ObjectInvocation_KeyWord" ActArg:  "1" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "for(1):to(10):repeat{   res := res + V;}"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=4 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 4 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 4 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "first: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "1" :isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "for(1):to(10):repeat{   res := res + V;}" 
 -- E.arg: "var" last: var integer 
 -- NonVirt: "for(1):to(10):repeat{   res := res + V;}" "ObjectInvocation_KeyWord" ActArg:  "10" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "for(1):to(10):repeat{   res := res + V;}"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "10" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=4 
 -- OG:gen: "10" 
 -- OG:before:super.gen: "10" 
 -- $Invocation:gen: "10" >useRtnV:"True"superAdj: 4 
 -- INV:gen: "10" 
 -- isConstant: "Invocation" "10" 
 -- needorigin: "10" 
 -- needOrigin:E: "10"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 4 
 -- rec:  "10" E:  "10" 
 -- INV:gen:E.loadArgs "10" 
 -- $ConstLiteral:loadArgs: "10"  
 -- INV:gen:after:E.loadArgs "10" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "10" 
 -- $ConstLiteral:invoke: "10"  
 pushc 10
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "last: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "10" :isBasicVal: true 
 -- case:B: 10 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "for(1):to(10):repeat{   res := res + V;}" 
 -- args:  "repeat:< object" "res := res + V" for:to:repeat 
 -- hArgOrg:super: for:to:repeat 
 -- Store itemArgs:  
 -- last: var integer true 1 
 -- DI:store: "last" 
 pushThis 
 storeg integer$5 2
 -- first: var integer true 1 
 -- DI:store: "first" 
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- vdtAdd: inx=1 descInx=222 vDescInx=28 vdtTop: 2 
 -- $Property:gen: "%OSDvisibility skipInternal"  
 -- $Property:gen: "%globals inSub"  
 -- $var:gen: "inx: var integer"  
 -- DI:gen: "inx: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  inx 
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0
 -- Handle VB: "" E: "for(1):to(10):repeat{   res := res + V;}" 
 -- vdtAdd: inx=2 descInx=222 vDescInx=221 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 223 
 -- Items:GenClass: for:to:repeat$223 descNo: 223 isValue: false 
 -- Items:GenClass: for:to:repeat$223 descNo: 28 isValue: false 
 -- Items:GenClass: for:to:repeat descNo: 21 isValue: false 

 CLASS for:to:repeat$223 223 4 P2 218
 -- vdtTableCopy: I:1:28 V:2:29
 -- Store itemArgs:  
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- push:super.origin: 
 -- handleSuperArgs:E: "for(1):to(6):repeat{   myM.putItem("Sum: "):value(inx):res(sum(inx));}" theIS: "" 
 -- super.sig:none:superAdj: 4 
 -- $ObjectInvocation_KeyWord:loadArgs: "for(1):to(6):repeat{   myM.putItem("Sum: "):value(inx):res(sum(inx));" >staticOff:0 "for(first: var integer):to(last: var integer):rep ..."} 
 -- $pattern:loadArgs: "for(first: var integer):to(last: var integer):repeat{repeat:< object}: {   %OSDvisibility skipInternal;   %globals inSub;   inx: var integer;   inx :=  ..."} 
 -- ptn:loadArgs:E "for(1):to(6):repeat{   myM.putItem("Sum: "):value(inx):res(sum(inx));}" 
 -- {(ObjectInvocation_KeyWord; (name: "for:to:repeat"); (Arguments;  (name: "for");  (name: "(");  (ObjectGenerator;   (Invocation;    (ConstLiteral 1));   (Items descNo: 0 o ...} 
 -- args: "for(1):to(6):repeat{   myM.putItem("Sum: "):value(inx):res(sum(inx));}" 
 -- E: "ObjectGenerator" 1 
 -- E: "ObjectGenerator" 6 
 -- E: "ObjectGenerator" myM.putItem("Sum: "):value(inx):res(sum(inx)) 
 -- E.arg: "var" first: var integer 
 -- NonVirt: "for(1):to(6):repeat{   myM.putItem("Sum: "):value(inx):res(sum(inx));}" "ObjectInvocation_KeyWord" ActArg:  "1" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "for(1):to(6):repeat{   myM.putItem("Sum: "):value(inx):res(sum(inx));}"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=4 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 4 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 4 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "first: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "1" :isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "for(1):to(6):repeat{   myM.putItem("Sum: "):value(inx):res(sum(inx));}" 
 -- E.arg: "var" last: var integer 
 -- NonVirt: "for(1):to(6):repeat{   myM.putItem("Sum: "):value(inx):res(sum(inx));}" "ObjectInvocation_KeyWord" ActArg:  "6" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "for(1):to(6):repeat{   myM.putItem("Sum: "):value(inx):res(sum(inx));}"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "6" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=4 
 -- OG:gen: "6" 
 -- OG:before:super.gen: "6" 
 -- $Invocation:gen: "6" >useRtnV:"True"superAdj: 4 
 -- INV:gen: "6" 
 -- isConstant: "Invocation" "6" 
 -- needorigin: "6" 
 -- needOrigin:E: "6"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 4 
 -- rec:  "6" E:  "6" 
 -- INV:gen:E.loadArgs "6" 
 -- $ConstLiteral:loadArgs: "6"  
 -- INV:gen:after:E.loadArgs "6" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "6" 
 -- $ConstLiteral:invoke: "6"  
 pushc 6
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "last: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "6" :isBasicVal: true 
 -- case:B: 6 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "for(1):to(6):repeat{   myM.putItem("Sum: "):value(inx):res(sum(inx));}" 
 -- args:  "repeat:< object" "myM.putItem("Sum: "):value(inx):res(sum(inx))" for:to:repeat 
 -- hArgOrg:super: for:to:repeat 
 -- Store itemArgs:  
 -- last: var integer true 1 
 -- DI:store: "last" 
 pushThis 
 storeg integer$5 2
 -- first: var integer true 1 
 -- DI:store: "first" 
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- vdtAdd: inx=1 descInx=223 vDescInx=28 vdtTop: 2 
 -- $Property:gen: "%OSDvisibility skipInternal"  
 -- $Property:gen: "%globals inSub"  
 -- $var:gen: "inx: var integer"  
 -- DI:gen: "inx: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  inx 
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0
 -- Handle VB: "" E: "for(1):to(6):repeat{   myM.putItem("Sum: "):value(inx):res(sum(inx));}" 
 -- vdtAdd: inx=2 descInx=223 vDescInx=219 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:   : done: false 

 CLASS valProx 230 1 Object 0
 END OSDV:0 objSize:4 isIndexed:0

 CLASS VM 231 0 Object 0
 L1:
 pushThis 
 invoke BETAworld 1 0 1
 stop
 L2:
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS EventProcessor 232 0 Object 0
 stop
 END OSDV:0 objSize:1 isIndexed:0

 CLASS ThreadStub 233 0 Object 0
DO:
 call(D)ThreadStub
 stop
 END OSDV:0 objSize:1 isIndexed:0
 -- vdtAdd: inx=2 descInx=30 vDescInx=24 vdtTop: 2 
 -- vdtAdd: inx=2 descInx=106 vDescInx=104 vdtTop: 2 
 -- vdtAdd: inx=2 descInx=150 vDescInx=149 vdtTop: 2 
 -- vdtAdd: inx=2 descInx=152 vDescInx=151 vdtTop: 2 
 -- vdtAdd: inx=2 descInx=213 vDescInx=210 vdtTop: 2 
 -- vdtAdd: inx=2 descInx=214 vDescInx=201 vdtTop: 2 
 -- vdtAdd: inx=2 descInx=222 vDescInx=221 vdtTop: 2 
 -- vdtAdd: inx=2 descInx=223 vDescInx=219 vdtTop: 2 

Class BETAworld descInx:1 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	pushthis 
7:	saveBETAworld
8:	mvStack
allocE: 
9:	pushthis 
10:	invoke 2 2 1
16:	rpop 
17:	pushthis 
18:	invoke 33 3 1
24:	rpop 
25:	pushthis 
26:	invoke 70 4 1
32:	rpop 
33:	rtnAlloc 1
doE: 
35:	doEventQ 
36:	mvStack
37:	setThisStack
38:	pushthis 
39:	rtn D


Class BETA descInx:2 objSize:3 originOff: 1 visibility: 2
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 3 2 1
14:	rpop 
15:	rtnAlloc 1
doE: 
17:	doEventQ 
18:	mvStack
19:	setThisStack
20:	pushthis 
21:	rtn D


Class ascii descInx:3 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushc 10
9:	pushthis 
10:	storeg 2
12:	pushc 13
14:	pushthis 
15:	storeg 3
17:	pushc 0
19:	pushthis 
20:	storeg 4
22:	rtnAlloc 1
doE: 
24:	doEventQ 
25:	mvStack
26:	pushthis 
27:	pushc 10
29:	storeg 5
31:	setThisStack
32:	pushthis 
33:	rtn D


Class Value descInx:4 objSize:0 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
doE: 
1:	rtnV
2:	rtn D


Class integer descInx:5 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
doE: 
1:	rtnV
2:	rtn D


Class universal descInx:6 objSize:0 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
doE: 
1:	rtnV
2:	rtn D


Class char descInx:7 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
doE: 
1:	rtnV
2:	rtn D


Class ConsoleIF descInx:8 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class put descInx:9 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class String descInx:10 objSize:0 originOff: 0 visibility: 2
storeOrgAndArgsE:
1:	allocEventQ 1
3:	mvStack
allocE: 
4:	rtnAlloc 1
doE: 
6:	doEventQ 
7:	mvStack
8:	setThisStack
9:	pushthis 
10:	rtn D


Class = descInx:11 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	jmpFalse 13
4:	pushthis 
5:	vassign 4 2 0
10:	jmp 19
13:	invokeVal 31 3 0
19:	tstOriginNone 
20:	rstore 1
22:	store 3
24:	store 2
26:	allocEventQ 0
28:	mvStack
allocE: 
29:	rtnAlloc 1
doE: 
31:	doEventQ 
32:	mvStack
33:	pushthis 
34:	innerP 2
36:	rpopThisObj
37:	setThisStack
38:	pushthis 
39:	rtn D


Class = descInx:13 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	rshiftup 1
3:	tstOriginNone 
4:	rstore 1
6:	allocEventQ 0
8:	pushthis 
9:	rpushg 1
11:	rshiftdown 1
13:	pushthis 
14:	rstoreg 2
16:	tstOriginNone 
17:	rstore 1
19:	allocEventQ 0
21:	mvStack
allocE: 
doE: 
22:	doEventQ 
23:	mvStack
24:	pushthis 
25:	invoke 14 0 0
31:	rpop 
32:	setThisStack
33:	pushthis 
34:	rtn D


Class loop descInx:14 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	rpushg 1
17:	invoke 15 0 0
23:	pushg 2
25:	storeg 4
27:	pushthis 
28:	pushg 4
30:	pushthis 
31:	rpushg 1
33:	rpushg 2
35:	invoke 15 0 0
41:	pushg 2
43:	ne 
44:	jmpFalse 55
47:	pushthis 
48:	invoke 18 0 0
54:	rpop 
55:	pushthis 
56:	rpushg 1
58:	invoke 23 0 0
64:	pushg 1
66:	storeg 3
68:	pushthis 
69:	invoke 30 0 0
75:	rpop 
76:	setThisStack
77:	pushthis 
78:	rtn D


Class length descInx:15 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	pushc 0
17:	xpushg 1 0 1
21:	storeg 2
23:	setThisStack
24:	pushthis 
25:	rtn D


Class $18 descInx:18 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	break 1 2 14 0
18:	setThisStack
19:	pushthis 
20:	rtn D


Class if:then descInx:20 objSize:1 originOff: 0 visibility: 1
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class BETAworld descInx:21 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	innerP 2
14:	rpopThisObj
15:	setThisStack
16:	pushthis 
17:	rtn D


Class thenPart#22 descInx:22 objSize:3 originOff: 0 visibility: 1
storeOrgAndArgsE:
1:	invoke 21 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class True descInx:23 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
3:	mvStack
allocE: 
4:	rtnAlloc 1
doE: 
6:	doEventQ 
7:	mvStack
8:	pushthis 
9:	pushc 1
11:	storeg 1
13:	setThisStack
14:	pushthis 
15:	rtn D


Class repeat$24 descInx:24 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	pushthis 
17:	rpushg 1
19:	rpushg 4
21:	rpushg 1
23:	rpushg 1
25:	pushthis 
26:	rpushg 1
28:	pushg 3
30:	xpushg 1 0 1
34:	storeg 2
36:	pushthis 
37:	rpushg 1
39:	rpushg 4
41:	pushthis 
42:	rpushg 1
44:	rpushg 4
46:	rpushg 1
48:	rpushg 2
50:	pushthis 
51:	rpushg 1
53:	pushg 3
55:	xpushg 1 0 1
59:	storeg 3
61:	pushthis 
62:	rpushg 1
64:	rpushg 4
66:	pushg 2
68:	pushthis 
69:	rpushg 1
71:	rpushg 4
73:	pushg 3
75:	ne 
76:	jmpFalse 87
79:	pushthis 
80:	invoke 26 0 0
86:	rpop 
87:	setThisStack
88:	pushthis 
89:	rtn D


Class $26 descInx:26 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 4
18:	rpushg 1
20:	invoke 27 0 0
26:	pushg 1
28:	storeg 3
30:	break 3 2 14 0
37:	setThisStack
38:	pushthis 
39:	rtn D


Class False descInx:27 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
3:	mvStack
allocE: 
4:	rtnAlloc 1
doE: 
6:	doEventQ 
7:	mvStack
8:	pushthis 
9:	pushc 0
11:	storeg 1
13:	setThisStack
14:	pushthis 
15:	rtn D


Class for:to:repeat descInx:28 objSize:3 originOff: 0 visibility: 1
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 2
4:	pushthis 
5:	storeg 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	pushthis 
16:	pushg 1
18:	storeg 3
20:	pushthis 
21:	invoke 46 0 0
27:	rpop 
28:	setThisStack
29:	pushthis 
30:	rtn D


Class repeat#29 descInx:29 objSize:3 originOff: 0 visibility: 1
storeOrgAndArgsE:
1:	invoke 21 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class for:to:repeat$30 descInx:30 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	rpushg 1
13:	invoke 15 0 0
19:	pushg 2
21:	pushthis 
22:	storeg 2
24:	pushthis 
25:	storeg 1
27:	allocEventQ 0
allocE: 
29:	rtnAlloc 1
31:	toSuper 28
doE: 
34:	mvStack
35:	rtnInner


Class this descInx:31 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	setThisStack
15:	pushthis 
16:	rtn D


Class X_asString descInx:32 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushText 1
9:	pushthis 
10:	rstoreg 2
12:	rtnAlloc 1
doE: 
14:	doEventQ 
15:	mvStack
16:	pushthis 
17:	innerP 2
19:	rpopThisObj
20:	setThisStack
21:	pushthis 
22:	rtn D


Class LIB descInx:33 objSize:8 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 34 3 1
14:	rpop 
15:	pushthis 
16:	invoke 38 4 1
22:	rpop 
23:	pushthis 
24:	invoke 40 5 1
30:	rpop 
31:	pushthis 
32:	invoke 42 6 1
38:	rpop 
39:	pushthis 
40:	invoke 43 7 1
46:	rpop 
47:	pushthis 
48:	invoke 44 8 1
54:	rpop 
55:	rtnAlloc 1
doE: 
57:	doEventQ 
58:	mvStack
59:	setThisStack
60:	pushthis 
61:	rtn D


Class BasicIO descInx:34 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 35 2 1
14:	rpop 
15:	pushthis 
16:	invoke 36 3 1
22:	rpop 
23:	rtnAlloc 1
doE: 
25:	doEventQ 
26:	mvStack
27:	setThisStack
28:	pushthis 
29:	rtn D


Class keyboard descInx:35 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class screen descInx:36 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	rpushg 1
10:	invoke 37 2 1
16:	rpop 
17:	rtnAlloc 1
doE: 
19:	doEventQ 
20:	mvStack
21:	setThisStack
22:	pushthis 
23:	rtn D


Class Lock descInx:37 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class BasicSystemLib descInx:38 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 39 2 1
14:	rpop 
15:	rtnAlloc 1
doE: 
17:	doEventQ 
18:	mvStack
19:	setThisStack
20:	pushthis 
21:	rtn D


Class SemaphoreLib descInx:39 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class Collections descInx:40 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 41 2 1
14:	rpop 
15:	rtnAlloc 1
doE: 
17:	doEventQ 
18:	mvStack
19:	setThisStack
20:	pushthis 
21:	rtn D


Class QueueLib descInx:41 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class Dimensions descInx:42 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class MonitorSystemLib descInx:43 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class StringLib descInx:44 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	saveStringOrigin
7:	mvStack
allocE: 
8:	rtnAlloc 1
doE: 
10:	doEventQ 
11:	mvStack
12:	setThisStack
13:	pushthis 
14:	rtn D


Class Boolean descInx:45 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
doE: 
1:	rtnV
2:	rtn D


Class _doIt descInx:46 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushg 3
16:	pushthis 
17:	rpushg 1
19:	pushg 2
21:	le
22:	jmpFalse 36
25:	pushthis 
26:	invoke 48 0 0
32:	rpop 
33:	jmp 44
36:	pushthis 
37:	invoke 51 0 0
43:	rpop 
44:	setThisStack
45:	pushthis 
46:	rtn D


Class <= descInx:47 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	jmpFalse 13
4:	pushthis 
5:	vassign 4 2 0
10:	jmp 19
13:	invokeVal 31 3 0
19:	tstOriginNone 
20:	rstore 1
22:	store 3
24:	store 2
26:	allocEventQ 0
28:	mvStack
allocE: 
29:	rtnAlloc 1
doE: 
31:	doEventQ 
32:	mvStack
33:	setThisStack
34:	pushthis 
35:	rtn D


Class $48 descInx:48 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	invokev 2 0 0
20:	rpop 
21:	pushthis 
22:	rpushg 1
24:	rpushg 1
26:	pushthis 
27:	rpushg 1
29:	rpushg 1
31:	pushg 3
33:	pushc 1
35:	+
36:	storeg 3
38:	break 1 1 46 0
45:	setThisStack
46:	pushthis 
47:	rtn D


Class $51 descInx:51 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushthis 
17:	rpushg 1
19:	rpushg 1
21:	pushg 3
23:	storeg 3
25:	setThisStack
26:	pushthis 
27:	rtn D


Class <= descInx:52 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	rshiftup 1
3:	tstOriginNone 
4:	rstore 1
6:	allocEventQ 0
8:	pushthis 
9:	rpushg 1
11:	rshiftdown 1
13:	pushthis 
14:	rstoreg 2
16:	tstOriginNone 
17:	rstore 1
19:	allocEventQ 0
21:	mvStack
allocE: 
22:	pushthis 
23:	invoke 53 4 1
29:	rpop 
doE: 
30:	doEventQ 
31:	mvStack
32:	setThisStack
33:	pushthis 
34:	rtn D


Class loop descInx:53 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	rpushg 1
17:	invoke 15 0 0
23:	pushg 2
25:	storeg 3
27:	pushthis 
28:	pushthis 
29:	rpushg 1
31:	rpushg 2
33:	invoke 15 0 0
39:	pushg 2
41:	storeg 4
43:	pushthis 
44:	pushg 3
46:	pushthis 
47:	pushg 4
49:	lt
50:	jmpFalse 64
53:	pushthis 
54:	invoke 55 0 0
60:	rpop 
61:	jmp 72
64:	pushthis 
65:	invoke 56 0 0
71:	rpop 
72:	pushthis 
73:	invoke 57 0 0
79:	rpop 
80:	setThisStack
81:	pushthis 
82:	rtn D


Class $55 descInx:55 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushthis 
15:	rpushg 1
17:	pushg 3
19:	storeg 2
21:	setThisStack
22:	pushthis 
23:	rtn D


Class $56 descInx:56 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushthis 
15:	rpushg 1
17:	pushg 4
19:	storeg 2
21:	setThisStack
22:	pushthis 
23:	rtn D


Class matchEq descInx:57 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	invoke 58 0 0
18:	rpop 
19:	pushthis 
20:	invoke 61 0 0
26:	rpop 
27:	pushthis 
28:	invoke 64 0 0
34:	rpop 
35:	setThisStack
36:	pushthis 
37:	rtn D


Class isEmpty descInx:58 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushg 3
18:	pushc 0
20:	eq 
21:	jmpFalse 32
24:	pushthis 
25:	invoke 59 0 0
31:	rpop 
32:	pushthis 
33:	rpushg 1
35:	rpushg 1
37:	pushg 4
39:	pushc 0
41:	eq 
42:	jmpFalse 53
45:	pushthis 
46:	invoke 60 0 0
52:	rpop 
53:	setThisStack
54:	pushthis 
55:	rtn D


Class $59 descInx:59 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 1
20:	pushthis 
21:	rpushg 1
23:	rpushg 1
25:	rpushg 1
27:	pushg 3
29:	pushthis 
30:	rpushg 1
32:	rpushg 1
34:	rpushg 1
36:	pushg 4
38:	le
39:	storeg 3
41:	break 2 2 57 0
48:	setThisStack
49:	pushthis 
50:	rtn D


Class $60 descInx:60 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 1
20:	invoke 27 0 0
26:	pushg 1
28:	storeg 3
30:	break 2 2 57 0
37:	setThisStack
38:	pushthis 
39:	rtn D


Class loop descInx:61 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushthis 
15:	rpushg 1
17:	pushg 2
19:	pushc 1
21:	+
22:	storeg 2
24:	pushthis 
25:	rpushg 1
27:	pushthis 
28:	rpushg 1
30:	rpushg 1
32:	rpushg 1
34:	rpushg 1
36:	pushthis 
37:	rpushg 1
39:	pushg 2
41:	xpushg 1 0 1
45:	storeg 3
47:	pushthis 
48:	rpushg 1
50:	pushthis 
51:	rpushg 1
53:	rpushg 1
55:	rpushg 1
57:	rpushg 2
59:	pushthis 
60:	rpushg 1
62:	pushg 2
64:	xpushg 1 0 1
68:	storeg 4
70:	pushthis 
71:	rpushg 1
73:	pushg 3
75:	pushthis 
76:	rpushg 1
78:	pushg 4
80:	eq 
81:	jmpFalse 92
84:	pushthis 
85:	invoke 62 0 0
91:	rpop 
92:	setThisStack
93:	pushthis 
94:	rtn D


Class $62 descInx:62 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushg 2
18:	pushthis 
19:	rpushg 1
21:	rpushg 1
23:	rpushg 1
25:	pushg 2
27:	lt
28:	jmpFalse 39
31:	pushthis 
32:	invoke 63 0 0
38:	rpop 
39:	setThisStack
40:	pushthis 
41:	rtn D


Class $63 descInx:63 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	break 2 1 61 0
18:	setThisStack
19:	pushthis 
20:	rtn D


Class doit descInx:64 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushg 3
16:	pushthis 
17:	rpushg 1
19:	pushg 4
21:	eq 
22:	jmpFalse 36
25:	pushthis 
26:	invoke 65 0 0
32:	rpop 
33:	jmp 44
36:	pushthis 
37:	invoke 66 0 0
43:	rpop 
44:	setThisStack
45:	pushthis 
46:	rtn D


Class $65 descInx:65 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 1
20:	pushthis 
21:	rpushg 1
23:	rpushg 1
25:	rpushg 1
27:	pushg 3
29:	pushthis 
30:	rpushg 1
32:	rpushg 1
34:	rpushg 1
36:	pushg 4
38:	le
39:	storeg 3
41:	break 2 2 57 0
48:	setThisStack
49:	pushthis 
50:	rtn D


Class $66 descInx:66 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 1
20:	pushthis 
21:	rpushg 1
23:	rpushg 1
25:	pushg 3
27:	pushthis 
28:	rpushg 1
30:	rpushg 1
32:	pushg 4
34:	lt
35:	storeg 3
37:	break 2 2 57 0
44:	setThisStack
45:	pushthis 
46:	rtn D


Class puttext descInx:68 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	innerP 2
17:	rpopThisObj
18:	setThisStack
19:	pushthis 
20:	rtn D


Class putint descInx:69 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	innerP 2
17:	rpopThisObj
18:	setThisStack
19:	pushthis 
20:	rtn D


Class workspace descInx:70 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 71 2 1
14:	rpop 
15:	rtnAlloc 1
doE: 
17:	doEventQ 
18:	mvStack
19:	setThisStack
20:	pushthis 
21:	rtn D


Class demo descInx:71 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 189 2 1
14:	rpop 
15:	rtnAlloc 1
doE: 
17:	doEventQ 
18:	mvStack
19:	setThisStack
20:	pushthis 
21:	rtn D


Class BasicSystem descInx:72 objSize:9 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushc 4
9:	pushthis 
10:	storeg 2
12:	pushthis 
13:	invoke 73 3 1
19:	rpop 
20:	pushthis 
21:	invoke 74 4 1
27:	rpop 
28:	pushthis 
29:	invoke 75 5 1
35:	rpop 
36:	pushthis 
37:	invoke 77 6 1
43:	rpop 
44:	pushText 1
46:	invoke 76 7 1
52:	rpop 
53:	pushthis 
54:	invoke 80 8 1
60:	rpop 
61:	pushthis 
62:	invoke 85 9 1
68:	rpop 
69:	rtnAlloc 1
doE: 
71:	doEventQ 
72:	mvStack
73:	pushthis 
74:	invoke 94 0 0
80:	rpop 
81:	pushthis 
82:	innerP 2
84:	rpopThisObj
85:	pushthis 
86:	rpushg 3
88:	invoke 111 0 0
94:	rpop 
95:	setThisStack
96:	pushthis 
97:	rtn D


Class cores descInx:73 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class P_status descInx:74 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushc 1
9:	pushthis 
10:	storeg 2
12:	pushc 2
14:	pushthis 
15:	storeg 3
17:	pushc 3
19:	pushthis 
20:	storeg 4
22:	rtnAlloc 1
doE: 
24:	doEventQ 
25:	mvStack
26:	setThisStack
27:	pushthis 
28:	rtn D


Class sch descInx:75 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushText 1
9:	invoke 76 2 1
15:	rpop 
16:	rtnAlloc 1
doE: 
18:	doEventQ 
19:	mvStack
20:	setThisStack
21:	pushthis 
22:	rtn D


Class Lock descInx:76 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class SQS descInx:77 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	invoke 79 2 1
13:	rpop 
14:	pushText 1
16:	invoke 76 3 1
22:	rpop 
23:	rtnAlloc 1
doE: 
25:	doEventQ 
26:	mvStack
27:	setThisStack
28:	pushthis 
29:	rtn D


Class Queue descInx:78 objSize:5 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 1
3:	mvStack
allocE: 
4:	pushText 1
6:	pushthis 
7:	rstoreg 1
9:	rtnAlloc 1
doE: 
11:	doEventQ 
12:	mvStack
13:	setThisStack
14:	pushthis 
15:	rtn D


Class ProcessQueue descInx:79 objSize:5 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 1
allocE: 
3:	pushText 5
5:	pushthis 
6:	rstoreg 1
8:	rtnAlloc 1
10:	toSuper 78
doE: 
13:	mvStack
14:	rtnInner


Class console descInx:80 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushText 1
9:	invoke 76 2 1
15:	rpop 
16:	rtnAlloc 1
doE: 
18:	doEventQ 
19:	mvStack
20:	pushthis 
21:	rpushg 2
23:	invoke 81 0 0
29:	rpop 
30:	setThisStack
31:	pushthis 
32:	rtn D


Class init descInx:81 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushc 0
16:	storeg 2
18:	setThisStack
19:	pushthis 
20:	rtn D


Class GeneralProcess descInx:82 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 1
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	innerP 7
17:	rpopThisObj
18:	setThisStack
19:	pushthis 
20:	rtn D


Class BasicProcess descInx:83 objSize:4 originOff: 4 visibility: 0
storeOrgAndArgsE:
1:	rshiftup 1
3:	tstOriginNone 
4:	rstore 4
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	rpushg 1
13:	rpushg 1
15:	rpushg 2
17:	rshiftdown 1
19:	pushthis 
20:	rstoreg 2
22:	tstOriginNone 
23:	rstore 1
25:	allocEventQ 1
allocE: 
27:	rtnAlloc 1
29:	toSuper 82
doE: 
32:	mvStack
33:	pushthis 
34:	susp 
35:	pushthis 
36:	innerP 8
38:	rpopThisObj
39:	pushthis 
40:	pushc 3
42:	storeg 3
44:	rtnInner


Class keyboard descInx:85 objSize:8 originOff: 4 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushthis 
5:	rpushg 4
7:	pushText 5
9:	rshiftup 1
11:	tstOriginNone 
12:	rstore 4
14:	pushthis 
15:	rpushg 4
17:	rpushg 1
19:	rpushg 1
21:	rpushg 1
23:	rpushg 2
25:	rshiftdown 1
27:	pushthis 
28:	rstoreg 2
30:	tstOriginNone 
31:	rstore 1
33:	allocEventQ 1
allocE: 
35:	pushc 100
37:	pushthis 
38:	pushc 1
40:	allocIndexed 86 1 0 
45:	pushthis 
46:	rstoreg 5
48:	rtnAlloc 1
50:	toSuper 82
doE: 
53:	mvStack
54:	pushthis 
55:	invoke 88 0 0
61:	rpop 
62:	rtnInner


Class Indexed descInx:86 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class Kscan descInx:88 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 89 2 1
14:	rpop 
15:	rtnAlloc 1
doE: 
17:	doEventQ 
18:	mvStack
19:	setThisStack
20:	pushthis 
21:	rtn D


Class loopB descInx:89 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 4
18:	rpushg 1
20:	rpushg 1
22:	rpushg 1
24:	rpushg 2
26:	invokeExternal 5 
28:	jmpFalse 39
31:	pushthis 
32:	invoke 91 0 0
38:	rpop 
39:	pushthis 
40:	rpushg 1
42:	rpushg 1
44:	rpushg 4
46:	rpushg 9
48:	susp 
49:	jmp 11
52:	setThisStack
53:	pushthis 
54:	rtn D


Class $91 descInx:91 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	pushthis 
19:	rpushg 1
21:	rpushg 1
23:	rpushg 1
25:	pushg 7
27:	pushc 1
29:	+
30:	storeg 7
32:	pushthis 
33:	rpushg 1
35:	rpushg 1
37:	rpushg 1
39:	rpushg 5
41:	pushthis 
42:	rpushg 1
44:	rpushg 1
46:	rpushg 1
48:	rpushg 4
50:	rpushg 1
52:	rpushg 1
54:	rpushg 1
56:	rpushg 2
58:	invokeExternal 4 
60:	pushthis 
61:	rpushg 1
63:	rpushg 1
65:	rpushg 1
67:	pushg 7
69:	xstoreg 1 0 1 
73:	setThisStack
74:	pushthis 
75:	rtn D


Class init descInx:94 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 6
16:	invoke 110 0 0
22:	rpop 
23:	setThisStack
24:	pushthis 
25:	rtn D


Class entry descInx:95 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 3
16:	invoke 96 0 0
22:	rpop 
23:	pushthis 
24:	rpushg 1
26:	pushthis 
27:	rpushg 1
29:	pushg 4
31:	pushc 1
33:	+
34:	storeg 4
36:	pushthis 
37:	rpushg 1
39:	pushg 4
41:	pushc 1
43:	gt 
44:	jmpFalse 55
47:	pushthis 
48:	invoke 107 0 0
54:	rpop 
55:	pushthis 
56:	innerP 2
58:	rpopThisObj
59:	pushthis 
60:	rpushg 1
62:	pushthis 
63:	rpushg 1
65:	pushg 4
67:	pushc 1
69:	-
70:	storeg 4
72:	pushthis 
73:	rpushg 1
75:	rpushg 3
77:	invoke 109 0 0
83:	rpop 
84:	setThisStack
85:	pushthis 
86:	rtn D


Class get descInx:96 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 97 2 1
14:	rpop 
15:	rtnAlloc 1
doE: 
17:	doEventQ 
18:	mvStack
19:	setThisStack
20:	pushthis 
21:	rtn D


Class loop descInx:97 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	rpushg 1
17:	pushc 2
19:	pushc 5
21:	pushc 1
23:	swap 
24:	vpop 
25:	swap 
26:	%prim cmpAndSwap 14
28:	storeg 2
30:	pushthis 
31:	pushg 2
33:	pushc 1
35:	eq 
36:	jmpFalse 47
39:	pushthis 
40:	invoke 99 0 0
46:	rpop 
47:	setThisStack
48:	pushthis 
49:	rtn D


Class $99 descInx:99 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushc 50
13:	%prim sleep 15
15:	pushthis 
16:	rpushg 1
18:	pushthis 
19:	rpushg 1
21:	pushg 3
23:	pushc 1
25:	+
26:	storeg 3
28:	pushthis 
29:	rpushg 1
31:	pushg 3
33:	pushc2 10000
36:	gt 
37:	jmpFalse 48
40:	pushthis 
41:	invoke 102 0 0
47:	rpop 
48:	break 1 1 97 0
55:	setThisStack
56:	pushthis 
57:	rtn D


Class $102 descInx:102 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 1
20:	rpushg 1
22:	pushText 1
24:	invoke 147 0 0
30:	rpushg 3
32:	invoke 103 0 0
38:	rpop 
39:	pushthis 
40:	rpushg 1
42:	rpushg 1
44:	pushc 0
46:	storeg 3
48:	setThisStack
49:	pushthis 
50:	rtn D


Class print descInx:103 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	invoke 106 0 0
18:	rpop 
19:	setThisStack
20:	pushthis 
21:	rtn D


Class repeat$104 descInx:104 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	rpushg 1
18:	pushthis 
19:	rpushg 1
21:	pushg 3
23:	xpushg 1 0 1
27:	%prim put 2
29:	setThisStack
30:	pushthis 
31:	rtn D


Class put descInx:105 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class for:to:repeat$106 descInx:106 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	invoke 15 0 0
17:	pushg 2
19:	pushthis 
20:	storeg 2
22:	pushthis 
23:	storeg 1
25:	allocEventQ 0
allocE: 
27:	rtnAlloc 1
29:	toSuper 28
doE: 
32:	mvStack
33:	rtnInner


Class $107 descInx:107 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushc 86
13:	%prim put 2
15:	setThisStack
16:	pushthis 
17:	rtn D


Class free descInx:109 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushc 0
16:	storeg 2
18:	setThisStack
19:	pushthis 
20:	rtn D


Class init descInx:110 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 95
doE: 
17:	mvStack
18:	pushthis 
19:	rpushg 1
21:	pushc 1
23:	storeg 4
25:	pushthis 
26:	rpushg 1
28:	rpushg 3
30:	invoke 81 0 0
36:	rpop 
37:	pushthis 
38:	rpushg 1
40:	rpushg 3
42:	pushText 5
44:	rswap 0
46:	rstoreg 1
48:	pushthis 
49:	rpushg 1
51:	rpushg 2
53:	pushText 9
55:	rswap 0
57:	rstoreg 1
59:	rtnInner


Class init descInx:111 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushthis 
15:	rpushg 1
17:	rpushg 1
19:	invoke 113 0 1
25:	rswap 0
27:	rstoreg 2
29:	pushthis 
30:	rpushg 1
32:	rpushg 2
34:	%prim fork 13
36:	pushthis 
37:	rpushg 1
39:	pushthis 
40:	rpushg 1
42:	rpushg 1
44:	invoke 113 0 1
50:	rswap 0
52:	rstoreg 3
54:	pushthis 
55:	rpushg 1
57:	rpushg 3
59:	%prim fork 13
61:	pushthis 
62:	rpushg 1
64:	pushthis 
65:	rpushg 1
67:	rpushg 1
69:	invoke 113 0 1
75:	rswap 0
77:	rstoreg 4
79:	pushthis 
80:	rpushg 1
82:	rpushg 4
84:	%prim fork 13
86:	pushthis 
87:	rpushg 1
89:	pushthis 
90:	rpushg 1
92:	rpushg 1
94:	invoke 113 0 1
100:	rswap 0
102:	rstoreg 5
104:	pushthis 
105:	rpushg 1
107:	rpushg 5
109:	%prim fork 13
111:	pushthis 
112:	pushthis 
113:	rpushg 1
115:	rpushg 1
117:	invoke 125 0 1
123:	rswap 0
125:	rstoreg 2
127:	pushthis 
128:	rpushg 1
130:	rpushg 2
132:	pushthis 
133:	rpushg 2
135:	invoke 131 0 0
141:	rpop 
142:	pushthis 
143:	pushthis 
144:	rpushg 1
146:	rpushg 1
148:	invoke 125 0 1
154:	rswap 0
156:	rstoreg 2
158:	pushthis 
159:	rpushg 1
161:	rpushg 3
163:	pushthis 
164:	rpushg 2
166:	invoke 131 0 0
172:	rpop 
173:	pushthis 
174:	pushthis 
175:	rpushg 1
177:	rpushg 1
179:	invoke 125 0 1
185:	rswap 0
187:	rstoreg 2
189:	pushthis 
190:	rpushg 1
192:	rpushg 4
194:	pushthis 
195:	rpushg 2
197:	invoke 131 0 0
203:	rpop 
204:	pushthis 
205:	rpushg 1
207:	rpushg 5
209:	pushthis 
210:	rpushg 1
212:	rpushg 1
214:	invoke 125 0 1
220:	invoke 131 0 0
226:	rpop 
227:	setThisStack
228:	pushthis 
229:	rtn D


Class SuperCore descInx:112 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	innerP 2
14:	rpopThisObj
15:	setThisStack
16:	pushthis 
17:	rtn D


Class Core descInx:113 objSize:4 originOff: 3 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 3
4:	pushthis 
5:	rpushg 3
7:	rpushg 1
9:	rpushg 1
11:	rpushg 1
13:	rpushg 2
15:	tstOriginNone 
16:	rstore 1
18:	allocEventQ 1
allocE: 
20:	rtnAlloc 1
22:	toSuper 112
doE: 
25:	mvStack
26:	pushthis 
27:	susp 
28:	pushthis 
29:	pushc 213
31:	storeg 4
33:	pushthis 
34:	invoke 114 0 0
40:	rpop 
41:	rtnInner


Class go descInx:114 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 115 2 1
14:	rpop 
15:	rtnAlloc 1
doE: 
17:	doEventQ 
18:	mvStack
19:	setThisStack
20:	pushthis 
21:	rtn D


Class loopX descInx:115 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 2
18:	pushNone 
19:	57
20:	jmpFalse 34
23:	pushthis 
24:	invoke 118 0 0
30:	rpop 
31:	jmp 42
34:	pushthis 
35:	invoke 120 0 0
41:	rpop 
42:	setThisStack
43:	pushthis 
44:	rtn D


Class $118 descInx:118 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 2
20:	call D
22:	rpop 
23:	setThisStack
24:	pushthis 
25:	rtn D


Class $120 descInx:120 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushc 100
13:	%prim sleep 15
15:	break 1 1 115 0
22:	setThisStack
23:	pushthis 
24:	rtn D


Class SuperScheduler descInx:122 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	innerP 4
14:	rpopThisObj
15:	setThisStack
16:	pushthis 
17:	rtn D


Class thisScheduler#123 descInx:123 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	invoke 21 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class ProcessType#124 descInx:124 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	rpushg 1
3:	invoke 82 0 1
9:	pushthis 
10:	rstoreg 2
12:	setThisStack
13:	pushthis 
14:	rpushg 2
16:	rtn D


Class Scheduler descInx:125 objSize:6 originOff: 3 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 3
4:	pushthis 
5:	rpushg 3
7:	rpushg 1
9:	rpushg 1
11:	rpushg 1
13:	rpushg 2
15:	tstOriginNone 
16:	rstore 1
18:	allocEventQ 1
allocE: 
20:	rtnAlloc 1
22:	toSuper 122
doE: 
25:	mvStack
26:	pushthis 
27:	susp 
28:	pushthis 
29:	rpushg 3
31:	rpushg 5
33:	invoke 128 0 0
39:	rpop 
40:	pushthis 
41:	invoke 165 0 0
47:	rpop 
48:	rtnInner


Class thisScheduler#126 descInx:126 objSize:3 originOff: 3 visibility: 0
storeOrgAndArgsE:
1:	rpushg 3
3:	invoke 125 0 1
9:	pushthis 
10:	rstoreg 2
12:	setThisStack
13:	pushthis 
14:	rpushg 2
16:	rtn D


Class ProcessType#127 descInx:127 objSize:3 originOff: 3 visibility: 0
storeOrgAndArgsE:
1:	rpushg 3
3:	invoke 83 0 1
9:	pushthis 
10:	rstoreg 2
12:	setThisStack
13:	pushthis 
14:	rpushg 2
16:	rtn D


Class add descInx:128 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	invoke 130 0 0
18:	rpop 
19:	setThisStack
20:	pushthis 
21:	rtn D


Class entry descInx:129 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 2
16:	invoke 96 0 0
22:	rpop 
23:	pushthis 
24:	innerP 2
26:	rpopThisObj
27:	pushthis 
28:	rpushg 1
30:	rpushg 2
32:	invoke 109 0 0
38:	rpop 
39:	setThisStack
40:	pushthis 
41:	rtn D


Class entry$130 descInx:130 objSize:2 originOff: 2 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 2
4:	pushthis 
5:	rpushg 2
7:	rpushg 1
9:	tstOriginNone 
10:	rstore 1
12:	allocEventQ 0
allocE: 
14:	rtnAlloc 1
16:	toSuper 129
doE: 
19:	mvStack
20:	pushthis 
21:	rpushg 2
23:	rpushg 1
25:	pushthis 
26:	rpushg 2
28:	rpushg 1
30:	pushg 3
32:	pushc 1
34:	+
35:	storeg 3
37:	rtnInner


Class attach descInx:131 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	rpushg 1
17:	pushthis 
18:	rpushg 2
20:	rswap 0
22:	rstoreg 2
24:	setThisStack
25:	pushthis 
26:	rtn D


Class start descInx:132 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	innerP 2
14:	rpopThisObj
15:	setThisStack
16:	pushthis 
17:	rtn D


Class mkActive descInx:133 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	innerP 2
14:	rpopThisObj
15:	setThisStack
16:	pushthis 
17:	rtn D


Class addWaiting descInx:134 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	innerP 2
14:	rpopThisObj
15:	setThisStack
16:	pushthis 
17:	rtn D


Class dcrWaiting descInx:135 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	innerP 2
14:	rpopThisObj
15:	setThisStack
16:	pushthis 
17:	rtn D


Class display descInx:136 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushText 1
13:	invoke 103 0 0
19:	rpop 
20:	pushthis 
21:	innerP 2
23:	rpopThisObj
24:	setThisStack
25:	pushthis 
26:	rtn D


Class Element descInx:137 objSize:6 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 1
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	pushthis 
16:	rswap 0
18:	rstoreg 3
20:	pushthis 
21:	rpushg 1
23:	pushthis 
24:	rpushg 1
26:	pushg 2
28:	pushc 1
30:	+
31:	storeg 2
33:	pushthis 
34:	pushthis 
35:	rpushg 1
37:	pushg 2
39:	storeg 4
41:	setThisStack
42:	pushthis 
43:	rtn D


Class mkActive descInx:138 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 133
doE: 
17:	mvStack
18:	pushthis 
19:	rpushg 1
21:	pushc 1
23:	storeg 3
25:	pushthis 
26:	rpushg 1
28:	rpushg 4
30:	rpushg 6
32:	pushthis 
33:	rpushg 1
35:	invoke 139 0 0
41:	rpop 
42:	rtnInner


Class insert descInx:139 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	pushthis 
8:	rpushg 1
10:	tstOriginNone 
11:	rstore 1
13:	allocEventQ 0
allocE: 
15:	rtnAlloc 1
17:	toSuper 95
doE: 
20:	mvStack
21:	pushthis 
22:	rpushg 1
24:	rpushg 2
26:	pushthis 
27:	rpushg 2
29:	invoke 154 0 0
35:	pushg 3
37:	nott
38:	jmpFalse 49
41:	pushthis 
42:	invoke 141 0 0
48:	rpop 
49:	rtnInner


Class $141 descInx:141 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 2
18:	pushthis 
19:	rpushg 1
21:	rpushg 2
23:	invoke 142 0 0
29:	rpop 
30:	setThisStack
31:	pushthis 
32:	rtn D


Class insert descInx:142 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	pushthis 
16:	rpushg 2
18:	pushNone 
19:	57
20:	storeg 4
22:	pushthis 
23:	pushg 4
25:	jmpFalse 36
28:	pushthis 
29:	invoke 143 0 0
35:	rpop 
36:	setThisStack
37:	pushthis 
38:	rtn D


Class $143 descInx:143 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushthis 
15:	rpushg 1
17:	rpushg 1
19:	pushthis 
20:	rpushg 1
22:	rpushg 2
24:	invoke 137 0 1
30:	rpushg 3
32:	rswap 0
34:	rstoreg 3
36:	pushthis 
37:	rpushg 1
39:	rpushg 1
41:	pushthis 
42:	rpushg 1
44:	rpushg 1
46:	pushg 3
48:	pushc 1
50:	+
51:	storeg 3
53:	pushthis 
54:	rpushg 1
56:	rpushg 1
58:	rpushg 4
60:	pushNone 
61:	req 
62:	jmpFalse 76
65:	pushthis 
66:	invoke 145 0 0
72:	rpop 
73:	jmp 84
76:	pushthis 
77:	invoke 146 0 0
83:	rpop 
84:	setThisStack
85:	pushthis 
86:	rtn D


Class $145 descInx:145 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	pushthis 
19:	rpushg 1
21:	rpushg 1
23:	rpushg 3
25:	rswap 0
27:	rstoreg 4
29:	pushthis 
30:	rpushg 1
32:	rpushg 1
34:	rpushg 1
36:	pushthis 
37:	rpushg 1
39:	rpushg 1
41:	rpushg 1
43:	rpushg 4
45:	rswap 0
47:	rstoreg 5
49:	setThisStack
50:	pushthis 
51:	rtn D


Class $146 descInx:146 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 3
18:	pushthis 
19:	rpushg 1
21:	rpushg 1
23:	rpushg 1
25:	rpushg 4
27:	rswap 0
29:	rstoreg 6
31:	pushthis 
32:	rpushg 1
34:	rpushg 1
36:	rpushg 1
38:	rpushg 4
40:	pushthis 
41:	rpushg 1
43:	rpushg 1
45:	rpushg 3
47:	rswap 0
49:	rstoreg 5
51:	pushthis 
52:	rpushg 1
54:	rpushg 1
56:	rpushg 1
58:	pushthis 
59:	rpushg 1
61:	rpushg 1
63:	rpushg 3
65:	rswap 0
67:	rstoreg 4
69:	setThisStack
70:	pushthis 
71:	rtn D


Class + descInx:147 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	pushText 1
12:	pushthis 
13:	rstoreg 3
15:	rtnAlloc 1
doE: 
17:	doEventQ 
18:	mvStack
19:	pushthis 
20:	pushthis 
21:	rpushg 1
23:	invoke 15 0 0
29:	pushg 2
31:	storeg 4
33:	pushthis 
34:	invoke 148 0 0
40:	rpop 
41:	setThisStack
42:	pushthis 
43:	rtn D


Class doplus descInx:148 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushthis 
8:	rpushg 1
10:	pushg 4
12:	pushthis 
13:	rpushg 1
15:	rpushg 2
17:	invoke 15 0 0
23:	pushg 2
25:	+
26:	pushthis 
27:	pushc 1
29:	allocIndexed 86 1 0 
34:	pushthis 
35:	rstoreg 4
37:	rtnAlloc 1
doE: 
39:	doEventQ 
40:	mvStack
41:	pushthis 
42:	invoke 150 0 0
48:	rpop 
49:	pushthis 
50:	invoke 152 0 0
56:	rpop 
57:	pushthis 
58:	rpushg 1
60:	pushthis 
61:	rpushg 4
63:	%prim asString 118
65:	rswap 0
67:	rstoreg 3
69:	setThisStack
70:	pushthis 
71:	rtn D


Class repeat$149 descInx:149 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	pushthis 
17:	rpushg 1
19:	rpushg 4
21:	rpushg 1
23:	rpushg 1
25:	pushthis 
26:	rpushg 1
28:	pushg 3
30:	xpushg 1 0 1
34:	storeg 2
36:	pushthis 
37:	rpushg 1
39:	rpushg 4
41:	rpushg 4
43:	pushthis 
44:	rpushg 1
46:	rpushg 4
48:	pushg 2
50:	pushthis 
51:	rpushg 1
53:	pushg 3
55:	xstoreg 1 0 1 
59:	setThisStack
60:	pushthis 
61:	rtn D


Class for:to:repeat$150 descInx:150 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	pushg 4
13:	pushthis 
14:	storeg 2
16:	pushthis 
17:	storeg 1
19:	allocEventQ 0
allocE: 
21:	rtnAlloc 1
23:	toSuper 28
doE: 
26:	mvStack
27:	rtnInner


Class repeat$151 descInx:151 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	pushthis 
17:	rpushg 1
19:	rpushg 4
21:	rpushg 1
23:	rpushg 2
25:	pushthis 
26:	rpushg 1
28:	pushg 3
30:	xpushg 1 0 1
34:	storeg 2
36:	pushthis 
37:	rpushg 1
39:	rpushg 4
41:	pushthis 
42:	rpushg 1
44:	rpushg 4
46:	rpushg 1
48:	pushg 4
50:	pushthis 
51:	rpushg 1
53:	pushg 3
55:	+
56:	storeg 3
58:	pushthis 
59:	rpushg 1
61:	rpushg 4
63:	rpushg 4
65:	pushthis 
66:	rpushg 1
68:	rpushg 4
70:	pushg 2
72:	pushthis 
73:	rpushg 1
75:	rpushg 4
77:	pushg 3
79:	xstoreg 1 0 1 
83:	setThisStack
84:	pushthis 
85:	rtn D


Class for:to:repeat$152 descInx:152 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	rpushg 2
13:	invoke 15 0 0
19:	pushg 2
21:	pushthis 
22:	storeg 2
24:	pushthis 
25:	storeg 1
27:	allocEventQ 0
allocE: 
29:	rtnAlloc 1
31:	toSuper 28
doE: 
34:	mvStack
35:	rtnInner


Class asString descInx:153 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushText 1
9:	pushthis 
10:	rstoreg 2
12:	rtnAlloc 1
doE: 
14:	doEventQ 
15:	mvStack
16:	setThisStack
17:	pushthis 
18:	rtn D


Class has descInx:154 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	invoke 158 0 0
21:	rpop 
22:	setThisStack
23:	pushthis 
24:	rtn D


Class scan descInx:155 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	rpushg 4
17:	rswap 0
19:	rstoreg 3
21:	pushthis 
22:	invoke 156 0 0
28:	rpop 
29:	setThisStack
30:	pushthis 
31:	rtn D


Class loop descInx:156 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 3
16:	pushNone 
17:	57
18:	jmpFalse 29
21:	pushthis 
22:	invoke 157 0 0
28:	rpop 
29:	setThisStack
30:	pushthis 
31:	rtn D


Class $157 descInx:157 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushthis 
17:	rpushg 1
19:	rpushg 1
21:	rpushg 3
23:	rpushg 2
25:	rswap 0
27:	rstoreg 2
29:	pushthis 
30:	rpushg 1
32:	rpushg 1
34:	innerP 2
36:	rpopThisObj
37:	pushthis 
38:	rpushg 1
40:	rpushg 1
42:	pushthis 
43:	rpushg 1
45:	rpushg 1
47:	rpushg 3
49:	rpushg 6
51:	rswap 0
53:	rstoreg 3
55:	break 1 1 156 0
62:	setThisStack
63:	pushthis 
64:	rtn D


Class scan$158 descInx:158 objSize:4 originOff: 4 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushthis 
5:	rpushg 4
7:	rpushg 1
9:	tstOriginNone 
10:	rstore 1
12:	allocEventQ 0
allocE: 
14:	rtnAlloc 1
16:	toSuper 155
doE: 
19:	mvStack
20:	pushthis 
21:	rpushg 4
23:	rpushg 2
25:	pushthis 
26:	rpushg 2
28:	req 
29:	jmpFalse 40
32:	pushthis 
33:	invoke 159 0 0
39:	rpop 
40:	rtnInner


Class $159 descInx:159 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	invoke 23 0 0
22:	pushg 1
24:	storeg 3
26:	break 2 2 154 0
33:	setThisStack
34:	pushthis 
35:	rtn D


Class start descInx:160 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 132
doE: 
17:	mvStack
18:	pushthis 
19:	rpushg 1
21:	pushc 1
23:	storeg 3
25:	pushthis 
26:	rpushg 1
28:	rpushg 4
30:	rpushg 6
32:	pushthis 
33:	rpushg 1
35:	invoke 139 0 0
41:	rpop 
42:	pushthis 
43:	innerP 3
45:	rpopThisObj
46:	rtnInner


Class addWaiting descInx:161 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 134
doE: 
17:	mvStack
18:	pushthis 
19:	rpushg 1
21:	pushc 2
23:	storeg 3
25:	rtnInner


Class dcrWaiting descInx:162 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 135
doE: 
17:	mvStack
18:	pushthis 
19:	rpushg 1
21:	rpushg 4
23:	rpushg 6
25:	invoke 163 0 0
31:	rpop 
32:	rtnInner


Class dcrWaiting descInx:163 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 95
doE: 
17:	mvStack
18:	pushthis 
19:	rpushg 1
21:	pushthis 
22:	rpushg 1
24:	pushg 5
26:	pushc 1
28:	-
29:	storeg 5
31:	rtnInner


Class display descInx:164 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 136
doE: 
17:	mvStack
18:	pushText 19
20:	invoke 103 0 0
26:	rpop 
27:	rtnInner


Class loop descInx:165 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushc 1
16:	storeg 5
18:	pushthis 
19:	rpushg 1
21:	pushthis 
22:	rpushg 1
24:	rpushg 3
26:	rpushg 6
28:	invoke 166 0 0
34:	rpushg 2
36:	rswap 0
38:	rstoreg 2
40:	pushthis 
41:	rpushg 1
43:	rpushg 2
45:	pushNone 
46:	57
47:	jmpFalse 58
50:	pushthis 
51:	invoke 172 0 0
57:	rpop 
58:	pushthis 
59:	rpushg 1
61:	rpushg 3
63:	rpushg 6
65:	invoke 175 0 0
71:	pushg 2
73:	jmpFalse 87
76:	pushthis 
77:	invoke 178 0 0
83:	rpop 
84:	jmp 95
87:	pushthis 
88:	invoke 187 0 0
94:	rpop 
95:	setThisStack
96:	pushthis 
97:	rtn D


Class removeNext descInx:166 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	invoke 167 0 0
18:	rpop 
19:	setThisStack
20:	pushthis 
21:	rtn D


Class entry$167 descInx:167 objSize:2 originOff: 2 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 2
4:	pushthis 
5:	rpushg 2
7:	rpushg 1
9:	tstOriginNone 
10:	rstore 1
12:	allocEventQ 0
allocE: 
14:	rtnAlloc 1
16:	toSuper 95
doE: 
19:	mvStack
20:	pushthis 
21:	rpushg 2
23:	pushthis 
24:	rpushg 2
26:	rpushg 1
28:	rpushg 2
30:	invoke 168 0 0
36:	rpushg 2
38:	rswap 0
40:	rstoreg 2
42:	rtnInner


Class removeNext descInx:168 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 5
16:	pushNone 
17:	57
18:	jmpFalse 29
21:	pushthis 
22:	invoke 169 0 0
28:	rpop 
29:	setThisStack
30:	pushthis 
31:	rtn D


Class $169 descInx:169 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushthis 
17:	rpushg 1
19:	rpushg 1
21:	pushg 3
23:	pushc 1
25:	-
26:	storeg 3
28:	pushthis 
29:	rpushg 1
31:	pushthis 
32:	rpushg 1
34:	rpushg 1
36:	rpushg 5
38:	rpushg 2
40:	rswap 0
42:	rstoreg 2
44:	pushthis 
45:	rpushg 1
47:	rpushg 1
49:	pushthis 
50:	rpushg 1
52:	rpushg 1
54:	rpushg 5
56:	rpushg 5
58:	rswap 0
60:	rstoreg 5
62:	pushthis 
63:	rpushg 1
65:	rpushg 1
67:	rpushg 5
69:	pushNone 
70:	57
71:	jmpFalse 85
74:	pushthis 
75:	invoke 170 0 0
81:	rpop 
82:	jmp 93
85:	pushthis 
86:	invoke 171 0 0
92:	rpop 
93:	setThisStack
94:	pushthis 
95:	rtn D


Class $170 descInx:170 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 5
20:	pushNone 
21:	rswap 0
23:	rstoreg 6
25:	setThisStack
26:	pushthis 
27:	rtn D


Class $171 descInx:171 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	pushNone 
19:	rswap 0
21:	rstoreg 4
23:	setThisStack
24:	pushthis 
25:	rtn D


Class $172 descInx:172 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 2
18:	pushc 1
20:	storeg 3
22:	pushthis 
23:	rpushg 1
25:	rpushg 1
27:	pushc 0
29:	storeg 5
31:	pushthis 
32:	rpushg 1
34:	rpushg 1
36:	rpushg 2
38:	pushc 50
40:	%prim attach 10 D
43:	rpop 
44:	pushthis 
45:	rpushg 1
47:	rpushg 1
49:	pushc 1
51:	storeg 5
53:	pushthis 
54:	rpushg 1
56:	rpushg 1
58:	rpushg 2
60:	pushg 3
62:	pushc 1
64:	eq 
65:	jmpFalse 76
68:	pushthis 
69:	invoke 174 0 0
75:	rpop 
76:	setThisStack
77:	pushthis 
78:	rtn D


Class $174 descInx:174 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 3
20:	rpushg 6
22:	pushthis 
23:	rpushg 1
25:	rpushg 1
27:	rpushg 1
29:	rpushg 2
31:	invoke 139 0 0
37:	rpop 
38:	setThisStack
39:	pushthis 
40:	rtn D


Class isEmpty descInx:175 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	invoke 176 0 0
18:	rpop 
19:	setThisStack
20:	pushthis 
21:	rtn D


Class entry$176 descInx:176 objSize:2 originOff: 2 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 2
4:	pushthis 
5:	rpushg 2
7:	rpushg 1
9:	tstOriginNone 
10:	rstore 1
12:	allocEventQ 0
allocE: 
14:	rtnAlloc 1
16:	toSuper 95
doE: 
19:	mvStack
20:	pushthis 
21:	rpushg 2
23:	pushthis 
24:	rpushg 2
26:	rpushg 1
28:	rpushg 2
30:	invoke 177 0 0
36:	pushg 2
38:	storeg 2
40:	rtnInner


Class isEmpty descInx:177 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	rpushg 4
17:	pushNone 
18:	req 
19:	storeg 2
21:	setThisStack
22:	pushthis 
23:	rtn D


Class $178 descInx:178 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 3
18:	rpushg 6
20:	invoke 179 0 0
26:	pushg 2
28:	jmpFalse 39
31:	pushthis 
32:	invoke 181 0 0
38:	rpop 
39:	pushthis 
40:	rpushg 1
42:	rpushg 1
44:	rpushg 3
46:	rpushg 5
48:	invoke 182 0 0
54:	rpop 
55:	pushthis 
56:	rpushg 1
58:	rpushg 1
60:	rpushg 3
62:	rpushg 5
64:	invoke 184 0 0
70:	pushg 2
72:	jmpFalse 83
75:	pushthis 
76:	invoke 186 0 0
82:	rpop 
83:	setThisStack
84:	pushthis 
85:	rtn D


Class hasWaiting descInx:179 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	invoke 180 0 0
18:	rpop 
19:	setThisStack
20:	pushthis 
21:	rtn D


Class entry$180 descInx:180 objSize:2 originOff: 2 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 2
4:	pushthis 
5:	rpushg 2
7:	rpushg 1
9:	tstOriginNone 
10:	rstore 1
12:	allocEventQ 0
allocE: 
14:	rtnAlloc 1
16:	toSuper 95
doE: 
19:	mvStack
20:	pushthis 
21:	rpushg 2
23:	pushthis 
24:	rpushg 2
26:	rpushg 1
28:	pushg 5
30:	pushc 0
32:	gt 
33:	storeg 2
35:	rtnInner


Class $181 descInx:181 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushc 100
13:	%prim sleep 15
15:	break 2 1 165 0
22:	setThisStack
23:	pushthis 
24:	rtn D


Class dcr descInx:182 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	invoke 183 0 0
18:	rpop 
19:	setThisStack
20:	pushthis 
21:	rtn D


Class entry$183 descInx:183 objSize:2 originOff: 2 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 2
4:	pushthis 
5:	rpushg 2
7:	rpushg 1
9:	tstOriginNone 
10:	rstore 1
12:	allocEventQ 0
allocE: 
14:	rtnAlloc 1
16:	toSuper 129
doE: 
19:	mvStack
20:	pushthis 
21:	rpushg 2
23:	rpushg 1
25:	pushthis 
26:	rpushg 2
28:	rpushg 1
30:	pushg 3
32:	pushc 1
34:	-
35:	storeg 3
37:	rtnInner


Class running descInx:184 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	invoke 185 0 0
18:	rpop 
19:	setThisStack
20:	pushthis 
21:	rtn D


Class entry$185 descInx:185 objSize:2 originOff: 2 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 2
4:	pushthis 
5:	rpushg 2
7:	rpushg 1
9:	tstOriginNone 
10:	rstore 1
12:	allocEventQ 0
allocE: 
14:	rtnAlloc 1
16:	toSuper 129
doE: 
19:	mvStack
20:	pushthis 
21:	rpushg 2
23:	pushthis 
24:	rpushg 2
26:	rpushg 1
28:	pushg 3
30:	pushc 0
32:	gt 
33:	storeg 2
35:	rtnInner


Class $186 descInx:186 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushc 50
13:	%prim sleep 15
15:	pushthis 
16:	rpushg 1
18:	rpushg 1
20:	rpushg 1
22:	rpushg 3
24:	rpushg 5
26:	invoke 128 0 0
32:	rpop 
33:	break 2 1 165 0
40:	setThisStack
41:	pushthis 
42:	rtn D


Class $187 descInx:187 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	break 1 1 165 0
18:	setThisStack
19:	pushthis 
20:	rtn D


Class MonitorSystem descInx:188 objSize:10 originOff: 10 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 10
4:	pushthis 
5:	rpushg 10
7:	rpushg 1
9:	rpushg 1
11:	rpushg 3
13:	rpushg 4
15:	tstOriginNone 
16:	rstore 1
18:	allocEventQ 0
allocE: 
20:	pushc 4
22:	pushthis 
23:	storeg 2
25:	pushthis 
26:	invoke 73 3 1
32:	rpop 
33:	pushthis 
34:	invoke 74 4 1
40:	rpop 
41:	pushthis 
42:	invoke 75 5 1
48:	rpop 
49:	pushthis 
50:	invoke 77 6 1
56:	rpop 
57:	pushText 17
59:	invoke 76 7 1
65:	rpop 
66:	pushthis 
67:	invoke 80 8 1
73:	rpop 
74:	pushthis 
75:	invoke 85 9 1
81:	rpop 
82:	rtnAlloc 1
84:	toSuper 72
doE: 
87:	mvStack
88:	pushthis 
89:	innerP 3
91:	rpopThisObj
92:	rtnInner


Class MonitorDemo descInx:189 objSize:14 originOff: 11 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 11
4:	pushthis 
5:	rpushg 11
7:	rpushg 1
9:	rpushg 1
11:	rpushg 3
13:	rpushg 7
15:	tstOriginNone 
16:	rstore 10
18:	pushthis 
19:	rpushg 10
21:	rpushg 1
23:	rpushg 1
25:	rpushg 3
27:	rpushg 4
29:	tstOriginNone 
30:	rstore 1
32:	allocEventQ 0
allocE: 
34:	pushc 4
36:	pushthis 
37:	storeg 2
39:	pushthis 
40:	invoke 73 3 1
46:	rpop 
47:	pushthis 
48:	invoke 74 4 1
54:	rpop 
55:	pushthis 
56:	invoke 75 5 1
62:	rpop 
63:	pushthis 
64:	invoke 77 6 1
70:	rpop 
71:	pushText 41
73:	invoke 76 7 1
79:	rpop 
80:	pushthis 
81:	invoke 80 8 1
87:	rpop 
88:	pushthis 
89:	invoke 85 9 1
95:	rpop 
96:	pushthis 
97:	invoke 191 12 1
103:	rpop 
104:	pushthis 
105:	invoke 217 13 1
111:	rpop 
112:	pushthis 
113:	invoke 218 14 1
119:	rpop 
120:	rtnAlloc 1
122:	toSuper 72
doE: 
125:	mvStack
126:	pushthis 
127:	rpushg 13
129:	invoke 224 0 0
135:	rpop 
136:	pushthis 
137:	rpushg 12
139:	invoke 225 0 0
145:	rpop 
146:	pushthis 
147:	rpushg 14
149:	invoke 225 0 0
155:	rpop 
156:	rtnInner


Class MonitorProcess descInx:190 objSize:4 originOff: 4 visibility: 0
storeOrgAndArgsE:
1:	rshiftup 1
3:	tstOriginNone 
4:	rstore 4
6:	pushthis 
7:	rpushg 4
9:	rshiftdown 1
11:	rshiftup 1
13:	tstOriginNone 
14:	rstore 4
16:	pushthis 
17:	rpushg 4
19:	rpushg 1
21:	rpushg 1
23:	rpushg 1
25:	rpushg 2
27:	rshiftdown 1
29:	pushthis 
30:	rstoreg 2
32:	tstOriginNone 
33:	rstore 1
35:	allocEventQ 1
allocE: 
37:	rtnAlloc 1
39:	toSuper 82
doE: 
42:	mvStack
43:	pushthis 
44:	innerP 9
46:	rpopThisObj
47:	rtnInner


Class P1 descInx:191 objSize:4 originOff: 4 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushthis 
5:	rpushg 4
7:	pushText 5
9:	rshiftup 1
11:	tstOriginNone 
12:	rstore 4
14:	pushthis 
15:	rpushg 4
17:	rshiftdown 1
19:	rshiftup 1
21:	tstOriginNone 
22:	rstore 4
24:	pushthis 
25:	rpushg 4
27:	rpushg 1
29:	rpushg 1
31:	rpushg 1
33:	rpushg 2
35:	rshiftdown 1
37:	pushthis 
38:	rstoreg 2
40:	tstOriginNone 
41:	rstore 1
43:	allocEventQ 1
allocE: 
45:	rtnAlloc 1
47:	toSuper 82
doE: 
50:	mvStack
51:	pushthis 
52:	rpushg 4
54:	rpushg 13
56:	pushText 9
58:	invoke 200 0 0
64:	rpop 
65:	pushthis 
66:	invoke 214 0 0
72:	rpop 
73:	rtnInner


Class entry descInx:192 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 2
16:	invoke 193 0 0
22:	rpop 
23:	pushthis 
24:	rpushg 1
26:	pushthis 
27:	rpushg 1
29:	pushg 3
31:	pushc 1
33:	+
34:	storeg 3
36:	pushthis 
37:	innerP 2
39:	rpopThisObj
40:	pushthis 
41:	rpushg 1
43:	rpushg 2
45:	invoke 198 0 0
51:	rpop 
52:	setThisStack
53:	pushthis 
54:	rtn D


Class wait descInx:193 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 2
16:	invoke 96 0 0
22:	rpop 
23:	pushthis 
24:	rpushg 1
26:	pushthis 
27:	rpushg 1
29:	pushg 1
31:	pushc 1
33:	-
34:	storeg 1
36:	pushthis 
37:	rpushg 1
39:	pushg 1
41:	pushc 0
43:	lt
44:	jmpFalse 58
47:	pushthis 
48:	invoke 194 0 0
54:	rpop 
55:	jmp 66
58:	pushthis 
59:	invoke 197 0 0
65:	rpop 
66:	setThisStack
67:	pushthis 
68:	rtn D


Class $194 descInx:194 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	%prim disable 11
13:	pushthis 
14:	rpushg 1
16:	%prim thisCore 17
18:	rpushg 2
20:	rpushg 2
22:	rswap 0
24:	rstoreg 2
26:	pushthis 
27:	rpushg 1
29:	rpushg 1
31:	rpushg 3
33:	pushthis 
34:	rpushg 1
36:	rpushg 2
38:	invoke 142 0 0
44:	rpop 
45:	%prim enable 12
47:	pushthis 
48:	rpushg 1
50:	rpushg 1
52:	rpushg 2
54:	invoke 109 0 0
60:	rpop 
61:	pushthis 
62:	rpushg 1
64:	rpushg 2
66:	invokev 4 0 0
70:	rpop 
71:	pushthis 
72:	rpushg 1
74:	rpushg 2
76:	susp 
77:	setThisStack
78:	pushthis 
79:	rtn D


Class $197 descInx:197 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 2
18:	invoke 109 0 0
24:	rpop 
25:	setThisStack
26:	pushthis 
27:	rtn D


Class signal descInx:198 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 2
16:	invoke 96 0 0
22:	rpop 
23:	pushthis 
24:	rpushg 1
26:	pushthis 
27:	rpushg 1
29:	pushg 1
31:	pushc 1
33:	+
34:	storeg 1
36:	pushthis 
37:	rpushg 1
39:	pushg 1
41:	pushc 0
43:	le
44:	jmpFalse 55
47:	pushthis 
48:	invoke 199 0 0
54:	rpop 
55:	pushthis 
56:	rpushg 1
58:	rpushg 2
60:	invoke 109 0 0
66:	rpop 
67:	setThisStack
68:	pushthis 
69:	rtn D


Class $199 descInx:199 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	%prim disable 11
13:	pushthis 
14:	rpushg 1
16:	pushthis 
17:	rpushg 1
19:	rpushg 1
21:	rpushg 3
23:	invoke 168 0 0
29:	rpushg 2
31:	rswap 0
33:	rstoreg 2
35:	pushthis 
36:	rpushg 1
38:	rpushg 2
40:	invokev 3 0 0
44:	rpop 
45:	%prim enable 12
47:	setThisStack
48:	pushthis 
49:	rtn D


Class print descInx:200 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	pushthis 
8:	rpushg 1
10:	tstOriginNone 
11:	rstore 1
13:	allocEventQ 0
allocE: 
15:	rtnAlloc 1
17:	toSuper 192
doE: 
20:	mvStack
21:	pushthis 
22:	rpushg 2
24:	invoke 103 0 0
30:	rpop 
31:	rtnInner


Class repeat$201 descInx:201 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	rpushg 4
18:	rpushg 13
20:	pushText 1
22:	pushthis 
23:	rpushg 1
25:	pushg 3
27:	pushthis 
28:	rpushg 1
30:	rpushg 4
32:	pushthis 
33:	rpushg 1
35:	pushg 3
37:	invoke 202 0 0
43:	pushg 3
45:	invoke 206 0 0
51:	rpop 
52:	setThisStack
53:	pushthis 
54:	rtn D


Class fac descInx:202 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	pushg 2
17:	pushc 1
19:	eq 
20:	jmpFalse 34
23:	pushthis 
24:	invoke 203 0 0
30:	rpop 
31:	jmp 42
34:	pushthis 
35:	invoke 204 0 0
41:	rpop 
42:	setThisStack
43:	pushthis 
44:	rtn D


Class $203 descInx:203 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushc 1
16:	storeg 3
18:	setThisStack
19:	pushthis 
20:	rtn D


Class $204 descInx:204 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushthis 
15:	rpushg 1
17:	pushg 2
19:	pushthis 
20:	rpushg 1
22:	rpushg 1
24:	pushthis 
25:	rpushg 1
27:	pushg 2
29:	pushc 1
31:	-
32:	invoke 202 0 0
38:	pushg 3
40:	*
41:	storeg 3
43:	setThisStack
44:	pushthis 
45:	rtn D


Class putItem:value:res descInx:206 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 4
4:	pushthis 
5:	storeg 3
7:	pushthis 
8:	rstoreg 2
10:	tstOriginNone 
11:	rstore 1
13:	pushthis 
14:	rpushg 1
16:	tstOriginNone 
17:	rstore 1
19:	allocEventQ 0
allocE: 
21:	rtnAlloc 1
23:	toSuper 192
doE: 
26:	mvStack
27:	pushc 10
29:	%prim put 2
31:	pushc 60
33:	%prim put 2
35:	pushthis 
36:	rpushg 2
38:	invoke 103 0 0
44:	rpop 
45:	pushthis 
46:	pushg 3
48:	invoke 207 0 0
54:	rpop 
55:	pushText 5
57:	invoke 103 0 0
63:	rpop 
64:	pushthis 
65:	pushg 4
67:	invoke 207 0 0
73:	rpop 
74:	pushc 62
76:	%prim put 2
78:	rtnInner


Class putint descInx:207 objSize:4 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushc 20
9:	pushthis 
10:	pushc 1
12:	allocIndexed 86 1 0 
17:	pushthis 
18:	rstoreg 2
20:	rtnAlloc 1
doE: 
22:	doEventQ 
23:	mvStack
24:	pushthis 
25:	pushthis 
26:	pushg 1
28:	pushc 0
30:	lt
31:	storeg 4
33:	pushthis 
34:	pushg 4
36:	jmpFalse 47
39:	pushthis 
40:	invoke 208 0 0
46:	rpop 
47:	pushthis 
48:	invoke 226 0 0
54:	rpop 
55:	pushthis 
56:	pushg 4
58:	jmpFalse 69
61:	pushthis 
62:	invoke 209 0 0
68:	rpop 
69:	pushthis 
70:	invoke 213 0 0
76:	rpop 
77:	setThisStack
78:	pushthis 
79:	rtn D


Class $208 descInx:208 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushc 0
16:	pushthis 
17:	rpushg 1
19:	pushg 1
21:	-
22:	storeg 1
24:	setThisStack
25:	pushthis 
26:	rtn D


Class $209 descInx:209 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushc 45
13:	%prim put 2
15:	setThisStack
16:	pushthis 
17:	rtn D


Class repeat$210 descInx:210 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	rpushg 4
17:	pushg 3
19:	pushc 1
21:	+
22:	pushthis 
23:	rpushg 1
25:	pushg 3
27:	-
28:	storeg 2
30:	pushc 48
32:	pushthis 
33:	rpushg 1
35:	rpushg 4
37:	rpushg 2
39:	pushthis 
40:	pushg 2
42:	xpushg 1 0 1
46:	+
47:	%prim put 2
49:	setThisStack
50:	pushthis 
51:	rtn D


Class for:to:repeat$213 descInx:213 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	pushg 3
11:	pushthis 
12:	storeg 2
14:	pushthis 
15:	storeg 1
17:	allocEventQ 0
allocE: 
19:	rtnAlloc 1
21:	toSuper 28
doE: 
24:	mvStack
25:	rtnInner


Class for:to:repeat$214 descInx:214 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushc 5
8:	pushthis 
9:	storeg 2
11:	pushthis 
12:	storeg 1
14:	allocEventQ 0
allocE: 
16:	rtnAlloc 1
18:	toSuper 28
doE: 
21:	mvStack
22:	rtnInner


Class Monitor descInx:215 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushc 1
9:	invoke 216 2 1
15:	rpop 
16:	rtnAlloc 1
doE: 
18:	doEventQ 
19:	mvStack
20:	pushthis 
21:	innerP 3
23:	rpopThisObj
24:	setThisStack
25:	pushthis 
26:	rtn D


Class Semaphore descInx:216 objSize:3 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushText 1
9:	invoke 76 2 1
15:	rpop 
16:	invoke 78 3 1
22:	rpop 
23:	rtnAlloc 1
doE: 
25:	doEventQ 
26:	mvStack
27:	pushthis 
28:	rpushg 3
30:	pushText 8
32:	rswap 0
34:	rstoreg 1
36:	setThisStack
37:	pushthis 
38:	rtn D


Class myM descInx:217 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	pushc 1
14:	invoke 216 2 1
20:	rpop 
21:	rtnAlloc 1
23:	toSuper 215
doE: 
26:	mvStack
27:	rtnInner


Class P2 descInx:218 objSize:4 originOff: 4 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushthis 
5:	rpushg 4
7:	pushText 5
9:	rshiftup 1
11:	tstOriginNone 
12:	rstore 4
14:	pushthis 
15:	rpushg 4
17:	rshiftdown 1
19:	rshiftup 1
21:	tstOriginNone 
22:	rstore 4
24:	pushthis 
25:	rpushg 4
27:	rpushg 1
29:	rpushg 1
31:	rpushg 1
33:	rpushg 2
35:	rshiftdown 1
37:	pushthis 
38:	rstoreg 2
40:	tstOriginNone 
41:	rstore 1
43:	allocEventQ 1
allocE: 
45:	rtnAlloc 1
47:	toSuper 82
doE: 
50:	mvStack
51:	pushthis 
52:	rpushg 4
54:	rpushg 13
56:	pushText 9
58:	invoke 200 0 0
64:	rpop 
65:	pushthis 
66:	invoke 223 0 0
72:	rpop 
73:	rtnInner


Class repeat$219 descInx:219 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	rpushg 4
18:	rpushg 13
20:	pushText 1
22:	pushthis 
23:	rpushg 1
25:	pushg 3
27:	pushthis 
28:	rpushg 1
30:	rpushg 4
32:	pushthis 
33:	rpushg 1
35:	pushg 3
37:	invoke 220 0 0
43:	pushg 3
45:	invoke 206 0 0
51:	rpop 
52:	setThisStack
53:	pushthis 
54:	rtn D


Class sum descInx:220 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	invoke 222 0 0
21:	rpop 
22:	setThisStack
23:	pushthis 
24:	rtn D


Class repeat$221 descInx:221 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	pushthis 
17:	rpushg 1
19:	rpushg 4
21:	pushg 3
23:	pushthis 
24:	rpushg 1
26:	rpushg 4
28:	pushg 2
30:	+
31:	storeg 3
33:	setThisStack
34:	pushthis 
35:	rtn D


Class for:to:repeat$222 descInx:222 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushc 10
8:	pushthis 
9:	storeg 2
11:	pushthis 
12:	storeg 1
14:	allocEventQ 0
allocE: 
16:	rtnAlloc 1
18:	toSuper 28
doE: 
21:	mvStack
22:	rtnInner


Class for:to:repeat$223 descInx:223 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushc 6
8:	pushthis 
9:	storeg 2
11:	pushthis 
12:	storeg 1
14:	allocEventQ 0
allocE: 
16:	rtnAlloc 1
18:	toSuper 28
doE: 
21:	mvStack
22:	rtnInner


Class init descInx:224 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 192
doE: 
17:	mvStack
18:	pushText 5
20:	invoke 103 0 0
26:	rpop 
27:	pushthis 
28:	innerP 1
30:	rpopThisObj
31:	rtnInner


Class start descInx:225 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	pushthis 
11:	rpushg 1
13:	tstOriginNone 
14:	rstore 1
16:	allocEventQ 0
allocE: 
18:	rtnAlloc 1
20:	toSuper 132
doE: 
23:	mvStack
24:	rtnInner


Class loop descInx:226 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushthis 
15:	rpushg 1
17:	pushg 3
19:	pushc 1
21:	+
22:	storeg 3
24:	pushthis 
25:	rpushg 1
27:	rpushg 2
29:	pushthis 
30:	rpushg 1
32:	pushg 1
34:	pushc 10
36:	modd
37:	pushthis 
38:	rpushg 1
40:	pushg 3
42:	xstoreg 1 0 1 
46:	pushthis 
47:	rpushg 1
49:	pushthis 
50:	rpushg 1
52:	pushg 1
54:	pushc 10
56:	idiv
57:	storeg 1
59:	pushthis 
60:	rpushg 1
62:	pushg 1
64:	pushc 0
66:	gt 
67:	jmpFalse 78
70:	pushthis 
71:	invoke 229 0 0
77:	rpop 
78:	setThisStack
79:	pushthis 
80:	rtn D


Class $229 descInx:229 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	break 1 1 226 0
18:	setThisStack
19:	pushthis 
20:	rtn D


Class valProx descInx:230 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	0


Class VM descInx:231 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	invoke 1 0 1
8:	stop 
9:	rtn D


Class EventProcessor descInx:232 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	stop 


Class ThreadStub descInx:233 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
doE: 
1:	call D
3:	stop 

