 -- QBETA
 -- OG:markForCodeGen:%modules BETA, LIB, LIB.String | error:  |    %basic 999 |  ...
 -- OG:markIS:%modules BETA, LIB, LIB.String | error:  |    %basic 999 | --BETA | - ...
 -- items:markForCodeGen:%modules BETA, LIB, LIB.String | error:  |    %basic 9 ...
 -- markItem:"%modules BETA, LIB, LIB.String" Property
 -- OG:markForCodeGen:%OSDvisibility disguised | %public | universal: Value |     ...
 -- OG:markIS:%OSDvisibility disguised | %public | universal: Value |    %basic 1 ...
 -- items:markForCodeGen:%OSDvisibility disguised | %public | universal: Value |  ...
 -- markItem:"%OSDvisibility disguised" Property
 -- markItem:"%public" Property
 -- DataItem:markForCodeGen:ascii:descNo:0 :OG.primNo:0 
 -- OG:markForCodeGen:nl: val 10 | cr: val 13 | newline: var char | newline := cr ...
 -- OG:markIS:nl: val 10 | cr: val 13 | newline: var char | newline := cr -- Wind ...
 -- items:markForCodeGen:nl: val 10 | cr: val 13 | newline: var char | newline := ...
 -- DataItem:markForCodeGen:nl:descNo:0 :OG.primNo:1 
 -- ObjCall:markSuper:10
 -- Invocation:markForCodeGen:10
 -- DataItem:markForCodeGen:cr:descNo:0 :OG.primNo:1 
 -- ObjCall:markSuper:13
 -- Invocation:markForCodeGen:13
 -- DataItem:markForCodeGen:newline:descNo:0 :OG.primNo:3 
 -- ObjCall:markSuper:char
 -- Invocation:markForCodeGen:char
 -- ObjectInvocation:markForCodeGen:char ATd:char: value |    %globals |    %ba ...
 -- Pattern:markForCodeGen:char: value |    %globals |    %basic 3, 16 |    %publ ...
 -- OG:markForCodeGen:value |    %globals |    %basic 3, 16 |    %public |    _this ...
 -- OG:markSuper:value
 -- Invocation:markForCodeGen:value
 -- ObjectInvocation:markForCodeGen:value ATd:Value:  |    %globals |    %basic ...
 -- Pattern:markForCodeGen:Value:  |    %globals |    %basic 21 |    %public |    : ...
 -- OG:markForCodeGen:%globals | %basic 21 | %public | := :  |    %basic 8 |    in V: ...
 -- OG:markIS:%globals | %basic 21 | %public | := :  |    %basic 8 |    in V: var Val ...
 -- items:markForCodeGen:%globals | %basic 21 | %public | := :  |    %basic 8 |    in ...
 -- markItem:"%globals" Property
 -- markItem:"%basic 21" Property
 -- markItem:"%public" Property
 -- ComputeVariant:A:Value
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:%globals | %basic 21 | %public | := :  |    %basic 8 |    in V: var V ...
 -- :varNo:1 :allocDone:false
 -- OG:Qalloc:SuperAlloc:Object:  |    %basic 64 |    %public |    := :  |       %b ...
 -- :OG:Qalloc:B:Value:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:1 IS.newDescNo:1 :objSize:0 varNo:1 %globals |  ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:0 originOff:0 
 -- Pattern:Qalloc::=
 -- IS.newDescNo:1 IS.objSize:0 :%globals | %basic 21 | %public | := :  |    %basic ...
 -- computeVariant:newDescNo:1 IS:%globals | %basic 21 | %public | := :  |    %basi ...
 -- ComputeVariant:B:Value
 -- ObjTmpStack:add::genDone:false Value:%globals | %basic 21 | %public | := :  |   ...
 -- OG:markIS:value |    %globals |    %basic 3, 16 |    %public |    _thisBasicVal ...
 -- items:markForCodeGen:%globals | %basic 3, 16 | %public | _thisBasicValue: var ...
 -- markItem:"%globals" Property
 -- markItem:"%basic 3, 16" Property
 -- markItem:"%public" Property
 -- DataItem:markForCodeGen:_thisBasicValue:descNo:0 :OG.primNo:1 
 -- ObjCall:markSuper:Universal
 -- Invocation:markForCodeGen:Universal
 -- ObjectInvocation:markForCodeGen:Universal ATd:universal: Value |    %basi ...
 -- Pattern:markForCodeGen:universal: Value |    %basic 1, 32 |    %globals |     ...
 -- OG:markForCodeGen:Value |    %basic 1, 32 |    %globals |    + :  |       %basi ...
 -- OG:markSuper:Value
 -- Invocation:markForCodeGen:Value
 -- ObjectInvocation:markForCodeGen:Value ATd:Value:  |    %globals |    %basic ...
 -- Pattern:markForCodeGen:Value:  |    %globals |    %basic 21 |    %public |    : ...
 -- OG:markIS:Value |    %basic 1, 32 |    %globals |    + :  |       %basic 61 |     ...
 -- items:markForCodeGen:%basic 1, 32 | %globals | + :  |    %basic 61 |    in V: v ...
 -- markItem:"%basic 1, 32" Property
 -- markItem:"%globals" Property
 -- ComputeVariant:A:universal
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Value
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:Value |    %basic 1, 32 |    %globals |    + :  |       %basic 61 |   ...
 -- :varNo:1 :allocDone:false
 -- OG:super: Value:  |    %globals |    %basic 21 |    %public |    := :  |       %b ...
 -- :OG:Qalloc:B:universal:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:2 IS.newDescNo:2 :objSize:0 varNo:1 %basic 1, ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super:Value:super:size:0 :noGlobalsInSuper:true
 -- Items:Qalloc:super:B:objSize:0 originOff:0 
 -- Pattern:Qalloc:+
 -- Pattern:Qalloc:-
 -- IS.newDescNo:2 IS.objSize:0 :%basic 1, 32 | %globals | + :  |    %basic 61 |    ...
 -- computeVariant:newDescNo:2 IS:%basic 1, 32 | %globals | + :  |    %basic 61 |   ...
 -- ComputeVariant:B:universal
 -- ObjTmpStack:add::genDone:false universal:Value |    %basic 1, 32 |    %glob ...
 -- ComputeVariant:A:char
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Value
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:value |    %globals |    %basic 3, 16 |    %public |    _thisBasicV ...
 -- :varNo:1 :allocDone:false
 -- OG:super: Value:  |    %globals |    %basic 21 |    %public |    := :  |       %b ...
 -- :OG:Qalloc:B:char:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:3 IS.newDescNo:3 :objSize:0 varNo:1 %globals |  ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super:value:super:size:0 :noGlobalsInSuper:true
 -- Items:Qalloc:super:B:objSize:0 originOff:0 
 -- dataitem:qalloc:_thisBasicValue isValue:true isPrimitive: true isValObj ...true  ...true
 -- Pattern:Qalloc:+
 -- Pattern:Qalloc:-
 -- Pattern:Qalloc:=
 -- Pattern:Qalloc:<
 -- Pattern:Qalloc:<=
 -- Pattern:Qalloc:>
 -- Pattern:Qalloc:>=
 -- Pattern:Qalloc:<>
 -- IS.newDescNo:3 IS.objSize:1 :%globals | %basic 3, 16 | %public | _thisBasicVa ...
 -- computeVariant:newDescNo:3 IS:%globals | %basic 3, 16 | %public | _thisBasicV ...
 -- ComputeVariant:B:char
 -- ObjTmpStack:add::genDone:false char:value |    %globals |    %basic 3, 16 |   ...
 -- markItem:"newline := cr -- Windows/Linux???" ObjectCall
 -- ObjCall:markSuper:newline := cr -- Windows/Linux???
 -- Invocation:markForCodeGen:newline := cr -- Windows/Linux???
 -- ObjectInvocation:markForCodeGen:newline ATd:newline: var char
 -- DataItem:markForCodeGen:newline:descNo:0 :OG.primNo:3 
 -- ObjectInvocation:markForCodeGen::= cr -- Windows/Linux??? ATd::= :  |     ...
 -- Pattern:markForCodeGen::= :  |    %basic 8 |    in V: var Value
 -- OG:markForCodeGen:%basic 8 | in V: var Value
 -- OG:markIS:%basic 8 | in V: var Value
 -- items:markForCodeGen:%basic 8 | in V: var Value
 -- markItem:"%basic 8" Property
 -- DataItem:markForCodeGen:V:descNo:0 :OG.primNo:21 
 -- ObjCall:markSuper:Value
 -- Invocation:markForCodeGen:Value
 -- ObjectInvocation:markForCodeGen:Value ATd:Value:  |    %globals |    %basic ...
 -- Pattern:markForCodeGen:Value:  |    %globals |    %basic 21 |    %public |    : ...
 -- ComputeVariant:A::=
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:%basic 8 | in V: var Value
 -- :varNo:1 :allocDone:false
 -- OG:Qalloc:SuperAlloc:Object:  |    %basic 64 |    %public |    := :  |       %b ...
 -- :OG:Qalloc:B::=:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:4 IS.newDescNo:4 :objSize:0 varNo:1 %basic 8 |  ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:2 originOff:1 
 -- dataitem:qalloc:V isValue:true isPrimitive: true isValObj: true isBasic ...false
 -- IS.newDescNo:4 IS.objSize:3 :%basic 8 | in V: var Value
 -- computeVariant:newDescNo:4 IS:%basic 8 | in V: var Value
 -- ComputeVariant:B::=
 -- ObjTmpStack:add::genDone:false := :%basic 8 | in V: var Value
 -- arg: cr -- Windows/Linux???
 -- ComputeVariant:A:ascii
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:nl: val 10 | cr: val 13 | newline: var char | newline := cr -- Wi ...
 -- :varNo:1 :allocDone:false
 -- OG:Qalloc:SuperAlloc:Object:  |    %basic 64 |    %public |    := :  |       %b ...
 -- :OG:Qalloc:B:ascii:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:5 IS.newDescNo:5 :objSize:0 varNo:1 nl: val 1 ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- dataitem:qalloc:nl isValue:true isPrimitive: true isValObj: true isBasi ...true
 -- dataitem:qalloc:cr isValue:true isPrimitive: true isValObj: true isBasi ...true
 -- dataitem:qalloc:newline isValue:true isPrimitive: true isValObj: true i ...true
 -- IS.newDescNo:5 IS.objSize:4 :nl: val 10 | cr: val 13 | newline: var char | ne ...
 -- computeVariant:newDescNo:5 IS:nl: val 10 | cr: val 13 | newline: var char | n ...
 -- ComputeVariant:B:ascii
 -- ObjTmpStack:add::genDone:false nl: val 10 | cr: val 13 | newline: var char |  ...
 -- ComputeVariant:A:BETA
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:%OSDvisibility disguised | %public | universal: Value |    %basic ...
 -- :varNo:1 :allocDone:false
 -- OG:Qalloc:SuperAlloc:Object:  |    %basic 64 |    %public |    := :  |       %b ...
 -- :OG:Qalloc:B:BETA:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:6 IS.newDescNo:6 :objSize:0 varNo:1 %OSDvisib ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- Pattern:Qalloc:universal
 -- Pattern:Qalloc:integer
 -- Pattern:Qalloc:Boolean
 -- Pattern:Qalloc:False
 -- Pattern:Qalloc:False
 -- Pattern:Qalloc:True
 -- Pattern:Qalloc:True
 -- Pattern:Qalloc:char
 -- Pattern:Qalloc:universalFloat
 -- Pattern:Qalloc:float
 -- Pattern:Qalloc:put
 -- Pattern:Qalloc:_iget
 -- Pattern:Qalloc:_iget
 -- Pattern:Qalloc:_kbhit
 -- Pattern:Qalloc:_kbhit
 -- Pattern:Qalloc:Object
 -- Pattern:Qalloc:Value
 -- Pattern:Qalloc:none
 -- Pattern:Qalloc:immutable
 -- Pattern:Qalloc:unique
 -- Pattern:Qalloc:unique
 -- Pattern:Qalloc:inner
 -- Pattern:Qalloc:@inner:
 -- Pattern:Qalloc:@this:
 -- Pattern:Qalloc:disable
 -- Pattern:Qalloc:enable
 -- Pattern:Qalloc:fork
 -- Pattern:Qalloc:sleep
 -- Pattern:Qalloc:core
 -- Pattern:Qalloc:core
 -- Pattern:Qalloc:thisCore
 -- Pattern:Qalloc:thisCoreId
 -- Pattern:Qalloc:inSub
 -- Pattern:Qalloc:method
 -- Pattern:Qalloc:method
 -- Pattern:Qalloc:disguised
 -- Pattern:Qalloc:disguised
 -- Pattern:Qalloc:SkipInternal
 -- Pattern:Qalloc:SkipInternal
 -- Pattern:Qalloc:Show
 -- Pattern:Qalloc:Show
 -- Pattern:Qalloc:Indexed
 -- Pattern:Qalloc:@if::then
 -- Pattern:Qalloc:@ifX::thenX
 -- Pattern:Qalloc:@restart:
 -- Pattern:Qalloc:@leave:
 -- Pattern:Qalloc:@if::then:else
 -- Pattern:Qalloc:@if::then:else
 -- Pattern:Qalloc:cycle
 -- Pattern:Qalloc:cycle
 -- Pattern:Qalloc:@for::to:do
 -- Pattern:Qalloc:@for::to:do
 -- Pattern:Qalloc:switch
 -- Pattern:Qalloc:switch
 -- Pattern:Qalloc:@xswitch:
 -- Pattern:Qalloc:@xswitch:
 -- dataitem:qalloc:ascii isValue:false isPrimitive: false isValObj: false  ...false
 -- DI:alloc:off:2 ascii: obj  |    nl: val 10 |    cr: val 13 |    newline: var  ...
 -- Pattern:Qalloc:newline
 -- Pattern:Qalloc:newline
 -- Pattern:Qalloc:putint
 -- Pattern:Qalloc:putint
 -- Pattern:Qalloc:exp
 -- Pattern:Qalloc:exp
 -- Pattern:Qalloc:sqrt
 -- Pattern:Qalloc:sqrt
 -- Pattern:Qalloc:log
 -- Pattern:Qalloc:putFloat
 -- Pattern:Qalloc:putFloatX
 -- Pattern:Qalloc:putFloatX
 -- IS.newDescNo:6 IS.objSize:2 :%OSDvisibility disguised | %public | universal ...
 -- computeVariant:newDescNo:6 IS:%OSDvisibility disguised | %public | universa ...
 -- ComputeVariant:B:BETA
 -- ObjTmpStack:add::genDone:false %OSDvisibility disguised | %public | univers ...
 -- OG:markForCodeGen:%include BETA | x_dummy_LIB: var integer | --Associations ...
 -- OG:markIS:%include BETA | x_dummy_LIB: var integer | --Associations | --Basic ...
 -- items:markForCodeGen:%include BETA | x_dummy_LIB: var integer | --Associati ...
 -- markItem:"%include BETA" Property
 -- DataItem:markForCodeGen:x_dummy_LIB:descNo:0 :OG.primNo:1 
 -- ObjCall:markSuper:integer
 -- Invocation:markForCodeGen:integer
 -- ObjectInvocation:markForCodeGen:integer ATd:integer: value |    %basic 1, ...
 -- Pattern:markForCodeGen:integer: value |    %basic 1, 32 |    %globals |    %p ...
 -- OG:markForCodeGen:value |    %basic 1, 32 |    %globals |    %public |    _this ...
 -- OG:markSuper:value
 -- Invocation:markForCodeGen:value
 -- ObjectInvocation:markForCodeGen:value ATd:Value:  |    %globals |    %basic ...
 -- Pattern:markForCodeGen:Value:  |    %globals |    %basic 21 |    %public |    : ...
 -- OG:markIS:value |    %basic 1, 32 |    %globals |    %public |    _thisBasicVal ...
 -- items:markForCodeGen:%basic 1, 32 | %globals | %public | _thisBasicValue: var ...
 -- markItem:"%basic 1, 32" Property
 -- markItem:"%globals" Property
 -- markItem:"%public" Property
 -- DataItem:markForCodeGen:_thisBasicValue:descNo:0 :OG.primNo:1 
 -- ObjCall:markSuper:Universal
 -- Invocation:markForCodeGen:Universal
 -- ObjectInvocation:markForCodeGen:Universal ATd:universal: Value |    %basi ...
 -- Pattern:markForCodeGen:universal: Value |    %basic 1, 32 |    %globals |     ...
 -- ComputeVariant:A:integer
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Value
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:value |    %basic 1, 32 |    %globals |    %public |    _thisBasicV ...
 -- :varNo:1 :allocDone:false
 -- OG:super: Value:  |    %globals |    %basic 21 |    %public |    := :  |       %b ...
 -- :OG:Qalloc:B:integer:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:7 IS.newDescNo:7 :objSize:0 varNo:1 %basic 1, ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super:value:super:size:0 :noGlobalsInSuper:true
 -- Items:Qalloc:super:B:objSize:0 originOff:0 
 -- dataitem:qalloc:_thisBasicValue isValue:true isPrimitive: true isValObj ...true  ...true
 -- Pattern:Qalloc:+
 -- Pattern:Qalloc:-
 -- Pattern:Qalloc:*
 -- Pattern:Qalloc:/
 -- Pattern:Qalloc://
 -- Pattern:Qalloc:/%
 -- Pattern:Qalloc:=
 -- Pattern:Qalloc:<
 -- Pattern:Qalloc:<=
 -- Pattern:Qalloc:>
 -- Pattern:Qalloc:>=
 -- Pattern:Qalloc:<>
 -- Pattern:Qalloc:cmpAndSwap
 -- IS.newDescNo:7 IS.objSize:1 :%basic 1, 32 | %globals | %public | _thisBasicVa ...
 -- computeVariant:newDescNo:7 IS:%basic 1, 32 | %globals | %public | _thisBasicV ...
 -- ComputeVariant:B:integer
 -- ObjTmpStack:add::genDone:false integer:value |    %basic 1, 32 |    %global ...
 -- OG:markForCodeGen:%include Containers | %Public | Association:  |    %Public |  ...
 -- OG:markIS:%include Containers | %Public | Association:  |    %Public |    ElmTy ...
 -- items:markForCodeGen:%include Containers | %Public | Association:  |    %Publ ...
 -- markItem:"%include Containers" Property
 -- markItem:"%Public" Property
 -- ComputeVariant:A:Associations
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:%include Containers | %Public | Association:  |    %Public |    Elm ...
 -- :varNo:1 :allocDone:false
 -- OG:Qalloc:SuperAlloc:Object:  |    %basic 64 |    %public |    := :  |       %b ...
 -- :OG:Qalloc:B:Associations:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:8 IS.newDescNo:8 :objSize:0 varNo:1 %include  ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- Pattern:Qalloc:Association
 -- Pattern:Qalloc:Association
 -- Pattern:Qalloc:test
 -- Pattern:Qalloc:test
 -- IS.newDescNo:8 IS.objSize:1 :%include Containers | %Public | Association:  |  ...
 -- computeVariant:newDescNo:8 IS:%include Containers | %Public | Association:  ...
 -- ComputeVariant:B:Associations
 -- ObjTmpStack:add::genDone:false %include Containers | %Public | Association: ...
 -- OG:markForCodeGen:%Public | Lock:  |    dummy: var integer |    %Public |    M: ...
 -- OG:markIS:%Public | Lock:  |    dummy: var integer |    %Public |    M: var int ...
 -- items:markForCodeGen:%Public | Lock:  |    dummy: var integer |    %Public |    ...
 -- markItem:"%Public" Property
 -- DataItem:markForCodeGen:keyboard:descNo:0 :OG.primNo:0 
 -- OG:markForCodeGen:%Public | readLine:  |    out M: ref LIB.String.String |    ...
 -- OG:markIS:%Public | readLine:  |    out M: ref LIB.String.String |    inx: va ...
 -- items:markForCodeGen:%Public | readLine:  |    out M: ref LIB.String.String ...
 -- markItem:"%Public" Property
 -- ComputeVariant:A:keyboard
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:%Public | readLine:  |    out M: ref LIB.String.String |    inx:  ...
 -- :varNo:1 :allocDone:false
 -- OG:Qalloc:SuperAlloc:Object:  |    %basic 64 |    %public |    := :  |       %b ...
 -- :OG:Qalloc:B:keyboard:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:9 IS.newDescNo:9 :objSize:0 varNo:1 %Public | r ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- Pattern:Qalloc:readLine
 -- Pattern:Qalloc:readLine
 -- IS.newDescNo:9 IS.objSize:1 :%Public | readLine:  |    out M: ref LIB.Strin ...
 -- computeVariant:newDescNo:9 IS:%Public | readLine:  |    out M: ref LIB.Stri ...
 -- ComputeVariant:B:keyboard
 -- ObjTmpStack:add::genDone:false %Public | readLine:  |    out M: ref LIB.Str ...
 -- DataItem:markForCodeGen:screen:descNo:0 :OG.primNo:0 
 -- OG:markForCodeGen:L: obj Lock | %Public | init:  |    L.get |    L.init |    L.fr ...
 -- OG:markIS:L: obj Lock | %Public | init:  |    L.get |    L.init |    L.free | displ ...
 -- items:markForCodeGen:L: obj Lock | %Public | init:  |    L.get |    L.init |    L ...
 -- DataItem:markForCodeGen:L:descNo:0 :OG.primNo:0 
 -- ObjCall:markSuper:Lock
 -- Invocation:markForCodeGen:Lock
 -- ObjectInvocation:markForCodeGen:Lock ATd:Lock:  |    dummy: var integer |   ...
 -- Pattern:markForCodeGen:Lock:  |    dummy: var integer |    %Public |    M: va ...
 -- OG:markForCodeGen:dummy: var integer | %Public | M: var integer | init:  |    M ...
 -- OG:markIS:dummy: var integer | %Public | M: var integer | init:  |    M := 0 | ge ...
 -- items:markForCodeGen:dummy: var integer | %Public | M: var integer | init:  |   ...
 -- DataItem:markForCodeGen:dummy:descNo:0 :OG.primNo:1 
 -- ObjCall:markSuper:integer
 -- Invocation:markForCodeGen:integer
 -- ObjectInvocation:markForCodeGen:integer ATd:integer: value |    %basic 1, ...
 -- Pattern:markForCodeGen:integer: value |    %basic 1, 32 |    %globals |    %p ...
 -- markItem:"%Public" Property
 -- DataItem:markForCodeGen:M:descNo:0 :OG.primNo:1 
 -- ObjCall:markSuper:integer
 -- Invocation:markForCodeGen:integer
 -- ObjectInvocation:markForCodeGen:integer ATd:integer: value |    %basic 1, ...
 -- Pattern:markForCodeGen:integer: value |    %basic 1, 32 |    %globals |    %p ...
 -- ComputeVariant:A:Lock
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:dummy: var integer | %Public | M: var integer | init:  |    M := 0 |  ...
 -- :varNo:1 :allocDone:false
 -- OG:Qalloc:SuperAlloc:Object:  |    %basic 64 |    %public |    := :  |       %b ...
 -- :OG:Qalloc:B:Lock:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:10 IS.newDescNo:10 :objSize:0 varNo:1 dummy:  ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- dataitem:qalloc:dummy isValue:true isPrimitive: true isValObj: true isB ...true
 -- dataitem:qalloc:M isValue:true isPrimitive: true isValObj: true isBasic ...true
 -- Pattern:Qalloc:init
 -- Pattern:Qalloc:init
 -- Pattern:Qalloc:get
 -- Pattern:Qalloc:get
 -- Pattern:Qalloc:free
 -- Pattern:Qalloc:free
 -- IS.newDescNo:10 IS.objSize:3 :dummy: var integer | %Public | M: var integer ...
 -- computeVariant:newDescNo:10 IS:dummy: var integer | %Public | M: var intege ...
 -- ComputeVariant:B:Lock
 -- ObjTmpStack:add::genDone:false Lock:dummy: var integer | %Public | M: var i ...
 -- markItem:"%Public" Property
 -- ComputeVariant:A:screen
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:L: obj Lock | %Public | init:  |    L.get |    L.init |    L.free | dis ...
 -- :varNo:1 :allocDone:false
 -- OG:Qalloc:SuperAlloc:Object:  |    %basic 64 |    %public |    := :  |       %b ...
 -- :OG:Qalloc:B:screen:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:11 IS.newDescNo:11 :objSize:0 varNo:1 L: obj  ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- dataitem:qalloc:L isValue:false isPrimitive: false isValObj: false isBa ...false
 -- DI:alloc:off:2 L: obj Lock
 -- Pattern:Qalloc:init
 -- Pattern:Qalloc:init
 -- Pattern:Qalloc:display
 -- Pattern:Qalloc:display
 -- IS.newDescNo:11 IS.objSize:2 :L: obj Lock | %Public | init:  |    L.get |    L. ...
 -- computeVariant:newDescNo:11 IS:L: obj Lock | %Public | init:  |    L.get |    L ...
 -- ComputeVariant:B:screen
 -- ObjTmpStack:add::genDone:false L: obj Lock | %Public | init:  |    L.get |    L ...
 -- ComputeVariant:A:BasicIO
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:%Public | Lock:  |    dummy: var integer |    %Public |    M: var i ...
 -- :varNo:1 :allocDone:false
 -- OG:Qalloc:SuperAlloc:Object:  |    %basic 64 |    %public |    := :  |       %b ...
 -- :OG:Qalloc:B:BasicIO:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:12 IS.newDescNo:12 :objSize:0 varNo:1 %Public ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- Pattern:Qalloc:Lock
 -- Pattern:Qalloc:Lock
 -- dataitem:qalloc:keyboard isValue:false isPrimitive: false isValObj: false  ...false
 -- DI:alloc:off:2 keyboard: obj  |    %Public |    readLine:  |       out M: ref ...
 -- dataitem:qalloc:screen isValue:false isPrimitive: false isValObj: false  ...false
 -- DI:alloc:off:3 screen: obj  |    L: obj Lock |    %Public |    init:  |       L ...
 -- IS.newDescNo:12 IS.objSize:3 :%Public | Lock:  |    dummy: var integer |    % ...
 -- computeVariant:newDescNo:12 IS:%Public | Lock:  |    dummy: var integer |     ...
 -- ComputeVariant:B:BasicIO
 -- ObjTmpStack:add::genDone:false %Public | Lock:  |    dummy: var integer |     ...
 -- OG:markForCodeGen:Container:  |    in elm:< Object |    scan:<  |       curre ...
 -- OG:markIS:Container:  |    in elm:< Object |    scan:<  |       current: ref  ...
 -- items:markForCodeGen:Container:  |    in elm:< Object |    scan:<  |       cu ...
 -- OG:markForCodeGen:List:  |    in head: ref Object |    in tail: ref List |    ...
 -- OG:markIS:List:  |    in head: ref Object |    in tail: ref List |    scan:  |  ...
 -- items:markForCodeGen:List:  |    in head: ref Object |    in tail: ref List ...
 -- DataItem:markForCodeGen:XL:descNo:0 :OG.primNo:0 
 -- ObjCall:markSuper:List
 -- Invocation:markForCodeGen:List
 -- ObjectInvocation:markForCodeGen:List ATd:List:  |    in head: ref Object |  ...
 -- Pattern:markForCodeGen:List:  |    in head: ref Object |    in tail: ref Li ...
 -- OG:markForCodeGen:in head: ref Object | in tail: ref List | scan:  |    curre ...
 -- OG:markIS:in head: ref Object | in tail: ref List | scan:  |    current: ref  ...
 -- items:markForCodeGen:in head: ref Object | in tail: ref List | scan:  |    cu ...
 -- DataItem:markForCodeGen:head:descNo:0 :OG.primNo:64 
 -- DataItem:markForCodeGen:tail:descNo:0 :OG.primNo:0 
 -- ObjCall:markSuper:List
 -- Invocation:markForCodeGen:List
 -- ObjectInvocation:markForCodeGen:List ATd:List:  |    in head: ref Object |  ...
 -- Pattern:markForCodeGen:List:  |    in head: ref Object |    in tail: ref Li ...
 -- ComputeVariant:A:List
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:in head: ref Object | in tail: ref List | scan:  |    current: re ...
 -- :varNo:1 :allocDone:false
 -- OG:Qalloc:SuperAlloc:Object:  |    %basic 64 |    %public |    := :  |       %b ...
 -- :OG:Qalloc:B:List:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:13 IS.newDescNo:13 :objSize:0 varNo:1 in head ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- dataitem:qalloc:head isValue:false isPrimitive: true isValObj: false is ...false
 -- DI:alloc:off:2 in head: ref Object
 -- dataitem:qalloc:tail isValue:false isPrimitive: false isValObj: false i ...false
 -- DI:alloc:off:3 in tail: ref List
 -- Pattern:Qalloc:scan
 -- Pattern:Qalloc:scan
 -- IS.newDescNo:13 IS.objSize:3 :in head: ref Object | in tail: ref List | sca ...
 -- computeVariant:newDescNo:13 IS:in head: ref Object | in tail: ref List | sc ...
 -- ComputeVariant:B:List
 -- ObjTmpStack:add::genDone:false List:in head: ref Object | in tail: ref Li ...
 -- markItem:"XL := List(foo("Hello "),list(foo("World\n"),none))" ObjectCa ...
 -- ObjCall:markSuper:XL := List(foo("Hello "),list(foo("World\n"),none))
 -- Invocation:markForCodeGen:XL := List(foo("Hello "),list(foo("World\n"), ...
 -- ObjectInvocation:markForCodeGen:XL ATd:XL: ref List
 -- DataItem:markForCodeGen:XL:descNo:0 :OG.primNo:0 
 -- ObjectInvocation:markForCodeGen::= List(foo("Hello "),list(foo("World\n ..."  ...: ...
 -- Pattern:markForCodeGen::= :  |    %basic 8 |    in V: ref Value
 -- OG:markForCodeGen:%basic 8 | in V: ref Value
 -- OG:markIS:%basic 8 | in V: ref Value
 -- items:markForCodeGen:%basic 8 | in V: ref Value
 -- markItem:"%basic 8" Property
 -- DataItem:markForCodeGen:V:descNo:0 :OG.primNo:21 
 -- ObjCall:markSuper:Value
 -- Invocation:markForCodeGen:Value
 -- ObjectInvocation:markForCodeGen:Value ATd:Value:  |    %globals |    %basic ...
 -- Pattern:markForCodeGen:Value:  |    %globals |    %basic 21 |    %public |    : ...
 -- ComputeVariant:A::=
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:%basic 8 | in V: ref Value
 -- :varNo:1 :allocDone:false
 -- OG:Qalloc:SuperAlloc:Object:  |    %basic 64 |    %public |    := :  |       %b ...
 -- :OG:Qalloc:B::=:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:14 IS.newDescNo:14 :objSize:0 varNo:1 %basic  ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- dataitem:qalloc:V isValue:false isPrimitive: true isValObj: true isBasi ...false
 -- DI:alloc:off:2 in V: ref Value
 -- IS.newDescNo:14 IS.objSize:2 :%basic 8 | in V: ref Value
 -- computeVariant:newDescNo:14 IS:%basic 8 | in V: ref Value
 -- ComputeVariant:B::=
 -- ObjTmpStack:add::genDone:false := :%basic 8 | in V: ref Value
 -- arg: List(foo("Hello "),list(foo("World\n"),none))
 -- ObjCall:markSuper:List(foo("Hello "),list(foo("World\n"),none))
 -- Invocation:markForCodeGen:List(foo("Hello "),list(foo("World\n"),none)) ...
 -- ObjectInvocation:markForCodeGen:List(foo("Hello "),list(foo("World\n"), ...  ...L ...
 -- Pattern:markForCodeGen:List:  |    in head: ref Object |    in tail: ref Li ...
 -- arg: foo("Hello ")
 -- ObjCall:markSuper:foo("Hello ")
 -- Invocation:markForCodeGen:foo("Hello ")
 -- ObjectInvocation:markForCodeGen:foo("Hello ") ATd:foo:  |    in S: ref St ...
 -- Pattern:markForCodeGen:foo:  |    in S: ref String.String |    print:  |      ...
 -- OG:markForCodeGen:in S: ref String.String | print:  |    S.print
 -- OG:markIS:in S: ref String.String | print:  |    S.print
 -- items:markForCodeGen:in S: ref String.String | print:  |    S.print
 -- DataItem:markForCodeGen:S:descNo:0 :OG.primNo:5 
 -- ObjCall:markSuper:String.String
 -- Invocation:markForCodeGen:String.String
 -- ObjectInvocation:markForCodeGen:String ATd:--String
 -- OG:markForCodeGen:%public | String:  |    %OSDvisibility disguised |    %basi ...
 -- OG:markIS:%public | String:  |    %OSDvisibility disguised |    %basic 5 |    % ...
 -- items:markForCodeGen:%public | String:  |    %OSDvisibility disguised |    %b ...
 -- markItem:"%public" Property
 -- Items:markString%public | String:  |    %OSDvisibility disguised |    %basic  ...
 -- Pattern:markForCodeGen:String:  |    %OSDvisibility disguised |    %basic 5 ...
 -- OG:markForCodeGen:%OSDvisibility disguised | %basic 5 | %immutable | %public |  ...
 -- OG:markIS:%OSDvisibility disguised | %basic 5 | %immutable | %public | length:  ...
 -- items:markForCodeGen:%OSDvisibility disguised | %basic 5 | %immutable | %publ ...
 -- markItem:"%OSDvisibility disguised" Property
 -- markItem:"%basic 5" Property
 -- markItem:"%immutable" Property
 -- markItem:"%public" Property
 -- ComputeVariant:A:String
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:%OSDvisibility disguised | %basic 5 | %immutable | %public | length ...
 -- :varNo:1 :allocDone:false
 -- OG:Qalloc:SuperAlloc:Object:  |    %basic 64 |    %public |    := :  |       %b ...
 -- :OG:Qalloc:B:String:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:15 IS.newDescNo:15 :objSize:0 varNo:1 %OSDvis ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- Pattern:Qalloc:length
 -- Pattern:Qalloc:length
 -- Pattern:Qalloc:@get:
 -- Pattern:Qalloc:+
 -- Pattern:Qalloc:+
 -- Pattern:Qalloc:asLowerCase
 -- Pattern:Qalloc:asLowerCase
 -- Pattern:Qalloc:scan
 -- Pattern:Qalloc:scan
 -- Pattern:Qalloc:print
 -- Pattern:Qalloc:print
 -- Pattern:Qalloc:=
 -- Pattern:Qalloc:=
 -- Pattern:Qalloc:<>
 -- Pattern:Qalloc:<>
 -- Pattern:Qalloc:<=
 -- Pattern:Qalloc:<=
 -- IS.newDescNo:15 IS.objSize:1 :%OSDvisibility disguised | %basic 5 | %immuta ...
 -- computeVariant:newDescNo:15 IS:%OSDvisibility disguised | %basic 5 | %immut ...
 -- ComputeVariant:B:String
 -- ObjTmpStack:add::genDone:false String:%OSDvisibility disguised | %basic 5 ...
 -- ComputeVariant:A:String
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:%public | String:  |    %OSDvisibility disguised |    %basic 5 |    ...
 -- :varNo:1 :allocDone:false
 -- OG:Qalloc:SuperAlloc:Object:  |    %basic 64 |    %public |    := :  |       %b ...
 -- :OG:Qalloc:B:String:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:16 IS.newDescNo:16 :objSize:0 varNo:1 %public ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- Pattern:Qalloc:String
 -- Pattern:Qalloc:I2S
 -- Pattern:Qalloc:I2S
 -- IS.newDescNo:16 IS.objSize:1 :%public | String:  |    %OSDvisibility disgui ...
 -- computeVariant:newDescNo:16 IS:%public | String:  |    %OSDvisibility disgu ...
 -- ComputeVariant:B:String
 -- ObjTmpStack:add::genDone:false %public | String:  |    %OSDvisibility disgu ...
 -- ObjectInvocation:markForCodeGen:String ATd:String:  |    %OSDvisibility d ...
 -- Pattern:markForCodeGen:String:  |    %OSDvisibility disguised |    %basic 5 ...
 -- ComputeVariant:A:foo
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:in S: ref String.String | print:  |    S.print
 -- :varNo:1 :allocDone:false
 -- OG:Qalloc:SuperAlloc:Object:  |    %basic 64 |    %public |    := :  |       %b ...
 -- :OG:Qalloc:B:foo:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:17 IS.newDescNo:17 :objSize:0 varNo:1 in S: r ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- dataitem:qalloc:S isValue:false isPrimitive: true isValObj: false isBas ...false
 -- DI:alloc:off:2 in S: ref String.String
 -- Pattern:Qalloc:print
 -- Pattern:Qalloc:print
 -- IS.newDescNo:17 IS.objSize:2 :in S: ref String.String | print:  |    S.prin ...
 -- computeVariant:newDescNo:17 IS:in S: ref String.String | print:  |    S.pri ...
 -- ComputeVariant:B:foo
 -- ObjTmpStack:add::genDone:false foo:in S: ref String.String | print:  |    S ...
 -- arg: "Hello "
 -- ObjCall:markSuper:"Hello "
 -- Invocation:markForCodeGen:"Hello "
 -- arg: list(foo("World\n"),none)
 -- ObjCall:markSuper:list(foo("World\n"),none)
 -- Invocation:markForCodeGen:list(foo("World\n"),none)
 -- ObjectInvocation:markForCodeGen:list(foo("World\n"),none) ATd:List:  |    ...
 -- Pattern:markForCodeGen:List:  |    in head: ref Object |    in tail: ref Li ...
 -- arg: foo("World\n")
 -- ObjCall:markSuper:foo("World\n")
 -- Invocation:markForCodeGen:foo("World\n")
 -- ObjectInvocation:markForCodeGen:foo("World\n") ATd:foo:  |    in S: ref S ...
 -- Pattern:markForCodeGen:foo:  |    in S: ref String.String |    print:  |      ...
 -- arg: "World\n"
 -- ObjCall:markSuper:"World\n"
 -- Invocation:markForCodeGen:"World\n"
 -- arg: none
 -- markItem:"XL.scan |    F: ref Foo |    F := current |    F.print" Objec ...
 -- OG:markForCodeGen:XL.scan |    F: ref Foo |    F := current |    F.print
 -- OG:markSuper:XL.scan
 -- Invocation:markForCodeGen:XL.scan
 -- ObjectInvocation:markForCodeGen:XL ATd:XL: ref List
 -- DataItem:markForCodeGen:XL:descNo:0 :OG.primNo:0 
 -- ObjectInvocation:markForCodeGen:scan ATd:scan:  |    current: ref Object |  ...
 -- Pattern:markForCodeGen:scan:  |    current: ref Object |    L: ref List |     ...
 -- OG:markForCodeGen:current: ref Object | L: ref List | L := @this List | curre ...
 -- OG:markIS:current: ref Object | L: ref List | L := @this List | current := he ...
 -- items:markForCodeGen:current: ref Object | L: ref List | L := @this List | cu ...
 -- DataItem:markForCodeGen:current:descNo:0 :OG.primNo:64 
 -- DataItem:markForCodeGen:L:descNo:0 :OG.primNo:0 
 -- ObjCall:markSuper:List
 -- Invocation:markForCodeGen:List
 -- ObjectInvocation:markForCodeGen:List ATd:List:  |    in head: ref Object |  ...
 -- Pattern:markForCodeGen:List:  |    in head: ref Object |    in tail: ref Li ...
 -- markItem:"L := @this List" ObjectCall
 -- ObjCall:markSuper:L := @this List
 -- Invocation:markForCodeGen:L := @this List
 -- ObjectInvocation:markForCodeGen:L ATd:L: ref List
 -- DataItem:markForCodeGen:L:descNo:0 :OG.primNo:0 
 -- ObjectInvocation:markForCodeGen::= @this List ATd::= :  |    %basic 8 |     ...
 -- Pattern:markForCodeGen::= :  |    %basic 8 |    in V: ref Value
 -- arg: @this List
 -- ObjCall:markSuper:@this List
 -- Invocation:markForCodeGen:@this List
 -- ObjectInvocation:markForCodeGen:@this List ATd:@this:  |    %basic 18 |     ...
 -- Pattern:markForCodeGen:@this:  |    %basic 18 |    in this: ref Object
 -- OG:markForCodeGen:%basic 18 | in this: ref Object
 -- OG:markIS:%basic 18 | in this: ref Object
 -- items:markForCodeGen:%basic 18 | in this: ref Object
 -- markItem:"%basic 18" Property
 -- DataItem:markForCodeGen:this:descNo:0 :OG.primNo:64 
 -- ComputeVariant:A:@this:
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:%basic 18 | in this: ref Object
 -- :varNo:1 :allocDone:false
 -- OG:Qalloc:SuperAlloc:Object:  |    %basic 64 |    %public |    := :  |       %b ...
 -- :OG:Qalloc:B:@this::newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:18 IS.newDescNo:18 :objSize:0 varNo:1 %basic  ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- dataitem:qalloc:this isValue:false isPrimitive: true isValObj: false is ...false
 -- DI:alloc:off:2 in this: ref Object
 -- IS.newDescNo:18 IS.objSize:2 :%basic 18 | in this: ref Object
 -- computeVariant:newDescNo:18 IS:%basic 18 | in this: ref Object
 -- ComputeVariant:B:@this:
 -- ObjTmpStack:add::genDone:false :%basic 18 | in this: ref Object
 -- arg: List
 -- ObjCall:markSuper:List
 -- Invocation:markForCodeGen:List
 -- ObjectInvocation:markForCodeGen:List ATd:List:  |    in head: ref Object |  ...
 -- Pattern:markForCodeGen:List:  |    in head: ref Object |    in tail: ref Li ...
 -- markItem:"current := head" ObjectCall
 -- ObjCall:markSuper:current := head
 -- Invocation:markForCodeGen:current := head
 -- ObjectInvocation:markForCodeGen:current ATd:current: ref Object
 -- DataItem:markForCodeGen:current:descNo:0 :OG.primNo:64 
 -- ObjectInvocation:markForCodeGen::= head ATd::= :  |    %basic 8 |    in V:  ...
 -- Pattern:markForCodeGen::= :  |    %basic 8 |    in V: ref Value
 -- arg: head
 -- markItem:"loop" ObjectCall
 -- ObjCall:markSuper:loop
 -- Invocation:markForCodeGen:loop
 -- ObjectInvocation:markForCodeGen:loop ATd:loop:  |    @inner scan |    @if L ...
 -- Pattern:markForCodeGen:loop:  |    @inner scan |    @if L.tail <> none :the ...
 -- OG:markForCodeGen:@inner scan | @if L.tail <> none :then  |    L := tail |    ...
 -- OG:markIS:@inner scan | @if L.tail <> none :then  |    L := tail |    current ...
 -- items:markForCodeGen:@inner scan | @if L.tail <> none :then  |    L := tail ...
 -- markItem:"@inner scan" ObjectCall
 -- markItem:"@if L.tail <> none :then  |    L := tail |    current := L.head |   ..." O ...
 -- OG:markForCodeGen:@if L.tail <> none :then  |    L := tail |    current :=  ...
 -- OG:markSuper:@if L.tail <> none :then  |    L := tail |    current := L.hea ...
 -- Invocation:markForCodeGen:@if L.tail <> none :then  |    L := tail |    cur ...
 -- ObjectInvocation:markForCodeGen:@if L.tail <> none :then  |    L := tail |  ...  ...@ ...
 -- Pattern:markForCodeGen:@if:  |    %globals inSub |    %basic 100 |    in if:  ...
 -- OG:markForCodeGen:%globals inSub | %basic 100 | in if: var boolean | in then: ...
 -- OG:markIS:%globals inSub | %basic 100 | in if: var boolean | in then:< Object ...
 -- items:markForCodeGen:%globals inSub | %basic 100 | in if: var boolean | in th ...
 -- markItem:"%globals inSub" Property
 -- markItem:"%basic 100" Property
 -- DataItem:markForCodeGen:if:descNo:0 :OG.primNo:4 
 -- ObjCall:markSuper:boolean
 -- Invocation:markForCodeGen:boolean
 -- ObjectInvocation:markForCodeGen:boolean ATd:Boolean: value |    %globals  ...
 -- Pattern:markForCodeGen:Boolean: value |    %globals inSub |    %basic 4, 8 |  ...
 -- OG:markForCodeGen:value |    %globals inSub |    %basic 4, 8 |    %public |     ...
 -- OG:markSuper:value
 -- Invocation:markForCodeGen:value
 -- ObjectInvocation:markForCodeGen:value ATd:Value:  |    %globals |    %basic ...
 -- Pattern:markForCodeGen:Value:  |    %globals |    %basic 21 |    %public |    : ...
 -- OG:markIS:value |    %globals inSub |    %basic 4, 8 |    %public |    _thisBas ...
 -- items:markForCodeGen:%globals inSub | %basic 4, 8 | %public | _thisBasicValue ...
 -- markItem:"%globals inSub" Property
 -- markItem:"%basic 4, 8" Property
 -- markItem:"%public" Property
 -- DataItem:markForCodeGen:_thisBasicValue:descNo:0 :OG.primNo:1 
 -- ObjCall:markSuper:Universal
 -- Invocation:markForCodeGen:Universal
 -- ObjectInvocation:markForCodeGen:Universal ATd:universal: Value |    %basi ...
 -- Pattern:markForCodeGen:universal: Value |    %basic 1, 32 |    %globals |     ...
 -- ComputeVariant:A:Boolean
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Value
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:value |    %globals inSub |    %basic 4, 8 |    %public |    _thisB ...
 -- :varNo:1 :allocDone:false
 -- OG:super: Value:  |    %globals |    %basic 21 |    %public |    := :  |       %b ...
 -- :OG:Qalloc:B:Boolean:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:19 IS.newDescNo:19 :objSize:0 varNo:1 %global ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super:value:super:size:0 :noGlobalsInSuper:true
 -- Items:Qalloc:super:B:objSize:0 originOff:0 
 -- dataitem:qalloc:_thisBasicValue isValue:true isPrimitive: true isValObj ...true  ...true
 -- Pattern:Qalloc:&&
 -- Pattern:Qalloc:||
 -- Pattern:Qalloc:=
 -- Pattern:Qalloc:not
 -- IS.newDescNo:19 IS.objSize:1 :%globals inSub | %basic 4, 8 | %public | _thisB ...
 -- computeVariant:newDescNo:19 IS:%globals inSub | %basic 4, 8 | %public | _this ...
 -- ComputeVariant:B:Boolean
 -- ObjTmpStack:add::genDone:false Boolean:value |    %globals inSub |    %basi ...
 -- Pattern:markForCodeGen:in then:< Object
 -- OG:markForCodeGen:Object
 -- ComputeVariant:A:@if::then
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:%globals inSub | %basic 100 | in if: var boolean | in then:< Obje ...
 -- :varNo:1 :allocDone:false
 -- OG:Qalloc:SuperAlloc:Object:  |    %basic 64 |    %public |    := :  |       %b ...
 -- :OG:Qalloc:B:@if::then:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:20 IS.newDescNo:20 :objSize:0 varNo:1 %global ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:0 originOff:0 
 -- dataitem:qalloc:if isValue:true isPrimitive: true isValObj: true isBasi ...true
 -- Pattern:Qalloc:then
 -- Pattern:Qalloc:then
 -- (OG.super.desc).newDescNo = 0
 -- OG:Qalloc:A:%basic 64 | %public | := :  |    %basic 8 |    in V: ref Value | :- : ...
 -- :varNo:1 :allocDone:
 -- :OG:Qalloc:B:Object:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:21 IS.newDescNo:21 :objSize:0 varNo:1 %basic  ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- Pattern:Qalloc::=
 -- Pattern:Qalloc::-
 -- Pattern:Qalloc:=
 -- Pattern:Qalloc:<>
 -- Pattern:Qalloc:suspend
 -- Pattern:Qalloc:attach
 -- Pattern:Qalloc:resume
 -- Pattern:Qalloc:onResume
 -- Pattern:Qalloc:onSuspend
 -- Pattern:Qalloc:dumpObj
 -- IS.newDescNo:21 IS.objSize:1 :%basic 64 | %public | := :  |    %basic 8 |    in ...
 -- Pattern:qalloc:super:descNo:21 in then:< Object
 -- IS.newDescNo:20 IS.objSize:1 :%globals inSub | %basic 100 | in if: var bool ...
 -- computeVariant:newDescNo:20 IS:%globals inSub | %basic 100 | in if: var boo ...
 -- ComputeVariant:B:@if::then
 -- ObjTmpStack:add::genDone:false :%globals inSub | %basic 100 | in if: var bo ...
 -- arg: L.tail <> none
 -- ObjCall:markSuper:L.tail <> none
 -- Invocation:markForCodeGen:L.tail <> none
 -- ObjectInvocation:markForCodeGen:L ATd:L: ref List
 -- DataItem:markForCodeGen:L:descNo:0 :OG.primNo:0 
 -- ObjectInvocation:markForCodeGen:tail ATd:in tail: ref List
 -- DataItem:markForCodeGen:tail:descNo:0 :OG.primNo:0 
 -- ObjectInvocation:markForCodeGen:<> none ATd:<> :  |    %basic 57 |    in ob ...
 -- Pattern:markForCodeGen:<> :  |    %basic 57 |    in objx: ref Object |    out ...
 -- arg: none
 -- arg: L := tail | current := L.head | @restart loop
 -- OG:markForCodeGen:L := tail | current := L.head | @restart loop
 -- OG:markIS:L := tail | current := L.head | @restart loop
 -- items:markForCodeGen:L := tail | current := L.head | @restart loop
 -- markItem:"L := tail" ObjectCall
 -- ObjCall:markSuper:L := tail
 -- Invocation:markForCodeGen:L := tail
 -- ObjectInvocation:markForCodeGen:L ATd:L: ref List
 -- DataItem:markForCodeGen:L:descNo:0 :OG.primNo:0 
 -- ObjectInvocation:markForCodeGen::= tail ATd::= :  |    %basic 8 |    in V:  ...
 -- Pattern:markForCodeGen::= :  |    %basic 8 |    in V: ref Value
 -- arg: tail
 -- markItem:"current := L.head" ObjectCall
 -- ObjCall:markSuper:current := L.head
 -- Invocation:markForCodeGen:current := L.head
 -- ObjectInvocation:markForCodeGen:current ATd:current: ref Object
 -- DataItem:markForCodeGen:current:descNo:0 :OG.primNo:64 
 -- ObjectInvocation:markForCodeGen::= L.head ATd::= :  |    %basic 8 |    in V ...
 -- Pattern:markForCodeGen::= :  |    %basic 8 |    in V: ref Value
 -- arg: L.head
 -- markItem:"@restart loop" ObjectCall
 -- ComputeVariant:A:#S#0
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:L := tail | current := L.head | @restart loop
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:#S#0:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:22 IS.newDescNo:22 :objSize:0 varNo:1 L := ta ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- IS.newDescNo:22 IS.objSize:1 :L := tail | current := L.head | @restart loop ...
 -- computeVariant:newDescNo:22 IS:L := tail | current := L.head | @restart loo ...
 -- ComputeVariant:B:#S#22
 -- ObjTmpStack:add::genDone:false L := tail | current := L.head | @restart loo ...
 -- ComputeVariant:A:loop
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:@inner scan | @if L.tail <> none :then  |    L := tail |    curre ...
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:loop:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:23 IS.newDescNo:23 :objSize:0 varNo:1 @inner  ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- OG:Qalloc:A:@if L.tail <> none :then  |    L := tail |    current := L.head ...
 -- :varNo:1 :allocDone:
 -- OG:super: @if:  |    %globals inSub |    %basic 100 |    in if: var boolean |   ...
 -- IS.newDescNo:23 IS.objSize:1 :@inner scan | @if L.tail <> none :then  |     ...
 -- computeVariant:newDescNo:23 IS:@inner scan | @if L.tail <> none :then  |    ...
 -- ComputeVariant:B:loop
 -- ObjTmpStack:add::genDone:false loop:@inner scan | @if L.tail <> none :the ...
 -- ComputeVariant:A:scan
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:current: ref Object | L: ref List | L := @this List | current :=  ...
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:scan:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:24 IS.newDescNo:24 :objSize:0 varNo:1 current ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- dataitem:qalloc:current isValue:false isPrimitive: true isValObj: false  ...false
 -- DI:alloc:off:2 current: ref Object
 -- dataitem:qalloc:L isValue:false isPrimitive: false isValObj: false isBa ...false
 -- DI:alloc:off:3 L: ref List
 -- Pattern:Qalloc:loop
 -- Pattern:Qalloc:loop
 -- IS.newDescNo:24 IS.objSize:3 :current: ref Object | L: ref List | L := @thi ...
 -- computeVariant:newDescNo:24 IS:current: ref Object | L: ref List | L := @th ...
 -- ComputeVariant:B:scan
 -- ObjTmpStack:add::genDone:false scan:current: ref Object | L: ref List | L : ...
 -- OG:markIS:XL.scan |    F: ref Foo |    F := current |    F.print
 -- items:markForCodeGen:F: ref Foo | F := current | F.print
 -- DataItem:markForCodeGen:F:descNo:0 :OG.primNo:0 
 -- ObjCall:markSuper:Foo
 -- Invocation:markForCodeGen:Foo
 -- ObjectInvocation:markForCodeGen:Foo ATd:foo:  |    in S: ref String.Strin ...
 -- Pattern:markForCodeGen:foo:  |    in S: ref String.String |    print:  |      ...
 -- markItem:"F := current" ObjectCall
 -- ObjCall:markSuper:F := current
 -- Invocation:markForCodeGen:F := current
 -- ObjectInvocation:markForCodeGen:F ATd:F: ref Foo
 -- DataItem:markForCodeGen:F:descNo:0 :OG.primNo:0 
 -- ObjectInvocation:markForCodeGen::= current ATd::= :  |    %basic 8 |    in  ...
 -- Pattern:markForCodeGen::= :  |    %basic 8 |    in V: ref Value
 -- arg: current
 -- markItem:"F.print" ObjectCall
 -- ObjCall:markSuper:F.print
 -- Invocation:markForCodeGen:F.print
 -- ObjectInvocation:markForCodeGen:F ATd:F: ref Foo
 -- DataItem:markForCodeGen:F:descNo:0 :OG.primNo:0 
 -- ObjectInvocation:markForCodeGen:print ATd:print:  |    S.print
 -- Pattern:markForCodeGen:print:  |    S.print
 -- OG:markForCodeGen:S.print
 -- OG:markIS:S.print
 -- items:markForCodeGen:S.print
 -- markItem:"S.print" ObjectCall
 -- ObjCall:markSuper:S.print
 -- Invocation:markForCodeGen:S.print
 -- ObjectInvocation:markForCodeGen:S ATd:in S: ref String.String
 -- DataItem:markForCodeGen:S:descNo:0 :OG.primNo:5 
 -- ObjectInvocation:markForCodeGen:print ATd:print:  |    @for 1 :to length  ...
 -- Pattern:markForCodeGen:print:  |    @for 1 :to length  |    :do  |       put( ...
 -- OG:markForCodeGen:@for 1 :to length  | :do  |    put(@get inx)
 -- OG:markIS:@for 1 :to length  | :do  |    put(@get inx)
 -- items:markForCodeGen:@for 1 :to length  | :do  |    put(@get inx)
 -- markItem:"@for 1 :to length  | :do  |    put(@get inx)" ObjectGenerator ...
 -- OG:markForCodeGen:@for 1 :to length  | :do  |    put(@get inx)
 -- OG:markSuper:@for 1 :to length  | :do  |    put(@get inx)
 -- Invocation:markForCodeGen:@for 1 :to length  | :do  |    put(@get inx)
 -- ObjectInvocation:markForCodeGen:@for 1 :to length  | :do  |    put(@get inx ...  ...@ ...
 -- Pattern:markForCodeGen:@for:  |    %globals inSub |    in for: var integer |  ...
 -- OG:markForCodeGen:%globals inSub | in for: var integer | in to: var integer ...
 -- OG:markIS:%globals inSub | in for: var integer | in to: var integer | in do:< ...
 -- items:markForCodeGen:%globals inSub | in for: var integer | in to: var inte ...
 -- markItem:"%globals inSub" Property
 -- DataItem:markForCodeGen:for:descNo:0 :OG.primNo:1 
 -- ObjCall:markSuper:integer
 -- Invocation:markForCodeGen:integer
 -- ObjectInvocation:markForCodeGen:integer ATd:integer: value |    %basic 1, ...
 -- Pattern:markForCodeGen:integer: value |    %basic 1, 32 |    %globals |    %p ...
 -- DataItem:markForCodeGen:to:descNo:0 :OG.primNo:1 
 -- ObjCall:markSuper:integer
 -- Invocation:markForCodeGen:integer
 -- ObjectInvocation:markForCodeGen:integer ATd:integer: value |    %basic 1, ...
 -- Pattern:markForCodeGen:integer: value |    %basic 1, 32 |    %globals |    %p ...
 -- Pattern:markForCodeGen:in do:< Object
 -- OG:markForCodeGen:Object
 -- markItem:"%public" Property
 -- DataItem:markForCodeGen:inx:descNo:0 :OG.primNo:1 
 -- ObjCall:markSuper:integer
 -- Invocation:markForCodeGen:integer
 -- ObjectInvocation:markForCodeGen:integer ATd:integer: value |    %basic 1, ...
 -- Pattern:markForCodeGen:integer: value |    %basic 1, 32 |    %globals |    %p ...
 -- markItem:"%private" Property
 -- markItem:"inx := for" ObjectCall
 -- ObjCall:markSuper:inx := for
 -- Invocation:markForCodeGen:inx := for
 -- ObjectInvocation:markForCodeGen:inx ATd:inx: var integer
 -- DataItem:markForCodeGen:inx:descNo:0 :OG.primNo:1 
 -- ObjectInvocation:markForCodeGen::= for ATd::= :  |    %basic 8 |    in V: v ...
 -- Pattern:markForCodeGen::= :  |    %basic 8 |    in V: var Value
 -- arg: for
 -- markItem:"doIt" ObjectCall
 -- ObjCall:markSuper:doIt
 -- Invocation:markForCodeGen:doIt
 -- ObjectInvocation:markForCodeGen:doIt ATd:doIt:  |    loop: obj  |       @if ...
 -- Pattern:markForCodeGen:doIt:  |    loop: obj  |       @if inx <= to :then  |  ...
 -- OG:markForCodeGen:loop: obj  |    @if inx <= to :then  |       do |       inx ...
 -- OG:markIS:loop: obj  |    @if inx <= to :then  |       do |       inx := inx  ...
 -- items:markForCodeGen:loop: obj  |    @if inx <= to :then  |       do |        ...
 -- DataItem:markForCodeGen:loop:descNo:0 :OG.primNo:0 
 -- OG:markForCodeGen:@if inx <= to :then  |    do |    inx := inx + 1 |    @rest ...
 -- OG:markIS:@if inx <= to :then  |    do |    inx := inx + 1 |    @restart loop ...
 -- items:markForCodeGen:@if inx <= to :then  |    do |    inx := inx + 1 |    @r ...
 -- markItem:"@if inx <= to :then  |    do |    inx := inx + 1 |    @restart loop ..." O ...
 -- OG:markForCodeGen:@if inx <= to :then  |    do |    inx := inx + 1 |    @rest ...
 -- OG:markSuper:@if inx <= to :then  |    do |    inx := inx + 1 |    @restart l ...
 -- Invocation:markForCodeGen:@if inx <= to :then  |    do |    inx := inx + 1 |  ...
 -- ObjectInvocation:markForCodeGen:@if inx <= to :then  |    do |    inx := in ...  ...@ ...
 -- Pattern:markForCodeGen:@if:  |    %globals inSub |    %basic 100 |    in if:  ...
 -- arg: inx <= to
 -- ObjCall:markSuper:inx <= to
 -- Invocation:markForCodeGen:inx <= to
 -- ObjectInvocation:markForCodeGen:inx ATd:inx: var integer
 -- DataItem:markForCodeGen:inx:descNo:0 :OG.primNo:1 
 -- ObjectInvocation:markForCodeGen:<= to ATd:<= :  |    %basic 52 |    in V: v ...
 -- Pattern:markForCodeGen:<= :  |    %basic 52 |    in V: var integer |    out B ...
 -- arg: to
 -- arg: do | inx := inx + 1 | @restart loop
 -- OG:markForCodeGen:do | inx := inx + 1 | @restart loop
 -- OG:markIS:do | inx := inx + 1 | @restart loop
 -- items:markForCodeGen:do | inx := inx + 1 | @restart loop
 -- markItem:"do" ObjectCall
 -- ObjCall:markSuper:do
 -- Invocation:markForCodeGen:do
 -- ObjectInvocation:markForCodeGen:do ATd:in do:< Object
 -- Pattern:markForCodeGen:in do:< Object
 -- markItem:"inx := inx + 1" ObjectCall
 -- ObjCall:markSuper:inx := inx + 1
 -- Invocation:markForCodeGen:inx := inx + 1
 -- ObjectInvocation:markForCodeGen:inx ATd:inx: var integer
 -- DataItem:markForCodeGen:inx:descNo:0 :OG.primNo:1 
 -- ObjectInvocation:markForCodeGen::= inx + 1 ATd::= :  |    %basic 8 |    in  ...
 -- Pattern:markForCodeGen::= :  |    %basic 8 |    in V: var Value
 -- arg: inx + 1
 -- ObjCall:markSuper:inx + 1
 -- Invocation:markForCodeGen:inx + 1
 -- ObjectInvocation:markForCodeGen:inx ATd:inx: var integer
 -- DataItem:markForCodeGen:inx:descNo:0 :OG.primNo:1 
 -- ObjectInvocation:markForCodeGen:+ 1 ATd:+ :  |    %basic 61 |    in V: var  ...
 -- Pattern:markForCodeGen:+ :  |    %basic 61 |    in V: var integer |    out R: ...
 -- arg: 1
 -- ObjCall:markSuper:1
 -- Invocation:markForCodeGen:1
 -- markItem:"@restart loop" ObjectCall
 -- ComputeVariant:A:#S#0
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:do | inx := inx + 1 | @restart loop
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:#S#0:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:25 IS.newDescNo:25 :objSize:0 varNo:1 do | inx  ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- IS.newDescNo:25 IS.objSize:1 :do | inx := inx + 1 | @restart loop
 -- computeVariant:newDescNo:25 IS:do | inx := inx + 1 | @restart loop
 -- ComputeVariant:B:#S#25
 -- ObjTmpStack:add::genDone:false do | inx := inx + 1 | @restart loop
 -- ComputeVariant:A:loop
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:@if inx <= to :then  |    do |    inx := inx + 1 |    @restart lo ...
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:loop:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:26 IS.newDescNo:26 :objSize:0 varNo:1 @if inx ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- OG:Qalloc:A:@if inx <= to :then  |    do |    inx := inx + 1 |    @restart lo ...
 -- :varNo:1 :allocDone:
 -- OG:super: @if:  |    %globals inSub |    %basic 100 |    in if: var boolean |   ...
 -- IS.newDescNo:26 IS.objSize:1 :@if inx <= to :then  |    do |    inx := inx  ...
 -- computeVariant:newDescNo:26 IS:@if inx <= to :then  |    do |    inx := inx ...
 -- ComputeVariant:B:loop
 -- ObjTmpStack:add::genDone:false @if inx <= to :then  |    do |    inx := inx ...
 -- ComputeVariant:A:doIt
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:loop: obj  |    @if inx <= to :then  |       do |       inx := in ...
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:doIt:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:27 IS.newDescNo:27 :objSize:0 varNo:1 loop: o ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- dataitem:qalloc:loop isValue:false isPrimitive: false isValObj: false i ...false
 -- DI:alloc:off:2 loop: obj  |    @if inx <= to :then  |       do |       inx := ...
 -- IS.newDescNo:27 IS.objSize:2 :loop: obj  |    @if inx <= to :then  |        ...
 -- computeVariant:newDescNo:27 IS:loop: obj  |    @if inx <= to :then  |       ...
 -- ComputeVariant:B:doIt
 -- ObjTmpStack:add::genDone:false doIt:loop: obj  |    @if inx <= to :then  |  ...
 -- markItem:"@inner for" ObjectCall
 -- ComputeVariant:A:@for::to:do
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:%globals inSub | in for: var integer | in to: var integer | in do ...
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:@for::to:do:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:28 IS.newDescNo:28 :objSize:0 varNo:1 %global ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:0 originOff:0 
 -- dataitem:qalloc:for isValue:true isPrimitive: true isValObj: true isBas ...true
 -- dataitem:qalloc:to isValue:true isPrimitive: true isValObj: true isBasi ...true
 -- Pattern:Qalloc:do
 -- Pattern:Qalloc:do
 -- dataitem:qalloc:inx isValue:true isPrimitive: true isValObj: true isBas ...true
 -- Pattern:Qalloc:doIt
 -- Pattern:Qalloc:doIt
 -- IS.newDescNo:28 IS.objSize:3 :%globals inSub | in for: var integer | in to: ...
 -- computeVariant:newDescNo:28 IS:%globals inSub | in for: var integer | in to ...
 -- ComputeVariant:B:@for::to:do
 -- ObjTmpStack:add::genDone:false :%globals inSub | in for: var integer | in t ...
 -- arg: 1
 -- ObjCall:markSuper:1
 -- Invocation:markForCodeGen:1
 -- arg: length
 -- ObjCall:markSuper:length
 -- Invocation:markForCodeGen:length
 -- ObjectInvocation:markForCodeGen:length ATd:length:  |    out V: var integ ...
 -- Pattern:markForCodeGen:length:  |    out V: var integer |    V := @get 0
 -- OG:markForCodeGen:out V: var integer | V := @get 0
 -- OG:markIS:out V: var integer | V := @get 0
 -- items:markForCodeGen:out V: var integer | V := @get 0
 -- DataItem:markForCodeGen:V:descNo:0 :OG.primNo:1 
 -- ObjCall:markSuper:integer
 -- Invocation:markForCodeGen:integer
 -- ObjectInvocation:markForCodeGen:integer ATd:integer: value |    %basic 1, ...
 -- Pattern:markForCodeGen:integer: value |    %basic 1, 32 |    %globals |    %p ...
 -- markItem:"V := @get 0" ObjectCall
 -- ObjCall:markSuper:V := @get 0
 -- Invocation:markForCodeGen:V := @get 0
 -- ObjectInvocation:markForCodeGen:V ATd:out V: var integer
 -- DataItem:markForCodeGen:V:descNo:0 :OG.primNo:1 
 -- ObjectInvocation:markForCodeGen::= @get 0 ATd::= :  |    %basic 8 |    in V ...
 -- Pattern:markForCodeGen::= :  |    %basic 8 |    in V: var Value
 -- arg: @get 0
 -- ComputeVariant:A:length
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:out V: var integer | V := @get 0
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:length:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:29 IS.newDescNo:29 :objSize:0 varNo:1 out V:  ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- dataitem:qalloc:V isValue:true isPrimitive: true isValObj: true isBasic ...true
 -- IS.newDescNo:29 IS.objSize:2 :out V: var integer | V := @get 0
 -- computeVariant:newDescNo:29 IS:out V: var integer | V := @get 0
 -- ComputeVariant:B:length
 -- ObjTmpStack:add::genDone:false length:out V: var integer | V := @get 0
 -- arg: put(@get inx)
 -- OG:markForCodeGen:put(@get inx)
 -- OG:markIS:put(@get inx)
 -- items:markForCodeGen:put(@get inx)
 -- markItem:"put(@get inx)" ObjectCall
 -- ObjCall:markSuper:put(@get inx)
 -- Invocation:markForCodeGen:put(@get inx)
 -- ObjectInvocation:markForCodeGen:put(@get inx) ATd:put:  |    %globals |     ...
 -- Pattern:markForCodeGen:put:  |    %globals |    %basic 2 |    in ch: val char ...
 -- OG:markForCodeGen:%globals | %basic 2 | in ch: val char
 -- OG:markIS:%globals | %basic 2 | in ch: val char
 -- items:markForCodeGen:%globals | %basic 2 | in ch: val char
 -- markItem:"%globals" Property
 -- markItem:"%basic 2" Property
 -- DataItem:markForCodeGen:ch:descNo:0 :OG.primNo:3 
 -- ObjCall:markSuper:char
 -- Invocation:markForCodeGen:char
 -- ObjectInvocation:markForCodeGen:char ATd:char: value |    %globals |    %ba ...
 -- Pattern:markForCodeGen:char: value |    %globals |    %basic 3, 16 |    %publ ...
 -- ComputeVariant:A:put
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:%globals | %basic 2 | in ch: val char
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:put:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:30 IS.newDescNo:30 :objSize:0 varNo:1 %global ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:0 originOff:0 
 -- dataitem:qalloc:ch isValue:true isPrimitive: true isValObj: true isBasi ...true
 -- IS.newDescNo:30 IS.objSize:1 :%globals | %basic 2 | in ch: val char
 -- computeVariant:newDescNo:30 IS:%globals | %basic 2 | in ch: val char
 -- ComputeVariant:B:put
 -- ObjTmpStack:add::genDone:false put:%globals | %basic 2 | in ch: val char
 -- arg: @get inx
 -- ComputeVariant:A:do#S#0
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:do
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- OG:Qalloc:A:Object
 -- :varNo:1 :allocDone:false
 -- OG:super: Object:  |    %basic 64 |    %public |    := :  |       %basic 8 |      ...
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:put(@get inx)
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:do#S#0:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:31 IS.newDescNo:31 :objSize:0 varNo:1 put(@ge ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super::super:size:1 :noGlobalsInSuper:false
 -- Items:Qalloc:super:B:objSize:1 originOff:1 
 -- IS.newDescNo:31 IS.objSize:1 :put(@get inx)
 -- computeVariant:newDescNo:31 IS:put(@get inx)
 -- ComputeVariant:B:do#S#31
 -- ObjTmpStack:add::genDone:false put(@get inx)
 -- OG:markIS:@for 1 :to length  | :do  |    put(@get inx)
 -- items:markForCodeGen:
 -- ComputeVariant:A:@for::to:do#S#0
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:@for::to:do
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:@for 1 :to length  | :do  |    put(@get inx)
 -- :varNo:1 :allocDone:false
 -- OG:super: @for:  |    %globals inSub |    in for: var integer |    in to: var ...
 -- :OG:Qalloc:B:@for::to:do#S#0:newDescNo:0 :objSize:3 
 -- OG:isObjectDesc:NewDescNo:32 IS.newDescNo:32 :objSize:3 varNo:1 
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super:@for 1 :to length  | :do  |    put(@get inx):super:s ...3 : ...true
 -- Items:Qalloc:super:B:objSize:4 originOff:4 
 -- IS.newDescNo:32 IS.objSize:3 :
 -- computeVariant:newDescNo:32 IS:
 -- ComputeVariant:B:@for::to:do#S#32
 -- ObjTmpStack:add::genDone:false @for 1 :to length  | :do  |    put(@get inx) ...
 -- ComputeVariant:A:print
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:@for 1 :to length  | :do  |    put(@get inx)
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:print:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:33 IS.newDescNo:33 :objSize:0 varNo:1 @for 1  ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- OG:Qalloc:A:@for 1 :to length  | :do  |    put(@get inx)
 -- :varNo:1 :allocDone:false
 -- OG:super: @for:  |    %globals inSub |    in for: var integer |    in to: var ...
 -- :OG:Qalloc:B:@for::to:do#S#32:newDescNo:32 :objSize:3 
 -- OG:isObjectDesc:NewDescNo:34 IS.newDescNo:34 :objSize:3 varNo:1 
 -- Items:Qalloc:objSize:4 
 -- Items:Qalloc:super:@for 1 :to length  | :do  |    put(@get inx):super:s ...3 : ...true
 -- Items:Qalloc:super:B:objSize:4 originOff:4 
 -- IS.newDescNo:34 IS.objSize:3 :
 -- IS.newDescNo:33 IS.objSize:1 :@for 1 :to length  | :do  |    put(@get inx)
 -- computeVariant:newDescNo:33 IS:@for 1 :to length  | :do  |    put(@get inx) ...
 -- ComputeVariant:B:print
 -- ObjTmpStack:add::genDone:false print:@for 1 :to length  | :do  |    put(@ge ...
 -- ComputeVariant:A:print
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:S.print
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:print:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:35 IS.newDescNo:35 :objSize:0 varNo:1 S.print ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- IS.newDescNo:35 IS.objSize:1 :S.print
 -- computeVariant:newDescNo:35 IS:S.print
 -- ComputeVariant:B:print
 -- ObjTmpStack:add::genDone:false print:S.print
 -- ComputeVariant:A:scan#S#0
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:scan
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:XL.scan |    F: ref Foo |    F := current |    F.print
 -- :varNo:1 :allocDone:false
 -- OG:super: scan:  |    current: ref Object |    L: ref List |    L := @this Li ...
 -- :OG:Qalloc:B:scan#S#0:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:36 IS.newDescNo:36 :objSize:0 varNo:1 F: ref  ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super:XL.scan:super:size:3 :noGlobalsInSuper:false
 -- Items:Qalloc:super:B:objSize:4 originOff:4 
 -- dataitem:qalloc:F isValue:false isPrimitive: false isValObj: false isBa ...false
 -- DI:alloc:off:5 F: ref Foo
 -- IS.newDescNo:36 IS.objSize:5 :F: ref Foo | F := current | F.print
 -- computeVariant:newDescNo:36 IS:F: ref Foo | F := current | F.print
 -- ComputeVariant:B:scan#S#36
 -- ObjTmpStack:add::genDone:false XL.scan |    F: ref Foo |    F := current |    ...
 -- ComputeVariant:A:List
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:List:  |    in head: ref Object |    in tail: ref List |    scan: ...
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:List:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:37 IS.newDescNo:37 :objSize:0 varNo:1 List:  |  ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- Pattern:Qalloc:List
 -- Pattern:Qalloc:List
 -- Pattern:Qalloc:foo
 -- Pattern:Qalloc:foo
 -- dataitem:qalloc:XL isValue:false isPrimitive: false isValObj: false isB ...false
 -- DI:alloc:off:2 XL: ref List
 -- OG:Qalloc:A:XL.scan |    F: ref Foo |    F := current |    F.print
 -- :varNo:1 :allocDone:false
 -- OG:super: scan:  |    current: ref Object |    L: ref List |    L := @this Li ...
 -- :OG:Qalloc:B:scan#S#36:newDescNo:36 :objSize:5 
 -- OG:isObjectDesc:NewDescNo:38 IS.newDescNo:38 :objSize:5 varNo:1 F: ref  ...
 -- Items:Qalloc:objSize:5 
 -- Items:Qalloc:super:XL.scan:super:size:3 :noGlobalsInSuper:false
 -- Items:Qalloc:super:B:objSize:4 originOff:4 
 -- dataitem:qalloc:F isValue:false isPrimitive: false isValObj: false isBa ...false
 -- DI:alloc:off:5 F: ref Foo
 -- IS.newDescNo:38 IS.objSize:5 :F: ref Foo | F := current | F.print
 -- IS.newDescNo:37 IS.objSize:2 :List:  |    in head: ref Object |    in tail: ...
 -- computeVariant:newDescNo:37 IS:List:  |    in head: ref Object |    in tail ...
 -- ComputeVariant:B:List
 -- ObjTmpStack:add::genDone:false List:  |    in head: ref Object |    in tail ...
 -- ComputeVariant:A:Containers
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:Container:  |    in elm:< Object |    scan:<  |       current: re ...
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:Containers:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:39 IS.newDescNo:39 :objSize:0 varNo:1 Contain ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- Pattern:Qalloc:Container
 -- Pattern:Qalloc:Container
 -- ModuleItem:Qalloc: --List
 -- ModuleItem:Qalloc:B:
 -- Qalloc:module:List
 -- Module:alloc:off:2 List: obj  |    List:  |       in head: ref Object |       ...
 -- ModuleItem:Qalloc: --MapLib
 -- ModuleItem:Qalloc: --Set
 -- ModuleItem:Qalloc: --mQueue
 -- IS.newDescNo:39 IS.objSize:2 :Container:  |    in elm:< Object |    scan:<  ...
 -- computeVariant:newDescNo:39 IS:Container:  |    in elm:< Object |    scan:< ...
 -- ComputeVariant:B:Containers
 -- ObjTmpStack:add::genDone:false Container:  |    in elm:< Object |    scan:< ...
 -- OG:markForCodeGen:%domain_boundary | %public | Dimension:  |    %public |    Ba ...
 -- OG:markIS:%domain_boundary | %public | Dimension:  |    %public |    BaseUnit:< ...
 -- items:markForCodeGen:%domain_boundary | %public | Dimension:  |    %public |    ...
 -- markItem:"%domain_boundary" Property
 -- markItem:"%public" Property
 -- OG:markForCodeGen:Dimension |    %Public |    SquareMeter: Unit |       %unit ...
 -- OG:markSuper:Dimension
 -- Invocation:markForCodeGen:Dimension
 -- ObjectInvocation:markForCodeGen:Dimension ATd:Dimension:  |    %public |    ...
 -- Pattern:markForCodeGen:Dimension:  |    %public |    BaseUnit:< Unit |    Uni ...
 -- OG:markForCodeGen:%public | BaseUnit:< Unit | Unit: Value |    %unit "U" |    % ...
 -- OG:markIS:%public | BaseUnit:< Unit | Unit: Value |    %unit "U" |    %public |   ...
 -- items:markForCodeGen:%public | BaseUnit:< Unit | Unit: Value |    %unit "U" |   ...
 -- markItem:"%public" Property
 -- Pattern:markForCodeGen:BaseUnit:< Unit
 -- OG:markForCodeGen:Unit
 -- OG:markSuper:Unit
 -- Invocation:markForCodeGen:Unit
 -- ObjectInvocation:markForCodeGen:Unit ATd:Unit: Value |    %unit "U" |    %p ...
 -- Pattern:markForCodeGen:Unit: Value |    %unit "U" |    %public |    magnitude ...
 -- OG:markForCodeGen:Value |    %unit "U" |    %public |    magnitude: var Float ...
 -- OG:markSuper:Value
 -- Invocation:markForCodeGen:Value
 -- ObjectInvocation:markForCodeGen:Value ATd:Value:  |    %globals |    %basic ...
 -- Pattern:markForCodeGen:Value:  |    %globals |    %basic 21 |    %public |    : ...
 -- OG:markIS:Value |    %unit "U" |    %public |    magnitude: var Float |    this ...
 -- items:markForCodeGen:%unit "U" | %public | magnitude: var Float | thisUnit:<  ...
 -- markItem:"%unit "U"" Property
 -- markItem:"%public" Property
 -- DataItem:markForCodeGen:magnitude:descNo:0 :OG.primNo:9 
 -- ObjCall:markSuper:Float
 -- Invocation:markForCodeGen:Float
 -- ObjectInvocation:markForCodeGen:Float ATd:float: Value |    %globals |    % ...
 -- Pattern:markForCodeGen:float: Value |    %globals |    %basic 9 |    _thisBas ...
 -- OG:markForCodeGen:Value |    %globals |    %basic 9 |    _thisBasicValue: var ...
 -- OG:markSuper:Value
 -- Invocation:markForCodeGen:Value
 -- ObjectInvocation:markForCodeGen:Value ATd:Value:  |    %globals |    %basic ...
 -- Pattern:markForCodeGen:Value:  |    %globals |    %basic 21 |    %public |    : ...
 -- OG:markIS:Value |    %globals |    %basic 9 |    _thisBasicValue: var Float |   ...
 -- items:markForCodeGen:%globals | %basic 9 | _thisBasicValue: var Float | %publ ...
 -- markItem:"%globals" Property
 -- markItem:"%basic 9" Property
 -- DataItem:markForCodeGen:_thisBasicValue:descNo:0 :OG.primNo:9 
 -- ObjCall:markSuper:Float
 -- Invocation:markForCodeGen:Float
 -- ObjectInvocation:markForCodeGen:Float ATd:float: Value |    %globals |    % ...
 -- Pattern:markForCodeGen:float: Value |    %globals |    %basic 9 |    _thisBas ...
 -- markItem:"%public" Property
 -- ComputeVariant:A:float
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Value
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:Value |    %globals |    %basic 9 |    _thisBasicValue: var Float ...
 -- :varNo:1 :allocDone:false
 -- OG:super: Value:  |    %globals |    %basic 21 |    %public |    := :  |       %b ...
 -- :OG:Qalloc:B:float:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:40 IS.newDescNo:40 :objSize:0 varNo:1 %global ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super:Value:super:size:0 :noGlobalsInSuper:true
 -- Items:Qalloc:super:B:objSize:0 originOff:0 
 -- dataitem:qalloc:_thisBasicValue isValue:true isPrimitive: true isValObj ...true  ...true
 -- Pattern:Qalloc:+
 -- Pattern:Qalloc:-
 -- Pattern:Qalloc:*
 -- Pattern:Qalloc:/
 -- Pattern:Qalloc:=
 -- Pattern:Qalloc:<
 -- Pattern:Qalloc:<=
 -- Pattern:Qalloc:>
 -- Pattern:Qalloc:>=
 -- Pattern:Qalloc:<>
 -- Pattern:Qalloc:^
 -- Pattern:Qalloc:^
 -- IS.newDescNo:40 IS.objSize:2 :%globals | %basic 9 | _thisBasicValue: var Fl ...
 -- computeVariant:newDescNo:40 IS:%globals | %basic 9 | _thisBasicValue: var F ...
 -- ComputeVariant:B:float
 -- ObjTmpStack:add::genDone:false float:Value |    %globals |    %basic 9 |    _ ...
 -- Pattern:markForCodeGen:thisUnit:< Unit
 -- OG:markForCodeGen:Unit
 -- OG:markSuper:Unit
 -- Invocation:markForCodeGen:Unit
 -- ObjectInvocation:markForCodeGen:Unit ATd:Unit: Value |    %unit "U" |    %p ...
 -- Pattern:markForCodeGen:Unit: Value |    %unit "U" |    %public |    magnitude ...
 -- Pattern:markForCodeGen:argUnit:< Unit
 -- OG:markForCodeGen:Unit
 -- OG:markSuper:Unit
 -- Invocation:markForCodeGen:Unit
 -- ObjectInvocation:markForCodeGen:Unit ATd:Unit: Value |    %unit "U" |    %p ...
 -- Pattern:markForCodeGen:Unit: Value |    %unit "U" |    %public |    magnitude ...
 -- Pattern:markForCodeGen:resUnit:< Unit
 -- OG:markForCodeGen:Unit
 -- OG:markSuper:Unit
 -- Invocation:markForCodeGen:Unit
 -- ObjectInvocation:markForCodeGen:Unit ATd:Unit: Value |    %unit "U" |    %p ...
 -- Pattern:markForCodeGen:Unit: Value |    %unit "U" |    %public |    magnitude ...
 -- Pattern:markForCodeGen:toBase:<  |    out base: var BaseUnit |    @inner to ...
 -- OG:markForCodeGen:out base: var BaseUnit | @inner toBase
 -- OG:markIS:out base: var BaseUnit | @inner toBase
 -- items:markForCodeGen:out base: var BaseUnit | @inner toBase
 -- DataItem:markForCodeGen:base:descNo:0 :OG.primNo:0 
 -- ObjCall:markSuper:BaseUnit
 -- Invocation:markForCodeGen:BaseUnit
 -- ObjectInvocation:markForCodeGen:BaseUnit ATd:BaseUnit:< Unit
 -- Pattern:markForCodeGen:BaseUnit:< Unit
 -- markItem:"@inner toBase" ObjectCall
 -- ComputeVariant:A:toBase
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:out base: var BaseUnit | @inner toBase
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:toBase:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:41 IS.newDescNo:41 :objSize:0 varNo:1 out bas ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:2 originOff:1 
 -- dataitem:qalloc:base isValue:true isPrimitive: false isValObj: true isB ...false
 -- IS.newDescNo:41 IS.objSize:2 :out base: var BaseUnit | @inner toBase
 -- computeVariant:newDescNo:41 IS:out base: var BaseUnit | @inner toBase
 -- ComputeVariant:B:toBase
 -- ObjTmpStack:add::genDone:false toBase:out base: var BaseUnit | @inner toB ...
 -- Pattern:markForCodeGen:fromBase:<  |    in base: var float |    @inner from ...
 -- OG:markForCodeGen:in base: var float | @inner fromBase
 -- OG:markIS:in base: var float | @inner fromBase
 -- items:markForCodeGen:in base: var float | @inner fromBase
 -- DataItem:markForCodeGen:base:descNo:0 :OG.primNo:9 
 -- ObjCall:markSuper:float
 -- Invocation:markForCodeGen:float
 -- ObjectInvocation:markForCodeGen:float ATd:float: Value |    %globals |    % ...
 -- Pattern:markForCodeGen:float: Value |    %globals |    %basic 9 |    _thisBas ...
 -- markItem:"@inner fromBase" ObjectCall
 -- ComputeVariant:A:fromBase
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:in base: var float | @inner fromBase
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:fromBase:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:42 IS.newDescNo:42 :objSize:0 varNo:1 in base ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:2 originOff:1 
 -- dataitem:qalloc:base isValue:true isPrimitive: true isValObj: true isBa ...true
 -- IS.newDescNo:42 IS.objSize:4 :in base: var float | @inner fromBase
 -- computeVariant:newDescNo:42 IS:in base: var float | @inner fromBase
 -- ComputeVariant:B:fromBase
 -- ObjTmpStack:add::genDone:false fromBase:in base: var float | @inner fromB ...
 -- Pattern:markForCodeGen:print:<  |    "Unit:".print |    @inner print |    put ...
 -- OG:markForCodeGen:"Unit:".print | @inner print | put(':') | putFloat(magnitud ...
 -- OG:markIS:"Unit:".print | @inner print | put(':') | putFloat(magnitude)
 -- items:markForCodeGen:"Unit:".print | @inner print | put(':') | putFloat(magni ...
 -- markItem:""Unit:".print" ObjectCall
 -- ObjCall:markSuper:"Unit:".print
 -- Invocation:markForCodeGen:"Unit:".print
 -- ObjectInvocation:markForCodeGen:print ATd:print:  |    @for 1 :to length  ...
 -- Pattern:markForCodeGen:print:  |    @for 1 :to length  |    :do  |       put( ...
 -- markItem:"@inner print" ObjectCall
 -- markItem:"put(':')" ObjectCall
 -- ObjCall:markSuper:put(':')
 -- Invocation:markForCodeGen:put(':')
 -- ObjectInvocation:markForCodeGen:put(':') ATd:put:  |    %globals |    %basi ...
 -- Pattern:markForCodeGen:put:  |    %globals |    %basic 2 |    in ch: val char ...
 -- arg: ':'
 -- ObjCall:markSuper:':'
 -- Invocation:markForCodeGen:':'
 -- markItem:"putFloat(magnitude)" ObjectCall
 -- ObjCall:markSuper:putFloat(magnitude)
 -- Invocation:markForCodeGen:putFloat(magnitude)
 -- ObjectInvocation:markForCodeGen:putFloat(magnitude) ATd:putFloat:  |    % ...
 -- Pattern:markForCodeGen:putFloat:  |    %basic 142 |    in X: var Float |    o ...
 -- OG:markForCodeGen:%basic 142 | in X: var Float | out V: var integer
 -- OG:markIS:%basic 142 | in X: var Float | out V: var integer
 -- items:markForCodeGen:%basic 142 | in X: var Float | out V: var integer
 -- markItem:"%basic 142" Property
 -- DataItem:markForCodeGen:X:descNo:0 :OG.primNo:9 
 -- ObjCall:markSuper:Float
 -- Invocation:markForCodeGen:Float
 -- ObjectInvocation:markForCodeGen:Float ATd:float: Value |    %globals |    % ...
 -- Pattern:markForCodeGen:float: Value |    %globals |    %basic 9 |    _thisBas ...
 -- DataItem:markForCodeGen:V:descNo:0 :OG.primNo:1 
 -- ObjCall:markSuper:integer
 -- Invocation:markForCodeGen:integer
 -- ObjectInvocation:markForCodeGen:integer ATd:integer: value |    %basic 1, ...
 -- Pattern:markForCodeGen:integer: value |    %basic 1, 32 |    %globals |    %p ...
 -- ComputeVariant:A:putFloat
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:%basic 142 | in X: var Float | out V: var integer
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:putFloat:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:43 IS.newDescNo:43 :objSize:0 varNo:1 %basic  ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- dataitem:qalloc:X isValue:true isPrimitive: true isValObj: true isBasic ...true
 -- dataitem:qalloc:V isValue:true isPrimitive: true isValObj: true isBasic ...true
 -- IS.newDescNo:43 IS.objSize:4 :%basic 142 | in X: var Float | out V: var int ...
 -- computeVariant:newDescNo:43 IS:%basic 142 | in X: var Float | out V: var in ...
 -- ComputeVariant:B:putFloat
 -- ObjTmpStack:add::genDone:false putFloat:%basic 142 | in X: var Float | out  ...
 -- arg: magnitude
 -- ComputeVariant:A:print
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"Unit:".print | @inner print | put(':') | putFloat(magnitude)
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:print:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:44 IS.newDescNo:44 :objSize:0 varNo:1 "Unit:" ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:2 originOff:1 
 -- IS.newDescNo:44 IS.objSize:2 :"Unit:".print | @inner print | put(':') | putFl ...
 -- computeVariant:newDescNo:44 IS:"Unit:".print | @inner print | put(':') | putF ...
 -- ComputeVariant:B:print
 -- ObjTmpStack:add::genDone:false print:"Unit:".print | @inner print | put(':' ...
 -- ComputeVariant:A:Unit
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Value
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:Value |    %unit "U" |    %public |    magnitude: var Float |    th ...
 -- :varNo:1 :allocDone:false
 -- OG:super: Value:  |    %globals |    %basic 21 |    %public |    := :  |       %b ...
 -- :OG:Qalloc:B:Unit:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:45 IS.newDescNo:45 :objSize:0 varNo:1 %unit " ..."
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super:Value:super:size:0 :noGlobalsInSuper:true
 -- Items:Qalloc:super:B:objSize:0 originOff:0 
 -- dataitem:qalloc:magnitude isValue:true isPrimitive: true isValObj: true  ...true
 -- Pattern:Qalloc:thisUnit
 -- Pattern:Qalloc:thisUnit
 -- Pattern:Qalloc:argUnit
 -- Pattern:Qalloc:argUnit
 -- Pattern:Qalloc:resUnit
 -- Pattern:Qalloc:resUnit
 -- Pattern:Qalloc:+?
 -- Pattern:Qalloc:+?
 -- Pattern:Qalloc:-?
 -- Pattern:Qalloc:-?
 -- Pattern:Qalloc:*?
 -- Pattern:Qalloc:*?
 -- Pattern:Qalloc:/?
 -- Pattern:Qalloc:/?
 -- Pattern:Qalloc:^?
 -- Pattern:Qalloc:^?
 -- Pattern:Qalloc:***
 -- Pattern:Qalloc:***
 -- Pattern:Qalloc:=+
 -- Pattern:Qalloc:=+
 -- Pattern:Qalloc:square
 -- Pattern:Qalloc:square
 -- Pattern:Qalloc:min
 -- Pattern:Qalloc:min
 -- Pattern:Qalloc:max
 -- Pattern:Qalloc:max
 -- Pattern:Qalloc:toBase
 -- Pattern:Qalloc:toBase
 -- Pattern:Qalloc:fromBase
 -- Pattern:Qalloc:fromBase
 -- Pattern:Qalloc:print
 -- Pattern:Qalloc:print
 -- IS.newDescNo:45 IS.objSize:2 :%unit "U" | %public | magnitude: var Float | th ...
 -- computeVariant:newDescNo:45 IS:%unit "U" | %public | magnitude: var Float | t ...
 -- ComputeVariant:B:Unit
 -- ObjTmpStack:add::genDone:false Unit:Value |    %unit "U" |    %public |    ma ...
 -- Pattern:markForCodeGen:shortName:<  |    out T: var String.String |    @inn ...
 -- OG:markForCodeGen:out T: var String.String | @inner shortName
 -- OG:markIS:out T: var String.String | @inner shortName
 -- items:markForCodeGen:out T: var String.String | @inner shortName
 -- DataItem:markForCodeGen:T:descNo:0 :OG.primNo:5 
 -- ObjCall:markSuper:String.String
 -- Invocation:markForCodeGen:String.String
 -- ObjectInvocation:markForCodeGen:String ATd:--String
 -- ObjectInvocation:markForCodeGen:String ATd:String:  |    %OSDvisibility d ...
 -- Pattern:markForCodeGen:String:  |    %OSDvisibility disguised |    %basic 5 ...
 -- markItem:"@inner shortName" ObjectCall
 -- ComputeVariant:A:shortName
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:out T: var String.String | @inner shortName
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:shortName:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:46 IS.newDescNo:46 :objSize:0 varNo:1 out T:  ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- dataitem:qalloc:T isValue:true isPrimitive: true isValObj: false isBasi ...false
 -- IS.newDescNo:46 IS.objSize:2 :out T: var String.String | @inner shortName ...
 -- computeVariant:newDescNo:46 IS:out T: var String.String | @inner shortNam ...
 -- ComputeVariant:B:shortName
 -- ObjTmpStack:add::genDone:false shortName:out T: var String.String | @inne ...
 -- Pattern:markForCodeGen:MultArgL:< Unit
 -- OG:markForCodeGen:Unit
 -- OG:markSuper:Unit
 -- Invocation:markForCodeGen:Unit
 -- ObjectInvocation:markForCodeGen:Unit ATd:Unit: Value |    %unit "U" |    %p ...
 -- Pattern:markForCodeGen:Unit: Value |    %unit "U" |    %public |    magnitude ...
 -- Pattern:markForCodeGen:MultArgR:< Unit
 -- OG:markForCodeGen:Unit
 -- OG:markSuper:Unit
 -- Invocation:markForCodeGen:Unit
 -- ObjectInvocation:markForCodeGen:Unit ATd:Unit: Value |    %unit "U" |    %p ...
 -- Pattern:markForCodeGen:Unit: Value |    %unit "U" |    %public |    magnitude ...
 -- Pattern:markForCodeGen:MultRes:< Unit
 -- OG:markForCodeGen:Unit
 -- OG:markSuper:Unit
 -- Invocation:markForCodeGen:Unit
 -- ObjectInvocation:markForCodeGen:Unit ATd:Unit: Value |    %unit "U" |    %p ...
 -- Pattern:markForCodeGen:Unit: Value |    %unit "U" |    %public |    magnitude ...
 -- Pattern:markForCodeGen:gMult:<  |    in L: var MultArgL |    in R: var Mult ...
 -- OG:markForCodeGen:in L: var MultArgL | in R: var MultArgR | out U: var Mult ...
 -- OG:markIS:in L: var MultArgL | in R: var MultArgR | out U: var MultRes | U.ma ...
 -- items:markForCodeGen:in L: var MultArgL | in R: var MultArgR | out U: var M ...
 -- DataItem:markForCodeGen:L:descNo:0 :OG.primNo:0 
 -- ObjCall:markSuper:MultArgL
 -- Invocation:markForCodeGen:MultArgL
 -- ObjectInvocation:markForCodeGen:MultArgL ATd:MultArgL:< Unit
 -- Pattern:markForCodeGen:MultArgL:< Unit
 -- DataItem:markForCodeGen:R:descNo:0 :OG.primNo:0 
 -- ObjCall:markSuper:MultArgR
 -- Invocation:markForCodeGen:MultArgR
 -- ObjectInvocation:markForCodeGen:MultArgR ATd:MultArgR:< Unit
 -- Pattern:markForCodeGen:MultArgR:< Unit
 -- DataItem:markForCodeGen:U:descNo:0 :OG.primNo:0 
 -- ObjCall:markSuper:MultRes
 -- Invocation:markForCodeGen:MultRes
 -- ObjectInvocation:markForCodeGen:MultRes ATd:MultRes:< Unit
 -- Pattern:markForCodeGen:MultRes:< Unit
 -- markItem:"U.magnitude := L.magnitude * R.magnitude" ObjectCall
 -- ObjCall:markSuper:U.magnitude := L.magnitude * R.magnitude
 -- Invocation:markForCodeGen:U.magnitude := L.magnitude * R.magnitude
 -- ObjectInvocation:markForCodeGen:U ATd:out U: var MultRes
 -- DataItem:markForCodeGen:U:descNo:0 :OG.primNo:0 
 -- ObjectInvocation:markForCodeGen:magnitude ATd:magnitude: var Float
 -- DataItem:markForCodeGen:magnitude:descNo:0 :OG.primNo:9 
 -- ObjectInvocation:markForCodeGen::= L.magnitude * R.magnitude ATd::= :  |  ...
 -- Pattern:markForCodeGen::= :  |    %basic 8 |    in V: var Value
 -- arg: L.magnitude * R.magnitude
 -- ObjCall:markSuper:L.magnitude * R.magnitude
 -- Invocation:markForCodeGen:L.magnitude * R.magnitude
 -- ObjectInvocation:markForCodeGen:L ATd:in L: var MultArgL
 -- DataItem:markForCodeGen:L:descNo:0 :OG.primNo:0 
 -- ObjectInvocation:markForCodeGen:magnitude ATd:magnitude: var Float
 -- DataItem:markForCodeGen:magnitude:descNo:0 :OG.primNo:9 
 -- ObjectInvocation:markForCodeGen:* R.magnitude ATd:* :  |    %basic 112 |    ...
 -- Pattern:markForCodeGen:* :  |    %basic 112 |    in V: var float |    out R:  ...
 -- arg: R.magnitude
 -- ComputeVariant:A:gMult
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:in L: var MultArgL | in R: var MultArgR | out U: var MultRes | U. ...
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:gMult:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:47 IS.newDescNo:47 :objSize:0 varNo:1 in L: v ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- dataitem:qalloc:L isValue:true isPrimitive: false isValObj: true isBasi ...false
 -- dataitem:qalloc:R isValue:true isPrimitive: false isValObj: true isBasi ...false
 -- dataitem:qalloc:U isValue:true isPrimitive: false isValObj: true isBasi ...false
 -- IS.newDescNo:47 IS.objSize:7 :in L: var MultArgL | in R: var MultArgR | out ...
 -- computeVariant:newDescNo:47 IS:in L: var MultArgL | in R: var MultArgR | ou ...
 -- ComputeVariant:B:gMult
 -- ObjTmpStack:add::genDone:false gMult:in L: var MultArgL | in R: var MultA ...
 -- ComputeVariant:A:Dimension
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:%public | BaseUnit:< Unit | Unit: Value |    %unit "U" |    %public ...
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:Dimension:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:48 IS.newDescNo:48 :objSize:0 varNo:1 %public ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- Pattern:Qalloc:BaseUnit
 -- Pattern:Qalloc:BaseUnit
 -- Pattern:Qalloc:Unit
 -- Pattern:Qalloc:Unit
 -- Pattern:Qalloc:shortName
 -- Pattern:Qalloc:shortName
 -- Pattern:Qalloc:MultArgL
 -- Pattern:Qalloc:MultArgL
 -- Pattern:Qalloc:MultArgR
 -- Pattern:Qalloc:MultArgR
 -- Pattern:Qalloc:MultRes
 -- Pattern:Qalloc:MultRes
 -- Pattern:Qalloc:gMult
 -- Pattern:Qalloc:gMult
 -- IS.newDescNo:48 IS.objSize:1 :%public | BaseUnit:< Unit | Unit: Value |    %u ...
 -- computeVariant:newDescNo:48 IS:%public | BaseUnit:< Unit | Unit: Value |    % ...
 -- ComputeVariant:B:Dimension
 -- ObjTmpStack:add::genDone:false Dimension:%public | BaseUnit:< Unit | Unit:  ...
 -- OG:markIS:Dimension |    %Public |    SquareMeter: Unit |       %unit "m2", " ..."
 -- items:markForCodeGen:%Public | SquareMeter: Unit |    %unit "m2", "m*m" |     ...
 -- markItem:"%Public" Property
 -- Pattern:markForCodeGen:shortName::  |    T := "m2"
 -- OG:markForCodeGen:T := "m2"
 -- OG:markIS:T := "m2"
 -- items:markForCodeGen:T := "m2"
 -- markItem:"T := "m2"" ObjectCall
 -- ObjCall:markSuper:T := "m2"
 -- Invocation:markForCodeGen:T := "m2"
 -- ObjectInvocation:markForCodeGen:T ATd:out T: var String.String
 -- DataItem:markForCodeGen:T:descNo:0 :OG.primNo:5 
 -- ObjectInvocation:markForCodeGen::= "m2" ATd::= :  |    %basic 8 |    in V:  ...
 -- Pattern:markForCodeGen::= :  |    %basic 8 |    in V: ref Value
 -- arg: "m2"
 -- ObjCall:markSuper:"m2"
 -- Invocation:markForCodeGen:"m2"
 -- ComputeVariant:A:shortName
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:shortName
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:T := "m2"
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:shortName:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:49 IS.newDescNo:49 :objSize:0 varNo:1 T := "m ..."
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super::super:size:2 :noGlobalsInSuper:false
 -- Items:Qalloc:super:B:objSize:2 originOff:1 
 -- IS.newDescNo:49 IS.objSize:2 :T := "m2"
 -- computeVariant:newDescNo:49 IS:T := "m2"
 -- ComputeVariant:B:shortName
 -- ObjTmpStack:add::genDone:false shortName:T := "m2"
 -- ComputeVariant:A:Area
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Dimension
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:Dimension |    %Public |    SquareMeter: Unit |       %unit "m2", ...
 -- :varNo:1 :allocDone:false
 -- OG:super: Dimension:  |    %public |    BaseUnit:< Unit |    Unit: Value |      ...
 -- :OG:Qalloc:B:Area:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:50 IS.newDescNo:50 :objSize:0 varNo:1 %Public ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super:Dimension:super:size:1 :noGlobalsInSuper:false
 -- Items:Qalloc:super:B:objSize:1 originOff:1 
 -- Pattern:Qalloc:SquareMeter
 -- Pattern:Qalloc:SquareMeter
 -- Pattern:Qalloc:mult
 -- Pattern:Qalloc:mult
 -- Pattern:Qalloc:shortName
 -- Pattern:Qalloc:shortName
 -- IS.newDescNo:50 IS.objSize:1 :%Public | SquareMeter: Unit |    %unit "m2",  ...
 -- computeVariant:newDescNo:50 IS:%Public | SquareMeter: Unit |    %unit "m2", ...
 -- ComputeVariant:B:Area
 -- ObjTmpStack:add::genDone:false Dimension |    %Public |    SquareMeter: Uni ...
 -- OG:markForCodeGen:Dimension |    %Public |    BaseUnit:: Meter |    Foot: Uni ...
 -- OG:markSuper:Dimension
 -- Invocation:markForCodeGen:Dimension
 -- ObjectInvocation:markForCodeGen:Dimension ATd:Dimension:  |    %public |    ...
 -- Pattern:markForCodeGen:Dimension:  |    %public |    BaseUnit:< Unit |    Uni ...
 -- OG:markIS:Dimension |    %Public |    BaseUnit:: Meter |    Foot: Unit |        ...
 -- items:markForCodeGen:%Public | BaseUnit:: Meter | Foot: Unit |    %Public |     ...
 -- markItem:"%Public" Property
 -- Pattern:markForCodeGen:BaseUnit:: Meter
 -- OG:markForCodeGen:Meter
 -- OG:markSuper:Meter
 -- Invocation:markForCodeGen:Meter
 -- ObjectInvocation:markForCodeGen:Meter ATd:Meter: Unit |    %unit "m" |    % ...
 -- Pattern:markForCodeGen:Meter: Unit |    %unit "m" |    %Public |    thisUnit: ...
 -- OG:markForCodeGen:Unit |    %unit "m" |    %Public |    thisUnit:: Meter |    a ...
 -- OG:markSuper:Unit
 -- Invocation:markForCodeGen:Unit
 -- ObjectInvocation:markForCodeGen:Unit ATd:Unit: Value |    %unit "U" |    %p ...
 -- Pattern:markForCodeGen:Unit: Value |    %unit "U" |    %public |    magnitude ...
 -- OG:markIS:Unit |    %unit "m" |    %Public |    thisUnit:: Meter |    argUnit:: ...
 -- items:markForCodeGen:%unit "m" | %Public | thisUnit:: Meter | argUnit:: Meter ...
 -- markItem:"%unit "m"" Property
 -- markItem:"%Public" Property
 -- Pattern:markForCodeGen:thisUnit:: Meter
 -- OG:markForCodeGen:Meter
 -- OG:markSuper:Meter
 -- Invocation:markForCodeGen:Meter
 -- ObjectInvocation:markForCodeGen:Meter ATd:Meter: Unit |    %unit "m" |    % ...
 -- Pattern:markForCodeGen:Meter: Unit |    %unit "m" |    %Public |    thisUnit: ...
 -- Pattern:markForCodeGen:argUnit:: Meter
 -- OG:markForCodeGen:Meter
 -- OG:markSuper:Meter
 -- Invocation:markForCodeGen:Meter
 -- ObjectInvocation:markForCodeGen:Meter ATd:Meter: Unit |    %unit "m" |    % ...
 -- Pattern:markForCodeGen:Meter: Unit |    %unit "m" |    %Public |    thisUnit: ...
 -- Pattern:markForCodeGen:resUnit:: Area.SquareMeter
 -- OG:markForCodeGen:Area.SquareMeter
 -- OG:markSuper:Area.SquareMeter
 -- Invocation:markForCodeGen:Area.SquareMeter
 -- ObjectInvocation:markForCodeGen:Area ATd:--Area
 -- ObjectInvocation:markForCodeGen:SquareMeter ATd:SquareMeter: Unit |    %u ...
 -- Pattern:markForCodeGen:SquareMeter: Unit |    %unit "m2", "m*m" |    %Publi ...
 -- OG:markForCodeGen:Unit |    %unit "m2", "m*m" |    %Public |    thisUnit:: Sq ...
 -- OG:markSuper:Unit
 -- Invocation:markForCodeGen:Unit
 -- ObjectInvocation:markForCodeGen:Unit ATd:Unit: Value |    %unit "U" |    %p ...
 -- Pattern:markForCodeGen:Unit: Value |    %unit "U" |    %public |    magnitude ...
 -- OG:markIS:Unit |    %unit "m2", "m*m" |    %Public |    thisUnit:: SquareMete ...
 -- items:markForCodeGen:%unit "m2", "m*m" | %Public | thisUnit:: SquareMeter | p ...
 -- markItem:"%unit "m2", "m*m"" Property
 -- markItem:"%Public" Property
 -- Pattern:markForCodeGen:thisUnit:: SquareMeter
 -- OG:markForCodeGen:SquareMeter
 -- OG:markSuper:SquareMeter
 -- Invocation:markForCodeGen:SquareMeter
 -- ObjectInvocation:markForCodeGen:SquareMeter ATd:SquareMeter: Unit |    %u ...
 -- Pattern:markForCodeGen:SquareMeter: Unit |    %unit "m2", "m*m" |    %Publi ...
 -- Pattern:markForCodeGen:print::  |    "SquareMeter".print
 -- OG:markForCodeGen:"SquareMeter".print
 -- OG:markIS:"SquareMeter".print
 -- items:markForCodeGen:"SquareMeter".print
 -- markItem:""SquareMeter".print" ObjectCall
 -- ObjCall:markSuper:"SquareMeter".print
 -- Invocation:markForCodeGen:"SquareMeter".print
 -- ObjectInvocation:markForCodeGen:print ATd:print:  |    @for 1 :to length  ...
 -- Pattern:markForCodeGen:print:  |    @for 1 :to length  |    :do  |       put( ...
 -- ComputeVariant:A:print
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:print
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"SquareMeter".print
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:print:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:51 IS.newDescNo:51 :objSize:0 varNo:1 "Square ..."
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super::super:size:2 :noGlobalsInSuper:false
 -- Items:Qalloc:super:B:objSize:2 originOff:1 
 -- IS.newDescNo:51 IS.objSize:2 :"SquareMeter".print
 -- computeVariant:newDescNo:51 IS:"SquareMeter".print
 -- ComputeVariant:B:print
 -- ObjTmpStack:add::genDone:false print:"SquareMeter".print
 -- ComputeVariant:A:SquareMeter
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Unit
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Value
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:Unit |    %unit "m2", "m*m" |    %Public |    thisUnit:: SquareMe ...
 -- :varNo:1 :allocDone:false
 -- OG:super: Unit: Value |    %unit "U" |    %public |    magnitude: var Float |   ...
 -- :OG:Qalloc:B:SquareMeter:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:52 IS.newDescNo:52 :objSize:0 varNo:1 %unit " ..."
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super:Unit:super:size:2 :noGlobalsInSuper:true
 -- Items:Qalloc:super:B:objSize:2 originOff:0 
 -- Pattern:Qalloc:thisUnit
 -- Pattern:Qalloc:thisUnit
 -- Pattern:Qalloc:print
 -- Pattern:Qalloc:print
 -- IS.newDescNo:52 IS.objSize:2 :%unit "m2", "m*m" | %Public | thisUnit:: Squa ...
 -- computeVariant:newDescNo:52 IS:%unit "m2", "m*m" | %Public | thisUnit:: Squ ...
 -- ComputeVariant:B:SquareMeter
 -- ObjTmpStack:add::genDone:false SquareMeter:Unit |    %unit "m2", "m*m" |    ...
 -- Pattern:markForCodeGen:toBase::  |    base := magnitude
 -- OG:markForCodeGen:base := magnitude
 -- OG:markIS:base := magnitude
 -- items:markForCodeGen:base := magnitude
 -- markItem:"base := magnitude" ObjectCall
 -- ObjCall:markSuper:base := magnitude
 -- Invocation:markForCodeGen:base := magnitude
 -- ObjectInvocation:markForCodeGen:base ATd:out base: var BaseUnit
 -- DataItem:markForCodeGen:base:descNo:0 :OG.primNo:0 
 -- ObjectInvocation:markForCodeGen::= magnitude ATd::= :  |    %basic 8 |    i ...
 -- Pattern:markForCodeGen::= :  |    %basic 8 |    in V: var Value
 -- arg: magnitude
 -- ComputeVariant:A:toBase
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:toBase
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:base := magnitude
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:toBase:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:53 IS.newDescNo:53 :objSize:0 varNo:1 base := ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super::super:size:2 :noGlobalsInSuper:false
 -- Items:Qalloc:super:B:objSize:2 originOff:1 
 -- IS.newDescNo:53 IS.objSize:2 :base := magnitude
 -- computeVariant:newDescNo:53 IS:base := magnitude
 -- ComputeVariant:B:toBase
 -- ObjTmpStack:add::genDone:false toBase:base := magnitude
 -- Pattern:markForCodeGen:fromBase::  |    magnitude := base
 -- OG:markForCodeGen:magnitude := base
 -- OG:markIS:magnitude := base
 -- items:markForCodeGen:magnitude := base
 -- markItem:"magnitude := base" ObjectCall
 -- ObjCall:markSuper:magnitude := base
 -- Invocation:markForCodeGen:magnitude := base
 -- ObjectInvocation:markForCodeGen:magnitude ATd:magnitude: var Float
 -- DataItem:markForCodeGen:magnitude:descNo:0 :OG.primNo:9 
 -- ObjectInvocation:markForCodeGen::= base ATd::= :  |    %basic 8 |    in V:  ...
 -- Pattern:markForCodeGen::= :  |    %basic 8 |    in V: var Value
 -- arg: base
 -- ComputeVariant:A:fromBase
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:fromBase
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:magnitude := base
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:fromBase:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:54 IS.newDescNo:54 :objSize:0 varNo:1 magnitu ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super::super:size:4 :noGlobalsInSuper:false
 -- Items:Qalloc:super:B:objSize:4 originOff:1 
 -- IS.newDescNo:54 IS.objSize:4 :magnitude := base
 -- computeVariant:newDescNo:54 IS:magnitude := base
 -- ComputeVariant:B:fromBase
 -- ObjTmpStack:add::genDone:false fromBase:magnitude := base
 -- Pattern:markForCodeGen:print::  |    "Meter".print
 -- OG:markForCodeGen:"Meter".print
 -- OG:markIS:"Meter".print
 -- items:markForCodeGen:"Meter".print
 -- markItem:""Meter".print" ObjectCall
 -- ObjCall:markSuper:"Meter".print
 -- Invocation:markForCodeGen:"Meter".print
 -- ObjectInvocation:markForCodeGen:print ATd:print:  |    @for 1 :to length  ...
 -- Pattern:markForCodeGen:print:  |    @for 1 :to length  |    :do  |       put( ...
 -- ComputeVariant:A:print
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:print
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"Meter".print
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:print:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:55 IS.newDescNo:55 :objSize:0 varNo:1 "Meter" ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super::super:size:2 :noGlobalsInSuper:false
 -- Items:Qalloc:super:B:objSize:2 originOff:1 
 -- IS.newDescNo:55 IS.objSize:2 :"Meter".print
 -- computeVariant:newDescNo:55 IS:"Meter".print
 -- ComputeVariant:B:print
 -- ObjTmpStack:add::genDone:false print:"Meter".print
 -- ComputeVariant:A:Meter
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Unit
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Value
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:Unit |    %unit "m" |    %Public |    thisUnit:: Meter |    argUnit ...
 -- :varNo:1 :allocDone:false
 -- OG:super: Unit: Value |    %unit "U" |    %public |    magnitude: var Float |   ...
 -- :OG:Qalloc:B:Meter:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:56 IS.newDescNo:56 :objSize:0 varNo:1 %unit " ..."
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super:Unit:super:size:2 :noGlobalsInSuper:true
 -- Items:Qalloc:super:B:objSize:2 originOff:0 
 -- Pattern:Qalloc:thisUnit
 -- Pattern:Qalloc:thisUnit
 -- Pattern:Qalloc:argUnit
 -- Pattern:Qalloc:argUnit
 -- Pattern:Qalloc:resUnit
 -- Pattern:Qalloc:resUnit
 -- Pattern:Qalloc:toBase
 -- Pattern:Qalloc:toBase
 -- Pattern:Qalloc:fromBase
 -- Pattern:Qalloc:fromBase
 -- Pattern:Qalloc:print
 -- Pattern:Qalloc:print
 -- Pattern:Qalloc:power
 -- Pattern:Qalloc:power
 -- Pattern:Qalloc:power2
 -- Pattern:Qalloc:power2
 -- IS.newDescNo:56 IS.objSize:2 :%unit "m" | %Public | thisUnit:: Meter | argUni ...
 -- computeVariant:newDescNo:56 IS:%unit "m" | %Public | thisUnit:: Meter | argUn ...
 -- ComputeVariant:B:Meter
 -- ObjTmpStack:add::genDone:false Meter:Unit |    %unit "m" |    %Public |    th ...
 -- Pattern:markForCodeGen:shortName::  |    T := "L"
 -- OG:markForCodeGen:T := "L"
 -- OG:markIS:T := "L"
 -- items:markForCodeGen:T := "L"
 -- markItem:"T := "L"" ObjectCall
 -- ObjCall:markSuper:T := "L"
 -- Invocation:markForCodeGen:T := "L"
 -- ObjectInvocation:markForCodeGen:T ATd:out T: var String.String
 -- DataItem:markForCodeGen:T:descNo:0 :OG.primNo:5 
 -- ObjectInvocation:markForCodeGen::= "L" ATd::= :  |    %basic 8 |    in V: r ...
 -- Pattern:markForCodeGen::= :  |    %basic 8 |    in V: ref Value
 -- arg: "L"
 -- ObjCall:markSuper:"L"
 -- Invocation:markForCodeGen:"L"
 -- ComputeVariant:A:shortName
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:shortName
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:T := "L"
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:shortName:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:57 IS.newDescNo:57 :objSize:0 varNo:1 T := "L ..."
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super::super:size:2 :noGlobalsInSuper:false
 -- Items:Qalloc:super:B:objSize:2 originOff:1 
 -- IS.newDescNo:57 IS.objSize:2 :T := "L"
 -- computeVariant:newDescNo:57 IS:T := "L"
 -- ComputeVariant:B:shortName
 -- ObjTmpStack:add::genDone:false shortName:T := "L"
 -- ComputeVariant:A:Length
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Dimension
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:Dimension |    %Public |    BaseUnit:: Meter |    Foot: Unit |      ...
 -- :varNo:1 :allocDone:false
 -- OG:super: Dimension:  |    %public |    BaseUnit:< Unit |    Unit: Value |      ...
 -- :OG:Qalloc:B:Length:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:58 IS.newDescNo:58 :objSize:0 varNo:1 %Public ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super:Dimension:super:size:1 :noGlobalsInSuper:false
 -- Items:Qalloc:super:B:objSize:1 originOff:1 
 -- Pattern:Qalloc:BaseUnit
 -- Pattern:Qalloc:BaseUnit
 -- Pattern:Qalloc:Foot
 -- Pattern:Qalloc:Foot
 -- Pattern:Qalloc:Mile
 -- Pattern:Qalloc:Mile
 -- Pattern:Qalloc:Meter
 -- Pattern:Qalloc:Meter
 -- Pattern:Qalloc:Centimeter
 -- Pattern:Qalloc:Centimeter
 -- Pattern:Qalloc:LightYear
 -- Pattern:Qalloc:LightYear
 -- Pattern:Qalloc:F2M
 -- Pattern:Qalloc:F2M
 -- Pattern:Qalloc:shortName
 -- Pattern:Qalloc:shortName
 -- Pattern:Qalloc:Meter2Foot
 -- Pattern:Qalloc:Meter2Foot
 -- IS.newDescNo:58 IS.objSize:1 :%Public | BaseUnit:: Meter | Foot: Unit |    %P ...
 -- computeVariant:newDescNo:58 IS:%Public | BaseUnit:: Meter | Foot: Unit |    % ...
 -- ComputeVariant:B:Length
 -- ObjTmpStack:add::genDone:false Dimension |    %Public |    BaseUnit:: Meter ...
 -- OG:markForCodeGen:Dimension |    %public |    KiloGram: Unit |       %unit "k ..."
 -- OG:markSuper:Dimension
 -- Invocation:markForCodeGen:Dimension
 -- ObjectInvocation:markForCodeGen:Dimension ATd:Dimension:  |    %public |    ...
 -- Pattern:markForCodeGen:Dimension:  |    %public |    BaseUnit:< Unit |    Uni ...
 -- OG:markIS:Dimension |    %public |    KiloGram: Unit |       %unit "kg" |       ...
 -- items:markForCodeGen:%public | KiloGram: Unit |    %unit "kg" |    %public |    ...
 -- markItem:"%public" Property
 -- ComputeVariant:A:Mass
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Dimension
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:Dimension |    %public |    KiloGram: Unit |       %unit "kg" |     ...
 -- :varNo:1 :allocDone:false
 -- OG:super: Dimension:  |    %public |    BaseUnit:< Unit |    Unit: Value |      ...
 -- :OG:Qalloc:B:Mass:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:59 IS.newDescNo:59 :objSize:0 varNo:1 %public ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super:Dimension:super:size:1 :noGlobalsInSuper:false
 -- Items:Qalloc:super:B:objSize:1 originOff:1 
 -- Pattern:Qalloc:KiloGram
 -- Pattern:Qalloc:KiloGram
 -- IS.newDescNo:59 IS.objSize:1 :%public | KiloGram: Unit |    %unit "kg" |    % ...
 -- computeVariant:newDescNo:59 IS:%public | KiloGram: Unit |    %unit "kg" |     ...
 -- ComputeVariant:B:Mass
 -- ObjTmpStack:add::genDone:false Dimension |    %public |    KiloGram: Unit |   ...
 -- OG:markForCodeGen:Dimension -- 5:  |    %Public |    Second: Unit |       %un ...
 -- OG:markSuper:Dimension -- 5: 
 -- Invocation:markForCodeGen:Dimension -- 5: 
 -- ObjectInvocation:markForCodeGen:Dimension -- 5:  ATd:Dimension:  |    %pu ...
 -- Pattern:markForCodeGen:Dimension:  |    %public |    BaseUnit:< Unit |    Uni ...
 -- OG:markIS:Dimension -- 5:  |    %Public |    Second: Unit |       %unit "s" |   ...
 -- items:markForCodeGen:%Public | Second: Unit |    %unit "s" |    %public |    th ...
 -- markItem:"%Public" Property
 -- ComputeVariant:A:Time
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Dimension
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:Dimension -- 5:  |    %Public |    Second: Unit |       %unit "s" ...
 -- :varNo:1 :allocDone:false
 -- OG:super: Dimension:  |    %public |    BaseUnit:< Unit |    Unit: Value |      ...
 -- :OG:Qalloc:B:Time:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:60 IS.newDescNo:60 :objSize:0 varNo:1 %Public ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super:Dimension -- 5: :super:size:1 :noGlobalsInSuper:false
 -- Items:Qalloc:super:B:objSize:1 originOff:1 
 -- Pattern:Qalloc:Second
 -- Pattern:Qalloc:Second
 -- Pattern:Qalloc:Minutes
 -- Pattern:Qalloc:Minutes
 -- Pattern:Qalloc:F2M
 -- Pattern:Qalloc:F2M
 -- IS.newDescNo:60 IS.objSize:1 :%Public | Second: Unit |    %unit "s" |    %pub ...
 -- computeVariant:newDescNo:60 IS:%Public | Second: Unit |    %unit "s" |    %pu ...
 -- ComputeVariant:B:Time
 -- ObjTmpStack:add::genDone:false Dimension -- 5:  |    %Public |    Second: U ...
 -- OG:markForCodeGen:Dimension |    %Public |    MperS: Unit |       %unit "m*s^ ..."
 -- OG:markSuper:Dimension
 -- Invocation:markForCodeGen:Dimension
 -- ObjectInvocation:markForCodeGen:Dimension ATd:Dimension:  |    %public |    ...
 -- Pattern:markForCodeGen:Dimension:  |    %public |    BaseUnit:< Unit |    Uni ...
 -- OG:markIS:Dimension |    %Public |    MperS: Unit |       %unit "m*s^-1", "m* ..."
 -- items:markForCodeGen:%Public | MperS: Unit |    %unit "m*s^-1", "m*s^-1" |    ...
 -- markItem:"%Public" Property
 -- Pattern:markForCodeGen:shortName::  |    T := "V"
 -- OG:markForCodeGen:T := "V"
 -- OG:markIS:T := "V"
 -- items:markForCodeGen:T := "V"
 -- markItem:"T := "V"" ObjectCall
 -- ObjCall:markSuper:T := "V"
 -- Invocation:markForCodeGen:T := "V"
 -- ObjectInvocation:markForCodeGen:T ATd:out T: var String.String
 -- DataItem:markForCodeGen:T:descNo:0 :OG.primNo:5 
 -- ObjectInvocation:markForCodeGen::= "V" ATd::= :  |    %basic 8 |    in V: r ...
 -- Pattern:markForCodeGen::= :  |    %basic 8 |    in V: ref Value
 -- arg: "V"
 -- ObjCall:markSuper:"V"
 -- Invocation:markForCodeGen:"V"
 -- ComputeVariant:A:shortName
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:shortName
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:T := "V"
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:shortName:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:61 IS.newDescNo:61 :objSize:0 varNo:1 T := "V ..."
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super::super:size:2 :noGlobalsInSuper:false
 -- Items:Qalloc:super:B:objSize:2 originOff:1 
 -- IS.newDescNo:61 IS.objSize:2 :T := "V"
 -- computeVariant:newDescNo:61 IS:T := "V"
 -- ComputeVariant:B:shortName
 -- ObjTmpStack:add::genDone:false shortName:T := "V"
 -- Pattern:markForCodeGen:MultArgL:: Length.Meter
 -- OG:markForCodeGen:Length.Meter
 -- OG:markSuper:Length.Meter
 -- Invocation:markForCodeGen:Length.Meter
 -- ObjectInvocation:markForCodeGen:Length ATd:--Length
 -- ObjectInvocation:markForCodeGen:Meter ATd:Meter: Unit |    %unit "m" |    % ...
 -- Pattern:markForCodeGen:Meter: Unit |    %unit "m" |    %Public |    thisUnit: ...
 -- Pattern:markForCodeGen:MultArgR:: Time.Minutes
 -- OG:markForCodeGen:Time.Minutes
 -- OG:markSuper:Time.Minutes
 -- Invocation:markForCodeGen:Time.Minutes
 -- ObjectInvocation:markForCodeGen:Time ATd:--Time
 -- ObjectInvocation:markForCodeGen:Minutes ATd:Minutes: Unit |    %unit "min ..."
 -- Pattern:markForCodeGen:Minutes: Unit |    %unit "min", 60 |    %Public |    t ...
 -- OG:markForCodeGen:Unit |    %unit "min", 60 |    %Public |    thisUnit:: Minu ...
 -- OG:markSuper:Unit
 -- Invocation:markForCodeGen:Unit
 -- ObjectInvocation:markForCodeGen:Unit ATd:Unit: Value |    %unit "U" |    %p ...
 -- Pattern:markForCodeGen:Unit: Value |    %unit "U" |    %public |    magnitude ...
 -- OG:markIS:Unit |    %unit "min", 60 |    %Public |    thisUnit:: Minutes |    t ...
 -- items:markForCodeGen:%unit "min", 60 | %Public | thisUnit:: Minutes | toBase: ...
 -- markItem:"%unit "min", 60" Property
 -- markItem:"%Public" Property
 -- Pattern:markForCodeGen:thisUnit:: Minutes
 -- OG:markForCodeGen:Minutes
 -- OG:markSuper:Minutes
 -- Invocation:markForCodeGen:Minutes
 -- ObjectInvocation:markForCodeGen:Minutes ATd:Minutes: Unit |    %unit "min ..."
 -- Pattern:markForCodeGen:Minutes: Unit |    %unit "min", 60 |    %Public |    t ...
 -- Pattern:markForCodeGen:toBase::  |    base := magnitude * 60
 -- OG:markForCodeGen:base := magnitude * 60
 -- OG:markIS:base := magnitude * 60
 -- items:markForCodeGen:base := magnitude * 60
 -- markItem:"base := magnitude * 60" ObjectCall
 -- ObjCall:markSuper:base := magnitude * 60
 -- Invocation:markForCodeGen:base := magnitude * 60
 -- ObjectInvocation:markForCodeGen:base ATd:out base: var BaseUnit
 -- DataItem:markForCodeGen:base:descNo:0 :OG.primNo:0 
 -- ObjectInvocation:markForCodeGen::= magnitude * 60 ATd::= :  |    %basic 8 ...
 -- Pattern:markForCodeGen::= :  |    %basic 8 |    in V: var Value
 -- arg: magnitude * 60
 -- ObjCall:markSuper:magnitude * 60
 -- Invocation:markForCodeGen:magnitude * 60
 -- ObjectInvocation:markForCodeGen:magnitude ATd:magnitude: var Float
 -- DataItem:markForCodeGen:magnitude:descNo:0 :OG.primNo:9 
 -- ObjectInvocation:markForCodeGen:* 60 ATd:* :  |    %basic 112 |    in V: va ...
 -- Pattern:markForCodeGen:* :  |    %basic 112 |    in V: var float |    out R:  ...
 -- arg: 60
 -- ObjCall:markSuper:60
 -- Invocation:markForCodeGen:60
 -- ComputeVariant:A:toBase
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:toBase
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:base := magnitude * 60
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:toBase:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:62 IS.newDescNo:62 :objSize:0 varNo:1 base := ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super::super:size:2 :noGlobalsInSuper:false
 -- Items:Qalloc:super:B:objSize:2 originOff:1 
 -- IS.newDescNo:62 IS.objSize:2 :base := magnitude * 60
 -- computeVariant:newDescNo:62 IS:base := magnitude * 60
 -- ComputeVariant:B:toBase
 -- ObjTmpStack:add::genDone:false toBase:base := magnitude * 60
 -- Pattern:markForCodeGen:fromBase::  |    magnitude := base / 60
 -- OG:markForCodeGen:magnitude := base / 60
 -- OG:markIS:magnitude := base / 60
 -- items:markForCodeGen:magnitude := base / 60
 -- markItem:"magnitude := base / 60" ObjectCall
 -- ObjCall:markSuper:magnitude := base / 60
 -- Invocation:markForCodeGen:magnitude := base / 60
 -- ObjectInvocation:markForCodeGen:magnitude ATd:magnitude: var Float
 -- DataItem:markForCodeGen:magnitude:descNo:0 :OG.primNo:9 
 -- ObjectInvocation:markForCodeGen::= base / 60 ATd::= :  |    %basic 8 |    i ...
 -- Pattern:markForCodeGen::= :  |    %basic 8 |    in V: var Value
 -- arg: base / 60
 -- ObjCall:markSuper:base / 60
 -- Invocation:markForCodeGen:base / 60
 -- ObjectInvocation:markForCodeGen:base ATd:in base: var float
 -- DataItem:markForCodeGen:base:descNo:0 :OG.primNo:9 
 -- ObjectInvocation:markForCodeGen:/ 60 ATd:/ :  |    %basic 121 |    in V: va ...
 -- Pattern:markForCodeGen:/ :  |    %basic 121 |    in V: var float |    out R:  ...
 -- arg: 60
 -- ObjCall:markSuper:60
 -- Invocation:markForCodeGen:60
 -- ComputeVariant:A:fromBase
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:fromBase
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:magnitude := base / 60
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:fromBase:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:63 IS.newDescNo:63 :objSize:0 varNo:1 magnitu ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super::super:size:4 :noGlobalsInSuper:false
 -- Items:Qalloc:super:B:objSize:4 originOff:1 
 -- IS.newDescNo:63 IS.objSize:4 :magnitude := base / 60
 -- computeVariant:newDescNo:63 IS:magnitude := base / 60
 -- ComputeVariant:B:fromBase
 -- ObjTmpStack:add::genDone:false fromBase:magnitude := base / 60
 -- Pattern:markForCodeGen:print::  |    "Minutes".print
 -- OG:markForCodeGen:"Minutes".print
 -- OG:markIS:"Minutes".print
 -- items:markForCodeGen:"Minutes".print
 -- markItem:""Minutes".print" ObjectCall
 -- ObjCall:markSuper:"Minutes".print
 -- Invocation:markForCodeGen:"Minutes".print
 -- ObjectInvocation:markForCodeGen:print ATd:print:  |    @for 1 :to length  ...
 -- Pattern:markForCodeGen:print:  |    @for 1 :to length  |    :do  |       put( ...
 -- ComputeVariant:A:print
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:print
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"Minutes".print
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:print:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:64 IS.newDescNo:64 :objSize:0 varNo:1 "Minute ..."
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super::super:size:2 :noGlobalsInSuper:false
 -- Items:Qalloc:super:B:objSize:2 originOff:1 
 -- IS.newDescNo:64 IS.objSize:2 :"Minutes".print
 -- computeVariant:newDescNo:64 IS:"Minutes".print
 -- ComputeVariant:B:print
 -- ObjTmpStack:add::genDone:false print:"Minutes".print
 -- ComputeVariant:A:Minutes
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Unit
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Value
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:Unit |    %unit "min", 60 |    %Public |    thisUnit:: Minutes |    ...
 -- :varNo:1 :allocDone:false
 -- OG:super: Unit: Value |    %unit "U" |    %public |    magnitude: var Float |   ...
 -- :OG:Qalloc:B:Minutes:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:65 IS.newDescNo:65 :objSize:0 varNo:1 %unit " ..."
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super:Unit:super:size:2 :noGlobalsInSuper:true
 -- Items:Qalloc:super:B:objSize:2 originOff:0 
 -- Pattern:Qalloc:thisUnit
 -- Pattern:Qalloc:thisUnit
 -- Pattern:Qalloc:toBase
 -- Pattern:Qalloc:toBase
 -- Pattern:Qalloc:fromBase
 -- Pattern:Qalloc:fromBase
 -- Pattern:Qalloc:print
 -- Pattern:Qalloc:print
 -- IS.newDescNo:65 IS.objSize:2 :%unit "min", 60 | %Public | thisUnit:: Minute ...
 -- computeVariant:newDescNo:65 IS:%unit "min", 60 | %Public | thisUnit:: Minut ...
 -- ComputeVariant:B:Minutes
 -- ObjTmpStack:add::genDone:false Minutes:Unit |    %unit "min", 60 |    %Publ ...
 -- Pattern:markForCodeGen:MultRes:: MperS
 -- OG:markForCodeGen:MperS
 -- OG:markSuper:MperS
 -- Invocation:markForCodeGen:MperS
 -- ObjectInvocation:markForCodeGen:MperS ATd:MperS: Unit |    %unit "m*s^-1" ...
 -- Pattern:markForCodeGen:MperS: Unit |    %unit "m*s^-1", "m*s^-1" |    %Publ ...
 -- OG:markForCodeGen:Unit |    %unit "m*s^-1", "m*s^-1" |    %Public |    thisUn ...
 -- OG:markSuper:Unit
 -- Invocation:markForCodeGen:Unit
 -- ObjectInvocation:markForCodeGen:Unit ATd:Unit: Value |    %unit "U" |    %p ...
 -- Pattern:markForCodeGen:Unit: Value |    %unit "U" |    %public |    magnitude ...
 -- OG:markIS:Unit |    %unit "m*s^-1", "m*s^-1" |    %Public |    thisUnit:: Mpe ...
 -- items:markForCodeGen:%unit "m*s^-1", "m*s^-1" | %Public | thisUnit:: MperS |  ...
 -- markItem:"%unit "m*s^-1", "m*s^-1"" Property
 -- markItem:"%Public" Property
 -- Pattern:markForCodeGen:thisUnit:: MperS
 -- OG:markForCodeGen:MperS
 -- OG:markSuper:MperS
 -- Invocation:markForCodeGen:MperS
 -- ObjectInvocation:markForCodeGen:MperS ATd:MperS: Unit |    %unit "m*s^-1" ...
 -- Pattern:markForCodeGen:MperS: Unit |    %unit "m*s^-1", "m*s^-1" |    %Publ ...
 -- Pattern:markForCodeGen:print::  |    "MperS".print
 -- OG:markForCodeGen:"MperS".print
 -- OG:markIS:"MperS".print
 -- items:markForCodeGen:"MperS".print
 -- markItem:""MperS".print" ObjectCall
 -- ObjCall:markSuper:"MperS".print
 -- Invocation:markForCodeGen:"MperS".print
 -- ObjectInvocation:markForCodeGen:print ATd:print:  |    @for 1 :to length  ...
 -- Pattern:markForCodeGen:print:  |    @for 1 :to length  |    :do  |       put( ...
 -- ComputeVariant:A:print
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:print
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"MperS".print
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:print:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:66 IS.newDescNo:66 :objSize:0 varNo:1 "MperS" ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super::super:size:2 :noGlobalsInSuper:false
 -- Items:Qalloc:super:B:objSize:2 originOff:1 
 -- IS.newDescNo:66 IS.objSize:2 :"MperS".print
 -- computeVariant:newDescNo:66 IS:"MperS".print
 -- ComputeVariant:B:print
 -- ObjTmpStack:add::genDone:false print:"MperS".print
 -- ComputeVariant:A:MperS
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Unit
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Value
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:Unit |    %unit "m*s^-1", "m*s^-1" |    %Public |    thisUnit:: M ...
 -- :varNo:1 :allocDone:false
 -- OG:super: Unit: Value |    %unit "U" |    %public |    magnitude: var Float |   ...
 -- :OG:Qalloc:B:MperS:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:67 IS.newDescNo:67 :objSize:0 varNo:1 %unit " ..."
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super:Unit:super:size:2 :noGlobalsInSuper:true
 -- Items:Qalloc:super:B:objSize:2 originOff:0 
 -- Pattern:Qalloc:thisUnit
 -- Pattern:Qalloc:thisUnit
 -- Pattern:Qalloc:print
 -- Pattern:Qalloc:print
 -- IS.newDescNo:67 IS.objSize:2 :%unit "m*s^-1", "m*s^-1" | %Public | thisUnit ...
 -- computeVariant:newDescNo:67 IS:%unit "m*s^-1", "m*s^-1" | %Public | thisUni ...
 -- ComputeVariant:B:MperS
 -- ObjTmpStack:add::genDone:false MperS:Unit |    %unit "m*s^-1", "m*s^-1" |   ...
 -- ComputeVariant:A:Velocity
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Dimension
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:Dimension |    %Public |    MperS: Unit |       %unit "m*s^-1", " ..."
 -- :varNo:1 :allocDone:false
 -- OG:super: Dimension:  |    %public |    BaseUnit:< Unit |    Unit: Value |      ...
 -- :OG:Qalloc:B:Velocity:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:68 IS.newDescNo:68 :objSize:0 varNo:1 %Public ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super:Dimension:super:size:1 :noGlobalsInSuper:false
 -- Items:Qalloc:super:B:objSize:1 originOff:1 
 -- Pattern:Qalloc:MperS
 -- Pattern:Qalloc:MperS
 -- Pattern:Qalloc:mult
 -- Pattern:Qalloc:mult
 -- Pattern:Qalloc:div
 -- Pattern:Qalloc:div
 -- Pattern:Qalloc:F2M
 -- Pattern:Qalloc:F2M
 -- Pattern:Qalloc:shortName
 -- Pattern:Qalloc:shortName
 -- Pattern:Qalloc:MultArgL
 -- Pattern:Qalloc:MultArgL
 -- Pattern:Qalloc:MultArgR
 -- Pattern:Qalloc:MultArgR
 -- Pattern:Qalloc:MultRes
 -- Pattern:Qalloc:MultRes
 -- IS.newDescNo:68 IS.objSize:1 :%Public | MperS: Unit |    %unit "m*s^-1", "m ..."
 -- computeVariant:newDescNo:68 IS:%Public | MperS: Unit |    %unit "m*s^-1", " ..."
 -- ComputeVariant:B:Velocity
 -- ObjTmpStack:add::genDone:false Dimension |    %Public |    MperS: Unit |      ...
 -- ComputeVariant:A:Dimensions
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:%domain_boundary | %public | Dimension:  |    %public |    BaseUnit ...
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:Dimensions:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:69 IS.newDescNo:69 :objSize:0 varNo:1 %domain ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- Pattern:Qalloc:Dimension
 -- Pattern:Qalloc:Dimension
 -- ModuleItem:Qalloc: --Acceleration
 -- ModuleItem:Qalloc: --AmountOfSubstance
 -- ModuleItem:Qalloc: --Area
 -- ModuleItem:Qalloc:B:
 -- Qalloc:module:Area
 -- Module:alloc:off:2 Area: obj Dimension |    %Public |    SquareMeter: Unit |  ...
 -- ModuleItem:Qalloc: --ElectricCurrent
 -- ModuleItem:Qalloc: --Energy
 -- ModuleItem:Qalloc: --Force
 -- ModuleItem:Qalloc: --Length
 -- ModuleItem:Qalloc:B:
 -- Qalloc:module:Length
 -- Module:alloc:off:3 Length: obj Dimension |    %Public |    BaseUnit:: Meter ...
 -- ModuleItem:Qalloc: --LuminousIntensity
 -- ModuleItem:Qalloc: --MagneticFluxDensity
 -- ModuleItem:Qalloc: --Mass
 -- ModuleItem:Qalloc:B:
 -- Qalloc:module:Mass
 -- Module:alloc:off:4 Mass: obj Dimension |    %public |    KiloGram: Unit |     ...
 -- ModuleItem:Qalloc: --MeterPowerN
 -- ModuleItem:Qalloc: --Temperature
 -- ModuleItem:Qalloc: --ThermodynamicTemperature
 -- ModuleItem:Qalloc: --Time
 -- ModuleItem:Qalloc:B:
 -- Qalloc:module:Time
 -- Module:alloc:off:5 Time: obj Dimension -- 5:  |    %Public |    Second: Uni ...
 -- ModuleItem:Qalloc: --Velocity
 -- ModuleItem:Qalloc:B:
 -- Qalloc:module:Velocity
 -- Module:alloc:off:6 Velocity: obj Dimension |    %Public |    MperS: Unit |    ...
 -- ModuleItem:Qalloc: --Volume
 -- IS.newDescNo:69 IS.objSize:6 :%domain_boundary | %public | Dimension:  |    % ...
 -- computeVariant:newDescNo:69 IS:%domain_boundary | %public | Dimension:  |     ...
 -- ComputeVariant:B:Dimensions
 -- ObjTmpStack:add::genDone:false %domain_boundary | %public | Dimension:  |     ...
 -- ComputeVariant:A:LIB
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:%include BETA | x_dummy_LIB: var integer | --Associations | --Bas ...
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:LIB:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:70 IS.newDescNo:70 :objSize:0 varNo:1 %includ ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- dataitem:qalloc:x_dummy_LIB isValue:true isPrimitive: true isValObj: true  ...true
 -- ModuleItem:Qalloc: --Associations
 -- ModuleItem:Qalloc:B:
 -- Qalloc:module:Associations
 -- Module:alloc:off:3 Associations: obj  |    %include Containers |    %Public ...
 -- ModuleItem:Qalloc: --BasicIO
 -- ModuleItem:Qalloc:B:
 -- Qalloc:module:BasicIO
 -- Module:alloc:off:4 BasicIO: obj  |    %Public |    Lock:  |       dummy: var  ...
 -- ModuleItem:Qalloc: --BasicSystem
 -- ModuleItem:Qalloc: --Complex
 -- ModuleItem:Qalloc: --Containers
 -- ModuleItem:Qalloc:B:
 -- Qalloc:module:Containers
 -- Module:alloc:off:5 Containers: obj  |    Container:  |       in elm:< Objec ...
 -- ModuleItem:Qalloc: --Dimensions
 -- ModuleItem:Qalloc:B:
 -- Qalloc:module:Dimensions
 -- Module:alloc:off:6 Dimensions: obj  |    %domain_boundary |    %public |    D ...
 -- ModuleItem:Qalloc: --EMC2array
 -- ModuleItem:Qalloc: --Embedded
 -- ModuleItem:Qalloc: --FileSys
 -- ModuleItem:Qalloc: --ForkJoinSystem
 -- ModuleItem:Qalloc: --MetaSystem
 -- ModuleItem:Qalloc: --MonitorSystem
 -- ModuleItem:Qalloc: --NonBlockingIO
 -- ModuleItem:Qalloc: --SimpleConcurrentProcesses
 -- ModuleItem:Qalloc: --Socket
 -- ModuleItem:Qalloc: --SocketSystem
 -- ModuleItem:Qalloc: --String
 -- ModuleItem:Qalloc:B:
 -- Qalloc:module:String
 -- Module:alloc:off:7 String: obj  |    %public |    String:  |       %OSDvisibi ...
 -- ModuleItem:Qalloc: --Units
 -- IS.newDescNo:70 IS.objSize:7 :%include BETA | x_dummy_LIB: var integer | -- ...
 -- computeVariant:newDescNo:70 IS:%include BETA | x_dummy_LIB: var integer | - ...
 -- ComputeVariant:B:LIB
 -- ObjTmpStack:add::genDone:false %include BETA | x_dummy_LIB: var integer | - ...
 -- OG:markForCodeGen:%include BETA, LIB, LIB.BasicIO | %domain_boundary | --Ac ...
 -- OG:markIS:%include BETA, LIB, LIB.BasicIO | %domain_boundary | --AccessEx | - ...
 -- items:markForCodeGen:%include BETA, LIB, LIB.BasicIO | %domain_boundary | - ...
 -- markItem:"%include BETA, LIB, LIB.BasicIO" Property
 -- markItem:"%domain_boundary" Property
 -- OG:markForCodeGen:%include Associations | --ArrayDemos | --Bank | --BasicValu ...
 -- OG:markIS:%include Associations | --ArrayDemos | --Bank | --BasicValueSub | --B ...
 -- items:markForCodeGen:%include Associations | --ArrayDemos | --Bank | --BasicV ...
 -- markItem:"%include Associations" Property
 -- OG:markForCodeGen:%include Dimensions | rocketSpeed: var Velocity.MperS | e ...
 -- OG:markIS:%include Dimensions | rocketSpeed: var Velocity.MperS | exhaustSp ...
 -- items:markForCodeGen:%include Dimensions | rocketSpeed: var Velocity.Mper ...
 -- markItem:"%include Dimensions" Property
 -- DataItem:markForCodeGen:rocketSpeed:descNo:0 :OG.primNo:0 
 -- ObjCall:markSuper:Velocity.MperS
 -- Invocation:markForCodeGen:Velocity.MperS
 -- ObjectInvocation:markForCodeGen:Velocity ATd:--Velocity
 -- ObjectInvocation:markForCodeGen:MperS ATd:MperS: Unit |    %unit "m*s^-1" ...
 -- Pattern:markForCodeGen:MperS: Unit |    %unit "m*s^-1", "m*s^-1" |    %Publ ...
 -- DataItem:markForCodeGen:exhaustSpeed:descNo:0 :OG.primNo:0 
 -- ObjCall:markSuper:Velocity.MperS
 -- Invocation:markForCodeGen:Velocity.MperS
 -- ObjectInvocation:markForCodeGen:Velocity ATd:--Velocity
 -- ObjectInvocation:markForCodeGen:MperS ATd:MperS: Unit |    %unit "m*s^-1" ...
 -- Pattern:markForCodeGen:MperS: Unit |    %unit "m*s^-1", "m*s^-1" |    %Publ ...
 -- DataItem:markForCodeGen:rocketMass:descNo:0 :OG.primNo:0 
 -- ObjCall:markSuper:Mass.KiloGram
 -- Invocation:markForCodeGen:Mass.KiloGram
 -- ObjectInvocation:markForCodeGen:Mass ATd:--Mass
 -- ObjectInvocation:markForCodeGen:KiloGram ATd:KiloGram: Unit |    %unit "k ..."
 -- Pattern:markForCodeGen:KiloGram: Unit |    %unit "kg" |    %public |    thisU ...
 -- OG:markForCodeGen:Unit |    %unit "kg" |    %public |    thisUnit:: KiloGram |  ...
 -- OG:markSuper:Unit
 -- Invocation:markForCodeGen:Unit
 -- ObjectInvocation:markForCodeGen:Unit ATd:Unit: Value |    %unit "U" |    %p ...
 -- Pattern:markForCodeGen:Unit: Value |    %unit "U" |    %public |    magnitude ...
 -- OG:markIS:Unit |    %unit "kg" |    %public |    thisUnit:: KiloGram |    print ...
 -- items:markForCodeGen:%unit "kg" | %public | thisUnit:: KiloGram | print::  |    ...
 -- markItem:"%unit "kg"" Property
 -- markItem:"%public" Property
 -- Pattern:markForCodeGen:thisUnit:: KiloGram
 -- OG:markForCodeGen:KiloGram
 -- OG:markSuper:KiloGram
 -- Invocation:markForCodeGen:KiloGram
 -- ObjectInvocation:markForCodeGen:KiloGram ATd:KiloGram: Unit |    %unit "k ..."
 -- Pattern:markForCodeGen:KiloGram: Unit |    %unit "kg" |    %public |    thisU ...
 -- Pattern:markForCodeGen:print::  |    "kg".print
 -- OG:markForCodeGen:"kg".print
 -- OG:markIS:"kg".print
 -- items:markForCodeGen:"kg".print
 -- markItem:""kg".print" ObjectCall
 -- ObjCall:markSuper:"kg".print
 -- Invocation:markForCodeGen:"kg".print
 -- ObjectInvocation:markForCodeGen:print ATd:print:  |    @for 1 :to length  ...
 -- Pattern:markForCodeGen:print:  |    @for 1 :to length  |    :do  |       put( ...
 -- ComputeVariant:A:print
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:print
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"kg".print
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:print:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:71 IS.newDescNo:71 :objSize:0 varNo:1 "kg".pr ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super::super:size:2 :noGlobalsInSuper:false
 -- Items:Qalloc:super:B:objSize:2 originOff:1 
 -- IS.newDescNo:71 IS.objSize:2 :"kg".print
 -- computeVariant:newDescNo:71 IS:"kg".print
 -- ComputeVariant:B:print
 -- ObjTmpStack:add::genDone:false print:"kg".print
 -- ComputeVariant:A:KiloGram
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Unit
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Value
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:Unit |    %unit "kg" |    %public |    thisUnit:: KiloGram |    pri ...
 -- :varNo:1 :allocDone:false
 -- OG:super: Unit: Value |    %unit "U" |    %public |    magnitude: var Float |   ...
 -- :OG:Qalloc:B:KiloGram:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:72 IS.newDescNo:72 :objSize:0 varNo:1 %unit " ..."
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super:Unit:super:size:2 :noGlobalsInSuper:true
 -- Items:Qalloc:super:B:objSize:2 originOff:0 
 -- Pattern:Qalloc:thisUnit
 -- Pattern:Qalloc:thisUnit
 -- Pattern:Qalloc:print
 -- Pattern:Qalloc:print
 -- IS.newDescNo:72 IS.objSize:2 :%unit "kg" | %public | thisUnit:: KiloGram | pr ...
 -- computeVariant:newDescNo:72 IS:%unit "kg" | %public | thisUnit:: KiloGram | p ...
 -- ComputeVariant:B:KiloGram
 -- ObjTmpStack:add::genDone:false KiloGram:Unit |    %unit "kg" |    %public |   ...
 -- DataItem:markForCodeGen:fuelMass:descNo:0 :OG.primNo:0 
 -- ObjCall:markSuper:Mass.KiloGram
 -- Invocation:markForCodeGen:Mass.KiloGram
 -- ObjectInvocation:markForCodeGen:Mass ATd:--Mass
 -- ObjectInvocation:markForCodeGen:KiloGram ATd:KiloGram: Unit |    %unit "k ..."
 -- Pattern:markForCodeGen:KiloGram: Unit |    %unit "kg" |    %public |    thisU ...
 -- DataItem:markForCodeGen:distToAlpha:descNo:0 :OG.primNo:0 
 -- ObjCall:markSuper:Length.LightYear
 -- Invocation:markForCodeGen:Length.LightYear
 -- ObjectInvocation:markForCodeGen:Length ATd:--Length
 -- ObjectInvocation:markForCodeGen:LightYear ATd:LightYear: Unit |    %unit  ...
 -- Pattern:markForCodeGen:LightYear: Unit |    %unit "ly", "9460000000000000 ..."
 -- OG:markForCodeGen:Unit |    %unit "ly", "9460000000000000" |    toBase::  |   ...
 -- OG:markSuper:Unit
 -- Invocation:markForCodeGen:Unit
 -- ObjectInvocation:markForCodeGen:Unit ATd:Unit: Value |    %unit "U" |    %p ...
 -- Pattern:markForCodeGen:Unit: Value |    %unit "U" |    %public |    magnitude ...
 -- OG:markIS:Unit |    %unit "ly", "9460000000000000" |    toBase::  |       --b ...
 -- items:markForCodeGen:%unit "ly", "9460000000000000" | toBase::  |    --bxx: ...
 -- markItem:"%unit "ly", "9460000000000000"" Property
 -- Pattern:markForCodeGen:toBase::  |    --bxx: var BaseUnit |    --bxx := mag ...
 -- OG:markForCodeGen:--bxx: var BaseUnit | --bxx := magnitude * 946000000000 ...
 -- OG:markIS:--bxx: var BaseUnit | --bxx := magnitude * 9460000000000000.0 | b ...
 -- items:markForCodeGen:--bxx: var BaseUnit | --bxx := magnitude * 946000000 ...
 -- markItem:"base := magnitude * 9460000000000000.0" ObjectCall
 -- ObjCall:markSuper:base := magnitude * 9460000000000000.0
 -- Invocation:markForCodeGen:base := magnitude * 9460000000000000.0
 -- ObjectInvocation:markForCodeGen:base ATd:out base: var BaseUnit
 -- DataItem:markForCodeGen:base:descNo:0 :OG.primNo:0 
 -- ObjectInvocation:markForCodeGen::= magnitude * 9460000000000000.0 ATd:: ...
 -- Pattern:markForCodeGen::= :  |    %basic 8 |    in V: var Value
 -- arg: magnitude * 9460000000000000.0
 -- ObjCall:markSuper:magnitude * 9460000000000000.0
 -- Invocation:markForCodeGen:magnitude * 9460000000000000.0
 -- ObjectInvocation:markForCodeGen:magnitude ATd:magnitude: var Float
 -- DataItem:markForCodeGen:magnitude:descNo:0 :OG.primNo:9 
 -- ObjectInvocation:markForCodeGen:* 9460000000000000.0 ATd:* :  |    %basic ...
 -- Pattern:markForCodeGen:* :  |    %basic 112 |    in V: var float |    out R:  ...
 -- arg: 9460000000000000.0
 -- ObjCall:markSuper:9460000000000000.0
 -- Invocation:markForCodeGen:9460000000000000.0
 -- ComputeVariant:A:toBase
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:toBase
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:--bxx: var BaseUnit | --bxx := magnitude * 9460000000000000.0 ...
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:toBase:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:73 IS.newDescNo:73 :objSize:0 varNo:1 --bxx:  ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super::super:size:2 :noGlobalsInSuper:false
 -- Items:Qalloc:super:B:objSize:2 originOff:1 
 -- IS.newDescNo:73 IS.objSize:2 :--bxx: var BaseUnit | --bxx := magnitude *  ...
 -- computeVariant:newDescNo:73 IS:--bxx: var BaseUnit | --bxx := magnitude * ...
 -- ComputeVariant:B:toBase
 -- ObjTmpStack:add::genDone:false toBase:--bxx: var BaseUnit | --bxx := magn ...
 -- Pattern:markForCodeGen:fromBase::  |    magnitude := base / 9460000000000 ...
 -- OG:markForCodeGen:magnitude := base / 9460000000000000.0
 -- OG:markIS:magnitude := base / 9460000000000000.0
 -- items:markForCodeGen:magnitude := base / 9460000000000000.0
 -- markItem:"magnitude := base / 9460000000000000.0" ObjectCall
 -- ObjCall:markSuper:magnitude := base / 9460000000000000.0
 -- Invocation:markForCodeGen:magnitude := base / 9460000000000000.0
 -- ObjectInvocation:markForCodeGen:magnitude ATd:magnitude: var Float
 -- DataItem:markForCodeGen:magnitude:descNo:0 :OG.primNo:9 
 -- ObjectInvocation:markForCodeGen::= base / 9460000000000000.0 ATd::= :  |  ...
 -- Pattern:markForCodeGen::= :  |    %basic 8 |    in V: var Value
 -- arg: base / 9460000000000000.0
 -- ObjCall:markSuper:base / 9460000000000000.0
 -- Invocation:markForCodeGen:base / 9460000000000000.0
 -- ObjectInvocation:markForCodeGen:base ATd:in base: var float
 -- DataItem:markForCodeGen:base:descNo:0 :OG.primNo:9 
 -- ObjectInvocation:markForCodeGen:/ 9460000000000000.0 ATd:/ :  |    %basic ...
 -- Pattern:markForCodeGen:/ :  |    %basic 121 |    in V: var float |    out R:  ...
 -- arg: 9460000000000000.0
 -- ObjCall:markSuper:9460000000000000.0
 -- Invocation:markForCodeGen:9460000000000000.0
 -- ComputeVariant:A:fromBase
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:fromBase
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:magnitude := base / 9460000000000000.0
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:fromBase:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:74 IS.newDescNo:74 :objSize:0 varNo:1 magnitu ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super::super:size:4 :noGlobalsInSuper:false
 -- Items:Qalloc:super:B:objSize:4 originOff:1 
 -- IS.newDescNo:74 IS.objSize:4 :magnitude := base / 9460000000000000.0
 -- computeVariant:newDescNo:74 IS:magnitude := base / 9460000000000000.0
 -- ComputeVariant:B:fromBase
 -- ObjTmpStack:add::genDone:false fromBase:magnitude := base / 94600000000 ...
 -- Pattern:markForCodeGen:print::  |    "LightYear".print
 -- OG:markForCodeGen:"LightYear".print
 -- OG:markIS:"LightYear".print
 -- items:markForCodeGen:"LightYear".print
 -- markItem:""LightYear".print" ObjectCall
 -- ObjCall:markSuper:"LightYear".print
 -- Invocation:markForCodeGen:"LightYear".print
 -- ObjectInvocation:markForCodeGen:print ATd:print:  |    @for 1 :to length  ...
 -- Pattern:markForCodeGen:print:  |    @for 1 :to length  |    :do  |       put( ...
 -- ComputeVariant:A:print
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:print
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"LightYear".print
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:print:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:75 IS.newDescNo:75 :objSize:0 varNo:1 "LightY ..."
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super::super:size:2 :noGlobalsInSuper:false
 -- Items:Qalloc:super:B:objSize:2 originOff:1 
 -- IS.newDescNo:75 IS.objSize:2 :"LightYear".print
 -- computeVariant:newDescNo:75 IS:"LightYear".print
 -- ComputeVariant:B:print
 -- ObjTmpStack:add::genDone:false print:"LightYear".print
 -- ComputeVariant:A:LightYear
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Unit
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Value
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:Unit |    %unit "ly", "9460000000000000" |    toBase::  |       - ...
 -- :varNo:1 :allocDone:false
 -- OG:super: Unit: Value |    %unit "U" |    %public |    magnitude: var Float |   ...
 -- :OG:Qalloc:B:LightYear:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:76 IS.newDescNo:76 :objSize:0 varNo:1 %unit " ..."
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super:Unit:super:size:2 :noGlobalsInSuper:true
 -- Items:Qalloc:super:B:objSize:2 originOff:0 
 -- Pattern:Qalloc:toBase
 -- Pattern:Qalloc:toBase
 -- Pattern:Qalloc:fromBase
 -- Pattern:Qalloc:fromBase
 -- Pattern:Qalloc:print
 -- Pattern:Qalloc:print
 -- IS.newDescNo:76 IS.objSize:2 :%unit "ly", "9460000000000000" | toBase::  |  ...
 -- computeVariant:newDescNo:76 IS:%unit "ly", "9460000000000000" | toBase::  ...
 -- ComputeVariant:B:LightYear
 -- ObjTmpStack:add::genDone:false LightYear:Unit |    %unit "ly", "946000000 ..."
 -- DataItem:markForCodeGen:t:descNo:0 :OG.primNo:0 
 -- ObjCall:markSuper:Time.Second
 -- Invocation:markForCodeGen:Time.Second
 -- ObjectInvocation:markForCodeGen:Time ATd:--Time
 -- ObjectInvocation:markForCodeGen:Second ATd:Second: Unit |    %unit "s" |    ...
 -- Pattern:markForCodeGen:Second: Unit |    %unit "s" |    %public |    thisUnit ...
 -- OG:markForCodeGen:Unit |    %unit "s" |    %public |    thisUnit:: Second |     ...
 -- OG:markSuper:Unit
 -- Invocation:markForCodeGen:Unit
 -- ObjectInvocation:markForCodeGen:Unit ATd:Unit: Value |    %unit "U" |    %p ...
 -- Pattern:markForCodeGen:Unit: Value |    %unit "U" |    %public |    magnitude ...
 -- OG:markIS:Unit |    %unit "s" |    %public |    thisUnit:: Second |    toBase:: ...
 -- items:markForCodeGen:%unit "s" | %public | thisUnit:: Second | toBase::  |    b ...
 -- markItem:"%unit "s"" Property
 -- markItem:"%public" Property
 -- Pattern:markForCodeGen:thisUnit:: Second
 -- OG:markForCodeGen:Second
 -- OG:markSuper:Second
 -- Invocation:markForCodeGen:Second
 -- ObjectInvocation:markForCodeGen:Second ATd:Second: Unit |    %unit "s" |    ...
 -- Pattern:markForCodeGen:Second: Unit |    %unit "s" |    %public |    thisUnit ...
 -- Pattern:markForCodeGen:toBase::  |    base := magnitude
 -- OG:markForCodeGen:base := magnitude
 -- OG:markIS:base := magnitude
 -- items:markForCodeGen:base := magnitude
 -- markItem:"base := magnitude" ObjectCall
 -- ObjCall:markSuper:base := magnitude
 -- Invocation:markForCodeGen:base := magnitude
 -- ObjectInvocation:markForCodeGen:base ATd:out base: var BaseUnit
 -- DataItem:markForCodeGen:base:descNo:0 :OG.primNo:0 
 -- ObjectInvocation:markForCodeGen::= magnitude ATd::= :  |    %basic 8 |    i ...
 -- Pattern:markForCodeGen::= :  |    %basic 8 |    in V: var Value
 -- arg: magnitude
 -- ComputeVariant:A:toBase
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:toBase
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:base := magnitude
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:toBase:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:77 IS.newDescNo:77 :objSize:0 varNo:1 base := ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super::super:size:2 :noGlobalsInSuper:false
 -- Items:Qalloc:super:B:objSize:2 originOff:1 
 -- IS.newDescNo:77 IS.objSize:2 :base := magnitude
 -- computeVariant:newDescNo:77 IS:base := magnitude
 -- ComputeVariant:B:toBase
 -- ObjTmpStack:add::genDone:false toBase:base := magnitude
 -- Pattern:markForCodeGen:fromBase::  |    magnitude := base
 -- OG:markForCodeGen:magnitude := base
 -- OG:markIS:magnitude := base
 -- items:markForCodeGen:magnitude := base
 -- markItem:"magnitude := base" ObjectCall
 -- ObjCall:markSuper:magnitude := base
 -- Invocation:markForCodeGen:magnitude := base
 -- ObjectInvocation:markForCodeGen:magnitude ATd:magnitude: var Float
 -- DataItem:markForCodeGen:magnitude:descNo:0 :OG.primNo:9 
 -- ObjectInvocation:markForCodeGen::= base ATd::= :  |    %basic 8 |    in V:  ...
 -- Pattern:markForCodeGen::= :  |    %basic 8 |    in V: var Value
 -- arg: base
 -- ComputeVariant:A:fromBase
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:fromBase
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:magnitude := base
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:fromBase:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:78 IS.newDescNo:78 :objSize:0 varNo:1 magnitu ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super::super:size:4 :noGlobalsInSuper:false
 -- Items:Qalloc:super:B:objSize:4 originOff:1 
 -- IS.newDescNo:78 IS.objSize:4 :magnitude := base
 -- computeVariant:newDescNo:78 IS:magnitude := base
 -- ComputeVariant:B:fromBase
 -- ObjTmpStack:add::genDone:false fromBase:magnitude := base
 -- Pattern:markForCodeGen:print::  |    "Second".print
 -- OG:markForCodeGen:"Second".print
 -- OG:markIS:"Second".print
 -- items:markForCodeGen:"Second".print
 -- markItem:""Second".print" ObjectCall
 -- ObjCall:markSuper:"Second".print
 -- Invocation:markForCodeGen:"Second".print
 -- ObjectInvocation:markForCodeGen:print ATd:print:  |    @for 1 :to length  ...
 -- Pattern:markForCodeGen:print:  |    @for 1 :to length  |    :do  |       put( ...
 -- ComputeVariant:A:print
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:print
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"Second".print
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:print:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:79 IS.newDescNo:79 :objSize:0 varNo:1 "Second ..."
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super::super:size:2 :noGlobalsInSuper:false
 -- Items:Qalloc:super:B:objSize:2 originOff:1 
 -- IS.newDescNo:79 IS.objSize:2 :"Second".print
 -- computeVariant:newDescNo:79 IS:"Second".print
 -- ComputeVariant:B:print
 -- ObjTmpStack:add::genDone:false print:"Second".print
 -- ComputeVariant:A:Second
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Unit
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Value
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:Unit |    %unit "s" |    %public |    thisUnit:: Second |    toBase ...
 -- :varNo:1 :allocDone:false
 -- OG:super: Unit: Value |    %unit "U" |    %public |    magnitude: var Float |   ...
 -- :OG:Qalloc:B:Second:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:80 IS.newDescNo:80 :objSize:0 varNo:1 %unit " ..."
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super:Unit:super:size:2 :noGlobalsInSuper:true
 -- Items:Qalloc:super:B:objSize:2 originOff:0 
 -- Pattern:Qalloc:thisUnit
 -- Pattern:Qalloc:thisUnit
 -- Pattern:Qalloc:toBase
 -- Pattern:Qalloc:toBase
 -- Pattern:Qalloc:fromBase
 -- Pattern:Qalloc:fromBase
 -- Pattern:Qalloc:print
 -- Pattern:Qalloc:print
 -- IS.newDescNo:80 IS.objSize:2 :%unit "s" | %public | thisUnit:: Second | toBas ...
 -- computeVariant:newDescNo:80 IS:%unit "s" | %public | thisUnit:: Second | toBa ...
 -- ComputeVariant:B:Second
 -- ObjTmpStack:add::genDone:false Second:Unit |    %unit "s" |    %public |    t ...
 -- markItem:"exhaustSpeed := 1000000.0"m*s^-1"" ObjectCall
 -- ObjCall:markSuper:exhaustSpeed := 1000000.0"m*s^-1"
 -- Invocation:markForCodeGen:exhaustSpeed := 1000000.0"m*s^-1"
 -- ObjectInvocation:markForCodeGen:exhaustSpeed ATd:exhaustSpeed: var Velo ...
 -- DataItem:markForCodeGen:exhaustSpeed:descNo:0 :OG.primNo:0 
 -- ObjectInvocation:markForCodeGen::= 1000000.0"m*s^-1" ATd::= :  |    %basi ...
 -- Pattern:markForCodeGen::= :  |    %basic 8 |    in V: var Value
 -- arg: 1000000.0"m*s^-1"
 -- ObjCall:markSuper:1000000.0"m*s^-1"
 -- Invocation:markForCodeGen:1000000.0"m*s^-1"
 -- markItem:"rocketMass := 40"kg"" ObjectCall
 -- ObjCall:markSuper:rocketMass := 40"kg"
 -- Invocation:markForCodeGen:rocketMass := 40"kg"
 -- ObjectInvocation:markForCodeGen:rocketMass ATd:rocketMass: var Mass.Kil ...
 -- DataItem:markForCodeGen:rocketMass:descNo:0 :OG.primNo:0 
 -- ObjectInvocation:markForCodeGen::= 40"kg" ATd::= :  |    %basic 8 |    in V ...
 -- Pattern:markForCodeGen::= :  |    %basic 8 |    in V: var Value
 -- arg: 40"kg"
 -- ObjCall:markSuper:40"kg"
 -- Invocation:markForCodeGen:40"kg"
 -- markItem:"fuelMass := 10000"kg"" ObjectCall
 -- ObjCall:markSuper:fuelMass := 10000"kg"
 -- Invocation:markForCodeGen:fuelMass := 10000"kg"
 -- ObjectInvocation:markForCodeGen:fuelMass ATd:fuelMass: var Mass.KiloGra ...
 -- DataItem:markForCodeGen:fuelMass:descNo:0 :OG.primNo:0 
 -- ObjectInvocation:markForCodeGen::= 10000"kg" ATd::= :  |    %basic 8 |    i ...
 -- Pattern:markForCodeGen::= :  |    %basic 8 |    in V: var Value
 -- arg: 10000"kg"
 -- ObjCall:markSuper:10000"kg"
 -- Invocation:markForCodeGen:10000"kg"
 -- markItem:"distToAlpha := 70"ly"" ObjectCall
 -- ObjCall:markSuper:distToAlpha := 70"ly"
 -- Invocation:markForCodeGen:distToAlpha := 70"ly"
 -- ObjectInvocation:markForCodeGen:distToAlpha ATd:distToAlpha: var Length ...
 -- DataItem:markForCodeGen:distToAlpha:descNo:0 :OG.primNo:0 
 -- ObjectInvocation:markForCodeGen::= 70"ly" ATd::= :  |    %basic 8 |    in V ...
 -- Pattern:markForCodeGen::= :  |    %basic 8 |    in V: var Value
 -- arg: 70"ly"
 -- ObjCall:markSuper:70"ly"
 -- Invocation:markForCodeGen:70"ly"
 -- DataItem:markForCodeGen:Y:descNo:0 :OG.primNo:0 
 -- ObjCall:markSuper:Length.Meter
 -- Invocation:markForCodeGen:Length.Meter
 -- ObjectInvocation:markForCodeGen:Length ATd:--Length
 -- ObjectInvocation:markForCodeGen:Meter ATd:Meter: Unit |    %unit "m" |    % ...
 -- Pattern:markForCodeGen:Meter: Unit |    %unit "m" |    %Public |    thisUnit: ...
 -- markItem:""distToAlpha: ".print" ObjectCall
 -- ObjCall:markSuper:"distToAlpha: ".print
 -- Invocation:markForCodeGen:"distToAlpha: ".print
 -- ObjectInvocation:markForCodeGen:print ATd:print:  |    @for 1 :to length  ...
 -- Pattern:markForCodeGen:print:  |    @for 1 :to length  |    :do  |       put( ...
 -- markItem:"putFloat(distToAlpha)" ObjectCall
 -- ObjCall:markSuper:putFloat(distToAlpha)
 -- Invocation:markForCodeGen:putFloat(distToAlpha)
 -- ObjectInvocation:markForCodeGen:putFloat(distToAlpha) ATd:putFloat:  |    ...
 -- Pattern:markForCodeGen:putFloat:  |    %basic 142 |    in X: var Float |    o ...
 -- arg: distToAlpha
 -- OG:markForCodeGen:distToAlpha
 -- markItem:"Y := distToAlpha.toBase" ObjectCall
 -- ObjCall:markSuper:Y := distToAlpha.toBase
 -- Invocation:markForCodeGen:Y := distToAlpha.toBase
 -- ObjectInvocation:markForCodeGen:Y ATd:Y: var Length.Meter
 -- DataItem:markForCodeGen:Y:descNo:0 :OG.primNo:0 
 -- ObjectInvocation:markForCodeGen::= distToAlpha.toBase ATd::= :  |    %bas ...
 -- Pattern:markForCodeGen::= :  |    %basic 8 |    in V: var Value
 -- arg: distToAlpha.toBase
 -- ObjCall:markSuper:distToAlpha.toBase
 -- Invocation:markForCodeGen:distToAlpha.toBase
 -- ObjectInvocation:markForCodeGen:distToAlpha ATd:distToAlpha: var Length ...
 -- DataItem:markForCodeGen:distToAlpha:descNo:0 :OG.primNo:0 
 -- ObjectInvocation:markForCodeGen:toBase ATd:toBase::  |    --bxx: var Base ...
 -- Pattern:markForCodeGen:toBase::  |    --bxx: var BaseUnit |    --bxx := mag ...
 -- markItem:""ly in meter: ".print" ObjectCall
 -- ObjCall:markSuper:"ly in meter: ".print
 -- Invocation:markForCodeGen:"ly in meter: ".print
 -- ObjectInvocation:markForCodeGen:print ATd:print:  |    @for 1 :to length  ...
 -- Pattern:markForCodeGen:print:  |    @for 1 :to length  |    :do  |       put( ...
 -- markItem:"putFloat(Y)" ObjectCall
 -- ObjCall:markSuper:putFloat(Y)
 -- Invocation:markForCodeGen:putFloat(Y)
 -- ObjectInvocation:markForCodeGen:putFloat(Y) ATd:putFloat:  |    %basic 14 ...
 -- Pattern:markForCodeGen:putFloat:  |    %basic 142 |    in X: var Float |    o ...
 -- arg: Y
 -- OG:markForCodeGen:Y
 -- markItem:"newline" ObjectCall
 -- ObjCall:markSuper:newline
 -- Invocation:markForCodeGen:newline
 -- ObjectInvocation:markForCodeGen:newline ATd:newline:  |    %globals |    pu ...
 -- Pattern:markForCodeGen:newline:  |    %globals |    put(10)
 -- OG:markForCodeGen:%globals | put(10)
 -- OG:markIS:%globals | put(10)
 -- items:markForCodeGen:%globals | put(10)
 -- markItem:"%globals" Property
 -- markItem:"put(10)" ObjectCall
 -- ObjCall:markSuper:put(10)
 -- Invocation:markForCodeGen:put(10)
 -- ObjectInvocation:markForCodeGen:put(10) ATd:put:  |    %globals |    %basic ...
 -- Pattern:markForCodeGen:put:  |    %globals |    %basic 2 |    in ch: val char ...
 -- arg: 10
 -- ObjCall:markSuper:10
 -- Invocation:markForCodeGen:10
 -- ComputeVariant:A:newline
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:%globals | put(10)
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:newline:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:81 IS.newDescNo:81 :objSize:0 varNo:1 %global ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:0 originOff:0 
 -- IS.newDescNo:81 IS.objSize:0 :%globals | put(10)
 -- computeVariant:newDescNo:81 IS:%globals | put(10)
 -- ComputeVariant:B:newline
 -- ObjTmpStack:add::genDone:false newline:%globals | put(10)
 -- DataItem:markForCodeGen:X:descNo:0 :OG.primNo:9 
 -- ObjCall:markSuper:Float
 -- Invocation:markForCodeGen:Float
 -- ObjectInvocation:markForCodeGen:Float ATd:float: Value |    %globals |    % ...
 -- Pattern:markForCodeGen:float: Value |    %globals |    %basic 9 |    _thisBas ...
 -- markItem:"X := (rocketMass + fuelMass) / rocketMass" ObjectCall
 -- ObjCall:markSuper:X := (rocketMass + fuelMass) / rocketMass
 -- Invocation:markForCodeGen:X := (rocketMass + fuelMass) / rocketMass
 -- ObjectInvocation:markForCodeGen:X ATd:X: var Float
 -- DataItem:markForCodeGen:X:descNo:0 :OG.primNo:9 
 -- ObjectInvocation:markForCodeGen::= (rocketMass + fuelMass) / rocketMass ...  ...: ...
 -- Pattern:markForCodeGen::= :  |    %basic 8 |    in V: var Value
 -- arg: (rocketMass + fuelMass) / rocketMass
 -- ObjCall:markSuper:(rocketMass + fuelMass) / rocketMass
 -- Invocation:markForCodeGen:(rocketMass + fuelMass) / rocketMass
 -- Invocation:markForCodeGen:rocketMass + fuelMass
 -- ObjectInvocation:markForCodeGen:rocketMass ATd:rocketMass: var Mass.Kil ...
 -- DataItem:markForCodeGen:rocketMass:descNo:0 :OG.primNo:0 
 -- ObjectInvocation:markForCodeGen:+ fuelMass ATd:+ :  |    %basic 109 |    in ...
 -- Pattern:markForCodeGen:+ :  |    %basic 109 |    in V: var float |    out R:  ...
 -- arg: fuelMass
 -- OG:markForCodeGen:fuelMass
 -- ObjectInvocation:markForCodeGen:/ rocketMass ATd:/ :  |    %basic 121 |     ...
 -- Pattern:markForCodeGen:/ :  |    %basic 121 |    in V: var float |    out R:  ...
 -- arg: rocketMass
 -- OG:markForCodeGen:rocketMass
 -- markItem:"putFloat(X)" ObjectCall
 -- ObjCall:markSuper:putFloat(X)
 -- Invocation:markForCodeGen:putFloat(X)
 -- ObjectInvocation:markForCodeGen:putFloat(X) ATd:putFloat:  |    %basic 14 ...
 -- Pattern:markForCodeGen:putFloat:  |    %basic 142 |    in X: var Float |    o ...
 -- arg: X
 -- markItem:"newline" ObjectCall
 -- ObjCall:markSuper:newline
 -- Invocation:markForCodeGen:newline
 -- ObjectInvocation:markForCodeGen:newline ATd:newline:  |    %globals |    pu ...
 -- Pattern:markForCodeGen:newline:  |    %globals |    put(10)
 -- markItem:"X := log(X)" ObjectCall
 -- ObjCall:markSuper:X := log(X)
 -- Invocation:markForCodeGen:X := log(X)
 -- ObjectInvocation:markForCodeGen:X ATd:X: var Float
 -- DataItem:markForCodeGen:X:descNo:0 :OG.primNo:9 
 -- ObjectInvocation:markForCodeGen::= log(X) ATd::= :  |    %basic 8 |    in V ...
 -- Pattern:markForCodeGen::= :  |    %basic 8 |    in V: var Value
 -- arg: log(X)
 -- markItem:""log X: ".print" ObjectCall
 -- ObjCall:markSuper:"log X: ".print
 -- Invocation:markForCodeGen:"log X: ".print
 -- ObjectInvocation:markForCodeGen:print ATd:print:  |    @for 1 :to length  ...
 -- Pattern:markForCodeGen:print:  |    @for 1 :to length  |    :do  |       put( ...
 -- markItem:"putFloat(X)" ObjectCall
 -- ObjCall:markSuper:putFloat(X)
 -- Invocation:markForCodeGen:putFloat(X)
 -- ObjectInvocation:markForCodeGen:putFloat(X) ATd:putFloat:  |    %basic 14 ...
 -- Pattern:markForCodeGen:putFloat:  |    %basic 142 |    in X: var Float |    o ...
 -- arg: X
 -- markItem:"newline" ObjectCall
 -- ObjCall:markSuper:newline
 -- Invocation:markForCodeGen:newline
 -- ObjectInvocation:markForCodeGen:newline ATd:newline:  |    %globals |    pu ...
 -- Pattern:markForCodeGen:newline:  |    %globals |    put(10)
 -- markItem:""exhaustSpeed: ".print" ObjectCall
 -- ObjCall:markSuper:"exhaustSpeed: ".print
 -- Invocation:markForCodeGen:"exhaustSpeed: ".print
 -- ObjectInvocation:markForCodeGen:print ATd:print:  |    @for 1 :to length  ...
 -- Pattern:markForCodeGen:print:  |    @for 1 :to length  |    :do  |       put( ...
 -- markItem:"putFloat(exhaustSpeed)" ObjectCall
 -- ObjCall:markSuper:putFloat(exhaustSpeed)
 -- Invocation:markForCodeGen:putFloat(exhaustSpeed)
 -- ObjectInvocation:markForCodeGen:putFloat(exhaustSpeed) ATd:putFloat:  |   ...
 -- Pattern:markForCodeGen:putFloat:  |    %basic 142 |    in X: var Float |    o ...
 -- arg: exhaustSpeed
 -- OG:markForCodeGen:exhaustSpeed
 -- markItem:"newline" ObjectCall
 -- ObjCall:markSuper:newline
 -- Invocation:markForCodeGen:newline
 -- ObjectInvocation:markForCodeGen:newline ATd:newline:  |    %globals |    pu ...
 -- Pattern:markForCodeGen:newline:  |    %globals |    put(10)
 -- markItem:"newline" ObjectCall
 -- ObjCall:markSuper:newline
 -- Invocation:markForCodeGen:newline
 -- ObjectInvocation:markForCodeGen:newline ATd:newline:  |    %globals |    pu ...
 -- Pattern:markForCodeGen:newline:  |    %globals |    put(10)
 -- markItem:"rocketSpeed := exhaustSpeed * log((rocketMass + fuelMass) / r ..." O ...
 -- ObjCall:markSuper:rocketSpeed := exhaustSpeed * log((rocketMass + fuelM ...
 -- Invocation:markForCodeGen:rocketSpeed := exhaustSpeed * log((rocketMass ...
 -- ObjectInvocation:markForCodeGen:rocketSpeed ATd:rocketSpeed: var Veloci ...
 -- DataItem:markForCodeGen:rocketSpeed:descNo:0 :OG.primNo:0 
 -- ObjectInvocation:markForCodeGen::= exhaustSpeed * log((rocketMass + fue ...  ...: ...
 -- Pattern:markForCodeGen::= :  |    %basic 8 |    in V: var Value
 -- arg: exhaustSpeed * log((rocketMass + fuelMass) / rocketMass)
 -- ObjCall:markSuper:exhaustSpeed * log((rocketMass + fuelMass) / rocketMa ...
 -- Invocation:markForCodeGen:exhaustSpeed * log((rocketMass + fuelMass) /  ...
 -- ObjectInvocation:markForCodeGen:exhaustSpeed ATd:exhaustSpeed: var Velo ...
 -- DataItem:markForCodeGen:exhaustSpeed:descNo:0 :OG.primNo:0 
 -- ObjectInvocation:markForCodeGen:* log((rocketMass + fuelMass) / rocketM ...  ...* ...
 -- Pattern:markForCodeGen:* :  |    %basic 112 |    in V: var float |    out R:  ...
 -- arg: log((rocketMass + fuelMass) / rocketMass)
 -- markItem:""distToAlpha: ".print" ObjectCall
 -- ObjCall:markSuper:"distToAlpha: ".print
 -- Invocation:markForCodeGen:"distToAlpha: ".print
 -- ObjectInvocation:markForCodeGen:print ATd:print:  |    @for 1 :to length  ...
 -- Pattern:markForCodeGen:print:  |    @for 1 :to length  |    :do  |       put( ...
 -- markItem:"putFloat(distToAlpha)" ObjectCall
 -- ObjCall:markSuper:putFloat(distToAlpha)
 -- Invocation:markForCodeGen:putFloat(distToAlpha)
 -- ObjectInvocation:markForCodeGen:putFloat(distToAlpha) ATd:putFloat:  |    ...
 -- Pattern:markForCodeGen:putFloat:  |    %basic 142 |    in X: var Float |    o ...
 -- arg: distToAlpha
 -- OG:markForCodeGen:distToAlpha
 -- markItem:"" rocketSpeed: ".print" ObjectCall
 -- ObjCall:markSuper:" rocketSpeed: ".print
 -- Invocation:markForCodeGen:" rocketSpeed: ".print
 -- ObjectInvocation:markForCodeGen:print ATd:print:  |    @for 1 :to length  ...
 -- Pattern:markForCodeGen:print:  |    @for 1 :to length  |    :do  |       put( ...
 -- markItem:"putFloat(rocketSpeed)" ObjectCall
 -- ObjCall:markSuper:putFloat(rocketSpeed)
 -- Invocation:markForCodeGen:putFloat(rocketSpeed)
 -- ObjectInvocation:markForCodeGen:putFloat(rocketSpeed) ATd:putFloat:  |    ...
 -- Pattern:markForCodeGen:putFloat:  |    %basic 142 |    in X: var Float |    o ...
 -- arg: rocketSpeed
 -- OG:markForCodeGen:rocketSpeed
 -- DataItem:markForCodeGen:d:descNo:0 :OG.primNo:0 
 -- ObjCall:markSuper:Length.Meter
 -- Invocation:markForCodeGen:Length.Meter
 -- ObjectInvocation:markForCodeGen:Length ATd:--Length
 -- ObjectInvocation:markForCodeGen:Meter ATd:Meter: Unit |    %unit "m" |    % ...
 -- Pattern:markForCodeGen:Meter: Unit |    %unit "m" |    %Public |    thisUnit: ...
 -- markItem:"d := distToAlpha.toBase" ObjectCall
 -- ObjCall:markSuper:d := distToAlpha.toBase
 -- Invocation:markForCodeGen:d := distToAlpha.toBase
 -- ObjectInvocation:markForCodeGen:d ATd:d: var Length.Meter
 -- DataItem:markForCodeGen:d:descNo:0 :OG.primNo:0 
 -- ObjectInvocation:markForCodeGen::= distToAlpha.toBase ATd::= :  |    %bas ...
 -- Pattern:markForCodeGen::= :  |    %basic 8 |    in V: var Value
 -- arg: distToAlpha.toBase
 -- ObjCall:markSuper:distToAlpha.toBase
 -- Invocation:markForCodeGen:distToAlpha.toBase
 -- ObjectInvocation:markForCodeGen:distToAlpha ATd:distToAlpha: var Length ...
 -- DataItem:markForCodeGen:distToAlpha:descNo:0 :OG.primNo:0 
 -- ObjectInvocation:markForCodeGen:toBase ATd:toBase::  |    --bxx: var Base ...
 -- Pattern:markForCodeGen:toBase::  |    --bxx: var BaseUnit |    --bxx := mag ...
 -- markItem:"t := d / rocketSpeed" ObjectCall
 -- ObjCall:markSuper:t := d / rocketSpeed
 -- Invocation:markForCodeGen:t := d / rocketSpeed
 -- ObjectInvocation:markForCodeGen:t ATd:t: var Time.Second
 -- DataItem:markForCodeGen:t:descNo:0 :OG.primNo:0 
 -- ObjectInvocation:markForCodeGen::= d / rocketSpeed ATd::= :  |    %basic  ...
 -- Pattern:markForCodeGen::= :  |    %basic 8 |    in V: var Value
 -- arg: d / rocketSpeed
 -- ObjCall:markSuper:d / rocketSpeed
 -- Invocation:markForCodeGen:d / rocketSpeed
 -- ObjectInvocation:markForCodeGen:d ATd:d: var Length.Meter
 -- DataItem:markForCodeGen:d:descNo:0 :OG.primNo:0 
 -- ObjectInvocation:markForCodeGen:/ rocketSpeed ATd:/ :  |    %basic 121 |    ...
 -- Pattern:markForCodeGen:/ :  |    %basic 121 |    in V: var float |    out R:  ...
 -- arg: rocketSpeed
 -- OG:markForCodeGen:rocketSpeed
 -- markItem:"" time: ".print" ObjectCall
 -- ObjCall:markSuper:" time: ".print
 -- Invocation:markForCodeGen:" time: ".print
 -- ObjectInvocation:markForCodeGen:print ATd:print:  |    @for 1 :to length  ...
 -- Pattern:markForCodeGen:print:  |    @for 1 :to length  |    :do  |       put( ...
 -- markItem:"putfloat(t)" ObjectCall
 -- ObjCall:markSuper:putfloat(t)
 -- Invocation:markForCodeGen:putfloat(t)
 -- ObjectInvocation:markForCodeGen:putfloat(t) ATd:putFloat:  |    %basic 14 ...
 -- Pattern:markForCodeGen:putFloat:  |    %basic 142 |    in X: var Float |    o ...
 -- arg: t
 -- OG:markForCodeGen:t
 -- markItem:"newline" ObjectCall
 -- ObjCall:markSuper:newline
 -- Invocation:markForCodeGen:newline
 -- ObjectInvocation:markForCodeGen:newline ATd:newline:  |    %globals |    pu ...
 -- Pattern:markForCodeGen:newline:  |    %globals |    put(10)
 -- ComputeVariant:A:LibraEx
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:%include Dimensions | rocketSpeed: var Velocity.MperS | exhaust ...
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:LibraEx:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:82 IS.newDescNo:82 :objSize:0 varNo:1 %includ ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- dataitem:qalloc:rocketSpeed isValue:true isPrimitive: false isValObj: true  ...false
 -- dataitem:qalloc:exhaustSpeed isValue:true isPrimitive: false isValObj:  ...true  ...false
 -- dataitem:qalloc:rocketMass isValue:true isPrimitive: false isValObj: true  ...false
 -- dataitem:qalloc:fuelMass isValue:true isPrimitive: false isValObj: true  ...false
 -- dataitem:qalloc:distToAlpha isValue:true isPrimitive: false isValObj: true  ...false
 -- dataitem:qalloc:t isValue:true isPrimitive: false isValObj: true isBasi ...false
 -- dataitem:qalloc:Y isValue:true isPrimitive: false isValObj: true isBasi ...false
 -- dataitem:qalloc:X isValue:true isPrimitive: true isValObj: true isBasic ...true
 -- dataitem:qalloc:d isValue:true isPrimitive: false isValObj: true isBasi ...false
 -- IS.newDescNo:82 IS.objSize:19 :%include Dimensions | rocketSpeed: var Vel ...
 -- computeVariant:newDescNo:82 IS:%include Dimensions | rocketSpeed: var Vel ...
 -- ComputeVariant:B:LibraEx
 -- ObjTmpStack:add::genDone:false %include Dimensions | rocketSpeed: var Vel ...
 -- ComputeVariant:A:demo
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:%include Associations | --ArrayDemos | --Bank | --BasicValueSub | - ...
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:demo:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:83 IS.newDescNo:83 :objSize:0 varNo:1 %includ ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- ModuleItem:Qalloc: --ArrayDemos
 -- ModuleItem:Qalloc: --Bank
 -- ModuleItem:Qalloc: --BasicValueSub
 -- ModuleItem:Qalloc: --BinTree
 -- ModuleItem:Qalloc: --Break
 -- ModuleItem:Qalloc: --CoArg
 -- ModuleItem:Qalloc: --ComplexEx
 -- ModuleItem:Qalloc: --ContainerEx
 -- ModuleItem:Qalloc: --FileDemo
 -- ModuleItem:Qalloc: --ForkJoinEx
 -- ModuleItem:Qalloc: --Formater
 -- ModuleItem:Qalloc: --KBprocess
 -- ModuleItem:Qalloc: --LibraEx
 -- ModuleItem:Qalloc:B:
 -- Qalloc:module:LibraEx
 -- Module:alloc:off:2 LibraEx: obj  |    %include Dimensions |    rocketSpeed: ...
 -- ModuleItem:Qalloc: --MixedScheduling
 -- ModuleItem:Qalloc: --MonitorDemo
 -- ModuleItem:Qalloc: --NewArgEx
 -- ModuleItem:Qalloc: --NonBlockingIOex
 -- ModuleItem:Qalloc: --NullList
 -- ModuleItem:Qalloc: --PointEx
 -- ModuleItem:Qalloc: --SCPex
 -- ModuleItem:Qalloc: --SimpleEx
 -- ModuleItem:Qalloc: --SimpleThreadEx
 -- ModuleItem:Qalloc: --SocketEx
 -- ModuleItem:Qalloc: --Static
 -- ModuleItem:Qalloc: --TempEx
 -- ModuleItem:Qalloc: --ToyCar
 -- ModuleItem:Qalloc: --UnitEx
 -- ModuleItem:Qalloc: --Units
 -- ModuleItem:Qalloc: --ValueDemo
 -- ModuleItem:Qalloc: --comment
 -- IS.newDescNo:83 IS.objSize:2 :%include Associations | --ArrayDemos | --Bank ...
 -- computeVariant:newDescNo:83 IS:%include Associations | --ArrayDemos | --Ban ...
 -- ComputeVariant:B:demo
 -- ObjTmpStack:add::genDone:false %include Associations | --ArrayDemos | --Ban ...
 -- ComputeVariant:A:workspace
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:%include BETA, LIB, LIB.BasicIO | %domain_boundary | --AccessEx ...
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:workspace:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:84 IS.newDescNo:84 :objSize:0 varNo:1 %includ ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- ModuleItem:Qalloc: --AccessEx
 -- ModuleItem:Qalloc: --ApplyPred
 -- ModuleItem:Qalloc: --ArduinoEx
 -- ModuleItem:Qalloc: --ArmLed
 -- ModuleItem:Qalloc: --ArmMultiCore
 -- ModuleItem:Qalloc: --CAStest
 -- ModuleItem:Qalloc: --CAStestCore
 -- ModuleItem:Qalloc: --ChemicalPlantSystem
 -- ModuleItem:Qalloc: --CppEx
 -- ModuleItem:Qalloc: --DumpObjEx
 -- ModuleItem:Qalloc: --ESP32Ex
 -- ModuleItem:Qalloc: --Errors
 -- ModuleItem:Qalloc: --ForkGC
 -- ModuleItem:Qalloc: --FuncVirtExVclass
 -- ModuleItem:Qalloc: --FunctionalVirtEx
 -- ModuleItem:Qalloc: --Generic
 -- ModuleItem:Qalloc: --GenericArray
 -- ModuleItem:Qalloc: --GenericList
 -- ModuleItem:Qalloc: --IndexEx
 -- ModuleItem:Qalloc: --Itest
 -- ModuleItem:Qalloc: --Line
 -- ModuleItem:Qalloc: --LockTest
 -- ModuleItem:Qalloc: --LockTestCore
 -- ModuleItem:Qalloc: --MVRsystem
 -- ModuleItem:Qalloc: --MapEx
 -- ModuleItem:Qalloc: --MiniVal
 -- ModuleItem:Qalloc: --NewKeyWord
 -- ModuleItem:Qalloc: --NewStorage
 -- ModuleItem:Qalloc: --NoneEx
 -- ModuleItem:Qalloc: --ObjectAndValues
 -- ModuleItem:Qalloc: --PTX
 -- ModuleItem:Qalloc: --PointReturn
 -- ModuleItem:Qalloc: --PointSys
 -- ModuleItem:Qalloc: --PtnName
 -- ModuleItem:Qalloc: --Qtst
 -- ModuleItem:Qalloc: --QuaValue
 -- ModuleItem:Qalloc: --Qual
 -- ModuleItem:Qalloc: --Recursive
 -- ModuleItem:Qalloc: --Restrictions
 -- ModuleItem:Qalloc: --SlideEx
 -- ModuleItem:Qalloc: --Small
 -- ModuleItem:Qalloc: --SmallVirtEx
 -- ModuleItem:Qalloc: --StringEx
 -- ModuleItem:Qalloc: --Sub1
 -- ModuleItem:Qalloc: --SubOfInt
 -- ModuleItem:Qalloc: --TST
 -- ModuleItem:Qalloc: --UnitLiterals
 -- ModuleItem:Qalloc: --UnitTest
 -- ModuleItem:Qalloc: --ValueArray
 -- ModuleItem:Qalloc: --ValueEx
 -- ModuleItem:Qalloc: --ValueItemEx
 -- ModuleItem:Qalloc: --ValueTypes
 -- ModuleItem:Qalloc: --VirtError
 -- ModuleItem:Qalloc: --VirtualEx
 -- ModuleItem:Qalloc: --Visibility
 -- ModuleItem:Qalloc: --comment
 -- ModuleItem:Qalloc: --demo
 -- ModuleItem:Qalloc:B:
 -- Qalloc:module:demo
 -- Module:alloc:off:2 demo: obj  |    %include Associations |    --ArrayDemos |  ...
 -- ModuleItem:Qalloc: --noglobtst
 -- ModuleItem:Qalloc: --qbetaCmp
 -- ModuleItem:Qalloc: --rangetst
 -- ModuleItem:Qalloc: --test
 -- ModuleItem:Qalloc: --testE
 -- ModuleItem:Qalloc: --testQ
 -- ModuleItem:Qalloc: --testT
 -- ModuleItem:Qalloc: --testU
 -- ModuleItem:Qalloc: --testW
 -- ModuleItem:Qalloc: --testX
 -- ModuleItem:Qalloc: --testY
 -- ModuleItem:Qalloc: --testZ
 -- ModuleItem:Qalloc: --vctest
 -- ModuleItem:Qalloc: --xKinds
 -- ModuleItem:Qalloc: --xtest
 -- IS.newDescNo:84 IS.objSize:2 :%include BETA, LIB, LIB.BasicIO | %domain_b ...
 -- computeVariant:newDescNo:84 IS:%include BETA, LIB, LIB.BasicIO | %domain_ ...
 -- ComputeVariant:B:workspace
 -- ObjTmpStack:add::genDone:false %include BETA, LIB, LIB.BasicIO | %domain_ ...
 -- ComputeVariant:A:BETAworld
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:%modules BETA, LIB, LIB.String | error:  |    %basic 999 | --BETA ...
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:BETAworld:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:85 IS.newDescNo:85 :objSize:0 varNo:1 %module ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- Pattern:Qalloc:error
 -- ModuleItem:Qalloc: --BETA
 -- ModuleItem:Qalloc:B:
 -- Qalloc:module:BETA
 -- Module:alloc:off:2 BETA: obj  |    %OSDvisibility disguised |    %public |    ...
 -- ModuleItem:Qalloc: --DK
 -- ModuleItem:Qalloc: --LIB
 -- ModuleItem:Qalloc:B:
 -- Qalloc:module:LIB
 -- Module:alloc:off:3 LIB: obj  |    %include BETA |    x_dummy_LIB: var integ ...
 -- ModuleItem:Qalloc: --no
 -- ModuleItem:Qalloc: --workspace
 -- ModuleItem:Qalloc:B:
 -- Qalloc:module:workspace
 -- Module:alloc:off:4 workspace: obj  |    %include BETA, LIB, LIB.BasicIO |   ...
 -- IS.newDescNo:85 IS.objSize:4 :%modules BETA, LIB, LIB.String | error:  |    ...
 -- computeVariant:newDescNo:85 IS:%modules BETA, LIB, LIB.String | error:  |   ...
 -- ComputeVariant:B:BETAworld
 -- ObjTmpStack:add::genDone:false %modules BETA, LIB, LIB.String | error:  |   ...
 -- ComputeVariant:A:Object
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:%basic 64 | %public | := :  |    %basic 8 |    in V: ref Value | :- : ...
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:Object:newDescNo:21 :objSize:1 
 -- OG:isObjectDesc:NewDescNo:86 IS.newDescNo:86 :objSize:1 varNo:1 %basic  ...
 -- Items:Qalloc:objSize:1 
 -- Items:Qalloc:Super:C:objSize:2 originOff:2 
 -- Pattern:Qalloc::=
 -- Pattern:Qalloc::-
 -- Pattern:Qalloc:=
 -- Pattern:Qalloc:<>
 -- Pattern:Qalloc:suspend
 -- Pattern:Qalloc:attach
 -- Pattern:Qalloc:resume
 -- Pattern:Qalloc:onResume
 -- Pattern:Qalloc:onSuspend
 -- Pattern:Qalloc:dumpObj
 -- IS.newDescNo:86 IS.objSize:2 :%basic 64 | %public | := :  |    %basic 8 |    in ...
 -- computeVariant:newDescNo:86 IS:%basic 64 | %public | := :  |    %basic 8 |    i ...
 -- ComputeVariant:B:Object
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 1 :top:1 
 -- GenClass:Value :varNo = 1 
 -- GenClass:Object :varNo = 1 
 -- GenClass:Object:true -> var.genDone

class Object 86 2 6
 -- Store itemArgs
 tstOriginIsNone 
 rstore 2 origin
 allocEventQ
 mvStack 
 -- $Signature:gen: "Object"
 innerA  1
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%basic 64" 
 -- $Property:gen: "%basic 64"
 -- genclass:Qgen:stmt:"%public" 
 -- $Property:gen: "%public"
 -- genclass:Qgen:stmt:"@inner Object" 
 -- $ObjectCall:gen: "@inner Object"
 -- $Invocation:gen: descNo: 0 top: 0 "@inner Object"
 -- needorigin:"@inner Object" 
 -- needOrigin:E:"@inner Object"  E.ATd:"@inner:  |    %basic 101 |    in inner ..." 
 -- computeAdr: "@inner Object" 
 -- computeAdr:1 :rec:"none"  E:"@inner Object" :Address:E:"none"off:0 size ...
 -- $ObjectInvocation_KeyWord:pushThis: "@inner Object"
 -- $ObjectInvocation_KeyWord:loadOrigin::on:1 "@inner Object"
 -- $ObjectInvocation_KeyWord:getAdr::superAdj:0:on:1 "@inner Object"
 -- $pattern:getAdr: "@inner:  |    %basic 101 |    in inner: ref Object"
 -- :Address:E:"@inner Object"off:0 size:0 isFloat:False superAdj:0 isUniqu ...
 -- computeAdr:isFirst::Address:E:"@inner Object"off:0 size:0 isFloat:False ...
 -- computeAdr:isLast:E: "@inner Object" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"@inner Object"off:0 size:0 i ...
 -- rec: "@inner Object" E: "@inner Object" isValueAssign: false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@inner Object"
 -- $pattern:loadArgs:E:"@inner Object":descNo:0:top:0 "@inner:  |    %basic  ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"@inner Object" :Address:E:"@inner Object"off:0 ...
 -- $ObjectInvocation_KeyWord:invoke: rec:"@inner Object" "@inner Object"
 -- >top:0 descNo:0 
 -- E.ATd: "" unique: false
 -- adr::Address:E:"@inner Object"off:0 size:0 isFloat:False superAdj:0 isU ...
 -- $pattern:invoke: "@inner:  |    %basic 101 |    in inner: ref Object"
 pushThis 
 innerP  1
 rpopThisObj 
 -- OI:invoke:@inner Object:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"@inner Object" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"Object" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- GenClass:Value:true -> var.genDone

class Value 1 0 6
 -- Store itemArgs
 -- $Signature:gen: "Value"
DO:
 L1:
 -- genclass:Qgen:stmt:"%globals" 
 -- $Property:gen: "%globals"
 -- genclass:Qgen:stmt:"%basic 21" 
 -- $Property:gen: "%basic 21"
 -- genclass:Qgen:stmt:"%public" 
 -- $Property:gen: "%public"
 L2:
 -- OG:pushReturn:"Value" 
 rtnV
 rtn(D)
 end OSDV:0 objSize:0 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 2 :top:1 
 -- GenClass:universal :varNo = 1 
 -- GenClass:universal:true -> var.genDone

class universal 2 0 6
 -- Store itemArgs
 -- $Signature:gen: "universal"
DO:
 L1:
 -- genclass:Qgen:stmt:"%basic 1, 32" 
 -- $Property:gen: "%basic 1, 32"
 -- genclass:Qgen:stmt:"%globals" 
 -- $Property:gen: "%globals"
 L2:
 -- OG:pushReturn:"universal" 
 rtnV
 rtn(D)
 end OSDV:0 objSize:0 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 3 :top:1 
 -- GenClass:char :varNo = 1 
 -- GenClass:char:true -> var.genDone

class char 3 0 6
 -- Store itemArgs
 -- $Signature:gen: "char"
 -- $var:gen: "_thisBasicValue: var Universal"
 -- DI:isConst:false:isBasicValue:true:primNo:1 
 -- OGqual:universal:OGqual.isBasicValue:true:OGqual.isValueObj:true
DO:
 L1:
 -- genclass:Qgen:stmt:"%globals" 
 -- $Property:gen: "%globals"
 -- genclass:Qgen:stmt:"%basic 3, 16" 
 -- $Property:gen: "%basic 3, 16"
 -- genclass:Qgen:stmt:"%public" 
 -- $Property:gen: "%public"
 L2:
 -- OG:pushReturn:"char" 
 rtnV
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 4 :top:1 
 -- GenClass::= :varNo = 1 
 -- GenClass::=:true -> var.genDone

class := 4 1 1
 -- Store itemArgs
 pushThis 
 storeg 3 V
 tstOriginIsNone 
 rstore 1 origin
 -- origin.valueOff:store:2 
 store 2 originOff
 allocEventQ
 mvStack 
 -- $Signature:gen: ":= "
 -- $var:gen: "in V: var Value"
 -- DI:isConst:false:isBasicValue:false:primNo:21 
 -- OGqual:Value:OGqual.isBasicValue:false:OGqual.isValueObj:true
 -- inArg:in V: var Value
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%basic 8" 
 -- $Property:gen: "%basic 8"
 L2:
 rtnEventQ 0
 -- OG:pushReturn:":=" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:3 isIndexed:0  vTop:-2 vTopMax:0 rTop:1 rTopMax:1
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 5 :top:1 
 -- GenClass:ascii :varNo = 1 
 -- GenClass:ascii:true -> var.genDone

class ascii 5 1 6
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $val:gen: "nl: val 10"
 -- DI:isConst:true:isBasicValue:true:primNo:1 
 -- OGqual:integer:OGqual.isBasicValue:true:OGqual.isValueObj:true
 -- $ObjectCall:gen: "10"
 -- $Invocation:gen: "10"
 -- needorigin:"10" 
 -- needOrigin:E:"10"  E.ATd:"integer: value |    %basic 1, 32 |    %globals |    ..." 
 -- LoadOrign:no:loadOrigin: "value |    %basic 1, 32 |    %globals |    %public |  ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "10" E: "10" isValueAssign: false
 -- $ConstLiteral:loadArgs: "10"
 -- invoke:after:loadArgsOf:"10" 
 -- $ConstLiteral:invoke: "10"
 pushc 10
 -- invoke:after:E.invoke:"10" 
 -- dataItem:store:basicValue:off:1  NewOff:2 
 pushThis 
 storeg 2 nl
 -- $val:gen: "cr: val 13"
 -- DI:isConst:true:isBasicValue:true:primNo:1 
 -- OGqual:integer:OGqual.isBasicValue:true:OGqual.isValueObj:true
 -- $ObjectCall:gen: "13"
 -- $Invocation:gen: "13"
 -- needorigin:"13" 
 -- needOrigin:E:"13"  E.ATd:"integer: value |    %basic 1, 32 |    %globals |    ..." 
 -- LoadOrign:no:loadOrigin: "value |    %basic 1, 32 |    %globals |    %public |  ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "13" E: "13" isValueAssign: false
 -- $ConstLiteral:loadArgs: "13"
 -- invoke:after:loadArgsOf:"13" 
 -- $ConstLiteral:invoke: "13"
 pushc 13
 -- invoke:after:E.invoke:"13" 
 -- dataItem:store:basicValue:off:2  NewOff:3 
 pushThis 
 storeg 3 cr
 -- $var:gen: "newline: var char"
 -- DI:isConst:false:isBasicValue:true:primNo:3 
 -- OGqual:char:OGqual.isBasicValue:true:OGqual.isValueObj:true
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"newline := cr -- Windows/Linux???" 
 -- $ObjectCall:gen: "newline := cr -- Windows/Linux???"
 -- $Invocation:gen: descNo: 4 top: 1 "newline := cr -- Windows/Linux???"
 -- needorigin:"newline := cr -- Windows/Linux???" 
 -- needOrigin:E:":= cr -- Windows/Linux???"  E.ATd:":= :  |    %basic 8 |    i ..." 
 -- computeAdr: "newline := cr -- Windows/Linux???" 
 -- computeAdr:1 :rec:"none"  E:"newline" :Address:E:"none"off:0 size:0 isF ...
 -- $ObjectInvocation_Unary:pushThis: "newline"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "newline"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "newline"
 -- $var:getAdr:,newOff:4,isValue:"True",A.isValue:"False" "newline: var ch ..."
 --  A::Address:E:"newline"off:0 size:0 isFloat:False superAdj:0 isUnique:F ...  ...n ...
 -- value_prim:false
 -- char
 -- before:floatTest: 
 -- computeAdr:isFirst::Address:E:"newline"off:4 size:0 isFloat:False super ...
 -- computeAdr:2 :rec:"newline"  E:":= cr -- Windows/Linux???" :Address:E:" ..."
 -- computeAdr:isAssign:rec: "newline"  E:":= cr -- Windows/Linux???" 
 -- :Address:E:"newline"off:4 size:0 isFloat:False superAdj:0 isUnique:Fals ...
 -- computeAdr:isLast:E: ":= cr -- Windows/Linux???" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"newline"off:4 size:0 isFloat ...
 -- rec: "newline" E: ":= cr -- Windows/Linux???" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:4 ":= cr -- Windows/Linux?? ..."
 -- $pattern:loadArgs:E:":= cr -- Windows/Linux???":descNo:4:top:1 ":= :  |   ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= cr -- Windows/Linux???" ActArg: "cr -- Windows/Lin ..." i ...false
 -- $ObjectCall:gen: "cr -- Windows/Linux???"
 -- $Invocation:gen: "cr -- Windows/Linux???"
 -- needorigin:"cr -- Windows/Linux???" 
 -- needOrigin:E:"cr -- Windows/Linux???"  E.ATd:"cr: val 13" 
 -- needOrigin:datItem:leave
 -- computeAdr: "cr -- Windows/Linux???" 
 -- computeAdr:1 :rec:"none"  E:"cr -- Windows/Linux???" :Address:E:"none"o ...
 -- $ObjectInvocation_Unary:pushThis: "cr -- Windows/Linux???"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "cr -- Windows/Linux???"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "cr -- Windows/Linux??? ..."
 -- $val:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "cr: val 13"
 --  A::Address:E:"cr -- Windows/Linux???"off:0 size:0 isFloat:False superA ...  ...c ...
 -- value_prim:false
 -- 13
 -- before:floatTest: 
 -- computeAdr:isFirst::Address:E:"cr -- Windows/Linux???"off:3 size:0 isFl ...
 -- computeAdr:isLast:E: "cr -- Windows/Linux???" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"cr -- Windows/Linux???"off:3 ...
 -- rec: "cr -- Windows/Linux???" E: "cr -- Windows/Linux???" isValueAssign ...false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "cr -- Windows/Linux???"
 -- $val:loadArgs: "cr: val 13"
 -- invoke:after:loadArgsOf:"cr -- Windows/Linux???" :Address:E:"cr -- Wind ..."
 -- $ObjectInvocation_Unary:invoke: rec:"cr -- Windows/Linux???" "cr -- Win ..."
 -- E.ATd: "cr" unique: false
 -- adr::Address:E:"cr -- Windows/Linux???"off:3 size:0 isFloat:False super ...
 -- $val:invoke: newOff:3 "cr: val 13"
 -- load::Address:E:"cr -- Windows/Linux???"off:3 size:0 isFloat:False supe ...
 -- isFloat: false
 pushg 3 
 -- OI:invoke:cr -- Windows/Linux???:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"cr -- Windows/Linux???" 
 -- loadArgs:after:Qgen:":= cr -- Windows/Linux???" 
 -- vAssign:fArg:"in V: var Value" 
 -- end:loadArgs:NonVirt:":= cr -- Windows/Linux???" 
 -- invoke:after:loadArgsOf:":= cr -- Windows/Linux???" :Address:E:"newline ..."
 -- $ObjectInvocation_Binary:invoke: rec:"newline" ":= cr -- Windows/Linux? ..."
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Address:E:"newline"off:4 size:0 isFloat:False superAdj:0 isUnique: ...
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "newline" from: ":= cr -- Windows/Linux???" 
 -- assign:dstDI :"newline: var char" isUnitValueObj: false
 -- assign:arg: "cr -- Windows/Linux???" lab:"ObjectCall" UnitValObj :false  ...false
 --  float: false DataItem:false arg.super:cr -- Windows/Linux???
 --  arg.super.ATd:"Invocation" "cr: val 13" 
 --  arg.super.ATd.isDataItem:true arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "val" 
 -- assign:simple value: 
 -- :Address:E:"newline"off:4 size:0 isFloat:False superAdj:0 isUnique:Fals ...
 -- store::Address:E:"newline"off:4 size:0 isFloat:False superAdj:0 isUniqu ...
 -- isValue:true isAdr:false descNo: 0 
 -- isFloat: false
 storeg 4 address:storeg
 -- OI:invoke::= cr -- Windows/Linux???:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= cr -- Windows/Linux???" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:4 isIndexed:0  vTop:-1 vTopMax:1 rTop:4 rTopMax:4
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 6 :top:1 
 -- GenClass:BETA :varNo = 1 
 -- GenClass:BETA:true -> var.genDone

class BETA 6 1 85
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $obj:gen: "ascii: obj  |    nl: val 10 |    cr: val 13 |    newline: var char ..."
 -- DI:isConst:true:isBasicValue:false:primNo:0 
 -- OGqual:none:OGqual.isBasicValue:false:OGqual.isValueObj:false
 -- $ObjectGenerator:gen:"ascii"singular! staticOff: 2 descNo: 5 top:1 "nl: ..."
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 5  ascii
 invoke ascii 5 2 1
 rpop
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%OSDvisibility disguised" 
 -- $Property:gen: "%OSDvisibility disguised"
 -- genclass:Qgen:stmt:"%public" 
 -- $Property:gen: "%public"
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 7 :top:1 
 -- GenClass:integer :varNo = 1 
 -- GenClass:integer:true -> var.genDone

class integer 7 0 6
 -- Store itemArgs
 -- $Signature:gen: "integer"
 -- $var:gen: "_thisBasicValue: var Universal"
 -- DI:isConst:false:isBasicValue:true:primNo:1 
 -- OGqual:universal:OGqual.isBasicValue:true:OGqual.isValueObj:true
DO:
 L1:
 -- genclass:Qgen:stmt:"%basic 1, 32" 
 -- $Property:gen: "%basic 1, 32"
 -- genclass:Qgen:stmt:"%globals" 
 -- $Property:gen: "%globals"
 -- genclass:Qgen:stmt:"%public" 
 -- $Property:gen: "%public"
 L2:
 -- OG:pushReturn:"integer" 
 rtnV
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 8 :top:1 
 -- GenClass:Associations :varNo = 1 
 -- GenClass:Associations:true -> var.genDone

class Associations 8 1 70
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%include Containers" 
 -- $Property:gen: "%include Containers"
 -- genclass:Qgen:stmt:"%Public" 
 -- $Property:gen: "%Public"
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 9 :top:1 
 -- GenClass:keyboard :varNo = 1 
 -- GenClass:keyboard:true -> var.genDone

class keyboard 9 1 12
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%Public" 
 -- $Property:gen: "%Public"
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 10 :top:1 
 -- GenClass:Lock :varNo = 1 
 -- GenClass:Lock:true -> var.genDone

class Lock 10 1 12
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $Signature:gen: "Lock"
 -- $var:gen: "dummy: var integer"
 -- DI:isConst:false:isBasicValue:true:primNo:1 
 -- OGqual:integer:OGqual.isBasicValue:true:OGqual.isValueObj:true
 -- $var:gen: "M: var integer"
 -- DI:isConst:false:isBasicValue:true:primNo:1 
 -- OGqual:integer:OGqual.isBasicValue:true:OGqual.isValueObj:true
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%Public" 
 -- $Property:gen: "%Public"
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"Lock" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:3 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 11 :top:1 
 -- GenClass:screen :varNo = 1 
 -- GenClass:screen:true -> var.genDone

class screen 11 1 12
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $obj:gen: "L: obj Lock"
 -- DI:isConst:true:isBasicValue:false:primNo:0 
 -- OGqual:Lock:OGqual.isBasicValue:false:OGqual.isValueObj:false
 -- $ObjectCall:gen: "Lock"
 -- $Invocation:gen: descNo: 10 top: 1 "Lock"
 -- needorigin:"Lock" 
 -- needOrigin:E:"Lock"  E.ATd:"Lock:  |    dummy: var integer |    %Public |     ..." 
 -- computeAdr: "Lock" 
 -- computeAdr:1 :rec:"none"  E:"Lock" :Address:E:"none"off:0 size:0 isFloa ...
 -- $ObjectInvocation_Unary:pushThis: "Lock"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "Lock"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:1 
 -- goOrigin:screen:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 screen:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:1 "Lock"
 -- $pattern:getAdr: "Lock:  |    dummy: var integer |    %Public |    M: var int ..."
 -- :Address:E:"Lock"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...
 -- computeAdr:isFirst::Address:E:"Lock"off:0 size:0 isFloat:False superAdj ...
 -- computeAdr:isLast:E: "Lock" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"Lock"off:0 size:0 isFloat:Fa ...
 -- rec: "Lock" E: "Lock" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "Lock"
 -- $pattern:loadArgs:E:"Lock":descNo:10:top:1 "Lock:  |    dummy: var intege ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"Lock" :Address:E:"Lock"off:0 size:0 isFloat:Fa ...
 -- $ObjectInvocation_Unary:invoke: rec:"Lock" "Lock"
 -- >top:1 descNo:10 
 -- E.ATd: "Lock" unique: false
 -- adr::Address:E:"Lock"off:0 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- $pattern:invoke: "Lock:  |    dummy: var integer |    %Public |    M: var int ..."
 -- Pattern:invoke:descNo:10  top:1  rec:"Lock" 
 -- ptn:invoke::isValObj:false:rtnValObj:false:"Lock:  |    dummy: var intege ..." 
 -- rec=E:true:rec:"Lock" 
 -- kuk:obj:rec.ATd:"Lock:  |    dummy: var integer |    %Public |    M: var inte ..." 
 invoke Lock 10 2 0
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:true"Lock" 
 rpop
 -- OI:invoke:Lock:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"Lock" 
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%Public" 
 -- $Property:gen: "%Public"
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 12 :top:1 
 -- GenClass:BasicIO :varNo = 1 
 -- GenClass:BasicIO:true -> var.genDone

class BasicIO 12 1 70
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $obj:gen: "keyboard: obj  |    %Public |    readLine:  |       out M: ref LIB ..."
 -- DI:isConst:true:isBasicValue:false:primNo:0 
 -- OGqual:none:OGqual.isBasicValue:false:OGqual.isValueObj:false
 -- $ObjectGenerator:gen:"keyboard"singular! staticOff: 2 descNo: 9 top:1 " ..."
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 9  keyboard
 invoke keyboard 9 2 1
 rpop
 -- $obj:gen: "screen: obj  |    L: obj Lock |    %Public |    init:  |       L.get ..."
 -- DI:isConst:true:isBasicValue:false:primNo:0 
 -- OGqual:none:OGqual.isBasicValue:false:OGqual.isValueObj:false
 -- $ObjectGenerator:gen:"screen"singular! staticOff: 3 descNo: 11 top:1 "L ..."
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 11  screen
 invoke screen 11 3 1
 rpop
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%Public" 
 -- $Property:gen: "%Public"
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:3 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 13 :top:1 
 -- GenClass:List :varNo = 1 
 -- GenClass:List:true -> var.genDone

class List 13 1 37
 -- Store itemArgs
 pushThis 
 rstoreg 3 tail
 pushThis 
 rstoreg 2 head
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $Signature:gen: "List"
 -- $ref:gen: "in head: ref Object"
 -- DI:isConst:false:isBasicValue:false:primNo:64 
 -- OGqual:Object:OGqual.isBasicValue:false:OGqual.isValueObj:false
 -- $ref:gen: "in tail: ref List"
 -- DI:isConst:false:isBasicValue:false:primNo:0 
 -- OGqual:List:OGqual.isBasicValue:false:OGqual.isValueObj:false
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"List" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:3 isIndexed:0  vTop:0 vTopMax:0 rTop:-2 rTopMax:1
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 14 :top:1 
 -- GenClass::= :varNo = 1 
 -- GenClass::=:true -> var.genDone

class := 14 1 86
 -- Store itemArgs
 pushThis 
 storeg 2 V
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $Signature:gen: ":= "
 -- $ref:gen: "in V: ref Value"
 -- DI:isConst:false:isBasicValue:false:primNo:21 
 -- OGqual:Value:OGqual.isBasicValue:false:OGqual.isValueObj:true
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%basic 8" 
 -- $Property:gen: "%basic 8"
 L2:
 rtnEventQ 0
 -- OG:pushReturn:":=" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:-1 vTopMax:0 rTop:1 rTopMax:1
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 15 :top:1 
 -- GenClass:String :varNo = 1 
 -- GenClass:String:true -> var.genDone

class String 15 1 16
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $Signature:gen: "String"
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%OSDvisibility disguised" 
 -- $Property:gen: "%OSDvisibility disguised"
 -- genclass:Qgen:stmt:"%basic 5" 
 -- $Property:gen: "%basic 5"
 -- genclass:Qgen:stmt:"%immutable" 
 -- $Property:gen: "%immutable"
 -- genclass:Qgen:stmt:"%public" 
 -- $Property:gen: "%public"
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"String" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:1  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 16 :top:1 
 -- GenClass:String :varNo = 1 
 -- GenClass:String:true -> var.genDone

class String 16 1 70
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 saveStringOrigin
 mvStack 
 -- $pattern:gen: "String:  |    %OSDvisibility disguised |    %basic 5 |    %imm ..."
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%public" 
 -- $Property:gen: "%public"
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 17 :top:1 
 -- GenClass:foo :varNo = 1 
 -- GenClass:foo:true -> var.genDone

class foo 17 1 37
 -- Store itemArgs
 pushThis 
 rstoreg 2 S
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $Signature:gen: "foo"
 -- $ref:gen: "in S: ref String.String"
 -- DI:isConst:false:isBasicValue:false:primNo:5 
 -- OGqual:String:OGqual.isBasicValue:false:OGqual.isValueObj:false
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"foo" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:-1 rTopMax:1
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 18 :top:1 
 -- GenClass:@this: :varNo = 1 
 -- GenClass:@this::true -> var.genDone

class @this: 18 1 6
 -- Store itemArgs
 pushThis 
 rstoreg 2 this
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $Signature:gen: ""
 -- $ref:gen: "in this: ref Object"
 -- DI:isConst:false:isBasicValue:false:primNo:64 
 -- OGqual:Object:OGqual.isBasicValue:false:OGqual.isValueObj:false
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%basic 18" 
 -- $Property:gen: "%basic 18"
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"@this:" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:-1 rTopMax:1
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 19 :top:1 
 -- GenClass:Boolean :varNo = 1 
 -- GenClass:Boolean:true -> var.genDone

class Boolean 19 0 6
 -- Store itemArgs
 -- $Signature:gen: "Boolean"
 -- $var:gen: "_thisBasicValue: var Universal"
 -- DI:isConst:false:isBasicValue:true:primNo:1 
 -- OGqual:universal:OGqual.isBasicValue:true:OGqual.isValueObj:true
DO:
 L1:
 -- genclass:Qgen:stmt:"%globals inSub" 
 -- $Property:gen: "%globals inSub"
 -- genclass:Qgen:stmt:"%basic 4, 8" 
 -- $Property:gen: "%basic 4, 8"
 -- genclass:Qgen:stmt:"%public" 
 -- $Property:gen: "%public"
 L2:
 -- OG:pushReturn:"Boolean" 
 rtnV
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 20 :top:1 
 -- GenClass:@if::then :varNo = 1 
 -- GenClass:@if::then:true -> var.genDone

class @if::then 20 0 6
 -- Store itemArgs
 pushThis 
 storeg 1 if
 allocEventQ
 mvStack 
 -- $Signature:gen: ""
 -- $var:gen: "in if: var boolean"
 -- DI:isConst:false:isBasicValue:true:primNo:4 
 -- OGqual:Boolean:OGqual.isBasicValue:true:OGqual.isValueObj:true
 -- $pattern:gen: "in then:< Object"
 -- vdt:d
 -- vdtAdd: inx=1 descInx=86
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%globals inSub" 
 -- $Property:gen: "%globals inSub"
 -- genclass:Qgen:stmt:"%basic 100" 
 -- $Property:gen: "%basic 100"
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"@if::then" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:0  vTop:-1 vTopMax:0 rTop:2 rTopMax:2
 -- Virtual
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 22 :top:1 
 -- GenClass:#S#22 :varNo = 1 
 -- GenClass:#S#22:true -> var.genDone

class #S#22 22 1 0
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"L := tail" 
 -- $ObjectCall:gen: "L := tail"
 -- $Invocation:gen: descNo: 14 top: 1 "L := tail"
 -- needorigin:"L := tail" 
 -- needOrigin:E:":= tail"  E.ATd:":= :  |    %basic 8 |    in V: ref Value" 
 -- computeAdr: "L := tail" 
 -- computeAdr:1 :rec:"none"  E:"L" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "L"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:2 "L"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:2 
 -- goOrigin:#S#22:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 #S#22:origin
 -- goOrigin:A:1 
 -- goOrigin:Skip:ifThen
 -- goOrigin:A:1 
 -- goOrigin:loop:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 loop:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:2 "L"
 -- $ref:getAdr:,newOff:3,isValue:"False",A.isValue:"False" "L: ref List"
 --  A::Address:E:"L"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...L ...
 -- value_prim:false
 -- computeAdr:isFirst::Address:E:"none"off:3 size:0 isFloat:False superAdj ...
 -- computeAdr:2 :rec:"L"  E:":= tail" :Address:E:"none"off:3 size:0 isFloa ...
 -- computeAdr:isAssign:rec: "L"  E:":= tail" 
 -- :Address:E:"none"off:3 size:0 isFloat:False superAdj:0 isUnique:False i ...
 -- computeAdr:isLast:E: ":= tail" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"none"off:3 size:0 isFloat:Fa ...
 -- rec: "L" E: ":= tail" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:3 ":= tail"
 -- $pattern:loadArgs:E:":= tail":descNo:14:top:1 ":= :  |    %basic 8 |    in  ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= tail" ActArg: "tail" isValue: false
 -- $ObjectCall:gen: "tail"
 -- $Invocation:gen: "tail"
 -- needorigin:"tail" 
 -- needOrigin:E:"tail"  E.ATd:"in tail: ref List" 
 -- needOrigin:datItem:leave
 -- computeAdr: "tail" 
 -- computeAdr:1 :rec:"none"  E:"tail" :Address:E:"none"off:0 size:0 isFloa ...
 -- $ObjectInvocation_Unary:pushThis: "tail"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:3 "tail"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:3 
 -- goOrigin:#S#22:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 #S#22:origin
 -- goOrigin:A:2 
 -- goOrigin:Skip:ifThen
 -- goOrigin:A:2 
 -- goOrigin:loop:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 loop:origin
 -- goOrigin:A:1 
 -- goOrigin:scan:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 scan:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:3 "tail"
 -- $ref:getAdr:,newOff:3,isValue:"False",A.isValue:"False" "in tail: ref L ..."
 --  A::Address:E:"tail"off:0 size:0 isFloat:False superAdj:0 isUnique:Fals ...  ...i ...
 -- value_prim:false
 -- computeAdr:isFirst::Address:E:"none"off:3 size:0 isFloat:False superAdj ...
 -- computeAdr:isLast:E: "tail" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"none"off:3 size:0 isFloat:Fa ...
 -- rec: "tail" E: "tail" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "tail"
 -- $ref:loadArgs: "in tail: ref List"
 -- invoke:after:loadArgsOf:"tail" :Address:E:"none"off:3 size:0 isFloat:Fa ...
 -- $ObjectInvocation_Unary:invoke: rec:"tail" "tail"
 -- E.ATd: "tail" unique: false
 -- adr::Address:E:"none"off:3 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- $ref:invoke: newOff:3 "in tail: ref List"
 -- >Object:unique:false
 -- load::Address:E:"none"off:3 size:0 isFloat:False superAdj:0 isUnique:Fa ...
 rpushg 3 
 -- OI:invoke:tail:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"tail" 
 -- loadArgs:after:Qgen:":= tail" 
 -- vAssign:fArg:"in V: ref Value" 
 -- end:loadArgs:NonVirt:":= tail" 
 -- invoke:after:loadArgsOf:":= tail" :Address:E:"none"off:3 size:0 isFloat ...
 -- $ObjectInvocation_Binary:invoke: rec:"L" ":= tail"
 -- >top:1 descNo:14 
 -- E.ATd: ":= " unique: false
 -- adr::Address:E:"none"off:3 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: ref Value"
 -- AssignPtn:invoke:rec: "L" from: ":= tail" 
 -- assign:dstDI :"L: ref List" isUnitValueObj: false
 -- assign:arg: "tail" lab:"ObjectCall" UnitValObj :false ptn: false
 --  float: false DataItem:false arg.super:tail
 --  arg.super.ATd:"Invocation" "in tail: ref List" 
 --  arg.super.ATd.isDataItem:true arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "ref" 
 -- assign:reference: "L" 
 -- :Address:E:"none"off:3 size:0 isFloat:False superAdj:0 isUnique:False i ...
 -- store::Address:E:"none"off:3 size:0 isFloat:False superAdj:0 isUnique:F ...
 -- isValue:false isAdr:false descNo: 0 
 rswap
 rstoreg 3 
 -- OI:invoke::= tail:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= tail" 
 -- genclass:Qgen:stmt:"current := L.head" 
 -- $ObjectCall:gen: "current := L.head"
 -- $Invocation:gen: descNo: 14 top: 1 "current := L.head"
 -- needorigin:"current := L.head" 
 -- needOrigin:E:":= L.head"  E.ATd:":= :  |    %basic 8 |    in V: ref Value" 
 -- computeAdr: "current := L.head" 
 -- computeAdr:1 :rec:"none"  E:"current" :Address:E:"none"off:0 size:0 isF ...
 -- $ObjectInvocation_Unary:pushThis: "current"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:2 "current"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:2 
 -- goOrigin:#S#22:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 #S#22:origin
 -- goOrigin:A:1 
 -- goOrigin:Skip:ifThen
 -- goOrigin:A:1 
 -- goOrigin:loop:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 loop:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:2 "current"
 -- $ref:getAdr:,newOff:2,isValue:"False",A.isValue:"False" "current: ref O ..."
 --  A::Address:E:"current"off:0 size:0 isFloat:False superAdj:0 isUnique:F ...  ...c ...
 -- value_prim:false
 -- computeAdr:isFirst::Address:E:"none"off:2 size:0 isFloat:False superAdj ...
 -- computeAdr:2 :rec:"current"  E:":= L.head" :Address:E:"none"off:2 size: ...
 -- computeAdr:isAssign:rec: "current"  E:":= L.head" 
 -- :Address:E:"none"off:2 size:0 isFloat:False superAdj:0 isUnique:False i ...
 -- computeAdr:isLast:E: ":= L.head" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"none"off:2 size:0 isFloat:Fa ...
 -- rec: "current" E: ":= L.head" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:2 ":= L.head"
 -- $pattern:loadArgs:E:":= L.head":descNo:14:top:1 ":= :  |    %basic 8 |    i ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= L.head" ActArg: "L.head" isValue: false
 -- $ObjectCall:gen: "L.head"
 -- $Invocation:gen: "L.head"
 -- needorigin:"L.head" 
 -- needOrigin:E:"head"  E.ATd:"in head: ref Object" 
 -- needOrigin:datItem:leave
 -- computeAdr: "L.head" 
 -- computeAdr:1 :rec:"none"  E:"L" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "L"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:2 "L"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:2 
 -- goOrigin:#S#22:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 #S#22:origin
 -- goOrigin:A:1 
 -- goOrigin:Skip:ifThen
 -- goOrigin:A:1 
 -- goOrigin:loop:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 loop:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:2 "L"
 -- $ref:getAdr:,newOff:3,isValue:"False",A.isValue:"False" "L: ref List"
 --  A::Address:E:"L"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...L ...
 -- value_prim:false
 -- computeAdr:isFirst::Address:E:"none"off:3 size:0 isFloat:False superAdj ...
 -- computeAdr:2 :rec:"L"  E:"head" :Address:E:"none"off:3 size:0 isFloat:F ...
 -- E:notAssign:head
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "head"
 -- $ref:getAdr:,newOff:2,isValue:"False",A.isValue:"False" "in head: ref O ..."
 --  A::Address:E:"head"off:3 size:0 isFloat:False superAdj:0 isUnique:Fals ...  ...i ...
 -- value_prim:false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "L"
 -- $ref:loadArgs: "L: ref List"
 -- $ObjectInvocation_Unary:invoke: rec:"L" "L"
 -- E.ATd: "head" unique: false
 -- adr::Address:E:"head"off:3 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- $ref:invoke: newOff:3 "L: ref List"
 -- >Object:unique:false
 -- load::Address:E:"head"off:3 size:0 isFloat:False superAdj:0 isUnique:Fa ...
 rpushg 3 
 -- OI:invoke:L:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "head" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"none"off:2 size:0 isFloat:Fa ...
 -- rec: "L" E: "head" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "head"
 -- $ref:loadArgs: "in head: ref Object"
 -- invoke:after:loadArgsOf:"head" :Address:E:"none"off:2 size:0 isFloat:Fa ...
 -- $ObjectInvocation_Unary:invoke: rec:"L" "head"
 -- E.ATd: "head" unique: false
 -- adr::Address:E:"none"off:2 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- $ref:invoke: newOff:2 "in head: ref Object"
 -- >Object:unique:false
 -- load::Address:E:"none"off:2 size:0 isFloat:False superAdj:0 isUnique:Fa ...
 rpushg 2 
 -- OI:invoke:head:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"head" 
 -- loadArgs:after:Qgen:":= L.head" 
 -- vAssign:fArg:"in V: ref Value" 
 -- end:loadArgs:NonVirt:":= L.head" 
 -- invoke:after:loadArgsOf:":= L.head" :Address:E:"none"off:2 size:0 isFlo ...
 -- $ObjectInvocation_Binary:invoke: rec:"current" ":= L.head"
 -- >top:1 descNo:14 
 -- E.ATd: ":= " unique: false
 -- adr::Address:E:"none"off:2 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: ref Value"
 -- AssignPtn:invoke:rec: "current" from: ":= L.head" 
 -- assign:dstDI :"current: ref Object" isUnitValueObj: false
 -- assign:arg: "L.head" lab:"ObjectCall" UnitValObj :false ptn: false
 --  float: false DataItem:false arg.super:L.head
 --  arg.super.ATd:"Invocation" "in head: ref Object" 
 --  arg.super.ATd.isDataItem:true arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "ref" 
 -- assign:reference: "current" 
 -- :Address:E:"none"off:2 size:0 isFloat:False superAdj:0 isUnique:False i ...
 -- store::Address:E:"none"off:2 size:0 isFloat:False superAdj:0 isUnique:F ...
 -- isValue:false isAdr:false descNo: 0 
 rswap
 rstoreg 2 
 -- OI:invoke::= L.head:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= L.head" 
 -- genclass:Qgen:stmt:"@restart loop" 
 -- $ObjectCall:gen: "@restart loop"
 -- $Invocation:gen: descNo: 0 top: 0 "@restart loop"
 -- needorigin:"@restart loop" 
 -- needOrigin:E:"@restart loop"  E.ATd:"@restart:  |    %basic 102 |    in res ..." 
 -- computeAdr: "@restart loop" 
 -- computeAdr:1 :rec:"none"  E:"@restart loop" :Address:E:"none"off:0 size ...
 -- $ObjectInvocation_KeyWord:pushThis: "@restart loop"
 -- $ObjectInvocation_KeyWord:loadOrigin::on:6 "@restart loop"
 -- $ObjectInvocation_KeyWord:getAdr::superAdj:0:on:6 "@restart loop"
 -- $pattern:getAdr: "@restart:  |    %basic 102 |    in restart: var integer"
 -- :Address:E:"@restart loop"off:0 size:0 isFloat:False superAdj:0 isUniqu ...
 -- computeAdr:isFirst::Address:E:"@restart loop"off:0 size:0 isFloat:False ...
 -- computeAdr:isLast:E: "@restart loop" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"@restart loop"off:0 size:0 i ...
 -- rec: "@restart loop" E: "@restart loop" isValueAssign: false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@restart loop"
 -- $pattern:loadArgs:E:"@restart loop":descNo:0:top:0 "@restart:  |    %basi ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"@restart loop" :Address:E:"@restart loop"off:0 ...
 -- $ObjectInvocation_KeyWord:invoke: rec:"@restart loop" "@restart loop"
 -- >top:0 descNo:0 
 -- E.ATd: "" unique: false
 -- adr::Address:E:"@restart loop"off:0 size:0 isFloat:False superAdj:0 isU ...
 -- $pattern:invoke: "@restart:  |    %basic 102 |    in restart: var integer"
 break 1 1 23
 -- OI:invoke:@restart loop:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"@restart loop" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:1
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 23 :top:1 
 -- GenClass:loop :varNo = 1 
 -- GenClass:loop:true -> var.genDone

class loop 23 1 24
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $Signature:gen: "loop"
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"@inner scan" 
 -- $ObjectCall:gen: "@inner scan"
 -- $Invocation:gen: descNo: 0 top: 0 "@inner scan"
 -- needorigin:"@inner scan" 
 -- needOrigin:E:"@inner scan"  E.ATd:"@inner:  |    %basic 101 |    in inner:  ..." 
 -- computeAdr: "@inner scan" 
 -- computeAdr:1 :rec:"none"  E:"@inner scan" :Address:E:"none"off:0 size:0 ...
 -- $ObjectInvocation_KeyWord:pushThis: "@inner scan"
 -- $ObjectInvocation_KeyWord:loadOrigin::on:5 "@inner scan"
 -- $ObjectInvocation_KeyWord:getAdr::superAdj:0:on:5 "@inner scan"
 -- $pattern:getAdr: "@inner:  |    %basic 101 |    in inner: ref Object"
 -- :Address:E:"@inner scan"off:0 size:0 isFloat:False superAdj:0 isUnique: ...
 -- computeAdr:isFirst::Address:E:"@inner scan"off:0 size:0 isFloat:False s ...
 -- computeAdr:isLast:E: "@inner scan" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"@inner scan"off:0 size:0 isF ...
 -- rec: "@inner scan" E: "@inner scan" isValueAssign: false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@inner scan"
 -- $pattern:loadArgs:E:"@inner scan":descNo:0:top:0 "@inner:  |    %basic 10 ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"@inner scan" :Address:E:"@inner scan"off:0 siz ...
 -- $ObjectInvocation_KeyWord:invoke: rec:"@inner scan" "@inner scan"
 -- >top:0 descNo:0 
 -- E.ATd: "" unique: false
 -- adr::Address:E:"@inner scan"off:0 size:0 isFloat:False superAdj:0 isUni ...
 -- $pattern:invoke: "@inner:  |    %basic 101 |    in inner: ref Object"
 pushThis 
 -- goOrigin:A:1 
 -- goOrigin:loop:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 loop:origin
 innerP  1
 rpopThisObj 
 -- OI:invoke:@inner scan:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"@inner scan" 
 -- genclass:Qgen:stmt:"@if L.tail <> none :then  |    L := tail |    current : ..." 
 -- $ObjectGenerator:gen:"@if::then#S#0"IS.isempty! staticOff: 0 descNo: 0  ...
 -- OG:gen:super:"" superDescNo:20 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: false
 -- $Invocation:gen: descNo: 20 top: 1 "@if L.tail <> none :then  |    L := t ..."
 -- needorigin:"@if L.tail <> none :then  |    L := tail |    current := L.head ..." 
 -- needOrigin:E:"@if L.tail <> none :then  |    L := tail |    current := L.he ..."   ..."@ ..." 
 -- LoadOrign:no:loadOrigin: "%globals inSub | %basic 100 | in if: var boolean |  ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "@if L.tail <> none :then  |    L := tail |    current := L.head |    @r ..." E ..."@ ..." i ...false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@if L.tail <> none :the ..."
 -- $pattern:loadArgs:E:"@if L.tail <> none :then  |    L := tail |    current  ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"@if L.tail <> none :then  |    L := tail |    curr ..." 
 -- $ObjectInvocation_KeyWord:invoke: rec:"@if L.tail <> none :then  |    L : ..."
 -- >top:1 descNo:20 
 -- $pattern:invoke: "@if:  |    %globals inSub |    %basic 100 |    in if: var b ..."
 -- $ObjectCall:gen: "L.tail <> none"
 -- $Invocation:gen: descNo: 0 top: 0 "L.tail <> none"
 -- needorigin:"L.tail <> none" 
 -- needOrigin:E:"<> none"  E.ATd:"<> :  |    %basic 57 |    in objx: ref Objec ..." 
 -- computeAdr: "L.tail <> none" 
 -- computeAdr:1 :rec:"none"  E:"L" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "L"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "L"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:1 
 -- goOrigin:loop:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 loop:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:1 "L"
 -- $ref:getAdr:,newOff:3,isValue:"False",A.isValue:"False" "L: ref List"
 --  A::Address:E:"L"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...L ...
 -- value_prim:false
 -- computeAdr:isFirst::Address:E:"none"off:3 size:0 isFloat:False superAdj ...
 -- computeAdr:2 :rec:"L"  E:"tail" :Address:E:"none"off:3 size:0 isFloat:F ...
 -- E:notAssign:tail
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "tail"
 -- $ref:getAdr:,newOff:3,isValue:"False",A.isValue:"False" "in tail: ref L ..."
 --  A::Address:E:"tail"off:3 size:0 isFloat:False superAdj:0 isUnique:Fals ...  ...i ...
 -- value_prim:false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "L"
 -- $ref:loadArgs: "L: ref List"
 -- $ObjectInvocation_Unary:invoke: rec:"L" "L"
 -- E.ATd: "tail" unique: false
 -- adr::Address:E:"tail"off:3 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- $ref:invoke: newOff:3 "L: ref List"
 -- >Object:unique:false
 -- load::Address:E:"tail"off:3 size:0 isFloat:False superAdj:0 isUnique:Fa ...
 rpushg 3 
 -- OI:invoke:L:unit: -none- convFactor: 0.000000
 -- computeAdr:3 :rec:"tail"  E:"<> none" :Address:E:"none"off:3 size:0 isF ...
 -- E:notAssign:<> none
 -- $ObjectInvocation_Binary:getAdr::superAdj:0:on:0 "<> none"
 -- $pattern:getAdr: "<> :  |    %basic 57 |    in objx: ref Object |    out V: v ..."
 -- :Address:E:"<> none"off:3 size:0 isFloat:False superAdj:0 isUnique:Fals ...
 -- ptn.ssUnitValueObj:false isFloat:false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "tail"
 -- $ref:loadArgs: "in tail: ref List"
 -- $ObjectInvocation_Unary:invoke: rec:"L" "tail"
 -- E.ATd: "<> " unique: false
 -- adr::Address:E:"<> none"off:3 size:0 isFloat:False superAdj:0 isUnique: ...
 -- $ref:invoke: newOff:3 "in tail: ref List"
 -- >Object:unique:false
 -- load::Address:E:"<> none"off:3 size:0 isFloat:False superAdj:0 isUnique ...
 rpushg 3 
 -- OI:invoke:tail:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "<> none" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"<> none"off:3 size:0 isFloat ...
 -- rec: "tail" E: "<> none" isValueAssign: false
 -- $ObjectInvocation_Binary:loadArgs:staticOff:0 "<> none"
 -- $pattern:loadArgs:E:"<> none":descNo:0:top:0 "<> :  |    %basic 57 |    in  ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"<> none" ActArg: "none" isValue: false
 -- loadArgs:not:*: formalArgOf:"<> none"  isCompositeValueObj:false
 -- $ObjectCall:gen: "none"
 -- $Invocation:gen: descNo: 0 top: 0 "none"
 -- needorigin:"none" 
 -- needOrigin:E:"none"  E.ATd:"none:  |    %basic 19 |    none_x: var integer" 
 -- computeAdr: "none" 
 -- computeAdr:1 :rec:"none"  E:"none" :Address:E:"none"off:0 size:0 isFloa ...
 -- $ObjectInvocation_Unary:pushThis: "none"
 -- $ObjectInvocation_Unary:loadOrigin::on:5 "none"
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:5 "none"
 -- $pattern:getAdr: "none:  |    %basic 19 |    none_x: var integer"
 -- :Address:E:"none"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...
 -- computeAdr:isFirst::Address:E:"none"off:0 size:0 isFloat:False superAdj ...
 -- computeAdr:isLast:E: "none" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"none"off:0 size:0 isFloat:Fa ...
 -- rec: "none" E: "none" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "none"
 -- $pattern:loadArgs:E:"none":descNo:0:top:0 "none:  |    %basic 19 |    none_ ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"none" :Address:E:"none"off:0 size:0 isFloat:Fa ...
 -- $ObjectInvocation_Unary:invoke: rec:"none" "none"
 -- >top:0 descNo:0 
 -- E.ATd: "none" unique: false
 -- adr::Address:E:"none"off:0 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- $pattern:invoke: "none:  |    %basic 19 |    none_x: var integer"
 pushNone
 -- OI:invoke:none:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"none" 
 -- loadArgs:after:Qgen:"<> none" 
 -- formalArg:isPtn:"in objx: ref Object" :isBasicVal:false:valueObj:false
 -- :actArg:"none" :isBasicVal:false
 -- noneObjectCall
 -- end:loadArgs:NonVirt:"<> none" 
 -- invoke:after:loadArgsOf:"<> none" :Address:E:"<> none"off:3 size:0 isFl ...
 -- $ObjectInvocation_Binary:invoke: rec:"tail" "<> none"
 -- >top:0 descNo:0 
 -- E.ATd: "<> " unique: false
 -- adr::Address:E:"<> none"off:3 size:0 isFloat:False superAdj:0 isUnique: ...
 -- $pattern:invoke: "<> :  |    %basic 57 |    in objx: ref Object |    out V: v ..."
 -- bodyC:
 rne
 -- OI:invoke:<> none:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"<> none" 
 jmpFalse L3
 -- $ObjectGenerator:gen:"#S#22"singular! staticOff: 0 descNo: 22 top:1 "L  ..."
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 22  #S#22
 invoke #S#22 22 0 1
 rpop
 L3:
 -- OI:invoke:@if L.tail <> none :then  |    L := tail |    current := L.head |   ...: ...-none-  ...0.000000
 -- invoke:after:E.invoke:"@if L.tail <> none :then  |    L := tail |    curren ..." 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"loop" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:0  vTop:-1 vTopMax:0 rTop:2 rTopMax:2
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 24 :top:1 
 -- GenClass:scan :varNo = 1 
 -- GenClass:scan:true -> var.genDone

class scan 24 1 13
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $Signature:gen: "scan"
 -- $ref:gen: "current: ref Object"
 -- DI:isConst:false:isBasicValue:false:primNo:64 
 -- OGqual:Object:OGqual.isBasicValue:false:OGqual.isValueObj:false
 -- $ref:gen: "L: ref List"
 -- DI:isConst:false:isBasicValue:false:primNo:0 
 -- OGqual:List:OGqual.isBasicValue:false:OGqual.isValueObj:false
 innerA  1
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"L := @this List" 
 -- $ObjectCall:gen: "L := @this List"
 -- $Invocation:gen: descNo: 14 top: 1 "L := @this List"
 -- needorigin:"L := @this List" 
 -- needOrigin:E:":= @this List"  E.ATd:":= :  |    %basic 8 |    in V: ref Val ..." 
 -- computeAdr: "L := @this List" 
 -- computeAdr:1 :rec:"none"  E:"L" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "L"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "L"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "L"
 -- $ref:getAdr:,newOff:3,isValue:"False",A.isValue:"False" "L: ref List"
 --  A::Address:E:"L"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...L ...
 -- value_prim:false
 -- computeAdr:isFirst::Address:E:"none"off:3 size:0 isFloat:False superAdj ...
 -- computeAdr:2 :rec:"L"  E:":= @this List" :Address:E:"none"off:3 size:0  ...
 -- computeAdr:isAssign:rec: "L"  E:":= @this List" 
 -- :Address:E:"none"off:3 size:0 isFloat:False superAdj:0 isUnique:False i ...
 -- computeAdr:isLast:E: ":= @this List" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"none"off:3 size:0 isFloat:Fa ...
 -- rec: "L" E: ":= @this List" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:3 ":= @this List"
 -- $pattern:loadArgs:E:":= @this List":descNo:14:top:1 ":= :  |    %basic 8 |  ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= @this List" ActArg: "@this List" isValue: false
 -- $ObjectCall:gen: "@this List"
 -- $Invocation:gen: descNo: 18 top: 1 "@this List"
 -- needorigin:"@this List" 
 -- needOrigin:E:"@this List"  E.ATd:"@this:  |    %basic 18 |    in this: ref  ..." 
 -- computeAdr: "@this List" 
 -- computeAdr:1 :rec:"none"  E:"@this List" :Address:E:"none"off:0 size:0  ...
 -- $ObjectInvocation_KeyWord:pushThis: "@this List"
 pushThis 
 -- $ObjectInvocation_KeyWord:loadOrigin::on:4 "@this List"
 -- AdjustOrigin:originOff: 0
 -- this_prim:List:super.on:2 
 -- goOrigin:A:1 
 -- goOrigin:scan:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 scan:origin
 -- $ObjectInvocation_KeyWord:getAdr::superAdj:0:on:4 "@this List"
 -- $pattern:getAdr: "@this:  |    %basic 18 |    in this: ref Object"
 -- :Address:E:"@this List"off:0 size:0 isFloat:False superAdj:0 isUnique:F ...
 -- computeAdr:isFirst::Address:E:"@this List"off:0 size:0 isFloat:False su ...
 -- computeAdr:isLast:E: "@this List" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"@this List"off:0 size:0 isFl ...
 -- rec: "@this List" E: "@this List" isValueAssign: false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@this List"
 -- $pattern:loadArgs:E:"@this List":descNo:18:top:1 "@this:  |    %basic 18 |  ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"@this List" :Address:E:"@this List"off:0 size: ...
 -- $ObjectInvocation_KeyWord:invoke: rec:"@this List" "@this List"
 -- >top:1 descNo:18 
 -- E.ATd: "" unique: false
 -- adr::Address:E:"@this List"off:0 size:0 isFloat:False superAdj:0 isUniq ...
 -- $pattern:invoke: "@this:  |    %basic 18 |    in this: ref Object"
 -- Pattern:invoke:descNo:18  top:1  rec:"@this List" 
 -- ptn:invoke:primitive:
 -- useRtnVal:true:isVal:false:rtnValObj:false:rec=E:true"@this List" 
 -- OI:invoke:@this List:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"@this List" 
 -- loadArgs:after:Qgen:":= @this List" 
 -- vAssign:fArg:"in V: ref Value" 
 -- BINGO
 -- aaaa: in V: ref Value
 -- end:loadArgs:NonVirt:":= @this List" 
 -- invoke:after:loadArgsOf:":= @this List" :Address:E:"none"off:3 size:0 i ...
 -- $ObjectInvocation_Binary:invoke: rec:"L" ":= @this List"
 -- >top:1 descNo:14 
 -- E.ATd: ":= " unique: false
 -- adr::Address:E:"none"off:3 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: ref Value"
 -- AssignPtn:invoke:rec: "L" from: ":= @this List" 
 -- assign:dstDI :"L: ref List" isUnitValueObj: false
 -- assign:arg: "@this List" lab:"ObjectCall" UnitValObj :false ptn: false
 --  float: false DataItem:false arg.super:@this List
 --  arg.super.ATd:"Invocation" "@this:  |    %basic 18 |    in this: ref Objec ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "pattern" 
 -- assign:reference: "L" 
 -- :Address:E:"none"off:3 size:0 isFloat:False superAdj:0 isUnique:False i ...
 -- store::Address:E:"none"off:3 size:0 isFloat:False superAdj:0 isUnique:F ...
 -- isValue:false isAdr:false descNo: 0 
 rswap
 rstoreg 3 
 -- OI:invoke::= @this List:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= @this List" 
 -- genclass:Qgen:stmt:"current := head" 
 -- $ObjectCall:gen: "current := head"
 -- $Invocation:gen: descNo: 14 top: 1 "current := head"
 -- needorigin:"current := head" 
 -- needOrigin:E:":= head"  E.ATd:":= :  |    %basic 8 |    in V: ref Value" 
 -- computeAdr: "current := head" 
 -- computeAdr:1 :rec:"none"  E:"current" :Address:E:"none"off:0 size:0 isF ...
 -- $ObjectInvocation_Unary:pushThis: "current"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "current"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "current"
 -- $ref:getAdr:,newOff:2,isValue:"False",A.isValue:"False" "current: ref O ..."
 --  A::Address:E:"current"off:0 size:0 isFloat:False superAdj:0 isUnique:F ...  ...c ...
 -- value_prim:false
 -- computeAdr:isFirst::Address:E:"none"off:2 size:0 isFloat:False superAdj ...
 -- computeAdr:2 :rec:"current"  E:":= head" :Address:E:"none"off:2 size:0  ...
 -- computeAdr:isAssign:rec: "current"  E:":= head" 
 -- :Address:E:"none"off:2 size:0 isFloat:False superAdj:0 isUnique:False i ...
 -- computeAdr:isLast:E: ":= head" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"none"off:2 size:0 isFloat:Fa ...
 -- rec: "current" E: ":= head" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:2 ":= head"
 -- $pattern:loadArgs:E:":= head":descNo:14:top:1 ":= :  |    %basic 8 |    in  ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= head" ActArg: "head" isValue: false
 -- $ObjectCall:gen: "head"
 -- $Invocation:gen: "head"
 -- needorigin:"head" 
 -- needOrigin:E:"head"  E.ATd:"in head: ref Object" 
 -- needOrigin:datItem:leave
 -- computeAdr: "head" 
 -- computeAdr:1 :rec:"none"  E:"head" :Address:E:"none"off:0 size:0 isFloa ...
 -- $ObjectInvocation_Unary:pushThis: "head"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "head"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:1 
 -- goOrigin:scan:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 scan:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:1 "head"
 -- $ref:getAdr:,newOff:2,isValue:"False",A.isValue:"False" "in head: ref O ..."
 --  A::Address:E:"head"off:0 size:0 isFloat:False superAdj:0 isUnique:Fals ...  ...i ...
 -- value_prim:false
 -- computeAdr:isFirst::Address:E:"none"off:2 size:0 isFloat:False superAdj ...
 -- computeAdr:isLast:E: "head" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"none"off:2 size:0 isFloat:Fa ...
 -- rec: "head" E: "head" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "head"
 -- $ref:loadArgs: "in head: ref Object"
 -- invoke:after:loadArgsOf:"head" :Address:E:"none"off:2 size:0 isFloat:Fa ...
 -- $ObjectInvocation_Unary:invoke: rec:"head" "head"
 -- E.ATd: "head" unique: false
 -- adr::Address:E:"none"off:2 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- $ref:invoke: newOff:2 "in head: ref Object"
 -- >Object:unique:false
 -- load::Address:E:"none"off:2 size:0 isFloat:False superAdj:0 isUnique:Fa ...
 rpushg 2 
 -- OI:invoke:head:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"head" 
 -- loadArgs:after:Qgen:":= head" 
 -- vAssign:fArg:"in V: ref Value" 
 -- end:loadArgs:NonVirt:":= head" 
 -- invoke:after:loadArgsOf:":= head" :Address:E:"none"off:2 size:0 isFloat ...
 -- $ObjectInvocation_Binary:invoke: rec:"current" ":= head"
 -- >top:1 descNo:14 
 -- E.ATd: ":= " unique: false
 -- adr::Address:E:"none"off:2 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: ref Value"
 -- AssignPtn:invoke:rec: "current" from: ":= head" 
 -- assign:dstDI :"current: ref Object" isUnitValueObj: false
 -- assign:arg: "head" lab:"ObjectCall" UnitValObj :false ptn: false
 --  float: false DataItem:false arg.super:head
 --  arg.super.ATd:"Invocation" "in head: ref Object" 
 --  arg.super.ATd.isDataItem:true arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "ref" 
 -- assign:reference: "current" 
 -- :Address:E:"none"off:2 size:0 isFloat:False superAdj:0 isUnique:False i ...
 -- store::Address:E:"none"off:2 size:0 isFloat:False superAdj:0 isUnique:F ...
 -- isValue:false isAdr:false descNo: 0 
 rswap
 rstoreg 2 
 -- OI:invoke::= head:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= head" 
 -- genclass:Qgen:stmt:"loop" 
 -- $ObjectCall:gen: "loop"
 -- $Invocation:gen: descNo: 23 top: 1 "loop"
 -- needorigin:"loop" 
 -- needOrigin:E:"loop"  E.ATd:"loop:  |    @inner scan |    @if L.tail <> none ..." 
 -- computeAdr: "loop" 
 -- computeAdr:1 :rec:"none"  E:"loop" :Address:E:"none"off:0 size:0 isFloa ...
 -- $ObjectInvocation_Unary:pushThis: "loop"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "loop"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "loop"
 -- $pattern:getAdr: "loop:  |    @inner scan |    @if L.tail <> none :then  |    ..."
 -- :Address:E:"loop"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...
 -- computeAdr:isFirst::Address:E:"loop"off:0 size:0 isFloat:False superAdj ...
 -- computeAdr:isLast:E: "loop" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"loop"off:0 size:0 isFloat:Fa ...
 -- rec: "loop" E: "loop" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "loop"
 -- $pattern:loadArgs:E:"loop":descNo:23:top:1 "loop:  |    @inner scan |    @i ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"loop" :Address:E:"loop"off:0 size:0 isFloat:Fa ...
 -- $ObjectInvocation_Unary:invoke: rec:"loop" "loop"
 -- >top:1 descNo:23 
 -- E.ATd: "loop" unique: false
 -- adr::Address:E:"loop"off:0 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- $pattern:invoke: "loop:  |    @inner scan |    @if L.tail <> none :then  |    ..."
 -- Pattern:invoke:descNo:23  top:1  rec:"loop" 
 -- ptn:invoke::isValObj:false:rtnValObj:false:"loop:  |    @inner scan |    @i ..." 
 -- rec=E:true:rec:"loop" 
 -- kuk:pattern:rec.ATd:"loop:  |    @inner scan |    @if L.tail <> none :then  ..." 
 invoke loop 23 0 0
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:true"loop" 
 rpop
 -- OI:invoke:loop:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"loop" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"scan" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:3 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:1
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 25 :top:1 
 -- GenClass:#S#25 :varNo = 1 
 -- GenClass:#S#25:true -> var.genDone

class #S#25 25 1 0
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"do" 
 -- $ObjectCall:gen: "do"
 -- $Invocation:gen: descNo: 0 top: 1 "do"
 -- needorigin:"do" 
 -- needOrigin:E:"do"  E.ATd:"in do:< Object" 
 -- computeAdr: "do" 
 -- computeAdr:1 :rec:"none"  E:"do" :Address:E:"none"off:0 size:0 isFloat: ...
 -- $ObjectInvocation_Unary:pushThis: "do"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:3 "do"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:3 
 -- goOrigin:#S#25:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 #S#25:origin
 -- goOrigin:A:2 
 -- goOrigin:Skip:ifThen
 -- goOrigin:A:2 
 -- goOrigin:loop:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 loop:origin
 -- goOrigin:A:1 
 -- goOrigin:doIt:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 doIt:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:3 "do"
 -- $pattern:getAdr: "in do:< Object"
 -- :Address:E:"do"off:0 size:0 isFloat:False superAdj:0 isUnique:False isV ...
 -- computeAdr:isFirst::Address:E:"do"off:0 size:0 isFloat:False superAdj:0 ...
 -- computeAdr:isLast:E: "do" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"do"off:0 size:0 isFloat:Fals ...
 -- rec: "do" E: "do" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "do"
 -- $pattern:loadArgs:E:"do":descNo:0:top:1 "in do:< Object"
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"do" :Address:E:"do"off:0 size:0 isFloat:False  ...
 -- $ObjectInvocation_Unary:invoke: rec:"do" "do"
 -- >top:1 descNo:0 
 -- E.ATd: "do" unique: false
 -- adr::Address:E:"do"off:0 size:0 isFloat:False superAdj:0 isUnique:False ...
 -- $pattern:invoke: "in do:< Object"
 -- Pattern:invoke:descNo:0  top:1  rec:"do" 
 sendv 1 0 do
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:true"do" 
 rpop
 -- OI:invoke:do:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"do" 
 -- genclass:Qgen:stmt:"inx := inx + 1" 
 -- $ObjectCall:gen: "inx := inx + 1"
 -- $Invocation:gen: descNo: 4 top: 1 "inx := inx + 1"
 -- needorigin:"inx := inx + 1" 
 -- needOrigin:E:":= inx + 1"  E.ATd:":= :  |    %basic 8 |    in V: var Value" 
 -- computeAdr: "inx := inx + 1" 
 -- computeAdr:1 :rec:"none"  E:"inx" :Address:E:"none"off:0 size:0 isFloat ...
 -- $ObjectInvocation_Unary:pushThis: "inx"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:3 "inx"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:3 
 -- goOrigin:#S#25:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 #S#25:origin
 -- goOrigin:A:2 
 -- goOrigin:Skip:ifThen
 -- goOrigin:A:2 
 -- goOrigin:loop:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 loop:origin
 -- goOrigin:A:1 
 -- goOrigin:doIt:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 doIt:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:3 "inx"
 -- $var:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "inx: var intege ..."
 --  A::Address:E:"inx"off:0 size:0 isFloat:False superAdj:0 isUnique:False ...  ...i ...
 -- value_prim:false
 -- integer
 -- before:floatTest: 
 -- computeAdr:isFirst::Address:E:"inx"off:3 size:0 isFloat:False superAdj: ...
 -- computeAdr:2 :rec:"inx"  E:":= inx + 1" :Address:E:"inx"off:3 size:0 is ...
 -- computeAdr:isAssign:rec: "inx"  E:":= inx + 1" 
 -- :Address:E:"inx"off:3 size:0 isFloat:False superAdj:0 isUnique:False is ...
 -- computeAdr:isLast:E: ":= inx + 1" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"inx"off:3 size:0 isFloat:Fal ...
 -- rec: "inx" E: ":= inx + 1" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:3 ":= inx + 1"
 -- $pattern:loadArgs:E:":= inx + 1":descNo:4:top:1 ":= :  |    %basic 8 |    i ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= inx + 1" ActArg: "inx + 1" isValue: false
 -- $ObjectCall:gen: "inx + 1"
 -- $Invocation:gen: descNo: 0 top: 0 "inx + 1"
 -- needorigin:"inx + 1" 
 -- needOrigin:E:"+ 1"  E.ATd:"+ :  |    %basic 61 |    in V: var integer |    ou ..." 
 -- computeAdr: "inx + 1" 
 -- computeAdr:1 :rec:"none"  E:"inx" :Address:E:"none"off:0 size:0 isFloat ...
 -- $ObjectInvocation_Unary:pushThis: "inx"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:3 "inx"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:3 
 -- goOrigin:#S#25:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 #S#25:origin
 -- goOrigin:A:2 
 -- goOrigin:Skip:ifThen
 -- goOrigin:A:2 
 -- goOrigin:loop:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 loop:origin
 -- goOrigin:A:1 
 -- goOrigin:doIt:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 doIt:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:3 "inx"
 -- $var:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "inx: var intege ..."
 --  A::Address:E:"inx"off:0 size:0 isFloat:False superAdj:0 isUnique:False ...  ...i ...
 -- value_prim:false
 -- integer
 -- before:floatTest: 
 -- computeAdr:isFirst::Address:E:"inx"off:3 size:0 isFloat:False superAdj: ...
 -- computeAdr:2 :rec:"inx"  E:"+ 1" :Address:E:"inx"off:3 size:0 isFloat:F ...
 -- E:notAssign:+ 1
 -- $ObjectInvocation_Binary:getAdr::superAdj:0:on:0 "+ 1"
 -- $pattern:getAdr: "+ :  |    %basic 61 |    in V: var integer |    out R: var  ..."
 -- :Address:E:"inx"off:3 size:0 isFloat:False superAdj:0 isUnique:False is ...
 -- ptn.ssUnitValueObj:false isFloat:false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "inx"
 -- $var:loadArgs: "inx: var integer"
 -- $ObjectInvocation_Unary:invoke: rec:"inx" "inx"
 -- E.ATd: "+  | --%basic 61]] | " unique: false
 -- adr::Address:E:"inx"off:3 size:0 isFloat:False superAdj:0 isUnique:Fals ...
 -- $var:invoke: newOff:3 "inx: var integer"
 -- load::Address:E:"inx"off:3 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- isFloat: false
 pushg 3 
 -- OI:invoke:inx:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "+ 1" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"inx"off:3 size:0 isFloat:Fal ...
 -- rec: "inx" E: "+ 1" isValueAssign: false
 -- $ObjectInvocation_Binary:loadArgs:staticOff:0 "+ 1"
 -- $pattern:loadArgs:E:"+ 1":descNo:0:top:0 "+ :  |    %basic 61 |    in V: va ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"+ 1" ActArg: "1" isValue: true
 -- loadArgs:not:*: formalArgOf:"+ 1"  isCompositeValueObj:false
 -- $ObjectCall:gen: "1"
 -- $Invocation:gen: "1"
 -- needorigin:"1" 
 -- needOrigin:E:"1"  E.ATd:"integer: value |    %basic 1, 32 |    %globals |     ..." 
 -- LoadOrign:no:loadOrigin: "value |    %basic 1, 32 |    %globals |    %public |  ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "1" E: "1" isValueAssign: false
 -- $ConstLiteral:loadArgs: "1"
 -- invoke:after:loadArgsOf:"1" 
 -- $ConstLiteral:invoke: "1"
 pushc 1
 -- invoke:after:E.invoke:"1" 
 -- loadArgs:after:Qgen:"+ 1" 
 -- formalArg:isPtn:"in V: var integer" :isBasicVal:true:valueObj:true
 -- :actArg:"1" :isBasicVal:true
 -- 1ObjectCall
 -- convDone:false
 -- end:loadArgs:NonVirt:"+ 1" 
 -- invoke:after:loadArgsOf:"+ 1" :Address:E:"inx"off:3 size:0 isFloat:Fals ...
 -- $ObjectInvocation_Binary:invoke: rec:"inx" "+ 1"
 -- >top:0 descNo:0 
 -- E.ATd: "+  | --%basic 61]] | " unique: false
 -- adr::Address:E:"inx"off:3 size:0 isFloat:False superAdj:0 isUnique:Fals ...
 -- $pattern:invoke: "+ :  |    %basic 61 |    in V: var integer |    out R: var  ..."
 -- bodyC:
 plus
 -- OI:invoke:+ 1:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"+ 1" 
 -- loadArgs:after:Qgen:":= inx + 1" 
 -- vAssign:fArg:"in V: var Value" 
 -- BINGO
 -- aaaa: in V: var Value
 -- end:loadArgs:NonVirt:":= inx + 1" 
 -- invoke:after:loadArgsOf:":= inx + 1" :Address:E:"inx"off:3 size:0 isFlo ...
 -- $ObjectInvocation_Binary:invoke: rec:"inx" ":= inx + 1"
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Address:E:"inx"off:3 size:0 isFloat:False superAdj:0 isUnique:Fals ...
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "inx" from: ":= inx + 1" 
 -- assign:dstDI :"inx: var integer" isUnitValueObj: false
 -- assign:arg: "inx + 1" lab:"ObjectCall" UnitValObj :false ptn: false
 --  float: false DataItem:false arg.super:inx + 1
 --  arg.super.ATd:"Invocation" "+ :  |    %basic 61 |    in V: var integer |     ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "pattern" 
 -- assign:simple value: 
 -- :Address:E:"inx"off:3 size:0 isFloat:False superAdj:0 isUnique:False is ...
 -- store::Address:E:"inx"off:3 size:0 isFloat:False superAdj:0 isUnique:Fa ...
 -- isValue:true isAdr:false descNo: 0 
 -- isFloat: false
 storeg 3 address:storeg
 -- OI:invoke::= inx + 1:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= inx + 1" 
 -- genclass:Qgen:stmt:"@restart loop" 
 -- $ObjectCall:gen: "@restart loop"
 -- $Invocation:gen: descNo: 0 top: 0 "@restart loop"
 -- needorigin:"@restart loop" 
 -- needOrigin:E:"@restart loop"  E.ATd:"@restart:  |    %basic 102 |    in res ..." 
 -- computeAdr: "@restart loop" 
 -- computeAdr:1 :rec:"none"  E:"@restart loop" :Address:E:"none"off:0 size ...
 -- $ObjectInvocation_KeyWord:pushThis: "@restart loop"
 -- $ObjectInvocation_KeyWord:loadOrigin::on:4 "@restart loop"
 -- $ObjectInvocation_KeyWord:getAdr::superAdj:0:on:4 "@restart loop"
 -- $pattern:getAdr: "@restart:  |    %basic 102 |    in restart: var integer"
 -- :Address:E:"@restart loop"off:0 size:0 isFloat:False superAdj:0 isUniqu ...
 -- computeAdr:isFirst::Address:E:"@restart loop"off:0 size:0 isFloat:False ...
 -- computeAdr:isLast:E: "@restart loop" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"@restart loop"off:0 size:0 i ...
 -- rec: "@restart loop" E: "@restart loop" isValueAssign: false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@restart loop"
 -- $pattern:loadArgs:E:"@restart loop":descNo:0:top:0 "@restart:  |    %basi ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"@restart loop" :Address:E:"@restart loop"off:0 ...
 -- $ObjectInvocation_KeyWord:invoke: rec:"@restart loop" "@restart loop"
 -- >top:0 descNo:0 
 -- E.ATd: "" unique: false
 -- adr::Address:E:"@restart loop"off:0 size:0 isFloat:False superAdj:0 isU ...
 -- $pattern:invoke: "@restart:  |    %basic 102 |    in restart: var integer"
 break 1 1 26
 -- OI:invoke:@restart loop:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"@restart loop" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:0  vTop:-1 vTopMax:1 rTop:2 rTopMax:2
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 26 :top:1 
 -- GenClass:loop :varNo = 1 
 -- GenClass:loop:true -> var.genDone

class loop 26 1 27
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"@if inx <= to :then  |    do |    inx := inx + 1 |    @re ..." 
 -- $ObjectGenerator:gen:"@if::then#S#0"IS.isempty! staticOff: 0 descNo: 0  ...
 -- OG:gen:super:"" superDescNo:20 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: false
 -- $Invocation:gen: descNo: 20 top: 1 "@if inx <= to :then  |    do |    inx : ..."
 -- needorigin:"@if inx <= to :then  |    do |    inx := inx + 1 |    @restart lo ..." 
 -- needOrigin:E:"@if inx <= to :then  |    do |    inx := inx + 1 |    @restart  ..."   ..."@ ..." 
 -- LoadOrign:no:loadOrigin: "%globals inSub | %basic 100 | in if: var boolean |  ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "@if inx <= to :then  |    do |    inx := inx + 1 |    @restart loop" E ..."@ ..." i ...false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@if inx <= to :then  |    ..."
 -- $pattern:loadArgs:E:"@if inx <= to :then  |    do |    inx := inx + 1 |    @r ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"@if inx <= to :then  |    do |    inx := inx + 1 |   ..." 
 -- $ObjectInvocation_KeyWord:invoke: rec:"@if inx <= to :then  |    do |    in ..."
 -- >top:1 descNo:20 
 -- $pattern:invoke: "@if:  |    %globals inSub |    %basic 100 |    in if: var b ..."
 -- $ObjectCall:gen: "inx <= to"
 -- $Invocation:gen: descNo: 0 top: 0 "inx <= to"
 -- needorigin:"inx <= to" 
 -- needOrigin:E:"<= to"  E.ATd:"<= :  |    %basic 52 |    in V: var integer |    ..." 
 -- computeAdr: "inx <= to" 
 -- computeAdr:1 :rec:"none"  E:"inx" :Address:E:"none"off:0 size:0 isFloat ...
 -- $ObjectInvocation_Unary:pushThis: "inx"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:2 "inx"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:2 
 -- goOrigin:loop:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 loop:origin
 -- goOrigin:A:1 
 -- goOrigin:doIt:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 doIt:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:2 "inx"
 -- $var:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "inx: var intege ..."
 --  A::Address:E:"inx"off:0 size:0 isFloat:False superAdj:0 isUnique:False ...  ...i ...
 -- value_prim:false
 -- integer
 -- before:floatTest: 
 -- computeAdr:isFirst::Address:E:"inx"off:3 size:0 isFloat:False superAdj: ...
 -- computeAdr:2 :rec:"inx"  E:"<= to" :Address:E:"inx"off:3 size:0 isFloat ...
 -- E:notAssign:<= to
 -- $ObjectInvocation_Binary:getAdr::superAdj:0:on:0 "<= to"
 -- $pattern:getAdr: "<= :  |    %basic 52 |    in V: var integer |    out B: var ..."
 -- :Address:E:"inx"off:3 size:0 isFloat:False superAdj:0 isUnique:False is ...
 -- ptn.ssUnitValueObj:false isFloat:false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "inx"
 -- $var:loadArgs: "inx: var integer"
 -- $ObjectInvocation_Unary:invoke: rec:"inx" "inx"
 -- E.ATd: "<= " unique: false
 -- adr::Address:E:"inx"off:3 size:0 isFloat:False superAdj:0 isUnique:Fals ...
 -- $var:invoke: newOff:3 "inx: var integer"
 -- load::Address:E:"inx"off:3 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- isFloat: false
 pushg 3 
 -- OI:invoke:inx:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "<= to" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"inx"off:3 size:0 isFloat:Fal ...
 -- rec: "inx" E: "<= to" isValueAssign: false
 -- $ObjectInvocation_Binary:loadArgs:staticOff:0 "<= to"
 -- $pattern:loadArgs:E:"<= to":descNo:0:top:0 "<= :  |    %basic 52 |    in V: ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"<= to" ActArg: "to" isValue: false
 -- loadArgs:not:*: formalArgOf:"<= to"  isCompositeValueObj:false
 -- $ObjectCall:gen: "to"
 -- $Invocation:gen: "to"
 -- needorigin:"to" 
 -- needOrigin:E:"to"  E.ATd:"in to: var integer" 
 -- needOrigin:datItem:leave
 -- computeAdr: "to" 
 -- computeAdr:1 :rec:"none"  E:"to" :Address:E:"none"off:0 size:0 isFloat: ...
 -- $ObjectInvocation_Unary:pushThis: "to"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:2 "to"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:2 
 -- goOrigin:loop:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 loop:origin
 -- goOrigin:A:1 
 -- goOrigin:doIt:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 doIt:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:2 "to"
 -- $var:getAdr:,newOff:2,isValue:"True",A.isValue:"False" "in to: var inte ..."
 --  A::Address:E:"to"off:0 size:0 isFloat:False superAdj:0 isUnique:False  ...  ...i ...
 -- value_prim:false
 -- integer
 -- before:floatTest: 
 -- computeAdr:isFirst::Address:E:"to"off:2 size:0 isFloat:False superAdj:0 ...
 -- computeAdr:isLast:E: "to" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"to"off:2 size:0 isFloat:Fals ...
 -- rec: "to" E: "to" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "to"
 -- $var:loadArgs: "in to: var integer"
 -- invoke:after:loadArgsOf:"to" :Address:E:"to"off:2 size:0 isFloat:False  ...
 -- $ObjectInvocation_Unary:invoke: rec:"to" "to"
 -- E.ATd: "to" unique: false
 -- adr::Address:E:"to"off:2 size:0 isFloat:False superAdj:0 isUnique:False ...
 -- $var:invoke: newOff:2 "in to: var integer"
 -- load::Address:E:"to"off:2 size:0 isFloat:False superAdj:0 isUnique:Fals ...
 -- isFloat: false
 pushg 2 
 -- OI:invoke:to:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"to" 
 -- loadArgs:after:Qgen:"<= to" 
 -- formalArg:isPtn:"in V: var integer" :isBasicVal:true:valueObj:true
 -- :actArg:"to" :isBasicVal:true
 -- toObjectCall
 -- end:loadArgs:NonVirt:"<= to" 
 -- invoke:after:loadArgsOf:"<= to" :Address:E:"inx"off:3 size:0 isFloat:Fa ...
 -- $ObjectInvocation_Binary:invoke: rec:"inx" "<= to"
 -- >top:0 descNo:0 
 -- E.ATd: "<= " unique: false
 -- adr::Address:E:"inx"off:3 size:0 isFloat:False superAdj:0 isUnique:Fals ...
 -- $pattern:invoke: "<= :  |    %basic 52 |    in V: var integer |    out B: var ..."
 -- bodyC:
 le
 -- OI:invoke:<= to:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"<= to" 
 jmpFalse L3
 -- $ObjectGenerator:gen:"#S#25"singular! staticOff: 0 descNo: 25 top:1 "do ..."
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 25  #S#25
 invoke #S#25 25 0 1
 rpop
 L3:
 -- OI:invoke:@if inx <= to :then  |    do |    inx := inx + 1 |    @restart loop ...: ...-none-  ...0.000000
 -- invoke:after:E.invoke:"@if inx <= to :then  |    do |    inx := inx + 1 |     ..." 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:0  vTop:-1 vTopMax:0 rTop:2 rTopMax:2
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 27 :top:1 
 -- GenClass:doIt :varNo = 1 
 -- GenClass:doIt:true -> var.genDone

class doIt 27 1 28
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $Signature:gen: "doIt"
 -- $obj:gen: "loop: obj  |    @if inx <= to :then  |       do |       inx := inx ..."
 -- DI:isConst:true:isBasicValue:false:primNo:0 
 -- OGqual:none:OGqual.isBasicValue:false:OGqual.isValueObj:false
 -- $ObjectGenerator:gen:"loop"singular! staticOff: 2 descNo: 26 top:1 "@if ..."
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 26  loop
 invoke loop 26 2 1
 rpop
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"doIt" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 28 :top:1 
 -- GenClass:@for::to:do :varNo = 1 
 -- GenClass:@for::to:do:true -> var.genDone

class @for::to:do 28 0 6
 -- Store itemArgs
 pushThis 
 storeg 2 to
 pushThis 
 storeg 1 for
 allocEventQ
 mvStack 
 -- $Signature:gen: ""
 -- $var:gen: "in for: var integer"
 -- DI:isConst:false:isBasicValue:true:primNo:1 
 -- OGqual:integer:OGqual.isBasicValue:true:OGqual.isValueObj:true
 -- $var:gen: "in to: var integer"
 -- DI:isConst:false:isBasicValue:true:primNo:1 
 -- OGqual:integer:OGqual.isBasicValue:true:OGqual.isValueObj:true
 -- $pattern:gen: "in do:< Object"
 -- vdt:d
 -- vdtAdd: inx=1 descInx=86
 -- $var:gen: "inx: var integer"
 -- DI:isConst:false:isBasicValue:true:primNo:1 
 -- OGqual:integer:OGqual.isBasicValue:true:OGqual.isValueObj:true
 innerA  2
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%globals inSub" 
 -- $Property:gen: "%globals inSub"
 -- genclass:Qgen:stmt:"%public" 
 -- $Property:gen: "%public"
 -- genclass:Qgen:stmt:"%private" 
 -- $Property:gen: "%private"
 -- genclass:Qgen:stmt:"inx := for" 
 -- $ObjectCall:gen: "inx := for"
 -- $Invocation:gen: descNo: 4 top: 1 "inx := for"
 -- needorigin:"inx := for" 
 -- needOrigin:E:":= for"  E.ATd:":= :  |    %basic 8 |    in V: var Value" 
 -- computeAdr: "inx := for" 
 -- computeAdr:1 :rec:"none"  E:"inx" :Address:E:"none"off:0 size:0 isFloat ...
 -- $ObjectInvocation_Unary:pushThis: "inx"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "inx"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "inx"
 -- $var:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "inx: var intege ..."
 --  A::Address:E:"inx"off:0 size:0 isFloat:False superAdj:0 isUnique:False ...  ...i ...
 -- value_prim:false
 -- integer
 -- before:floatTest: 
 -- computeAdr:isFirst::Address:E:"inx"off:3 size:0 isFloat:False superAdj: ...
 -- computeAdr:2 :rec:"inx"  E:":= for" :Address:E:"inx"off:3 size:0 isFloa ...
 -- computeAdr:isAssign:rec: "inx"  E:":= for" 
 -- :Address:E:"inx"off:3 size:0 isFloat:False superAdj:0 isUnique:False is ...
 -- computeAdr:isLast:E: ":= for" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"inx"off:3 size:0 isFloat:Fal ...
 -- rec: "inx" E: ":= for" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:3 ":= for"
 -- $pattern:loadArgs:E:":= for":descNo:4:top:1 ":= :  |    %basic 8 |    in V: ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= for" ActArg: "for" isValue: false
 -- $ObjectCall:gen: "for"
 -- $Invocation:gen: "for"
 -- needorigin:"for" 
 -- needOrigin:E:"for"  E.ATd:"in for: var integer" 
 -- needOrigin:datItem:leave
 -- computeAdr: "for" 
 -- computeAdr:1 :rec:"none"  E:"for" :Address:E:"none"off:0 size:0 isFloat ...
 -- $ObjectInvocation_Unary:pushThis: "for"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "for"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "for"
 -- $var:getAdr:,newOff:1,isValue:"True",A.isValue:"False" "in for: var int ..."
 --  A::Address:E:"for"off:0 size:0 isFloat:False superAdj:0 isUnique:False ...  ...i ...
 -- value_prim:false
 -- integer
 -- before:floatTest: 
 -- computeAdr:isFirst::Address:E:"for"off:1 size:0 isFloat:False superAdj: ...
 -- computeAdr:isLast:E: "for" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"for"off:1 size:0 isFloat:Fal ...
 -- rec: "for" E: "for" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "for"
 -- $var:loadArgs: "in for: var integer"
 -- invoke:after:loadArgsOf:"for" :Address:E:"for"off:1 size:0 isFloat:Fals ...
 -- $ObjectInvocation_Unary:invoke: rec:"for" "for"
 -- E.ATd: "for" unique: false
 -- adr::Address:E:"for"off:1 size:0 isFloat:False superAdj:0 isUnique:Fals ...
 -- $var:invoke: newOff:1 "in for: var integer"
 -- load::Address:E:"for"off:1 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- isFloat: false
 pushg 1 
 -- OI:invoke:for:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"for" 
 -- loadArgs:after:Qgen:":= for" 
 -- vAssign:fArg:"in V: var Value" 
 -- end:loadArgs:NonVirt:":= for" 
 -- invoke:after:loadArgsOf:":= for" :Address:E:"inx"off:3 size:0 isFloat:F ...
 -- $ObjectInvocation_Binary:invoke: rec:"inx" ":= for"
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Address:E:"inx"off:3 size:0 isFloat:False superAdj:0 isUnique:Fals ...
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "inx" from: ":= for" 
 -- assign:dstDI :"inx: var integer" isUnitValueObj: false
 -- assign:arg: "for" lab:"ObjectCall" UnitValObj :false ptn: false
 --  float: false DataItem:false arg.super:for
 --  arg.super.ATd:"Invocation" "in for: var integer" 
 --  arg.super.ATd.isDataItem:true arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "var" 
 -- assign:simple value: 
 -- :Address:E:"inx"off:3 size:0 isFloat:False superAdj:0 isUnique:False is ...
 -- store::Address:E:"inx"off:3 size:0 isFloat:False superAdj:0 isUnique:Fa ...
 -- isValue:true isAdr:false descNo: 0 
 -- isFloat: false
 storeg 3 address:storeg
 -- OI:invoke::= for:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= for" 
 -- genclass:Qgen:stmt:"doIt" 
 -- $ObjectCall:gen: "doIt"
 -- $Invocation:gen: descNo: 27 top: 1 "doIt"
 -- needorigin:"doIt" 
 -- needOrigin:E:"doIt"  E.ATd:"doIt:  |    loop: obj  |       @if inx <= to :t ..." 
 -- computeAdr: "doIt" 
 -- computeAdr:1 :rec:"none"  E:"doIt" :Address:E:"none"off:0 size:0 isFloa ...
 -- $ObjectInvocation_Unary:pushThis: "doIt"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "doIt"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "doIt"
 -- $pattern:getAdr: "doIt:  |    loop: obj  |       @if inx <= to :then  |       ..."
 -- :Address:E:"doIt"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...
 -- computeAdr:isFirst::Address:E:"doIt"off:0 size:0 isFloat:False superAdj ...
 -- computeAdr:isLast:E: "doIt" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"doIt"off:0 size:0 isFloat:Fa ...
 -- rec: "doIt" E: "doIt" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "doIt"
 -- $pattern:loadArgs:E:"doIt":descNo:27:top:1 "doIt:  |    loop: obj  |        ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"doIt" :Address:E:"doIt"off:0 size:0 isFloat:Fa ...
 -- $ObjectInvocation_Unary:invoke: rec:"doIt" "doIt"
 -- >top:1 descNo:27 
 -- E.ATd: "doIt" unique: false
 -- adr::Address:E:"doIt"off:0 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- $pattern:invoke: "doIt:  |    loop: obj  |       @if inx <= to :then  |       ..."
 -- Pattern:invoke:descNo:27  top:1  rec:"doIt" 
 -- ptn:invoke::isValObj:false:rtnValObj:false:"doIt:  |    loop: obj  |        ..." 
 -- rec=E:true:rec:"doIt" 
 -- kuk:pattern:rec.ATd:"doIt:  |    loop: obj  |       @if inx <= to :then  |    ..." 
 invoke doIt 27 0 0
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:true"doIt" 
 rpop
 -- OI:invoke:doIt:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"doIt" 
 -- genclass:Qgen:stmt:"@inner for" 
 -- $ObjectCall:gen: "@inner for"
 -- $Invocation:gen: descNo: 0 top: 0 "@inner for"
 -- needorigin:"@inner for" 
 -- needOrigin:E:"@inner for"  E.ATd:"@inner:  |    %basic 101 |    in inner: r ..." 
 -- computeAdr: "@inner for" 
 -- computeAdr:1 :rec:"none"  E:"@inner for" :Address:E:"none"off:0 size:0  ...
 -- $ObjectInvocation_KeyWord:pushThis: "@inner for"
 -- $ObjectInvocation_KeyWord:loadOrigin::on:1 "@inner for"
 -- $ObjectInvocation_KeyWord:getAdr::superAdj:0:on:1 "@inner for"
 -- $pattern:getAdr: "@inner:  |    %basic 101 |    in inner: ref Object"
 -- :Address:E:"@inner for"off:0 size:0 isFloat:False superAdj:0 isUnique:F ...
 -- computeAdr:isFirst::Address:E:"@inner for"off:0 size:0 isFloat:False su ...
 -- computeAdr:isLast:E: "@inner for" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"@inner for"off:0 size:0 isFl ...
 -- rec: "@inner for" E: "@inner for" isValueAssign: false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@inner for"
 -- $pattern:loadArgs:E:"@inner for":descNo:0:top:0 "@inner:  |    %basic 101 ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"@inner for" :Address:E:"@inner for"off:0 size: ...
 -- $ObjectInvocation_KeyWord:invoke: rec:"@inner for" "@inner for"
 -- >top:0 descNo:0 
 -- E.ATd: "" unique: false
 -- adr::Address:E:"@inner for"off:0 size:0 isFloat:False superAdj:0 isUniq ...
 -- $pattern:invoke: "@inner:  |    %basic 101 |    in inner: ref Object"
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:@inner for:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"@inner for" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"@for::to:do" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:3 isIndexed:0  vTop:-3 vTopMax:0 rTop:5 rTopMax:5
 -- Virtual
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 29 :top:1 
 -- GenClass:length :varNo = 1 
 -- GenClass:length:true -> var.genDone

class length 29 1 15
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $Signature:gen: "length"
 -- $var:gen: "out V: var integer"
 -- DI:isConst:false:isBasicValue:true:primNo:1 
 -- OGqual:integer:OGqual.isBasicValue:true:OGqual.isValueObj:true
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"V := @get 0" 
 -- $ObjectCall:gen: "V := @get 0"
 -- $Invocation:gen: descNo: 4 top: 1 "V := @get 0"
 -- needorigin:"V := @get 0" 
 -- needOrigin:E:":= @get 0"  E.ATd:":= :  |    %basic 8 |    in V: var Value" 
 -- computeAdr: "V := @get 0" 
 -- computeAdr:1 :rec:"none"  E:"V" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "V"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "V"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "V"
 -- $var:getAdr:,newOff:2,isValue:"True",A.isValue:"False" "out V: var inte ..."
 --  A::Address:E:"V"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...o ...
 -- value_prim:false
 -- integer
 -- before:floatTest: 
 -- computeAdr:isFirst::Address:E:"V"off:2 size:0 isFloat:False superAdj:0  ...
 -- computeAdr:2 :rec:"V"  E:":= @get 0" :Address:E:"V"off:2 size:0 isFloat ...
 -- computeAdr:isAssign:rec: "V"  E:":= @get 0" 
 -- :Address:E:"V"off:2 size:0 isFloat:False superAdj:0 isUnique:False isVa ...
 -- computeAdr:isLast:E: ":= @get 0" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"V"off:2 size:0 isFloat:False ...
 -- rec: "V" E: ":= @get 0" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:2 ":= @get 0"
 -- $pattern:loadArgs:E:":= @get 0":descNo:4:top:1 ":= :  |    %basic 8 |    in ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= @get 0" ActArg: "@get 0" isValue: false
 -- $ObjectCall:gen: "@get 0"
 -- $Invocation:gen: descNo: 0 top: 0 "@get 0"
 -- needorigin:"@get 0" 
 -- needOrigin:E:"@get 0"  E.ATd:"@get:  |    %basic 117 |    in get: var integ ..." 
 -- computeAdr: "@get 0" 
 -- computeAdr:1 :rec:"none"  E:"@get 0" :Address:E:"none"off:0 size:0 isFl ...
 -- $ObjectInvocation_KeyWord:pushThis: "@get 0"
 pushThis 
 -- $ObjectInvocation_KeyWord:loadOrigin::on:1 "@get 0"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:1 
 -- goOrigin:length:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 length:origin
 -- $ObjectInvocation_KeyWord:getAdr::superAdj:0:on:1 "@get 0"
 -- $pattern:getAdr: "@get:  |    %basic 117 |    in get: var integer |    out ch ..."
 -- :Address:E:"@get 0"off:0 size:0 isFloat:False superAdj:0 isUnique:False ...
 -- computeAdr:isFirst::Address:E:"@get 0"off:0 size:0 isFloat:False superA ...
 -- computeAdr:isLast:E: "@get 0" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"@get 0"off:0 size:0 isFloat: ...
 -- rec: "@get 0" E: "@get 0" isValueAssign: false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@get 0"
 -- $pattern:loadArgs:E:"@get 0":descNo:0:top:0 "@get:  |    %basic 117 |    in ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"@get 0" ActArg: "0" isValue: true
 -- loadArgs:not:*: formalArgOf:"@get 0"  isCompositeValueObj:false
 -- $ObjectCall:gen: "0"
 -- $Invocation:gen: "0"
 -- needorigin:"0" 
 -- needOrigin:E:"0"  E.ATd:"integer: value |    %basic 1, 32 |    %globals |     ..." 
 -- LoadOrign:no:loadOrigin: "value |    %basic 1, 32 |    %globals |    %public |  ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "0" E: "0" isValueAssign: false
 -- $ConstLiteral:loadArgs: "0"
 -- invoke:after:loadArgsOf:"0" 
 -- $ConstLiteral:invoke: "0"
 pushc 0
 -- invoke:after:E.invoke:"0" 
 -- loadArgs:after:Qgen:"@get 0" 
 -- formalArg:isPtn:"in get: var integer" :isBasicVal:true:valueObj:true
 -- :actArg:"0" :isBasicVal:true
 -- 0ObjectCall
 -- convDone:false
 -- end:loadArgs:NonVirt:"@get 0" 
 -- invoke:after:loadArgsOf:"@get 0" :Address:E:"@get 0"off:0 size:0 isFloa ...
 -- $ObjectInvocation_KeyWord:invoke: rec:"@get 0" "@get 0"
 -- >top:0 descNo:0 
 -- E.ATd: "" unique: false
 -- adr::Address:E:"@get 0"off:0 size:0 isFloat:False superAdj:0 isUnique:F ...
 -- $pattern:invoke: "@get:  |    %basic 117 |    in get: var integer |    out ch ..."
 xpushg inx 1 0 1
 -- OI:invoke:@get 0:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"@get 0" 
 -- loadArgs:after:Qgen:":= @get 0" 
 -- vAssign:fArg:"in V: var Value" 
 -- BINGO
 -- aaaa: in V: var Value
 -- end:loadArgs:NonVirt:":= @get 0" 
 -- invoke:after:loadArgsOf:":= @get 0" :Address:E:"V"off:2 size:0 isFloat: ...
 -- $ObjectInvocation_Binary:invoke: rec:"V" ":= @get 0"
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Address:E:"V"off:2 size:0 isFloat:False superAdj:0 isUnique:False  ...
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "V" from: ":= @get 0" 
 -- assign:dstDI :"out V: var integer" isUnitValueObj: false
 -- assign:arg: "@get 0" lab:"ObjectCall" UnitValObj :false ptn: false
 --  float: false DataItem:false arg.super:@get 0
 --  arg.super.ATd:"Invocation" "@get:  |    %basic 117 |    in get: var intege ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "pattern" 
 -- assign:simple value: 
 -- :Address:E:"V"off:2 size:0 isFloat:False superAdj:0 isUnique:False isVa ...
 -- store::Address:E:"V"off:2 size:0 isFloat:False superAdj:0 isUnique:Fals ...
 -- isValue:true isAdr:false descNo: 0 
 -- isFloat: false
 storeg 2 address:storeg
 -- OI:invoke::= @get 0:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= @get 0" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"length" 
 setThisStack 
 pushThis 
 -- $var:invoke: newOff:2 "out V: var integer"
 -- >:E=none
 pushg 2 V
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:1 vTopMax:2 rTop:2 rTopMax:2
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 30 :top:1 
 -- GenClass:put :varNo = 1 
 -- GenClass:put:true -> var.genDone

class put 30 0 6
 -- Store itemArgs
 pushThis 
 storeg 1 ch
 allocEventQ
 mvStack 
 -- $Signature:gen: "put"
 -- $val:gen: "in ch: val char"
 -- DI:isConst:true:isBasicValue:true:primNo:3 
 -- OGqual:char:OGqual.isBasicValue:true:OGqual.isValueObj:true
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%globals" 
 -- $Property:gen: "%globals"
 -- genclass:Qgen:stmt:"%basic 2" 
 -- $Property:gen: "%basic 2"
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"put" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:0  vTop:-1 vTopMax:0 rTop:2 rTopMax:2
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 31 :top:1 
 -- GenClass:do#S#31 :varNo = 1 
 -- GenClass:do#S#31:true -> var.genDone

class do#S#31 31 1 34
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"put(@get inx)" 
 -- $ObjectCall:gen: "put(@get inx)"
 -- $Invocation:gen: descNo: 30 top: 1 "put(@get inx)"
 -- needorigin:"put(@get inx)" 
 -- needOrigin:E:"put(@get inx)"  E.ATd:"put:  |    %globals |    %basic 2 |    i ..." 
 -- LoadOrign:no:loadOrigin: "%globals | %basic 2 | in ch: val char" 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "put(@get inx)" E: "put(@get inx)" isValueAssign: false
 -- $ObjectInvocation_Function:loadArgs:staticOff:0 "put(@get inx)"
 -- $pattern:loadArgs:E:"put(@get inx)":descNo:30:top:1 "put:  |    %globals |  ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"put(@get inx)" ActArg: "@get inx" isValue: false
 -- loadArgs:not:*: formalArgOf:"put(@get inx)"  isCompositeValueObj:false
 -- $ObjectCall:gen: "@get inx"
 -- $Invocation:gen: descNo: 0 top: 0 "@get inx"
 -- needorigin:"@get inx" 
 -- needOrigin:E:"@get inx"  E.ATd:"@get:  |    %basic 117 |    in get: var int ..." 
 -- computeAdr: "@get inx" 
 -- computeAdr:1 :rec:"none"  E:"@get inx" :Address:E:"none"off:0 size:0 is ...
 -- $ObjectInvocation_KeyWord:pushThis: "@get inx"
 pushThis 
 -- $ObjectInvocation_KeyWord:loadOrigin::on:3 "@get inx"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:3 
 -- goOrigin:do#S#31:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 do#S#31:origin
 -- goOrigin:A:2 
 -- goOrigin:@for::to:do#S#34:encOG.IS.newOriginOff:4 :newOriginOff:4 
 rpushg 4 @for::to:do#S#34:origin
 -- goOrigin:A:1 
 -- goOrigin:print:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 print:origin
 -- $ObjectInvocation_KeyWord:getAdr::superAdj:0:on:3 "@get inx"
 -- $pattern:getAdr: "@get:  |    %basic 117 |    in get: var integer |    out ch ..."
 -- :Address:E:"@get inx"off:0 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- computeAdr:isFirst::Address:E:"@get inx"off:0 size:0 isFloat:False supe ...
 -- computeAdr:isLast:E: "@get inx" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"@get inx"off:0 size:0 isFloa ...
 -- rec: "@get inx" E: "@get inx" isValueAssign: false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@get inx"
 -- $pattern:loadArgs:E:"@get inx":descNo:0:top:0 "@get:  |    %basic 117 |     ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"@get inx" ActArg: "inx" isValue: false
 -- loadArgs:not:*: formalArgOf:"@get inx"  isCompositeValueObj:false
 -- $ObjectCall:gen: "inx"
 -- $Invocation:gen: "inx"
 -- needorigin:"inx" 
 -- needOrigin:E:"inx"  E.ATd:"inx: var integer" 
 -- needOrigin:datItem:leave
 -- computeAdr: "inx" 
 -- computeAdr:1 :rec:"none"  E:"inx" :Address:E:"none"off:0 size:0 isFloat ...
 -- $ObjectInvocation_Unary:pushThis: "inx"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "inx"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:1 
 -- goOrigin:do#S#31:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 do#S#31:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:1 "inx"
 -- $var:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "inx: var intege ..."
 --  A::Address:E:"inx"off:0 size:0 isFloat:False superAdj:0 isUnique:False ...  ...i ...
 -- value_prim:false
 -- integer
 -- before:floatTest: 
 -- computeAdr:isFirst::Address:E:"inx"off:3 size:0 isFloat:False superAdj: ...
 -- computeAdr:isLast:E: "inx" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"inx"off:3 size:0 isFloat:Fal ...
 -- rec: "inx" E: "inx" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "inx"
 -- $var:loadArgs: "inx: var integer"
 -- invoke:after:loadArgsOf:"inx" :Address:E:"inx"off:3 size:0 isFloat:Fals ...
 -- $ObjectInvocation_Unary:invoke: rec:"inx" "inx"
 -- E.ATd: "inx" unique: false
 -- adr::Address:E:"inx"off:3 size:0 isFloat:False superAdj:0 isUnique:Fals ...
 -- $var:invoke: newOff:3 "inx: var integer"
 -- load::Address:E:"inx"off:3 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- isFloat: false
 pushg 3 
 -- OI:invoke:inx:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"inx" 
 -- loadArgs:after:Qgen:"@get inx" 
 -- formalArg:isPtn:"in get: var integer" :isBasicVal:true:valueObj:true
 -- :actArg:"inx" :isBasicVal:true
 -- inxObjectCall
 -- end:loadArgs:NonVirt:"@get inx" 
 -- invoke:after:loadArgsOf:"@get inx" :Address:E:"@get inx"off:0 size:0 is ...
 -- $ObjectInvocation_KeyWord:invoke: rec:"@get inx" "@get inx"
 -- >top:0 descNo:0 
 -- E.ATd: "" unique: false
 -- adr::Address:E:"@get inx"off:0 size:0 isFloat:False superAdj:0 isUnique ...
 -- $pattern:invoke: "@get:  |    %basic 117 |    in get: var integer |    out ch ..."
 xpushg inx 1 0 1
 -- OI:invoke:@get inx:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"@get inx" 
 -- loadArgs:after:Qgen:"put(@get inx)" 
 -- formalArg:isPtn:"in ch: val char" :isBasicVal:true:valueObj:true
 -- :actArg:"@get inx" :isBasicVal:true
 -- @get inxObjectCall
 -- end:loadArgs:NonVirt:"put(@get inx)" 
 -- invoke:after:loadArgsOf:"put(@get inx)" 
 -- $ObjectInvocation_Function:invoke: rec:"put(@get inx)" "put(@get inx)"
 -- >top:1 descNo:30 
 -- $pattern:invoke: "put:  |    %globals |    %basic 2 |    in ch: val char"
 %put 2
 -- OI:invoke:put(@get inx):unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"put(@get inx)" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:0  vTop:1 vTopMax:1 rTop:2 rTopMax:2
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 34 :top:1 
 -- GenClass:@for::to:do#S#34 :varNo = 1 
 -- GenClass:@for::to:do#S#34:true -> var.genDone

class @for::to:do#S#34 34 4 33
 -- Store itemArgs
 tstOriginIsNone 
 rstore 4 origin
 -- super @for::to:do
 -- vdt:b
 --  1:86 2:0 3:0 4:0
 -- vdt:c:innerInx: 2  descNo: 34 
 -- vdtAdd: inx=2 descInx=34
 -- Super:sig none
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@for 1 :to length  | :do  ..."
 -- $pattern:loadArgs:E:"@for 1 :to length  | :do  |    put(@get inx)":descNo:2 ...
 -- isValueAssign: false
 -- loadArgs:NonVirt:"@for 1 :to length  | :do  |    put(@get inx)" ActArg: ..."1 ..." i ...true
 -- loadArgs:not:*: formalArgOf:"@for 1 :to length  | :do  |    put(@get inx)"   ...false
 -- $ObjectCall:gen: "1"
 -- $Invocation:gen: "1"
 -- needorigin:"1" 
 -- needOrigin:E:"1"  E.ATd:"integer: value |    %basic 1, 32 |    %globals |     ..." 
 -- LoadOrign:no:loadOrigin: "value |    %basic 1, 32 |    %globals |    %public |  ..." 
 -- IV:after:computeAdr:superAdj:4 
 -- rec: "1" E: "1" isValueAssign: false
 -- $ConstLiteral:loadArgs: "1"
 -- invoke:after:loadArgsOf:"1" 
 -- $ConstLiteral:invoke: "1"
 pushc 1
 -- invoke:after:E.invoke:"1" 
 -- loadArgs:after:Qgen:"@for 1 :to length  | :do  |    put(@get inx)" 
 -- formalArg:isPtn:"in for: var integer" :isBasicVal:true:valueObj:true
 -- :actArg:"1" :isBasicVal:true
 -- 1ObjectCall
 -- convDone:false
 -- end:loadArgs:NonVirt:"@for 1 :to length  | :do  |    put(@get inx)" 
 -- loadArgs:NonVirt:"@for 1 :to length  | :do  |    put(@get inx)" ActArg: ..."l ..." i ...false
 -- loadArgs:not:*: formalArgOf:"@for 1 :to length  | :do  |    put(@get inx)"   ...false
 -- $ObjectCall:gen: "length"
 -- $Invocation:gen: descNo: 29 top: 1 "length"
 -- needorigin:"length" 
 -- needOrigin:E:"length"  E.ATd:"length:  |    out V: var integer |    V := @g ..." 
 -- computeAdr: "length" 
 -- computeAdr:1 :rec:"none"  E:"length" :Address:E:"none"off:0 size:0 isFl ...
 -- $ObjectInvocation_Unary:pushThis: "length"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "length"
 -- AdjustOrigin:originOff: 4
 rpushg 4 origin
 -- goOrigin:A:1 
 -- goOrigin:print:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 print:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:4:on:1 "length"
 -- $pattern:getAdr: "length:  |    out V: var integer |    V := @get 0"
 -- :Address:E:"length"off:0 size:0 isFloat:False superAdj:4 isUnique:False ...
 -- computeAdr:isFirst::Address:E:"length"off:0 size:0 isFloat:False superA ...
 -- computeAdr:isLast:E: "length" 
 -- IV:after:computeAdr:superAdj:4 :Address:E:"length"off:0 size:0 isFloat: ...
 -- rec: "length" E: "length" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "length"
 -- $pattern:loadArgs:E:"length":descNo:29:top:1 "length:  |    out V: var in ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"length" :Address:E:"length"off:0 size:0 isFloa ...
 -- $ObjectInvocation_Unary:invoke: rec:"length" "length"
 -- >top:1 descNo:29 
 -- E.ATd: "length" unique: false
 -- adr::Address:E:"length"off:0 size:0 isFloat:False superAdj:4 isUnique:F ...
 -- $pattern:invoke: "length:  |    out V: var integer |    V := @get 0"
 -- Pattern:invoke:descNo:29  top:1  rec:"length" 
 -- ptn:invoke::isValObj:false:rtnValObj:true:"length:  |    out V: var integ ..." 
 -- rec=E:true:rec:"length" 
 -- kuk:pattern:rec.ATd:"length:  |    out V: var integer |    V := @get 0" 
 invoke length 29 0 0
 -- useRtnVal:true:isVal:false:rtnValObj:true:rec=E:true"length" 
 -- OI:invoke:length:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"length" 
 -- loadArgs:after:Qgen:"@for 1 :to length  | :do  |    put(@get inx)" 
 -- formalArg:isPtn:"in to: var integer" :isBasicVal:true:valueObj:true
 -- :actArg:"length" :isBasicVal:true
 -- lengthObjectCall
 -- end:loadArgs:NonVirt:"@for 1 :to length  | :do  |    put(@get inx)" 
 toSuper 28
 rtnInner
DO:
 mvStack 
 L1:
 L2:
 rtnInner
 end OSDV:0 objSize:4 isIndexed:0  vTop:1 vTopMax:1 rTop:0 rTopMax:0
 -- Handle VB: "" E: "@for 1 :to length  | :do  |    put(@get inx)" 
 -- Virtual
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 33 :top:1 
 -- GenClass:print :varNo = 1 
 -- GenClass:print:true -> var.genDone

class print 33 1 15
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $Signature:gen: "print"
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"@for 1 :to length  | :do  |    put(@get inx)" 
 -- $ObjectGenerator:gen:"@for::to:do#S#34"IS.isempty! staticOff: 0 descNo: ...
 -- OG:gen:super:"" superDescNo:28 super.OG.top:1 
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 34  @for::to:do#S#34
 invoke @for::to:do#S#34 34 0 1
 rpop
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"print" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 35 :top:1 
 -- GenClass:print :varNo = 1 
 -- GenClass:print:true -> var.genDone

class print 35 1 17
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $Signature:gen: "print"
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"S.print" 
 -- $ObjectCall:gen: "S.print"
 -- $Invocation:gen: descNo: 33 top: 1 "S.print"
 -- needorigin:"S.print" 
 -- needOrigin:E:"print"  E.ATd:"print:  |    @for 1 :to length  |    :do  |      ..." 
 -- computeAdr: "S.print" 
 -- computeAdr:1 :rec:"none"  E:"S" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "S"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "S"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:1 
 -- goOrigin:print:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 print:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:1 "S"
 -- $ref:getAdr:,newOff:2,isValue:"False",A.isValue:"False" "in S: ref Stri ..."
 --  A::Address:E:"S"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...i ...
 -- value_prim:false
 -- computeAdr:isFirst::Address:E:"none"off:2 size:0 isFloat:False superAdj ...
 -- computeAdr:2 :rec:"S"  E:"print" :Address:E:"none"off:2 size:0 isFloat: ...
 -- E:notAssign:print
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "print"
 -- $pattern:getAdr: "print:  |    @for 1 :to length  |    :do  |       put(@get  ..."
 -- :Address:E:"print"off:2 size:0 isFloat:False superAdj:0 isUnique:False  ...
 -- ptn.ssUnitValueObj:false isFloat:false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "S"
 -- $ref:loadArgs: "in S: ref String.String"
 -- $ObjectInvocation_Unary:invoke: rec:"S" "S"
 -- E.ATd: "print" unique: false
 -- adr::Address:E:"print"off:2 size:0 isFloat:False superAdj:0 isUnique:Fa ...
 -- $ref:invoke: newOff:2 "in S: ref String.String"
 -- >Object:unique:false
 -- loadAdr::Address:E:"print"off:2 size:0 isFloat:False superAdj:0 isUniqu ...
 rpushg 2 
 -- OI:invoke:S:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "print" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"print"off:2 size:0 isFloat:F ...
 -- rec: "S" E: "print" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "print"
 -- $pattern:loadArgs:E:"print":descNo:33:top:1 "print:  |    @for 1 :to leng ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"print" :Address:E:"print"off:2 size:0 isFloat: ...
 -- $ObjectInvocation_Unary:invoke: rec:"S" "print"
 -- >top:1 descNo:33 
 -- E.ATd: "print" unique: false
 -- adr::Address:E:"print"off:2 size:0 isFloat:False superAdj:0 isUnique:Fa ...
 -- $pattern:invoke: "print:  |    @for 1 :to length  |    :do  |       put(@get  ..."
 -- Pattern:invoke:descNo:33  top:1  rec:"S" 
 -- ComputeVariantX
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- <>var
 -- ptn:invoke::isValObj:false:rtnValObj:false:"print:  |    @for 1 :to lengt ..." 
 -- rec=E:false:rec:"S" 
 -- kuk:pattern:rec.ATd:"in S: ref String.String" 
 invoke print 33 0 0
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:false"S" 
 rpop
 -- OI:invoke:print:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"print" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"print" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 38 :top:1 
 -- GenClass:scan#S#38 :varNo = 1 
 -- GenClass:scan#S#38:true -> var.genDone

class scan#S#38 38 4 37
 -- Store itemArgs
 tstOriginIsNone 
 rstore 4 origin
 -- super scan
 -- vdt:b
 --  1:0 2:0 3:0 4:0
 -- vdt:c:innerInx: 1  descNo: 38 
 -- vdtAdd: inx=1 descInx=38
 -- computeAdr: "XL.scan" 
 -- computeAdr:1 :rec:"none"  E:"XL" :Address:E:"none"off:0 size:0 isFloat: ...
 -- $ObjectInvocation_Unary:pushThis: "XL"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "XL"
 -- AdjustOrigin:originOff: 4
 rpushg 4 origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:4:on:0 "XL"
 -- $ref:getAdr:,newOff:2,isValue:"False",A.isValue:"False" "XL: ref List"
 --  A::Address:E:"XL"off:0 size:0 isFloat:False superAdj:4 isUnique:False  ...  ...X ...
 -- value_prim:false
 -- computeAdr:isFirst::Address:E:"none"off:2 size:0 isFloat:False superAdj ...
 -- computeAdr:2 :rec:"XL"  E:"scan" :Address:E:"none"off:2 size:0 isFloat: ...
 -- E:notAssign:scan
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "scan"
 -- $pattern:getAdr: "scan:  |    current: ref Object |    L: ref List |    L :=  ..."
 -- :Address:E:"scan"off:2 size:0 isFloat:False superAdj:0 isUnique:False i ...
 -- ptn.ssUnitValueObj:false isFloat:false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "XL"
 -- $ref:loadArgs: "XL: ref List"
 -- $ObjectInvocation_Unary:invoke: rec:"XL" "XL"
 -- E.ATd: "scan" unique: false
 -- adr::Address:E:"scan"off:2 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- $ref:invoke: newOff:2 "XL: ref List"
 -- >Object:unique:false
 -- loadAdr::Address:E:"scan"off:2 size:0 isFloat:False superAdj:0 isUnique ...
 rpushg 2 
 -- OI:invoke:XL:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "scan" 
 -- genClass:after:ComputeAdr:"scan" :Address:E:"scan"off:2 size:0 isFloat: ...
 -- Super:sig none
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "scan"
 -- $pattern:loadArgs:E:"scan":descNo:24:top:1 "scan:  |    current: ref Obje ..."
 -- isValueAssign: false
 toSuper 24
 -- $ref:gen: "F: ref Foo"
 -- DI:isConst:false:isBasicValue:false:primNo:0 
 -- OGqual:foo:OGqual.isBasicValue:false:OGqual.isValueObj:false
 rtnInner
DO:
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"F := current" 
 -- $ObjectCall:gen: "F := current"
 -- $Invocation:gen: descNo: 14 top: 1 "F := current"
 -- needorigin:"F := current" 
 -- needOrigin:E:":= current"  E.ATd:":= :  |    %basic 8 |    in V: ref Value" 
 -- computeAdr: "F := current" 
 -- computeAdr:1 :rec:"none"  E:"F" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "F"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "F"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "F"
 -- $ref:getAdr:,newOff:5,isValue:"False",A.isValue:"False" "F: ref Foo"
 --  A::Address:E:"F"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...F ...
 -- value_prim:false
 -- computeAdr:isFirst::Address:E:"none"off:5 size:0 isFloat:False superAdj ...
 -- computeAdr:2 :rec:"F"  E:":= current" :Address:E:"none"off:5 size:0 isF ...
 -- computeAdr:isAssign:rec: "F"  E:":= current" 
 -- :Address:E:"none"off:5 size:0 isFloat:False superAdj:0 isUnique:False i ...
 -- computeAdr:isLast:E: ":= current" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"none"off:5 size:0 isFloat:Fa ...
 -- rec: "F" E: ":= current" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:5 ":= current"
 -- $pattern:loadArgs:E:":= current":descNo:14:top:1 ":= :  |    %basic 8 |     ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= current" ActArg: "current" isValue: false
 -- $ObjectCall:gen: "current"
 -- $Invocation:gen: "current"
 -- needorigin:"current" 
 -- needOrigin:E:"current"  E.ATd:"current: ref Object" 
 -- needOrigin:datItem:leave
 -- computeAdr: "current" 
 -- computeAdr:1 :rec:"none"  E:"current" :Address:E:"none"off:0 size:0 isF ...
 -- $ObjectInvocation_Unary:pushThis: "current"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "current"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "current"
 -- $ref:getAdr:,newOff:2,isValue:"False",A.isValue:"False" "current: ref O ..."
 --  A::Address:E:"current"off:0 size:0 isFloat:False superAdj:0 isUnique:F ...  ...c ...
 -- value_prim:false
 -- computeAdr:isFirst::Address:E:"none"off:2 size:0 isFloat:False superAdj ...
 -- computeAdr:isLast:E: "current" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"none"off:2 size:0 isFloat:Fa ...
 -- rec: "current" E: "current" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "current"
 -- $ref:loadArgs: "current: ref Object"
 -- invoke:after:loadArgsOf:"current" :Address:E:"none"off:2 size:0 isFloat ...
 -- $ObjectInvocation_Unary:invoke: rec:"current" "current"
 -- E.ATd: "current" unique: false
 -- adr::Address:E:"none"off:2 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- $ref:invoke: newOff:2 "current: ref Object"
 -- >Object:unique:false
 -- load::Address:E:"none"off:2 size:0 isFloat:False superAdj:0 isUnique:Fa ...
 rpushg 2 
 -- OI:invoke:current:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"current" 
 -- loadArgs:after:Qgen:":= current" 
 -- vAssign:fArg:"in V: ref Value" 
 -- end:loadArgs:NonVirt:":= current" 
 -- invoke:after:loadArgsOf:":= current" :Address:E:"none"off:5 size:0 isFl ...
 -- $ObjectInvocation_Binary:invoke: rec:"F" ":= current"
 -- >top:1 descNo:14 
 -- E.ATd: ":= " unique: false
 -- adr::Address:E:"none"off:5 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: ref Value"
 -- AssignPtn:invoke:rec: "F" from: ":= current" 
 -- assign:dstDI :"F: ref Foo" isUnitValueObj: false
 -- assign:arg: "current" lab:"ObjectCall" UnitValObj :false ptn: false
 --  float: false DataItem:false arg.super:current
 --  arg.super.ATd:"Invocation" "current: ref Object" 
 --  arg.super.ATd.isDataItem:true arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "ref" 
 -- assign:reference: "F" 
 -- :Address:E:"none"off:5 size:0 isFloat:False superAdj:0 isUnique:False i ...
 -- store::Address:E:"none"off:5 size:0 isFloat:False superAdj:0 isUnique:F ...
 -- isValue:false isAdr:false descNo: 0 
 rswap
 rstoreg 5 
 -- OI:invoke::= current:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= current" 
 -- genclass:Qgen:stmt:"F.print" 
 -- $ObjectCall:gen: "F.print"
 -- $Invocation:gen: descNo: 35 top: 1 "F.print"
 -- needorigin:"F.print" 
 -- needOrigin:E:"print"  E.ATd:"print:  |    S.print" 
 -- computeAdr: "F.print" 
 -- computeAdr:1 :rec:"none"  E:"F" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "F"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "F"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "F"
 -- $ref:getAdr:,newOff:5,isValue:"False",A.isValue:"False" "F: ref Foo"
 --  A::Address:E:"F"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...F ...
 -- value_prim:false
 -- computeAdr:isFirst::Address:E:"none"off:5 size:0 isFloat:False superAdj ...
 -- computeAdr:2 :rec:"F"  E:"print" :Address:E:"none"off:5 size:0 isFloat: ...
 -- E:notAssign:print
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "print"
 -- $pattern:getAdr: "print:  |    S.print"
 -- :Address:E:"print"off:5 size:0 isFloat:False superAdj:0 isUnique:False  ...
 -- ptn.ssUnitValueObj:false isFloat:false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "F"
 -- $ref:loadArgs: "F: ref Foo"
 -- $ObjectInvocation_Unary:invoke: rec:"F" "F"
 -- E.ATd: "print" unique: false
 -- adr::Address:E:"print"off:5 size:0 isFloat:False superAdj:0 isUnique:Fa ...
 -- $ref:invoke: newOff:5 "F: ref Foo"
 -- >Object:unique:false
 -- loadAdr::Address:E:"print"off:5 size:0 isFloat:False superAdj:0 isUniqu ...
 rpushg 5 
 -- OI:invoke:F:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "print" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"print"off:5 size:0 isFloat:F ...
 -- rec: "F" E: "print" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "print"
 -- $pattern:loadArgs:E:"print":descNo:35:top:1 "print:  |    S.print"
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"print" :Address:E:"print"off:5 size:0 isFloat: ...
 -- $ObjectInvocation_Unary:invoke: rec:"F" "print"
 -- >top:1 descNo:35 
 -- E.ATd: "print" unique: false
 -- adr::Address:E:"print"off:5 size:0 isFloat:False superAdj:0 isUnique:Fa ...
 -- $pattern:invoke: "print:  |    S.print"
 -- Pattern:invoke:descNo:35  top:1  rec:"F" 
 -- ComputeVariantX
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- <>var
 -- ptn:invoke::isValObj:false:rtnValObj:false:"print:  |    S.print" 
 -- rec=E:false:rec:"F" 
 -- kuk:Items:rec.ATd:"F: ref Foo" 
 invoke print 35 0 0
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:false"F" 
 rpop
 -- OI:invoke:print:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"print" 
 L2:
 rtnInner
 end OSDV:0 objSize:5 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:2
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 37 :top:1 
 -- GenClass:List :varNo = 1 
 -- GenClass:List:true -> var.genDone

class List 37 1 39
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $ref:gen: "XL: ref List"
 -- DI:isConst:false:isBasicValue:false:primNo:0 
 -- OGqual:List:OGqual.isBasicValue:false:OGqual.isValueObj:false
 rtnEventQ 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"XL := List(foo("Hello "),list(foo("World\n"),none)) ..." 
 -- $ObjectCall:gen: "XL := List(foo("Hello "),list(foo("World\n"),none))"
 -- $Invocation:gen: descNo: 14 top: 1 "XL := List(foo("Hello "),list(foo(" ...
 -- needorigin:"XL := List(foo("Hello "),list(foo("World\n"),none))" 
 -- needOrigin:E:":= List(foo("Hello "),list(foo("World\n"),none))"  E.ATd: ...": ..." 
 -- computeAdr: "XL := List(foo("Hello "),list(foo("World\n"),none))" 
 -- computeAdr:1 :rec:"none"  E:"XL" :Address:E:"none"off:0 size:0 isFloat: ...
 -- $ObjectInvocation_Unary:pushThis: "XL"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "XL"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "XL"
 -- $ref:getAdr:,newOff:2,isValue:"False",A.isValue:"False" "XL: ref List"
 --  A::Address:E:"XL"off:0 size:0 isFloat:False superAdj:0 isUnique:False  ...  ...X ...
 -- value_prim:false
 -- computeAdr:isFirst::Address:E:"none"off:2 size:0 isFloat:False superAdj ...
 -- computeAdr:2 :rec:"XL"  E:":= List(foo("Hello "),list(foo("World\n"),no ..." : ...
 -- computeAdr:isAssign:rec: "XL"  E:":= List(foo("Hello "),list(foo("World ..."" 
 -- :Address:E:"none"off:2 size:0 isFloat:False superAdj:0 isUnique:False i ...
 -- computeAdr:isLast:E: ":= List(foo("Hello "),list(foo("World\n"),none))" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"none"off:2 size:0 isFloat:Fa ...
 -- rec: "XL" E: ":= List(foo("Hello "),list(foo("World\n"),none))" isValue ...true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:2 ":= List(foo("Hello "),li ..."
 -- $pattern:loadArgs:E:":= List(foo("Hello "),list(foo("World\n"),none))": ...
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= List(foo("Hello "),list(foo("World\n"),none))" Act ..."L ..." i ...false
 -- $ObjectCall:gen: "List(foo("Hello "),list(foo("World\n"),none))"
 -- $Invocation:gen: descNo: 13 top: 1 "List(foo("Hello "),list(foo("World\ ...
 -- needorigin:"List(foo("Hello "),list(foo("World\n"),none))" 
 -- needOrigin:E:"List(foo("Hello "),list(foo("World\n"),none))"  E.ATd:"Li ..." 
 -- computeAdr: "List(foo("Hello "),list(foo("World\n"),none))" 
 -- computeAdr:1 :rec:"none"  E:"List(foo("Hello "),list(foo("World\n"),non ..." : ...
 -- $ObjectInvocation_Function:pushThis: "List(foo("Hello "),list(foo("Worl ...
 pushThis 
 -- $ObjectInvocation_Function:loadOrigin::on:0 "List(foo("Hello "),list(fo ..."
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Function:getAdr::superAdj:0:on:0 "List(foo("Hello "), ..."
 -- $pattern:getAdr: "List:  |    in head: ref Object |    in tail: ref List |    ..."
 -- :Address:E:"List(foo("Hello "),list(foo("World\n"),none))"off:0 size:0  ...
 -- computeAdr:isFirst::Address:E:"List(foo("Hello "),list(foo("World\n"),n ..."
 -- computeAdr:isLast:E: "List(foo("Hello "),list(foo("World\n"),none))" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"List(foo("Hello "),list(foo( ..."
 -- rec: "List(foo("Hello "),list(foo("World\n"),none))" E: "List(foo("Hell ..."" i ...false
 -- $ObjectInvocation_Function:loadArgs:staticOff:0 "List(foo("Hello "),lis ..."
 -- $pattern:loadArgs:E:"List(foo("Hello "),list(foo("World\n"),none))":des ...
 -- isValueAssign: false
 -- loadArgs:NonVirt:"List(foo("Hello "),list(foo("World\n"),none))" ActArg ..."f ..." i ...false
 -- loadArgs:not:*: formalArgOf:"List(foo("Hello "),list(foo("World\n"),non ..."   ...false
 -- $ObjectCall:gen: "foo("Hello ")"
 -- $Invocation:gen: descNo: 17 top: 1 "foo("Hello ")"
 -- needorigin:"foo("Hello ")" 
 -- needOrigin:E:"foo("Hello ")"  E.ATd:"foo:  |    in S: ref String.String |   ..." 
 -- computeAdr: "foo("Hello ")" 
 -- computeAdr:1 :rec:"none"  E:"foo("Hello ")" :Address:E:"none"off:0 size ...
 -- $ObjectInvocation_Function:pushThis: "foo("Hello ")"
 pushThis 
 -- $ObjectInvocation_Function:loadOrigin::on:0 "foo("Hello ")"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Function:getAdr::superAdj:0:on:0 "foo("Hello ")"
 -- $pattern:getAdr: "foo:  |    in S: ref String.String |    print:  |       S.p ..."
 -- :Address:E:"foo("Hello ")"off:0 size:0 isFloat:False superAdj:0 isUniqu ...
 -- computeAdr:isFirst::Address:E:"foo("Hello ")"off:0 size:0 isFloat:False ...
 -- computeAdr:isLast:E: "foo("Hello ")" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"foo("Hello ")"off:0 size:0 i ...
 -- rec: "foo("Hello ")" E: "foo("Hello ")" isValueAssign: false
 -- $ObjectInvocation_Function:loadArgs:staticOff:0 "foo("Hello ")"
 -- $pattern:loadArgs:E:"foo("Hello ")":descNo:17:top:1 "foo:  |    in S: ref ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"foo("Hello ")" ActArg: ""Hello "" isValue: false
 -- loadArgs:not:*: formalArgOf:"foo("Hello ")"  isCompositeValueObj:false
 -- $ObjectCall:gen: ""Hello ""
 -- $Invocation:gen: ""Hello ""
 -- needorigin:""Hello "" 
 -- needOrigin:E:""Hello ""  E.ATd:"String:  |    %OSDvisibility disguised |    ..." 
 -- computeAdr: ""Hello "" 
 -- computeAdr:1 :rec:"none"  E:""Hello "" :Address:E:"none"off:0 size:0 is ...
 -- $String::pushThis: ""Hello ""
 -- $String::loadOrigin: ""Hello ""
 -- StringObj:loadOrigin:"Hello "
 -- $String::getAdr: ""Hello ""
 -- computeAdr:isFirst::Address:E:""Hello ""off:0 size:0 isFloat:False supe ...
 -- computeAdr:isLast:E: ""Hello "" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:""Hello ""off:0 size:0 isFloa ...
 -- rec: ""Hello "" E: ""Hello "" isValueAssign: false
 -- $String::loadArgs: ""Hello ""
 -- invoke:after:loadArgsOf:""Hello "" :Address:E:""Hello ""off:0 size:0 is ...
 -- $String::invoke: ""Hello ""
 -- Pattern:markForCodeGen:+ :  |    in S: ref String |    out V: ref String |    ...
 -- OG:markForCodeGen:in S: ref String | out V: ref String | L: var integer | L : ...
 -- OG:markIS:in S: ref String | out V: ref String | L: var integer | L := Length ...
 -- items:markForCodeGen:in S: ref String | out V: ref String | L: var integer |  ...
 -- DataItem:markForCodeGen:S:descNo:0 :OG.primNo:5 
 -- ObjCall:markSuper:String
 -- Invocation:markForCodeGen:String
 -- ObjectInvocation:markForCodeGen:String ATd:String:  |    %OSDvisibility d ...
 -- Pattern:markForCodeGen:String:  |    %OSDvisibility disguised |    %basic 5 ...
 -- DataItem:markForCodeGen:V:descNo:0 :OG.primNo:5 
 -- ObjCall:markSuper:String
 -- Invocation:markForCodeGen:String
 -- ObjectInvocation:markForCodeGen:String ATd:String:  |    %OSDvisibility d ...
 -- Pattern:markForCodeGen:String:  |    %OSDvisibility disguised |    %basic 5 ...
 -- DataItem:markForCodeGen:L:descNo:0 :OG.primNo:1 
 -- ObjCall:markSuper:integer
 -- Invocation:markForCodeGen:integer
 -- ObjectInvocation:markForCodeGen:integer ATd:integer: value |    %basic 1, ...
 -- Pattern:markForCodeGen:integer: value |    %basic 1, 32 |    %globals |    %p ...
 -- markItem:"L := Length" ObjectCall
 -- ObjCall:markSuper:L := Length
 -- Invocation:markForCodeGen:L := Length
 -- ObjectInvocation:markForCodeGen:L ATd:L: var integer
 -- DataItem:markForCodeGen:L:descNo:0 :OG.primNo:1 
 -- ObjectInvocation:markForCodeGen::= Length ATd::= :  |    %basic 8 |    in V ...
 -- Pattern:markForCodeGen::= :  |    %basic 8 |    in V: var Value
 -- arg: Length
 -- ObjCall:markSuper:Length
 -- Invocation:markForCodeGen:Length
 -- ObjectInvocation:markForCodeGen:Length ATd:length:  |    out V: var integ ...
 -- Pattern:markForCodeGen:length:  |    out V: var integer |    V := @get 0
 -- markItem:"doplus | -- V: obj Indexed(Length + S.length) |  | -- V := T[1:leng ..." O ...
 -- ObjCall:markSuper:doplus | -- V: obj Indexed(Length + S.length) |  | -- V :=  ...
 -- Invocation:markForCodeGen:doplus | -- V: obj Indexed(Length + S.length) |  |  ...
 -- ObjectInvocation:markForCodeGen:doplus ATd:doplus:  |    e: var integer |   ...
 -- Pattern:markForCodeGen:doplus:  |    e: var integer |    i: var integer |     ...
 -- OG:markForCodeGen:e: var integer | i: var integer | T: obj Indexed(L + S.le ...
 -- OG:markIS:e: var integer | i: var integer | T: obj Indexed(L + S.length,Int ...
 -- items:markForCodeGen:e: var integer | i: var integer | T: obj Indexed(L + S ...
 -- DataItem:markForCodeGen:e:descNo:0 :OG.primNo:1 
 -- ObjCall:markSuper:integer
 -- Invocation:markForCodeGen:integer
 -- ObjectInvocation:markForCodeGen:integer ATd:integer: value |    %basic 1, ...
 -- Pattern:markForCodeGen:integer: value |    %basic 1, 32 |    %globals |    %p ...
 -- DataItem:markForCodeGen:i:descNo:0 :OG.primNo:1 
 -- ObjCall:markSuper:integer
 -- Invocation:markForCodeGen:integer
 -- ObjectInvocation:markForCodeGen:integer ATd:integer: value |    %basic 1, ...
 -- Pattern:markForCodeGen:integer: value |    %basic 1, 32 |    %globals |    %p ...
 -- DataItem:markForCodeGen:T:descNo:0 :OG.primNo:114 
 -- markItem:"@for 1 :to L  | :do  |    e := @get inx |    T.@put e :at inx" O ...
 -- OG:markForCodeGen:@for 1 :to L  | :do  |    e := @get inx |    T.@put e :at i ...
 -- OG:markSuper:@for 1 :to L  | :do  |    e := @get inx |    T.@put e :at inx
 -- Invocation:markForCodeGen:@for 1 :to L  | :do  |    e := @get inx |    T.@put ...
 -- ObjectInvocation:markForCodeGen:@for 1 :to L  | :do  |    e := @get inx |     ...  ...@ ...
 -- Pattern:markForCodeGen:@for:  |    %globals inSub |    in for: var integer |  ...
 -- arg: 1
 -- ObjCall:markSuper:1
 -- Invocation:markForCodeGen:1
 -- arg: L
 -- arg: e := @get inx | T.@put e :at inx
 -- OG:markForCodeGen:e := @get inx | T.@put e :at inx
 -- OG:markIS:e := @get inx | T.@put e :at inx
 -- items:markForCodeGen:e := @get inx | T.@put e :at inx
 -- markItem:"e := @get inx" ObjectCall
 -- ObjCall:markSuper:e := @get inx
 -- Invocation:markForCodeGen:e := @get inx
 -- ObjectInvocation:markForCodeGen:e ATd:e: var integer
 -- DataItem:markForCodeGen:e:descNo:0 :OG.primNo:1 
 -- ObjectInvocation:markForCodeGen::= @get inx ATd::= :  |    %basic 8 |    in ...
 -- Pattern:markForCodeGen::= :  |    %basic 8 |    in V: var Value
 -- arg: @get inx
 -- markItem:"T.@put e :at inx" ObjectCall
 -- ComputeVariant:A:do#S#0
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:do
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:e := @get inx | T.@put e :at inx
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:do#S#0:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:87 IS.newDescNo:87 :objSize:0 varNo:1 e := @g ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super::super:size:2 :noGlobalsInSuper:false
 -- Items:Qalloc:super:B:objSize:2 originOff:2 
 -- IS.newDescNo:87 IS.objSize:2 :e := @get inx | T.@put e :at inx
 -- computeVariant:newDescNo:87 IS:e := @get inx | T.@put e :at inx
 -- ComputeVariant:B:do#S#87
 -- ObjTmpStack:add::genDone:false e := @get inx | T.@put e :at inx
 -- OG:markIS:@for 1 :to L  | :do  |    e := @get inx |    T.@put e :at inx
 -- items:markForCodeGen:
 -- ComputeVariant:A:@for::to:do#S#0
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:@for::to:do
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:@for 1 :to L  | :do  |    e := @get inx |    T.@put e :at inx
 -- :varNo:1 :allocDone:false
 -- OG:super: @for:  |    %globals inSub |    in for: var integer |    in to: var ...
 -- :OG:Qalloc:B:@for::to:do#S#0:newDescNo:0 :objSize:3 
 -- OG:isObjectDesc:NewDescNo:88 IS.newDescNo:88 :objSize:3 varNo:1 
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super:@for 1 :to L  | :do  |    e := @get inx |    T.@put e :at  ...: ...3 : ...true
 -- Items:Qalloc:super:B:objSize:4 originOff:4 
 -- IS.newDescNo:88 IS.objSize:3 :
 -- computeVariant:newDescNo:88 IS:
 -- ComputeVariant:B:@for::to:do#S#88
 -- ObjTmpStack:add::genDone:false @for 1 :to L  | :do  |    e := @get inx |    T ...
 -- markItem:"@for 1 :to S.length  | :do  |    e := S.@get inx |    i := L + inx |  ..." O ...
 -- OG:markForCodeGen:@for 1 :to S.length  | :do  |    e := S.@get inx |    i :=  ...
 -- OG:markSuper:@for 1 :to S.length  | :do  |    e := S.@get inx |    i := L + i ...
 -- Invocation:markForCodeGen:@for 1 :to S.length  | :do  |    e := S.@get inx |  ...
 -- ObjectInvocation:markForCodeGen:@for 1 :to S.length  | :do  |    e := S.@ge ...  ...@ ...
 -- Pattern:markForCodeGen:@for:  |    %globals inSub |    in for: var integer |  ...
 -- arg: 1
 -- ObjCall:markSuper:1
 -- Invocation:markForCodeGen:1
 -- arg: S.length
 -- ObjCall:markSuper:S.length
 -- Invocation:markForCodeGen:S.length
 -- ObjectInvocation:markForCodeGen:S ATd:in S: ref String
 -- DataItem:markForCodeGen:S:descNo:0 :OG.primNo:5 
 -- ObjectInvocation:markForCodeGen:length ATd:length:  |    out V: var integ ...
 -- Pattern:markForCodeGen:length:  |    out V: var integer |    V := @get 0
 -- arg: e := S.@get inx | i := L + inx | T.@put e :at i
 -- OG:markForCodeGen:e := S.@get inx | i := L + inx | T.@put e :at i
 -- OG:markIS:e := S.@get inx | i := L + inx | T.@put e :at i
 -- items:markForCodeGen:e := S.@get inx | i := L + inx | T.@put e :at i
 -- markItem:"e := S.@get inx" ObjectCall
 -- ObjCall:markSuper:e := S.@get inx
 -- Invocation:markForCodeGen:e := S.@get inx
 -- ObjectInvocation:markForCodeGen:e ATd:e: var integer
 -- DataItem:markForCodeGen:e:descNo:0 :OG.primNo:1 
 -- ObjectInvocation:markForCodeGen::= S.@get inx ATd::= :  |    %basic 8 |     ...
 -- Pattern:markForCodeGen::= :  |    %basic 8 |    in V: var Value
 -- arg: S.@get inx
 -- markItem:"i := L + inx" ObjectCall
 -- ObjCall:markSuper:i := L + inx
 -- Invocation:markForCodeGen:i := L + inx
 -- ObjectInvocation:markForCodeGen:i ATd:i: var integer
 -- DataItem:markForCodeGen:i:descNo:0 :OG.primNo:1 
 -- ObjectInvocation:markForCodeGen::= L + inx ATd::= :  |    %basic 8 |    in  ...
 -- Pattern:markForCodeGen::= :  |    %basic 8 |    in V: var Value
 -- arg: L + inx
 -- ObjCall:markSuper:L + inx
 -- Invocation:markForCodeGen:L + inx
 -- ObjectInvocation:markForCodeGen:L ATd:L: var integer
 -- DataItem:markForCodeGen:L:descNo:0 :OG.primNo:1 
 -- ObjectInvocation:markForCodeGen:+ inx ATd:+ :  |    %basic 61 |    in V: va ...
 -- Pattern:markForCodeGen:+ :  |    %basic 61 |    in V: var integer |    out R: ...
 -- arg: inx
 -- markItem:"T.@put e :at i" ObjectCall
 -- ComputeVariant:A:do#S#0
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:do
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:e := S.@get inx | i := L + inx | T.@put e :at i
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:do#S#0:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:89 IS.newDescNo:89 :objSize:0 varNo:1 e := S. ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super::super:size:2 :noGlobalsInSuper:false
 -- Items:Qalloc:super:B:objSize:2 originOff:2 
 -- IS.newDescNo:89 IS.objSize:2 :e := S.@get inx | i := L + inx | T.@put e :at ...
 -- computeVariant:newDescNo:89 IS:e := S.@get inx | i := L + inx | T.@put e :a ...
 -- ComputeVariant:B:do#S#89
 -- ObjTmpStack:add::genDone:false e := S.@get inx | i := L + inx | T.@put e :a ...
 -- OG:markIS:@for 1 :to S.length  | :do  |    e := S.@get inx |    i := L + inx |  ...
 -- items:markForCodeGen:
 -- ComputeVariant:A:@for::to:do#S#0
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:@for::to:do
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:@for 1 :to S.length  | :do  |    e := S.@get inx |    i := L + in ...
 -- :varNo:1 :allocDone:false
 -- OG:super: @for:  |    %globals inSub |    in for: var integer |    in to: var ...
 -- :OG:Qalloc:B:@for::to:do#S#0:newDescNo:0 :objSize:3 
 -- OG:isObjectDesc:NewDescNo:90 IS.newDescNo:90 :objSize:3 varNo:1 
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:super:@for 1 :to S.length  | :do  |    e := S.@get inx |    i := ...: ...3 : ...true
 -- Items:Qalloc:super:B:objSize:4 originOff:4 
 -- IS.newDescNo:90 IS.objSize:3 :
 -- computeVariant:newDescNo:90 IS:
 -- ComputeVariant:B:@for::to:do#S#90
 -- ObjTmpStack:add::genDone:false @for 1 :to S.length  | :do  |    e := S.@get ...
 -- markItem:"V := T.asString" ObjectCall
 -- ObjCall:markSuper:V := T.asString
 -- Invocation:markForCodeGen:V := T.asString
 -- ObjectInvocation:markForCodeGen:V ATd:out V: ref String
 -- DataItem:markForCodeGen:V:descNo:0 :OG.primNo:5 
 -- ObjectInvocation:markForCodeGen::= T.asString ATd::= :  |    %basic 8 |     ...
 -- Pattern:markForCodeGen::= :  |    %basic 8 |    in V: ref Value
 -- arg: T.asString
 -- ComputeVariant:A:doplus
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:e: var integer | i: var integer | T: obj Indexed(L + S.length,I ...
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:doplus:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:91 IS.newDescNo:91 :objSize:0 varNo:1 e: var  ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- dataitem:qalloc:e isValue:true isPrimitive: true isValObj: true isBasic ...true
 -- dataitem:qalloc:i isValue:true isPrimitive: true isValObj: true isBasic ...true
 -- dataitem:qalloc:T isValue:false isPrimitive: true isValObj: false isBas ...false
 -- DI:alloc:off:4 T: obj Indexed(L + S.length,Integer)
 -- OG:Qalloc:A:@for 1 :to L  | :do  |    e := @get inx |    T.@put e :at inx
 -- :varNo:1 :allocDone:false
 -- OG:super: @for:  |    %globals inSub |    in for: var integer |    in to: var ...
 -- :OG:Qalloc:B:@for::to:do#S#88:newDescNo:88 :objSize:3 
 -- OG:isObjectDesc:NewDescNo:92 IS.newDescNo:92 :objSize:3 varNo:1 
 -- Items:Qalloc:objSize:4 
 -- Items:Qalloc:super:@for 1 :to L  | :do  |    e := @get inx |    T.@put e :at  ...: ...3 : ...true
 -- Items:Qalloc:super:B:objSize:4 originOff:4 
 -- IS.newDescNo:92 IS.objSize:3 :
 -- OG:Qalloc:A:@for 1 :to S.length  | :do  |    e := S.@get inx |    i := L + in ...
 -- :varNo:1 :allocDone:false
 -- OG:super: @for:  |    %globals inSub |    in for: var integer |    in to: var ...
 -- :OG:Qalloc:B:@for::to:do#S#90:newDescNo:90 :objSize:3 
 -- OG:isObjectDesc:NewDescNo:93 IS.newDescNo:93 :objSize:3 varNo:1 
 -- Items:Qalloc:objSize:4 
 -- Items:Qalloc:super:@for 1 :to S.length  | :do  |    e := S.@get inx |    i := ...: ...3 : ...true
 -- Items:Qalloc:super:B:objSize:4 originOff:4 
 -- IS.newDescNo:93 IS.objSize:3 :
 -- IS.newDescNo:91 IS.objSize:4 :e: var integer | i: var integer | T: obj Inde ...
 -- computeVariant:newDescNo:91 IS:e: var integer | i: var integer | T: obj Ind ...
 -- ComputeVariant:B:doplus
 -- ObjTmpStack:add::genDone:false doplus:e: var integer | i: var integer | T:  ...
 -- ComputeVariant:A:+
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:in S: ref String | out V: ref String | L: var integer | L := Leng ...
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:+:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:94 IS.newDescNo:94 :objSize:0 varNo:1 in S: r ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- dataitem:qalloc:S isValue:false isPrimitive: true isValObj: false isBas ...false
 -- DI:alloc:off:2 in S: ref String
 -- dataitem:qalloc:V isValue:false isPrimitive: true isValObj: false isBas ...false
 -- DI:alloc:off:3 out V: ref String
 -- dataitem:qalloc:L isValue:true isPrimitive: true isValObj: true isBasic ...true
 -- Pattern:Qalloc:doplus
 -- Pattern:Qalloc:doplus
 -- IS.newDescNo:94 IS.objSize:4 :in S: ref String | out V: ref String | L: var ...
 -- computeVariant:newDescNo:94 IS:in S: ref String | out V: ref String | L: va ...
 -- ComputeVariant:B:+
 -- ObjTmpStack:add::genDone:false + :in S: ref String | out V: ref String | L: ...
 pushText Hello 
 -- invoke:after:E.invoke:""Hello "" 
 -- loadArgs:after:Qgen:"foo("Hello ")" 
 -- formalArg:isPtn:"in S: ref String.String" :isBasicVal:false:valueObj:false
 -- :actArg:""Hello "" :isBasicVal:false
 -- "Hello "ObjectCall
 -- end:loadArgs:NonVirt:"foo("Hello ")" 
 -- invoke:after:loadArgsOf:"foo("Hello ")" :Address:E:"foo("Hello ")"off:0 ...
 -- $ObjectInvocation_Function:invoke: rec:"foo("Hello ")" "foo("Hello ")"
 -- >top:1 descNo:17 
 -- E.ATd: "foo" unique: false
 -- adr::Address:E:"foo("Hello ")"off:0 size:0 isFloat:False superAdj:0 isU ...
 -- $pattern:invoke: "foo:  |    in S: ref String.String |    print:  |       S.p ..."
 -- Pattern:invoke:descNo:17  top:1  rec:"foo("Hello ")" 
 -- ptn:invoke::isValObj:false:rtnValObj:false:"foo:  |    in S: ref String.S ..." 
 -- rec=E:true:rec:"foo("Hello ")" 
 -- kuk:obj:rec.ATd:"foo:  |    in S: ref String.String |    print:  |       S.pr ..." 
 invoke foo 17 0 1
 -- useRtnVal:true:isVal:false:rtnValObj:false:rec=E:true"foo("Hello ")" 
 -- OI:invoke:foo("Hello "):unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"foo("Hello ")" 
 -- loadArgs:after:Qgen:"List(foo("Hello "),list(foo("World\n"),none))" 
 -- formalArg:isPtn:"in head: ref Object" :isBasicVal:false:valueObj:false
 -- :actArg:"foo("Hello ")" :isBasicVal:false
 -- foo("Hello ")ObjectCall
 -- end:loadArgs:NonVirt:"List(foo("Hello "),list(foo("World\n"),none))" 
 -- loadArgs:NonVirt:"List(foo("Hello "),list(foo("World\n"),none))" ActArg ..."l ..." i ...false
 -- loadArgs:not:*: formalArgOf:"List(foo("Hello "),list(foo("World\n"),non ..."   ...false
 -- $ObjectCall:gen: "list(foo("World\n"),none)"
 -- $Invocation:gen: descNo: 13 top: 1 "list(foo("World\n"),none)"
 -- needorigin:"list(foo("World\n"),none)" 
 -- needOrigin:E:"list(foo("World\n"),none)"  E.ATd:"List:  |    in head: ref ..." 
 -- computeAdr: "list(foo("World\n"),none)" 
 -- computeAdr:1 :rec:"none"  E:"list(foo("World\n"),none)" :Address:E:"non ..."
 -- $ObjectInvocation_Function:pushThis: "list(foo("World\n"),none)"
 pushThis 
 -- $ObjectInvocation_Function:loadOrigin::on:0 "list(foo("World\n"),none)" ...
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Function:getAdr::superAdj:0:on:0 "list(foo("World\n") ..."
 -- $pattern:getAdr: "List:  |    in head: ref Object |    in tail: ref List |    ..."
 -- :Address:E:"list(foo("World\n"),none)"off:0 size:0 isFloat:False superA ...
 -- computeAdr:isFirst::Address:E:"list(foo("World\n"),none)"off:0 size:0 i ...
 -- computeAdr:isLast:E: "list(foo("World\n"),none)" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"list(foo("World\n"),none)"of ...
 -- rec: "list(foo("World\n"),none)" E: "list(foo("World\n"),none)" isValue ...false
 -- $ObjectInvocation_Function:loadArgs:staticOff:0 "list(foo("World\n"),no ..."
 -- $pattern:loadArgs:E:"list(foo("World\n"),none)":descNo:13:top:1 "List:  ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"list(foo("World\n"),none)" ActArg: "foo("World\n")" i ...false
 -- loadArgs:not:*: formalArgOf:"list(foo("World\n"),none)"  isCompositeVal ...false
 -- $ObjectCall:gen: "foo("World\n")"
 -- $Invocation:gen: descNo: 17 top: 1 "foo("World\n")"
 -- needorigin:"foo("World\n")" 
 -- needOrigin:E:"foo("World\n")"  E.ATd:"foo:  |    in S: ref String.String |  ..." 
 -- computeAdr: "foo("World\n")" 
 -- computeAdr:1 :rec:"none"  E:"foo("World\n")" :Address:E:"none"off:0 siz ...
 -- $ObjectInvocation_Function:pushThis: "foo("World\n")"
 pushThis 
 -- $ObjectInvocation_Function:loadOrigin::on:0 "foo("World\n")"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Function:getAdr::superAdj:0:on:0 "foo("World\n")"
 -- $pattern:getAdr: "foo:  |    in S: ref String.String |    print:  |       S.p ..."
 -- :Address:E:"foo("World\n")"off:0 size:0 isFloat:False superAdj:0 isUniq ...
 -- computeAdr:isFirst::Address:E:"foo("World\n")"off:0 size:0 isFloat:Fals ...
 -- computeAdr:isLast:E: "foo("World\n")" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"foo("World\n")"off:0 size:0  ...
 -- rec: "foo("World\n")" E: "foo("World\n")" isValueAssign: false
 -- $ObjectInvocation_Function:loadArgs:staticOff:0 "foo("World\n")"
 -- $pattern:loadArgs:E:"foo("World\n")":descNo:17:top:1 "foo:  |    in S: re ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"foo("World\n")" ActArg: ""World\n"" isValue: false
 -- loadArgs:not:*: formalArgOf:"foo("World\n")"  isCompositeValueObj:false
 -- $ObjectCall:gen: ""World\n""
 -- $Invocation:gen: ""World\n""
 -- needorigin:""World\n"" 
 -- needOrigin:E:""World\n""  E.ATd:"String:  |    %OSDvisibility disguised |   ..." 
 -- computeAdr: ""World\n"" 
 -- computeAdr:1 :rec:"none"  E:""World\n"" :Address:E:"none"off:0 size:0 i ...
 -- $String::pushThis: ""World\n""
 -- $String::loadOrigin: ""World\n""
 -- StringObj:loadOrigin:"World\n"
 -- $String::getAdr: ""World\n""
 -- computeAdr:isFirst::Address:E:""World\n""off:0 size:0 isFloat:False sup ...
 -- computeAdr:isLast:E: ""World\n"" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:""World\n""off:0 size:0 isFlo ...
 -- rec: ""World\n"" E: ""World\n"" isValueAssign: false
 -- $String::loadArgs: ""World\n""
 -- invoke:after:loadArgsOf:""World\n"" :Address:E:""World\n""off:0 size:0  ...
 -- $String::invoke: ""World\n""
 -- Pattern:markForCodeGen:+ :  |    in S: ref String |    out V: ref String |    ...
 pushText World\n
 -- invoke:after:E.invoke:""World\n"" 
 -- loadArgs:after:Qgen:"foo("World\n")" 
 -- formalArg:isPtn:"in S: ref String.String" :isBasicVal:false:valueObj:false
 -- :actArg:""World\n"" :isBasicVal:false
 -- "World\n"ObjectCall
 -- end:loadArgs:NonVirt:"foo("World\n")" 
 -- invoke:after:loadArgsOf:"foo("World\n")" :Address:E:"foo("World\n")"off ...
 -- $ObjectInvocation_Function:invoke: rec:"foo("World\n")" "foo("World\n") ..."
 -- >top:1 descNo:17 
 -- E.ATd: "foo" unique: false
 -- adr::Address:E:"foo("World\n")"off:0 size:0 isFloat:False superAdj:0 is ...
 -- $pattern:invoke: "foo:  |    in S: ref String.String |    print:  |       S.p ..."
 -- Pattern:invoke:descNo:17  top:1  rec:"foo("World\n")" 
 -- ptn:invoke::isValObj:false:rtnValObj:false:"foo:  |    in S: ref String.S ..." 
 -- rec=E:true:rec:"foo("World\n")" 
 -- kuk:obj:rec.ATd:"foo:  |    in S: ref String.String |    print:  |       S.pr ..." 
 invoke foo 17 0 1
 -- useRtnVal:true:isVal:false:rtnValObj:false:rec=E:true"foo("World\n")" 
 -- OI:invoke:foo("World\n"):unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"foo("World\n")" 
 -- loadArgs:after:Qgen:"list(foo("World\n"),none)" 
 -- formalArg:isPtn:"in head: ref Object" :isBasicVal:false:valueObj:false
 -- :actArg:"foo("World\n")" :isBasicVal:false
 -- foo("World\n")ObjectCall
 -- end:loadArgs:NonVirt:"list(foo("World\n"),none)" 
 -- loadArgs:NonVirt:"list(foo("World\n"),none)" ActArg: "none" isValue: false
 -- loadArgs:not:*: formalArgOf:"list(foo("World\n"),none)"  isCompositeVal ...false
 -- $ObjectCall:gen: "none"
 -- $Invocation:gen: descNo: 0 top: 0 "none"
 -- needorigin:"none" 
 -- needOrigin:E:"none"  E.ATd:"none:  |    %basic 19 |    none_x: var integer" 
 -- computeAdr: "none" 
 -- computeAdr:1 :rec:"none"  E:"none" :Address:E:"none"off:0 size:0 isFloa ...
 -- $ObjectInvocation_Unary:pushThis: "none"
 -- $ObjectInvocation_Unary:loadOrigin::on:2 "none"
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:2 "none"
 -- $pattern:getAdr: "none:  |    %basic 19 |    none_x: var integer"
 -- :Address:E:"none"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...
 -- computeAdr:isFirst::Address:E:"none"off:0 size:0 isFloat:False superAdj ...
 -- computeAdr:isLast:E: "none" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"none"off:0 size:0 isFloat:Fa ...
 -- rec: "none" E: "none" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "none"
 -- $pattern:loadArgs:E:"none":descNo:0:top:0 "none:  |    %basic 19 |    none_ ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"none" :Address:E:"none"off:0 size:0 isFloat:Fa ...
 -- $ObjectInvocation_Unary:invoke: rec:"none" "none"
 -- >top:0 descNo:0 
 -- E.ATd: "none" unique: false
 -- adr::Address:E:"none"off:0 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- $pattern:invoke: "none:  |    %basic 19 |    none_x: var integer"
 pushNone
 -- OI:invoke:none:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"none" 
 -- loadArgs:after:Qgen:"list(foo("World\n"),none)" 
 -- formalArg:isPtn:"in tail: ref List" :isBasicVal:false:valueObj:false
 -- :actArg:"none" :isBasicVal:false
 -- noneObjectCall
 -- end:loadArgs:NonVirt:"list(foo("World\n"),none)" 
 -- invoke:after:loadArgsOf:"list(foo("World\n"),none)" :Address:E:"list(fo ..."
 -- $ObjectInvocation_Function:invoke: rec:"list(foo("World\n"),none)" "lis ..."
 -- >top:1 descNo:13 
 -- E.ATd: "List" unique: false
 -- adr::Address:E:"list(foo("World\n"),none)"off:0 size:0 isFloat:False su ...
 -- $pattern:invoke: "List:  |    in head: ref Object |    in tail: ref List |    ..."
 -- Pattern:invoke:descNo:13  top:1  rec:"list(foo("World\n"),none)" 
 -- ptn:invoke::isValObj:false:rtnValObj:false:"List:  |    in head: ref Obje ..." 
 -- rec=E:true:rec:"list(foo("World\n"),none)" 
 -- kuk:obj:rec.ATd:"List:  |    in head: ref Object |    in tail: ref List |     ..." 
 invoke List 13 0 1
 -- useRtnVal:true:isVal:false:rtnValObj:false:rec=E:true"list(foo("World\n ..."" 
 -- OI:invoke:list(foo("World\n"),none):unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"list(foo("World\n"),none)" 
 -- loadArgs:after:Qgen:"List(foo("Hello "),list(foo("World\n"),none))" 
 -- formalArg:isPtn:"in tail: ref List" :isBasicVal:false:valueObj:false
 -- :actArg:"list(foo("World\n"),none)" :isBasicVal:false
 -- list(foo("World\n"),none)ObjectCall
 -- end:loadArgs:NonVirt:"List(foo("Hello "),list(foo("World\n"),none))" 
 -- invoke:after:loadArgsOf:"List(foo("Hello "),list(foo("World\n"),none))" : ...
 -- $ObjectInvocation_Function:invoke: rec:"List(foo("Hello "),list(foo("Wo ...
 -- >top:1 descNo:13 
 -- E.ATd: "List" unique: false
 -- adr::Address:E:"List(foo("Hello "),list(foo("World\n"),none))"off:0 siz ...
 -- $pattern:invoke: "List:  |    in head: ref Object |    in tail: ref List |    ..."
 -- Pattern:invoke:descNo:13  top:1  rec:"List(foo("Hello "),list(foo("Worl ..."" 
 -- ptn:invoke::isValObj:false:rtnValObj:false:"List:  |    in head: ref Obje ..." 
 -- rec=E:true:rec:"List(foo("Hello "),list(foo("World\n"),none))" 
 -- kuk:obj:rec.ATd:"List:  |    in head: ref Object |    in tail: ref List |     ..." 
 invoke List 13 0 1
 -- useRtnVal:true:isVal:false:rtnValObj:false:rec=E:true"List(foo("Hello " ..." 
 -- OI:invoke:List(foo("Hello "),list(foo("World\n"),none)):unit: -none- co ...0.000000
 -- invoke:after:E.invoke:"List(foo("Hello "),list(foo("World\n"),none))" 
 -- loadArgs:after:Qgen:":= List(foo("Hello "),list(foo("World\n"),none))" 
 -- vAssign:fArg:"in V: ref Value" 
 -- BINGO
 -- aaaa: in V: ref Value
 -- end:loadArgs:NonVirt:":= List(foo("Hello "),list(foo("World\n"),none))" 
 -- invoke:after:loadArgsOf:":= List(foo("Hello "),list(foo("World\n"),none ..." : ...
 -- $ObjectInvocation_Binary:invoke: rec:"XL" ":= List(foo("Hello "),list(f ..."
 -- >top:1 descNo:14 
 -- E.ATd: ":= " unique: false
 -- adr::Address:E:"none"off:2 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: ref Value"
 -- AssignPtn:invoke:rec: "XL" from: ":= List(foo("Hello "),list(foo("World ..."" 
 -- assign:dstDI :"XL: ref List" isUnitValueObj: false
 -- assign:arg: "List(foo("Hello "),list(foo("World\n"),none))" lab:"Object ..." U ...false  ...false
 --  float: false DataItem:false arg.super:List(foo("Hello "),list(foo("Wor ..."
 --  arg.super.ATd:"Invocation" "List:  |    in head: ref Object |    in tail:  ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "pattern" 
 -- assign:reference: "XL" 
 -- :Address:E:"none"off:2 size:0 isFloat:False superAdj:0 isUnique:False i ...
 -- store::Address:E:"none"off:2 size:0 isFloat:False superAdj:0 isUnique:F ...
 -- isValue:false isAdr:false descNo: 0 
 rswap
 rstoreg 2 
 -- OI:invoke::= List(foo("Hello "),list(foo("World\n"),none)):unit: -none-  ...0.000000
 -- invoke:after:E.invoke:":= List(foo("Hello "),list(foo("World\n"),none)) ..." 
 -- genclass:Qgen:stmt:"XL.scan |    F: ref Foo |    F := current |    F.print" 
 -- $ObjectGenerator:gen:"scan#S#38"singular! staticOff: 0 descNo: 38 top:1 ...
 -- OG:gen:super:"scan" superDescNo:24 super.OG.top:1 
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 38  scan#S#38
 invoke scan#S#38 38 0 1
 rpop
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:6 rTopMax:7
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 39 :top:1 
 -- GenClass:Containers :varNo = 1 
 -- GenClass:Containers:true -> var.genDone

class Containers 39 1 70
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $ModuleItem:gen: "--List"
 -- ModuleItem:gen List
 -- $obj:gen: "List: obj  |    List:  |       in head: ref Object |       in tail ..."
 -- $ObjectGenerator:gen:"List"singular! staticOff: 2 descNo: 37 top:1 "Lis ..."
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 37  List
 invoke List 37 2 1
 rpop
 -- $ModuleItem:gen: "--MapLib"
 -- $ModuleItem:gen: "--Set"
 -- $ModuleItem:gen: "--mQueue"
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 40 :top:1 
 -- GenClass:float :varNo = 1 
 -- GenClass:float:true -> var.genDone

class float 40 0 6
 -- Store itemArgs
 -- $Signature:gen: "float"
 -- $var:gen: "_thisBasicValue: var Float"
 -- DI:isConst:false:isBasicValue:true:primNo:9 
 -- OGqual:float:OGqual.isBasicValue:true:OGqual.isValueObj:true
DO:
 L1:
 -- genclass:Qgen:stmt:"%globals" 
 -- $Property:gen: "%globals"
 -- genclass:Qgen:stmt:"%basic 9" 
 -- $Property:gen: "%basic 9"
 -- genclass:Qgen:stmt:"%public" 
 -- $Property:gen: "%public"
 L2:
 -- OG:pushReturn:"float" 
 rtnV
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 41 :top:1 
 -- GenClass:toBase :varNo = 1 
 -- GenClass:toBase:true -> var.genDone

class toBase 41 1 45
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 -- origin.valueOff:store:2 
 store 2 originOff
 allocEventQ
 mvStack 
 -- $Signature:gen: "toBase"
 -- $var:gen: "out base: var BaseUnit"
 -- DI:isConst:false:isBasicValue:false:primNo:0 
 -- OGqual:Unit:OGqual.isBasicValue:false:OGqual.isValueObj:true
 -- $ObjectCall:gen: "BaseUnit"
 -- $Invocation:gen: descNo: 0 top: 0 "BaseUnit"
 -- needorigin:"BaseUnit" 
 -- needOrigin:E:"BaseUnit"  E.ATd:"BaseUnit:< Unit" 
 -- LoadOrign:no:loadOrigin: "Value |    %unit "U" |    %public |    magnitude: v ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "BaseUnit" E: "BaseUnit" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "BaseUnit"
 -- $pattern:loadArgs:E:"BaseUnit":descNo:0:top:0 "BaseUnit:< Unit"
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"BaseUnit" 
 -- $ObjectInvocation_Unary:invoke: rec:"BaseUnit" "BaseUnit"
 -- >top:0 descNo:0 
 -- $pattern:invoke: "BaseUnit:< Unit"
 -- Pattern:invoke:descNo:0  top:0  rec:"BaseUnit" 
 invokeVal BaseUnit 45 2
 -- useRtnVal:false:isVal:true:rtnValObj:false:rec=E:true"BaseUnit" 
 -- OI:invoke:BaseUnit:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"BaseUnit" 
 innerA  1
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"@inner toBase" 
 -- $ObjectCall:gen: "@inner toBase"
 -- $Invocation:gen: descNo: 0 top: 0 "@inner toBase"
 -- needorigin:"@inner toBase" 
 -- needOrigin:E:"@inner toBase"  E.ATd:"@inner:  |    %basic 101 |    in inner ..." 
 -- computeAdr: "@inner toBase" 
 -- computeAdr:1 :rec:"none"  E:"@inner toBase" :Address:E:"none"off:0 size ...
 -- $ObjectInvocation_KeyWord:pushThis: "@inner toBase"
 -- $ObjectInvocation_KeyWord:loadOrigin::on:4 "@inner toBase"
 -- $ObjectInvocation_KeyWord:getAdr::superAdj:0:on:4 "@inner toBase"
 -- $pattern:getAdr: "@inner:  |    %basic 101 |    in inner: ref Object"
 -- :Address:E:"@inner toBase"off:0 size:0 isFloat:False superAdj:0 isUniqu ...
 -- computeAdr:isFirst::Address:E:"@inner toBase"off:0 size:0 isFloat:False ...
 -- computeAdr:isLast:E: "@inner toBase" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"@inner toBase"off:0 size:0 i ...
 -- rec: "@inner toBase" E: "@inner toBase" isValueAssign: false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@inner toBase"
 -- $pattern:loadArgs:E:"@inner toBase":descNo:0:top:0 "@inner:  |    %basic  ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"@inner toBase" :Address:E:"@inner toBase"off:0 ...
 -- $ObjectInvocation_KeyWord:invoke: rec:"@inner toBase" "@inner toBase"
 -- >top:0 descNo:0 
 -- E.ATd: "" unique: false
 -- adr::Address:E:"@inner toBase"off:0 size:0 isFloat:False superAdj:0 isU ...
 -- $pattern:invoke: "@inner:  |    %basic 101 |    in inner: ref Object"
 pushThis 
 innerP  1
 rpopThisObj 
 -- OI:invoke:@inner toBase:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"@inner toBase" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"toBase" 
 setThisStack 
 pushThis 
 pushc 3
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 42 :top:1 
 -- GenClass:fromBase :varNo = 1 
 -- GenClass:fromBase:true -> var.genDone

class fromBase 42 1 45
 -- Store itemArgs
 pushThis 
 fstoreg 3 base
 tstOriginIsNone 
 rstore 1 origin
 -- origin.valueOff:store:2 
 store 2 originOff
 allocEventQ
 mvStack 
 -- $Signature:gen: "fromBase"
 -- $var:gen: "in base: var float"
 -- DI:isConst:false:isBasicValue:true:primNo:9 
 -- OGqual:float:OGqual.isBasicValue:true:OGqual.isValueObj:true
 innerA  1
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"@inner fromBase" 
 -- $ObjectCall:gen: "@inner fromBase"
 -- $Invocation:gen: descNo: 0 top: 0 "@inner fromBase"
 -- needorigin:"@inner fromBase" 
 -- needOrigin:E:"@inner fromBase"  E.ATd:"@inner:  |    %basic 101 |    in inn ..." 
 -- computeAdr: "@inner fromBase" 
 -- computeAdr:1 :rec:"none"  E:"@inner fromBase" :Address:E:"none"off:0 si ...
 -- $ObjectInvocation_KeyWord:pushThis: "@inner fromBase"
 -- $ObjectInvocation_KeyWord:loadOrigin::on:4 "@inner fromBase"
 -- $ObjectInvocation_KeyWord:getAdr::superAdj:0:on:4 "@inner fromBase"
 -- $pattern:getAdr: "@inner:  |    %basic 101 |    in inner: ref Object"
 -- :Address:E:"@inner fromBase"off:0 size:0 isFloat:False superAdj:0 isUni ...
 -- computeAdr:isFirst::Address:E:"@inner fromBase"off:0 size:0 isFloat:Fal ...
 -- computeAdr:isLast:E: "@inner fromBase" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"@inner fromBase"off:0 size:0 ...
 -- rec: "@inner fromBase" E: "@inner fromBase" isValueAssign: false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@inner fromBase"
 -- $pattern:loadArgs:E:"@inner fromBase":descNo:0:top:0 "@inner:  |    %basi ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"@inner fromBase" :Address:E:"@inner fromBase"o ...
 -- $ObjectInvocation_KeyWord:invoke: rec:"@inner fromBase" "@inner fromBas ..."
 -- >top:0 descNo:0 
 -- E.ATd: "" unique: false
 -- adr::Address:E:"@inner fromBase"off:0 size:0 isFloat:False superAdj:0 i ...
 -- $pattern:invoke: "@inner:  |    %basic 101 |    in inner: ref Object"
 pushThis 
 innerP  1
 rpopThisObj 
 -- OI:invoke:@inner fromBase:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"@inner fromBase" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"fromBase" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:4 isIndexed:0  vTop:-2 vTopMax:0 rTop:1 rTopMax:1
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 43 :top:1 
 -- GenClass:putFloat :varNo = 1 
 -- GenClass:putFloat:true -> var.genDone

class putFloat 43 1 6
 -- Store itemArgs
 pushThis 
 fstoreg 2 X
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $Signature:gen: "putFloat"
 -- $var:gen: "in X: var Float"
 -- DI:isConst:false:isBasicValue:true:primNo:9 
 -- OGqual:float:OGqual.isBasicValue:true:OGqual.isValueObj:true
 -- $var:gen: "out V: var integer"
 -- DI:isConst:false:isBasicValue:true:primNo:1 
 -- OGqual:integer:OGqual.isBasicValue:true:OGqual.isValueObj:true
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%basic 142" 
 -- $Property:gen: "%basic 142"
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"putFloat" 
 setThisStack 
 pushThis 
 -- $var:invoke: newOff:4 "out V: var integer"
 -- >:E=none
 pushg 4 V
 rtn(D)
 end OSDV:0 objSize:4 isIndexed:0  vTop:-1 vTopMax:0 rTop:1 rTopMax:1
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 44 :top:1 
 -- GenClass:print :varNo = 1 
 -- GenClass:print:true -> var.genDone

class print 44 1 45
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 -- origin.valueOff:store:2 
 store 2 originOff
 allocEventQ
 mvStack 
 -- $Signature:gen: "print"
 innerA  1
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:""Unit:".print" 
 -- $ObjectCall:gen: ""Unit:".print"
 -- $Invocation:gen: descNo: 33 top: 1 ""Unit:".print"
 -- needorigin:""Unit:".print" 
 -- needOrigin:E:"print"  E.ATd:"print:  |    @for 1 :to length  |    :do  |      ..." 
 -- computeAdr: ""Unit:".print" 
 -- computeAdr:1 :rec:"none"  E:""Unit:"" :Address:E:"none"off:0 size:0 isF ...
 -- $String::pushThis: ""Unit:""
 -- $String::loadOrigin: ""Unit:""
 -- StringObj:loadOrigin:"Unit:"
 -- $String::getAdr: ""Unit:""
 -- computeAdr:isFirst::Address:E:""Unit:""off:0 size:0 isFloat:False super ...
 -- computeAdr:2 :rec:""Unit:""  E:"print" :Address:E:""Unit:""off:0 size:0 ...
 -- E:notAssign:print
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "print"
 -- $pattern:getAdr: "print:  |    @for 1 :to length  |    :do  |       put(@get  ..."
 -- :Address:E:""Unit:""off:0 size:0 isFloat:False superAdj:0 isUnique:Fals ...
 -- ptn.ssUnitValueObj:false isFloat:false
 -- $String::loadArgs: ""Unit:""
 -- $String::invoke: ""Unit:""
 -- Pattern:markForCodeGen:+ :  |    in S: ref String |    out V: ref String |    ...
 pushText Unit:
 -- computeAdr:isLast:E: "print" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:""Unit:""off:0 size:0 isFloat ...
 -- rec: ""Unit:"" E: "print" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "print"
 -- $pattern:loadArgs:E:"print":descNo:33:top:1 "print:  |    @for 1 :to leng ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"print" :Address:E:""Unit:""off:0 size:0 isFloa ...
 -- $ObjectInvocation_Unary:invoke: rec:""Unit:"" "print"
 -- >top:1 descNo:33 
 -- E.ATd: "print" unique: false
 -- adr::Address:E:""Unit:""off:0 size:0 isFloat:False superAdj:0 isUnique: ...
 -- $pattern:invoke: "print:  |    @for 1 :to length  |    :do  |       put(@get  ..."
 -- Pattern:invoke:descNo:33  top:1  rec:""Unit:"" 
 -- ComputeVariantX
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- <>var
 -- rec:module or pattern:"print"  descno: 33  top: 1 "@for 1 :to length  | : ..." 
 -- ptn:invoke::isValObj:false:rtnValObj:false:"print:  |    @for 1 :to lengt ..." 
 -- rec=E:false:rec:""Unit:"" 
 -- kuk:obj:rec.ATd:"String:  |    %OSDvisibility disguised |    %basic 5 |    %i ..." 
 invoke print 33 0 0
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:false""Unit:"" 
 rpop
 -- OI:invoke:print:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"print" 
 -- genclass:Qgen:stmt:"@inner print" 
 -- $ObjectCall:gen: "@inner print"
 -- $Invocation:gen: descNo: 0 top: 0 "@inner print"
 -- needorigin:"@inner print" 
 -- needOrigin:E:"@inner print"  E.ATd:"@inner:  |    %basic 101 |    in inner: ..." 
 -- computeAdr: "@inner print" 
 -- computeAdr:1 :rec:"none"  E:"@inner print" :Address:E:"none"off:0 size: ...
 -- $ObjectInvocation_KeyWord:pushThis: "@inner print"
 -- $ObjectInvocation_KeyWord:loadOrigin::on:4 "@inner print"
 -- $ObjectInvocation_KeyWord:getAdr::superAdj:0:on:4 "@inner print"
 -- $pattern:getAdr: "@inner:  |    %basic 101 |    in inner: ref Object"
 -- :Address:E:"@inner print"off:0 size:0 isFloat:False superAdj:0 isUnique ...
 -- computeAdr:isFirst::Address:E:"@inner print"off:0 size:0 isFloat:False  ...
 -- computeAdr:isLast:E: "@inner print" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"@inner print"off:0 size:0 is ...
 -- rec: "@inner print" E: "@inner print" isValueAssign: false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@inner print"
 -- $pattern:loadArgs:E:"@inner print":descNo:0:top:0 "@inner:  |    %basic 1 ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"@inner print" :Address:E:"@inner print"off:0 s ...
 -- $ObjectInvocation_KeyWord:invoke: rec:"@inner print" "@inner print"
 -- >top:0 descNo:0 
 -- E.ATd: "" unique: false
 -- adr::Address:E:"@inner print"off:0 size:0 isFloat:False superAdj:0 isUn ...
 -- $pattern:invoke: "@inner:  |    %basic 101 |    in inner: ref Object"
 pushThis 
 innerP  1
 rpopThisObj 
 -- OI:invoke:@inner print:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"@inner print" 
 -- genclass:Qgen:stmt:"put(':')" 
 -- $ObjectCall:gen: "put(':')"
 -- $Invocation:gen: descNo: 30 top: 1 "put(':')"
 -- needorigin:"put(':')" 
 -- needOrigin:E:"put(':')"  E.ATd:"put:  |    %globals |    %basic 2 |    in ch: ..." 
 -- LoadOrign:no:loadOrigin: "%globals | %basic 2 | in ch: val char" 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "put(':')" E: "put(':')" isValueAssign: false
 -- $ObjectInvocation_Function:loadArgs:staticOff:0 "put(':')"
 -- $pattern:loadArgs:E:"put(':')":descNo:30:top:1 "put:  |    %globals |    %b ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"put(':')" ActArg: "':'" isValue: true
 -- loadArgs:not:*: formalArgOf:"put(':')"  isCompositeValueObj:false
 -- $ObjectCall:gen: "':'"
 -- $Invocation:gen: "':'"
 -- needorigin:"':'" 
 -- needOrigin:E:"':'"  E.ATd:"char: value |    %globals |    %basic 3, 16 |    % ..." 
 -- LoadOrign:no:loadOrigin: "value |    %globals |    %basic 3, 16 |    %public |  ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "':'" E: "':'" isValueAssign: false
 -- $Char::loadArgs: "':'"
 -- invoke:after:loadArgsOf:"':'" 
 -- $Char::invoke: "':'"
 pushc 58
 -- invoke:after:E.invoke:"':'" 
 -- loadArgs:after:Qgen:"put(':')" 
 -- formalArg:isPtn:"in ch: val char" :isBasicVal:true:valueObj:true
 -- :actArg:"':'" :isBasicVal:true
 -- ':'ObjectCall
 -- end:loadArgs:NonVirt:"put(':')" 
 -- invoke:after:loadArgsOf:"put(':')" 
 -- $ObjectInvocation_Function:invoke: rec:"put(':')" "put(':')"
 -- >top:1 descNo:30 
 -- $pattern:invoke: "put:  |    %globals |    %basic 2 |    in ch: val char"
 %put 2
 -- OI:invoke:put(':'):unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"put(':')" 
 -- genclass:Qgen:stmt:"putFloat(magnitude)" 
 -- $ObjectCall:gen: "putFloat(magnitude)"
 -- $Invocation:gen: descNo: 43 top: 1 "putFloat(magnitude)"
 -- needorigin:"putFloat(magnitude)" 
 -- needOrigin:E:"putFloat(magnitude)"  E.ATd:"putFloat:  |    %basic 142 |     ..." 
 -- computeAdr: "putFloat(magnitude)" 
 -- computeAdr:1 :rec:"none"  E:"putFloat(magnitude)" :Address:E:"none"off: ...
 -- $ObjectInvocation_Function:pushThis: "putFloat(magnitude)"
 -- $ObjectInvocation_Function:loadOrigin::on:4 "putFloat(magnitude)"
 -- $ObjectInvocation_Function:getAdr::superAdj:0:on:4 "putFloat(magnitude) ..."
 -- $pattern:getAdr: "putFloat:  |    %basic 142 |    in X: var Float |    out V: ..."
 -- :Address:E:"putFloat(magnitude)"off:0 size:0 isFloat:False superAdj:0 i ...
 -- computeAdr:isFirst::Address:E:"putFloat(magnitude)"off:0 size:0 isFloat ...
 -- computeAdr:isLast:E: "putFloat(magnitude)" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"putFloat(magnitude)"off:0 si ...
 -- rec: "putFloat(magnitude)" E: "putFloat(magnitude)" isValueAssign: false
 -- $ObjectInvocation_Function:loadArgs:staticOff:0 "putFloat(magnitude)"
 -- $pattern:loadArgs:E:"putFloat(magnitude)":descNo:43:top:1 "putFloat:  |   ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"putFloat(magnitude)" ActArg: "magnitude" isValue: false
 -- loadArgs:not:*: formalArgOf:"putFloat(magnitude)"  isCompositeValueObj: ...false
 -- $ObjectCall:gen: "magnitude"
 -- $Invocation:gen: "magnitude"
 -- needorigin:"magnitude" 
 -- needOrigin:E:"magnitude"  E.ATd:"magnitude: var Float" 
 -- needOrigin:datItem:leave
 -- computeAdr: "magnitude" 
 -- computeAdr:1 :rec:"none"  E:"magnitude" :Address:E:"none"off:0 size:0 i ...
 -- $ObjectInvocation_Unary:pushThis: "magnitude"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "magnitude"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:1 
 -- goOrigin:print:encOG.IS.newOriginOff:1 :newOriginOff:1 
 -- origin.valueOff:load 2 
 rdouble
 rpushg 1 print:origin
 rswap
 pushg 2 print:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:1 "magnitude"
 -- $var:getAdr:,newOff:1,isValue:"True",A.isValue:"False" "magnitude: var  ..."
 --  A::Address:E:"magnitude"off:0 size:0 isFloat:False superAdj:0 isUnique ...  ...m ...
 -- value_prim:false
 -- Float
 -- before:floatTest: 
 -- getAdr:isfloat:magnitude: var Float A.isValue:true
 -- computeAdr:isFirst::Address:E:"magnitude"off:1 size:0 isFloat:True supe ...
 -- computeAdr:isLast:E: "magnitude" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"magnitude"off:1 size:0 isFlo ...
 -- rec: "magnitude" E: "magnitude" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "magnitude"
 -- $var:loadArgs: "magnitude: var Float"
 -- invoke:after:loadArgsOf:"magnitude" :Address:E:"magnitude"off:1 size:0  ...
 -- $ObjectInvocation_Unary:invoke: rec:"magnitude" "magnitude"
 -- E.ATd: "magnitude" unique: false
 -- adr::Address:E:"magnitude"off:1 size:0 isFloat:True superAdj:0 isUnique ...
 -- $var:invoke: newOff:1 "magnitude: var Float"
 -- load::Address:E:"magnitude"off:1 size:0 isFloat:True superAdj:0 isUniqu ...
 fovpushg 1 
 -- OI:invoke:magnitude:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"magnitude" 
 -- loadArgs:after:Qgen:"putFloat(magnitude)" 
 -- formalArg:isPtn:"in X: var Float" :isBasicVal:true:valueObj:true
 -- :actArg:"magnitude" :isBasicVal:true
 -- magnitudeObjectCall
 -- end:loadArgs:NonVirt:"putFloat(magnitude)" 
 -- invoke:after:loadArgsOf:"putFloat(magnitude)" :Address:E:"putFloat(magn ..."
 -- $ObjectInvocation_Function:invoke: rec:"putFloat(magnitude)" "putFloat( ..."
 -- >top:1 descNo:43 
 -- E.ATd: "putFloat" unique: false
 -- adr::Address:E:"putFloat(magnitude)"off:0 size:0 isFloat:False superAdj ...
 -- $pattern:invoke: "putFloat:  |    %basic 142 |    in X: var Float |    out V: ..."
 -- Pattern:invoke:descNo:43  top:1  rec:"putFloat(magnitude)" 
 -- ptn:invoke:primitive:putFloat
 %printf_prim 142
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:true"putFloat(magnitu ..." 
 vpop
 -- OI:invoke:putFloat(magnitude):unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"putFloat(magnitude)" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"print" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:-1 vTopMax:0 rTop:3 rTopMax:3
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 45 :top:1 
 -- GenClass:Unit :varNo = 1 
 -- GenClass:Unit:true -> var.genDone

class Unit 45 0 48
 -- Store itemArgs
 -- $Signature:gen: "Unit"
 -- $var:gen: "magnitude: var Float"
 -- DI:isConst:false:isBasicValue:true:primNo:9 
 -- OGqual:float:OGqual.isBasicValue:true:OGqual.isValueObj:true
 -- $pattern:gen: "thisUnit:< Unit"
 -- vdt:d
 -- vdtAdd: inx=1 descInx=45
 -- $pattern:gen: "argUnit:< Unit"
 -- vdt:d
 -- vdtAdd: inx=2 descInx=45
 -- $pattern:gen: "resUnit:< Unit"
 -- vdt:d
 -- vdtAdd: inx=3 descInx=45
 -- $pattern:gen: "toBase:<  |    out base: var BaseUnit |    @inner toBase"
 -- vdt:e
 -- vdtAdd: inx=4 descInx=41
 -- $pattern:gen: "fromBase:<  |    in base: var float |    @inner fromBase"
 -- vdt:e
 -- vdtAdd: inx=5 descInx=42
 -- $pattern:gen: "print:<  |    "Unit:".print |    @inner print |    put(':') |    ..."
 -- vdt:e
 -- vdtAdd: inx=6 descInx=44
DO:
 L1:
 -- genclass:Qgen:stmt:"%unit "U"" 
 -- $Property:gen: "%unit "U""
 -- genclass:Qgen:stmt:"%public" 
 -- $Property:gen: "%public"
 L2:
 -- OG:pushReturn:"Unit" 
 rtnV
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- Virtual
 -- Virtual
 -- Virtual
 -- Virtual
 -- Virtual
 -- Virtual
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 46 :top:1 
 -- GenClass:shortName :varNo = 1 
 -- GenClass:shortName:true -> var.genDone

class shortName 46 1 48
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $Signature:gen: "shortName"
 -- $var:gen: "out T: var String.String"
 -- DI:isConst:false:isBasicValue:false:primNo:5 
 -- OGqual:String:OGqual.isBasicValue:false:OGqual.isValueObj:false
 -- $ObjectCall:gen: "String.String"
 -- $Invocation:gen: descNo: 15 top: 1 "String.String"
 -- needorigin:"String.String" 
 -- needOrigin:E:"String"  E.ATd:"String:  |    %OSDvisibility disguised |    % ..." 
 -- computeAdr: "String.String" 
 -- computeAdr:1 :rec:"none"  E:"String" :Address:E:"none"off:0 size:0 isFl ...
 -- $ObjectInvocation_Unary:pushThis: "String"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:3 "String"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:3 
 -- goOrigin:shortName:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 shortName:origin
 -- goOrigin:A:2 
 -- goOrigin:Dimension:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 Dimension:origin
 -- goOrigin:A:1 
 -- goOrigin:Dimensions:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 Dimensions:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:3 "String"
 -- $ModuleItem:getAdr: "--String"
 -- $obj:getAdr: "String: obj  |    %public |    String:  |       %OSDvisibility  ..."
 -- computeAdr:isFirst::Address:E:"none"off:7 size:0 isFloat:False superAdj ...
 -- computeAdr:2 :rec:"String"  E:"String" :Address:E:"none"off:7 size:0 is ...
 -- E:notAssign:String
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "String"
 -- $pattern:getAdr: "String:  |    %OSDvisibility disguised |    %basic 5 |    % ..."
 -- :Address:E:"String"off:7 size:0 isFloat:False superAdj:0 isUnique:False ...
 -- ptn.ssUnitValueObj:false isFloat:false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "String"
 -- $ModuleItem:loadArgs: "--String"
 -- $ObjectInvocation_Unary:invoke: rec:"String" "String"
 -- >moduleItem
 -- E.ATd: "String" unique: false
 -- adr::Address:E:"String"off:7 size:0 isFloat:False superAdj:0 isUnique:F ...
 -- $ModuleItem:invoke: "--String"
 -- ModuleItem:invoke:
 -- $obj:invoke: "String: obj  |    %public |    String:  |       %OSDvisibility  ..."
 -- Module:invoke:adr<>none:false
 rpushg 7 String
 -- OI:invoke:String:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "String" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"String"off:7 size:0 isFloat: ...
 -- rec: "String" E: "String" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "String"
 -- $pattern:loadArgs:E:"String":descNo:15:top:1 "String:  |    %OSDvisibilit ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"String" :Address:E:"String"off:7 size:0 isFloa ...
 -- $ObjectInvocation_Unary:invoke: rec:"String" "String"
 -- >top:1 descNo:15 
 -- E.ATd: "String" unique: false
 -- adr::Address:E:"String"off:7 size:0 isFloat:False superAdj:0 isUnique:F ...
 -- $pattern:invoke: "String:  |    %OSDvisibility disguised |    %basic 5 |    % ..."
 -- Pattern:invoke:descNo:15  top:1  rec:"String" 
 -- ComputeVariantX
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- <>var
 -- rec:module or pattern:"String"  descno: 15  top: 1 "%OSDvisibility disg ..." 
 -- ptn:invoke:primitive:String
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:false"String" 
 rpop
 -- OI:invoke:String:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"String" 
 innerA  1
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"@inner shortName" 
 -- $ObjectCall:gen: "@inner shortName"
 -- $Invocation:gen: descNo: 0 top: 0 "@inner shortName"
 -- needorigin:"@inner shortName" 
 -- needOrigin:E:"@inner shortName"  E.ATd:"@inner:  |    %basic 101 |    in in ..." 
 -- computeAdr: "@inner shortName" 
 -- computeAdr:1 :rec:"none"  E:"@inner shortName" :Address:E:"none"off:0 s ...
 -- $ObjectInvocation_KeyWord:pushThis: "@inner shortName"
 -- $ObjectInvocation_KeyWord:loadOrigin::on:3 "@inner shortName"
 -- $ObjectInvocation_KeyWord:getAdr::superAdj:0:on:3 "@inner shortName"
 -- $pattern:getAdr: "@inner:  |    %basic 101 |    in inner: ref Object"
 -- :Address:E:"@inner shortName"off:0 size:0 isFloat:False superAdj:0 isUn ...
 -- computeAdr:isFirst::Address:E:"@inner shortName"off:0 size:0 isFloat:Fa ...
 -- computeAdr:isLast:E: "@inner shortName" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"@inner shortName"off:0 size: ...
 -- rec: "@inner shortName" E: "@inner shortName" isValueAssign: false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@inner shortName"
 -- $pattern:loadArgs:E:"@inner shortName":descNo:0:top:0 "@inner:  |    %bas ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"@inner shortName" :Address:E:"@inner shortName ..."
 -- $ObjectInvocation_KeyWord:invoke: rec:"@inner shortName" "@inner shortN ..."
 -- >top:0 descNo:0 
 -- E.ATd: "" unique: false
 -- adr::Address:E:"@inner shortName"off:0 size:0 isFloat:False superAdj:0  ...
 -- $pattern:invoke: "@inner:  |    %basic 101 |    in inner: ref Object"
 pushThis 
 innerP  1
 rpopThisObj 
 -- OI:invoke:@inner shortName:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"@inner shortName" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"shortName" 
 setThisStack 
 pushThis 
 -- $var:invoke: newOff:2 "out T: var String.String"
 -- >Object:unique:false
 -- >adr=none
 rpushg 2 T
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 47 :top:1 
 -- GenClass:gMult :varNo = 1 
 -- GenClass:gMult:true -> var.genDone

class gMult 47 1 48
 -- Store itemArgs
 -- >StoreValue: "MultArgR" 
 jmpFalse L3
 pushThis 
 addOff 4
 vassign 2 0
 jmp L4
 L3:
 invokeVal R 45 3
 L4:
 -- >StoreValue: "MultArgL" 
 jmpFalse L5
 pushThis 
 addOff 2
 vassign 2 0
 jmp L6
 L5:
 invokeVal L 45 1
 L6:
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $Signature:gen: "gMult"
 -- $var:gen: "in L: var MultArgL"
 -- DI:isConst:false:isBasicValue:false:primNo:0 
 -- OGqual:Unit:OGqual.isBasicValue:false:OGqual.isValueObj:true
 -- inArg:in L: var MultArgL
 -- $var:gen: "in R: var MultArgR"
 -- DI:isConst:false:isBasicValue:false:primNo:0 
 -- OGqual:Unit:OGqual.isBasicValue:false:OGqual.isValueObj:true
 -- inArg:in R: var MultArgR
 -- $var:gen: "out U: var MultRes"
 -- DI:isConst:false:isBasicValue:false:primNo:0 
 -- OGqual:Unit:OGqual.isBasicValue:false:OGqual.isValueObj:true
 -- $ObjectCall:gen: "MultRes"
 -- $Invocation:gen: descNo: 0 top: 0 "MultRes"
 -- needorigin:"MultRes" 
 -- needOrigin:E:"MultRes"  E.ATd:"MultRes:< Unit" 
 -- LoadOrign:no:loadOrigin: "Value |    %unit "U" |    %public |    magnitude: v ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "MultRes" E: "MultRes" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "MultRes"
 -- $pattern:loadArgs:E:"MultRes":descNo:0:top:0 "MultRes:< Unit"
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"MultRes" 
 -- $ObjectInvocation_Unary:invoke: rec:"MultRes" "MultRes"
 -- >top:0 descNo:0 
 -- $pattern:invoke: "MultRes:< Unit"
 -- Pattern:invoke:descNo:0  top:0  rec:"MultRes" 
 invokeVal MultRes 45 5
 -- useRtnVal:false:isVal:true:rtnValObj:false:rec=E:true"MultRes" 
 -- OI:invoke:MultRes:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"MultRes" 
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"U.magnitude := L.magnitude * R.magnitude" 
 -- $ObjectCall:gen: "U.magnitude := L.magnitude * R.magnitude"
 -- $Invocation:gen: descNo: 4 top: 1 "U.magnitude := L.magnitude * R.magni ..."
 -- needorigin:"U.magnitude := L.magnitude * R.magnitude" 
 -- needOrigin:E:":= L.magnitude * R.magnitude"  E.ATd:":= :  |    %basic 8 |   ..." 
 -- computeAdr: "U.magnitude := L.magnitude * R.magnitude" 
 -- computeAdr:1 :rec:"none"  E:"U" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "U"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "U"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "U"
 -- $var:getAdr:,newOff:6,isValue:"True",A.isValue:"False" "out U: var Mult ..."
 --  A::Address:E:"U"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...o ...
 -- value_prim:false
 -- MultRes
 -- before:floatTest: 
 -- computeAdr:isFirst::Address:E:"U"off:6 size:0 isFloat:False superAdj:0  ...
 -- computeAdr:2 :rec:"U"  E:"magnitude" :Address:E:"U"off:6 size:0 isFloat ...
 -- E:notAssign:magnitude
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "magnitude"
 -- $var:getAdr:,newOff:1,isValue:"True",A.isValue:"True" "magnitude: var F ..."
 --  A::Address:E:"U"off:6 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...m ...
 -- value_prim:false
 -- Float
 -- before:floatTest: 
 -- getAdr:isfloat:magnitude: var Float A.isValue:true
 -- computeAdr:3 :rec:"magnitude"  E:":= L.magnitude * R.magnitude" :Addres ...
 -- computeAdr:isAssign:rec: "magnitude"  E:":= L.magnitude * R.magnitude" 
 -- :Address:E:"U"off:6 size:0 isFloat:True superAdj:0 isUnique:False isVal ...
 -- computeAdr:isLast:E: ":= L.magnitude * R.magnitude" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"U"off:6 size:0 isFloat:True  ...
 -- rec: "magnitude" E: ":= L.magnitude * R.magnitude" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:6 ":= L.magnitude * R.magni ..."
 -- $pattern:loadArgs:E:":= L.magnitude * R.magnitude":descNo:4:top:1 ":= : ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= L.magnitude * R.magnitude" ActArg: "L.magnitude *  ..." i ...false
 -- $ObjectCall:gen: "L.magnitude * R.magnitude"
 -- $Invocation:gen: descNo: 0 top: 0 "L.magnitude * R.magnitude"
 -- needorigin:"L.magnitude * R.magnitude" 
 -- needOrigin:E:"* R.magnitude"  E.ATd:"* :  |    %basic 112 |    in V: var fl ..." 
 -- computeAdr: "L.magnitude * R.magnitude" 
 -- computeAdr:1 :rec:"none"  E:"L" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "L"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "L"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "L"
 -- $var:getAdr:,newOff:2,isValue:"True",A.isValue:"False" "in L: var MultA ..."
 --  A::Address:E:"L"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...i ...
 -- value_prim:false
 -- MultArgL
 -- before:floatTest: 
 -- computeAdr:isFirst::Address:E:"L"off:2 size:0 isFloat:False superAdj:0  ...
 -- computeAdr:2 :rec:"L"  E:"magnitude" :Address:E:"L"off:2 size:0 isFloat ...
 -- E:notAssign:magnitude
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "magnitude"
 -- $var:getAdr:,newOff:1,isValue:"True",A.isValue:"True" "magnitude: var F ..."
 --  A::Address:E:"L"off:2 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...m ...
 -- value_prim:false
 -- Float
 -- before:floatTest: 
 -- getAdr:isfloat:magnitude: var Float A.isValue:true
 -- computeAdr:3 :rec:"magnitude"  E:"* R.magnitude" :Address:E:"L"off:2 si ...
 -- E:notAssign:* R.magnitude
 -- $ObjectInvocation_Binary:getAdr::superAdj:0:on:0 "* R.magnitude"
 -- $pattern:getAdr: "* :  |    %basic 112 |    in V: var float |    out R: var f ..."
 -- :Address:E:"L"off:2 size:0 isFloat:True superAdj:0 isUnique:False isVal ...
 -- ptn.ssUnitValueObj:false isFloat:true
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "magnitude"
 -- $var:loadArgs: "magnitude: var Float"
 -- $ObjectInvocation_Unary:invoke: rec:"L" "magnitude"
 -- E.ATd: "* " unique: false
 -- adr::Address:E:"L"off:2 size:0 isFloat:True superAdj:0 isUnique:False i ...
 -- $var:invoke: newOff:1 "magnitude: var Float"
 -- load::Address:E:"L"off:2 size:0 isFloat:True superAdj:0 isUnique:False  ...
 -- isFloat: true
 fpushg 2 
 -- OI:invoke:magnitude:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "* R.magnitude" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"L"off:2 size:0 isFloat:True  ...
 -- rec: "magnitude" E: "* R.magnitude" isValueAssign: false
 -- $ObjectInvocation_Binary:loadArgs:staticOff:0 "* R.magnitude"
 -- $pattern:loadArgs:E:"* R.magnitude":descNo:0:top:0 "* :  |    %basic 112 |  ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"* R.magnitude" ActArg: "R.magnitude" isValue: false
 -- $ObjectCall:gen: "R.magnitude"
 -- $Invocation:gen: "R.magnitude"
 -- needorigin:"R.magnitude" 
 -- needOrigin:E:"magnitude"  E.ATd:"magnitude: var Float" 
 -- needOrigin:datItem:leave
 -- computeAdr: "R.magnitude" 
 -- computeAdr:1 :rec:"none"  E:"R" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "R"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "R"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "R"
 -- $var:getAdr:,newOff:4,isValue:"True",A.isValue:"False" "in R: var MultA ..."
 --  A::Address:E:"R"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...i ...
 -- value_prim:false
 -- MultArgR
 -- before:floatTest: 
 -- computeAdr:isFirst::Address:E:"R"off:4 size:0 isFloat:False superAdj:0  ...
 -- computeAdr:2 :rec:"R"  E:"magnitude" :Address:E:"R"off:4 size:0 isFloat ...
 -- E:notAssign:magnitude
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "magnitude"
 -- $var:getAdr:,newOff:1,isValue:"True",A.isValue:"True" "magnitude: var F ..."
 --  A::Address:E:"R"off:4 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...m ...
 -- value_prim:false
 -- Float
 -- before:floatTest: 
 -- getAdr:isfloat:magnitude: var Float A.isValue:true
 -- computeAdr:isLast:E: "magnitude" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"R"off:4 size:0 isFloat:True  ...
 -- rec: "R" E: "magnitude" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "magnitude"
 -- $var:loadArgs: "magnitude: var Float"
 -- invoke:after:loadArgsOf:"magnitude" :Address:E:"R"off:4 size:0 isFloat: ...
 -- $ObjectInvocation_Unary:invoke: rec:"R" "magnitude"
 -- E.ATd: "magnitude" unique: false
 -- adr::Address:E:"R"off:4 size:0 isFloat:True superAdj:0 isUnique:False i ...
 -- $var:invoke: newOff:1 "magnitude: var Float"
 -- load::Address:E:"R"off:4 size:0 isFloat:True superAdj:0 isUnique:False  ...
 -- isFloat: true
 fpushg 4 
 -- OI:invoke:magnitude:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"magnitude" 
 -- loadArgs:after:Qgen:"* R.magnitude" 
 -- formalArg:isPtn:"in V: var float" :isBasicVal:true:valueObj:true
 -- :actArg:"R.magnitude" :isBasicVal:true
 -- R.magnitudeObjectCall
 -- end:loadArgs:NonVirt:"* R.magnitude" 
 -- invoke:after:loadArgsOf:"* R.magnitude" :Address:E:"L"off:2 size:0 isFl ...
 -- $ObjectInvocation_Binary:invoke: rec:"magnitude" "* R.magnitude"
 -- >top:0 descNo:0 
 -- E.ATd: "* " unique: false
 -- adr::Address:E:"L"off:2 size:0 isFloat:True superAdj:0 isUnique:False i ...
 -- $pattern:invoke: "* :  |    %basic 112 |    in V: var float |    out R: var f ..."
 -- bodyC:
 fmult
 -- OI:invoke:* R.magnitude:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"* R.magnitude" 
 -- loadArgs:after:Qgen:":= L.magnitude * R.magnitude" 
 -- vAssign:fArg:"in V: var Value" 
 -- BINGO
 -- aaaa: in V: var Value
 -- end:loadArgs:NonVirt:":= L.magnitude * R.magnitude" 
 -- invoke:after:loadArgsOf:":= L.magnitude * R.magnitude" :Address:E:"U"of ...
 -- $ObjectInvocation_Binary:invoke: rec:"magnitude" ":= L.magnitude * R.ma ..."
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Address:E:"U"off:6 size:0 isFloat:True superAdj:0 isUnique:False i ...
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "magnitude" from: ":= L.magnitude * R.magnitude" 
 -- assign:dstDI :"magnitude: var Float" isUnitValueObj: false
 -- assign:arg: "L.magnitude * R.magnitude" lab:"ObjectCall" UnitValObj :false  ...false
 --  float: true DataItem:false arg.super:L.magnitude * R.magnitude
 --  arg.super.ATd:"Invocation" "* :  |    %basic 112 |    in V: var float |    o ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:true
 --  arg.super.ATd.label: "pattern" 
 -- assign:simple value: 
 -- :Address:E:"U"off:6 size:0 isFloat:True superAdj:0 isUnique:False isVal ...
 -- store::Address:E:"U"off:6 size:0 isFloat:True superAdj:0 isUnique:False ...
 -- isValue:true isAdr:false descNo: 0 
 -- isFloat: true
 fstoreg 6 address:storeg
 -- OI:invoke::= L.magnitude * R.magnitude:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= L.magnitude * R.magnitude" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"gMult" 
 setThisStack 
 pushThis 
 pushc 6
 rtn(D)
 end OSDV:0 objSize:7 isIndexed:0  vTop:1 vTopMax:2 rTop:5 rTopMax:5
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 48 :top:1 
 -- GenClass:Dimension :varNo = 1 
 -- GenClass:Dimension:true -> var.genDone

class Dimension 48 1 69
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $Signature:gen: "Dimension"
 -- $pattern:gen: "BaseUnit:< Unit"
 -- vdt:d
 -- vdtAdd: inx=1 descInx=45
 -- $pattern:gen: "shortName:<  |    out T: var String.String |    @inner short ..."
 -- vdt:e
 -- vdtAdd: inx=2 descInx=46
 -- $pattern:gen: "MultArgL:< Unit"
 -- vdt:d
 -- vdtAdd: inx=3 descInx=45
 -- $pattern:gen: "MultArgR:< Unit"
 -- vdt:d
 -- vdtAdd: inx=4 descInx=45
 -- $pattern:gen: "MultRes:< Unit"
 -- vdt:d
 -- vdtAdd: inx=5 descInx=45
 -- $pattern:gen: "gMult:<  |    in L: var MultArgL |    in R: var MultArgR |     ..."
 -- vdt:e
 -- vdtAdd: inx=6 descInx=47
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%public" 
 -- $Property:gen: "%public"
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"Dimension" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- Virtual
 -- Virtual
 -- Virtual
 -- Virtual
 -- Virtual
 -- Virtual
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 49 :top:1 
 -- GenClass:shortName :varNo = 1 
 -- GenClass:shortName:true -> var.genDone

class shortName 49 1 50
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 -- super shortName
 -- vdt:b
 --  1:0 2:0 3:0 4:0
 -- vdt:c:innerInx: 1  descNo: 49 
 -- vdtAdd: inx=1 descInx=49
 pushThis 
 rpushg 1 iOrigin
 toSuper 46
 -- $Signature:gen: "shortName"
 rtnInner
DO:
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"T := "m2"" 
 -- $ObjectCall:gen: "T := "m2""
 -- $Invocation:gen: descNo: 14 top: 1 "T := "m2""
 -- needorigin:"T := "m2"" 
 -- needOrigin:E:":= "m2""  E.ATd:":= :  |    %basic 8 |    in V: ref Value" 
 -- computeAdr: "T := "m2"" 
 -- computeAdr:1 :rec:"none"  E:"T" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "T"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "T"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "T"
 -- $var:getAdr:,newOff:2,isValue:"True",A.isValue:"False" "out T: var Stri ..."
 --  A::Address:E:"T"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...o ...
 -- value_prim:false
 -- String.String
 -- before:floatTest: 
 -- computeAdr:isFirst::Address:E:"T"off:2 size:0 isFloat:False superAdj:0  ...
 -- computeAdr:2 :rec:"T"  E:":= "m2"" :Address:E:"T"off:2 size:0 isFloat:F ...
 -- computeAdr:isAssign:rec: "T"  E:":= "m2"" 
 -- :Address:E:"T"off:2 size:0 isFloat:False superAdj:0 isUnique:False isVa ...
 -- computeAdr:isLast:E: ":= "m2"" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"T"off:2 size:0 isFloat:False ...
 -- rec: "T" E: ":= "m2"" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:2 ":= "m2""
 -- $pattern:loadArgs:E:":= "m2"":descNo:14:top:1 ":= :  |    %basic 8 |    in  ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= "m2"" ActArg: ""m2"" isValue: false
 -- $ObjectCall:gen: ""m2""
 -- $Invocation:gen: ""m2""
 -- needorigin:""m2"" 
 -- needOrigin:E:""m2""  E.ATd:"String:  |    %OSDvisibility disguised |    %ba ..." 
 -- computeAdr: ""m2"" 
 -- computeAdr:1 :rec:"none"  E:""m2"" :Address:E:"none"off:0 size:0 isFloa ...
 -- $String::pushThis: ""m2""
 -- $String::loadOrigin: ""m2""
 -- StringObj:loadOrigin:"m2"
 -- $String::getAdr: ""m2""
 -- computeAdr:isFirst::Address:E:""m2""off:0 size:0 isFloat:False superAdj ...
 -- computeAdr:isLast:E: ""m2"" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:""m2""off:0 size:0 isFloat:Fa ...
 -- rec: ""m2"" E: ""m2"" isValueAssign: false
 -- $String::loadArgs: ""m2""
 -- invoke:after:loadArgsOf:""m2"" :Address:E:""m2""off:0 size:0 isFloat:Fa ...
 -- $String::invoke: ""m2""
 -- Pattern:markForCodeGen:+ :  |    in S: ref String |    out V: ref String |    ...
 pushText m2
 -- invoke:after:E.invoke:""m2"" 
 -- loadArgs:after:Qgen:":= "m2"" 
 -- vAssign:fArg:"in V: ref Value" 
 -- BINGO
 -- aaaa: in V: ref Value
 -- end:loadArgs:NonVirt:":= "m2"" 
 -- invoke:after:loadArgsOf:":= "m2"" :Address:E:"T"off:2 size:0 isFloat:Fa ...
 -- $ObjectInvocation_Binary:invoke: rec:"T" ":= "m2""
 -- >top:1 descNo:14 
 -- E.ATd: ":= " unique: false
 -- adr::Address:E:"T"off:2 size:0 isFloat:False superAdj:0 isUnique:False  ...
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: ref Value"
 -- AssignPtn:invoke:rec: "T" from: ":= "m2"" 
 -- assign:dstDI :"out T: var String.String" isUnitValueObj: false
 -- assign:arg: ""m2"" lab:"ObjectCall" UnitValObj :false ptn: false
 --  float: false DataItem:false arg.super:"m2"
 --  arg.super.ATd:"Invocation" "String:  |    %OSDvisibility disguised |    %b ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "pattern" 
 -- assign:reference: "T" 
 -- :Address:E:"T"off:2 size:0 isFloat:False superAdj:0 isUnique:False isVa ...
 -- store::Address:E:"T"off:2 size:0 isFloat:False superAdj:0 isUnique:Fals ...
 -- isValue:false isAdr:false descNo: 0 
 rswap
 rstoreg 2 
 -- OI:invoke::= "m2":unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= "m2"" 
 L2:
 rtnInner
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:2
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 50 :top:1 
 -- GenClass:Area :varNo = 1 
 -- GenClass:Area:true -> var.genDone

class Area 50 1 69
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 -- super Dimension
 -- vdt:b
 --  1:45 2:46 3:45 4:45 5:45 6:47
 -- computeAdr: "Dimension" 
 -- computeAdr:1 :rec:"none"  E:"Dimension" :Address:E:"none"off:0 size:0 i ...
 -- $ObjectInvocation_Unary:pushThis: "Dimension"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "Dimension"
 -- AdjustOrigin:originOff: 1
 rpushg 1 origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:1:on:0 "Dimension"
 -- $pattern:getAdr: "Dimension:  |    %public |    BaseUnit:< Unit |    Unit: Va ..."
 -- :Address:E:"Dimension"off:0 size:0 isFloat:False superAdj:1 isUnique:Fa ...
 -- computeAdr:isFirst::Address:E:"Dimension"off:0 size:0 isFloat:False sup ...
 -- computeAdr:isLast:E: "Dimension" 
 -- genClass:after:ComputeAdr:"Dimension" :Address:E:"Dimension"off:0 size: ...
 -- Super:sig none
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "Dimension"
 -- $pattern:loadArgs:E:"Dimension":descNo:48:top:1 "Dimension:  |    %public ..."
 -- isValueAssign: false
 toSuper 48
 -- $pattern:gen: "shortName::  |    T := "m2""
 -- vdt:f:49 getDescNo:49 
 -- vdtAdd: inx=2 descInx=49
 rtnInner
DO:
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%Public" 
 -- $Property:gen: "%Public"
 L2:
 rtnInner
 end OSDV:0 objSize:1 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- Virtual
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 51 :top:1 
 -- GenClass:print :varNo = 1 
 -- GenClass:print:true -> var.genDone

class print 51 1 52
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 -- origin.valueOff:store:2 
 store 2 originOff
 -- super print
 -- vdt:b
 --  1:0 2:0 3:0 4:0
 -- vdt:c:innerInx: 1  descNo: 51 
 -- vdtAdd: inx=1 descInx=51
 pushThis 
 rpushg 1 iOrigin
 pushThis 
 pushg 2 
 toSuper 44
 -- $Signature:gen: "print"
 rtnInner
DO:
 mvStack 
 L1:
 -- genclass:Qgen:stmt:""SquareMeter".print" 
 -- $ObjectCall:gen: ""SquareMeter".print"
 -- $Invocation:gen: descNo: 33 top: 1 ""SquareMeter".print"
 -- needorigin:""SquareMeter".print" 
 -- needOrigin:E:"print"  E.ATd:"print:  |    @for 1 :to length  |    :do  |      ..." 
 -- computeAdr: ""SquareMeter".print" 
 -- computeAdr:1 :rec:"none"  E:""SquareMeter"" :Address:E:"none"off:0 size ...
 -- $String::pushThis: ""SquareMeter""
 -- $String::loadOrigin: ""SquareMeter""
 -- StringObj:loadOrigin:"SquareMeter"
 -- $String::getAdr: ""SquareMeter""
 -- computeAdr:isFirst::Address:E:""SquareMeter""off:0 size:0 isFloat:False ...
 -- computeAdr:2 :rec:""SquareMeter""  E:"print" :Address:E:""SquareMeter"" ...
 -- E:notAssign:print
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "print"
 -- $pattern:getAdr: "print:  |    @for 1 :to length  |    :do  |       put(@get  ..."
 -- :Address:E:""SquareMeter""off:0 size:0 isFloat:False superAdj:0 isUniqu ...
 -- ptn.ssUnitValueObj:false isFloat:false
 -- $String::loadArgs: ""SquareMeter""
 -- $String::invoke: ""SquareMeter""
 -- Pattern:markForCodeGen:+ :  |    in S: ref String |    out V: ref String |    ...
 pushText SquareMeter
 -- computeAdr:isLast:E: "print" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:""SquareMeter""off:0 size:0 i ...
 -- rec: ""SquareMeter"" E: "print" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "print"
 -- $pattern:loadArgs:E:"print":descNo:33:top:1 "print:  |    @for 1 :to leng ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"print" :Address:E:""SquareMeter""off:0 size:0  ...
 -- $ObjectInvocation_Unary:invoke: rec:""SquareMeter"" "print"
 -- >top:1 descNo:33 
 -- E.ATd: "print" unique: false
 -- adr::Address:E:""SquareMeter""off:0 size:0 isFloat:False superAdj:0 isU ...
 -- $pattern:invoke: "print:  |    @for 1 :to length  |    :do  |       put(@get  ..."
 -- Pattern:invoke:descNo:33  top:1  rec:""SquareMeter"" 
 -- ComputeVariantX
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- <>var
 -- rec:module or pattern:"print"  descno: 33  top: 1 "@for 1 :to length  | : ..." 
 -- ptn:invoke::isValObj:false:rtnValObj:false:"print:  |    @for 1 :to lengt ..." 
 -- rec=E:false:rec:""SquareMeter"" 
 -- kuk:obj:rec.ATd:"String:  |    %OSDvisibility disguised |    %basic 5 |    %i ..." 
 invoke print 33 0 0
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:false""SquareMeter"" 
 rpop
 -- OI:invoke:print:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"print" 
 L2:
 rtnInner
 end OSDV:0 objSize:2 isIndexed:0  vTop:-1 vTopMax:0 rTop:1 rTopMax:2
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 52 :top:1 
 -- GenClass:SquareMeter :varNo = 1 
 -- GenClass:SquareMeter:true -> var.genDone

class SquareMeter 52 0 50
 -- Store itemArgs
 -- super Unit
 -- vdt:b
 --  1:45 2:45 3:45 4:41 5:42 6:44
 -- Super:sig not none
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "Unit"
 -- $pattern:loadArgs:E:"Unit":descNo:45:top:1 "Unit: Value |    %unit "U" |    ..."
 -- isValueAssign: false
 toSuper 45
 -- $Signature:gen: "SquareMeter"
 -- $pattern:gen: "thisUnit:: SquareMeter"
 -- vdtTable: off: 1  descNo: 7 
 -- $pattern:gen: "print::  |    "SquareMeter".print"
 -- vdt:f:51 getDescNo:51 
 -- vdtAdd: inx=6 descInx=51
 rtnInner
DO:
 L1:
 -- genclass:Qgen:stmt:"%unit "m2", "m*m"" 
 -- $Property:gen: "%unit "m2", "m*m""
 -- genclass:Qgen:stmt:"%Public" 
 -- $Property:gen: "%Public"
 L2:
 rtnInner
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- Virtual
 -- genClass:BindVirtuals:descNo:95 

class Vstub#SquareMeter#7 95 0 0
 -- Load origin:OG.isVirtualArg:false
 -- goOrigin:A:1 
 -- OBS! Qalloc, originOff = 0 
 -- ComputeVariant:A:SquareMeter
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Unit
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Value
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is not new:
 -- ComputeVariant:B:SquareMeter
 -- goOrigin:SquareMeter:encOG.IS.newOriginOff:0 :newOriginOff:0 
 rpushg 0 SquareMeter:origin
 -- OG.super.on/descNo:1 52 
 invoke SquareMeter 52 0 1
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- vdt:a:descNo52 
 -- Virtual
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 53 :top:1 
 -- GenClass:toBase :varNo = 1 
 -- GenClass:toBase:true -> var.genDone

class toBase 53 1 56
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 -- origin.valueOff:store:2 
 store 2 originOff
 -- super toBase
 -- vdt:b
 --  1:0 2:0 3:0 4:0
 -- vdt:c:innerInx: 1  descNo: 53 
 -- vdtAdd: inx=1 descInx=53
 pushThis 
 rpushg 1 iOrigin
 pushThis 
 pushg 2 
 toSuper 41
 -- $Signature:gen: "toBase"
 rtnInner
DO:
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"base := magnitude" 
 -- $ObjectCall:gen: "base := magnitude"
 -- $Invocation:gen: descNo: 4 top: 1 "base := magnitude"
 -- needorigin:"base := magnitude" 
 -- needOrigin:E:":= magnitude"  E.ATd:":= :  |    %basic 8 |    in V: var Valu ..." 
 -- computeAdr: "base := magnitude" 
 -- computeAdr:1 :rec:"none"  E:"base" :Address:E:"none"off:0 size:0 isFloa ...
 -- $ObjectInvocation_Unary:pushThis: "base"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "base"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "base"
 -- $var:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "out base: var B ..."
 --  A::Address:E:"base"off:0 size:0 isFloat:False superAdj:0 isUnique:Fals ...  ...o ...
 -- value_prim:false
 -- BaseUnit
 -- before:floatTest: 
 -- computeAdr:isFirst::Address:E:"base"off:3 size:0 isFloat:False superAdj ...
 -- computeAdr:2 :rec:"base"  E:":= magnitude" :Address:E:"base"off:3 size: ...
 -- computeAdr:isAssign:rec: "base"  E:":= magnitude" 
 -- :Address:E:"base"off:3 size:0 isFloat:False superAdj:0 isUnique:False i ...
 -- computeAdr:isLast:E: ":= magnitude" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"base"off:3 size:0 isFloat:Fa ...
 -- rec: "base" E: ":= magnitude" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:3 ":= magnitude"
 -- $pattern:loadArgs:E:":= magnitude":descNo:4:top:1 ":= :  |    %basic 8 |    ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= magnitude" ActArg: "magnitude" isValue: false
 -- $ObjectCall:gen: "magnitude"
 -- $Invocation:gen: "magnitude"
 -- needorigin:"magnitude" 
 -- needOrigin:E:"magnitude"  E.ATd:"magnitude: var Float" 
 -- needOrigin:datItem:leave
 -- computeAdr: "magnitude" 
 -- computeAdr:1 :rec:"none"  E:"magnitude" :Address:E:"none"off:0 size:0 i ...
 -- $ObjectInvocation_Unary:pushThis: "magnitude"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "magnitude"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:1 
 -- goOrigin:toBase:encOG.IS.newOriginOff:1 :newOriginOff:1 
 -- origin.valueOff:load 2 
 rdouble
 rpushg 1 toBase:origin
 rswap
 pushg 2 toBase:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:1 "magnitude"
 -- $var:getAdr:,newOff:1,isValue:"True",A.isValue:"False" "magnitude: var  ..."
 --  A::Address:E:"magnitude"off:0 size:0 isFloat:False superAdj:0 isUnique ...  ...m ...
 -- value_prim:false
 -- Float
 -- before:floatTest: 
 -- getAdr:isfloat:magnitude: var Float A.isValue:true
 -- computeAdr:isFirst::Address:E:"magnitude"off:1 size:0 isFloat:True supe ...
 -- computeAdr:isLast:E: "magnitude" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"magnitude"off:1 size:0 isFlo ...
 -- rec: "magnitude" E: "magnitude" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "magnitude"
 -- $var:loadArgs: "magnitude: var Float"
 -- invoke:after:loadArgsOf:"magnitude" :Address:E:"magnitude"off:1 size:0  ...
 -- $ObjectInvocation_Unary:invoke: rec:"magnitude" "magnitude"
 -- E.ATd: "magnitude" unique: false
 -- adr::Address:E:"magnitude"off:1 size:0 isFloat:True superAdj:0 isUnique ...
 -- $var:invoke: newOff:1 "magnitude: var Float"
 -- load::Address:E:"magnitude"off:1 size:0 isFloat:True superAdj:0 isUniqu ...
 fovpushg 1 
 -- OI:invoke:magnitude:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"magnitude" 
 -- loadArgs:after:Qgen:":= magnitude" 
 -- vAssign:fArg:"in V: var Value" 
 -- end:loadArgs:NonVirt:":= magnitude" 
 -- invoke:after:loadArgsOf:":= magnitude" :Address:E:"base"off:3 size:0 is ...
 -- $ObjectInvocation_Binary:invoke: rec:"base" ":= magnitude"
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Address:E:"base"off:3 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "base" from: ":= magnitude" 
 -- assign:dstDI :"out base: var BaseUnit" isUnitValueObj: false
 -- assign:arg: "magnitude" lab:"ObjectCall" UnitValObj :false ptn: false
 --  float: false DataItem:false arg.super:magnitude
 --  arg.super.ATd:"Invocation" "magnitude: var Float" 
 --  arg.super.ATd.isDataItem:true arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "var" 
 -- assign:ValueObj:isPtn: false size:2 
 -- :Address:E:"base"off:3 size:2 isFloat:False superAdj:0 isUnique:False i ...
 -- store::Address:E:"base"off:3 size:2 isFloat:False superAdj:0 isUnique:F ...
 -- isValue:true isAdr:true descNo: 0 
 -- Address:store::srcIsVal:true destIsVal:false mode:0 
 addOff 3
 vassign 2 0
 -- OI:invoke::= magnitude:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= magnitude" 
 L2:
 rtnInner
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:5 rTopMax:5
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 54 :top:1 
 -- GenClass:fromBase :varNo = 1 
 -- GenClass:fromBase:true -> var.genDone

class fromBase 54 1 56
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 -- origin.valueOff:store:2 
 store 2 originOff
 -- super fromBase
 -- vdt:b
 --  1:0 2:0 3:0 4:0
 -- vdt:c:innerInx: 1  descNo: 54 
 -- vdtAdd: inx=1 descInx=54
 pushThis 
 rpushg 1 iOrigin
 pushThis 
 pushg 2 
 toSuper 42
 -- $Signature:gen: "fromBase"
 rtnInner
DO:
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"magnitude := base" 
 -- $ObjectCall:gen: "magnitude := base"
 -- $Invocation:gen: descNo: 4 top: 1 "magnitude := base"
 -- needorigin:"magnitude := base" 
 -- needOrigin:E:":= base"  E.ATd:":= :  |    %basic 8 |    in V: var Value" 
 -- computeAdr: "magnitude := base" 
 -- computeAdr:1 :rec:"none"  E:"magnitude" :Address:E:"none"off:0 size:0 i ...
 -- $ObjectInvocation_Unary:pushThis: "magnitude"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "magnitude"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:1 
 -- goOrigin:fromBase:encOG.IS.newOriginOff:1 :newOriginOff:1 
 -- origin.valueOff:load 2 
 rdouble
 rpushg 1 fromBase:origin
 rswap
 pushg 2 fromBase:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:1 "magnitude"
 -- $var:getAdr:,newOff:1,isValue:"True",A.isValue:"False" "magnitude: var  ..."
 --  A::Address:E:"magnitude"off:0 size:0 isFloat:False superAdj:0 isUnique ...  ...m ...
 -- value_prim:false
 -- Float
 -- before:floatTest: 
 -- getAdr:isfloat:magnitude: var Float A.isValue:true
 -- computeAdr:isFirst::Address:E:"magnitude"off:1 size:0 isFloat:True supe ...
 -- computeAdr:2 :rec:"magnitude"  E:":= base" :Address:E:"magnitude"off:1  ...
 -- computeAdr:isAssign:rec: "magnitude"  E:":= base" 
 -- :Address:E:"magnitude"off:1 size:0 isFloat:True superAdj:0 isUnique:Fal ...
 -- computeAdr:isLast:E: ":= base" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"magnitude"off:1 size:0 isFlo ...
 -- rec: "magnitude" E: ":= base" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:1 ":= base"
 -- $pattern:loadArgs:E:":= base":descNo:4:top:1 ":= :  |    %basic 8 |    in V ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= base" ActArg: "base" isValue: false
 -- $ObjectCall:gen: "base"
 -- $Invocation:gen: "base"
 -- needorigin:"base" 
 -- needOrigin:E:"base"  E.ATd:"in base: var float" 
 -- needOrigin:datItem:leave
 -- computeAdr: "base" 
 -- computeAdr:1 :rec:"none"  E:"base" :Address:E:"none"off:0 size:0 isFloa ...
 -- $ObjectInvocation_Unary:pushThis: "base"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "base"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "base"
 -- $var:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "in base: var fl ..."
 --  A::Address:E:"base"off:0 size:0 isFloat:False superAdj:0 isUnique:Fals ...  ...i ...
 -- value_prim:false
 -- float
 -- before:floatTest: 
 -- getAdr:isfloat:in base: var float A.isValue:true
 -- computeAdr:isFirst::Address:E:"base"off:3 size:0 isFloat:True superAdj: ...
 -- computeAdr:isLast:E: "base" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"base"off:3 size:0 isFloat:Tr ...
 -- rec: "base" E: "base" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "base"
 -- $var:loadArgs: "in base: var float"
 -- invoke:after:loadArgsOf:"base" :Address:E:"base"off:3 size:0 isFloat:Tr ...
 -- $ObjectInvocation_Unary:invoke: rec:"base" "base"
 -- E.ATd: "base" unique: false
 -- adr::Address:E:"base"off:3 size:0 isFloat:True superAdj:0 isUnique:Fals ...
 -- $var:invoke: newOff:3 "in base: var float"
 -- load::Address:E:"base"off:3 size:0 isFloat:True superAdj:0 isUnique:Fal ...
 -- isFloat: true
 fpushg 3 
 -- OI:invoke:base:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"base" 
 -- loadArgs:after:Qgen:":= base" 
 -- vAssign:fArg:"in V: var Value" 
 -- end:loadArgs:NonVirt:":= base" 
 -- invoke:after:loadArgsOf:":= base" :Address:E:"magnitude"off:1 size:0 is ...
 -- $ObjectInvocation_Binary:invoke: rec:"magnitude" ":= base"
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Address:E:"magnitude"off:1 size:0 isFloat:True superAdj:0 isUnique ...
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "magnitude" from: ":= base" 
 -- assign:dstDI :"magnitude: var Float" isUnitValueObj: false
 -- assign:arg: "base" lab:"ObjectCall" UnitValObj :false ptn: false
 --  float: false DataItem:false arg.super:base
 --  arg.super.ATd:"Invocation" "in base: var float" 
 --  arg.super.ATd.isDataItem:true arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "var" 
 -- assign:simple value: 
 -- :Address:E:"magnitude"off:1 size:0 isFloat:True superAdj:0 isUnique:Fal ...
 -- store::Address:E:"magnitude"off:1 size:0 isFloat:True superAdj:0 isUniq ...
 -- isValue:true isAdr:false descNo: 0 
 -- Address:store:originIsValue:
 fovstoreg 1 
 -- OI:invoke::= base:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= base" 
 L2:
 rtnInner
 end OSDV:0 objSize:4 isIndexed:0  vTop:-2 vTopMax:0 rTop:5 rTopMax:5
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 55 :top:1 
 -- GenClass:print :varNo = 1 
 -- GenClass:print:true -> var.genDone

class print 55 1 56
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 -- origin.valueOff:store:2 
 store 2 originOff
 -- super print
 -- vdt:b
 --  1:0 2:0 3:0 4:0
 -- vdt:c:innerInx: 1  descNo: 55 
 -- vdtAdd: inx=1 descInx=55
 pushThis 
 rpushg 1 iOrigin
 pushThis 
 pushg 2 
 toSuper 44
 -- $Signature:gen: "print"
 rtnInner
DO:
 mvStack 
 L1:
 -- genclass:Qgen:stmt:""Meter".print" 
 -- $ObjectCall:gen: ""Meter".print"
 -- $Invocation:gen: descNo: 33 top: 1 ""Meter".print"
 -- needorigin:""Meter".print" 
 -- needOrigin:E:"print"  E.ATd:"print:  |    @for 1 :to length  |    :do  |      ..." 
 -- computeAdr: ""Meter".print" 
 -- computeAdr:1 :rec:"none"  E:""Meter"" :Address:E:"none"off:0 size:0 isF ...
 -- $String::pushThis: ""Meter""
 -- $String::loadOrigin: ""Meter""
 -- StringObj:loadOrigin:"Meter"
 -- $String::getAdr: ""Meter""
 -- computeAdr:isFirst::Address:E:""Meter""off:0 size:0 isFloat:False super ...
 -- computeAdr:2 :rec:""Meter""  E:"print" :Address:E:""Meter""off:0 size:0 ...
 -- E:notAssign:print
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "print"
 -- $pattern:getAdr: "print:  |    @for 1 :to length  |    :do  |       put(@get  ..."
 -- :Address:E:""Meter""off:0 size:0 isFloat:False superAdj:0 isUnique:Fals ...
 -- ptn.ssUnitValueObj:false isFloat:false
 -- $String::loadArgs: ""Meter""
 -- $String::invoke: ""Meter""
 -- Pattern:markForCodeGen:+ :  |    in S: ref String |    out V: ref String |    ...
 pushText Meter
 -- computeAdr:isLast:E: "print" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:""Meter""off:0 size:0 isFloat ...
 -- rec: ""Meter"" E: "print" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "print"
 -- $pattern:loadArgs:E:"print":descNo:33:top:1 "print:  |    @for 1 :to leng ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"print" :Address:E:""Meter""off:0 size:0 isFloa ...
 -- $ObjectInvocation_Unary:invoke: rec:""Meter"" "print"
 -- >top:1 descNo:33 
 -- E.ATd: "print" unique: false
 -- adr::Address:E:""Meter""off:0 size:0 isFloat:False superAdj:0 isUnique: ...
 -- $pattern:invoke: "print:  |    @for 1 :to length  |    :do  |       put(@get  ..."
 -- Pattern:invoke:descNo:33  top:1  rec:""Meter"" 
 -- ComputeVariantX
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- <>var
 -- rec:module or pattern:"print"  descno: 33  top: 1 "@for 1 :to length  | : ..." 
 -- ptn:invoke::isValObj:false:rtnValObj:false:"print:  |    @for 1 :to lengt ..." 
 -- rec=E:false:rec:""Meter"" 
 -- kuk:obj:rec.ATd:"String:  |    %OSDvisibility disguised |    %basic 5 |    %i ..." 
 invoke print 33 0 0
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:false""Meter"" 
 rpop
 -- OI:invoke:print:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"print" 
 L2:
 rtnInner
 end OSDV:0 objSize:2 isIndexed:0  vTop:-1 vTopMax:0 rTop:1 rTopMax:2
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 56 :top:1 
 -- GenClass:Meter :varNo = 1 
 -- GenClass:Meter:true -> var.genDone

class Meter 56 0 58
 -- Store itemArgs
 -- super Unit
 -- vdt:b
 --  1:45 2:45 3:45 4:41 5:42 6:44
 -- Super:sig not none
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "Unit"
 -- $pattern:loadArgs:E:"Unit":descNo:45:top:1 "Unit: Value |    %unit "U" |    ..."
 -- isValueAssign: false
 toSuper 45
 -- $Signature:gen: "Meter"
 -- $pattern:gen: "thisUnit:: Meter"
 -- vdtTable: off: 1  descNo: 4 
 -- $pattern:gen: "argUnit:: Meter"
 -- vdtTable: off: 2  descNo: 5 
 -- $pattern:gen: "resUnit:: Area.SquareMeter"
 -- vdtTable: off: 3  descNo: 6 
 -- $pattern:gen: "toBase::  |    base := magnitude"
 -- vdt:f:53 getDescNo:53 
 -- vdtAdd: inx=4 descInx=53
 -- $pattern:gen: "fromBase::  |    magnitude := base"
 -- vdt:f:54 getDescNo:54 
 -- vdtAdd: inx=5 descInx=54
 -- $pattern:gen: "print::  |    "Meter".print"
 -- vdt:f:55 getDescNo:55 
 -- vdtAdd: inx=6 descInx=55
 rtnInner
DO:
 L1:
 -- genclass:Qgen:stmt:"%unit "m"" 
 -- $Property:gen: "%unit "m""
 -- genclass:Qgen:stmt:"%Public" 
 -- $Property:gen: "%Public"
 L2:
 rtnInner
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- Virtual
 -- genClass:BindVirtuals:descNo:96 

class Vstub#Meter#4 96 0 0
 -- Load origin:OG.isVirtualArg:false
 -- goOrigin:A:1 
 -- OBS! Qalloc, originOff = 0 
 -- ComputeVariant:A:Meter
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Unit
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Value
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is not new:
 -- ComputeVariant:B:Meter
 -- goOrigin:Meter:encOG.IS.newOriginOff:0 :newOriginOff:0 
 rpushg 0 Meter:origin
 -- OG.super.on/descNo:1 56 
 invoke Meter 56 0 1
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- vdt:a:descNo56 
 -- Virtual
 -- genClass:BindVirtuals:descNo:97 

class Vstub#Meter#5 97 0 0
 -- Load origin:OG.isVirtualArg:false
 -- goOrigin:A:1 
 -- OBS! Qalloc, originOff = 0 
 -- ComputeVariant:A:Meter
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Unit
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Value
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is not new:
 -- ComputeVariant:B:Meter
 -- goOrigin:Meter:encOG.IS.newOriginOff:0 :newOriginOff:0 
 rpushg 0 Meter:origin
 -- OG.super.on/descNo:1 56 
 invoke Meter 56 0 1
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- vdt:a:descNo56 
 -- Virtual
 -- genClass:BindVirtuals:descNo:98 

class Vstub#Meter#6 98 0 0
 -- Load origin:OG.isVirtualArg:false
 -- OG.super.on/descNo:0 52 
 invoke Meter 52 0 1
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- vdt:a:descNo56 
 -- Virtual
 -- Virtual
 -- Virtual
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 57 :top:1 
 -- GenClass:shortName :varNo = 1 
 -- GenClass:shortName:true -> var.genDone

class shortName 57 1 58
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 -- super shortName
 -- vdt:b
 --  1:0 2:0 3:0 4:0
 -- vdt:c:innerInx: 1  descNo: 57 
 -- vdtAdd: inx=1 descInx=57
 pushThis 
 rpushg 1 iOrigin
 toSuper 46
 -- $Signature:gen: "shortName"
 rtnInner
DO:
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"T := "L"" 
 -- $ObjectCall:gen: "T := "L""
 -- $Invocation:gen: descNo: 14 top: 1 "T := "L""
 -- needorigin:"T := "L"" 
 -- needOrigin:E:":= "L""  E.ATd:":= :  |    %basic 8 |    in V: ref Value" 
 -- computeAdr: "T := "L"" 
 -- computeAdr:1 :rec:"none"  E:"T" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "T"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "T"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "T"
 -- $var:getAdr:,newOff:2,isValue:"True",A.isValue:"False" "out T: var Stri ..."
 --  A::Address:E:"T"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...o ...
 -- value_prim:false
 -- String.String
 -- before:floatTest: 
 -- computeAdr:isFirst::Address:E:"T"off:2 size:0 isFloat:False superAdj:0  ...
 -- computeAdr:2 :rec:"T"  E:":= "L"" :Address:E:"T"off:2 size:0 isFloat:Fa ...
 -- computeAdr:isAssign:rec: "T"  E:":= "L"" 
 -- :Address:E:"T"off:2 size:0 isFloat:False superAdj:0 isUnique:False isVa ...
 -- computeAdr:isLast:E: ":= "L"" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"T"off:2 size:0 isFloat:False ...
 -- rec: "T" E: ":= "L"" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:2 ":= "L""
 -- $pattern:loadArgs:E:":= "L"":descNo:14:top:1 ":= :  |    %basic 8 |    in V ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= "L"" ActArg: ""L"" isValue: false
 -- $ObjectCall:gen: ""L""
 -- $Invocation:gen: ""L""
 -- needorigin:""L"" 
 -- needOrigin:E:""L""  E.ATd:"String:  |    %OSDvisibility disguised |    %bas ..." 
 -- computeAdr: ""L"" 
 -- computeAdr:1 :rec:"none"  E:""L"" :Address:E:"none"off:0 size:0 isFloat ...
 -- $String::pushThis: ""L""
 -- $String::loadOrigin: ""L""
 -- StringObj:loadOrigin:"L"
 -- $String::getAdr: ""L""
 -- computeAdr:isFirst::Address:E:""L""off:0 size:0 isFloat:False superAdj: ...
 -- computeAdr:isLast:E: ""L"" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:""L""off:0 size:0 isFloat:Fal ...
 -- rec: ""L"" E: ""L"" isValueAssign: false
 -- $String::loadArgs: ""L""
 -- invoke:after:loadArgsOf:""L"" :Address:E:""L""off:0 size:0 isFloat:Fals ...
 -- $String::invoke: ""L""
 -- Pattern:markForCodeGen:+ :  |    in S: ref String |    out V: ref String |    ...
 pushText L
 -- invoke:after:E.invoke:""L"" 
 -- loadArgs:after:Qgen:":= "L"" 
 -- vAssign:fArg:"in V: ref Value" 
 -- BINGO
 -- aaaa: in V: ref Value
 -- end:loadArgs:NonVirt:":= "L"" 
 -- invoke:after:loadArgsOf:":= "L"" :Address:E:"T"off:2 size:0 isFloat:Fal ...
 -- $ObjectInvocation_Binary:invoke: rec:"T" ":= "L""
 -- >top:1 descNo:14 
 -- E.ATd: ":= " unique: false
 -- adr::Address:E:"T"off:2 size:0 isFloat:False superAdj:0 isUnique:False  ...
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: ref Value"
 -- AssignPtn:invoke:rec: "T" from: ":= "L"" 
 -- assign:dstDI :"out T: var String.String" isUnitValueObj: false
 -- assign:arg: ""L"" lab:"ObjectCall" UnitValObj :false ptn: false
 --  float: false DataItem:false arg.super:"L"
 --  arg.super.ATd:"Invocation" "String:  |    %OSDvisibility disguised |    %b ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "pattern" 
 -- assign:reference: "T" 
 -- :Address:E:"T"off:2 size:0 isFloat:False superAdj:0 isUnique:False isVa ...
 -- store::Address:E:"T"off:2 size:0 isFloat:False superAdj:0 isUnique:Fals ...
 -- isValue:false isAdr:false descNo: 0 
 rswap
 rstoreg 2 
 -- OI:invoke::= "L":unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= "L"" 
 L2:
 rtnInner
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:2
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 58 :top:1 
 -- GenClass:Length :varNo = 1 
 -- GenClass:Length:true -> var.genDone

class Length 58 1 69
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 -- super Dimension
 -- vdt:b
 --  1:45 2:46 3:45 4:45 5:45 6:47
 -- computeAdr: "Dimension" 
 -- computeAdr:1 :rec:"none"  E:"Dimension" :Address:E:"none"off:0 size:0 i ...
 -- $ObjectInvocation_Unary:pushThis: "Dimension"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "Dimension"
 -- AdjustOrigin:originOff: 1
 rpushg 1 origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:1:on:0 "Dimension"
 -- $pattern:getAdr: "Dimension:  |    %public |    BaseUnit:< Unit |    Unit: Va ..."
 -- :Address:E:"Dimension"off:0 size:0 isFloat:False superAdj:1 isUnique:Fa ...
 -- computeAdr:isFirst::Address:E:"Dimension"off:0 size:0 isFloat:False sup ...
 -- computeAdr:isLast:E: "Dimension" 
 -- genClass:after:ComputeAdr:"Dimension" :Address:E:"Dimension"off:0 size: ...
 -- Super:sig none
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "Dimension"
 -- $pattern:loadArgs:E:"Dimension":descNo:48:top:1 "Dimension:  |    %public ..."
 -- isValueAssign: false
 toSuper 48
 -- $pattern:gen: "BaseUnit:: Meter"
 -- vdtTable: off: 1  descNo: 3 
 -- $pattern:gen: "shortName::  |    T := "L""
 -- vdt:f:57 getDescNo:57 
 -- vdtAdd: inx=2 descInx=57
 rtnInner
DO:
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%Public" 
 -- $Property:gen: "%Public"
 L2:
 rtnInner
 end OSDV:0 objSize:1 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- Virtual
 -- genClass:BindVirtuals:descNo:99 

class Vstub#S#3 99 1 0
 -- Load origin:OG.isVirtualArg:false
 -- OG.super.on/descNo:0 56 
 invoke S 56 0 1
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- vdt:a:descNo58 
 -- Virtual
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 59 :top:1 
 -- GenClass:Mass :varNo = 1 
 -- GenClass:Mass:true -> var.genDone

class Mass 59 1 69
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 -- super Dimension
 -- vdt:b
 --  1:45 2:46 3:45 4:45 5:45 6:47
 -- computeAdr: "Dimension" 
 -- computeAdr:1 :rec:"none"  E:"Dimension" :Address:E:"none"off:0 size:0 i ...
 -- $ObjectInvocation_Unary:pushThis: "Dimension"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "Dimension"
 -- AdjustOrigin:originOff: 1
 rpushg 1 origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:1:on:0 "Dimension"
 -- $pattern:getAdr: "Dimension:  |    %public |    BaseUnit:< Unit |    Unit: Va ..."
 -- :Address:E:"Dimension"off:0 size:0 isFloat:False superAdj:1 isUnique:Fa ...
 -- computeAdr:isFirst::Address:E:"Dimension"off:0 size:0 isFloat:False sup ...
 -- computeAdr:isLast:E: "Dimension" 
 -- genClass:after:ComputeAdr:"Dimension" :Address:E:"Dimension"off:0 size: ...
 -- Super:sig none
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "Dimension"
 -- $pattern:loadArgs:E:"Dimension":descNo:48:top:1 "Dimension:  |    %public ..."
 -- isValueAssign: false
 toSuper 48
 rtnInner
DO:
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%public" 
 -- $Property:gen: "%public"
 L2:
 rtnInner
 end OSDV:0 objSize:1 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 60 :top:1 
 -- GenClass:Time :varNo = 1 
 -- GenClass:Time:true -> var.genDone

class Time 60 1 69
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 -- super Dimension
 -- vdt:b
 --  1:45 2:46 3:45 4:45 5:45 6:47
 -- computeAdr: "Dimension -- 5: " 
 -- computeAdr:1 :rec:"none"  E:"Dimension -- 5: " :Address:E:"none"off:0 s ...
 -- $ObjectInvocation_Unary:pushThis: "Dimension -- 5: "
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "Dimension -- 5: "
 -- AdjustOrigin:originOff: 1
 rpushg 1 origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:1:on:0 "Dimension -- 5: "
 -- $pattern:getAdr: "Dimension:  |    %public |    BaseUnit:< Unit |    Unit: Va ..."
 -- :Address:E:"Dimension -- 5: "off:0 size:0 isFloat:False superAdj:1 isUn ...
 -- computeAdr:isFirst::Address:E:"Dimension -- 5: "off:0 size:0 isFloat:Fa ...
 -- computeAdr:isLast:E: "Dimension -- 5: " 
 -- genClass:after:ComputeAdr:"Dimension -- 5: " :Address:E:"Dimension -- 5 ..."
 -- Super:sig none
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "Dimension -- 5: "
 -- $pattern:loadArgs:E:"Dimension -- 5: ":descNo:48:top:1 "Dimension:  |     ..."
 -- isValueAssign: false
 toSuper 48
 rtnInner
DO:
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%Public" 
 -- $Property:gen: "%Public"
 L2:
 rtnInner
 end OSDV:0 objSize:1 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 61 :top:1 
 -- GenClass:shortName :varNo = 1 
 -- GenClass:shortName:true -> var.genDone

class shortName 61 1 68
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 -- super shortName
 -- vdt:b
 --  1:0 2:0 3:0 4:0
 -- vdt:c:innerInx: 1  descNo: 61 
 -- vdtAdd: inx=1 descInx=61
 pushThis 
 rpushg 1 iOrigin
 toSuper 46
 -- $Signature:gen: "shortName"
 rtnInner
DO:
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"T := "V"" 
 -- $ObjectCall:gen: "T := "V""
 -- $Invocation:gen: descNo: 14 top: 1 "T := "V""
 -- needorigin:"T := "V"" 
 -- needOrigin:E:":= "V""  E.ATd:":= :  |    %basic 8 |    in V: ref Value" 
 -- computeAdr: "T := "V"" 
 -- computeAdr:1 :rec:"none"  E:"T" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "T"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "T"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "T"
 -- $var:getAdr:,newOff:2,isValue:"True",A.isValue:"False" "out T: var Stri ..."
 --  A::Address:E:"T"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...o ...
 -- value_prim:false
 -- String.String
 -- before:floatTest: 
 -- computeAdr:isFirst::Address:E:"T"off:2 size:0 isFloat:False superAdj:0  ...
 -- computeAdr:2 :rec:"T"  E:":= "V"" :Address:E:"T"off:2 size:0 isFloat:Fa ...
 -- computeAdr:isAssign:rec: "T"  E:":= "V"" 
 -- :Address:E:"T"off:2 size:0 isFloat:False superAdj:0 isUnique:False isVa ...
 -- computeAdr:isLast:E: ":= "V"" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"T"off:2 size:0 isFloat:False ...
 -- rec: "T" E: ":= "V"" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:2 ":= "V""
 -- $pattern:loadArgs:E:":= "V"":descNo:14:top:1 ":= :  |    %basic 8 |    in V ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= "V"" ActArg: ""V"" isValue: false
 -- $ObjectCall:gen: ""V""
 -- $Invocation:gen: ""V""
 -- needorigin:""V"" 
 -- needOrigin:E:""V""  E.ATd:"String:  |    %OSDvisibility disguised |    %bas ..." 
 -- computeAdr: ""V"" 
 -- computeAdr:1 :rec:"none"  E:""V"" :Address:E:"none"off:0 size:0 isFloat ...
 -- $String::pushThis: ""V""
 -- $String::loadOrigin: ""V""
 -- StringObj:loadOrigin:"V"
 -- $String::getAdr: ""V""
 -- computeAdr:isFirst::Address:E:""V""off:0 size:0 isFloat:False superAdj: ...
 -- computeAdr:isLast:E: ""V"" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:""V""off:0 size:0 isFloat:Fal ...
 -- rec: ""V"" E: ""V"" isValueAssign: false
 -- $String::loadArgs: ""V""
 -- invoke:after:loadArgsOf:""V"" :Address:E:""V""off:0 size:0 isFloat:Fals ...
 -- $String::invoke: ""V""
 -- Pattern:markForCodeGen:+ :  |    in S: ref String |    out V: ref String |    ...
 pushText V
 -- invoke:after:E.invoke:""V"" 
 -- loadArgs:after:Qgen:":= "V"" 
 -- vAssign:fArg:"in V: ref Value" 
 -- BINGO
 -- aaaa: in V: ref Value
 -- end:loadArgs:NonVirt:":= "V"" 
 -- invoke:after:loadArgsOf:":= "V"" :Address:E:"T"off:2 size:0 isFloat:Fal ...
 -- $ObjectInvocation_Binary:invoke: rec:"T" ":= "V""
 -- >top:1 descNo:14 
 -- E.ATd: ":= " unique: false
 -- adr::Address:E:"T"off:2 size:0 isFloat:False superAdj:0 isUnique:False  ...
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: ref Value"
 -- AssignPtn:invoke:rec: "T" from: ":= "V"" 
 -- assign:dstDI :"out T: var String.String" isUnitValueObj: false
 -- assign:arg: ""V"" lab:"ObjectCall" UnitValObj :false ptn: false
 --  float: false DataItem:false arg.super:"V"
 --  arg.super.ATd:"Invocation" "String:  |    %OSDvisibility disguised |    %b ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "pattern" 
 -- assign:reference: "T" 
 -- :Address:E:"T"off:2 size:0 isFloat:False superAdj:0 isUnique:False isVa ...
 -- store::Address:E:"T"off:2 size:0 isFloat:False superAdj:0 isUnique:Fals ...
 -- isValue:false isAdr:false descNo: 0 
 rswap
 rstoreg 2 
 -- OI:invoke::= "V":unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= "V"" 
 L2:
 rtnInner
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:2
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 62 :top:1 
 -- GenClass:toBase :varNo = 1 
 -- GenClass:toBase:true -> var.genDone

class toBase 62 1 65
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 -- origin.valueOff:store:2 
 store 2 originOff
 -- super toBase
 -- vdt:b
 --  1:0 2:0 3:0 4:0
 -- vdt:c:innerInx: 1  descNo: 62 
 -- vdtAdd: inx=1 descInx=62
 pushThis 
 rpushg 1 iOrigin
 pushThis 
 pushg 2 
 toSuper 41
 -- $Signature:gen: "toBase"
 rtnInner
DO:
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"base := magnitude * 60" 
 -- $ObjectCall:gen: "base := magnitude * 60"
 -- $Invocation:gen: descNo: 4 top: 1 "base := magnitude * 60"
 -- needorigin:"base := magnitude * 60" 
 -- needOrigin:E:":= magnitude * 60"  E.ATd:":= :  |    %basic 8 |    in V: var ..." 
 -- computeAdr: "base := magnitude * 60" 
 -- computeAdr:1 :rec:"none"  E:"base" :Address:E:"none"off:0 size:0 isFloa ...
 -- $ObjectInvocation_Unary:pushThis: "base"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "base"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "base"
 -- $var:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "out base: var B ..."
 --  A::Address:E:"base"off:0 size:0 isFloat:False superAdj:0 isUnique:Fals ...  ...o ...
 -- value_prim:false
 -- BaseUnit
 -- before:floatTest: 
 -- computeAdr:isFirst::Address:E:"base"off:3 size:0 isFloat:False superAdj ...
 -- computeAdr:2 :rec:"base"  E:":= magnitude * 60" :Address:E:"base"off:3  ...
 -- computeAdr:isAssign:rec: "base"  E:":= magnitude * 60" 
 -- :Address:E:"base"off:3 size:0 isFloat:False superAdj:0 isUnique:False i ...
 -- computeAdr:isLast:E: ":= magnitude * 60" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"base"off:3 size:0 isFloat:Fa ...
 -- rec: "base" E: ":= magnitude * 60" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:3 ":= magnitude * 60"
 -- $pattern:loadArgs:E:":= magnitude * 60":descNo:4:top:1 ":= :  |    %basic ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= magnitude * 60" ActArg: "magnitude * 60" isValue:  ...false
 -- $ObjectCall:gen: "magnitude * 60"
 -- $Invocation:gen: descNo: 0 top: 0 "magnitude * 60"
 -- needorigin:"magnitude * 60" 
 -- needOrigin:E:"* 60"  E.ATd:"* :  |    %basic 112 |    in V: var float |    ou ..." 
 -- computeAdr: "magnitude * 60" 
 -- computeAdr:1 :rec:"none"  E:"magnitude" :Address:E:"none"off:0 size:0 i ...
 -- $ObjectInvocation_Unary:pushThis: "magnitude"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "magnitude"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:1 
 -- goOrigin:toBase:encOG.IS.newOriginOff:1 :newOriginOff:1 
 -- origin.valueOff:load 2 
 rdouble
 rpushg 1 toBase:origin
 rswap
 pushg 2 toBase:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:1 "magnitude"
 -- $var:getAdr:,newOff:1,isValue:"True",A.isValue:"False" "magnitude: var  ..."
 --  A::Address:E:"magnitude"off:0 size:0 isFloat:False superAdj:0 isUnique ...  ...m ...
 -- value_prim:false
 -- Float
 -- before:floatTest: 
 -- getAdr:isfloat:magnitude: var Float A.isValue:true
 -- computeAdr:isFirst::Address:E:"magnitude"off:1 size:0 isFloat:True supe ...
 -- computeAdr:2 :rec:"magnitude"  E:"* 60" :Address:E:"magnitude"off:1 siz ...
 -- E:notAssign:* 60
 -- $ObjectInvocation_Binary:getAdr::superAdj:0:on:0 "* 60"
 -- $pattern:getAdr: "* :  |    %basic 112 |    in V: var float |    out R: var f ..."
 -- :Address:E:"magnitude"off:1 size:0 isFloat:True superAdj:0 isUnique:Fal ...
 -- ptn.ssUnitValueObj:false isFloat:true
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "magnitude"
 -- $var:loadArgs: "magnitude: var Float"
 -- $ObjectInvocation_Unary:invoke: rec:"magnitude" "magnitude"
 -- E.ATd: "* " unique: false
 -- adr::Address:E:"magnitude"off:1 size:0 isFloat:True superAdj:0 isUnique ...
 -- $var:invoke: newOff:1 "magnitude: var Float"
 -- load::Address:E:"magnitude"off:1 size:0 isFloat:True superAdj:0 isUniqu ...
 fovpushg 1 
 -- OI:invoke:magnitude:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "* 60" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"magnitude"off:1 size:0 isFlo ...
 -- rec: "magnitude" E: "* 60" isValueAssign: false
 -- $ObjectInvocation_Binary:loadArgs:staticOff:0 "* 60"
 -- $pattern:loadArgs:E:"* 60":descNo:0:top:0 "* :  |    %basic 112 |    in V:  ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"* 60" ActArg: "60" isValue: true
 -- $ObjectCall:gen: "60"
 -- $Invocation:gen: "60"
 -- needorigin:"60" 
 -- needOrigin:E:"60"  E.ATd:"integer: value |    %basic 1, 32 |    %globals |    ..." 
 -- LoadOrign:no:loadOrigin: "value |    %basic 1, 32 |    %globals |    %public |  ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "60" E: "60" isValueAssign: false
 -- $ConstLiteral:loadArgs: "60"
 -- invoke:after:loadArgsOf:"60" 
 -- $ConstLiteral:invoke: "60"
 pushc 60
 -- invoke:after:E.invoke:"60" 
 -- loadArgs:after:Qgen:"* 60" 
 -- formalArg:isPtn:"in V: var float" :isBasicVal:true:valueObj:true
 -- :actArg:"60" :isBasicVal:true
 -- 60ObjectCall
 -- convDone:false
 i2f
 -- end:loadArgs:NonVirt:"* 60" 
 -- invoke:after:loadArgsOf:"* 60" :Address:E:"magnitude"off:1 size:0 isFlo ...
 -- $ObjectInvocation_Binary:invoke: rec:"magnitude" "* 60"
 -- >top:0 descNo:0 
 -- E.ATd: "* " unique: false
 -- adr::Address:E:"magnitude"off:1 size:0 isFloat:True superAdj:0 isUnique ...
 -- $pattern:invoke: "* :  |    %basic 112 |    in V: var float |    out R: var f ..."
 -- bodyC:
 fmult
 -- OI:invoke:* 60:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"* 60" 
 -- loadArgs:after:Qgen:":= magnitude * 60" 
 -- vAssign:fArg:"in V: var Value" 
 -- BINGO
 -- aaaa: in V: var Value
 -- end:loadArgs:NonVirt:":= magnitude * 60" 
 -- invoke:after:loadArgsOf:":= magnitude * 60" :Address:E:"base"off:3 size ...
 -- $ObjectInvocation_Binary:invoke: rec:"base" ":= magnitude * 60"
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Address:E:"base"off:3 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "base" from: ":= magnitude * 60" 
 -- assign:dstDI :"out base: var BaseUnit" isUnitValueObj: false
 -- assign:arg: "magnitude * 60" lab:"ObjectCall" UnitValObj :false ptn: false
 --  float: true DataItem:false arg.super:magnitude * 60
 --  arg.super.ATd:"Invocation" "* :  |    %basic 112 |    in V: var float |    o ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:true
 --  arg.super.ATd.label: "pattern" 
 -- assign:ValueObj:isPtn: true size:2 
 -- :Address:E:"base"off:3 size:2 isFloat:False superAdj:0 isUnique:False i ...
 -- store::Address:E:"base"off:3 size:2 isFloat:False superAdj:0 isUnique:F ...
 -- isValue:true isAdr:true descNo: 0 
 -- Address:store::srcIsVal:false destIsVal:false mode:0 
 addOff 3
 vassign 2 0
 -- OI:invoke::= magnitude * 60:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= magnitude * 60" 
 L2:
 rtnInner
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:5 rTopMax:5
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 63 :top:1 
 -- GenClass:fromBase :varNo = 1 
 -- GenClass:fromBase:true -> var.genDone

class fromBase 63 1 65
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 -- origin.valueOff:store:2 
 store 2 originOff
 -- super fromBase
 -- vdt:b
 --  1:0 2:0 3:0 4:0
 -- vdt:c:innerInx: 1  descNo: 63 
 -- vdtAdd: inx=1 descInx=63
 pushThis 
 rpushg 1 iOrigin
 pushThis 
 pushg 2 
 toSuper 42
 -- $Signature:gen: "fromBase"
 rtnInner
DO:
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"magnitude := base / 60" 
 -- $ObjectCall:gen: "magnitude := base / 60"
 -- $Invocation:gen: descNo: 4 top: 1 "magnitude := base / 60"
 -- needorigin:"magnitude := base / 60" 
 -- needOrigin:E:":= base / 60"  E.ATd:":= :  |    %basic 8 |    in V: var Valu ..." 
 -- computeAdr: "magnitude := base / 60" 
 -- computeAdr:1 :rec:"none"  E:"magnitude" :Address:E:"none"off:0 size:0 i ...
 -- $ObjectInvocation_Unary:pushThis: "magnitude"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "magnitude"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:1 
 -- goOrigin:fromBase:encOG.IS.newOriginOff:1 :newOriginOff:1 
 -- origin.valueOff:load 2 
 rdouble
 rpushg 1 fromBase:origin
 rswap
 pushg 2 fromBase:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:1 "magnitude"
 -- $var:getAdr:,newOff:1,isValue:"True",A.isValue:"False" "magnitude: var  ..."
 --  A::Address:E:"magnitude"off:0 size:0 isFloat:False superAdj:0 isUnique ...  ...m ...
 -- value_prim:false
 -- Float
 -- before:floatTest: 
 -- getAdr:isfloat:magnitude: var Float A.isValue:true
 -- computeAdr:isFirst::Address:E:"magnitude"off:1 size:0 isFloat:True supe ...
 -- computeAdr:2 :rec:"magnitude"  E:":= base / 60" :Address:E:"magnitude"o ...
 -- computeAdr:isAssign:rec: "magnitude"  E:":= base / 60" 
 -- :Address:E:"magnitude"off:1 size:0 isFloat:True superAdj:0 isUnique:Fal ...
 -- computeAdr:isLast:E: ":= base / 60" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"magnitude"off:1 size:0 isFlo ...
 -- rec: "magnitude" E: ":= base / 60" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:1 ":= base / 60"
 -- $pattern:loadArgs:E:":= base / 60":descNo:4:top:1 ":= :  |    %basic 8 |    ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= base / 60" ActArg: "base / 60" isValue: false
 -- $ObjectCall:gen: "base / 60"
 -- $Invocation:gen: descNo: 0 top: 0 "base / 60"
 -- needorigin:"base / 60" 
 -- needOrigin:E:"/ 60"  E.ATd:"/ :  |    %basic 121 |    in V: var float |    ou ..." 
 -- computeAdr: "base / 60" 
 -- computeAdr:1 :rec:"none"  E:"base" :Address:E:"none"off:0 size:0 isFloa ...
 -- $ObjectInvocation_Unary:pushThis: "base"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "base"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "base"
 -- $var:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "in base: var fl ..."
 --  A::Address:E:"base"off:0 size:0 isFloat:False superAdj:0 isUnique:Fals ...  ...i ...
 -- value_prim:false
 -- float
 -- before:floatTest: 
 -- getAdr:isfloat:in base: var float A.isValue:true
 -- computeAdr:isFirst::Address:E:"base"off:3 size:0 isFloat:True superAdj: ...
 -- computeAdr:2 :rec:"base"  E:"/ 60" :Address:E:"base"off:3 size:0 isFloa ...
 -- E:notAssign:/ 60
 -- $ObjectInvocation_Binary:getAdr::superAdj:0:on:0 "/ 60"
 -- $pattern:getAdr: "/ :  |    %basic 121 |    in V: var float |    out R: var f ..."
 -- :Address:E:"base"off:3 size:0 isFloat:True superAdj:0 isUnique:False is ...
 -- ptn.ssUnitValueObj:false isFloat:true
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "base"
 -- $var:loadArgs: "in base: var float"
 -- $ObjectInvocation_Unary:invoke: rec:"base" "base"
 -- E.ATd: "/ " unique: false
 -- adr::Address:E:"base"off:3 size:0 isFloat:True superAdj:0 isUnique:Fals ...
 -- $var:invoke: newOff:3 "in base: var float"
 -- load::Address:E:"base"off:3 size:0 isFloat:True superAdj:0 isUnique:Fal ...
 -- isFloat: true
 fpushg 3 
 -- OI:invoke:base:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "/ 60" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"base"off:3 size:0 isFloat:Tr ...
 -- rec: "base" E: "/ 60" isValueAssign: false
 -- $ObjectInvocation_Binary:loadArgs:staticOff:0 "/ 60"
 -- $pattern:loadArgs:E:"/ 60":descNo:0:top:0 "/ :  |    %basic 121 |    in V:  ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"/ 60" ActArg: "60" isValue: true
 -- loadArgs:not:*: formalArgOf:"/ 60"  isCompositeValueObj:false
 -- $ObjectCall:gen: "60"
 -- $Invocation:gen: "60"
 -- needorigin:"60" 
 -- needOrigin:E:"60"  E.ATd:"integer: value |    %basic 1, 32 |    %globals |    ..." 
 -- LoadOrign:no:loadOrigin: "value |    %basic 1, 32 |    %globals |    %public |  ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "60" E: "60" isValueAssign: false
 -- $ConstLiteral:loadArgs: "60"
 -- invoke:after:loadArgsOf:"60" 
 -- $ConstLiteral:invoke: "60"
 pushc 60
 -- invoke:after:E.invoke:"60" 
 -- loadArgs:after:Qgen:"/ 60" 
 -- formalArg:isPtn:"in V: var float" :isBasicVal:true:valueObj:true
 -- :actArg:"60" :isBasicVal:true
 -- 60ObjectCall
 -- convDone:false
 i2f
 -- end:loadArgs:NonVirt:"/ 60" 
 -- invoke:after:loadArgsOf:"/ 60" :Address:E:"base"off:3 size:0 isFloat:Tr ...
 -- $ObjectInvocation_Binary:invoke: rec:"base" "/ 60"
 -- >top:0 descNo:0 
 -- E.ATd: "/ " unique: false
 -- adr::Address:E:"base"off:3 size:0 isFloat:True superAdj:0 isUnique:Fals ...
 -- $pattern:invoke: "/ :  |    %basic 121 |    in V: var float |    out R: var f ..."
 -- bodyC:
 fdiv
 -- OI:invoke:/ 60:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"/ 60" 
 -- loadArgs:after:Qgen:":= base / 60" 
 -- vAssign:fArg:"in V: var Value" 
 -- BINGO
 -- aaaa: in V: var Value
 -- end:loadArgs:NonVirt:":= base / 60" 
 -- invoke:after:loadArgsOf:":= base / 60" :Address:E:"magnitude"off:1 size ...
 -- $ObjectInvocation_Binary:invoke: rec:"magnitude" ":= base / 60"
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Address:E:"magnitude"off:1 size:0 isFloat:True superAdj:0 isUnique ...
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "magnitude" from: ":= base / 60" 
 -- assign:dstDI :"magnitude: var Float" isUnitValueObj: false
 -- assign:arg: "base / 60" lab:"ObjectCall" UnitValObj :false ptn: false
 --  float: true DataItem:false arg.super:base / 60
 --  arg.super.ATd:"Invocation" "/ :  |    %basic 121 |    in V: var float |    o ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:true
 --  arg.super.ATd.label: "pattern" 
 -- assign:simple value: 
 -- :Address:E:"magnitude"off:1 size:0 isFloat:True superAdj:0 isUnique:Fal ...
 -- store::Address:E:"magnitude"off:1 size:0 isFloat:True superAdj:0 isUniq ...
 -- isValue:true isAdr:false descNo: 0 
 -- Address:store:originIsValue:
 fovstoreg 1 
 -- OI:invoke::= base / 60:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= base / 60" 
 L2:
 rtnInner
 end OSDV:0 objSize:4 isIndexed:0  vTop:-2 vTopMax:0 rTop:5 rTopMax:5
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 64 :top:1 
 -- GenClass:print :varNo = 1 
 -- GenClass:print:true -> var.genDone

class print 64 1 65
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 -- origin.valueOff:store:2 
 store 2 originOff
 -- super print
 -- vdt:b
 --  1:0 2:0 3:0 4:0
 -- vdt:c:innerInx: 1  descNo: 64 
 -- vdtAdd: inx=1 descInx=64
 pushThis 
 rpushg 1 iOrigin
 pushThis 
 pushg 2 
 toSuper 44
 -- $Signature:gen: "print"
 rtnInner
DO:
 mvStack 
 L1:
 -- genclass:Qgen:stmt:""Minutes".print" 
 -- $ObjectCall:gen: ""Minutes".print"
 -- $Invocation:gen: descNo: 33 top: 1 ""Minutes".print"
 -- needorigin:""Minutes".print" 
 -- needOrigin:E:"print"  E.ATd:"print:  |    @for 1 :to length  |    :do  |      ..." 
 -- computeAdr: ""Minutes".print" 
 -- computeAdr:1 :rec:"none"  E:""Minutes"" :Address:E:"none"off:0 size:0 i ...
 -- $String::pushThis: ""Minutes""
 -- $String::loadOrigin: ""Minutes""
 -- StringObj:loadOrigin:"Minutes"
 -- $String::getAdr: ""Minutes""
 -- computeAdr:isFirst::Address:E:""Minutes""off:0 size:0 isFloat:False sup ...
 -- computeAdr:2 :rec:""Minutes""  E:"print" :Address:E:""Minutes""off:0 si ...
 -- E:notAssign:print
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "print"
 -- $pattern:getAdr: "print:  |    @for 1 :to length  |    :do  |       put(@get  ..."
 -- :Address:E:""Minutes""off:0 size:0 isFloat:False superAdj:0 isUnique:Fa ...
 -- ptn.ssUnitValueObj:false isFloat:false
 -- $String::loadArgs: ""Minutes""
 -- $String::invoke: ""Minutes""
 -- Pattern:markForCodeGen:+ :  |    in S: ref String |    out V: ref String |    ...
 pushText Minutes
 -- computeAdr:isLast:E: "print" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:""Minutes""off:0 size:0 isFlo ...
 -- rec: ""Minutes"" E: "print" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "print"
 -- $pattern:loadArgs:E:"print":descNo:33:top:1 "print:  |    @for 1 :to leng ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"print" :Address:E:""Minutes""off:0 size:0 isFl ...
 -- $ObjectInvocation_Unary:invoke: rec:""Minutes"" "print"
 -- >top:1 descNo:33 
 -- E.ATd: "print" unique: false
 -- adr::Address:E:""Minutes""off:0 size:0 isFloat:False superAdj:0 isUniqu ...
 -- $pattern:invoke: "print:  |    @for 1 :to length  |    :do  |       put(@get  ..."
 -- Pattern:invoke:descNo:33  top:1  rec:""Minutes"" 
 -- ComputeVariantX
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- <>var
 -- rec:module or pattern:"print"  descno: 33  top: 1 "@for 1 :to length  | : ..." 
 -- ptn:invoke::isValObj:false:rtnValObj:false:"print:  |    @for 1 :to lengt ..." 
 -- rec=E:false:rec:""Minutes"" 
 -- kuk:obj:rec.ATd:"String:  |    %OSDvisibility disguised |    %basic 5 |    %i ..." 
 invoke print 33 0 0
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:false""Minutes"" 
 rpop
 -- OI:invoke:print:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"print" 
 L2:
 rtnInner
 end OSDV:0 objSize:2 isIndexed:0  vTop:-1 vTopMax:0 rTop:1 rTopMax:2
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 65 :top:1 
 -- GenClass:Minutes :varNo = 1 
 -- GenClass:Minutes:true -> var.genDone

class Minutes 65 0 60
 -- Store itemArgs
 -- super Unit
 -- vdt:b
 --  1:45 2:45 3:45 4:41 5:42 6:44
 -- Super:sig not none
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "Unit"
 -- $pattern:loadArgs:E:"Unit":descNo:45:top:1 "Unit: Value |    %unit "U" |    ..."
 -- isValueAssign: false
 toSuper 45
 -- $Signature:gen: "Minutes"
 -- $pattern:gen: "thisUnit:: Minutes"
 -- vdtTable: off: 1  descNo: 9 
 -- $pattern:gen: "toBase::  |    base := magnitude * 60"
 -- vdt:f:62 getDescNo:62 
 -- vdtAdd: inx=4 descInx=62
 -- $pattern:gen: "fromBase::  |    magnitude := base / 60"
 -- vdt:f:63 getDescNo:63 
 -- vdtAdd: inx=5 descInx=63
 -- $pattern:gen: "print::  |    "Minutes".print"
 -- vdt:f:64 getDescNo:64 
 -- vdtAdd: inx=6 descInx=64
 rtnInner
DO:
 L1:
 -- genclass:Qgen:stmt:"%unit "min", 60" 
 -- $Property:gen: "%unit "min", 60"
 -- genclass:Qgen:stmt:"%Public" 
 -- $Property:gen: "%Public"
 L2:
 rtnInner
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- Virtual
 -- genClass:BindVirtuals:descNo:100 

class Vstub#Minutes#9 100 0 0
 -- Load origin:OG.isVirtualArg:false
 -- goOrigin:A:1 
 -- OBS! Qalloc, originOff = 0 
 -- ComputeVariant:A:Minutes
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Unit
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Value
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is not new:
 -- ComputeVariant:B:Minutes
 -- goOrigin:Minutes:encOG.IS.newOriginOff:0 :newOriginOff:0 
 rpushg 0 Minutes:origin
 -- OG.super.on/descNo:1 65 
 invoke Minutes 65 0 1
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- vdt:a:descNo65 
 -- Virtual
 -- Virtual
 -- Virtual
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 66 :top:1 
 -- GenClass:print :varNo = 1 
 -- GenClass:print:true -> var.genDone

class print 66 1 67
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 -- origin.valueOff:store:2 
 store 2 originOff
 -- super print
 -- vdt:b
 --  1:0 2:0 3:0 4:0
 -- vdt:c:innerInx: 1  descNo: 66 
 -- vdtAdd: inx=1 descInx=66
 pushThis 
 rpushg 1 iOrigin
 pushThis 
 pushg 2 
 toSuper 44
 -- $Signature:gen: "print"
 rtnInner
DO:
 mvStack 
 L1:
 -- genclass:Qgen:stmt:""MperS".print" 
 -- $ObjectCall:gen: ""MperS".print"
 -- $Invocation:gen: descNo: 33 top: 1 ""MperS".print"
 -- needorigin:""MperS".print" 
 -- needOrigin:E:"print"  E.ATd:"print:  |    @for 1 :to length  |    :do  |      ..." 
 -- computeAdr: ""MperS".print" 
 -- computeAdr:1 :rec:"none"  E:""MperS"" :Address:E:"none"off:0 size:0 isF ...
 -- $String::pushThis: ""MperS""
 -- $String::loadOrigin: ""MperS""
 -- StringObj:loadOrigin:"MperS"
 -- $String::getAdr: ""MperS""
 -- computeAdr:isFirst::Address:E:""MperS""off:0 size:0 isFloat:False super ...
 -- computeAdr:2 :rec:""MperS""  E:"print" :Address:E:""MperS""off:0 size:0 ...
 -- E:notAssign:print
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "print"
 -- $pattern:getAdr: "print:  |    @for 1 :to length  |    :do  |       put(@get  ..."
 -- :Address:E:""MperS""off:0 size:0 isFloat:False superAdj:0 isUnique:Fals ...
 -- ptn.ssUnitValueObj:false isFloat:false
 -- $String::loadArgs: ""MperS""
 -- $String::invoke: ""MperS""
 -- Pattern:markForCodeGen:+ :  |    in S: ref String |    out V: ref String |    ...
 pushText MperS
 -- computeAdr:isLast:E: "print" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:""MperS""off:0 size:0 isFloat ...
 -- rec: ""MperS"" E: "print" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "print"
 -- $pattern:loadArgs:E:"print":descNo:33:top:1 "print:  |    @for 1 :to leng ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"print" :Address:E:""MperS""off:0 size:0 isFloa ...
 -- $ObjectInvocation_Unary:invoke: rec:""MperS"" "print"
 -- >top:1 descNo:33 
 -- E.ATd: "print" unique: false
 -- adr::Address:E:""MperS""off:0 size:0 isFloat:False superAdj:0 isUnique: ...
 -- $pattern:invoke: "print:  |    @for 1 :to length  |    :do  |       put(@get  ..."
 -- Pattern:invoke:descNo:33  top:1  rec:""MperS"" 
 -- ComputeVariantX
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- <>var
 -- rec:module or pattern:"print"  descno: 33  top: 1 "@for 1 :to length  | : ..." 
 -- ptn:invoke::isValObj:false:rtnValObj:false:"print:  |    @for 1 :to lengt ..." 
 -- rec=E:false:rec:""MperS"" 
 -- kuk:obj:rec.ATd:"String:  |    %OSDvisibility disguised |    %basic 5 |    %i ..." 
 invoke print 33 0 0
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:false""MperS"" 
 rpop
 -- OI:invoke:print:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"print" 
 L2:
 rtnInner
 end OSDV:0 objSize:2 isIndexed:0  vTop:-1 vTopMax:0 rTop:1 rTopMax:2
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 67 :top:1 
 -- GenClass:MperS :varNo = 1 
 -- GenClass:MperS:true -> var.genDone

class MperS 67 0 68
 -- Store itemArgs
 -- super Unit
 -- vdt:b
 --  1:45 2:45 3:45 4:41 5:42 6:44
 -- Super:sig not none
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "Unit"
 -- $pattern:loadArgs:E:"Unit":descNo:45:top:1 "Unit: Value |    %unit "U" |    ..."
 -- isValueAssign: false
 toSuper 45
 -- $Signature:gen: "MperS"
 -- $pattern:gen: "thisUnit:: MperS"
 -- vdtTable: off: 1  descNo: 2 
 -- $pattern:gen: "print::  |    "MperS".print"
 -- vdt:f:66 getDescNo:66 
 -- vdtAdd: inx=6 descInx=66
 rtnInner
DO:
 L1:
 -- genclass:Qgen:stmt:"%unit "m*s^-1", "m*s^-1"" 
 -- $Property:gen: "%unit "m*s^-1", "m*s^-1""
 -- genclass:Qgen:stmt:"%Public" 
 -- $Property:gen: "%Public"
 L2:
 rtnInner
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- Virtual
 -- genClass:BindVirtuals:descNo:101 

class Vstub#MperS#2 101 0 0
 -- Load origin:OG.isVirtualArg:false
 -- goOrigin:A:1 
 -- OBS! Qalloc, originOff = 0 
 -- ComputeVariant:A:MperS
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Unit
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Value
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is not new:
 -- ComputeVariant:B:MperS
 -- goOrigin:MperS:encOG.IS.newOriginOff:0 :newOriginOff:0 
 rpushg 0 MperS:origin
 -- OG.super.on/descNo:1 67 
 invoke MperS 67 0 1
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- vdt:a:descNo67 
 -- Virtual
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 68 :top:1 
 -- GenClass:Velocity :varNo = 1 
 -- GenClass:Velocity:true -> var.genDone

class Velocity 68 1 69
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 -- super Dimension
 -- vdt:b
 --  1:45 2:46 3:45 4:45 5:45 6:47
 -- computeAdr: "Dimension" 
 -- computeAdr:1 :rec:"none"  E:"Dimension" :Address:E:"none"off:0 size:0 i ...
 -- $ObjectInvocation_Unary:pushThis: "Dimension"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "Dimension"
 -- AdjustOrigin:originOff: 1
 rpushg 1 origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:1:on:0 "Dimension"
 -- $pattern:getAdr: "Dimension:  |    %public |    BaseUnit:< Unit |    Unit: Va ..."
 -- :Address:E:"Dimension"off:0 size:0 isFloat:False superAdj:1 isUnique:Fa ...
 -- computeAdr:isFirst::Address:E:"Dimension"off:0 size:0 isFloat:False sup ...
 -- computeAdr:isLast:E: "Dimension" 
 -- genClass:after:ComputeAdr:"Dimension" :Address:E:"Dimension"off:0 size: ...
 -- Super:sig none
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "Dimension"
 -- $pattern:loadArgs:E:"Dimension":descNo:48:top:1 "Dimension:  |    %public ..."
 -- isValueAssign: false
 toSuper 48
 -- $pattern:gen: "shortName::  |    T := "V""
 -- vdt:f:61 getDescNo:61 
 -- vdtAdd: inx=2 descInx=61
 -- $pattern:gen: "MultArgL:: Length.Meter"
 -- vdtTable: off: 3  descNo: 10 
 -- $pattern:gen: "MultArgR:: Time.Minutes"
 -- vdtTable: off: 4  descNo: 11 
 -- $pattern:gen: "MultRes:: MperS"
 -- vdtTable: off: 5  descNo: 12 
 rtnInner
DO:
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%Public" 
 -- $Property:gen: "%Public"
 L2:
 rtnInner
 end OSDV:0 objSize:1 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- Virtual
 -- Virtual
 -- genClass:BindVirtuals:descNo:102 

class Vstub#S#10 102 1 0
 -- Load origin:OG.isVirtualArg:false
 -- OG.super.on/descNo:0 56 
 invoke S 56 0 1
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- vdt:a:descNo68 
 -- Virtual
 -- genClass:BindVirtuals:descNo:103 

class Vstub#S#11 103 1 0
 -- Load origin:OG.isVirtualArg:false
 -- OG.super.on/descNo:0 65 
 invoke S 65 0 1
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- vdt:a:descNo68 
 -- Virtual
 -- genClass:BindVirtuals:descNo:104 

class Vstub#S#12 104 1 0
 -- Load origin:OG.isVirtualArg:false
 -- OG.super.on/descNo:0 67 
 invoke S 67 0 1
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- vdt:a:descNo68 
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 69 :top:1 
 -- GenClass:Dimensions :varNo = 1 
 -- GenClass:Dimensions:true -> var.genDone

class Dimensions 69 1 70
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $ModuleItem:gen: "--Acceleration"
 -- $ModuleItem:gen: "--AmountOfSubstance"
 -- $ModuleItem:gen: "--Area"
 -- ModuleItem:gen Area
 -- $obj:gen: "Area: obj Dimension |    %Public |    SquareMeter: Unit |       %u ..."
 -- $ObjectGenerator:gen:"Area"singular! staticOff: 2 descNo: 50 top:1 "Dim ..."
 -- OG:gen:super:"Dimension" superDescNo:48 super.OG.top:1 
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 50  Area
 invoke Area 50 2 1
 rpop
 -- $ModuleItem:gen: "--ElectricCurrent"
 -- $ModuleItem:gen: "--Energy"
 -- $ModuleItem:gen: "--Force"
 -- $ModuleItem:gen: "--Length"
 -- ModuleItem:gen Length
 -- $obj:gen: "Length: obj Dimension |    %Public |    BaseUnit:: Meter |    Foot ..."
 -- $ObjectGenerator:gen:"Length"singular! staticOff: 3 descNo: 58 top:1 "D ..."
 -- OG:gen:super:"Dimension" superDescNo:48 super.OG.top:1 
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 58  Length
 invoke Length 58 3 1
 rpop
 -- $ModuleItem:gen: "--LuminousIntensity"
 -- $ModuleItem:gen: "--MagneticFluxDensity"
 -- $ModuleItem:gen: "--Mass"
 -- ModuleItem:gen Mass
 -- $obj:gen: "Mass: obj Dimension |    %public |    KiloGram: Unit |       %unit ..."
 -- $ObjectGenerator:gen:"Mass"singular! staticOff: 4 descNo: 59 top:1 "Dim ..."
 -- OG:gen:super:"Dimension" superDescNo:48 super.OG.top:1 
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 59  Mass
 invoke Mass 59 4 1
 rpop
 -- $ModuleItem:gen: "--MeterPowerN"
 -- $ModuleItem:gen: "--Temperature"
 -- $ModuleItem:gen: "--ThermodynamicTemperature"
 -- $ModuleItem:gen: "--Time"
 -- ModuleItem:gen Time
 -- $obj:gen: "Time: obj Dimension -- 5:  |    %Public |    Second: Unit |        ..."
 -- $ObjectGenerator:gen:"Time"singular! staticOff: 5 descNo: 60 top:1 "Dim ..."
 -- OG:gen:super:"Dimension" superDescNo:48 super.OG.top:1 
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 60  Time
 invoke Time 60 5 1
 rpop
 -- $ModuleItem:gen: "--Velocity"
 -- ModuleItem:gen Velocity
 -- $obj:gen: "Velocity: obj Dimension |    %Public |    MperS: Unit |       %uni ..."
 -- $ObjectGenerator:gen:"Velocity"singular! staticOff: 6 descNo: 68 top:1  ...
 -- OG:gen:super:"Dimension" superDescNo:48 super.OG.top:1 
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 68  Velocity
 invoke Velocity 68 6 1
 rpop
 -- $ModuleItem:gen: "--Volume"
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%domain_boundary" 
 -- $Property:gen: "%domain_boundary"
 -- genclass:Qgen:stmt:"%public" 
 -- $Property:gen: "%public"
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:6 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 70 :top:1 
 -- GenClass:LIB :varNo = 1 
 -- GenClass:LIB:true -> var.genDone

class LIB 70 1 85
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $var:gen: "x_dummy_LIB: var integer"
 -- DI:isConst:false:isBasicValue:true:primNo:1 
 -- OGqual:integer:OGqual.isBasicValue:true:OGqual.isValueObj:true
 -- $ModuleItem:gen: "--Associations"
 -- ModuleItem:gen Associations
 -- $obj:gen: "Associations: obj  |    %include Containers |    %Public |    Asso ..."
 -- $ObjectGenerator:gen:"Associations"singular! staticOff: 3 descNo: 8 top ...
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 8  Associations
 invoke Associations 8 3 1
 rpop
 -- $ModuleItem:gen: "--BasicIO"
 -- ModuleItem:gen BasicIO
 -- $obj:gen: "BasicIO: obj  |    %Public |    Lock:  |       dummy: var integer |  ..."
 -- $ObjectGenerator:gen:"BasicIO"singular! staticOff: 4 descNo: 12 top:1 " ..."
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 12  BasicIO
 invoke BasicIO 12 4 1
 rpop
 -- $ModuleItem:gen: "--BasicSystem"
 -- $ModuleItem:gen: "--Complex"
 -- $ModuleItem:gen: "--Containers"
 -- ModuleItem:gen Containers
 -- $obj:gen: "Containers: obj  |    Container:  |       in elm:< Object |        ..."
 -- $ObjectGenerator:gen:"Containers"singular! staticOff: 5 descNo: 39 top: ...
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 39  Containers
 invoke Containers 39 5 1
 rpop
 -- $ModuleItem:gen: "--Dimensions"
 -- ModuleItem:gen Dimensions
 -- $obj:gen: "Dimensions: obj  |    %domain_boundary |    %public |    Dimension ..."
 -- $ObjectGenerator:gen:"Dimensions"singular! staticOff: 6 descNo: 69 top: ...
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 69  Dimensions
 invoke Dimensions 69 6 1
 rpop
 -- $ModuleItem:gen: "--EMC2array"
 -- $ModuleItem:gen: "--Embedded"
 -- $ModuleItem:gen: "--FileSys"
 -- $ModuleItem:gen: "--ForkJoinSystem"
 -- $ModuleItem:gen: "--MetaSystem"
 -- $ModuleItem:gen: "--MonitorSystem"
 -- $ModuleItem:gen: "--NonBlockingIO"
 -- $ModuleItem:gen: "--SimpleConcurrentProcesses"
 -- $ModuleItem:gen: "--Socket"
 -- $ModuleItem:gen: "--SocketSystem"
 -- $ModuleItem:gen: "--String"
 -- ModuleItem:gen String
 -- $obj:gen: "String: obj  |    %public |    String:  |       %OSDvisibility dis ..."
 -- $ObjectGenerator:gen:"String"singular! staticOff: 7 descNo: 16 top:1 "% ..."
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 16  String
 invoke String 16 7 1
 rpop
 -- $ModuleItem:gen: "--Units"
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%include BETA" 
 -- $Property:gen: "%include BETA"
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:7 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 71 :top:1 
 -- GenClass:print :varNo = 1 
 -- GenClass:print:true -> var.genDone

class print 71 1 72
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 -- origin.valueOff:store:2 
 store 2 originOff
 -- super print
 -- vdt:b
 --  1:0 2:0 3:0 4:0
 -- vdt:c:innerInx: 1  descNo: 71 
 -- vdtAdd: inx=1 descInx=71
 pushThis 
 rpushg 1 iOrigin
 pushThis 
 pushg 2 
 toSuper 44
 -- $Signature:gen: "print"
 rtnInner
DO:
 mvStack 
 L1:
 -- genclass:Qgen:stmt:""kg".print" 
 -- $ObjectCall:gen: ""kg".print"
 -- $Invocation:gen: descNo: 33 top: 1 ""kg".print"
 -- needorigin:""kg".print" 
 -- needOrigin:E:"print"  E.ATd:"print:  |    @for 1 :to length  |    :do  |      ..." 
 -- computeAdr: ""kg".print" 
 -- computeAdr:1 :rec:"none"  E:""kg"" :Address:E:"none"off:0 size:0 isFloa ...
 -- $String::pushThis: ""kg""
 -- $String::loadOrigin: ""kg""
 -- StringObj:loadOrigin:"kg"
 -- $String::getAdr: ""kg""
 -- computeAdr:isFirst::Address:E:""kg""off:0 size:0 isFloat:False superAdj ...
 -- computeAdr:2 :rec:""kg""  E:"print" :Address:E:""kg""off:0 size:0 isFlo ...
 -- E:notAssign:print
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "print"
 -- $pattern:getAdr: "print:  |    @for 1 :to length  |    :do  |       put(@get  ..."
 -- :Address:E:""kg""off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...
 -- ptn.ssUnitValueObj:false isFloat:false
 -- $String::loadArgs: ""kg""
 -- $String::invoke: ""kg""
 -- Pattern:markForCodeGen:+ :  |    in S: ref String |    out V: ref String |    ...
 pushText kg
 -- computeAdr:isLast:E: "print" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:""kg""off:0 size:0 isFloat:Fa ...
 -- rec: ""kg"" E: "print" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "print"
 -- $pattern:loadArgs:E:"print":descNo:33:top:1 "print:  |    @for 1 :to leng ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"print" :Address:E:""kg""off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:invoke: rec:""kg"" "print"
 -- >top:1 descNo:33 
 -- E.ATd: "print" unique: false
 -- adr::Address:E:""kg""off:0 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- $pattern:invoke: "print:  |    @for 1 :to length  |    :do  |       put(@get  ..."
 -- Pattern:invoke:descNo:33  top:1  rec:""kg"" 
 -- ComputeVariantX
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- <>var
 -- rec:module or pattern:"print"  descno: 33  top: 1 "@for 1 :to length  | : ..." 
 -- ptn:invoke::isValObj:false:rtnValObj:false:"print:  |    @for 1 :to lengt ..." 
 -- rec=E:false:rec:""kg"" 
 -- kuk:obj:rec.ATd:"String:  |    %OSDvisibility disguised |    %basic 5 |    %i ..." 
 invoke print 33 0 0
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:false""kg"" 
 rpop
 -- OI:invoke:print:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"print" 
 L2:
 rtnInner
 end OSDV:0 objSize:2 isIndexed:0  vTop:-1 vTopMax:0 rTop:1 rTopMax:2
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 72 :top:1 
 -- GenClass:KiloGram :varNo = 1 
 -- GenClass:KiloGram:true -> var.genDone

class KiloGram 72 0 59
 -- Store itemArgs
 -- super Unit
 -- vdt:b
 --  1:45 2:45 3:45 4:41 5:42 6:44
 -- Super:sig not none
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "Unit"
 -- $pattern:loadArgs:E:"Unit":descNo:45:top:1 "Unit: Value |    %unit "U" |    ..."
 -- isValueAssign: false
 toSuper 45
 -- $Signature:gen: "KiloGram"
 -- $pattern:gen: "thisUnit:: KiloGram"
 -- vdtTable: off: 1  descNo: 13 
 -- $pattern:gen: "print::  |    "kg".print"
 -- vdt:f:71 getDescNo:71 
 -- vdtAdd: inx=6 descInx=71
 rtnInner
DO:
 L1:
 -- genclass:Qgen:stmt:"%unit "kg"" 
 -- $Property:gen: "%unit "kg""
 -- genclass:Qgen:stmt:"%public" 
 -- $Property:gen: "%public"
 L2:
 rtnInner
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- Virtual
 -- genClass:BindVirtuals:descNo:105 

class Vstub#KiloGram#13 105 0 0
 -- Load origin:OG.isVirtualArg:false
 -- goOrigin:A:1 
 -- OBS! Qalloc, originOff = 0 
 -- ComputeVariant:A:KiloGram
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Unit
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Value
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is not new:
 -- ComputeVariant:B:KiloGram
 -- goOrigin:KiloGram:encOG.IS.newOriginOff:0 :newOriginOff:0 
 rpushg 0 KiloGram:origin
 -- OG.super.on/descNo:1 72 
 invoke KiloGram 72 0 1
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- vdt:a:descNo72 
 -- Virtual
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 73 :top:1 
 -- GenClass:toBase :varNo = 1 
 -- GenClass:toBase:true -> var.genDone

class toBase 73 1 76
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 -- origin.valueOff:store:2 
 store 2 originOff
 -- super toBase
 -- vdt:b
 --  1:0 2:0 3:0 4:0
 -- vdt:c:innerInx: 1  descNo: 73 
 -- vdtAdd: inx=1 descInx=73
 pushThis 
 rpushg 1 iOrigin
 pushThis 
 pushg 2 
 toSuper 41
 -- $Signature:gen: "toBase"
 rtnInner
DO:
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"base := magnitude * 9460000000000000.0" 
 -- $ObjectCall:gen: "base := magnitude * 9460000000000000.0"
 -- $Invocation:gen: descNo: 4 top: 1 "base := magnitude * 9460000000000000 ..."
 -- needorigin:"base := magnitude * 9460000000000000.0" 
 -- needOrigin:E:":= magnitude * 9460000000000000.0"  E.ATd:":= :  |    %basi ..." 
 -- computeAdr: "base := magnitude * 9460000000000000.0" 
 -- computeAdr:1 :rec:"none"  E:"base" :Address:E:"none"off:0 size:0 isFloa ...
 -- $ObjectInvocation_Unary:pushThis: "base"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "base"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "base"
 -- $var:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "out base: var B ..."
 --  A::Address:E:"base"off:0 size:0 isFloat:False superAdj:0 isUnique:Fals ...  ...o ...
 -- value_prim:false
 -- BaseUnit
 -- before:floatTest: 
 -- computeAdr:isFirst::Address:E:"base"off:3 size:0 isFloat:False superAdj ...
 -- computeAdr:2 :rec:"base"  E:":= magnitude * 9460000000000000.0" :Addres ...
 -- computeAdr:isAssign:rec: "base"  E:":= magnitude * 9460000000000000.0" 
 -- :Address:E:"base"off:3 size:0 isFloat:False superAdj:0 isUnique:False i ...
 -- computeAdr:isLast:E: ":= magnitude * 9460000000000000.0" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"base"off:3 size:0 isFloat:Fa ...
 -- rec: "base" E: ":= magnitude * 9460000000000000.0" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:3 ":= magnitude * 946000000 ..."
 -- $pattern:loadArgs:E:":= magnitude * 9460000000000000.0":descNo:4:top:1  ...
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= magnitude * 9460000000000000.0" ActArg: "magnitude ..." i ...false
 -- $ObjectCall:gen: "magnitude * 9460000000000000.0"
 -- $Invocation:gen: descNo: 0 top: 0 "magnitude * 9460000000000000.0"
 -- needorigin:"magnitude * 9460000000000000.0" 
 -- needOrigin:E:"* 9460000000000000.0"  E.ATd:"* :  |    %basic 112 |    in V: ..." 
 -- computeAdr: "magnitude * 9460000000000000.0" 
 -- computeAdr:1 :rec:"none"  E:"magnitude" :Address:E:"none"off:0 size:0 i ...
 -- $ObjectInvocation_Unary:pushThis: "magnitude"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "magnitude"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:1 
 -- goOrigin:toBase:encOG.IS.newOriginOff:1 :newOriginOff:1 
 -- origin.valueOff:load 2 
 rdouble
 rpushg 1 toBase:origin
 rswap
 pushg 2 toBase:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:1 "magnitude"
 -- $var:getAdr:,newOff:1,isValue:"True",A.isValue:"False" "magnitude: var  ..."
 --  A::Address:E:"magnitude"off:0 size:0 isFloat:False superAdj:0 isUnique ...  ...m ...
 -- value_prim:false
 -- Float
 -- before:floatTest: 
 -- getAdr:isfloat:magnitude: var Float A.isValue:true
 -- computeAdr:isFirst::Address:E:"magnitude"off:1 size:0 isFloat:True supe ...
 -- computeAdr:2 :rec:"magnitude"  E:"* 9460000000000000.0" :Address:E:"mag ..."
 -- E:notAssign:* 9460000000000000.0
 -- $ObjectInvocation_Binary:getAdr::superAdj:0:on:0 "* 9460000000000000.0" ...
 -- $pattern:getAdr: "* :  |    %basic 112 |    in V: var float |    out R: var f ..."
 -- :Address:E:"magnitude"off:1 size:0 isFloat:True superAdj:0 isUnique:Fal ...
 -- ptn.ssUnitValueObj:false isFloat:true
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "magnitude"
 -- $var:loadArgs: "magnitude: var Float"
 -- $ObjectInvocation_Unary:invoke: rec:"magnitude" "magnitude"
 -- E.ATd: "* " unique: false
 -- adr::Address:E:"magnitude"off:1 size:0 isFloat:True superAdj:0 isUnique ...
 -- $var:invoke: newOff:1 "magnitude: var Float"
 -- load::Address:E:"magnitude"off:1 size:0 isFloat:True superAdj:0 isUniqu ...
 fovpushg 1 
 -- OI:invoke:magnitude:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "* 9460000000000000.0" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"magnitude"off:1 size:0 isFlo ...
 -- rec: "magnitude" E: "* 9460000000000000.0" isValueAssign: false
 -- $ObjectInvocation_Binary:loadArgs:staticOff:0 "* 9460000000000000.0"
 -- $pattern:loadArgs:E:"* 9460000000000000.0":descNo:0:top:0 "* :  |    %bas ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"* 9460000000000000.0" ActArg: "9460000000000000.0" is ...true
 -- $ObjectCall:gen: "9460000000000000.0"
 -- $Invocation:gen: "9460000000000000.0"
 -- needorigin:"9460000000000000.0" 
 -- needOrigin:E:"9460000000000000.0"  E.ATd:"float: Value |    %globals |    % ..." 
 -- LoadOrign:no:loadOrigin: "Value |    %globals |    %basic 9 |    _thisBasicVa ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "9460000000000000.0" E: "9460000000000000.0" isValueAssign: false
 -- $FloatLiteral:loadArgs: "9460000000000000.0"
 -- invoke:after:loadArgsOf:"9460000000000000.0" 
 -- $FloatLiteral:invoke: "9460000000000000.0"
 pushFloatConst 9460000000000000.000000
 -- invoke:after:E.invoke:"9460000000000000.0" 
 -- loadArgs:after:Qgen:"* 9460000000000000.0" 
 -- formalArg:isPtn:"in V: var float" :isBasicVal:true:valueObj:true
 -- :actArg:"9460000000000000.0" :isBasicVal:true
 -- 9460000000000000.0ObjectCall
 -- end:loadArgs:NonVirt:"* 9460000000000000.0" 
 -- invoke:after:loadArgsOf:"* 9460000000000000.0" :Address:E:"magnitude"of ...
 -- $ObjectInvocation_Binary:invoke: rec:"magnitude" "* 9460000000000000.0" ...
 -- >top:0 descNo:0 
 -- E.ATd: "* " unique: false
 -- adr::Address:E:"magnitude"off:1 size:0 isFloat:True superAdj:0 isUnique ...
 -- $pattern:invoke: "* :  |    %basic 112 |    in V: var float |    out R: var f ..."
 -- bodyC:
 fmult
 -- OI:invoke:* 9460000000000000.0:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"* 9460000000000000.0" 
 -- loadArgs:after:Qgen:":= magnitude * 9460000000000000.0" 
 -- vAssign:fArg:"in V: var Value" 
 -- BINGO
 -- aaaa: in V: var Value
 -- end:loadArgs:NonVirt:":= magnitude * 9460000000000000.0" 
 -- invoke:after:loadArgsOf:":= magnitude * 9460000000000000.0" :Address:E: ...
 -- $ObjectInvocation_Binary:invoke: rec:"base" ":= magnitude * 94600000000 ..."
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Address:E:"base"off:3 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "base" from: ":= magnitude * 9460000000000000.0" 
 -- assign:dstDI :"out base: var BaseUnit" isUnitValueObj: false
 -- assign:arg: "magnitude * 9460000000000000.0" lab:"ObjectCall" UnitValOb ...false  ...false
 --  float: true DataItem:false arg.super:magnitude * 9460000000000000.0
 --  arg.super.ATd:"Invocation" "* :  |    %basic 112 |    in V: var float |    o ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:true
 --  arg.super.ATd.label: "pattern" 
 -- assign:ValueObj:isPtn: true size:2 
 -- :Address:E:"base"off:3 size:2 isFloat:False superAdj:0 isUnique:False i ...
 -- store::Address:E:"base"off:3 size:2 isFloat:False superAdj:0 isUnique:F ...
 -- isValue:true isAdr:true descNo: 0 
 -- Address:store::srcIsVal:false destIsVal:false mode:0 
 addOff 3
 vassign 2 0
 -- OI:invoke::= magnitude * 9460000000000000.0:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= magnitude * 9460000000000000.0" 
 L2:
 rtnInner
 end OSDV:0 objSize:2 isIndexed:0  vTop:-1 vTopMax:0 rTop:5 rTopMax:5
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 74 :top:1 
 -- GenClass:fromBase :varNo = 1 
 -- GenClass:fromBase:true -> var.genDone

class fromBase 74 1 76
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 -- origin.valueOff:store:2 
 store 2 originOff
 -- super fromBase
 -- vdt:b
 --  1:0 2:0 3:0 4:0
 -- vdt:c:innerInx: 1  descNo: 74 
 -- vdtAdd: inx=1 descInx=74
 pushThis 
 rpushg 1 iOrigin
 pushThis 
 pushg 2 
 toSuper 42
 -- $Signature:gen: "fromBase"
 rtnInner
DO:
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"magnitude := base / 9460000000000000.0" 
 -- $ObjectCall:gen: "magnitude := base / 9460000000000000.0"
 -- $Invocation:gen: descNo: 4 top: 1 "magnitude := base / 9460000000000000 ..."
 -- needorigin:"magnitude := base / 9460000000000000.0" 
 -- needOrigin:E:":= base / 9460000000000000.0"  E.ATd:":= :  |    %basic 8 |   ..." 
 -- computeAdr: "magnitude := base / 9460000000000000.0" 
 -- computeAdr:1 :rec:"none"  E:"magnitude" :Address:E:"none"off:0 size:0 i ...
 -- $ObjectInvocation_Unary:pushThis: "magnitude"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "magnitude"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:1 
 -- goOrigin:fromBase:encOG.IS.newOriginOff:1 :newOriginOff:1 
 -- origin.valueOff:load 2 
 rdouble
 rpushg 1 fromBase:origin
 rswap
 pushg 2 fromBase:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:1 "magnitude"
 -- $var:getAdr:,newOff:1,isValue:"True",A.isValue:"False" "magnitude: var  ..."
 --  A::Address:E:"magnitude"off:0 size:0 isFloat:False superAdj:0 isUnique ...  ...m ...
 -- value_prim:false
 -- Float
 -- before:floatTest: 
 -- getAdr:isfloat:magnitude: var Float A.isValue:true
 -- computeAdr:isFirst::Address:E:"magnitude"off:1 size:0 isFloat:True supe ...
 -- computeAdr:2 :rec:"magnitude"  E:":= base / 9460000000000000.0" :Addres ...
 -- computeAdr:isAssign:rec: "magnitude"  E:":= base / 9460000000000000.0" 
 -- :Address:E:"magnitude"off:1 size:0 isFloat:True superAdj:0 isUnique:Fal ...
 -- computeAdr:isLast:E: ":= base / 9460000000000000.0" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"magnitude"off:1 size:0 isFlo ...
 -- rec: "magnitude" E: ":= base / 9460000000000000.0" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:1 ":= base / 94600000000000 ..."
 -- $pattern:loadArgs:E:":= base / 9460000000000000.0":descNo:4:top:1 ":= : ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= base / 9460000000000000.0" ActArg: "base / 9460000 ..." i ...false
 -- $ObjectCall:gen: "base / 9460000000000000.0"
 -- $Invocation:gen: descNo: 0 top: 0 "base / 9460000000000000.0"
 -- needorigin:"base / 9460000000000000.0" 
 -- needOrigin:E:"/ 9460000000000000.0"  E.ATd:"/ :  |    %basic 121 |    in V: ..." 
 -- computeAdr: "base / 9460000000000000.0" 
 -- computeAdr:1 :rec:"none"  E:"base" :Address:E:"none"off:0 size:0 isFloa ...
 -- $ObjectInvocation_Unary:pushThis: "base"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "base"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "base"
 -- $var:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "in base: var fl ..."
 --  A::Address:E:"base"off:0 size:0 isFloat:False superAdj:0 isUnique:Fals ...  ...i ...
 -- value_prim:false
 -- float
 -- before:floatTest: 
 -- getAdr:isfloat:in base: var float A.isValue:true
 -- computeAdr:isFirst::Address:E:"base"off:3 size:0 isFloat:True superAdj: ...
 -- computeAdr:2 :rec:"base"  E:"/ 9460000000000000.0" :Address:E:"base"off ...
 -- E:notAssign:/ 9460000000000000.0
 -- $ObjectInvocation_Binary:getAdr::superAdj:0:on:0 "/ 9460000000000000.0" ...
 -- $pattern:getAdr: "/ :  |    %basic 121 |    in V: var float |    out R: var f ..."
 -- :Address:E:"base"off:3 size:0 isFloat:True superAdj:0 isUnique:False is ...
 -- ptn.ssUnitValueObj:false isFloat:true
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "base"
 -- $var:loadArgs: "in base: var float"
 -- $ObjectInvocation_Unary:invoke: rec:"base" "base"
 -- E.ATd: "/ " unique: false
 -- adr::Address:E:"base"off:3 size:0 isFloat:True superAdj:0 isUnique:Fals ...
 -- $var:invoke: newOff:3 "in base: var float"
 -- load::Address:E:"base"off:3 size:0 isFloat:True superAdj:0 isUnique:Fal ...
 -- isFloat: true
 fpushg 3 
 -- OI:invoke:base:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "/ 9460000000000000.0" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"base"off:3 size:0 isFloat:Tr ...
 -- rec: "base" E: "/ 9460000000000000.0" isValueAssign: false
 -- $ObjectInvocation_Binary:loadArgs:staticOff:0 "/ 9460000000000000.0"
 -- $pattern:loadArgs:E:"/ 9460000000000000.0":descNo:0:top:0 "/ :  |    %bas ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"/ 9460000000000000.0" ActArg: "9460000000000000.0" is ...true
 -- loadArgs:not:*: formalArgOf:"/ 9460000000000000.0"  isCompositeValueObj ...false
 -- $ObjectCall:gen: "9460000000000000.0"
 -- $Invocation:gen: "9460000000000000.0"
 -- needorigin:"9460000000000000.0" 
 -- needOrigin:E:"9460000000000000.0"  E.ATd:"float: Value |    %globals |    % ..." 
 -- LoadOrign:no:loadOrigin: "Value |    %globals |    %basic 9 |    _thisBasicVa ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "9460000000000000.0" E: "9460000000000000.0" isValueAssign: false
 -- $FloatLiteral:loadArgs: "9460000000000000.0"
 -- invoke:after:loadArgsOf:"9460000000000000.0" 
 -- $FloatLiteral:invoke: "9460000000000000.0"
 pushFloatConst 9460000000000000.000000
 -- invoke:after:E.invoke:"9460000000000000.0" 
 -- loadArgs:after:Qgen:"/ 9460000000000000.0" 
 -- formalArg:isPtn:"in V: var float" :isBasicVal:true:valueObj:true
 -- :actArg:"9460000000000000.0" :isBasicVal:true
 -- 9460000000000000.0ObjectCall
 -- end:loadArgs:NonVirt:"/ 9460000000000000.0" 
 -- invoke:after:loadArgsOf:"/ 9460000000000000.0" :Address:E:"base"off:3 s ...
 -- $ObjectInvocation_Binary:invoke: rec:"base" "/ 9460000000000000.0"
 -- >top:0 descNo:0 
 -- E.ATd: "/ " unique: false
 -- adr::Address:E:"base"off:3 size:0 isFloat:True superAdj:0 isUnique:Fals ...
 -- $pattern:invoke: "/ :  |    %basic 121 |    in V: var float |    out R: var f ..."
 -- bodyC:
 fdiv
 -- OI:invoke:/ 9460000000000000.0:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"/ 9460000000000000.0" 
 -- loadArgs:after:Qgen:":= base / 9460000000000000.0" 
 -- vAssign:fArg:"in V: var Value" 
 -- BINGO
 -- aaaa: in V: var Value
 -- end:loadArgs:NonVirt:":= base / 9460000000000000.0" 
 -- invoke:after:loadArgsOf:":= base / 9460000000000000.0" :Address:E:"magn ..."
 -- $ObjectInvocation_Binary:invoke: rec:"magnitude" ":= base / 94600000000 ..."
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Address:E:"magnitude"off:1 size:0 isFloat:True superAdj:0 isUnique ...
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "magnitude" from: ":= base / 9460000000000000.0" 
 -- assign:dstDI :"magnitude: var Float" isUnitValueObj: false
 -- assign:arg: "base / 9460000000000000.0" lab:"ObjectCall" UnitValObj :false  ...false
 --  float: true DataItem:false arg.super:base / 9460000000000000.0
 --  arg.super.ATd:"Invocation" "/ :  |    %basic 121 |    in V: var float |    o ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:true
 --  arg.super.ATd.label: "pattern" 
 -- assign:simple value: 
 -- :Address:E:"magnitude"off:1 size:0 isFloat:True superAdj:0 isUnique:Fal ...
 -- store::Address:E:"magnitude"off:1 size:0 isFloat:True superAdj:0 isUniq ...
 -- isValue:true isAdr:false descNo: 0 
 -- Address:store:originIsValue:
 fovstoreg 1 
 -- OI:invoke::= base / 9460000000000000.0:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= base / 9460000000000000.0" 
 L2:
 rtnInner
 end OSDV:0 objSize:4 isIndexed:0  vTop:-3 vTopMax:0 rTop:5 rTopMax:5
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 75 :top:1 
 -- GenClass:print :varNo = 1 
 -- GenClass:print:true -> var.genDone

class print 75 1 76
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 -- origin.valueOff:store:2 
 store 2 originOff
 -- super print
 -- vdt:b
 --  1:0 2:0 3:0 4:0
 -- vdt:c:innerInx: 1  descNo: 75 
 -- vdtAdd: inx=1 descInx=75
 pushThis 
 rpushg 1 iOrigin
 pushThis 
 pushg 2 
 toSuper 44
 -- $Signature:gen: "print"
 rtnInner
DO:
 mvStack 
 L1:
 -- genclass:Qgen:stmt:""LightYear".print" 
 -- $ObjectCall:gen: ""LightYear".print"
 -- $Invocation:gen: descNo: 33 top: 1 ""LightYear".print"
 -- needorigin:""LightYear".print" 
 -- needOrigin:E:"print"  E.ATd:"print:  |    @for 1 :to length  |    :do  |      ..." 
 -- computeAdr: ""LightYear".print" 
 -- computeAdr:1 :rec:"none"  E:""LightYear"" :Address:E:"none"off:0 size:0 ...
 -- $String::pushThis: ""LightYear""
 -- $String::loadOrigin: ""LightYear""
 -- StringObj:loadOrigin:"LightYear"
 -- $String::getAdr: ""LightYear""
 -- computeAdr:isFirst::Address:E:""LightYear""off:0 size:0 isFloat:False s ...
 -- computeAdr:2 :rec:""LightYear""  E:"print" :Address:E:""LightYear""off: ...
 -- E:notAssign:print
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "print"
 -- $pattern:getAdr: "print:  |    @for 1 :to length  |    :do  |       put(@get  ..."
 -- :Address:E:""LightYear""off:0 size:0 isFloat:False superAdj:0 isUnique: ...
 -- ptn.ssUnitValueObj:false isFloat:false
 -- $String::loadArgs: ""LightYear""
 -- $String::invoke: ""LightYear""
 -- Pattern:markForCodeGen:+ :  |    in S: ref String |    out V: ref String |    ...
 pushText LightYear
 -- computeAdr:isLast:E: "print" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:""LightYear""off:0 size:0 isF ...
 -- rec: ""LightYear"" E: "print" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "print"
 -- $pattern:loadArgs:E:"print":descNo:33:top:1 "print:  |    @for 1 :to leng ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"print" :Address:E:""LightYear""off:0 size:0 is ...
 -- $ObjectInvocation_Unary:invoke: rec:""LightYear"" "print"
 -- >top:1 descNo:33 
 -- E.ATd: "print" unique: false
 -- adr::Address:E:""LightYear""off:0 size:0 isFloat:False superAdj:0 isUni ...
 -- $pattern:invoke: "print:  |    @for 1 :to length  |    :do  |       put(@get  ..."
 -- Pattern:invoke:descNo:33  top:1  rec:""LightYear"" 
 -- ComputeVariantX
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- <>var
 -- rec:module or pattern:"print"  descno: 33  top: 1 "@for 1 :to length  | : ..." 
 -- ptn:invoke::isValObj:false:rtnValObj:false:"print:  |    @for 1 :to lengt ..." 
 -- rec=E:false:rec:""LightYear"" 
 -- kuk:obj:rec.ATd:"String:  |    %OSDvisibility disguised |    %basic 5 |    %i ..." 
 invoke print 33 0 0
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:false""LightYear"" 
 rpop
 -- OI:invoke:print:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"print" 
 L2:
 rtnInner
 end OSDV:0 objSize:2 isIndexed:0  vTop:-1 vTopMax:0 rTop:1 rTopMax:2
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 76 :top:1 
 -- GenClass:LightYear :varNo = 1 
 -- GenClass:LightYear:true -> var.genDone

class LightYear 76 0 58
 -- Store itemArgs
 -- super Unit
 -- vdt:b
 --  1:45 2:45 3:45 4:41 5:42 6:44
 -- Super:sig not none
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "Unit"
 -- $pattern:loadArgs:E:"Unit":descNo:45:top:1 "Unit: Value |    %unit "U" |    ..."
 -- isValueAssign: false
 toSuper 45
 -- $Signature:gen: "LightYear"
 -- $pattern:gen: "toBase::  |    --bxx: var BaseUnit |    --bxx := magnitude * ..."
 -- vdt:f:73 getDescNo:73 
 -- vdtAdd: inx=4 descInx=73
 -- $pattern:gen: "fromBase::  |    magnitude := base / 9460000000000000.0"
 -- vdt:f:74 getDescNo:74 
 -- vdtAdd: inx=5 descInx=74
 -- $pattern:gen: "print::  |    "LightYear".print"
 -- vdt:f:75 getDescNo:75 
 -- vdtAdd: inx=6 descInx=75
 rtnInner
DO:
 L1:
 -- genclass:Qgen:stmt:"%unit "ly", "9460000000000000"" 
 -- $Property:gen: "%unit "ly", "9460000000000000""
 L2:
 rtnInner
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- Virtual
 -- Virtual
 -- Virtual
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 77 :top:1 
 -- GenClass:toBase :varNo = 1 
 -- GenClass:toBase:true -> var.genDone

class toBase 77 1 80
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 -- origin.valueOff:store:2 
 store 2 originOff
 -- super toBase
 -- vdt:b
 --  1:0 2:0 3:0 4:0
 -- vdt:c:innerInx: 1  descNo: 77 
 -- vdtAdd: inx=1 descInx=77
 pushThis 
 rpushg 1 iOrigin
 pushThis 
 pushg 2 
 toSuper 41
 -- $Signature:gen: "toBase"
 rtnInner
DO:
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"base := magnitude" 
 -- $ObjectCall:gen: "base := magnitude"
 -- $Invocation:gen: descNo: 4 top: 1 "base := magnitude"
 -- needorigin:"base := magnitude" 
 -- needOrigin:E:":= magnitude"  E.ATd:":= :  |    %basic 8 |    in V: var Valu ..." 
 -- computeAdr: "base := magnitude" 
 -- computeAdr:1 :rec:"none"  E:"base" :Address:E:"none"off:0 size:0 isFloa ...
 -- $ObjectInvocation_Unary:pushThis: "base"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "base"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "base"
 -- $var:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "out base: var B ..."
 --  A::Address:E:"base"off:0 size:0 isFloat:False superAdj:0 isUnique:Fals ...  ...o ...
 -- value_prim:false
 -- BaseUnit
 -- before:floatTest: 
 -- computeAdr:isFirst::Address:E:"base"off:3 size:0 isFloat:False superAdj ...
 -- computeAdr:2 :rec:"base"  E:":= magnitude" :Address:E:"base"off:3 size: ...
 -- computeAdr:isAssign:rec: "base"  E:":= magnitude" 
 -- :Address:E:"base"off:3 size:0 isFloat:False superAdj:0 isUnique:False i ...
 -- computeAdr:isLast:E: ":= magnitude" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"base"off:3 size:0 isFloat:Fa ...
 -- rec: "base" E: ":= magnitude" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:3 ":= magnitude"
 -- $pattern:loadArgs:E:":= magnitude":descNo:4:top:1 ":= :  |    %basic 8 |    ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= magnitude" ActArg: "magnitude" isValue: false
 -- $ObjectCall:gen: "magnitude"
 -- $Invocation:gen: "magnitude"
 -- needorigin:"magnitude" 
 -- needOrigin:E:"magnitude"  E.ATd:"magnitude: var Float" 
 -- needOrigin:datItem:leave
 -- computeAdr: "magnitude" 
 -- computeAdr:1 :rec:"none"  E:"magnitude" :Address:E:"none"off:0 size:0 i ...
 -- $ObjectInvocation_Unary:pushThis: "magnitude"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "magnitude"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:1 
 -- goOrigin:toBase:encOG.IS.newOriginOff:1 :newOriginOff:1 
 -- origin.valueOff:load 2 
 rdouble
 rpushg 1 toBase:origin
 rswap
 pushg 2 toBase:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:1 "magnitude"
 -- $var:getAdr:,newOff:1,isValue:"True",A.isValue:"False" "magnitude: var  ..."
 --  A::Address:E:"magnitude"off:0 size:0 isFloat:False superAdj:0 isUnique ...  ...m ...
 -- value_prim:false
 -- Float
 -- before:floatTest: 
 -- getAdr:isfloat:magnitude: var Float A.isValue:true
 -- computeAdr:isFirst::Address:E:"magnitude"off:1 size:0 isFloat:True supe ...
 -- computeAdr:isLast:E: "magnitude" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"magnitude"off:1 size:0 isFlo ...
 -- rec: "magnitude" E: "magnitude" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "magnitude"
 -- $var:loadArgs: "magnitude: var Float"
 -- invoke:after:loadArgsOf:"magnitude" :Address:E:"magnitude"off:1 size:0  ...
 -- $ObjectInvocation_Unary:invoke: rec:"magnitude" "magnitude"
 -- E.ATd: "magnitude" unique: false
 -- adr::Address:E:"magnitude"off:1 size:0 isFloat:True superAdj:0 isUnique ...
 -- $var:invoke: newOff:1 "magnitude: var Float"
 -- load::Address:E:"magnitude"off:1 size:0 isFloat:True superAdj:0 isUniqu ...
 fovpushg 1 
 -- OI:invoke:magnitude:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"magnitude" 
 -- loadArgs:after:Qgen:":= magnitude" 
 -- vAssign:fArg:"in V: var Value" 
 -- end:loadArgs:NonVirt:":= magnitude" 
 -- invoke:after:loadArgsOf:":= magnitude" :Address:E:"base"off:3 size:0 is ...
 -- $ObjectInvocation_Binary:invoke: rec:"base" ":= magnitude"
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Address:E:"base"off:3 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "base" from: ":= magnitude" 
 -- assign:dstDI :"out base: var BaseUnit" isUnitValueObj: false
 -- assign:arg: "magnitude" lab:"ObjectCall" UnitValObj :false ptn: false
 --  float: false DataItem:false arg.super:magnitude
 --  arg.super.ATd:"Invocation" "magnitude: var Float" 
 --  arg.super.ATd.isDataItem:true arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "var" 
 -- assign:ValueObj:isPtn: false size:2 
 -- :Address:E:"base"off:3 size:2 isFloat:False superAdj:0 isUnique:False i ...
 -- store::Address:E:"base"off:3 size:2 isFloat:False superAdj:0 isUnique:F ...
 -- isValue:true isAdr:true descNo: 0 
 -- Address:store::srcIsVal:true destIsVal:false mode:0 
 addOff 3
 vassign 2 0
 -- OI:invoke::= magnitude:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= magnitude" 
 L2:
 rtnInner
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:5 rTopMax:5
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 78 :top:1 
 -- GenClass:fromBase :varNo = 1 
 -- GenClass:fromBase:true -> var.genDone

class fromBase 78 1 80
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 -- origin.valueOff:store:2 
 store 2 originOff
 -- super fromBase
 -- vdt:b
 --  1:0 2:0 3:0 4:0
 -- vdt:c:innerInx: 1  descNo: 78 
 -- vdtAdd: inx=1 descInx=78
 pushThis 
 rpushg 1 iOrigin
 pushThis 
 pushg 2 
 toSuper 42
 -- $Signature:gen: "fromBase"
 rtnInner
DO:
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"magnitude := base" 
 -- $ObjectCall:gen: "magnitude := base"
 -- $Invocation:gen: descNo: 4 top: 1 "magnitude := base"
 -- needorigin:"magnitude := base" 
 -- needOrigin:E:":= base"  E.ATd:":= :  |    %basic 8 |    in V: var Value" 
 -- computeAdr: "magnitude := base" 
 -- computeAdr:1 :rec:"none"  E:"magnitude" :Address:E:"none"off:0 size:0 i ...
 -- $ObjectInvocation_Unary:pushThis: "magnitude"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "magnitude"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:1 
 -- goOrigin:fromBase:encOG.IS.newOriginOff:1 :newOriginOff:1 
 -- origin.valueOff:load 2 
 rdouble
 rpushg 1 fromBase:origin
 rswap
 pushg 2 fromBase:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:1 "magnitude"
 -- $var:getAdr:,newOff:1,isValue:"True",A.isValue:"False" "magnitude: var  ..."
 --  A::Address:E:"magnitude"off:0 size:0 isFloat:False superAdj:0 isUnique ...  ...m ...
 -- value_prim:false
 -- Float
 -- before:floatTest: 
 -- getAdr:isfloat:magnitude: var Float A.isValue:true
 -- computeAdr:isFirst::Address:E:"magnitude"off:1 size:0 isFloat:True supe ...
 -- computeAdr:2 :rec:"magnitude"  E:":= base" :Address:E:"magnitude"off:1  ...
 -- computeAdr:isAssign:rec: "magnitude"  E:":= base" 
 -- :Address:E:"magnitude"off:1 size:0 isFloat:True superAdj:0 isUnique:Fal ...
 -- computeAdr:isLast:E: ":= base" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"magnitude"off:1 size:0 isFlo ...
 -- rec: "magnitude" E: ":= base" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:1 ":= base"
 -- $pattern:loadArgs:E:":= base":descNo:4:top:1 ":= :  |    %basic 8 |    in V ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= base" ActArg: "base" isValue: false
 -- $ObjectCall:gen: "base"
 -- $Invocation:gen: "base"
 -- needorigin:"base" 
 -- needOrigin:E:"base"  E.ATd:"in base: var float" 
 -- needOrigin:datItem:leave
 -- computeAdr: "base" 
 -- computeAdr:1 :rec:"none"  E:"base" :Address:E:"none"off:0 size:0 isFloa ...
 -- $ObjectInvocation_Unary:pushThis: "base"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "base"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "base"
 -- $var:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "in base: var fl ..."
 --  A::Address:E:"base"off:0 size:0 isFloat:False superAdj:0 isUnique:Fals ...  ...i ...
 -- value_prim:false
 -- float
 -- before:floatTest: 
 -- getAdr:isfloat:in base: var float A.isValue:true
 -- computeAdr:isFirst::Address:E:"base"off:3 size:0 isFloat:True superAdj: ...
 -- computeAdr:isLast:E: "base" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"base"off:3 size:0 isFloat:Tr ...
 -- rec: "base" E: "base" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "base"
 -- $var:loadArgs: "in base: var float"
 -- invoke:after:loadArgsOf:"base" :Address:E:"base"off:3 size:0 isFloat:Tr ...
 -- $ObjectInvocation_Unary:invoke: rec:"base" "base"
 -- E.ATd: "base" unique: false
 -- adr::Address:E:"base"off:3 size:0 isFloat:True superAdj:0 isUnique:Fals ...
 -- $var:invoke: newOff:3 "in base: var float"
 -- load::Address:E:"base"off:3 size:0 isFloat:True superAdj:0 isUnique:Fal ...
 -- isFloat: true
 fpushg 3 
 -- OI:invoke:base:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"base" 
 -- loadArgs:after:Qgen:":= base" 
 -- vAssign:fArg:"in V: var Value" 
 -- end:loadArgs:NonVirt:":= base" 
 -- invoke:after:loadArgsOf:":= base" :Address:E:"magnitude"off:1 size:0 is ...
 -- $ObjectInvocation_Binary:invoke: rec:"magnitude" ":= base"
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Address:E:"magnitude"off:1 size:0 isFloat:True superAdj:0 isUnique ...
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "magnitude" from: ":= base" 
 -- assign:dstDI :"magnitude: var Float" isUnitValueObj: false
 -- assign:arg: "base" lab:"ObjectCall" UnitValObj :false ptn: false
 --  float: false DataItem:false arg.super:base
 --  arg.super.ATd:"Invocation" "in base: var float" 
 --  arg.super.ATd.isDataItem:true arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "var" 
 -- assign:simple value: 
 -- :Address:E:"magnitude"off:1 size:0 isFloat:True superAdj:0 isUnique:Fal ...
 -- store::Address:E:"magnitude"off:1 size:0 isFloat:True superAdj:0 isUniq ...
 -- isValue:true isAdr:false descNo: 0 
 -- Address:store:originIsValue:
 fovstoreg 1 
 -- OI:invoke::= base:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= base" 
 L2:
 rtnInner
 end OSDV:0 objSize:4 isIndexed:0  vTop:-2 vTopMax:0 rTop:5 rTopMax:5
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 79 :top:1 
 -- GenClass:print :varNo = 1 
 -- GenClass:print:true -> var.genDone

class print 79 1 80
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 -- origin.valueOff:store:2 
 store 2 originOff
 -- super print
 -- vdt:b
 --  1:0 2:0 3:0 4:0
 -- vdt:c:innerInx: 1  descNo: 79 
 -- vdtAdd: inx=1 descInx=79
 pushThis 
 rpushg 1 iOrigin
 pushThis 
 pushg 2 
 toSuper 44
 -- $Signature:gen: "print"
 rtnInner
DO:
 mvStack 
 L1:
 -- genclass:Qgen:stmt:""Second".print" 
 -- $ObjectCall:gen: ""Second".print"
 -- $Invocation:gen: descNo: 33 top: 1 ""Second".print"
 -- needorigin:""Second".print" 
 -- needOrigin:E:"print"  E.ATd:"print:  |    @for 1 :to length  |    :do  |      ..." 
 -- computeAdr: ""Second".print" 
 -- computeAdr:1 :rec:"none"  E:""Second"" :Address:E:"none"off:0 size:0 is ...
 -- $String::pushThis: ""Second""
 -- $String::loadOrigin: ""Second""
 -- StringObj:loadOrigin:"Second"
 -- $String::getAdr: ""Second""
 -- computeAdr:isFirst::Address:E:""Second""off:0 size:0 isFloat:False supe ...
 -- computeAdr:2 :rec:""Second""  E:"print" :Address:E:""Second""off:0 size ...
 -- E:notAssign:print
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "print"
 -- $pattern:getAdr: "print:  |    @for 1 :to length  |    :do  |       put(@get  ..."
 -- :Address:E:""Second""off:0 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- ptn.ssUnitValueObj:false isFloat:false
 -- $String::loadArgs: ""Second""
 -- $String::invoke: ""Second""
 -- Pattern:markForCodeGen:+ :  |    in S: ref String |    out V: ref String |    ...
 pushText Second
 -- computeAdr:isLast:E: "print" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:""Second""off:0 size:0 isFloa ...
 -- rec: ""Second"" E: "print" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "print"
 -- $pattern:loadArgs:E:"print":descNo:33:top:1 "print:  |    @for 1 :to leng ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"print" :Address:E:""Second""off:0 size:0 isFlo ...
 -- $ObjectInvocation_Unary:invoke: rec:""Second"" "print"
 -- >top:1 descNo:33 
 -- E.ATd: "print" unique: false
 -- adr::Address:E:""Second""off:0 size:0 isFloat:False superAdj:0 isUnique ...
 -- $pattern:invoke: "print:  |    @for 1 :to length  |    :do  |       put(@get  ..."
 -- Pattern:invoke:descNo:33  top:1  rec:""Second"" 
 -- ComputeVariantX
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- <>var
 -- rec:module or pattern:"print"  descno: 33  top: 1 "@for 1 :to length  | : ..." 
 -- ptn:invoke::isValObj:false:rtnValObj:false:"print:  |    @for 1 :to lengt ..." 
 -- rec=E:false:rec:""Second"" 
 -- kuk:obj:rec.ATd:"String:  |    %OSDvisibility disguised |    %basic 5 |    %i ..." 
 invoke print 33 0 0
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:false""Second"" 
 rpop
 -- OI:invoke:print:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"print" 
 L2:
 rtnInner
 end OSDV:0 objSize:2 isIndexed:0  vTop:-1 vTopMax:0 rTop:1 rTopMax:2
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 80 :top:1 
 -- GenClass:Second :varNo = 1 
 -- GenClass:Second:true -> var.genDone

class Second 80 0 60
 -- Store itemArgs
 -- super Unit
 -- vdt:b
 --  1:45 2:45 3:45 4:41 5:42 6:44
 -- Super:sig not none
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "Unit"
 -- $pattern:loadArgs:E:"Unit":descNo:45:top:1 "Unit: Value |    %unit "U" |    ..."
 -- isValueAssign: false
 toSuper 45
 -- $Signature:gen: "Second"
 -- $pattern:gen: "thisUnit:: Second"
 -- vdtTable: off: 1  descNo: 8 
 -- $pattern:gen: "toBase::  |    base := magnitude"
 -- vdt:f:77 getDescNo:77 
 -- vdtAdd: inx=4 descInx=77
 -- $pattern:gen: "fromBase::  |    magnitude := base"
 -- vdt:f:78 getDescNo:78 
 -- vdtAdd: inx=5 descInx=78
 -- $pattern:gen: "print::  |    "Second".print"
 -- vdt:f:79 getDescNo:79 
 -- vdtAdd: inx=6 descInx=79
 rtnInner
DO:
 L1:
 -- genclass:Qgen:stmt:"%unit "s"" 
 -- $Property:gen: "%unit "s""
 -- genclass:Qgen:stmt:"%public" 
 -- $Property:gen: "%public"
 L2:
 rtnInner
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- Virtual
 -- genClass:BindVirtuals:descNo:106 

class Vstub#Second#8 106 0 0
 -- Load origin:OG.isVirtualArg:false
 -- goOrigin:A:1 
 -- OBS! Qalloc, originOff = 0 
 -- ComputeVariant:A:Second
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Unit
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Value
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is not new:
 -- ComputeVariant:B:Second
 -- goOrigin:Second:encOG.IS.newOriginOff:0 :newOriginOff:0 
 rpushg 0 Second:origin
 -- OG.super.on/descNo:1 80 
 invoke Second 80 0 1
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- vdt:a:descNo80 
 -- Virtual
 -- Virtual
 -- Virtual
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 81 :top:1 
 -- GenClass:newline :varNo = 1 
 -- GenClass:newline:true -> var.genDone

class newline 81 0 6
 -- Store itemArgs
 allocEventQ
 mvStack 
 -- $Signature:gen: "newline"
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%globals" 
 -- $Property:gen: "%globals"
 -- genclass:Qgen:stmt:"put(10)" 
 -- $ObjectCall:gen: "put(10)"
 -- $Invocation:gen: descNo: 30 top: 1 "put(10)"
 -- needorigin:"put(10)" 
 -- needOrigin:E:"put(10)"  E.ATd:"put:  |    %globals |    %basic 2 |    in ch:  ..." 
 -- LoadOrign:no:loadOrigin: "%globals | %basic 2 | in ch: val char" 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "put(10)" E: "put(10)" isValueAssign: false
 -- $ObjectInvocation_Function:loadArgs:staticOff:0 "put(10)"
 -- $pattern:loadArgs:E:"put(10)":descNo:30:top:1 "put:  |    %globals |    %ba ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"put(10)" ActArg: "10" isValue: true
 -- loadArgs:not:*: formalArgOf:"put(10)"  isCompositeValueObj:false
 -- $ObjectCall:gen: "10"
 -- $Invocation:gen: "10"
 -- needorigin:"10" 
 -- needOrigin:E:"10"  E.ATd:"integer: value |    %basic 1, 32 |    %globals |    ..." 
 -- LoadOrign:no:loadOrigin: "value |    %basic 1, 32 |    %globals |    %public |  ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "10" E: "10" isValueAssign: false
 -- $ConstLiteral:loadArgs: "10"
 -- invoke:after:loadArgsOf:"10" 
 -- $ConstLiteral:invoke: "10"
 pushc 10
 -- invoke:after:E.invoke:"10" 
 -- loadArgs:after:Qgen:"put(10)" 
 -- formalArg:isPtn:"in ch: val char" :isBasicVal:true:valueObj:true
 -- :actArg:"10" :isBasicVal:true
 -- 10ObjectCall
 -- convDone:false
 -- end:loadArgs:NonVirt:"put(10)" 
 -- invoke:after:loadArgsOf:"put(10)" 
 -- $ObjectInvocation_Function:invoke: rec:"put(10)" "put(10)"
 -- >top:1 descNo:30 
 -- $pattern:invoke: "put:  |    %globals |    %basic 2 |    in ch: val char"
 %put 2
 -- OI:invoke:put(10):unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"put(10)" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"newline" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:0 isIndexed:0  vTop:1 vTopMax:1 rTop:1 rTopMax:1
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 82 :top:1 
 -- GenClass:LibraEx :varNo = 1 
 -- GenClass:LibraEx:true -> var.genDone

class LibraEx 82 1 83
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $var:gen: "rocketSpeed: var Velocity.MperS"
 -- DI:isConst:false:isBasicValue:false:primNo:0 
 -- OGqual:MperS:OGqual.isBasicValue:false:OGqual.isValueObj:true
 -- $ObjectCall:gen: "Velocity.MperS"
 -- $Invocation:gen: descNo: 67 top: 1 "Velocity.MperS"
 -- needorigin:"Velocity.MperS" 
 -- needOrigin:E:"MperS"  E.ATd:"MperS: Unit |    %unit "m*s^-1", "m*s^-1" |    ..." 
 -- LoadOrign:no:loadOrigin: "Unit |    %unit "m*s^-1", "m*s^-1" |    %Public |   ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "Velocity" E: "MperS" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "MperS"
 -- $pattern:loadArgs:E:"MperS":descNo:67:top:1 "MperS: Unit |    %unit "m*s^ ...
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"MperS" 
 -- $ObjectInvocation_Unary:invoke: rec:"Velocity" "MperS"
 -- >top:1 descNo:67 
 -- $pattern:invoke: "MperS: Unit |    %unit "m*s^-1", "m*s^-1" |    %Public |    ..."
 -- Pattern:invoke:descNo:67  top:1  rec:"Velocity" 
 -- ComputeVariantX
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Unit
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Value
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- <>var
 -- rec:module or pattern:"MperS"  descno: 67  top: 1 "Unit |    %unit "m*s^- ..."" 
 -- ptn:invoke::isValObj:true:rtnValObj:false:"MperS: Unit |    %unit "m*s^-1 ..."" 
 -- rec=E:false:rec:"Velocity" 
 invokeVal MperS 67 1
 -- useRtnVal:false:isVal:true:rtnValObj:false:rec=E:false"Velocity" 
 -- OI:invoke:MperS:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"MperS" 
 -- $var:gen: "exhaustSpeed: var Velocity.MperS"
 -- DI:isConst:false:isBasicValue:false:primNo:0 
 -- OGqual:MperS:OGqual.isBasicValue:false:OGqual.isValueObj:true
 -- $ObjectCall:gen: "Velocity.MperS"
 -- $Invocation:gen: descNo: 67 top: 1 "Velocity.MperS"
 -- needorigin:"Velocity.MperS" 
 -- needOrigin:E:"MperS"  E.ATd:"MperS: Unit |    %unit "m*s^-1", "m*s^-1" |    ..." 
 -- LoadOrign:no:loadOrigin: "Unit |    %unit "m*s^-1", "m*s^-1" |    %Public |   ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "Velocity" E: "MperS" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "MperS"
 -- $pattern:loadArgs:E:"MperS":descNo:67:top:1 "MperS: Unit |    %unit "m*s^ ...
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"MperS" 
 -- $ObjectInvocation_Unary:invoke: rec:"Velocity" "MperS"
 -- >top:1 descNo:67 
 -- $pattern:invoke: "MperS: Unit |    %unit "m*s^-1", "m*s^-1" |    %Public |    ..."
 -- Pattern:invoke:descNo:67  top:1  rec:"Velocity" 
 -- ComputeVariantX
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Unit
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Value
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- <>var
 -- rec:module or pattern:"MperS"  descno: 67  top: 1 "Unit |    %unit "m*s^- ..."" 
 -- ptn:invoke::isValObj:true:rtnValObj:false:"MperS: Unit |    %unit "m*s^-1 ..."" 
 -- rec=E:false:rec:"Velocity" 
 invokeVal MperS 67 3
 -- useRtnVal:false:isVal:true:rtnValObj:false:rec=E:false"Velocity" 
 -- OI:invoke:MperS:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"MperS" 
 -- $var:gen: "rocketMass: var Mass.KiloGram"
 -- DI:isConst:false:isBasicValue:false:primNo:0 
 -- OGqual:KiloGram:OGqual.isBasicValue:false:OGqual.isValueObj:true
 -- $ObjectCall:gen: "Mass.KiloGram"
 -- $Invocation:gen: descNo: 72 top: 1 "Mass.KiloGram"
 -- needorigin:"Mass.KiloGram" 
 -- needOrigin:E:"KiloGram"  E.ATd:"KiloGram: Unit |    %unit "kg" |    %public ..." 
 -- LoadOrign:no:loadOrigin: "Unit |    %unit "kg" |    %public |    thisUnit:: K ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "Mass" E: "KiloGram" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "KiloGram"
 -- $pattern:loadArgs:E:"KiloGram":descNo:72:top:1 "KiloGram: Unit |    %unit ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"KiloGram" 
 -- $ObjectInvocation_Unary:invoke: rec:"Mass" "KiloGram"
 -- >top:1 descNo:72 
 -- $pattern:invoke: "KiloGram: Unit |    %unit "kg" |    %public |    thisUnit:: ..."
 -- Pattern:invoke:descNo:72  top:1  rec:"Mass" 
 -- ComputeVariantX
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Unit
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Value
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- <>var
 -- rec:module or pattern:"KiloGram"  descno: 72  top: 1 "Unit |    %unit "kg ..."" 
 -- ptn:invoke::isValObj:true:rtnValObj:false:"KiloGram: Unit |    %unit "kg" ..." 
 -- rec=E:false:rec:"Mass" 
 invokeVal KiloGram 72 5
 -- useRtnVal:false:isVal:true:rtnValObj:false:rec=E:false"Mass" 
 -- OI:invoke:KiloGram:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"KiloGram" 
 -- $var:gen: "fuelMass: var Mass.KiloGram"
 -- DI:isConst:false:isBasicValue:false:primNo:0 
 -- OGqual:KiloGram:OGqual.isBasicValue:false:OGqual.isValueObj:true
 -- $ObjectCall:gen: "Mass.KiloGram"
 -- $Invocation:gen: descNo: 72 top: 1 "Mass.KiloGram"
 -- needorigin:"Mass.KiloGram" 
 -- needOrigin:E:"KiloGram"  E.ATd:"KiloGram: Unit |    %unit "kg" |    %public ..." 
 -- LoadOrign:no:loadOrigin: "Unit |    %unit "kg" |    %public |    thisUnit:: K ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "Mass" E: "KiloGram" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "KiloGram"
 -- $pattern:loadArgs:E:"KiloGram":descNo:72:top:1 "KiloGram: Unit |    %unit ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"KiloGram" 
 -- $ObjectInvocation_Unary:invoke: rec:"Mass" "KiloGram"
 -- >top:1 descNo:72 
 -- $pattern:invoke: "KiloGram: Unit |    %unit "kg" |    %public |    thisUnit:: ..."
 -- Pattern:invoke:descNo:72  top:1  rec:"Mass" 
 -- ComputeVariantX
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Unit
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Value
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- <>var
 -- rec:module or pattern:"KiloGram"  descno: 72  top: 1 "Unit |    %unit "kg ..."" 
 -- ptn:invoke::isValObj:true:rtnValObj:false:"KiloGram: Unit |    %unit "kg" ..." 
 -- rec=E:false:rec:"Mass" 
 invokeVal KiloGram 72 7
 -- useRtnVal:false:isVal:true:rtnValObj:false:rec=E:false"Mass" 
 -- OI:invoke:KiloGram:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"KiloGram" 
 -- $var:gen: "distToAlpha: var Length.LightYear"
 -- DI:isConst:false:isBasicValue:false:primNo:0 
 -- OGqual:LightYear:OGqual.isBasicValue:false:OGqual.isValueObj:true
 -- $ObjectCall:gen: "Length.LightYear"
 -- $Invocation:gen: descNo: 76 top: 1 "Length.LightYear"
 -- needorigin:"Length.LightYear" 
 -- needOrigin:E:"LightYear"  E.ATd:"LightYear: Unit |    %unit "ly", "946000 ..."" 
 -- LoadOrign:no:loadOrigin: "Unit |    %unit "ly", "9460000000000000" |    toB ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "Length" E: "LightYear" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "LightYear"
 -- $pattern:loadArgs:E:"LightYear":descNo:76:top:1 "LightYear: Unit |    %un ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"LightYear" 
 -- $ObjectInvocation_Unary:invoke: rec:"Length" "LightYear"
 -- >top:1 descNo:76 
 -- $pattern:invoke: "LightYear: Unit |    %unit "ly", "9460000000000000" |     ..."
 -- Pattern:invoke:descNo:76  top:1  rec:"Length" 
 -- ComputeVariantX
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Unit
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Value
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- <>var
 -- rec:module or pattern:"LightYear"  descno: 76  top: 1 "Unit |    %unit "l ..."" 
 -- ptn:invoke::isValObj:true:rtnValObj:false:"LightYear: Unit |    %unit "ly ..."" 
 -- rec=E:false:rec:"Length" 
 invokeVal LightYear 76 9
 -- useRtnVal:false:isVal:true:rtnValObj:false:rec=E:false"Length" 
 -- OI:invoke:LightYear:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"LightYear" 
 -- $var:gen: "t: var Time.Second"
 -- DI:isConst:false:isBasicValue:false:primNo:0 
 -- OGqual:Second:OGqual.isBasicValue:false:OGqual.isValueObj:true
 -- $ObjectCall:gen: "Time.Second"
 -- $Invocation:gen: descNo: 80 top: 1 "Time.Second"
 -- needorigin:"Time.Second" 
 -- needOrigin:E:"Second"  E.ATd:"Second: Unit |    %unit "s" |    %public |    t ..." 
 -- LoadOrign:no:loadOrigin: "Unit |    %unit "s" |    %public |    thisUnit:: Se ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "Time" E: "Second" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "Second"
 -- $pattern:loadArgs:E:"Second":descNo:80:top:1 "Second: Unit |    %unit "s" ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"Second" 
 -- $ObjectInvocation_Unary:invoke: rec:"Time" "Second"
 -- >top:1 descNo:80 
 -- $pattern:invoke: "Second: Unit |    %unit "s" |    %public |    thisUnit:: Se ..."
 -- Pattern:invoke:descNo:80  top:1  rec:"Time" 
 -- ComputeVariantX
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Unit
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Value
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- <>var
 -- rec:module or pattern:"Second"  descno: 80  top: 1 "Unit |    %unit "s" |   ..." 
 -- ptn:invoke::isValObj:true:rtnValObj:false:"Second: Unit |    %unit "s" |    ..." 
 -- rec=E:false:rec:"Time" 
 invokeVal Second 80 11
 -- useRtnVal:false:isVal:true:rtnValObj:false:rec=E:false"Time" 
 -- OI:invoke:Second:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"Second" 
 -- $var:gen: "Y: var Length.Meter"
 -- DI:isConst:false:isBasicValue:false:primNo:0 
 -- OGqual:Meter:OGqual.isBasicValue:false:OGqual.isValueObj:true
 -- $ObjectCall:gen: "Length.Meter"
 -- $Invocation:gen: descNo: 56 top: 1 "Length.Meter"
 -- needorigin:"Length.Meter" 
 -- needOrigin:E:"Meter"  E.ATd:"Meter: Unit |    %unit "m" |    %Public |    thi ..." 
 -- LoadOrign:no:loadOrigin: "Unit |    %unit "m" |    %Public |    thisUnit:: Me ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "Length" E: "Meter" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "Meter"
 -- $pattern:loadArgs:E:"Meter":descNo:56:top:1 "Meter: Unit |    %unit "m" |   ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"Meter" 
 -- $ObjectInvocation_Unary:invoke: rec:"Length" "Meter"
 -- >top:1 descNo:56 
 -- $pattern:invoke: "Meter: Unit |    %unit "m" |    %Public |    thisUnit:: Met ..."
 -- Pattern:invoke:descNo:56  top:1  rec:"Length" 
 -- ComputeVariantX
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Unit
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Value
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- <>var
 -- rec:module or pattern:"Meter"  descno: 56  top: 1 "Unit |    %unit "m" |    ..." 
 -- ptn:invoke::isValObj:true:rtnValObj:false:"Meter: Unit |    %unit "m" |     ..." 
 -- rec=E:false:rec:"Length" 
 invokeVal Meter 56 13
 -- useRtnVal:false:isVal:true:rtnValObj:false:rec=E:false"Length" 
 -- OI:invoke:Meter:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"Meter" 
 -- $var:gen: "X: var Float"
 -- DI:isConst:false:isBasicValue:true:primNo:9 
 -- OGqual:float:OGqual.isBasicValue:true:OGqual.isValueObj:true
 -- $var:gen: "d: var Length.Meter"
 -- DI:isConst:false:isBasicValue:false:primNo:0 
 -- OGqual:Meter:OGqual.isBasicValue:false:OGqual.isValueObj:true
 -- $ObjectCall:gen: "Length.Meter"
 -- $Invocation:gen: descNo: 56 top: 1 "Length.Meter"
 -- needorigin:"Length.Meter" 
 -- needOrigin:E:"Meter"  E.ATd:"Meter: Unit |    %unit "m" |    %Public |    thi ..." 
 -- LoadOrign:no:loadOrigin: "Unit |    %unit "m" |    %Public |    thisUnit:: Me ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "Length" E: "Meter" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "Meter"
 -- $pattern:loadArgs:E:"Meter":descNo:56:top:1 "Meter: Unit |    %unit "m" |   ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"Meter" 
 -- $ObjectInvocation_Unary:invoke: rec:"Length" "Meter"
 -- >top:1 descNo:56 
 -- $pattern:invoke: "Meter: Unit |    %unit "m" |    %Public |    thisUnit:: Met ..."
 -- Pattern:invoke:descNo:56  top:1  rec:"Length" 
 -- ComputeVariantX
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Unit
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Value
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- <>var
 -- rec:module or pattern:"Meter"  descno: 56  top: 1 "Unit |    %unit "m" |    ..." 
 -- ptn:invoke::isValObj:true:rtnValObj:false:"Meter: Unit |    %unit "m" |     ..." 
 -- rec=E:false:rec:"Length" 
 invokeVal Meter 56 17
 -- useRtnVal:false:isVal:true:rtnValObj:false:rec=E:false"Length" 
 -- OI:invoke:Meter:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"Meter" 
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%include Dimensions" 
 -- $Property:gen: "%include Dimensions"
 -- genclass:Qgen:stmt:"exhaustSpeed := 1000000.0"m*s^-1"" 
 -- $ObjectCall:gen: "exhaustSpeed := 1000000.0"m*s^-1""
 -- $Invocation:gen: descNo: 4 top: 1 "exhaustSpeed := 1000000.0"m*s^-1""
 -- needorigin:"exhaustSpeed := 1000000.0"m*s^-1"" 
 -- needOrigin:E:":= 1000000.0"m*s^-1""  E.ATd:":= :  |    %basic 8 |    in V:  ..." 
 -- computeAdr: "exhaustSpeed := 1000000.0"m*s^-1"" 
 -- computeAdr:1 :rec:"none"  E:"exhaustSpeed" :Address:E:"none"off:0 size: ...
 -- $ObjectInvocation_Unary:pushThis: "exhaustSpeed"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "exhaustSpeed"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "exhaustSpeed"
 -- $var:getAdr:,newOff:4,isValue:"True",A.isValue:"False" "exhaustSpeed: v ..."
 --  A::Address:E:"exhaustSpeed"off:0 size:0 isFloat:False superAdj:0 isUni ...  ...e ...
 -- value_prim:false
 -- Velocity.MperS
 -- before:floatTest: %unit "m*s^-1", "m*s^-1"
 -- computeAdr:isFirst::Address:E:"exhaustSpeed"off:4 size:0 isFloat:False  ...
 -- computeAdr:2 :rec:"exhaustSpeed"  E:":= 1000000.0"m*s^-1"" :Address:E:" ..."
 -- computeAdr:isAssign:rec: "exhaustSpeed"  E:":= 1000000.0"m*s^-1"" 
 -- :Address:E:"exhaustSpeed"off:4 size:0 isFloat:False superAdj:0 isUnique ...
 -- computeAdr:isLast:E: ":= 1000000.0"m*s^-1"" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"exhaustSpeed"off:4 size:0 is ...
 -- rec: "exhaustSpeed" E: ":= 1000000.0"m*s^-1"" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:4 ":= 1000000.0"m*s^-1""
 -- $pattern:loadArgs:E:":= 1000000.0"m*s^-1"":descNo:4:top:1 ":= :  |    %ba ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= 1000000.0"m*s^-1"" ActArg: "1000000.0"m*s^-1"" isV ...true
 -- $ObjectCall:gen: "1000000.0"m*s^-1""
 -- $Invocation:gen: "1000000.0"m*s^-1""
 -- needorigin:"1000000.0"m*s^-1"" 
 -- needOrigin:E:"1000000.0"m*s^-1""  E.ATd:"float: Value |    %globals |    %b ..." 
 -- LoadOrign:no:loadOrigin: "Value |    %globals |    %basic 9 |    _thisBasicVa ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "1000000.0"m*s^-1"" E: "1000000.0"m*s^-1"" isValueAssign: false
 -- $FloatLiteral:loadArgs: "1000000.0"m*s^-1""
 -- invoke:after:loadArgsOf:"1000000.0"m*s^-1"" 
 -- $FloatLiteral:invoke: "1000000.0"m*s^-1""
 pushFloatConst 1000000.000000
 -- invoke:after:E.invoke:"1000000.0"m*s^-1"" 
 -- loadArgs:after:Qgen:":= 1000000.0"m*s^-1"" 
 -- vAssign:fArg:"in V: var Value" 
 -- BINGO
 -- aaaa: in V: var Value
 -- end:loadArgs:NonVirt:":= 1000000.0"m*s^-1"" 
 -- invoke:after:loadArgsOf:":= 1000000.0"m*s^-1"" :Address:E:"exhaustSpeed ..."
 -- $ObjectInvocation_Binary:invoke: rec:"exhaustSpeed" ":= 1000000.0"m*s^- ...
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Address:E:"exhaustSpeed"off:4 size:0 isFloat:False superAdj:0 isUn ...
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "exhaustSpeed" from: ":= 1000000.0"m*s^-1"" 
 -- assign:dstDI :"exhaustSpeed: var Velocity.MperS" isUnitValueObj: true
 -- assign:arg: "1000000.0"m*s^-1"" lab:"ObjectCall" UnitValObj :false ptn: ...false
 --  float: true DataItem:false arg.super:1000000.0"m*s^-1"
 --  arg.super.ATd:"Invocation" "float: Value |    %globals |    %basic 9 |    _t ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:true
 --  arg.super.ATd.label: "pattern" 
 -- assign:simple value: 
 -- :Address:E:"exhaustSpeed"off:4 size:0 isFloat:False superAdj:0 isUnique ...
 -- store::Address:E:"exhaustSpeed"off:4 size:0 isFloat:False superAdj:0 is ...
 -- isValue:true isAdr:false descNo: 0 
 -- isFloat: false
 fstoreg 4 address:storeg
 -- OI:invoke::= 1000000.0"m*s^-1":unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= 1000000.0"m*s^-1"" 
 -- genclass:Qgen:stmt:"rocketMass := 40"kg"" 
 -- $ObjectCall:gen: "rocketMass := 40"kg""
 -- $Invocation:gen: descNo: 4 top: 1 "rocketMass := 40"kg""
 -- needorigin:"rocketMass := 40"kg"" 
 -- needOrigin:E:":= 40"kg""  E.ATd:":= :  |    %basic 8 |    in V: var Value" 
 -- computeAdr: "rocketMass := 40"kg"" 
 -- computeAdr:1 :rec:"none"  E:"rocketMass" :Address:E:"none"off:0 size:0  ...
 -- $ObjectInvocation_Unary:pushThis: "rocketMass"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "rocketMass"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "rocketMass"
 -- $var:getAdr:,newOff:6,isValue:"True",A.isValue:"False" "rocketMass: var ..."
 --  A::Address:E:"rocketMass"off:0 size:0 isFloat:False superAdj:0 isUniqu ...  ...r ...
 -- value_prim:false
 -- Mass.KiloGram
 -- before:floatTest: %unit "kg"
 -- computeAdr:isFirst::Address:E:"rocketMass"off:6 size:0 isFloat:False su ...
 -- computeAdr:2 :rec:"rocketMass"  E:":= 40"kg"" :Address:E:"rocketMass"of ...
 -- computeAdr:isAssign:rec: "rocketMass"  E:":= 40"kg"" 
 -- :Address:E:"rocketMass"off:6 size:0 isFloat:False superAdj:0 isUnique:F ...
 -- computeAdr:isLast:E: ":= 40"kg"" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"rocketMass"off:6 size:0 isFl ...
 -- rec: "rocketMass" E: ":= 40"kg"" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:6 ":= 40"kg""
 -- $pattern:loadArgs:E:":= 40"kg"":descNo:4:top:1 ":= :  |    %basic 8 |    in ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= 40"kg"" ActArg: "40"kg"" isValue: true
 -- $ObjectCall:gen: "40"kg""
 -- $Invocation:gen: "40"kg""
 -- needorigin:"40"kg"" 
 -- needOrigin:E:"40"kg""  E.ATd:"integer: value |    %basic 1, 32 |    %global ..." 
 -- LoadOrign:no:loadOrigin: "value |    %basic 1, 32 |    %globals |    %public |  ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "40"kg"" E: "40"kg"" isValueAssign: false
 -- $ConstLiteral:loadArgs: "40"kg""
 -- invoke:after:loadArgsOf:"40"kg"" 
 -- $ConstLiteral:invoke: "40"kg""
 pushc 40
 -- invoke:after:E.invoke:"40"kg"" 
 -- loadArgs:after:Qgen:":= 40"kg"" 
 -- vAssign:fArg:"in V: var Value" 
 -- BINGO
 -- aaaa: in V: var Value
 -- end:loadArgs:NonVirt:":= 40"kg"" 
 -- invoke:after:loadArgsOf:":= 40"kg"" :Address:E:"rocketMass"off:6 size:0 ...
 -- $ObjectInvocation_Binary:invoke: rec:"rocketMass" ":= 40"kg""
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Address:E:"rocketMass"off:6 size:0 isFloat:False superAdj:0 isUniq ...
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "rocketMass" from: ":= 40"kg"" 
 -- assign:dstDI :"rocketMass: var Mass.KiloGram" isUnitValueObj: true
 -- assign:arg: "40"kg"" lab:"ObjectCall" UnitValObj :false ptn: false
 --  float: false DataItem:false arg.super:40"kg"
 --  arg.super.ATd:"Invocation" "integer: value |    %basic 1, 32 |    %globals ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "pattern" 
 -- assign:simple value: 
 i2f
 -- :Address:E:"rocketMass"off:6 size:0 isFloat:False superAdj:0 isUnique:F ...
 -- store::Address:E:"rocketMass"off:6 size:0 isFloat:False superAdj:0 isUn ...
 -- isValue:true isAdr:false descNo: 0 
 -- isFloat: false
 fstoreg 6 address:storeg
 -- OI:invoke::= 40"kg":unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= 40"kg"" 
 -- genclass:Qgen:stmt:"fuelMass := 10000"kg"" 
 -- $ObjectCall:gen: "fuelMass := 10000"kg""
 -- $Invocation:gen: descNo: 4 top: 1 "fuelMass := 10000"kg""
 -- needorigin:"fuelMass := 10000"kg"" 
 -- needOrigin:E:":= 10000"kg""  E.ATd:":= :  |    %basic 8 |    in V: var Valu ..." 
 -- computeAdr: "fuelMass := 10000"kg"" 
 -- computeAdr:1 :rec:"none"  E:"fuelMass" :Address:E:"none"off:0 size:0 is ...
 -- $ObjectInvocation_Unary:pushThis: "fuelMass"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "fuelMass"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "fuelMass"
 -- $var:getAdr:,newOff:8,isValue:"True",A.isValue:"False" "fuelMass: var M ..."
 --  A::Address:E:"fuelMass"off:0 size:0 isFloat:False superAdj:0 isUnique: ...  ...f ...
 -- value_prim:false
 -- Mass.KiloGram
 -- before:floatTest: %unit "kg"
 -- computeAdr:isFirst::Address:E:"fuelMass"off:8 size:0 isFloat:False supe ...
 -- computeAdr:2 :rec:"fuelMass"  E:":= 10000"kg"" :Address:E:"fuelMass"off ...
 -- computeAdr:isAssign:rec: "fuelMass"  E:":= 10000"kg"" 
 -- :Address:E:"fuelMass"off:8 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- computeAdr:isLast:E: ":= 10000"kg"" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"fuelMass"off:8 size:0 isFloa ...
 -- rec: "fuelMass" E: ":= 10000"kg"" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:8 ":= 10000"kg""
 -- $pattern:loadArgs:E:":= 10000"kg"":descNo:4:top:1 ":= :  |    %basic 8 |    ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= 10000"kg"" ActArg: "10000"kg"" isValue: true
 -- $ObjectCall:gen: "10000"kg""
 -- $Invocation:gen: "10000"kg""
 -- needorigin:"10000"kg"" 
 -- needOrigin:E:"10000"kg""  E.ATd:"integer: value |    %basic 1, 32 |    %glo ..." 
 -- LoadOrign:no:loadOrigin: "value |    %basic 1, 32 |    %globals |    %public |  ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "10000"kg"" E: "10000"kg"" isValueAssign: false
 -- $ConstLiteral:loadArgs: "10000"kg""
 -- invoke:after:loadArgsOf:"10000"kg"" 
 -- $ConstLiteral:invoke: "10000"kg""
 pushc 10000
 -- invoke:after:E.invoke:"10000"kg"" 
 -- loadArgs:after:Qgen:":= 10000"kg"" 
 -- vAssign:fArg:"in V: var Value" 
 -- BINGO
 -- aaaa: in V: var Value
 -- end:loadArgs:NonVirt:":= 10000"kg"" 
 -- invoke:after:loadArgsOf:":= 10000"kg"" :Address:E:"fuelMass"off:8 size: ...
 -- $ObjectInvocation_Binary:invoke: rec:"fuelMass" ":= 10000"kg""
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Address:E:"fuelMass"off:8 size:0 isFloat:False superAdj:0 isUnique ...
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "fuelMass" from: ":= 10000"kg"" 
 -- assign:dstDI :"fuelMass: var Mass.KiloGram" isUnitValueObj: true
 -- assign:arg: "10000"kg"" lab:"ObjectCall" UnitValObj :false ptn: false
 --  float: false DataItem:false arg.super:10000"kg"
 --  arg.super.ATd:"Invocation" "integer: value |    %basic 1, 32 |    %globals ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "pattern" 
 -- assign:simple value: 
 i2f
 -- :Address:E:"fuelMass"off:8 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- store::Address:E:"fuelMass"off:8 size:0 isFloat:False superAdj:0 isUniq ...
 -- isValue:true isAdr:false descNo: 0 
 -- isFloat: false
 fstoreg 8 address:storeg
 -- OI:invoke::= 10000"kg":unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= 10000"kg"" 
 -- genclass:Qgen:stmt:"distToAlpha := 70"ly"" 
 -- $ObjectCall:gen: "distToAlpha := 70"ly""
 -- $Invocation:gen: descNo: 4 top: 1 "distToAlpha := 70"ly""
 -- needorigin:"distToAlpha := 70"ly"" 
 -- needOrigin:E:":= 70"ly""  E.ATd:":= :  |    %basic 8 |    in V: var Value" 
 -- computeAdr: "distToAlpha := 70"ly"" 
 -- computeAdr:1 :rec:"none"  E:"distToAlpha" :Address:E:"none"off:0 size:0 ...
 -- $ObjectInvocation_Unary:pushThis: "distToAlpha"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "distToAlpha"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "distToAlpha"
 -- $var:getAdr:,newOff:10,isValue:"True",A.isValue:"False" "distToAlpha: v ..."
 --  A::Address:E:"distToAlpha"off:0 size:0 isFloat:False superAdj:0 isUniq ...  ...d ...
 -- value_prim:false
 -- Length.LightYear
 -- before:floatTest: %unit "ly", "9460000000000000"
 -- computeAdr:isFirst::Address:E:"distToAlpha"off:10 size:0 isFloat:False  ...
 -- computeAdr:2 :rec:"distToAlpha"  E:":= 70"ly"" :Address:E:"distToAlpha" ...
 -- computeAdr:isAssign:rec: "distToAlpha"  E:":= 70"ly"" 
 -- :Address:E:"distToAlpha"off:10 size:0 isFloat:False superAdj:0 isUnique ...
 -- computeAdr:isLast:E: ":= 70"ly"" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"distToAlpha"off:10 size:0 is ...
 -- rec: "distToAlpha" E: ":= 70"ly"" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:10 ":= 70"ly""
 -- $pattern:loadArgs:E:":= 70"ly"":descNo:4:top:1 ":= :  |    %basic 8 |    in ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= 70"ly"" ActArg: "70"ly"" isValue: true
 -- $ObjectCall:gen: "70"ly""
 -- $Invocation:gen: "70"ly""
 -- needorigin:"70"ly"" 
 -- needOrigin:E:"70"ly""  E.ATd:"integer: value |    %basic 1, 32 |    %global ..." 
 -- LoadOrign:no:loadOrigin: "value |    %basic 1, 32 |    %globals |    %public |  ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "70"ly"" E: "70"ly"" isValueAssign: false
 -- $ConstLiteral:loadArgs: "70"ly""
 -- invoke:after:loadArgsOf:"70"ly"" 
 -- $ConstLiteral:invoke: "70"ly""
 pushc 70
 -- invoke:after:E.invoke:"70"ly"" 
 -- loadArgs:after:Qgen:":= 70"ly"" 
 -- vAssign:fArg:"in V: var Value" 
 -- BINGO
 -- aaaa: in V: var Value
 -- end:loadArgs:NonVirt:":= 70"ly"" 
 -- invoke:after:loadArgsOf:":= 70"ly"" :Address:E:"distToAlpha"off:10 size ...
 -- $ObjectInvocation_Binary:invoke: rec:"distToAlpha" ":= 70"ly""
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Address:E:"distToAlpha"off:10 size:0 isFloat:False superAdj:0 isUn ...
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "distToAlpha" from: ":= 70"ly"" 
 -- assign:dstDI :"distToAlpha: var Length.LightYear" isUnitValueObj: true
 -- assign:arg: "70"ly"" lab:"ObjectCall" UnitValObj :false ptn: false
 --  float: false DataItem:false arg.super:70"ly"
 --  arg.super.ATd:"Invocation" "integer: value |    %basic 1, 32 |    %globals ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "pattern" 
 -- assign:simple value: 
 i2f
 -- :Address:E:"distToAlpha"off:10 size:0 isFloat:False superAdj:0 isUnique ...
 -- store::Address:E:"distToAlpha"off:10 size:0 isFloat:False superAdj:0 is ...
 -- isValue:true isAdr:false descNo: 0 
 -- isFloat: false
 fstoreg 10 address:storeg
 -- OI:invoke::= 70"ly":unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= 70"ly"" 
 -- genclass:Qgen:stmt:""distToAlpha: ".print" 
 -- $ObjectCall:gen: ""distToAlpha: ".print"
 -- $Invocation:gen: descNo: 33 top: 1 ""distToAlpha: ".print"
 -- needorigin:""distToAlpha: ".print" 
 -- needOrigin:E:"print"  E.ATd:"print:  |    @for 1 :to length  |    :do  |      ..." 
 -- computeAdr: ""distToAlpha: ".print" 
 -- computeAdr:1 :rec:"none"  E:""distToAlpha: "" :Address:E:"none"off:0 si ...
 -- $String::pushThis: ""distToAlpha: ""
 -- $String::loadOrigin: ""distToAlpha: ""
 -- StringObj:loadOrigin:"distToAlpha: "
 -- $String::getAdr: ""distToAlpha: ""
 -- computeAdr:isFirst::Address:E:""distToAlpha: ""off:0 size:0 isFloat:Fal ...
 -- computeAdr:2 :rec:""distToAlpha: ""  E:"print" :Address:E:""distToAlpha ...
 -- E:notAssign:print
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "print"
 -- $pattern:getAdr: "print:  |    @for 1 :to length  |    :do  |       put(@get  ..."
 -- :Address:E:""distToAlpha: ""off:0 size:0 isFloat:False superAdj:0 isUni ...
 -- ptn.ssUnitValueObj:false isFloat:false
 -- $String::loadArgs: ""distToAlpha: ""
 -- $String::invoke: ""distToAlpha: ""
 -- Pattern:markForCodeGen:+ :  |    in S: ref String |    out V: ref String |    ...
 pushText distToAlpha: 
 -- computeAdr:isLast:E: "print" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:""distToAlpha: ""off:0 size:0 ...
 -- rec: ""distToAlpha: "" E: "print" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "print"
 -- $pattern:loadArgs:E:"print":descNo:33:top:1 "print:  |    @for 1 :to leng ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"print" :Address:E:""distToAlpha: ""off:0 size: ...
 -- $ObjectInvocation_Unary:invoke: rec:""distToAlpha: "" "print"
 -- >top:1 descNo:33 
 -- E.ATd: "print" unique: false
 -- adr::Address:E:""distToAlpha: ""off:0 size:0 isFloat:False superAdj:0 i ...
 -- $pattern:invoke: "print:  |    @for 1 :to length  |    :do  |       put(@get  ..."
 -- Pattern:invoke:descNo:33  top:1  rec:""distToAlpha: "" 
 -- ComputeVariantX
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- <>var
 -- rec:module or pattern:"print"  descno: 33  top: 1 "@for 1 :to length  | : ..." 
 -- ptn:invoke::isValObj:false:rtnValObj:false:"print:  |    @for 1 :to lengt ..." 
 -- rec=E:false:rec:""distToAlpha: "" 
 -- kuk:obj:rec.ATd:"String:  |    %OSDvisibility disguised |    %basic 5 |    %i ..." 
 invoke print 33 0 0
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:false""distToAlpha: " ..." 
 rpop
 -- OI:invoke:print:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"print" 
 -- genclass:Qgen:stmt:"putFloat(distToAlpha)" 
 -- $ObjectCall:gen: "putFloat(distToAlpha)"
 -- $Invocation:gen: descNo: 43 top: 1 "putFloat(distToAlpha)"
 -- needorigin:"putFloat(distToAlpha)" 
 -- needOrigin:E:"putFloat(distToAlpha)"  E.ATd:"putFloat:  |    %basic 142 |   ..." 
 -- computeAdr: "putFloat(distToAlpha)" 
 -- computeAdr:1 :rec:"none"  E:"putFloat(distToAlpha)" :Address:E:"none"of ...
 -- $ObjectInvocation_Function:pushThis: "putFloat(distToAlpha)"
 -- $ObjectInvocation_Function:loadOrigin::on:2 "putFloat(distToAlpha)"
 -- $ObjectInvocation_Function:getAdr::superAdj:0:on:2 "putFloat(distToAlph ..."
 -- $pattern:getAdr: "putFloat:  |    %basic 142 |    in X: var Float |    out V: ..."
 -- :Address:E:"putFloat(distToAlpha)"off:0 size:0 isFloat:False superAdj:0 ...
 -- computeAdr:isFirst::Address:E:"putFloat(distToAlpha)"off:0 size:0 isFlo ...
 -- computeAdr:isLast:E: "putFloat(distToAlpha)" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"putFloat(distToAlpha)"off:0  ...
 -- rec: "putFloat(distToAlpha)" E: "putFloat(distToAlpha)" isValueAssign:  ...false
 -- $ObjectInvocation_Function:loadArgs:staticOff:0 "putFloat(distToAlpha)" ...
 -- $pattern:loadArgs:E:"putFloat(distToAlpha)":descNo:43:top:1 "putFloat:  ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"putFloat(distToAlpha)" ActArg: "distToAlpha" isValue: ...true
 -- loadArgs:not:*: formalArgOf:"putFloat(distToAlpha)"  isCompositeValueOb ...false
 -- $ObjectGenerator:gen:"distToAlpha#S#0"IS.isempty! staticOff: 0 descNo:  ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: false
 -- $Invocation:gen: "distToAlpha"
 -- needorigin:"distToAlpha" 
 -- needOrigin:E:"distToAlpha"  E.ATd:"distToAlpha: var Length.LightYear" 
 -- needOrigin:datItem:leave
 -- computeAdr: "distToAlpha" 
 -- computeAdr:1 :rec:"none"  E:"distToAlpha" :Address:E:"none"off:0 size:0 ...
 -- $ObjectInvocation_Unary:pushThis: "distToAlpha"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "distToAlpha"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "distToAlpha"
 -- $var:getAdr:,newOff:10,isValue:"True",A.isValue:"False" "distToAlpha: v ..."
 --  A::Address:E:"distToAlpha"off:0 size:0 isFloat:False superAdj:0 isUniq ...  ...d ...
 -- value_prim:false
 -- Length.LightYear
 -- before:floatTest: %unit "ly", "9460000000000000"
 -- computeAdr:isFirst::Address:E:"distToAlpha"off:10 size:0 isFloat:False  ...
 -- computeAdr:isLast:E: "distToAlpha" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"distToAlpha"off:10 size:0 is ...
 -- rec: "distToAlpha" E: "distToAlpha" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "distToAlpha"
 -- $var:loadArgs: "distToAlpha: var Length.LightYear"
 -- invoke:after:loadArgsOf:"distToAlpha" :Address:E:"distToAlpha"off:10 si ...
 -- $ObjectInvocation_Unary:invoke: rec:"distToAlpha" "distToAlpha"
 -- E.ATd: "distToAlpha" unique: false
 -- adr::Address:E:"distToAlpha"off:10 size:0 isFloat:False superAdj:0 isUn ...
 -- $var:invoke: newOff:10 "distToAlpha: var Length.LightYear"
 -- >LoadValue:isAdr:false,Size:2 ,rec:"distToAlpha" ,E:"distToAlpha" 
 -- isCompositeValueObj: false
 -- loadAdr::Address:E:"distToAlpha"off:10 size:0 isFloat:False superAdj:0  ...
 -- loadAdr:isValue:originIsValue:false
 -- isFloat: false
 fpushg 10 
 -- OI:invoke:distToAlpha:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"distToAlpha" 
 -- loadArgs:after:Qgen:"putFloat(distToAlpha)" 
 -- before:pushSize: actualArg.super.ATd.OG.isUnitValueObj:true
 -- :actualArg.isCompositeValueObj:false isAssign: false
 -- actualArg:UnitOne?:distToAlpha
 -- end:loadArgs:NonVirt:"putFloat(distToAlpha)" 
 -- invoke:after:loadArgsOf:"putFloat(distToAlpha)" :Address:E:"putFloat(di ..."
 -- $ObjectInvocation_Function:invoke: rec:"putFloat(distToAlpha)" "putFloa ..."
 -- >top:1 descNo:43 
 -- E.ATd: "putFloat" unique: false
 -- adr::Address:E:"putFloat(distToAlpha)"off:0 size:0 isFloat:False superA ...
 -- $pattern:invoke: "putFloat:  |    %basic 142 |    in X: var Float |    out V: ..."
 -- Pattern:invoke:descNo:43  top:1  rec:"putFloat(distToAlpha)" 
 -- ptn:invoke:primitive:putFloat
 %printf_prim 142
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:true"putFloat(distToA ..." 
 vpop
 -- OI:invoke:putFloat(distToAlpha):unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"putFloat(distToAlpha)" 
 -- genclass:Qgen:stmt:"Y := distToAlpha.toBase" 
 -- $ObjectCall:gen: "Y := distToAlpha.toBase"
 -- $Invocation:gen: descNo: 4 top: 1 "Y := distToAlpha.toBase"
 -- needorigin:"Y := distToAlpha.toBase" 
 -- needOrigin:E:":= distToAlpha.toBase"  E.ATd:":= :  |    %basic 8 |    in V: ..." 
 -- computeAdr: "Y := distToAlpha.toBase" 
 -- computeAdr:1 :rec:"none"  E:"Y" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "Y"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "Y"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "Y"
 -- $var:getAdr:,newOff:14,isValue:"True",A.isValue:"False" "Y: var Length. ..."
 --  A::Address:E:"Y"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...Y ...
 -- value_prim:false
 -- Length.Meter
 -- before:floatTest: %unit "m"
 -- computeAdr:isFirst::Address:E:"Y"off:14 size:0 isFloat:False superAdj:0 ...
 -- computeAdr:2 :rec:"Y"  E:":= distToAlpha.toBase" :Address:E:"Y"off:14 s ...
 -- computeAdr:isAssign:rec: "Y"  E:":= distToAlpha.toBase" 
 -- :Address:E:"Y"off:14 size:0 isFloat:False superAdj:0 isUnique:False isV ...
 -- computeAdr:isLast:E: ":= distToAlpha.toBase" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"Y"off:14 size:0 isFloat:Fals ...
 -- rec: "Y" E: ":= distToAlpha.toBase" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:14 ":= distToAlpha.toBase"
 -- $pattern:loadArgs:E:":= distToAlpha.toBase":descNo:4:top:1 ":= :  |    %b ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= distToAlpha.toBase" ActArg: "distToAlpha.toBase" i ...false
 -- $ObjectCall:gen: "distToAlpha.toBase"
 -- $Invocation:gen: descNo: 73 top: 1 "distToAlpha.toBase"
 -- needorigin:"distToAlpha.toBase" 
 -- needOrigin:E:"toBase"  E.ATd:"toBase::  |    --bxx: var BaseUnit |    --bxx ..." 
 -- computeAdr: "distToAlpha.toBase" 
 -- computeAdr:1 :rec:"none"  E:"distToAlpha" :Address:E:"none"off:0 size:0 ...
 -- $ObjectInvocation_Unary:pushThis: "distToAlpha"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "distToAlpha"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "distToAlpha"
 -- $var:getAdr:,newOff:10,isValue:"True",A.isValue:"False" "distToAlpha: v ..."
 --  A::Address:E:"distToAlpha"off:0 size:0 isFloat:False superAdj:0 isUniq ...  ...d ...
 -- value_prim:false
 -- Length.LightYear
 -- before:floatTest: %unit "ly", "9460000000000000"
 -- computeAdr:isFirst::Address:E:"distToAlpha"off:10 size:0 isFloat:False  ...
 -- computeAdr:2 :rec:"distToAlpha"  E:"toBase" :Address:E:"distToAlpha"off ...
 -- E:notAssign:toBase
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "toBase"
 -- $pattern:getAdr: "toBase::  |    --bxx: var BaseUnit |    --bxx := magnitud ..."
 -- :Address:E:"distToAlpha"off:10 size:0 isFloat:False superAdj:0 isUnique ...
 -- ptn.ssUnitValueObj:false isFloat:false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "distToAlpha"
 -- $var:loadArgs: "distToAlpha: var Length.LightYear"
 -- $ObjectInvocation_Unary:invoke: rec:"distToAlpha" "distToAlpha"
 -- E.ATd: "toBase" unique: false
 -- adr::Address:E:"distToAlpha"off:10 size:0 isFloat:False superAdj:0 isUn ...
 -- $var:invoke: newOff:10 "distToAlpha: var Length.LightYear"
 -- >LoadValue:isAdr:true,Size:2 ,rec:"distToAlpha" ,E:"toBase" 
 -- isCompositeValueObj: false
 -- loadAdr::Address:E:"distToAlpha"off:10 size:0 isFloat:False superAdj:0  ...
 -- loadAdr:isValue:originIsValue:false
 -- isFloat: false
 addOff 10
 -- OI:invoke:distToAlpha:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "toBase" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"distToAlpha"off:10 size:0 is ...
 -- rec: "distToAlpha" E: "toBase" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "toBase"
 -- $pattern:loadArgs:E:"toBase":descNo:73:top:1 "toBase::  |    --bxx: var B ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"toBase" :Address:E:"distToAlpha"off:10 size:0  ...
 -- $ObjectInvocation_Unary:invoke: rec:"distToAlpha" "toBase"
 -- >top:1 descNo:73 
 -- E.ATd: "toBase" unique: false
 -- adr::Address:E:"distToAlpha"off:10 size:0 isFloat:False superAdj:0 isUn ...
 -- $pattern:invoke: "toBase::  |    --bxx: var BaseUnit |    --bxx := magnitud ..."
 -- Pattern:invoke:descNo:73  top:1  rec:"distToAlpha" 
 -- ComputeVariantX
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:toBase
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- <>var
 invoke toBase 73 0 1
 -- useRtnVal:true:isVal:false:rtnValObj:false:rec=E:false"distToAlpha" 
 -- OI:invoke:toBase:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"toBase" 
 -- loadArgs:after:Qgen:":= distToAlpha.toBase" 
 -- vAssign:fArg:"in V: var Value" 
 -- BINGO
 -- loadArgs:assign:srcDI:rtnValueObj: base
 pushvalue 2
 -- end:loadArgs:NonVirt:":= distToAlpha.toBase" 
 -- invoke:after:loadArgsOf:":= distToAlpha.toBase" :Address:E:"Y"off:14 si ...
 -- $ObjectInvocation_Binary:invoke: rec:"Y" ":= distToAlpha.toBase"
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Address:E:"Y"off:14 size:0 isFloat:False superAdj:0 isUnique:False ...
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "Y" from: ":= distToAlpha.toBase" 
 -- assign:dstDI :"Y: var Length.Meter" isUnitValueObj: true
 -- assign:arg: "distToAlpha.toBase" lab:"ObjectCall" UnitValObj :false ptn ...false
 --  float: false DataItem:false arg.super:distToAlpha.toBase
 --  arg.super.ATd:"Invocation" "toBase::  |    --bxx: var BaseUnit |    --bxx  ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "pattern" 
 -- assign:ValueObj:isPtn: true size:2 
 -- :Address:E:"Y"off:14 size:2 isFloat:False superAdj:0 isUnique:False isV ...
 -- store::Address:E:"Y"off:14 size:2 isFloat:False superAdj:0 isUnique:Fal ...
 -- isValue:true isAdr:true descNo: 0 
 -- Address:store::srcIsVal:false destIsVal:false mode:0 
 addOff 14
 vassign 2 0
 -- OI:invoke::= distToAlpha.toBase:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= distToAlpha.toBase" 
 -- genclass:Qgen:stmt:""ly in meter: ".print" 
 -- $ObjectCall:gen: ""ly in meter: ".print"
 -- $Invocation:gen: descNo: 33 top: 1 ""ly in meter: ".print"
 -- needorigin:""ly in meter: ".print" 
 -- needOrigin:E:"print"  E.ATd:"print:  |    @for 1 :to length  |    :do  |      ..." 
 -- computeAdr: ""ly in meter: ".print" 
 -- computeAdr:1 :rec:"none"  E:""ly in meter: "" :Address:E:"none"off:0 si ...
 -- $String::pushThis: ""ly in meter: ""
 -- $String::loadOrigin: ""ly in meter: ""
 -- StringObj:loadOrigin:"ly in meter: "
 -- $String::getAdr: ""ly in meter: ""
 -- computeAdr:isFirst::Address:E:""ly in meter: ""off:0 size:0 isFloat:Fal ...
 -- computeAdr:2 :rec:""ly in meter: ""  E:"print" :Address:E:""ly in meter ...
 -- E:notAssign:print
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "print"
 -- $pattern:getAdr: "print:  |    @for 1 :to length  |    :do  |       put(@get  ..."
 -- :Address:E:""ly in meter: ""off:0 size:0 isFloat:False superAdj:0 isUni ...
 -- ptn.ssUnitValueObj:false isFloat:false
 -- $String::loadArgs: ""ly in meter: ""
 -- $String::invoke: ""ly in meter: ""
 -- Pattern:markForCodeGen:+ :  |    in S: ref String |    out V: ref String |    ...
 pushText ly in meter: 
 -- computeAdr:isLast:E: "print" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:""ly in meter: ""off:0 size:0 ...
 -- rec: ""ly in meter: "" E: "print" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "print"
 -- $pattern:loadArgs:E:"print":descNo:33:top:1 "print:  |    @for 1 :to leng ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"print" :Address:E:""ly in meter: ""off:0 size: ...
 -- $ObjectInvocation_Unary:invoke: rec:""ly in meter: "" "print"
 -- >top:1 descNo:33 
 -- E.ATd: "print" unique: false
 -- adr::Address:E:""ly in meter: ""off:0 size:0 isFloat:False superAdj:0 i ...
 -- $pattern:invoke: "print:  |    @for 1 :to length  |    :do  |       put(@get  ..."
 -- Pattern:invoke:descNo:33  top:1  rec:""ly in meter: "" 
 -- ComputeVariantX
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- <>var
 -- rec:module or pattern:"print"  descno: 33  top: 1 "@for 1 :to length  | : ..." 
 -- ptn:invoke::isValObj:false:rtnValObj:false:"print:  |    @for 1 :to lengt ..." 
 -- rec=E:false:rec:""ly in meter: "" 
 -- kuk:obj:rec.ATd:"String:  |    %OSDvisibility disguised |    %basic 5 |    %i ..." 
 invoke print 33 0 0
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:false""ly in meter: " ..." 
 rpop
 -- OI:invoke:print:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"print" 
 -- genclass:Qgen:stmt:"putFloat(Y)" 
 -- $ObjectCall:gen: "putFloat(Y)"
 -- $Invocation:gen: descNo: 43 top: 1 "putFloat(Y)"
 -- needorigin:"putFloat(Y)" 
 -- needOrigin:E:"putFloat(Y)"  E.ATd:"putFloat:  |    %basic 142 |    in X: va ..." 
 -- computeAdr: "putFloat(Y)" 
 -- computeAdr:1 :rec:"none"  E:"putFloat(Y)" :Address:E:"none"off:0 size:0 ...
 -- $ObjectInvocation_Function:pushThis: "putFloat(Y)"
 -- $ObjectInvocation_Function:loadOrigin::on:2 "putFloat(Y)"
 -- $ObjectInvocation_Function:getAdr::superAdj:0:on:2 "putFloat(Y)"
 -- $pattern:getAdr: "putFloat:  |    %basic 142 |    in X: var Float |    out V: ..."
 -- :Address:E:"putFloat(Y)"off:0 size:0 isFloat:False superAdj:0 isUnique: ...
 -- computeAdr:isFirst::Address:E:"putFloat(Y)"off:0 size:0 isFloat:False s ...
 -- computeAdr:isLast:E: "putFloat(Y)" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"putFloat(Y)"off:0 size:0 isF ...
 -- rec: "putFloat(Y)" E: "putFloat(Y)" isValueAssign: false
 -- $ObjectInvocation_Function:loadArgs:staticOff:0 "putFloat(Y)"
 -- $pattern:loadArgs:E:"putFloat(Y)":descNo:43:top:1 "putFloat:  |    %basic ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"putFloat(Y)" ActArg: "Y" isValue: true
 -- loadArgs:not:*: formalArgOf:"putFloat(Y)"  isCompositeValueObj:false
 -- $ObjectGenerator:gen:"Y#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 "Y ..."
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: false
 -- $Invocation:gen: "Y"
 -- needorigin:"Y" 
 -- needOrigin:E:"Y"  E.ATd:"Y: var Length.Meter" 
 -- needOrigin:datItem:leave
 -- computeAdr: "Y" 
 -- computeAdr:1 :rec:"none"  E:"Y" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "Y"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "Y"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "Y"
 -- $var:getAdr:,newOff:14,isValue:"True",A.isValue:"False" "Y: var Length. ..."
 --  A::Address:E:"Y"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...Y ...
 -- value_prim:false
 -- Length.Meter
 -- before:floatTest: %unit "m"
 -- computeAdr:isFirst::Address:E:"Y"off:14 size:0 isFloat:False superAdj:0 ...
 -- computeAdr:isLast:E: "Y" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"Y"off:14 size:0 isFloat:Fals ...
 -- rec: "Y" E: "Y" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "Y"
 -- $var:loadArgs: "Y: var Length.Meter"
 -- invoke:after:loadArgsOf:"Y" :Address:E:"Y"off:14 size:0 isFloat:False s ...
 -- $ObjectInvocation_Unary:invoke: rec:"Y" "Y"
 -- E.ATd: "Y" unique: false
 -- adr::Address:E:"Y"off:14 size:0 isFloat:False superAdj:0 isUnique:False ...
 -- $var:invoke: newOff:14 "Y: var Length.Meter"
 -- >LoadValue:isAdr:false,Size:2 ,rec:"Y" ,E:"Y" 
 -- isCompositeValueObj: false
 -- loadAdr::Address:E:"Y"off:14 size:0 isFloat:False superAdj:0 isUnique:F ...
 -- loadAdr:isValue:originIsValue:false
 -- isFloat: false
 fpushg 14 
 -- OI:invoke:Y:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"Y" 
 -- loadArgs:after:Qgen:"putFloat(Y)" 
 -- before:pushSize: actualArg.super.ATd.OG.isUnitValueObj:true
 -- :actualArg.isCompositeValueObj:false isAssign: false
 -- actualArg:UnitOne?:Y
 -- end:loadArgs:NonVirt:"putFloat(Y)" 
 -- invoke:after:loadArgsOf:"putFloat(Y)" :Address:E:"putFloat(Y)"off:0 siz ...
 -- $ObjectInvocation_Function:invoke: rec:"putFloat(Y)" "putFloat(Y)"
 -- >top:1 descNo:43 
 -- E.ATd: "putFloat" unique: false
 -- adr::Address:E:"putFloat(Y)"off:0 size:0 isFloat:False superAdj:0 isUni ...
 -- $pattern:invoke: "putFloat:  |    %basic 142 |    in X: var Float |    out V: ..."
 -- Pattern:invoke:descNo:43  top:1  rec:"putFloat(Y)" 
 -- ptn:invoke:primitive:putFloat
 %printf_prim 142
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:true"putFloat(Y)" 
 vpop
 -- OI:invoke:putFloat(Y):unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"putFloat(Y)" 
 -- genclass:Qgen:stmt:"newline" 
 -- $ObjectCall:gen: "newline"
 -- $Invocation:gen: descNo: 81 top: 1 "newline"
 -- needorigin:"newline" 
 -- needOrigin:E:"newline"  E.ATd:"newline:  |    %globals |    put(10)" 
 -- LoadOrign:no:loadOrigin: "%globals | put(10)" 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "newline" E: "newline" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "newline"
 -- $pattern:loadArgs:E:"newline":descNo:81:top:1 "newline:  |    %globals |    ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"newline" 
 -- $ObjectInvocation_Unary:invoke: rec:"newline" "newline"
 -- >top:1 descNo:81 
 -- $pattern:invoke: "newline:  |    %globals |    put(10)"
 -- Pattern:invoke:descNo:81  top:1  rec:"newline" 
 -- ptn:invoke::isValObj:false:rtnValObj:false:"newline:  |    %globals |    pu ..." 
 -- rec=E:true:rec:"newline" 
 -- kuk:obj:rec.ATd:"newline:  |    %globals |    put(10)" 
 invoke newline 81 0 0
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:true"newline" 
 rpop
 -- OI:invoke:newline:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"newline" 
 -- genclass:Qgen:stmt:"X := (rocketMass + fuelMass) / rocketMass" 
 -- $ObjectCall:gen: "X := (rocketMass + fuelMass) / rocketMass"
 -- $Invocation:gen: descNo: 4 top: 1 "X := (rocketMass + fuelMass) / rocke ..."
 -- needorigin:"X := (rocketMass + fuelMass) / rocketMass" 
 -- needOrigin:E:":= (rocketMass + fuelMass) / rocketMass"  E.ATd:":= :  |    ..." 
 -- computeAdr: "X := (rocketMass + fuelMass) / rocketMass" 
 -- computeAdr:1 :rec:"none"  E:"X" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "X"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "X"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "X"
 -- $var:getAdr:,newOff:16,isValue:"True",A.isValue:"False" "X: var Float"
 --  A::Address:E:"X"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...X ...
 -- value_prim:false
 -- Float
 -- before:floatTest: 
 -- getAdr:isfloat:X: var Float A.isValue:true
 -- computeAdr:isFirst::Address:E:"X"off:16 size:0 isFloat:True superAdj:0  ...
 -- computeAdr:2 :rec:"X"  E:":= (rocketMass + fuelMass) / rocketMass" :Add ...
 -- computeAdr:isAssign:rec: "X"  E:":= (rocketMass + fuelMass) / rocketMas ..." 
 -- :Address:E:"X"off:16 size:0 isFloat:True superAdj:0 isUnique:False isVa ...
 -- computeAdr:isLast:E: ":= (rocketMass + fuelMass) / rocketMass" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"X"off:16 size:0 isFloat:True ...
 -- rec: "X" E: ":= (rocketMass + fuelMass) / rocketMass" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:16 ":= (rocketMass + fuelMa ..."
 -- $pattern:loadArgs:E:":= (rocketMass + fuelMass) / rocketMass":descNo:4: ...
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= (rocketMass + fuelMass) / rocketMass" ActArg: "(ro ..." i ...false
 -- $ObjectCall:gen: "(rocketMass + fuelMass) / rocketMass"
 -- $Invocation:gen: descNo: 0 top: 0 "(rocketMass + fuelMass) / rocketMass ..."
 -- needorigin:"(rocketMass + fuelMass) / rocketMass" 
 -- needOrigin:E:"/ rocketMass"  E.ATd:"/ :  |    %basic 121 |    in V: var flo ..." 
 -- computeAdr: "(rocketMass + fuelMass) / rocketMass" 
 -- computeAdr:1 :rec:"none"  E:"(rocketMass + fuelMass)" :Address:E:"none" ...
 -- $BracketedExp:pushThis: "(rocketMass + fuelMass)"
 -- $BracketedExp:loadOrigin: "(rocketMass + fuelMass)"
 -- computeAdr: "rocketMass + fuelMass" 
 -- computeAdr:1 :rec:"none"  E:"rocketMass" :Address:E:"none"off:0 size:0  ...
 -- $ObjectInvocation_Unary:pushThis: "rocketMass"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "rocketMass"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "rocketMass"
 -- $var:getAdr:,newOff:6,isValue:"True",A.isValue:"False" "rocketMass: var ..."
 --  A::Address:E:"rocketMass"off:0 size:0 isFloat:False superAdj:0 isUniqu ...  ...r ...
 -- value_prim:false
 -- Mass.KiloGram
 -- before:floatTest: %unit "kg"
 -- computeAdr:isFirst::Address:E:"rocketMass"off:6 size:0 isFloat:False su ...
 -- computeAdr:2 :rec:"rocketMass"  E:"+ fuelMass" :Address:E:"rocketMass"o ...
 -- E:notAssign:+ fuelMass
 -- $ObjectInvocation_Binary:getAdr::superAdj:0:on:0 "+ fuelMass"
 -- $pattern:getAdr: "+ :  |    %basic 109 |    in V: var float |    out R: var f ..."
 -- :Address:E:"rocketMass"off:6 size:0 isFloat:False superAdj:0 isUnique:F ...
 -- ptn.ssUnitValueObj:false isFloat:true
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "rocketMass"
 -- $var:loadArgs: "rocketMass: var Mass.KiloGram"
 -- $ObjectInvocation_Unary:invoke: rec:"rocketMass" "rocketMass"
 -- E.ATd: "+ " unique: false
 -- adr::Address:E:"rocketMass"off:6 size:0 isFloat:False superAdj:0 isUniq ...
 -- $var:invoke: newOff:6 "rocketMass: var Mass.KiloGram"
 -- >LoadValue:isAdr:false,Size:2 ,rec:"rocketMass" ,E:"+ fuelMass" 
 -- isCompositeValueObj: false
 -- loadAdr::Address:E:"rocketMass"off:6 size:0 isFloat:False superAdj:0 is ...
 -- loadAdr:isValue:originIsValue:false
 -- isFloat: false
 fpushg 6 
 -- OI:invoke:rocketMass:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "+ fuelMass" 
 -- BE:loadOrigin:E: + fuelMass
 -- $ObjectInvocation_Binary:getAdr::superAdj:0:on:0 "+ fuelMass"
 -- $pattern:getAdr: "+ :  |    %basic 109 |    in V: var float |    out R: var f ..."
 -- :Address:E:"+ fuelMass"off:0 size:0 isFloat:False superAdj:0 isUnique:F ...
 -- computeAdr:isFirst::Address:E:"+ fuelMass"off:0 size:0 isFloat:False su ...
 -- computeAdr:2 :rec:"+ fuelMass"  E:"/ rocketMass" :Address:E:"+ fuelMass ..."
 -- E:notAssign:/ rocketMass
 -- $ObjectInvocation_Binary:getAdr::superAdj:0:on:0 "/ rocketMass"
 -- $pattern:getAdr: "/ :  |    %basic 121 |    in V: var float |    out R: var f ..."
 -- :Address:E:"+ fuelMass"off:0 size:0 isFloat:False superAdj:0 isUnique:F ...
 -- ptn.ssUnitValueObj:false isFloat:true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:0 "+ fuelMass"
 -- $pattern:loadArgs:E:"+ fuelMass":descNo:0:top:0 "+ :  |    %basic 109 |     ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"+ fuelMass" ActArg: "fuelMass" isValue: true
 -- loadArgs:not:*: formalArgOf:"+ fuelMass"  isCompositeValueObj:false
 -- $ObjectGenerator:gen:"fuelMass#S#0"IS.isempty! staticOff: 0 descNo: 0 t ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: false
 -- $Invocation:gen: "fuelMass"
 -- needorigin:"fuelMass" 
 -- needOrigin:E:"fuelMass"  E.ATd:"fuelMass: var Mass.KiloGram" 
 -- needOrigin:datItem:leave
 -- computeAdr: "fuelMass" 
 -- computeAdr:1 :rec:"none"  E:"fuelMass" :Address:E:"none"off:0 size:0 is ...
 -- $ObjectInvocation_Unary:pushThis: "fuelMass"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "fuelMass"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "fuelMass"
 -- $var:getAdr:,newOff:8,isValue:"True",A.isValue:"False" "fuelMass: var M ..."
 --  A::Address:E:"fuelMass"off:0 size:0 isFloat:False superAdj:0 isUnique: ...  ...f ...
 -- value_prim:false
 -- Mass.KiloGram
 -- before:floatTest: %unit "kg"
 -- computeAdr:isFirst::Address:E:"fuelMass"off:8 size:0 isFloat:False supe ...
 -- computeAdr:isLast:E: "fuelMass" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"fuelMass"off:8 size:0 isFloa ...
 -- rec: "fuelMass" E: "fuelMass" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "fuelMass"
 -- $var:loadArgs: "fuelMass: var Mass.KiloGram"
 -- invoke:after:loadArgsOf:"fuelMass" :Address:E:"fuelMass"off:8 size:0 is ...
 -- $ObjectInvocation_Unary:invoke: rec:"fuelMass" "fuelMass"
 -- E.ATd: "fuelMass" unique: false
 -- adr::Address:E:"fuelMass"off:8 size:0 isFloat:False superAdj:0 isUnique ...
 -- $var:invoke: newOff:8 "fuelMass: var Mass.KiloGram"
 -- >LoadValue:isAdr:false,Size:2 ,rec:"fuelMass" ,E:"fuelMass" 
 -- isCompositeValueObj: false
 -- loadAdr::Address:E:"fuelMass"off:8 size:0 isFloat:False superAdj:0 isUn ...
 -- loadAdr:isValue:originIsValue:false
 -- isFloat: false
 fpushg 8 
 -- OI:invoke:fuelMass:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"fuelMass" 
 -- loadArgs:after:Qgen:"+ fuelMass" 
 -- before:pushSize: actualArg.super.ATd.OG.isUnitValueObj:true
 -- :actualArg.isCompositeValueObj:false isAssign: false
 -- actualArg:UnitOne?:fuelMass
 -- end:loadArgs:NonVirt:"+ fuelMass" 
 -- $ObjectInvocation_Binary:invoke: rec:"rocketMass" "+ fuelMass"
 -- >top:0 descNo:0 
 -- E.ATd: "/ " unique: false
 -- adr::Address:E:"+ fuelMass"off:0 size:0 isFloat:False superAdj:0 isUniq ...
 -- $pattern:invoke: "+ :  |    %basic 109 |    in V: var float |    out R: var f ..."
 -- bodyC:
 fplus
 -- OI:invoke:+ fuelMass:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "/ rocketMass" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"+ fuelMass"off:0 size:0 isFl ...
 -- rec: "+ fuelMass" E: "/ rocketMass" isValueAssign: false
 -- $ObjectInvocation_Binary:loadArgs:staticOff:0 "/ rocketMass"
 -- $pattern:loadArgs:E:"/ rocketMass":descNo:0:top:0 "/ :  |    %basic 121 |   ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"/ rocketMass" ActArg: "rocketMass" isValue: true
 -- loadArgs:not:*: formalArgOf:"/ rocketMass"  isCompositeValueObj:false
 -- $ObjectGenerator:gen:"rocketMass#S#0"IS.isempty! staticOff: 0 descNo: 0 ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: false
 -- $Invocation:gen: "rocketMass"
 -- needorigin:"rocketMass" 
 -- needOrigin:E:"rocketMass"  E.ATd:"rocketMass: var Mass.KiloGram" 
 -- needOrigin:datItem:leave
 -- computeAdr: "rocketMass" 
 -- computeAdr:1 :rec:"none"  E:"rocketMass" :Address:E:"none"off:0 size:0  ...
 -- $ObjectInvocation_Unary:pushThis: "rocketMass"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "rocketMass"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "rocketMass"
 -- $var:getAdr:,newOff:6,isValue:"True",A.isValue:"False" "rocketMass: var ..."
 --  A::Address:E:"rocketMass"off:0 size:0 isFloat:False superAdj:0 isUniqu ...  ...r ...
 -- value_prim:false
 -- Mass.KiloGram
 -- before:floatTest: %unit "kg"
 -- computeAdr:isFirst::Address:E:"rocketMass"off:6 size:0 isFloat:False su ...
 -- computeAdr:isLast:E: "rocketMass" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"rocketMass"off:6 size:0 isFl ...
 -- rec: "rocketMass" E: "rocketMass" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "rocketMass"
 -- $var:loadArgs: "rocketMass: var Mass.KiloGram"
 -- invoke:after:loadArgsOf:"rocketMass" :Address:E:"rocketMass"off:6 size: ...
 -- $ObjectInvocation_Unary:invoke: rec:"rocketMass" "rocketMass"
 -- E.ATd: "rocketMass" unique: false
 -- adr::Address:E:"rocketMass"off:6 size:0 isFloat:False superAdj:0 isUniq ...
 -- $var:invoke: newOff:6 "rocketMass: var Mass.KiloGram"
 -- >LoadValue:isAdr:false,Size:2 ,rec:"rocketMass" ,E:"rocketMass" 
 -- isCompositeValueObj: false
 -- loadAdr::Address:E:"rocketMass"off:6 size:0 isFloat:False superAdj:0 is ...
 -- loadAdr:isValue:originIsValue:false
 -- isFloat: false
 fpushg 6 
 -- OI:invoke:rocketMass:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"rocketMass" 
 -- loadArgs:after:Qgen:"/ rocketMass" 
 -- before:pushSize: actualArg.super.ATd.OG.isUnitValueObj:true
 -- :actualArg.isCompositeValueObj:false isAssign: false
 -- actualArg:UnitOne?:rocketMass
 -- end:loadArgs:NonVirt:"/ rocketMass" 
 -- invoke:after:loadArgsOf:"/ rocketMass" :Address:E:"+ fuelMass"off:0 siz ...
 -- $ObjectInvocation_Binary:invoke: rec:"+ fuelMass" "/ rocketMass"
 -- >top:0 descNo:0 
 -- E.ATd: "/ " unique: false
 -- adr::Address:E:"+ fuelMass"off:0 size:0 isFloat:False superAdj:0 isUniq ...
 -- $pattern:invoke: "/ :  |    %basic 121 |    in V: var float |    out R: var f ..."
 -- bodyC:
 fdiv
 -- OI:invoke:/ rocketMass:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"/ rocketMass" 
 -- loadArgs:after:Qgen:":= (rocketMass + fuelMass) / rocketMass" 
 -- vAssign:fArg:"in V: var Value" 
 -- BINGO
 -- aaaa: in V: var Value
 -- end:loadArgs:NonVirt:":= (rocketMass + fuelMass) / rocketMass" 
 -- invoke:after:loadArgsOf:":= (rocketMass + fuelMass) / rocketMass" :Addr ...
 -- $ObjectInvocation_Binary:invoke: rec:"X" ":= (rocketMass + fuelMass) /  ..."
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Address:E:"X"off:16 size:0 isFloat:True superAdj:0 isUnique:False  ...
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "X" from: ":= (rocketMass + fuelMass) / rocketMas ..." 
 -- assign:dstDI :"X: var Float" isUnitValueObj: false
 -- assign:arg: "(rocketMass + fuelMass) / rocketMass" lab:"ObjectCall" Uni ...false  ...false
 --  float: true DataItem:false arg.super:(rocketMass + fuelMass) / rocketM ...
 --  arg.super.ATd:"Invocation" "/ :  |    %basic 121 |    in V: var float |    o ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:true
 --  arg.super.ATd.label: "pattern" 
 -- assign:simple value: 
 -- :Address:E:"X"off:16 size:0 isFloat:True superAdj:0 isUnique:False isVa ...
 -- store::Address:E:"X"off:16 size:0 isFloat:True superAdj:0 isUnique:Fals ...
 -- isValue:true isAdr:false descNo: 0 
 -- isFloat: true
 fstoreg 16 address:storeg
 -- OI:invoke::= (rocketMass + fuelMass) / rocketMass:unit: -none- convFact ...0.000000
 -- invoke:after:E.invoke:":= (rocketMass + fuelMass) / rocketMass" 
 -- genclass:Qgen:stmt:"putFloat(X)" 
 -- $ObjectCall:gen: "putFloat(X)"
 -- $Invocation:gen: descNo: 43 top: 1 "putFloat(X)"
 -- needorigin:"putFloat(X)" 
 -- needOrigin:E:"putFloat(X)"  E.ATd:"putFloat:  |    %basic 142 |    in X: va ..." 
 -- computeAdr: "putFloat(X)" 
 -- computeAdr:1 :rec:"none"  E:"putFloat(X)" :Address:E:"none"off:0 size:0 ...
 -- $ObjectInvocation_Function:pushThis: "putFloat(X)"
 -- $ObjectInvocation_Function:loadOrigin::on:2 "putFloat(X)"
 -- $ObjectInvocation_Function:getAdr::superAdj:0:on:2 "putFloat(X)"
 -- $pattern:getAdr: "putFloat:  |    %basic 142 |    in X: var Float |    out V: ..."
 -- :Address:E:"putFloat(X)"off:0 size:0 isFloat:False superAdj:0 isUnique: ...
 -- computeAdr:isFirst::Address:E:"putFloat(X)"off:0 size:0 isFloat:False s ...
 -- computeAdr:isLast:E: "putFloat(X)" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"putFloat(X)"off:0 size:0 isF ...
 -- rec: "putFloat(X)" E: "putFloat(X)" isValueAssign: false
 -- $ObjectInvocation_Function:loadArgs:staticOff:0 "putFloat(X)"
 -- $pattern:loadArgs:E:"putFloat(X)":descNo:43:top:1 "putFloat:  |    %basic ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"putFloat(X)" ActArg: "X" isValue: false
 -- loadArgs:not:*: formalArgOf:"putFloat(X)"  isCompositeValueObj:false
 -- $ObjectCall:gen: "X"
 -- $Invocation:gen: "X"
 -- needorigin:"X" 
 -- needOrigin:E:"X"  E.ATd:"X: var Float" 
 -- needOrigin:datItem:leave
 -- computeAdr: "X" 
 -- computeAdr:1 :rec:"none"  E:"X" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "X"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "X"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "X"
 -- $var:getAdr:,newOff:16,isValue:"True",A.isValue:"False" "X: var Float"
 --  A::Address:E:"X"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...X ...
 -- value_prim:false
 -- Float
 -- before:floatTest: 
 -- getAdr:isfloat:X: var Float A.isValue:true
 -- computeAdr:isFirst::Address:E:"X"off:16 size:0 isFloat:True superAdj:0  ...
 -- computeAdr:isLast:E: "X" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"X"off:16 size:0 isFloat:True ...
 -- rec: "X" E: "X" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "X"
 -- $var:loadArgs: "X: var Float"
 -- invoke:after:loadArgsOf:"X" :Address:E:"X"off:16 size:0 isFloat:True su ...
 -- $ObjectInvocation_Unary:invoke: rec:"X" "X"
 -- E.ATd: "X" unique: false
 -- adr::Address:E:"X"off:16 size:0 isFloat:True superAdj:0 isUnique:False  ...
 -- $var:invoke: newOff:16 "X: var Float"
 -- load::Address:E:"X"off:16 size:0 isFloat:True superAdj:0 isUnique:False ...
 -- isFloat: true
 fpushg 16 
 -- OI:invoke:X:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"X" 
 -- loadArgs:after:Qgen:"putFloat(X)" 
 -- formalArg:isPtn:"in X: var Float" :isBasicVal:true:valueObj:true
 -- :actArg:"X" :isBasicVal:true
 -- XObjectCall
 -- end:loadArgs:NonVirt:"putFloat(X)" 
 -- invoke:after:loadArgsOf:"putFloat(X)" :Address:E:"putFloat(X)"off:0 siz ...
 -- $ObjectInvocation_Function:invoke: rec:"putFloat(X)" "putFloat(X)"
 -- >top:1 descNo:43 
 -- E.ATd: "putFloat" unique: false
 -- adr::Address:E:"putFloat(X)"off:0 size:0 isFloat:False superAdj:0 isUni ...
 -- $pattern:invoke: "putFloat:  |    %basic 142 |    in X: var Float |    out V: ..."
 -- Pattern:invoke:descNo:43  top:1  rec:"putFloat(X)" 
 -- ptn:invoke:primitive:putFloat
 %printf_prim 142
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:true"putFloat(X)" 
 vpop
 -- OI:invoke:putFloat(X):unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"putFloat(X)" 
 -- genclass:Qgen:stmt:"newline" 
 -- $ObjectCall:gen: "newline"
 -- $Invocation:gen: descNo: 81 top: 1 "newline"
 -- needorigin:"newline" 
 -- needOrigin:E:"newline"  E.ATd:"newline:  |    %globals |    put(10)" 
 -- LoadOrign:no:loadOrigin: "%globals | put(10)" 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "newline" E: "newline" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "newline"
 -- $pattern:loadArgs:E:"newline":descNo:81:top:1 "newline:  |    %globals |    ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"newline" 
 -- $ObjectInvocation_Unary:invoke: rec:"newline" "newline"
 -- >top:1 descNo:81 
 -- $pattern:invoke: "newline:  |    %globals |    put(10)"
 -- Pattern:invoke:descNo:81  top:1  rec:"newline" 
 -- ptn:invoke::isValObj:false:rtnValObj:false:"newline:  |    %globals |    pu ..." 
 -- rec=E:true:rec:"newline" 
 -- kuk:obj:rec.ATd:"newline:  |    %globals |    put(10)" 
 invoke newline 81 0 0
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:true"newline" 
 rpop
 -- OI:invoke:newline:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"newline" 
 -- genclass:Qgen:stmt:"X := log(X)" 
 -- $ObjectCall:gen: "X := log(X)"
 -- $Invocation:gen: descNo: 4 top: 1 "X := log(X)"
 -- needorigin:"X := log(X)" 
 -- needOrigin:E:":= log(X)"  E.ATd:":= :  |    %basic 8 |    in V: var Value" 
 -- computeAdr: "X := log(X)" 
 -- computeAdr:1 :rec:"none"  E:"X" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "X"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "X"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "X"
 -- $var:getAdr:,newOff:16,isValue:"True",A.isValue:"False" "X: var Float"
 --  A::Address:E:"X"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...X ...
 -- value_prim:false
 -- Float
 -- before:floatTest: 
 -- getAdr:isfloat:X: var Float A.isValue:true
 -- computeAdr:isFirst::Address:E:"X"off:16 size:0 isFloat:True superAdj:0  ...
 -- computeAdr:2 :rec:"X"  E:":= log(X)" :Address:E:"X"off:16 size:0 isFloa ...
 -- computeAdr:isAssign:rec: "X"  E:":= log(X)" 
 -- :Address:E:"X"off:16 size:0 isFloat:True superAdj:0 isUnique:False isVa ...
 -- computeAdr:isLast:E: ":= log(X)" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"X"off:16 size:0 isFloat:True ...
 -- rec: "X" E: ":= log(X)" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:16 ":= log(X)"
 -- $pattern:loadArgs:E:":= log(X)":descNo:4:top:1 ":= :  |    %basic 8 |    in ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= log(X)" ActArg: "log(X)" isValue: false
 -- $ObjectCall:gen: "log(X)"
 -- $Invocation:gen: descNo: 0 top: 0 "log(X)"
 -- needorigin:"log(X)" 
 -- needOrigin:E:"log(X)"  E.ATd:"log:  |    %basic 141 |    in V: var float |    ..." 
 -- computeAdr: "log(X)" 
 -- computeAdr:1 :rec:"none"  E:"log(X)" :Address:E:"none"off:0 size:0 isFl ...
 -- $ObjectInvocation_Function:pushThis: "log(X)"
 -- $ObjectInvocation_Function:loadOrigin::on:2 "log(X)"
 -- $ObjectInvocation_Function:getAdr::superAdj:0:on:2 "log(X)"
 -- $pattern:getAdr: "log:  |    %basic 141 |    in V: var float |    out R: var  ..."
 -- :Address:E:"log(X)"off:0 size:0 isFloat:False superAdj:0 isUnique:False ...
 -- computeAdr:isFirst::Address:E:"log(X)"off:0 size:0 isFloat:False superA ...
 -- computeAdr:isLast:E: "log(X)" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"log(X)"off:0 size:0 isFloat: ...
 -- rec: "log(X)" E: "log(X)" isValueAssign: false
 -- $ObjectInvocation_Function:loadArgs:staticOff:0 "log(X)"
 -- $pattern:loadArgs:E:"log(X)":descNo:0:top:0 "log:  |    %basic 141 |    in  ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"log(X)" ActArg: "X" isValue: false
 -- loadArgs:not:*: formalArgOf:"log(X)"  isCompositeValueObj:false
 -- $ObjectCall:gen: "X"
 -- $Invocation:gen: "X"
 -- needorigin:"X" 
 -- needOrigin:E:"X"  E.ATd:"X: var Float" 
 -- needOrigin:datItem:leave
 -- computeAdr: "X" 
 -- computeAdr:1 :rec:"none"  E:"X" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "X"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "X"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "X"
 -- $var:getAdr:,newOff:16,isValue:"True",A.isValue:"False" "X: var Float"
 --  A::Address:E:"X"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...X ...
 -- value_prim:false
 -- Float
 -- before:floatTest: 
 -- getAdr:isfloat:X: var Float A.isValue:true
 -- computeAdr:isFirst::Address:E:"X"off:16 size:0 isFloat:True superAdj:0  ...
 -- computeAdr:isLast:E: "X" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"X"off:16 size:0 isFloat:True ...
 -- rec: "X" E: "X" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "X"
 -- $var:loadArgs: "X: var Float"
 -- invoke:after:loadArgsOf:"X" :Address:E:"X"off:16 size:0 isFloat:True su ...
 -- $ObjectInvocation_Unary:invoke: rec:"X" "X"
 -- E.ATd: "X" unique: false
 -- adr::Address:E:"X"off:16 size:0 isFloat:True superAdj:0 isUnique:False  ...
 -- $var:invoke: newOff:16 "X: var Float"
 -- load::Address:E:"X"off:16 size:0 isFloat:True superAdj:0 isUnique:False ...
 -- isFloat: true
 fpushg 16 
 -- OI:invoke:X:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"X" 
 -- loadArgs:after:Qgen:"log(X)" 
 -- formalArg:isPtn:"in V: var float" :isBasicVal:true:valueObj:true
 -- :actArg:"X" :isBasicVal:true
 -- XObjectCall
 -- end:loadArgs:NonVirt:"log(X)" 
 -- invoke:after:loadArgsOf:"log(X)" :Address:E:"log(X)"off:0 size:0 isFloa ...
 -- $ObjectInvocation_Function:invoke: rec:"log(X)" "log(X)"
 -- >top:0 descNo:0 
 -- E.ATd: "log" unique: false
 -- adr::Address:E:"log(X)"off:0 size:0 isFloat:False superAdj:0 isUnique:F ...
 -- $pattern:invoke: "log:  |    %basic 141 |    in V: var float |    out R: var  ..."
 -- Pattern:invoke:descNo:0  top:0  rec:"log(X)" 
 -- ptn:invoke:primitive:log
 %log_prim 141
 -- useRtnVal:true:isVal:false:rtnValObj:false:rec=E:true"log(X)" 
 -- OI:invoke:log(X):unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"log(X)" 
 -- loadArgs:after:Qgen:":= log(X)" 
 -- vAssign:fArg:"in V: var Value" 
 -- BINGO
 -- aaaa: in V: var Value
 -- end:loadArgs:NonVirt:":= log(X)" 
 -- invoke:after:loadArgsOf:":= log(X)" :Address:E:"X"off:16 size:0 isFloat ...
 -- $ObjectInvocation_Binary:invoke: rec:"X" ":= log(X)"
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Address:E:"X"off:16 size:0 isFloat:True superAdj:0 isUnique:False  ...
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "X" from: ":= log(X)" 
 -- assign:dstDI :"X: var Float" isUnitValueObj: false
 -- assign:arg: "log(X)" lab:"ObjectCall" UnitValObj :false ptn: false
 --  float: false DataItem:false arg.super:log(X)
 --  arg.super.ATd:"Invocation" "log:  |    %basic 141 |    in V: var float |     ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "pattern" 
 -- assign:simple value: 
 -- :Address:E:"X"off:16 size:0 isFloat:True superAdj:0 isUnique:False isVa ...
 -- store::Address:E:"X"off:16 size:0 isFloat:True superAdj:0 isUnique:Fals ...
 -- isValue:true isAdr:false descNo: 0 
 -- isFloat: true
 fstoreg 16 address:storeg
 -- OI:invoke::= log(X):unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= log(X)" 
 -- genclass:Qgen:stmt:""log X: ".print" 
 -- $ObjectCall:gen: ""log X: ".print"
 -- $Invocation:gen: descNo: 33 top: 1 ""log X: ".print"
 -- needorigin:""log X: ".print" 
 -- needOrigin:E:"print"  E.ATd:"print:  |    @for 1 :to length  |    :do  |      ..." 
 -- computeAdr: ""log X: ".print" 
 -- computeAdr:1 :rec:"none"  E:""log X: "" :Address:E:"none"off:0 size:0 i ...
 -- $String::pushThis: ""log X: ""
 -- $String::loadOrigin: ""log X: ""
 -- StringObj:loadOrigin:"log X: "
 -- $String::getAdr: ""log X: ""
 -- computeAdr:isFirst::Address:E:""log X: ""off:0 size:0 isFloat:False sup ...
 -- computeAdr:2 :rec:""log X: ""  E:"print" :Address:E:""log X: ""off:0 si ...
 -- E:notAssign:print
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "print"
 -- $pattern:getAdr: "print:  |    @for 1 :to length  |    :do  |       put(@get  ..."
 -- :Address:E:""log X: ""off:0 size:0 isFloat:False superAdj:0 isUnique:Fa ...
 -- ptn.ssUnitValueObj:false isFloat:false
 -- $String::loadArgs: ""log X: ""
 -- $String::invoke: ""log X: ""
 -- Pattern:markForCodeGen:+ :  |    in S: ref String |    out V: ref String |    ...
 pushText log X: 
 -- computeAdr:isLast:E: "print" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:""log X: ""off:0 size:0 isFlo ...
 -- rec: ""log X: "" E: "print" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "print"
 -- $pattern:loadArgs:E:"print":descNo:33:top:1 "print:  |    @for 1 :to leng ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"print" :Address:E:""log X: ""off:0 size:0 isFl ...
 -- $ObjectInvocation_Unary:invoke: rec:""log X: "" "print"
 -- >top:1 descNo:33 
 -- E.ATd: "print" unique: false
 -- adr::Address:E:""log X: ""off:0 size:0 isFloat:False superAdj:0 isUniqu ...
 -- $pattern:invoke: "print:  |    @for 1 :to length  |    :do  |       put(@get  ..."
 -- Pattern:invoke:descNo:33  top:1  rec:""log X: "" 
 -- ComputeVariantX
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- <>var
 -- rec:module or pattern:"print"  descno: 33  top: 1 "@for 1 :to length  | : ..." 
 -- ptn:invoke::isValObj:false:rtnValObj:false:"print:  |    @for 1 :to lengt ..." 
 -- rec=E:false:rec:""log X: "" 
 -- kuk:obj:rec.ATd:"String:  |    %OSDvisibility disguised |    %basic 5 |    %i ..." 
 invoke print 33 0 0
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:false""log X: "" 
 rpop
 -- OI:invoke:print:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"print" 
 -- genclass:Qgen:stmt:"putFloat(X)" 
 -- $ObjectCall:gen: "putFloat(X)"
 -- $Invocation:gen: descNo: 43 top: 1 "putFloat(X)"
 -- needorigin:"putFloat(X)" 
 -- needOrigin:E:"putFloat(X)"  E.ATd:"putFloat:  |    %basic 142 |    in X: va ..." 
 -- computeAdr: "putFloat(X)" 
 -- computeAdr:1 :rec:"none"  E:"putFloat(X)" :Address:E:"none"off:0 size:0 ...
 -- $ObjectInvocation_Function:pushThis: "putFloat(X)"
 -- $ObjectInvocation_Function:loadOrigin::on:2 "putFloat(X)"
 -- $ObjectInvocation_Function:getAdr::superAdj:0:on:2 "putFloat(X)"
 -- $pattern:getAdr: "putFloat:  |    %basic 142 |    in X: var Float |    out V: ..."
 -- :Address:E:"putFloat(X)"off:0 size:0 isFloat:False superAdj:0 isUnique: ...
 -- computeAdr:isFirst::Address:E:"putFloat(X)"off:0 size:0 isFloat:False s ...
 -- computeAdr:isLast:E: "putFloat(X)" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"putFloat(X)"off:0 size:0 isF ...
 -- rec: "putFloat(X)" E: "putFloat(X)" isValueAssign: false
 -- $ObjectInvocation_Function:loadArgs:staticOff:0 "putFloat(X)"
 -- $pattern:loadArgs:E:"putFloat(X)":descNo:43:top:1 "putFloat:  |    %basic ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"putFloat(X)" ActArg: "X" isValue: false
 -- loadArgs:not:*: formalArgOf:"putFloat(X)"  isCompositeValueObj:false
 -- $ObjectCall:gen: "X"
 -- $Invocation:gen: "X"
 -- needorigin:"X" 
 -- needOrigin:E:"X"  E.ATd:"X: var Float" 
 -- needOrigin:datItem:leave
 -- computeAdr: "X" 
 -- computeAdr:1 :rec:"none"  E:"X" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "X"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "X"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "X"
 -- $var:getAdr:,newOff:16,isValue:"True",A.isValue:"False" "X: var Float"
 --  A::Address:E:"X"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...X ...
 -- value_prim:false
 -- Float
 -- before:floatTest: 
 -- getAdr:isfloat:X: var Float A.isValue:true
 -- computeAdr:isFirst::Address:E:"X"off:16 size:0 isFloat:True superAdj:0  ...
 -- computeAdr:isLast:E: "X" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"X"off:16 size:0 isFloat:True ...
 -- rec: "X" E: "X" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "X"
 -- $var:loadArgs: "X: var Float"
 -- invoke:after:loadArgsOf:"X" :Address:E:"X"off:16 size:0 isFloat:True su ...
 -- $ObjectInvocation_Unary:invoke: rec:"X" "X"
 -- E.ATd: "X" unique: false
 -- adr::Address:E:"X"off:16 size:0 isFloat:True superAdj:0 isUnique:False  ...
 -- $var:invoke: newOff:16 "X: var Float"
 -- load::Address:E:"X"off:16 size:0 isFloat:True superAdj:0 isUnique:False ...
 -- isFloat: true
 fpushg 16 
 -- OI:invoke:X:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"X" 
 -- loadArgs:after:Qgen:"putFloat(X)" 
 -- formalArg:isPtn:"in X: var Float" :isBasicVal:true:valueObj:true
 -- :actArg:"X" :isBasicVal:true
 -- XObjectCall
 -- end:loadArgs:NonVirt:"putFloat(X)" 
 -- invoke:after:loadArgsOf:"putFloat(X)" :Address:E:"putFloat(X)"off:0 siz ...
 -- $ObjectInvocation_Function:invoke: rec:"putFloat(X)" "putFloat(X)"
 -- >top:1 descNo:43 
 -- E.ATd: "putFloat" unique: false
 -- adr::Address:E:"putFloat(X)"off:0 size:0 isFloat:False superAdj:0 isUni ...
 -- $pattern:invoke: "putFloat:  |    %basic 142 |    in X: var Float |    out V: ..."
 -- Pattern:invoke:descNo:43  top:1  rec:"putFloat(X)" 
 -- ptn:invoke:primitive:putFloat
 %printf_prim 142
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:true"putFloat(X)" 
 vpop
 -- OI:invoke:putFloat(X):unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"putFloat(X)" 
 -- genclass:Qgen:stmt:"newline" 
 -- $ObjectCall:gen: "newline"
 -- $Invocation:gen: descNo: 81 top: 1 "newline"
 -- needorigin:"newline" 
 -- needOrigin:E:"newline"  E.ATd:"newline:  |    %globals |    put(10)" 
 -- LoadOrign:no:loadOrigin: "%globals | put(10)" 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "newline" E: "newline" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "newline"
 -- $pattern:loadArgs:E:"newline":descNo:81:top:1 "newline:  |    %globals |    ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"newline" 
 -- $ObjectInvocation_Unary:invoke: rec:"newline" "newline"
 -- >top:1 descNo:81 
 -- $pattern:invoke: "newline:  |    %globals |    put(10)"
 -- Pattern:invoke:descNo:81  top:1  rec:"newline" 
 -- ptn:invoke::isValObj:false:rtnValObj:false:"newline:  |    %globals |    pu ..." 
 -- rec=E:true:rec:"newline" 
 -- kuk:obj:rec.ATd:"newline:  |    %globals |    put(10)" 
 invoke newline 81 0 0
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:true"newline" 
 rpop
 -- OI:invoke:newline:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"newline" 
 -- genclass:Qgen:stmt:""exhaustSpeed: ".print" 
 -- $ObjectCall:gen: ""exhaustSpeed: ".print"
 -- $Invocation:gen: descNo: 33 top: 1 ""exhaustSpeed: ".print"
 -- needorigin:""exhaustSpeed: ".print" 
 -- needOrigin:E:"print"  E.ATd:"print:  |    @for 1 :to length  |    :do  |      ..." 
 -- computeAdr: ""exhaustSpeed: ".print" 
 -- computeAdr:1 :rec:"none"  E:""exhaustSpeed: "" :Address:E:"none"off:0 s ...
 -- $String::pushThis: ""exhaustSpeed: ""
 -- $String::loadOrigin: ""exhaustSpeed: ""
 -- StringObj:loadOrigin:"exhaustSpeed: "
 -- $String::getAdr: ""exhaustSpeed: ""
 -- computeAdr:isFirst::Address:E:""exhaustSpeed: ""off:0 size:0 isFloat:Fa ...
 -- computeAdr:2 :rec:""exhaustSpeed: ""  E:"print" :Address:E:""exhaustSpe ...
 -- E:notAssign:print
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "print"
 -- $pattern:getAdr: "print:  |    @for 1 :to length  |    :do  |       put(@get  ..."
 -- :Address:E:""exhaustSpeed: ""off:0 size:0 isFloat:False superAdj:0 isUn ...
 -- ptn.ssUnitValueObj:false isFloat:false
 -- $String::loadArgs: ""exhaustSpeed: ""
 -- $String::invoke: ""exhaustSpeed: ""
 -- Pattern:markForCodeGen:+ :  |    in S: ref String |    out V: ref String |    ...
 pushText exhaustSpeed: 
 -- computeAdr:isLast:E: "print" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:""exhaustSpeed: ""off:0 size: ...
 -- rec: ""exhaustSpeed: "" E: "print" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "print"
 -- $pattern:loadArgs:E:"print":descNo:33:top:1 "print:  |    @for 1 :to leng ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"print" :Address:E:""exhaustSpeed: ""off:0 size ...
 -- $ObjectInvocation_Unary:invoke: rec:""exhaustSpeed: "" "print"
 -- >top:1 descNo:33 
 -- E.ATd: "print" unique: false
 -- adr::Address:E:""exhaustSpeed: ""off:0 size:0 isFloat:False superAdj:0  ...
 -- $pattern:invoke: "print:  |    @for 1 :to length  |    :do  |       put(@get  ..."
 -- Pattern:invoke:descNo:33  top:1  rec:""exhaustSpeed: "" 
 -- ComputeVariantX
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- <>var
 -- rec:module or pattern:"print"  descno: 33  top: 1 "@for 1 :to length  | : ..." 
 -- ptn:invoke::isValObj:false:rtnValObj:false:"print:  |    @for 1 :to lengt ..." 
 -- rec=E:false:rec:""exhaustSpeed: "" 
 -- kuk:obj:rec.ATd:"String:  |    %OSDvisibility disguised |    %basic 5 |    %i ..." 
 invoke print 33 0 0
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:false""exhaustSpeed:  ..."" 
 rpop
 -- OI:invoke:print:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"print" 
 -- genclass:Qgen:stmt:"putFloat(exhaustSpeed)" 
 -- $ObjectCall:gen: "putFloat(exhaustSpeed)"
 -- $Invocation:gen: descNo: 43 top: 1 "putFloat(exhaustSpeed)"
 -- needorigin:"putFloat(exhaustSpeed)" 
 -- needOrigin:E:"putFloat(exhaustSpeed)"  E.ATd:"putFloat:  |    %basic 142 |  ..." 
 -- computeAdr: "putFloat(exhaustSpeed)" 
 -- computeAdr:1 :rec:"none"  E:"putFloat(exhaustSpeed)" :Address:E:"none"o ...
 -- $ObjectInvocation_Function:pushThis: "putFloat(exhaustSpeed)"
 -- $ObjectInvocation_Function:loadOrigin::on:2 "putFloat(exhaustSpeed)"
 -- $ObjectInvocation_Function:getAdr::superAdj:0:on:2 "putFloat(exhaustSpe ..."
 -- $pattern:getAdr: "putFloat:  |    %basic 142 |    in X: var Float |    out V: ..."
 -- :Address:E:"putFloat(exhaustSpeed)"off:0 size:0 isFloat:False superAdj: ...
 -- computeAdr:isFirst::Address:E:"putFloat(exhaustSpeed)"off:0 size:0 isFl ...
 -- computeAdr:isLast:E: "putFloat(exhaustSpeed)" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"putFloat(exhaustSpeed)"off:0 ...
 -- rec: "putFloat(exhaustSpeed)" E: "putFloat(exhaustSpeed)" isValueAssign ...false
 -- $ObjectInvocation_Function:loadArgs:staticOff:0 "putFloat(exhaustSpeed) ..."
 -- $pattern:loadArgs:E:"putFloat(exhaustSpeed)":descNo:43:top:1 "putFloat: ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"putFloat(exhaustSpeed)" ActArg: "exhaustSpeed" isValu ...true
 -- loadArgs:not:*: formalArgOf:"putFloat(exhaustSpeed)"  isCompositeValueO ...false
 -- $ObjectGenerator:gen:"exhaustSpeed#S#0"IS.isempty! staticOff: 0 descNo: ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: false
 -- $Invocation:gen: "exhaustSpeed"
 -- needorigin:"exhaustSpeed" 
 -- needOrigin:E:"exhaustSpeed"  E.ATd:"exhaustSpeed: var Velocity.MperS" 
 -- needOrigin:datItem:leave
 -- computeAdr: "exhaustSpeed" 
 -- computeAdr:1 :rec:"none"  E:"exhaustSpeed" :Address:E:"none"off:0 size: ...
 -- $ObjectInvocation_Unary:pushThis: "exhaustSpeed"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "exhaustSpeed"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "exhaustSpeed"
 -- $var:getAdr:,newOff:4,isValue:"True",A.isValue:"False" "exhaustSpeed: v ..."
 --  A::Address:E:"exhaustSpeed"off:0 size:0 isFloat:False superAdj:0 isUni ...  ...e ...
 -- value_prim:false
 -- Velocity.MperS
 -- before:floatTest: %unit "m*s^-1", "m*s^-1"
 -- computeAdr:isFirst::Address:E:"exhaustSpeed"off:4 size:0 isFloat:False  ...
 -- computeAdr:isLast:E: "exhaustSpeed" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"exhaustSpeed"off:4 size:0 is ...
 -- rec: "exhaustSpeed" E: "exhaustSpeed" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "exhaustSpeed"
 -- $var:loadArgs: "exhaustSpeed: var Velocity.MperS"
 -- invoke:after:loadArgsOf:"exhaustSpeed" :Address:E:"exhaustSpeed"off:4 s ...
 -- $ObjectInvocation_Unary:invoke: rec:"exhaustSpeed" "exhaustSpeed"
 -- E.ATd: "exhaustSpeed" unique: false
 -- adr::Address:E:"exhaustSpeed"off:4 size:0 isFloat:False superAdj:0 isUn ...
 -- $var:invoke: newOff:4 "exhaustSpeed: var Velocity.MperS"
 -- >LoadValue:isAdr:false,Size:2 ,rec:"exhaustSpeed" ,E:"exhaustSpeed" 
 -- isCompositeValueObj: false
 -- loadAdr::Address:E:"exhaustSpeed"off:4 size:0 isFloat:False superAdj:0  ...
 -- loadAdr:isValue:originIsValue:false
 -- isFloat: false
 fpushg 4 
 -- OI:invoke:exhaustSpeed:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"exhaustSpeed" 
 -- loadArgs:after:Qgen:"putFloat(exhaustSpeed)" 
 -- before:pushSize: actualArg.super.ATd.OG.isUnitValueObj:true
 -- :actualArg.isCompositeValueObj:false isAssign: false
 -- actualArg:UnitOne?:exhaustSpeed
 -- end:loadArgs:NonVirt:"putFloat(exhaustSpeed)" 
 -- invoke:after:loadArgsOf:"putFloat(exhaustSpeed)" :Address:E:"putFloat(e ..."
 -- $ObjectInvocation_Function:invoke: rec:"putFloat(exhaustSpeed)" "putFlo ..."
 -- >top:1 descNo:43 
 -- E.ATd: "putFloat" unique: false
 -- adr::Address:E:"putFloat(exhaustSpeed)"off:0 size:0 isFloat:False super ...
 -- $pattern:invoke: "putFloat:  |    %basic 142 |    in X: var Float |    out V: ..."
 -- Pattern:invoke:descNo:43  top:1  rec:"putFloat(exhaustSpeed)" 
 -- ptn:invoke:primitive:putFloat
 %printf_prim 142
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:true"putFloat(exhaust ..." 
 vpop
 -- OI:invoke:putFloat(exhaustSpeed):unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"putFloat(exhaustSpeed)" 
 -- genclass:Qgen:stmt:"newline" 
 -- $ObjectCall:gen: "newline"
 -- $Invocation:gen: descNo: 81 top: 1 "newline"
 -- needorigin:"newline" 
 -- needOrigin:E:"newline"  E.ATd:"newline:  |    %globals |    put(10)" 
 -- LoadOrign:no:loadOrigin: "%globals | put(10)" 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "newline" E: "newline" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "newline"
 -- $pattern:loadArgs:E:"newline":descNo:81:top:1 "newline:  |    %globals |    ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"newline" 
 -- $ObjectInvocation_Unary:invoke: rec:"newline" "newline"
 -- >top:1 descNo:81 
 -- $pattern:invoke: "newline:  |    %globals |    put(10)"
 -- Pattern:invoke:descNo:81  top:1  rec:"newline" 
 -- ptn:invoke::isValObj:false:rtnValObj:false:"newline:  |    %globals |    pu ..." 
 -- rec=E:true:rec:"newline" 
 -- kuk:obj:rec.ATd:"newline:  |    %globals |    put(10)" 
 invoke newline 81 0 0
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:true"newline" 
 rpop
 -- OI:invoke:newline:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"newline" 
 -- genclass:Qgen:stmt:"newline" 
 -- $ObjectCall:gen: "newline"
 -- $Invocation:gen: descNo: 81 top: 1 "newline"
 -- needorigin:"newline" 
 -- needOrigin:E:"newline"  E.ATd:"newline:  |    %globals |    put(10)" 
 -- LoadOrign:no:loadOrigin: "%globals | put(10)" 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "newline" E: "newline" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "newline"
 -- $pattern:loadArgs:E:"newline":descNo:81:top:1 "newline:  |    %globals |    ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"newline" 
 -- $ObjectInvocation_Unary:invoke: rec:"newline" "newline"
 -- >top:1 descNo:81 
 -- $pattern:invoke: "newline:  |    %globals |    put(10)"
 -- Pattern:invoke:descNo:81  top:1  rec:"newline" 
 -- ptn:invoke::isValObj:false:rtnValObj:false:"newline:  |    %globals |    pu ..." 
 -- rec=E:true:rec:"newline" 
 -- kuk:obj:rec.ATd:"newline:  |    %globals |    put(10)" 
 invoke newline 81 0 0
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:true"newline" 
 rpop
 -- OI:invoke:newline:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"newline" 
 -- genclass:Qgen:stmt:"rocketSpeed := exhaustSpeed * log((rocketMass + fue ..." 
 -- $ObjectCall:gen: "rocketSpeed := exhaustSpeed * log((rocketMass + fuelM ..."
 -- $Invocation:gen: descNo: 4 top: 1 "rocketSpeed := exhaustSpeed * log((r ..."
 -- needorigin:"rocketSpeed := exhaustSpeed * log((rocketMass + fuelMass) / ..." 
 -- needOrigin:E:":= exhaustSpeed * log((rocketMass + fuelMass) / rocketMas ..."   ...": ..." 
 -- computeAdr: "rocketSpeed := exhaustSpeed * log((rocketMass + fuelMass)  ..." 
 -- computeAdr:1 :rec:"none"  E:"rocketSpeed" :Address:E:"none"off:0 size:0 ...
 -- $ObjectInvocation_Unary:pushThis: "rocketSpeed"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "rocketSpeed"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "rocketSpeed"
 -- $var:getAdr:,newOff:2,isValue:"True",A.isValue:"False" "rocketSpeed: va ..."
 --  A::Address:E:"rocketSpeed"off:0 size:0 isFloat:False superAdj:0 isUniq ...  ...r ...
 -- value_prim:false
 -- Velocity.MperS
 -- before:floatTest: %unit "m*s^-1", "m*s^-1"
 -- computeAdr:isFirst::Address:E:"rocketSpeed"off:2 size:0 isFloat:False s ...
 -- computeAdr:2 :rec:"rocketSpeed"  E:":= exhaustSpeed * log((rocketMass + ..." : ...
 -- computeAdr:isAssign:rec: "rocketSpeed"  E:":= exhaustSpeed * log((rocke ..." 
 -- :Address:E:"rocketSpeed"off:2 size:0 isFloat:False superAdj:0 isUnique: ...
 -- computeAdr:isLast:E: ":= exhaustSpeed * log((rocketMass + fuelMass) / r ..." 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"rocketSpeed"off:2 size:0 isF ...
 -- rec: "rocketSpeed" E: ":= exhaustSpeed * log((rocketMass + fuelMass) /  ..." i ...true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:2 ":= exhaustSpeed * log((r ..."
 -- $pattern:loadArgs:E:":= exhaustSpeed * log((rocketMass + fuelMass) / ro ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= exhaustSpeed * log((rocketMass + fuelMass) / rocke ..." A ..."e ..." i ...false
 -- $ObjectCall:gen: "exhaustSpeed * log((rocketMass + fuelMass) / rocketMa ..."
 -- $Invocation:gen: descNo: 0 top: 0 "exhaustSpeed * log((rocketMass + fue ..."
 -- needorigin:"exhaustSpeed * log((rocketMass + fuelMass) / rocketMass)" 
 -- needOrigin:E:"* log((rocketMass + fuelMass) / rocketMass)"  E.ATd:"* :  ..." 
 -- computeAdr: "exhaustSpeed * log((rocketMass + fuelMass) / rocketMass)" 
 -- computeAdr:1 :rec:"none"  E:"exhaustSpeed" :Address:E:"none"off:0 size: ...
 -- $ObjectInvocation_Unary:pushThis: "exhaustSpeed"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "exhaustSpeed"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "exhaustSpeed"
 -- $var:getAdr:,newOff:4,isValue:"True",A.isValue:"False" "exhaustSpeed: v ..."
 --  A::Address:E:"exhaustSpeed"off:0 size:0 isFloat:False superAdj:0 isUni ...  ...e ...
 -- value_prim:false
 -- Velocity.MperS
 -- before:floatTest: %unit "m*s^-1", "m*s^-1"
 -- computeAdr:isFirst::Address:E:"exhaustSpeed"off:4 size:0 isFloat:False  ...
 -- computeAdr:2 :rec:"exhaustSpeed"  E:"* log((rocketMass + fuelMass) / ro ..." : ...
 -- E:notAssign:* log((rocketMass + fuelMass) / rocketMass)
 -- $ObjectInvocation_Binary:getAdr::superAdj:0:on:0 "* log((rocketMass + f ..."
 -- $pattern:getAdr: "* :  |    %basic 112 |    in V: var float |    out R: var f ..."
 -- :Address:E:"exhaustSpeed"off:4 size:0 isFloat:False superAdj:0 isUnique ...
 -- ptn.ssUnitValueObj:false isFloat:true
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "exhaustSpeed"
 -- $var:loadArgs: "exhaustSpeed: var Velocity.MperS"
 -- $ObjectInvocation_Unary:invoke: rec:"exhaustSpeed" "exhaustSpeed"
 -- E.ATd: "* " unique: false
 -- adr::Address:E:"exhaustSpeed"off:4 size:0 isFloat:False superAdj:0 isUn ...
 -- $var:invoke: newOff:4 "exhaustSpeed: var Velocity.MperS"
 -- >LoadValue:isAdr:false,Size:2 ,rec:"exhaustSpeed" ,E:"* log((rocketMass ..." 
 -- isCompositeValueObj: false
 -- loadAdr::Address:E:"exhaustSpeed"off:4 size:0 isFloat:False superAdj:0  ...
 -- loadAdr:isValue:originIsValue:false
 -- isFloat: false
 fpushg 4 
 -- OI:invoke:exhaustSpeed:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "* log((rocketMass + fuelMass) / rocketMass)" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"exhaustSpeed"off:4 size:0 is ...
 -- rec: "exhaustSpeed" E: "* log((rocketMass + fuelMass) / rocketMass)" is ...false
 -- $ObjectInvocation_Binary:loadArgs:staticOff:0 "* log((rocketMass + fuel ..."
 -- $pattern:loadArgs:E:"* log((rocketMass + fuelMass) / rocketMass)":descN ...
 -- isValueAssign: false
 -- loadArgs:NonVirt:"* log((rocketMass + fuelMass) / rocketMass)" ActArg:  ..."l ..." i ...false
 -- $ObjectCall:gen: "log((rocketMass + fuelMass) / rocketMass)"
 -- $Invocation:gen: descNo: 0 top: 0 "log((rocketMass + fuelMass) / rocket ..."
 -- needorigin:"log((rocketMass + fuelMass) / rocketMass)" 
 -- needOrigin:E:"log((rocketMass + fuelMass) / rocketMass)"  E.ATd:"log:  |  ..." 
 -- computeAdr: "log((rocketMass + fuelMass) / rocketMass)" 
 -- computeAdr:1 :rec:"none"  E:"log((rocketMass + fuelMass) / rocketMass)" : ...
 -- $ObjectInvocation_Function:pushThis: "log((rocketMass + fuelMass) / roc ..."
 -- $ObjectInvocation_Function:loadOrigin::on:2 "log((rocketMass + fuelMass ..."
 -- $ObjectInvocation_Function:getAdr::superAdj:0:on:2 "log((rocketMass + f ..."
 -- $pattern:getAdr: "log:  |    %basic 141 |    in V: var float |    out R: var  ..."
 -- :Address:E:"log((rocketMass + fuelMass) / rocketMass)"off:0 size:0 isFl ...
 -- computeAdr:isFirst::Address:E:"log((rocketMass + fuelMass) / rocketMass ..."
 -- computeAdr:isLast:E: "log((rocketMass + fuelMass) / rocketMass)" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"log((rocketMass + fuelMass)  ..."
 -- rec: "log((rocketMass + fuelMass) / rocketMass)" E: "log((rocketMass +  ..." i ...false
 -- $ObjectInvocation_Function:loadArgs:staticOff:0 "log((rocketMass + fuel ..."
 -- $pattern:loadArgs:E:"log((rocketMass + fuelMass) / rocketMass)":descNo: ...
 -- isValueAssign: false
 -- loadArgs:NonVirt:"log((rocketMass + fuelMass) / rocketMass)" ActArg: "( ..." i ...false
 -- loadArgs:not:*: formalArgOf:"log((rocketMass + fuelMass) / rocketMass)"   ...false
 -- $ObjectCall:gen: "(rocketMass + fuelMass) / rocketMass"
 -- $Invocation:gen: descNo: 0 top: 0 "(rocketMass + fuelMass) / rocketMass ..."
 -- needorigin:"(rocketMass + fuelMass) / rocketMass" 
 -- needOrigin:E:"/ rocketMass"  E.ATd:"/ :  |    %basic 121 |    in V: var flo ..." 
 -- computeAdr: "(rocketMass + fuelMass) / rocketMass" 
 -- computeAdr:1 :rec:"none"  E:"(rocketMass + fuelMass)" :Address:E:"none" ...
 -- $BracketedExp:pushThis: "(rocketMass + fuelMass)"
 -- $BracketedExp:loadOrigin: "(rocketMass + fuelMass)"
 -- computeAdr: "rocketMass + fuelMass" 
 -- computeAdr:1 :rec:"none"  E:"rocketMass" :Address:E:"none"off:0 size:0  ...
 -- $ObjectInvocation_Unary:pushThis: "rocketMass"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "rocketMass"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "rocketMass"
 -- $var:getAdr:,newOff:6,isValue:"True",A.isValue:"False" "rocketMass: var ..."
 --  A::Address:E:"rocketMass"off:0 size:0 isFloat:False superAdj:0 isUniqu ...  ...r ...
 -- value_prim:false
 -- Mass.KiloGram
 -- before:floatTest: %unit "kg"
 -- computeAdr:isFirst::Address:E:"rocketMass"off:6 size:0 isFloat:False su ...
 -- computeAdr:2 :rec:"rocketMass"  E:"+ fuelMass" :Address:E:"rocketMass"o ...
 -- E:notAssign:+ fuelMass
 -- $ObjectInvocation_Binary:getAdr::superAdj:0:on:0 "+ fuelMass"
 -- $pattern:getAdr: "+ :  |    %basic 109 |    in V: var float |    out R: var f ..."
 -- :Address:E:"rocketMass"off:6 size:0 isFloat:False superAdj:0 isUnique:F ...
 -- ptn.ssUnitValueObj:false isFloat:true
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "rocketMass"
 -- $var:loadArgs: "rocketMass: var Mass.KiloGram"
 -- $ObjectInvocation_Unary:invoke: rec:"rocketMass" "rocketMass"
 -- E.ATd: "+ " unique: false
 -- adr::Address:E:"rocketMass"off:6 size:0 isFloat:False superAdj:0 isUniq ...
 -- $var:invoke: newOff:6 "rocketMass: var Mass.KiloGram"
 -- >LoadValue:isAdr:false,Size:2 ,rec:"rocketMass" ,E:"+ fuelMass" 
 -- isCompositeValueObj: false
 -- loadAdr::Address:E:"rocketMass"off:6 size:0 isFloat:False superAdj:0 is ...
 -- loadAdr:isValue:originIsValue:false
 -- isFloat: false
 fpushg 6 
 -- OI:invoke:rocketMass:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "+ fuelMass" 
 -- BE:loadOrigin:E: + fuelMass
 -- $ObjectInvocation_Binary:getAdr::superAdj:0:on:0 "+ fuelMass"
 -- $pattern:getAdr: "+ :  |    %basic 109 |    in V: var float |    out R: var f ..."
 -- :Address:E:"+ fuelMass"off:0 size:0 isFloat:False superAdj:0 isUnique:F ...
 -- computeAdr:isFirst::Address:E:"+ fuelMass"off:0 size:0 isFloat:False su ...
 -- computeAdr:2 :rec:"+ fuelMass"  E:"/ rocketMass" :Address:E:"+ fuelMass ..."
 -- E:notAssign:/ rocketMass
 -- $ObjectInvocation_Binary:getAdr::superAdj:0:on:0 "/ rocketMass"
 -- $pattern:getAdr: "/ :  |    %basic 121 |    in V: var float |    out R: var f ..."
 -- :Address:E:"+ fuelMass"off:0 size:0 isFloat:False superAdj:0 isUnique:F ...
 -- ptn.ssUnitValueObj:false isFloat:true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:0 "+ fuelMass"
 -- $pattern:loadArgs:E:"+ fuelMass":descNo:0:top:0 "+ :  |    %basic 109 |     ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"+ fuelMass" ActArg: "fuelMass" isValue: true
 -- loadArgs:not:*: formalArgOf:"+ fuelMass"  isCompositeValueObj:false
 -- $ObjectGenerator:gen:"fuelMass#S#0"IS.isempty! staticOff: 0 descNo: 0 t ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: false
 -- $Invocation:gen: "fuelMass"
 -- needorigin:"fuelMass" 
 -- needOrigin:E:"fuelMass"  E.ATd:"fuelMass: var Mass.KiloGram" 
 -- needOrigin:datItem:leave
 -- computeAdr: "fuelMass" 
 -- computeAdr:1 :rec:"none"  E:"fuelMass" :Address:E:"none"off:0 size:0 is ...
 -- $ObjectInvocation_Unary:pushThis: "fuelMass"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "fuelMass"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "fuelMass"
 -- $var:getAdr:,newOff:8,isValue:"True",A.isValue:"False" "fuelMass: var M ..."
 --  A::Address:E:"fuelMass"off:0 size:0 isFloat:False superAdj:0 isUnique: ...  ...f ...
 -- value_prim:false
 -- Mass.KiloGram
 -- before:floatTest: %unit "kg"
 -- computeAdr:isFirst::Address:E:"fuelMass"off:8 size:0 isFloat:False supe ...
 -- computeAdr:isLast:E: "fuelMass" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"fuelMass"off:8 size:0 isFloa ...
 -- rec: "fuelMass" E: "fuelMass" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "fuelMass"
 -- $var:loadArgs: "fuelMass: var Mass.KiloGram"
 -- invoke:after:loadArgsOf:"fuelMass" :Address:E:"fuelMass"off:8 size:0 is ...
 -- $ObjectInvocation_Unary:invoke: rec:"fuelMass" "fuelMass"
 -- E.ATd: "fuelMass" unique: false
 -- adr::Address:E:"fuelMass"off:8 size:0 isFloat:False superAdj:0 isUnique ...
 -- $var:invoke: newOff:8 "fuelMass: var Mass.KiloGram"
 -- >LoadValue:isAdr:false,Size:2 ,rec:"fuelMass" ,E:"fuelMass" 
 -- isCompositeValueObj: false
 -- loadAdr::Address:E:"fuelMass"off:8 size:0 isFloat:False superAdj:0 isUn ...
 -- loadAdr:isValue:originIsValue:false
 -- isFloat: false
 fpushg 8 
 -- OI:invoke:fuelMass:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"fuelMass" 
 -- loadArgs:after:Qgen:"+ fuelMass" 
 -- before:pushSize: actualArg.super.ATd.OG.isUnitValueObj:true
 -- :actualArg.isCompositeValueObj:false isAssign: false
 -- actualArg:UnitOne?:fuelMass
 -- end:loadArgs:NonVirt:"+ fuelMass" 
 -- $ObjectInvocation_Binary:invoke: rec:"rocketMass" "+ fuelMass"
 -- >top:0 descNo:0 
 -- E.ATd: "/ " unique: false
 -- adr::Address:E:"+ fuelMass"off:0 size:0 isFloat:False superAdj:0 isUniq ...
 -- $pattern:invoke: "+ :  |    %basic 109 |    in V: var float |    out R: var f ..."
 -- bodyC:
 fplus
 -- OI:invoke:+ fuelMass:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "/ rocketMass" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"+ fuelMass"off:0 size:0 isFl ...
 -- rec: "+ fuelMass" E: "/ rocketMass" isValueAssign: false
 -- $ObjectInvocation_Binary:loadArgs:staticOff:0 "/ rocketMass"
 -- $pattern:loadArgs:E:"/ rocketMass":descNo:0:top:0 "/ :  |    %basic 121 |   ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"/ rocketMass" ActArg: "rocketMass" isValue: true
 -- loadArgs:not:*: formalArgOf:"/ rocketMass"  isCompositeValueObj:false
 -- $ObjectGenerator:gen:"rocketMass#S#0"IS.isempty! staticOff: 0 descNo: 0 ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: false
 -- $Invocation:gen: "rocketMass"
 -- needorigin:"rocketMass" 
 -- needOrigin:E:"rocketMass"  E.ATd:"rocketMass: var Mass.KiloGram" 
 -- needOrigin:datItem:leave
 -- computeAdr: "rocketMass" 
 -- computeAdr:1 :rec:"none"  E:"rocketMass" :Address:E:"none"off:0 size:0  ...
 -- $ObjectInvocation_Unary:pushThis: "rocketMass"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "rocketMass"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "rocketMass"
 -- $var:getAdr:,newOff:6,isValue:"True",A.isValue:"False" "rocketMass: var ..."
 --  A::Address:E:"rocketMass"off:0 size:0 isFloat:False superAdj:0 isUniqu ...  ...r ...
 -- value_prim:false
 -- Mass.KiloGram
 -- before:floatTest: %unit "kg"
 -- computeAdr:isFirst::Address:E:"rocketMass"off:6 size:0 isFloat:False su ...
 -- computeAdr:isLast:E: "rocketMass" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"rocketMass"off:6 size:0 isFl ...
 -- rec: "rocketMass" E: "rocketMass" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "rocketMass"
 -- $var:loadArgs: "rocketMass: var Mass.KiloGram"
 -- invoke:after:loadArgsOf:"rocketMass" :Address:E:"rocketMass"off:6 size: ...
 -- $ObjectInvocation_Unary:invoke: rec:"rocketMass" "rocketMass"
 -- E.ATd: "rocketMass" unique: false
 -- adr::Address:E:"rocketMass"off:6 size:0 isFloat:False superAdj:0 isUniq ...
 -- $var:invoke: newOff:6 "rocketMass: var Mass.KiloGram"
 -- >LoadValue:isAdr:false,Size:2 ,rec:"rocketMass" ,E:"rocketMass" 
 -- isCompositeValueObj: false
 -- loadAdr::Address:E:"rocketMass"off:6 size:0 isFloat:False superAdj:0 is ...
 -- loadAdr:isValue:originIsValue:false
 -- isFloat: false
 fpushg 6 
 -- OI:invoke:rocketMass:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"rocketMass" 
 -- loadArgs:after:Qgen:"/ rocketMass" 
 -- before:pushSize: actualArg.super.ATd.OG.isUnitValueObj:true
 -- :actualArg.isCompositeValueObj:false isAssign: false
 -- actualArg:UnitOne?:rocketMass
 -- end:loadArgs:NonVirt:"/ rocketMass" 
 -- invoke:after:loadArgsOf:"/ rocketMass" :Address:E:"+ fuelMass"off:0 siz ...
 -- $ObjectInvocation_Binary:invoke: rec:"+ fuelMass" "/ rocketMass"
 -- >top:0 descNo:0 
 -- E.ATd: "/ " unique: false
 -- adr::Address:E:"+ fuelMass"off:0 size:0 isFloat:False superAdj:0 isUniq ...
 -- $pattern:invoke: "/ :  |    %basic 121 |    in V: var float |    out R: var f ..."
 -- bodyC:
 fdiv
 -- OI:invoke:/ rocketMass:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"/ rocketMass" 
 -- loadArgs:after:Qgen:"log((rocketMass + fuelMass) / rocketMass)" 
 -- formalArg:isPtn:"in V: var float" :isBasicVal:true:valueObj:true
 -- :actArg:"(rocketMass + fuelMass) / rocketMass" :isBasicVal:true
 -- (rocketMass + fuelMass) / rocketMassObjectCall
 -- end:loadArgs:NonVirt:"log((rocketMass + fuelMass) / rocketMass)" 
 -- invoke:after:loadArgsOf:"log((rocketMass + fuelMass) / rocketMass)" :Ad ...
 -- $ObjectInvocation_Function:invoke: rec:"log((rocketMass + fuelMass) / r ..."
 -- >top:0 descNo:0 
 -- E.ATd: "log" unique: false
 -- adr::Address:E:"log((rocketMass + fuelMass) / rocketMass)"off:0 size:0  ...
 -- $pattern:invoke: "log:  |    %basic 141 |    in V: var float |    out R: var  ..."
 -- Pattern:invoke:descNo:0  top:0  rec:"log((rocketMass + fuelMass) / rock ..." 
 -- ptn:invoke:primitive:log
 %log_prim 141
 -- useRtnVal:true:isVal:false:rtnValObj:false:rec=E:true"log((rocketMass + ..." 
 -- OI:invoke:log((rocketMass + fuelMass) / rocketMass):unit: -none- convFa ...0.000000
 -- invoke:after:E.invoke:"log((rocketMass + fuelMass) / rocketMass)" 
 -- loadArgs:after:Qgen:"* log((rocketMass + fuelMass) / rocketMass)" 
 -- formalArg:isPtn:"in V: var float" :isBasicVal:true:valueObj:true
 -- :actArg:"log((rocketMass + fuelMass) / rocketMass)" :isBasicVal:true
 -- log((rocketMass + fuelMass) / rocketMass)ObjectCall
 -- end:loadArgs:NonVirt:"* log((rocketMass + fuelMass) / rocketMass)" 
 -- invoke:after:loadArgsOf:"* log((rocketMass + fuelMass) / rocketMass)" : ...
 -- $ObjectInvocation_Binary:invoke: rec:"exhaustSpeed" "* log((rocketMass  ..."
 -- >top:0 descNo:0 
 -- E.ATd: "* " unique: false
 -- adr::Address:E:"exhaustSpeed"off:4 size:0 isFloat:False superAdj:0 isUn ...
 -- $pattern:invoke: "* :  |    %basic 112 |    in V: var float |    out R: var f ..."
 -- bodyC:
 fmult
 -- OI:invoke:* log((rocketMass + fuelMass) / rocketMass):unit: -none- conv ...0.000000
 -- invoke:after:E.invoke:"* log((rocketMass + fuelMass) / rocketMass)" 
 -- loadArgs:after:Qgen:":= exhaustSpeed * log((rocketMass + fuelMass) / ro ..." 
 -- vAssign:fArg:"in V: var Value" 
 -- BINGO
 -- aaaa: in V: var Value
 -- end:loadArgs:NonVirt:":= exhaustSpeed * log((rocketMass + fuelMass) / r ..." 
 -- invoke:after:loadArgsOf:":= exhaustSpeed * log((rocketMass + fuelMass)  ..." : ...
 -- $ObjectInvocation_Binary:invoke: rec:"rocketSpeed" ":= exhaustSpeed * l ..."
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Address:E:"rocketSpeed"off:2 size:0 isFloat:False superAdj:0 isUni ...
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "rocketSpeed" from: ":= exhaustSpeed * log((rocke ..." 
 -- assign:dstDI :"rocketSpeed: var Velocity.MperS" isUnitValueObj: true
 -- assign:arg: "exhaustSpeed * log((rocketMass + fuelMass) / rocketMass)" l ..."O ..." U ...false  ...false
 --  float: true DataItem:false arg.super:exhaustSpeed * log((rocketMass +  ...
 --  arg.super.ATd:"Invocation" "* :  |    %basic 112 |    in V: var float |    o ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:true
 --  arg.super.ATd.label: "pattern" 
 -- assign:simple value: 
 -- :Address:E:"rocketSpeed"off:2 size:0 isFloat:False superAdj:0 isUnique: ...
 -- store::Address:E:"rocketSpeed"off:2 size:0 isFloat:False superAdj:0 isU ...
 -- isValue:true isAdr:false descNo: 0 
 -- isFloat: false
 fstoreg 2 address:storeg
 -- OI:invoke::= exhaustSpeed * log((rocketMass + fuelMass) / rocketMass):u ...-none-  ...0.000000
 -- invoke:after:E.invoke:":= exhaustSpeed * log((rocketMass + fuelMass) /  ..." 
 -- genclass:Qgen:stmt:""distToAlpha: ".print" 
 -- $ObjectCall:gen: ""distToAlpha: ".print"
 -- $Invocation:gen: descNo: 33 top: 1 ""distToAlpha: ".print"
 -- needorigin:""distToAlpha: ".print" 
 -- needOrigin:E:"print"  E.ATd:"print:  |    @for 1 :to length  |    :do  |      ..." 
 -- computeAdr: ""distToAlpha: ".print" 
 -- computeAdr:1 :rec:"none"  E:""distToAlpha: "" :Address:E:"none"off:0 si ...
 -- $String::pushThis: ""distToAlpha: ""
 -- $String::loadOrigin: ""distToAlpha: ""
 -- StringObj:loadOrigin:"distToAlpha: "
 -- $String::getAdr: ""distToAlpha: ""
 -- computeAdr:isFirst::Address:E:""distToAlpha: ""off:0 size:0 isFloat:Fal ...
 -- computeAdr:2 :rec:""distToAlpha: ""  E:"print" :Address:E:""distToAlpha ...
 -- E:notAssign:print
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "print"
 -- $pattern:getAdr: "print:  |    @for 1 :to length  |    :do  |       put(@get  ..."
 -- :Address:E:""distToAlpha: ""off:0 size:0 isFloat:False superAdj:0 isUni ...
 -- ptn.ssUnitValueObj:false isFloat:false
 -- $String::loadArgs: ""distToAlpha: ""
 -- $String::invoke: ""distToAlpha: ""
 -- Pattern:markForCodeGen:+ :  |    in S: ref String |    out V: ref String |    ...
 pushText distToAlpha: 
 -- computeAdr:isLast:E: "print" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:""distToAlpha: ""off:0 size:0 ...
 -- rec: ""distToAlpha: "" E: "print" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "print"
 -- $pattern:loadArgs:E:"print":descNo:33:top:1 "print:  |    @for 1 :to leng ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"print" :Address:E:""distToAlpha: ""off:0 size: ...
 -- $ObjectInvocation_Unary:invoke: rec:""distToAlpha: "" "print"
 -- >top:1 descNo:33 
 -- E.ATd: "print" unique: false
 -- adr::Address:E:""distToAlpha: ""off:0 size:0 isFloat:False superAdj:0 i ...
 -- $pattern:invoke: "print:  |    @for 1 :to length  |    :do  |       put(@get  ..."
 -- Pattern:invoke:descNo:33  top:1  rec:""distToAlpha: "" 
 -- ComputeVariantX
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- <>var
 -- rec:module or pattern:"print"  descno: 33  top: 1 "@for 1 :to length  | : ..." 
 -- ptn:invoke::isValObj:false:rtnValObj:false:"print:  |    @for 1 :to lengt ..." 
 -- rec=E:false:rec:""distToAlpha: "" 
 -- kuk:obj:rec.ATd:"String:  |    %OSDvisibility disguised |    %basic 5 |    %i ..." 
 invoke print 33 0 0
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:false""distToAlpha: " ..." 
 rpop
 -- OI:invoke:print:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"print" 
 -- genclass:Qgen:stmt:"putFloat(distToAlpha)" 
 -- $ObjectCall:gen: "putFloat(distToAlpha)"
 -- $Invocation:gen: descNo: 43 top: 1 "putFloat(distToAlpha)"
 -- needorigin:"putFloat(distToAlpha)" 
 -- needOrigin:E:"putFloat(distToAlpha)"  E.ATd:"putFloat:  |    %basic 142 |   ..." 
 -- computeAdr: "putFloat(distToAlpha)" 
 -- computeAdr:1 :rec:"none"  E:"putFloat(distToAlpha)" :Address:E:"none"of ...
 -- $ObjectInvocation_Function:pushThis: "putFloat(distToAlpha)"
 -- $ObjectInvocation_Function:loadOrigin::on:2 "putFloat(distToAlpha)"
 -- $ObjectInvocation_Function:getAdr::superAdj:0:on:2 "putFloat(distToAlph ..."
 -- $pattern:getAdr: "putFloat:  |    %basic 142 |    in X: var Float |    out V: ..."
 -- :Address:E:"putFloat(distToAlpha)"off:0 size:0 isFloat:False superAdj:0 ...
 -- computeAdr:isFirst::Address:E:"putFloat(distToAlpha)"off:0 size:0 isFlo ...
 -- computeAdr:isLast:E: "putFloat(distToAlpha)" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"putFloat(distToAlpha)"off:0  ...
 -- rec: "putFloat(distToAlpha)" E: "putFloat(distToAlpha)" isValueAssign:  ...false
 -- $ObjectInvocation_Function:loadArgs:staticOff:0 "putFloat(distToAlpha)" ...
 -- $pattern:loadArgs:E:"putFloat(distToAlpha)":descNo:43:top:1 "putFloat:  ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"putFloat(distToAlpha)" ActArg: "distToAlpha" isValue: ...true
 -- loadArgs:not:*: formalArgOf:"putFloat(distToAlpha)"  isCompositeValueOb ...false
 -- $ObjectGenerator:gen:"distToAlpha#S#0"IS.isempty! staticOff: 0 descNo:  ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: false
 -- $Invocation:gen: "distToAlpha"
 -- needorigin:"distToAlpha" 
 -- needOrigin:E:"distToAlpha"  E.ATd:"distToAlpha: var Length.LightYear" 
 -- needOrigin:datItem:leave
 -- computeAdr: "distToAlpha" 
 -- computeAdr:1 :rec:"none"  E:"distToAlpha" :Address:E:"none"off:0 size:0 ...
 -- $ObjectInvocation_Unary:pushThis: "distToAlpha"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "distToAlpha"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "distToAlpha"
 -- $var:getAdr:,newOff:10,isValue:"True",A.isValue:"False" "distToAlpha: v ..."
 --  A::Address:E:"distToAlpha"off:0 size:0 isFloat:False superAdj:0 isUniq ...  ...d ...
 -- value_prim:false
 -- Length.LightYear
 -- before:floatTest: %unit "ly", "9460000000000000"
 -- computeAdr:isFirst::Address:E:"distToAlpha"off:10 size:0 isFloat:False  ...
 -- computeAdr:isLast:E: "distToAlpha" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"distToAlpha"off:10 size:0 is ...
 -- rec: "distToAlpha" E: "distToAlpha" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "distToAlpha"
 -- $var:loadArgs: "distToAlpha: var Length.LightYear"
 -- invoke:after:loadArgsOf:"distToAlpha" :Address:E:"distToAlpha"off:10 si ...
 -- $ObjectInvocation_Unary:invoke: rec:"distToAlpha" "distToAlpha"
 -- E.ATd: "distToAlpha" unique: false
 -- adr::Address:E:"distToAlpha"off:10 size:0 isFloat:False superAdj:0 isUn ...
 -- $var:invoke: newOff:10 "distToAlpha: var Length.LightYear"
 -- >LoadValue:isAdr:false,Size:2 ,rec:"distToAlpha" ,E:"distToAlpha" 
 -- isCompositeValueObj: false
 -- loadAdr::Address:E:"distToAlpha"off:10 size:0 isFloat:False superAdj:0  ...
 -- loadAdr:isValue:originIsValue:false
 -- isFloat: false
 fpushg 10 
 -- OI:invoke:distToAlpha:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"distToAlpha" 
 -- loadArgs:after:Qgen:"putFloat(distToAlpha)" 
 -- before:pushSize: actualArg.super.ATd.OG.isUnitValueObj:true
 -- :actualArg.isCompositeValueObj:false isAssign: false
 -- actualArg:UnitOne?:distToAlpha
 -- end:loadArgs:NonVirt:"putFloat(distToAlpha)" 
 -- invoke:after:loadArgsOf:"putFloat(distToAlpha)" :Address:E:"putFloat(di ..."
 -- $ObjectInvocation_Function:invoke: rec:"putFloat(distToAlpha)" "putFloa ..."
 -- >top:1 descNo:43 
 -- E.ATd: "putFloat" unique: false
 -- adr::Address:E:"putFloat(distToAlpha)"off:0 size:0 isFloat:False superA ...
 -- $pattern:invoke: "putFloat:  |    %basic 142 |    in X: var Float |    out V: ..."
 -- Pattern:invoke:descNo:43  top:1  rec:"putFloat(distToAlpha)" 
 -- ptn:invoke:primitive:putFloat
 %printf_prim 142
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:true"putFloat(distToA ..." 
 vpop
 -- OI:invoke:putFloat(distToAlpha):unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"putFloat(distToAlpha)" 
 -- genclass:Qgen:stmt:"" rocketSpeed: ".print" 
 -- $ObjectCall:gen: "" rocketSpeed: ".print"
 -- $Invocation:gen: descNo: 33 top: 1 "" rocketSpeed: ".print"
 -- needorigin:"" rocketSpeed: ".print" 
 -- needOrigin:E:"print"  E.ATd:"print:  |    @for 1 :to length  |    :do  |      ..." 
 -- computeAdr: "" rocketSpeed: ".print" 
 -- computeAdr:1 :rec:"none"  E:"" rocketSpeed: "" :Address:E:"none"off:0 s ...
 -- $String::pushThis: "" rocketSpeed: ""
 -- $String::loadOrigin: "" rocketSpeed: ""
 -- StringObj:loadOrigin:" rocketSpeed: "
 -- $String::getAdr: "" rocketSpeed: ""
 -- computeAdr:isFirst::Address:E:"" rocketSpeed: ""off:0 size:0 isFloat:Fa ...
 -- computeAdr:2 :rec:"" rocketSpeed: ""  E:"print" :Address:E:"" rocketSpe ...
 -- E:notAssign:print
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "print"
 -- $pattern:getAdr: "print:  |    @for 1 :to length  |    :do  |       put(@get  ..."
 -- :Address:E:"" rocketSpeed: ""off:0 size:0 isFloat:False superAdj:0 isUn ...
 -- ptn.ssUnitValueObj:false isFloat:false
 -- $String::loadArgs: "" rocketSpeed: ""
 -- $String::invoke: "" rocketSpeed: ""
 -- Pattern:markForCodeGen:+ :  |    in S: ref String |    out V: ref String |    ...
 pushText  rocketSpeed: 
 -- computeAdr:isLast:E: "print" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"" rocketSpeed: ""off:0 size: ...
 -- rec: "" rocketSpeed: "" E: "print" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "print"
 -- $pattern:loadArgs:E:"print":descNo:33:top:1 "print:  |    @for 1 :to leng ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"print" :Address:E:"" rocketSpeed: ""off:0 size ...
 -- $ObjectInvocation_Unary:invoke: rec:"" rocketSpeed: "" "print"
 -- >top:1 descNo:33 
 -- E.ATd: "print" unique: false
 -- adr::Address:E:"" rocketSpeed: ""off:0 size:0 isFloat:False superAdj:0  ...
 -- $pattern:invoke: "print:  |    @for 1 :to length  |    :do  |       put(@get  ..."
 -- Pattern:invoke:descNo:33  top:1  rec:"" rocketSpeed: "" 
 -- ComputeVariantX
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- <>var
 -- rec:module or pattern:"print"  descno: 33  top: 1 "@for 1 :to length  | : ..." 
 -- ptn:invoke::isValObj:false:rtnValObj:false:"print:  |    @for 1 :to lengt ..." 
 -- rec=E:false:rec:"" rocketSpeed: "" 
 -- kuk:obj:rec.ATd:"String:  |    %OSDvisibility disguised |    %basic 5 |    %i ..." 
 invoke print 33 0 0
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:false"" rocketSpeed:  ..."" 
 rpop
 -- OI:invoke:print:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"print" 
 -- genclass:Qgen:stmt:"putFloat(rocketSpeed)" 
 -- $ObjectCall:gen: "putFloat(rocketSpeed)"
 -- $Invocation:gen: descNo: 43 top: 1 "putFloat(rocketSpeed)"
 -- needorigin:"putFloat(rocketSpeed)" 
 -- needOrigin:E:"putFloat(rocketSpeed)"  E.ATd:"putFloat:  |    %basic 142 |   ..." 
 -- computeAdr: "putFloat(rocketSpeed)" 
 -- computeAdr:1 :rec:"none"  E:"putFloat(rocketSpeed)" :Address:E:"none"of ...
 -- $ObjectInvocation_Function:pushThis: "putFloat(rocketSpeed)"
 -- $ObjectInvocation_Function:loadOrigin::on:2 "putFloat(rocketSpeed)"
 -- $ObjectInvocation_Function:getAdr::superAdj:0:on:2 "putFloat(rocketSpee ..."
 -- $pattern:getAdr: "putFloat:  |    %basic 142 |    in X: var Float |    out V: ..."
 -- :Address:E:"putFloat(rocketSpeed)"off:0 size:0 isFloat:False superAdj:0 ...
 -- computeAdr:isFirst::Address:E:"putFloat(rocketSpeed)"off:0 size:0 isFlo ...
 -- computeAdr:isLast:E: "putFloat(rocketSpeed)" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"putFloat(rocketSpeed)"off:0  ...
 -- rec: "putFloat(rocketSpeed)" E: "putFloat(rocketSpeed)" isValueAssign:  ...false
 -- $ObjectInvocation_Function:loadArgs:staticOff:0 "putFloat(rocketSpeed)" ...
 -- $pattern:loadArgs:E:"putFloat(rocketSpeed)":descNo:43:top:1 "putFloat:  ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"putFloat(rocketSpeed)" ActArg: "rocketSpeed" isValue: ...true
 -- loadArgs:not:*: formalArgOf:"putFloat(rocketSpeed)"  isCompositeValueOb ...false
 -- $ObjectGenerator:gen:"rocketSpeed#S#0"IS.isempty! staticOff: 0 descNo:  ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: false
 -- $Invocation:gen: "rocketSpeed"
 -- needorigin:"rocketSpeed" 
 -- needOrigin:E:"rocketSpeed"  E.ATd:"rocketSpeed: var Velocity.MperS" 
 -- needOrigin:datItem:leave
 -- computeAdr: "rocketSpeed" 
 -- computeAdr:1 :rec:"none"  E:"rocketSpeed" :Address:E:"none"off:0 size:0 ...
 -- $ObjectInvocation_Unary:pushThis: "rocketSpeed"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "rocketSpeed"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "rocketSpeed"
 -- $var:getAdr:,newOff:2,isValue:"True",A.isValue:"False" "rocketSpeed: va ..."
 --  A::Address:E:"rocketSpeed"off:0 size:0 isFloat:False superAdj:0 isUniq ...  ...r ...
 -- value_prim:false
 -- Velocity.MperS
 -- before:floatTest: %unit "m*s^-1", "m*s^-1"
 -- computeAdr:isFirst::Address:E:"rocketSpeed"off:2 size:0 isFloat:False s ...
 -- computeAdr:isLast:E: "rocketSpeed" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"rocketSpeed"off:2 size:0 isF ...
 -- rec: "rocketSpeed" E: "rocketSpeed" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "rocketSpeed"
 -- $var:loadArgs: "rocketSpeed: var Velocity.MperS"
 -- invoke:after:loadArgsOf:"rocketSpeed" :Address:E:"rocketSpeed"off:2 siz ...
 -- $ObjectInvocation_Unary:invoke: rec:"rocketSpeed" "rocketSpeed"
 -- E.ATd: "rocketSpeed" unique: false
 -- adr::Address:E:"rocketSpeed"off:2 size:0 isFloat:False superAdj:0 isUni ...
 -- $var:invoke: newOff:2 "rocketSpeed: var Velocity.MperS"
 -- >LoadValue:isAdr:false,Size:2 ,rec:"rocketSpeed" ,E:"rocketSpeed" 
 -- isCompositeValueObj: false
 -- loadAdr::Address:E:"rocketSpeed"off:2 size:0 isFloat:False superAdj:0 i ...
 -- loadAdr:isValue:originIsValue:false
 -- isFloat: false
 fpushg 2 
 -- OI:invoke:rocketSpeed:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"rocketSpeed" 
 -- loadArgs:after:Qgen:"putFloat(rocketSpeed)" 
 -- before:pushSize: actualArg.super.ATd.OG.isUnitValueObj:true
 -- :actualArg.isCompositeValueObj:false isAssign: false
 -- actualArg:UnitOne?:rocketSpeed
 -- end:loadArgs:NonVirt:"putFloat(rocketSpeed)" 
 -- invoke:after:loadArgsOf:"putFloat(rocketSpeed)" :Address:E:"putFloat(ro ..."
 -- $ObjectInvocation_Function:invoke: rec:"putFloat(rocketSpeed)" "putFloa ..."
 -- >top:1 descNo:43 
 -- E.ATd: "putFloat" unique: false
 -- adr::Address:E:"putFloat(rocketSpeed)"off:0 size:0 isFloat:False superA ...
 -- $pattern:invoke: "putFloat:  |    %basic 142 |    in X: var Float |    out V: ..."
 -- Pattern:invoke:descNo:43  top:1  rec:"putFloat(rocketSpeed)" 
 -- ptn:invoke:primitive:putFloat
 %printf_prim 142
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:true"putFloat(rocketS ..." 
 vpop
 -- OI:invoke:putFloat(rocketSpeed):unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"putFloat(rocketSpeed)" 
 -- genclass:Qgen:stmt:"d := distToAlpha.toBase" 
 -- $ObjectCall:gen: "d := distToAlpha.toBase"
 -- $Invocation:gen: descNo: 4 top: 1 "d := distToAlpha.toBase"
 -- needorigin:"d := distToAlpha.toBase" 
 -- needOrigin:E:":= distToAlpha.toBase"  E.ATd:":= :  |    %basic 8 |    in V: ..." 
 -- computeAdr: "d := distToAlpha.toBase" 
 -- computeAdr:1 :rec:"none"  E:"d" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "d"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "d"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "d"
 -- $var:getAdr:,newOff:18,isValue:"True",A.isValue:"False" "d: var Length. ..."
 --  A::Address:E:"d"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...d ...
 -- value_prim:false
 -- Length.Meter
 -- before:floatTest: %unit "m"
 -- computeAdr:isFirst::Address:E:"d"off:18 size:0 isFloat:False superAdj:0 ...
 -- computeAdr:2 :rec:"d"  E:":= distToAlpha.toBase" :Address:E:"d"off:18 s ...
 -- computeAdr:isAssign:rec: "d"  E:":= distToAlpha.toBase" 
 -- :Address:E:"d"off:18 size:0 isFloat:False superAdj:0 isUnique:False isV ...
 -- computeAdr:isLast:E: ":= distToAlpha.toBase" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"d"off:18 size:0 isFloat:Fals ...
 -- rec: "d" E: ":= distToAlpha.toBase" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:18 ":= distToAlpha.toBase"
 -- $pattern:loadArgs:E:":= distToAlpha.toBase":descNo:4:top:1 ":= :  |    %b ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= distToAlpha.toBase" ActArg: "distToAlpha.toBase" i ...false
 -- $ObjectCall:gen: "distToAlpha.toBase"
 -- $Invocation:gen: descNo: 73 top: 1 "distToAlpha.toBase"
 -- needorigin:"distToAlpha.toBase" 
 -- needOrigin:E:"toBase"  E.ATd:"toBase::  |    --bxx: var BaseUnit |    --bxx ..." 
 -- computeAdr: "distToAlpha.toBase" 
 -- computeAdr:1 :rec:"none"  E:"distToAlpha" :Address:E:"none"off:0 size:0 ...
 -- $ObjectInvocation_Unary:pushThis: "distToAlpha"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "distToAlpha"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "distToAlpha"
 -- $var:getAdr:,newOff:10,isValue:"True",A.isValue:"False" "distToAlpha: v ..."
 --  A::Address:E:"distToAlpha"off:0 size:0 isFloat:False superAdj:0 isUniq ...  ...d ...
 -- value_prim:false
 -- Length.LightYear
 -- before:floatTest: %unit "ly", "9460000000000000"
 -- computeAdr:isFirst::Address:E:"distToAlpha"off:10 size:0 isFloat:False  ...
 -- computeAdr:2 :rec:"distToAlpha"  E:"toBase" :Address:E:"distToAlpha"off ...
 -- E:notAssign:toBase
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "toBase"
 -- $pattern:getAdr: "toBase::  |    --bxx: var BaseUnit |    --bxx := magnitud ..."
 -- :Address:E:"distToAlpha"off:10 size:0 isFloat:False superAdj:0 isUnique ...
 -- ptn.ssUnitValueObj:false isFloat:false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "distToAlpha"
 -- $var:loadArgs: "distToAlpha: var Length.LightYear"
 -- $ObjectInvocation_Unary:invoke: rec:"distToAlpha" "distToAlpha"
 -- E.ATd: "toBase" unique: false
 -- adr::Address:E:"distToAlpha"off:10 size:0 isFloat:False superAdj:0 isUn ...
 -- $var:invoke: newOff:10 "distToAlpha: var Length.LightYear"
 -- >LoadValue:isAdr:true,Size:2 ,rec:"distToAlpha" ,E:"toBase" 
 -- isCompositeValueObj: false
 -- loadAdr::Address:E:"distToAlpha"off:10 size:0 isFloat:False superAdj:0  ...
 -- loadAdr:isValue:originIsValue:false
 -- isFloat: false
 addOff 10
 -- OI:invoke:distToAlpha:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "toBase" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"distToAlpha"off:10 size:0 is ...
 -- rec: "distToAlpha" E: "toBase" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "toBase"
 -- $pattern:loadArgs:E:"toBase":descNo:73:top:1 "toBase::  |    --bxx: var B ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"toBase" :Address:E:"distToAlpha"off:10 size:0  ...
 -- $ObjectInvocation_Unary:invoke: rec:"distToAlpha" "toBase"
 -- >top:1 descNo:73 
 -- E.ATd: "toBase" unique: false
 -- adr::Address:E:"distToAlpha"off:10 size:0 isFloat:False superAdj:0 isUn ...
 -- $pattern:invoke: "toBase::  |    --bxx: var BaseUnit |    --bxx := magnitud ..."
 -- Pattern:invoke:descNo:73  top:1  rec:"distToAlpha" 
 -- ComputeVariantX
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:toBase
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- <>var
 invoke toBase 73 0 1
 -- useRtnVal:true:isVal:false:rtnValObj:false:rec=E:false"distToAlpha" 
 -- OI:invoke:toBase:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"toBase" 
 -- loadArgs:after:Qgen:":= distToAlpha.toBase" 
 -- vAssign:fArg:"in V: var Value" 
 -- BINGO
 -- loadArgs:assign:srcDI:rtnValueObj: base
 pushvalue 2
 -- end:loadArgs:NonVirt:":= distToAlpha.toBase" 
 -- invoke:after:loadArgsOf:":= distToAlpha.toBase" :Address:E:"d"off:18 si ...
 -- $ObjectInvocation_Binary:invoke: rec:"d" ":= distToAlpha.toBase"
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Address:E:"d"off:18 size:0 isFloat:False superAdj:0 isUnique:False ...
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "d" from: ":= distToAlpha.toBase" 
 -- assign:dstDI :"d: var Length.Meter" isUnitValueObj: true
 -- assign:arg: "distToAlpha.toBase" lab:"ObjectCall" UnitValObj :false ptn ...false
 --  float: false DataItem:false arg.super:distToAlpha.toBase
 --  arg.super.ATd:"Invocation" "toBase::  |    --bxx: var BaseUnit |    --bxx  ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "pattern" 
 -- assign:ValueObj:isPtn: true size:2 
 -- :Address:E:"d"off:18 size:2 isFloat:False superAdj:0 isUnique:False isV ...
 -- store::Address:E:"d"off:18 size:2 isFloat:False superAdj:0 isUnique:Fal ...
 -- isValue:true isAdr:true descNo: 0 
 -- Address:store::srcIsVal:false destIsVal:false mode:0 
 addOff 18
 vassign 2 0
 -- OI:invoke::= distToAlpha.toBase:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= distToAlpha.toBase" 
 -- genclass:Qgen:stmt:"t := d / rocketSpeed" 
 -- $ObjectCall:gen: "t := d / rocketSpeed"
 -- $Invocation:gen: descNo: 4 top: 1 "t := d / rocketSpeed"
 -- needorigin:"t := d / rocketSpeed" 
 -- needOrigin:E:":= d / rocketSpeed"  E.ATd:":= :  |    %basic 8 |    in V: va ..." 
 -- computeAdr: "t := d / rocketSpeed" 
 -- computeAdr:1 :rec:"none"  E:"t" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "t"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "t"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "t"
 -- $var:getAdr:,newOff:12,isValue:"True",A.isValue:"False" "t: var Time.Se ..."
 --  A::Address:E:"t"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...t ...
 -- value_prim:false
 -- Time.Second
 -- before:floatTest: %unit "s"
 -- computeAdr:isFirst::Address:E:"t"off:12 size:0 isFloat:False superAdj:0 ...
 -- computeAdr:2 :rec:"t"  E:":= d / rocketSpeed" :Address:E:"t"off:12 size ...
 -- computeAdr:isAssign:rec: "t"  E:":= d / rocketSpeed" 
 -- :Address:E:"t"off:12 size:0 isFloat:False superAdj:0 isUnique:False isV ...
 -- computeAdr:isLast:E: ":= d / rocketSpeed" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"t"off:12 size:0 isFloat:Fals ...
 -- rec: "t" E: ":= d / rocketSpeed" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:12 ":= d / rocketSpeed"
 -- $pattern:loadArgs:E:":= d / rocketSpeed":descNo:4:top:1 ":= :  |    %basi ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= d / rocketSpeed" ActArg: "d / rocketSpeed" isValue ...false
 -- $ObjectCall:gen: "d / rocketSpeed"
 -- $Invocation:gen: descNo: 0 top: 0 "d / rocketSpeed"
 -- needorigin:"d / rocketSpeed" 
 -- needOrigin:E:"/ rocketSpeed"  E.ATd:"/ :  |    %basic 121 |    in V: var fl ..." 
 -- computeAdr: "d / rocketSpeed" 
 -- computeAdr:1 :rec:"none"  E:"d" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "d"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "d"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "d"
 -- $var:getAdr:,newOff:18,isValue:"True",A.isValue:"False" "d: var Length. ..."
 --  A::Address:E:"d"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...d ...
 -- value_prim:false
 -- Length.Meter
 -- before:floatTest: %unit "m"
 -- computeAdr:isFirst::Address:E:"d"off:18 size:0 isFloat:False superAdj:0 ...
 -- computeAdr:2 :rec:"d"  E:"/ rocketSpeed" :Address:E:"d"off:18 size:0 is ...
 -- E:notAssign:/ rocketSpeed
 -- $ObjectInvocation_Binary:getAdr::superAdj:0:on:0 "/ rocketSpeed"
 -- $pattern:getAdr: "/ :  |    %basic 121 |    in V: var float |    out R: var f ..."
 -- :Address:E:"d"off:18 size:0 isFloat:False superAdj:0 isUnique:False isV ...
 -- ptn.ssUnitValueObj:false isFloat:true
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "d"
 -- $var:loadArgs: "d: var Length.Meter"
 -- $ObjectInvocation_Unary:invoke: rec:"d" "d"
 -- E.ATd: "/ " unique: false
 -- adr::Address:E:"d"off:18 size:0 isFloat:False superAdj:0 isUnique:False ...
 -- $var:invoke: newOff:18 "d: var Length.Meter"
 -- >LoadValue:isAdr:false,Size:2 ,rec:"d" ,E:"/ rocketSpeed" 
 -- isCompositeValueObj: false
 -- loadAdr::Address:E:"d"off:18 size:0 isFloat:False superAdj:0 isUnique:F ...
 -- loadAdr:isValue:originIsValue:false
 -- isFloat: false
 fpushg 18 
 -- OI:invoke:d:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "/ rocketSpeed" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"d"off:18 size:0 isFloat:Fals ...
 -- rec: "d" E: "/ rocketSpeed" isValueAssign: false
 -- $ObjectInvocation_Binary:loadArgs:staticOff:0 "/ rocketSpeed"
 -- $pattern:loadArgs:E:"/ rocketSpeed":descNo:0:top:0 "/ :  |    %basic 121 |  ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"/ rocketSpeed" ActArg: "rocketSpeed" isValue: true
 -- loadArgs:not:*: formalArgOf:"/ rocketSpeed"  isCompositeValueObj:false
 -- $ObjectGenerator:gen:"rocketSpeed#S#0"IS.isempty! staticOff: 0 descNo:  ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: false
 -- $Invocation:gen: "rocketSpeed"
 -- needorigin:"rocketSpeed" 
 -- needOrigin:E:"rocketSpeed"  E.ATd:"rocketSpeed: var Velocity.MperS" 
 -- needOrigin:datItem:leave
 -- computeAdr: "rocketSpeed" 
 -- computeAdr:1 :rec:"none"  E:"rocketSpeed" :Address:E:"none"off:0 size:0 ...
 -- $ObjectInvocation_Unary:pushThis: "rocketSpeed"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "rocketSpeed"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "rocketSpeed"
 -- $var:getAdr:,newOff:2,isValue:"True",A.isValue:"False" "rocketSpeed: va ..."
 --  A::Address:E:"rocketSpeed"off:0 size:0 isFloat:False superAdj:0 isUniq ...  ...r ...
 -- value_prim:false
 -- Velocity.MperS
 -- before:floatTest: %unit "m*s^-1", "m*s^-1"
 -- computeAdr:isFirst::Address:E:"rocketSpeed"off:2 size:0 isFloat:False s ...
 -- computeAdr:isLast:E: "rocketSpeed" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"rocketSpeed"off:2 size:0 isF ...
 -- rec: "rocketSpeed" E: "rocketSpeed" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "rocketSpeed"
 -- $var:loadArgs: "rocketSpeed: var Velocity.MperS"
 -- invoke:after:loadArgsOf:"rocketSpeed" :Address:E:"rocketSpeed"off:2 siz ...
 -- $ObjectInvocation_Unary:invoke: rec:"rocketSpeed" "rocketSpeed"
 -- E.ATd: "rocketSpeed" unique: false
 -- adr::Address:E:"rocketSpeed"off:2 size:0 isFloat:False superAdj:0 isUni ...
 -- $var:invoke: newOff:2 "rocketSpeed: var Velocity.MperS"
 -- >LoadValue:isAdr:false,Size:2 ,rec:"rocketSpeed" ,E:"rocketSpeed" 
 -- isCompositeValueObj: false
 -- loadAdr::Address:E:"rocketSpeed"off:2 size:0 isFloat:False superAdj:0 i ...
 -- loadAdr:isValue:originIsValue:false
 -- isFloat: false
 fpushg 2 
 -- OI:invoke:rocketSpeed:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"rocketSpeed" 
 -- loadArgs:after:Qgen:"/ rocketSpeed" 
 -- before:pushSize: actualArg.super.ATd.OG.isUnitValueObj:true
 -- :actualArg.isCompositeValueObj:false isAssign: false
 -- actualArg:UnitOne?:rocketSpeed
 -- end:loadArgs:NonVirt:"/ rocketSpeed" 
 -- invoke:after:loadArgsOf:"/ rocketSpeed" :Address:E:"d"off:18 size:0 isF ...
 -- $ObjectInvocation_Binary:invoke: rec:"d" "/ rocketSpeed"
 -- >top:0 descNo:0 
 -- E.ATd: "/ " unique: false
 -- adr::Address:E:"d"off:18 size:0 isFloat:False superAdj:0 isUnique:False ...
 -- $pattern:invoke: "/ :  |    %basic 121 |    in V: var float |    out R: var f ..."
 -- bodyC:
 fdiv
 -- OI:invoke:/ rocketSpeed:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"/ rocketSpeed" 
 -- loadArgs:after:Qgen:":= d / rocketSpeed" 
 -- vAssign:fArg:"in V: var Value" 
 -- BINGO
 -- aaaa: in V: var Value
 -- end:loadArgs:NonVirt:":= d / rocketSpeed" 
 -- invoke:after:loadArgsOf:":= d / rocketSpeed" :Address:E:"t"off:12 size: ...
 -- $ObjectInvocation_Binary:invoke: rec:"t" ":= d / rocketSpeed"
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Address:E:"t"off:12 size:0 isFloat:False superAdj:0 isUnique:False ...
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "t" from: ":= d / rocketSpeed" 
 -- assign:dstDI :"t: var Time.Second" isUnitValueObj: true
 -- assign:arg: "d / rocketSpeed" lab:"ObjectCall" UnitValObj :false ptn: false
 --  float: true DataItem:false arg.super:d / rocketSpeed
 --  arg.super.ATd:"Invocation" "/ :  |    %basic 121 |    in V: var float |    o ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:true
 --  arg.super.ATd.label: "pattern" 
 -- assign:simple value: 
 -- :Address:E:"t"off:12 size:0 isFloat:False superAdj:0 isUnique:False isV ...
 -- store::Address:E:"t"off:12 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- isValue:true isAdr:false descNo: 0 
 -- isFloat: false
 fstoreg 12 address:storeg
 -- OI:invoke::= d / rocketSpeed:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= d / rocketSpeed" 
 -- genclass:Qgen:stmt:"" time: ".print" 
 -- $ObjectCall:gen: "" time: ".print"
 -- $Invocation:gen: descNo: 33 top: 1 "" time: ".print"
 -- needorigin:"" time: ".print" 
 -- needOrigin:E:"print"  E.ATd:"print:  |    @for 1 :to length  |    :do  |      ..." 
 -- computeAdr: "" time: ".print" 
 -- computeAdr:1 :rec:"none"  E:"" time: "" :Address:E:"none"off:0 size:0 i ...
 -- $String::pushThis: "" time: ""
 -- $String::loadOrigin: "" time: ""
 -- StringObj:loadOrigin:" time: "
 -- $String::getAdr: "" time: ""
 -- computeAdr:isFirst::Address:E:"" time: ""off:0 size:0 isFloat:False sup ...
 -- computeAdr:2 :rec:"" time: ""  E:"print" :Address:E:"" time: ""off:0 si ...
 -- E:notAssign:print
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "print"
 -- $pattern:getAdr: "print:  |    @for 1 :to length  |    :do  |       put(@get  ..."
 -- :Address:E:"" time: ""off:0 size:0 isFloat:False superAdj:0 isUnique:Fa ...
 -- ptn.ssUnitValueObj:false isFloat:false
 -- $String::loadArgs: "" time: ""
 -- $String::invoke: "" time: ""
 -- Pattern:markForCodeGen:+ :  |    in S: ref String |    out V: ref String |    ...
 pushText  time: 
 -- computeAdr:isLast:E: "print" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"" time: ""off:0 size:0 isFlo ...
 -- rec: "" time: "" E: "print" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "print"
 -- $pattern:loadArgs:E:"print":descNo:33:top:1 "print:  |    @for 1 :to leng ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"print" :Address:E:"" time: ""off:0 size:0 isFl ...
 -- $ObjectInvocation_Unary:invoke: rec:"" time: "" "print"
 -- >top:1 descNo:33 
 -- E.ATd: "print" unique: false
 -- adr::Address:E:"" time: ""off:0 size:0 isFloat:False superAdj:0 isUniqu ...
 -- $pattern:invoke: "print:  |    @for 1 :to length  |    :do  |       put(@get  ..."
 -- Pattern:invoke:descNo:33  top:1  rec:"" time: "" 
 -- ComputeVariantX
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- <>var
 -- rec:module or pattern:"print"  descno: 33  top: 1 "@for 1 :to length  | : ..." 
 -- ptn:invoke::isValObj:false:rtnValObj:false:"print:  |    @for 1 :to lengt ..." 
 -- rec=E:false:rec:"" time: "" 
 -- kuk:obj:rec.ATd:"String:  |    %OSDvisibility disguised |    %basic 5 |    %i ..." 
 invoke print 33 0 0
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:false"" time: "" 
 rpop
 -- OI:invoke:print:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"print" 
 -- genclass:Qgen:stmt:"putfloat(t)" 
 -- $ObjectCall:gen: "putfloat(t)"
 -- $Invocation:gen: descNo: 43 top: 1 "putfloat(t)"
 -- needorigin:"putfloat(t)" 
 -- needOrigin:E:"putfloat(t)"  E.ATd:"putFloat:  |    %basic 142 |    in X: va ..." 
 -- computeAdr: "putfloat(t)" 
 -- computeAdr:1 :rec:"none"  E:"putfloat(t)" :Address:E:"none"off:0 size:0 ...
 -- $ObjectInvocation_Function:pushThis: "putfloat(t)"
 -- $ObjectInvocation_Function:loadOrigin::on:2 "putfloat(t)"
 -- $ObjectInvocation_Function:getAdr::superAdj:0:on:2 "putfloat(t)"
 -- $pattern:getAdr: "putFloat:  |    %basic 142 |    in X: var Float |    out V: ..."
 -- :Address:E:"putfloat(t)"off:0 size:0 isFloat:False superAdj:0 isUnique: ...
 -- computeAdr:isFirst::Address:E:"putfloat(t)"off:0 size:0 isFloat:False s ...
 -- computeAdr:isLast:E: "putfloat(t)" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"putfloat(t)"off:0 size:0 isF ...
 -- rec: "putfloat(t)" E: "putfloat(t)" isValueAssign: false
 -- $ObjectInvocation_Function:loadArgs:staticOff:0 "putfloat(t)"
 -- $pattern:loadArgs:E:"putfloat(t)":descNo:43:top:1 "putFloat:  |    %basic ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"putfloat(t)" ActArg: "t" isValue: true
 -- loadArgs:not:*: formalArgOf:"putfloat(t)"  isCompositeValueObj:false
 -- $ObjectGenerator:gen:"t#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 "t ..."
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: false
 -- $Invocation:gen: "t"
 -- needorigin:"t" 
 -- needOrigin:E:"t"  E.ATd:"t: var Time.Second" 
 -- needOrigin:datItem:leave
 -- computeAdr: "t" 
 -- computeAdr:1 :rec:"none"  E:"t" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "t"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "t"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "t"
 -- $var:getAdr:,newOff:12,isValue:"True",A.isValue:"False" "t: var Time.Se ..."
 --  A::Address:E:"t"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...t ...
 -- value_prim:false
 -- Time.Second
 -- before:floatTest: %unit "s"
 -- computeAdr:isFirst::Address:E:"t"off:12 size:0 isFloat:False superAdj:0 ...
 -- computeAdr:isLast:E: "t" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"t"off:12 size:0 isFloat:Fals ...
 -- rec: "t" E: "t" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "t"
 -- $var:loadArgs: "t: var Time.Second"
 -- invoke:after:loadArgsOf:"t" :Address:E:"t"off:12 size:0 isFloat:False s ...
 -- $ObjectInvocation_Unary:invoke: rec:"t" "t"
 -- E.ATd: "t" unique: false
 -- adr::Address:E:"t"off:12 size:0 isFloat:False superAdj:0 isUnique:False ...
 -- $var:invoke: newOff:12 "t: var Time.Second"
 -- >LoadValue:isAdr:false,Size:2 ,rec:"t" ,E:"t" 
 -- isCompositeValueObj: false
 -- loadAdr::Address:E:"t"off:12 size:0 isFloat:False superAdj:0 isUnique:F ...
 -- loadAdr:isValue:originIsValue:false
 -- isFloat: false
 fpushg 12 
 -- OI:invoke:t:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"t" 
 -- loadArgs:after:Qgen:"putfloat(t)" 
 -- before:pushSize: actualArg.super.ATd.OG.isUnitValueObj:true
 -- :actualArg.isCompositeValueObj:false isAssign: false
 -- actualArg:UnitOne?:t
 -- end:loadArgs:NonVirt:"putfloat(t)" 
 -- invoke:after:loadArgsOf:"putfloat(t)" :Address:E:"putfloat(t)"off:0 siz ...
 -- $ObjectInvocation_Function:invoke: rec:"putfloat(t)" "putfloat(t)"
 -- >top:1 descNo:43 
 -- E.ATd: "putFloat" unique: false
 -- adr::Address:E:"putfloat(t)"off:0 size:0 isFloat:False superAdj:0 isUni ...
 -- $pattern:invoke: "putFloat:  |    %basic 142 |    in X: var Float |    out V: ..."
 -- Pattern:invoke:descNo:43  top:1  rec:"putfloat(t)" 
 -- ptn:invoke:primitive:putFloat
 %printf_prim 142
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:true"putfloat(t)" 
 vpop
 -- OI:invoke:putfloat(t):unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"putfloat(t)" 
 -- genclass:Qgen:stmt:"newline" 
 -- $ObjectCall:gen: "newline"
 -- $Invocation:gen: descNo: 81 top: 1 "newline"
 -- needorigin:"newline" 
 -- needOrigin:E:"newline"  E.ATd:"newline:  |    %globals |    put(10)" 
 -- LoadOrign:no:loadOrigin: "%globals | put(10)" 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "newline" E: "newline" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "newline"
 -- $pattern:loadArgs:E:"newline":descNo:81:top:1 "newline:  |    %globals |    ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"newline" 
 -- $ObjectInvocation_Unary:invoke: rec:"newline" "newline"
 -- >top:1 descNo:81 
 -- $pattern:invoke: "newline:  |    %globals |    put(10)"
 -- Pattern:invoke:descNo:81  top:1  rec:"newline" 
 -- ptn:invoke::isValObj:false:rtnValObj:false:"newline:  |    %globals |    pu ..." 
 -- rec=E:true:rec:"newline" 
 -- kuk:obj:rec.ATd:"newline:  |    %globals |    put(10)" 
 invoke newline 81 0 0
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:true"newline" 
 rpop
 -- OI:invoke:newline:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"newline" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:19 isIndexed:0  vTop:-15 vTopMax:0 rTop:24 rTopMax:24
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 83 :top:1 
 -- GenClass:demo :varNo = 1 
 -- GenClass:demo:true -> var.genDone

class demo 83 1 84
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $ModuleItem:gen: "--ArrayDemos"
 -- $ModuleItem:gen: "--Bank"
 -- $ModuleItem:gen: "--BasicValueSub"
 -- $ModuleItem:gen: "--BinTree"
 -- $ModuleItem:gen: "--Break"
 -- $ModuleItem:gen: "--CoArg"
 -- $ModuleItem:gen: "--ComplexEx"
 -- $ModuleItem:gen: "--ContainerEx"
 -- $ModuleItem:gen: "--FileDemo"
 -- $ModuleItem:gen: "--ForkJoinEx"
 -- $ModuleItem:gen: "--Formater"
 -- $ModuleItem:gen: "--KBprocess"
 -- $ModuleItem:gen: "--LibraEx"
 -- ModuleItem:gen LibraEx
 -- $ModuleItem:gen: "--MixedScheduling"
 -- $ModuleItem:gen: "--MonitorDemo"
 -- $ModuleItem:gen: "--NewArgEx"
 -- $ModuleItem:gen: "--NonBlockingIOex"
 -- $ModuleItem:gen: "--NullList"
 -- $ModuleItem:gen: "--PointEx"
 -- $ModuleItem:gen: "--SCPex"
 -- $ModuleItem:gen: "--SimpleEx"
 -- $ModuleItem:gen: "--SimpleThreadEx"
 -- $ModuleItem:gen: "--SocketEx"
 -- $ModuleItem:gen: "--Static"
 -- $ModuleItem:gen: "--TempEx"
 -- $ModuleItem:gen: "--ToyCar"
 -- $ModuleItem:gen: "--UnitEx"
 -- $ModuleItem:gen: "--Units"
 -- $ModuleItem:gen: "--ValueDemo"
 -- $ModuleItem:gen: "--comment"
 -- $obj:gen: "LibraEx: obj  |    %include Dimensions |    rocketSpeed: var Vel ..."
 -- $ObjectGenerator:gen:"LibraEx"singular! staticOff: 2 descNo: 82 top:1 " ..."
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 82  LibraEx
 invoke LibraEx 82 2 1
 rpop
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%include Associations" 
 -- $Property:gen: "%include Associations"
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 84 :top:1 
 -- GenClass:workspace :varNo = 1 
 -- GenClass:workspace:true -> var.genDone

class workspace 84 1 85
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $ModuleItem:gen: "--AccessEx"
 -- $ModuleItem:gen: "--ApplyPred"
 -- $ModuleItem:gen: "--ArduinoEx"
 -- $ModuleItem:gen: "--ArmLed"
 -- $ModuleItem:gen: "--ArmMultiCore"
 -- $ModuleItem:gen: "--CAStest"
 -- $ModuleItem:gen: "--CAStestCore"
 -- $ModuleItem:gen: "--ChemicalPlantSystem"
 -- $ModuleItem:gen: "--CppEx"
 -- $ModuleItem:gen: "--DumpObjEx"
 -- $ModuleItem:gen: "--ESP32Ex"
 -- $ModuleItem:gen: "--Errors"
 -- $ModuleItem:gen: "--ForkGC"
 -- $ModuleItem:gen: "--FuncVirtExVclass"
 -- $ModuleItem:gen: "--FunctionalVirtEx"
 -- $ModuleItem:gen: "--Generic"
 -- $ModuleItem:gen: "--GenericArray"
 -- $ModuleItem:gen: "--GenericList"
 -- $ModuleItem:gen: "--IndexEx"
 -- $ModuleItem:gen: "--Itest"
 -- $ModuleItem:gen: "--Line"
 -- $ModuleItem:gen: "--LockTest"
 -- $ModuleItem:gen: "--LockTestCore"
 -- $ModuleItem:gen: "--MVRsystem"
 -- $ModuleItem:gen: "--MapEx"
 -- $ModuleItem:gen: "--MiniVal"
 -- $ModuleItem:gen: "--NewKeyWord"
 -- $ModuleItem:gen: "--NewStorage"
 -- $ModuleItem:gen: "--NoneEx"
 -- $ModuleItem:gen: "--ObjectAndValues"
 -- $ModuleItem:gen: "--PTX"
 -- $ModuleItem:gen: "--PointReturn"
 -- $ModuleItem:gen: "--PointSys"
 -- $ModuleItem:gen: "--PtnName"
 -- $ModuleItem:gen: "--Qtst"
 -- $ModuleItem:gen: "--QuaValue"
 -- $ModuleItem:gen: "--Qual"
 -- $ModuleItem:gen: "--Recursive"
 -- $ModuleItem:gen: "--Restrictions"
 -- $ModuleItem:gen: "--SlideEx"
 -- $ModuleItem:gen: "--Small"
 -- $ModuleItem:gen: "--SmallVirtEx"
 -- $ModuleItem:gen: "--StringEx"
 -- $ModuleItem:gen: "--Sub1"
 -- $ModuleItem:gen: "--SubOfInt"
 -- $ModuleItem:gen: "--TST"
 -- $ModuleItem:gen: "--UnitLiterals"
 -- $ModuleItem:gen: "--UnitTest"
 -- $ModuleItem:gen: "--ValueArray"
 -- $ModuleItem:gen: "--ValueEx"
 -- $ModuleItem:gen: "--ValueItemEx"
 -- $ModuleItem:gen: "--ValueTypes"
 -- $ModuleItem:gen: "--VirtError"
 -- $ModuleItem:gen: "--VirtualEx"
 -- $ModuleItem:gen: "--Visibility"
 -- $ModuleItem:gen: "--comment"
 -- $ModuleItem:gen: "--demo"
 -- ModuleItem:gen demo
 -- $ModuleItem:gen: "--noglobtst"
 -- $ModuleItem:gen: "--qbetaCmp"
 -- $ModuleItem:gen: "--rangetst"
 -- $ModuleItem:gen: "--test"
 -- $ModuleItem:gen: "--testE"
 -- $ModuleItem:gen: "--testQ"
 -- $ModuleItem:gen: "--testT"
 -- $ModuleItem:gen: "--testU"
 -- $ModuleItem:gen: "--testW"
 -- $ModuleItem:gen: "--testX"
 -- $ModuleItem:gen: "--testY"
 -- $ModuleItem:gen: "--testZ"
 -- $ModuleItem:gen: "--vctest"
 -- $ModuleItem:gen: "--xKinds"
 -- $ModuleItem:gen: "--xtest"
 -- $obj:gen: "demo: obj  |    %include Associations |    --ArrayDemos |    --Ban ..."
 -- $ObjectGenerator:gen:"demo"singular! staticOff: 2 descNo: 83 top:1 "%in ..."
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 83  demo
 invoke demo 83 2 1
 rpop
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%include BETA, LIB, LIB.BasicIO" 
 -- $Property:gen: "%include BETA, LIB, LIB.BasicIO"
 -- genclass:Qgen:stmt:"%domain_boundary" 
 -- $Property:gen: "%domain_boundary"
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 85 :top:1 
 -- GenClass:BETAworld :varNo = 1 
 -- GenClass:BETAworld:true -> var.genDone

class BETAworld 85 1 0
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 pushThis 
 saveBETAworld
 mvStack 
 -- $ModuleItem:gen: "--BETA"
 -- ModuleItem:gen BETA
 -- $obj:gen: "BETA: obj  |    %OSDvisibility disguised |    %public |    univers ..."
 -- $ObjectGenerator:gen:"BETA"singular! staticOff: 2 descNo: 6 top:1 "%OSD ..."
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 6  BETA
 invoke BETA 6 2 1
 rpop
 -- $ModuleItem:gen: "--DK"
 -- $ModuleItem:gen: "--LIB"
 -- ModuleItem:gen LIB
 -- $obj:gen: "LIB: obj  |    %include BETA |    x_dummy_LIB: var integer |    -- ..."
 -- $ObjectGenerator:gen:"LIB"singular! staticOff: 3 descNo: 70 top:1 "%inc ..."
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 70  LIB
 invoke LIB 70 3 1
 rpop
 -- $ModuleItem:gen: "--no"
 -- $ModuleItem:gen: "--workspace"
 -- ModuleItem:gen workspace
 -- $obj:gen: "workspace: obj  |    %include BETA, LIB, LIB.BasicIO |    %domai ..."
 -- $ObjectGenerator:gen:"workspace"singular! staticOff: 4 descNo: 84 top:1 ...
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 84  workspace
 invoke workspace 84 4 1
 rpop
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%modules BETA, LIB, LIB.String" 
 -- $Property:gen: "%modules BETA, LIB, LIB.String"
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:4 isIndexed:0  vTop:0 vTopMax:0 rTop:1 rTopMax:1
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 87 :top:1 
 -- GenClass:do#S#87 :varNo = 1 
 -- GenClass:do#S#87:true -> var.genDone

class do#S#87 87 2 92
 -- Store itemArgs
 tstOriginIsNone 
 rstore 2 origin
 allocEventQ
 mvStack 
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"e := @get inx" 
 -- $ObjectCall:gen: "e := @get inx"
 -- $Invocation:gen: descNo: 4 top: 1 "e := @get inx"
 -- needorigin:"e := @get inx" 
 -- needOrigin:E:":= @get inx"  E.ATd:":= :  |    %basic 8 |    in V: var Value ..." 
 -- computeAdr: "e := @get inx" 
 -- computeAdr:1 :rec:"none"  E:"e" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "e"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:2 "e"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:2 
 -- goOrigin:do#S#87:encOG.IS.newOriginOff:2 :newOriginOff:2 
 rpushg 2 do#S#87:origin
 -- goOrigin:A:1 
 -- goOrigin:@for::to:do#S#92:encOG.IS.newOriginOff:4 :newOriginOff:4 
 rpushg 4 @for::to:do#S#92:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:2 "e"
 -- $var:getAdr:,newOff:2,isValue:"True",A.isValue:"False" "e: var integer" ...
 --  A::Address:E:"e"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...e ...
 -- value_prim:false
 -- integer
 -- before:floatTest: 
 -- computeAdr:isFirst::Address:E:"e"off:2 size:0 isFloat:False superAdj:0  ...
 -- computeAdr:2 :rec:"e"  E:":= @get inx" :Address:E:"e"off:2 size:0 isFlo ...
 -- computeAdr:isAssign:rec: "e"  E:":= @get inx" 
 -- :Address:E:"e"off:2 size:0 isFloat:False superAdj:0 isUnique:False isVa ...
 -- computeAdr:isLast:E: ":= @get inx" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"e"off:2 size:0 isFloat:False ...
 -- rec: "e" E: ":= @get inx" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:2 ":= @get inx"
 -- $pattern:loadArgs:E:":= @get inx":descNo:4:top:1 ":= :  |    %basic 8 |     ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= @get inx" ActArg: "@get inx" isValue: false
 -- $ObjectCall:gen: "@get inx"
 -- $Invocation:gen: descNo: 0 top: 0 "@get inx"
 -- needorigin:"@get inx" 
 -- needOrigin:E:"@get inx"  E.ATd:"@get:  |    %basic 117 |    in get: var int ..." 
 -- computeAdr: "@get inx" 
 -- computeAdr:1 :rec:"none"  E:"@get inx" :Address:E:"none"off:0 size:0 is ...
 -- $ObjectInvocation_KeyWord:pushThis: "@get inx"
 pushThis 
 -- $ObjectInvocation_KeyWord:loadOrigin::on:4 "@get inx"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:4 
 -- goOrigin:do#S#87:encOG.IS.newOriginOff:2 :newOriginOff:2 
 rpushg 2 do#S#87:origin
 -- goOrigin:A:3 
 -- goOrigin:@for::to:do#S#92:encOG.IS.newOriginOff:4 :newOriginOff:4 
 rpushg 4 @for::to:do#S#92:origin
 -- goOrigin:A:2 
 -- goOrigin:doplus:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 doplus:origin
 -- goOrigin:A:1 
 -- goOrigin:+:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 +:origin
 -- $ObjectInvocation_KeyWord:getAdr::superAdj:0:on:4 "@get inx"
 -- $pattern:getAdr: "@get:  |    %basic 117 |    in get: var integer |    out ch ..."
 -- :Address:E:"@get inx"off:0 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- computeAdr:isFirst::Address:E:"@get inx"off:0 size:0 isFloat:False supe ...
 -- computeAdr:isLast:E: "@get inx" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"@get inx"off:0 size:0 isFloa ...
 -- rec: "@get inx" E: "@get inx" isValueAssign: false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@get inx"
 -- $pattern:loadArgs:E:"@get inx":descNo:0:top:0 "@get:  |    %basic 117 |     ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"@get inx" ActArg: "inx" isValue: false
 -- loadArgs:not:*: formalArgOf:"@get inx"  isCompositeValueObj:false
 -- $ObjectCall:gen: "inx"
 -- $Invocation:gen: "inx"
 -- needorigin:"inx" 
 -- needOrigin:E:"inx"  E.ATd:"inx: var integer" 
 -- needOrigin:datItem:leave
 -- computeAdr: "inx" 
 -- computeAdr:1 :rec:"none"  E:"inx" :Address:E:"none"off:0 size:0 isFloat ...
 -- $ObjectInvocation_Unary:pushThis: "inx"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "inx"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:1 
 -- goOrigin:do#S#87:encOG.IS.newOriginOff:2 :newOriginOff:2 
 rpushg 2 do#S#87:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:1 "inx"
 -- $var:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "inx: var intege ..."
 --  A::Address:E:"inx"off:0 size:0 isFloat:False superAdj:0 isUnique:False ...  ...i ...
 -- value_prim:false
 -- integer
 -- before:floatTest: 
 -- computeAdr:isFirst::Address:E:"inx"off:3 size:0 isFloat:False superAdj: ...
 -- computeAdr:isLast:E: "inx" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"inx"off:3 size:0 isFloat:Fal ...
 -- rec: "inx" E: "inx" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "inx"
 -- $var:loadArgs: "inx: var integer"
 -- invoke:after:loadArgsOf:"inx" :Address:E:"inx"off:3 size:0 isFloat:Fals ...
 -- $ObjectInvocation_Unary:invoke: rec:"inx" "inx"
 -- E.ATd: "inx" unique: false
 -- adr::Address:E:"inx"off:3 size:0 isFloat:False superAdj:0 isUnique:Fals ...
 -- $var:invoke: newOff:3 "inx: var integer"
 -- load::Address:E:"inx"off:3 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- isFloat: false
 pushg 3 
 -- OI:invoke:inx:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"inx" 
 -- loadArgs:after:Qgen:"@get inx" 
 -- formalArg:isPtn:"in get: var integer" :isBasicVal:true:valueObj:true
 -- :actArg:"inx" :isBasicVal:true
 -- inxObjectCall
 -- end:loadArgs:NonVirt:"@get inx" 
 -- invoke:after:loadArgsOf:"@get inx" :Address:E:"@get inx"off:0 size:0 is ...
 -- $ObjectInvocation_KeyWord:invoke: rec:"@get inx" "@get inx"
 -- >top:0 descNo:0 
 -- E.ATd: "" unique: false
 -- adr::Address:E:"@get inx"off:0 size:0 isFloat:False superAdj:0 isUnique ...
 -- $pattern:invoke: "@get:  |    %basic 117 |    in get: var integer |    out ch ..."
 xpushg inx 1 0 1
 -- OI:invoke:@get inx:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"@get inx" 
 -- loadArgs:after:Qgen:":= @get inx" 
 -- vAssign:fArg:"in V: var Value" 
 -- BINGO
 -- aaaa: in V: var Value
 -- end:loadArgs:NonVirt:":= @get inx" 
 -- invoke:after:loadArgsOf:":= @get inx" :Address:E:"e"off:2 size:0 isFloa ...
 -- $ObjectInvocation_Binary:invoke: rec:"e" ":= @get inx"
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Address:E:"e"off:2 size:0 isFloat:False superAdj:0 isUnique:False  ...
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "e" from: ":= @get inx" 
 -- assign:dstDI :"e: var integer" isUnitValueObj: false
 -- assign:arg: "@get inx" lab:"ObjectCall" UnitValObj :false ptn: false
 --  float: false DataItem:false arg.super:@get inx
 --  arg.super.ATd:"Invocation" "@get:  |    %basic 117 |    in get: var intege ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "pattern" 
 -- assign:simple value: 
 -- :Address:E:"e"off:2 size:0 isFloat:False superAdj:0 isUnique:False isVa ...
 -- store::Address:E:"e"off:2 size:0 isFloat:False superAdj:0 isUnique:Fals ...
 -- isValue:true isAdr:false descNo: 0 
 -- isFloat: false
 storeg 2 address:storeg
 -- OI:invoke::= @get inx:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= @get inx" 
 -- genclass:Qgen:stmt:"T.@put e :at inx" 
 -- $ObjectCall:gen: "T.@put e :at inx"
 -- $Invocation:gen: descNo: 0 top: 0 "T.@put e :at inx"
 -- needorigin:"T.@put e :at inx" 
 -- needOrigin:E:"@put e :at inx"  E.ATd:"@put:  |    %basic 115 |    in put: r ..." 
 -- computeAdr: "T.@put e :at inx" 
 -- computeAdr:1 :rec:"none"  E:"T" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "T"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:2 "T"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:2 
 -- goOrigin:do#S#87:encOG.IS.newOriginOff:2 :newOriginOff:2 
 rpushg 2 do#S#87:origin
 -- goOrigin:A:1 
 -- goOrigin:@for::to:do#S#92:encOG.IS.newOriginOff:4 :newOriginOff:4 
 rpushg 4 @for::to:do#S#92:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:2 "T"
 -- $obj:getAdr:,newOff:4,isValue:"False",A.isValue:"False" "T: obj Indexed ..."
 --  A::Address:E:"T"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...T ...
 -- value_prim:false
 -- computeAdr:isFirst::Address:E:"none"off:4 size:0 isFloat:False superAdj ...
 -- computeAdr:2 :rec:"T"  E:"@put e :at inx" :Address:E:"none"off:4 size:0 ...
 -- E:notAssign:@put e :at inx
 -- $ObjectInvocation_KeyWord:getAdr::superAdj:0:on:0 "@put e :at inx"
 -- $pattern:getAdr: "@put:  |    %basic 115 |    in put: ref elm |    in at: var ..."
 -- :Address:E:"@put e :at inx"off:4 size:0 isFloat:False superAdj:0 isUniq ...
 -- ptn.ssUnitValueObj:false isFloat:false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "T"
 -- $obj:loadArgs: "T: obj Indexed(L + S.length,Integer)"
 -- $ObjectInvocation_Unary:invoke: rec:"T" "T"
 -- E.ATd: "" unique: false
 -- adr::Address:E:"@put e :at inx"off:4 size:0 isFloat:False superAdj:0 is ...
 -- $obj:invoke: newOff:4 "T: obj Indexed(L + S.length,Integer)"
 -- >Object:unique:false
 -- load::Address:E:"@put e :at inx"off:4 size:0 isFloat:False superAdj:0 i ...
 rpushg 4 
 -- OI:invoke:T:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "@put e :at inx" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"@put e :at inx"off:4 size:0  ...
 -- rec: "T" E: "@put e :at inx" isValueAssign: false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@put e :at inx"
 -- $pattern:loadArgs:E:"@put e :at inx":descNo:0:top:0 "@put:  |    %basic 1 ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"@put e :at inx" ActArg: "e" isValue: false
 -- loadArgs:not:*: formalArgOf:"@put e :at inx"  isCompositeValueObj:false
 -- $ObjectCall:gen: "e"
 -- $Invocation:gen: "e"
 -- needorigin:"e" 
 -- needOrigin:E:"e"  E.ATd:"e: var integer" 
 -- needOrigin:datItem:leave
 -- computeAdr: "e" 
 -- computeAdr:1 :rec:"none"  E:"e" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "e"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:2 "e"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:2 
 -- goOrigin:do#S#87:encOG.IS.newOriginOff:2 :newOriginOff:2 
 rpushg 2 do#S#87:origin
 -- goOrigin:A:1 
 -- goOrigin:@for::to:do#S#92:encOG.IS.newOriginOff:4 :newOriginOff:4 
 rpushg 4 @for::to:do#S#92:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:2 "e"
 -- $var:getAdr:,newOff:2,isValue:"True",A.isValue:"False" "e: var integer" ...
 --  A::Address:E:"e"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...e ...
 -- value_prim:false
 -- integer
 -- before:floatTest: 
 -- computeAdr:isFirst::Address:E:"e"off:2 size:0 isFloat:False superAdj:0  ...
 -- computeAdr:isLast:E: "e" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"e"off:2 size:0 isFloat:False ...
 -- rec: "e" E: "e" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "e"
 -- $var:loadArgs: "e: var integer"
 -- invoke:after:loadArgsOf:"e" :Address:E:"e"off:2 size:0 isFloat:False su ...
 -- $ObjectInvocation_Unary:invoke: rec:"e" "e"
 -- E.ATd: "e" unique: false
 -- adr::Address:E:"e"off:2 size:0 isFloat:False superAdj:0 isUnique:False  ...
 -- $var:invoke: newOff:2 "e: var integer"
 -- load::Address:E:"e"off:2 size:0 isFloat:False superAdj:0 isUnique:False ...
 -- isFloat: false
 pushg 2 
 -- OI:invoke:e:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"e" 
 -- loadArgs:after:Qgen:"@put e :at inx" 
 -- formalArg:isPtn:"in put: ref elm" :isBasicVal:false:valueObj:false
 -- :actArg:"e" :isBasicVal:true
 -- eObjectCall
 -- end:loadArgs:NonVirt:"@put e :at inx" 
 -- loadArgs:NonVirt:"@put e :at inx" ActArg: "inx" isValue: false
 -- loadArgs:not:*: formalArgOf:"@put e :at inx"  isCompositeValueObj:false
 -- $ObjectCall:gen: "inx"
 -- $Invocation:gen: "inx"
 -- needorigin:"inx" 
 -- needOrigin:E:"inx"  E.ATd:"inx: var integer" 
 -- needOrigin:datItem:leave
 -- computeAdr: "inx" 
 -- computeAdr:1 :rec:"none"  E:"inx" :Address:E:"none"off:0 size:0 isFloat ...
 -- $ObjectInvocation_Unary:pushThis: "inx"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "inx"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:1 
 -- goOrigin:do#S#87:encOG.IS.newOriginOff:2 :newOriginOff:2 
 rpushg 2 do#S#87:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:1 "inx"
 -- $var:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "inx: var intege ..."
 --  A::Address:E:"inx"off:0 size:0 isFloat:False superAdj:0 isUnique:False ...  ...i ...
 -- value_prim:false
 -- integer
 -- before:floatTest: 
 -- computeAdr:isFirst::Address:E:"inx"off:3 size:0 isFloat:False superAdj: ...
 -- computeAdr:isLast:E: "inx" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"inx"off:3 size:0 isFloat:Fal ...
 -- rec: "inx" E: "inx" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "inx"
 -- $var:loadArgs: "inx: var integer"
 -- invoke:after:loadArgsOf:"inx" :Address:E:"inx"off:3 size:0 isFloat:Fals ...
 -- $ObjectInvocation_Unary:invoke: rec:"inx" "inx"
 -- E.ATd: "inx" unique: false
 -- adr::Address:E:"inx"off:3 size:0 isFloat:False superAdj:0 isUnique:Fals ...
 -- $var:invoke: newOff:3 "inx: var integer"
 -- load::Address:E:"inx"off:3 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- isFloat: false
 pushg 3 
 -- OI:invoke:inx:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"inx" 
 -- loadArgs:after:Qgen:"@put e :at inx" 
 -- formalArg:isPtn:"in at: var integer" :isBasicVal:true:valueObj:true
 -- :actArg:"inx" :isBasicVal:true
 -- inxObjectCall
 -- end:loadArgs:NonVirt:"@put e :at inx" 
 -- invoke:after:loadArgsOf:"@put e :at inx" :Address:E:"@put e :at inx"off ...
 -- $ObjectInvocation_KeyWord:invoke: rec:"T" "@put e :at inx"
 -- >top:0 descNo:0 
 -- E.ATd: "" unique: false
 -- adr::Address:E:"@put e :at inx"off:4 size:0 isFloat:False superAdj:0 is ...
 -- $pattern:invoke: "@put:  |    %basic 115 |    in put: ref elm |    in at: var ..."
 -- Integer
 -- primitive
 xstoreg inx 1 0 1
1 inx
 -- OI:invoke:@put e :at inx:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"@put e :at inx" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:-2 vTopMax:1 rTop:6 rTopMax:6
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 92 :top:1 
 -- GenClass:@for::to:do#S#92 :varNo = 1 
 -- GenClass:@for::to:do#S#92:true -> var.genDone

class @for::to:do#S#92 92 4 91
 -- Store itemArgs
 tstOriginIsNone 
 rstore 4 origin
 -- super @for::to:do
 -- vdt:b
 --  1:86 2:0 3:0 4:0
 -- vdt:c:innerInx: 2  descNo: 92 
 -- vdtAdd: inx=2 descInx=92
 -- Super:sig none
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@for 1 :to L  | :do  |    e ..."
 -- $pattern:loadArgs:E:"@for 1 :to L  | :do  |    e := @get inx |    T.@put e :a ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"@for 1 :to L  | :do  |    e := @get inx |    T.@put e :at i ..." A ..."1 ..." i ...true
 -- loadArgs:not:*: formalArgOf:"@for 1 :to L  | :do  |    e := @get inx |    T.@ ..."   ...false
 -- $ObjectCall:gen: "1"
 -- $Invocation:gen: "1"
 -- needorigin:"1" 
 -- needOrigin:E:"1"  E.ATd:"integer: value |    %basic 1, 32 |    %globals |     ..." 
 -- LoadOrign:no:loadOrigin: "value |    %basic 1, 32 |    %globals |    %public |  ..." 
 -- IV:after:computeAdr:superAdj:4 
 -- rec: "1" E: "1" isValueAssign: false
 -- $ConstLiteral:loadArgs: "1"
 -- invoke:after:loadArgsOf:"1" 
 -- $ConstLiteral:invoke: "1"
 pushc 1
 -- invoke:after:E.invoke:"1" 
 -- loadArgs:after:Qgen:"@for 1 :to L  | :do  |    e := @get inx |    T.@put e :a ..." 
 -- formalArg:isPtn:"in for: var integer" :isBasicVal:true:valueObj:true
 -- :actArg:"1" :isBasicVal:true
 -- 1ObjectCall
 -- convDone:false
 -- end:loadArgs:NonVirt:"@for 1 :to L  | :do  |    e := @get inx |    T.@put e : ..." 
 -- loadArgs:NonVirt:"@for 1 :to L  | :do  |    e := @get inx |    T.@put e :at i ..." A ..."L ..." i ...false
 -- loadArgs:not:*: formalArgOf:"@for 1 :to L  | :do  |    e := @get inx |    T.@ ..."   ...false
 -- $ObjectCall:gen: "L"
 -- $Invocation:gen: "L"
 -- needorigin:"L" 
 -- needOrigin:E:"L"  E.ATd:"L: var integer" 
 -- needOrigin:datItem:leave
 -- computeAdr: "L" 
 -- computeAdr:1 :rec:"none"  E:"L" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "L"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "L"
 -- AdjustOrigin:originOff: 4
 rpushg 4 origin
 -- goOrigin:A:1 
 -- goOrigin:doplus:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 doplus:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:4:on:1 "L"
 -- $var:getAdr:,newOff:4,isValue:"True",A.isValue:"False" "L: var integer" ...
 --  A::Address:E:"L"off:0 size:0 isFloat:False superAdj:4 isUnique:False i ...  ...L ...
 -- value_prim:false
 -- integer
 -- before:floatTest: 
 -- computeAdr:isFirst::Address:E:"L"off:4 size:0 isFloat:False superAdj:0  ...
 -- computeAdr:isLast:E: "L" 
 -- IV:after:computeAdr:superAdj:4 :Address:E:"L"off:4 size:0 isFloat:False ...
 -- rec: "L" E: "L" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "L"
 -- $var:loadArgs: "L: var integer"
 -- invoke:after:loadArgsOf:"L" :Address:E:"L"off:4 size:0 isFloat:False su ...
 -- $ObjectInvocation_Unary:invoke: rec:"L" "L"
 -- E.ATd: "L" unique: false
 -- adr::Address:E:"L"off:4 size:0 isFloat:False superAdj:0 isUnique:False  ...
 -- $var:invoke: newOff:4 "L: var integer"
 -- load::Address:E:"L"off:4 size:0 isFloat:False superAdj:0 isUnique:False ...
 -- isFloat: false
 pushg 4 
 -- OI:invoke:L:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"L" 
 -- loadArgs:after:Qgen:"@for 1 :to L  | :do  |    e := @get inx |    T.@put e :a ..." 
 -- formalArg:isPtn:"in to: var integer" :isBasicVal:true:valueObj:true
 -- :actArg:"L" :isBasicVal:true
 -- LObjectCall
 -- end:loadArgs:NonVirt:"@for 1 :to L  | :do  |    e := @get inx |    T.@put e : ..." 
 toSuper 28
 rtnInner
DO:
 mvStack 
 L1:
 L2:
 rtnInner
 end OSDV:0 objSize:4 isIndexed:0  vTop:1 vTopMax:1 rTop:0 rTopMax:0
 -- Handle VB: "" E: "@for 1 :to L  | :do  |    e := @get inx |    T.@put e :at i ..." 
 -- Virtual
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 89 :top:1 
 -- GenClass:do#S#89 :varNo = 1 
 -- GenClass:do#S#89:true -> var.genDone

class do#S#89 89 2 93
 -- Store itemArgs
 tstOriginIsNone 
 rstore 2 origin
 allocEventQ
 mvStack 
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"e := S.@get inx" 
 -- $ObjectCall:gen: "e := S.@get inx"
 -- $Invocation:gen: descNo: 4 top: 1 "e := S.@get inx"
 -- needorigin:"e := S.@get inx" 
 -- needOrigin:E:":= S.@get inx"  E.ATd:":= :  |    %basic 8 |    in V: var Val ..." 
 -- computeAdr: "e := S.@get inx" 
 -- computeAdr:1 :rec:"none"  E:"e" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "e"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:2 "e"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:2 
 -- goOrigin:do#S#89:encOG.IS.newOriginOff:2 :newOriginOff:2 
 rpushg 2 do#S#89:origin
 -- goOrigin:A:1 
 -- goOrigin:@for::to:do#S#93:encOG.IS.newOriginOff:4 :newOriginOff:4 
 rpushg 4 @for::to:do#S#93:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:2 "e"
 -- $var:getAdr:,newOff:2,isValue:"True",A.isValue:"False" "e: var integer" ...
 --  A::Address:E:"e"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...e ...
 -- value_prim:false
 -- integer
 -- before:floatTest: 
 -- computeAdr:isFirst::Address:E:"e"off:2 size:0 isFloat:False superAdj:0  ...
 -- computeAdr:2 :rec:"e"  E:":= S.@get inx" :Address:E:"e"off:2 size:0 isF ...
 -- computeAdr:isAssign:rec: "e"  E:":= S.@get inx" 
 -- :Address:E:"e"off:2 size:0 isFloat:False superAdj:0 isUnique:False isVa ...
 -- computeAdr:isLast:E: ":= S.@get inx" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"e"off:2 size:0 isFloat:False ...
 -- rec: "e" E: ":= S.@get inx" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:2 ":= S.@get inx"
 -- $pattern:loadArgs:E:":= S.@get inx":descNo:4:top:1 ":= :  |    %basic 8 |   ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= S.@get inx" ActArg: "S.@get inx" isValue: false
 -- $ObjectCall:gen: "S.@get inx"
 -- $Invocation:gen: descNo: 0 top: 0 "S.@get inx"
 -- needorigin:"S.@get inx" 
 -- needOrigin:E:"@get inx"  E.ATd:"@get:  |    %basic 117 |    in get: var int ..." 
 -- computeAdr: "S.@get inx" 
 -- computeAdr:1 :rec:"none"  E:"S" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "S"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:3 "S"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:3 
 -- goOrigin:do#S#89:encOG.IS.newOriginOff:2 :newOriginOff:2 
 rpushg 2 do#S#89:origin
 -- goOrigin:A:2 
 -- goOrigin:@for::to:do#S#93:encOG.IS.newOriginOff:4 :newOriginOff:4 
 rpushg 4 @for::to:do#S#93:origin
 -- goOrigin:A:1 
 -- goOrigin:doplus:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 doplus:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:3 "S"
 -- $ref:getAdr:,newOff:2,isValue:"False",A.isValue:"False" "in S: ref Stri ..."
 --  A::Address:E:"S"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...i ...
 -- value_prim:false
 -- computeAdr:isFirst::Address:E:"none"off:2 size:0 isFloat:False superAdj ...
 -- computeAdr:2 :rec:"S"  E:"@get inx" :Address:E:"none"off:2 size:0 isFlo ...
 -- E:notAssign:@get inx
 -- $ObjectInvocation_KeyWord:getAdr::superAdj:0:on:0 "@get inx"
 -- $pattern:getAdr: "@get:  |    %basic 117 |    in get: var integer |    out ch ..."
 -- :Address:E:"@get inx"off:2 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- ptn.ssUnitValueObj:false isFloat:false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "S"
 -- $ref:loadArgs: "in S: ref String"
 -- $ObjectInvocation_Unary:invoke: rec:"S" "S"
 -- E.ATd: "" unique: false
 -- adr::Address:E:"@get inx"off:2 size:0 isFloat:False superAdj:0 isUnique ...
 -- $ref:invoke: newOff:2 "in S: ref String"
 -- >Object:unique:false
 -- load::Address:E:"@get inx"off:2 size:0 isFloat:False superAdj:0 isUniqu ...
 rpushg 2 
 -- OI:invoke:S:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "@get inx" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"@get inx"off:2 size:0 isFloa ...
 -- rec: "S" E: "@get inx" isValueAssign: false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@get inx"
 -- $pattern:loadArgs:E:"@get inx":descNo:0:top:0 "@get:  |    %basic 117 |     ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"@get inx" ActArg: "inx" isValue: false
 -- loadArgs:not:*: formalArgOf:"@get inx"  isCompositeValueObj:false
 -- $ObjectCall:gen: "inx"
 -- $Invocation:gen: "inx"
 -- needorigin:"inx" 
 -- needOrigin:E:"inx"  E.ATd:"inx: var integer" 
 -- needOrigin:datItem:leave
 -- computeAdr: "inx" 
 -- computeAdr:1 :rec:"none"  E:"inx" :Address:E:"none"off:0 size:0 isFloat ...
 -- $ObjectInvocation_Unary:pushThis: "inx"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "inx"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:1 
 -- goOrigin:do#S#89:encOG.IS.newOriginOff:2 :newOriginOff:2 
 rpushg 2 do#S#89:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:1 "inx"
 -- $var:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "inx: var intege ..."
 --  A::Address:E:"inx"off:0 size:0 isFloat:False superAdj:0 isUnique:False ...  ...i ...
 -- value_prim:false
 -- integer
 -- before:floatTest: 
 -- computeAdr:isFirst::Address:E:"inx"off:3 size:0 isFloat:False superAdj: ...
 -- computeAdr:isLast:E: "inx" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"inx"off:3 size:0 isFloat:Fal ...
 -- rec: "inx" E: "inx" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "inx"
 -- $var:loadArgs: "inx: var integer"
 -- invoke:after:loadArgsOf:"inx" :Address:E:"inx"off:3 size:0 isFloat:Fals ...
 -- $ObjectInvocation_Unary:invoke: rec:"inx" "inx"
 -- E.ATd: "inx" unique: false
 -- adr::Address:E:"inx"off:3 size:0 isFloat:False superAdj:0 isUnique:Fals ...
 -- $var:invoke: newOff:3 "inx: var integer"
 -- load::Address:E:"inx"off:3 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- isFloat: false
 pushg 3 
 -- OI:invoke:inx:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"inx" 
 -- loadArgs:after:Qgen:"@get inx" 
 -- formalArg:isPtn:"in get: var integer" :isBasicVal:true:valueObj:true
 -- :actArg:"inx" :isBasicVal:true
 -- inxObjectCall
 -- end:loadArgs:NonVirt:"@get inx" 
 -- invoke:after:loadArgsOf:"@get inx" :Address:E:"@get inx"off:2 size:0 is ...
 -- $ObjectInvocation_KeyWord:invoke: rec:"S" "@get inx"
 -- >top:0 descNo:0 
 -- E.ATd: "" unique: false
 -- adr::Address:E:"@get inx"off:2 size:0 isFloat:False superAdj:0 isUnique ...
 -- $pattern:invoke: "@get:  |    %basic 117 |    in get: var integer |    out ch ..."
 xpushg inx 1 0 1
 -- OI:invoke:@get inx:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"@get inx" 
 -- loadArgs:after:Qgen:":= S.@get inx" 
 -- vAssign:fArg:"in V: var Value" 
 -- BINGO
 -- aaaa: in V: var Value
 -- end:loadArgs:NonVirt:":= S.@get inx" 
 -- invoke:after:loadArgsOf:":= S.@get inx" :Address:E:"e"off:2 size:0 isFl ...
 -- $ObjectInvocation_Binary:invoke: rec:"e" ":= S.@get inx"
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Address:E:"e"off:2 size:0 isFloat:False superAdj:0 isUnique:False  ...
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "e" from: ":= S.@get inx" 
 -- assign:dstDI :"e: var integer" isUnitValueObj: false
 -- assign:arg: "S.@get inx" lab:"ObjectCall" UnitValObj :false ptn: false
 --  float: false DataItem:false arg.super:S.@get inx
 --  arg.super.ATd:"Invocation" "@get:  |    %basic 117 |    in get: var intege ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "pattern" 
 -- assign:simple value: 
 -- :Address:E:"e"off:2 size:0 isFloat:False superAdj:0 isUnique:False isVa ...
 -- store::Address:E:"e"off:2 size:0 isFloat:False superAdj:0 isUnique:Fals ...
 -- isValue:true isAdr:false descNo: 0 
 -- isFloat: false
 storeg 2 address:storeg
 -- OI:invoke::= S.@get inx:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= S.@get inx" 
 -- genclass:Qgen:stmt:"i := L + inx" 
 -- $ObjectCall:gen: "i := L + inx"
 -- $Invocation:gen: descNo: 4 top: 1 "i := L + inx"
 -- needorigin:"i := L + inx" 
 -- needOrigin:E:":= L + inx"  E.ATd:":= :  |    %basic 8 |    in V: var Value" 
 -- computeAdr: "i := L + inx" 
 -- computeAdr:1 :rec:"none"  E:"i" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "i"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:2 "i"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:2 
 -- goOrigin:do#S#89:encOG.IS.newOriginOff:2 :newOriginOff:2 
 rpushg 2 do#S#89:origin
 -- goOrigin:A:1 
 -- goOrigin:@for::to:do#S#93:encOG.IS.newOriginOff:4 :newOriginOff:4 
 rpushg 4 @for::to:do#S#93:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:2 "i"
 -- $var:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "i: var integer" ...
 --  A::Address:E:"i"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...i ...
 -- value_prim:false
 -- integer
 -- before:floatTest: 
 -- computeAdr:isFirst::Address:E:"i"off:3 size:0 isFloat:False superAdj:0  ...
 -- computeAdr:2 :rec:"i"  E:":= L + inx" :Address:E:"i"off:3 size:0 isFloa ...
 -- computeAdr:isAssign:rec: "i"  E:":= L + inx" 
 -- :Address:E:"i"off:3 size:0 isFloat:False superAdj:0 isUnique:False isVa ...
 -- computeAdr:isLast:E: ":= L + inx" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"i"off:3 size:0 isFloat:False ...
 -- rec: "i" E: ":= L + inx" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:3 ":= L + inx"
 -- $pattern:loadArgs:E:":= L + inx":descNo:4:top:1 ":= :  |    %basic 8 |    i ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= L + inx" ActArg: "L + inx" isValue: false
 -- $ObjectCall:gen: "L + inx"
 -- $Invocation:gen: descNo: 0 top: 0 "L + inx"
 -- needorigin:"L + inx" 
 -- needOrigin:E:"+ inx"  E.ATd:"+ :  |    %basic 61 |    in V: var integer |     ..." 
 -- computeAdr: "L + inx" 
 -- computeAdr:1 :rec:"none"  E:"L" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "L"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:3 "L"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:3 
 -- goOrigin:do#S#89:encOG.IS.newOriginOff:2 :newOriginOff:2 
 rpushg 2 do#S#89:origin
 -- goOrigin:A:2 
 -- goOrigin:@for::to:do#S#93:encOG.IS.newOriginOff:4 :newOriginOff:4 
 rpushg 4 @for::to:do#S#93:origin
 -- goOrigin:A:1 
 -- goOrigin:doplus:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 doplus:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:3 "L"
 -- $var:getAdr:,newOff:4,isValue:"True",A.isValue:"False" "L: var integer" ...
 --  A::Address:E:"L"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...L ...
 -- value_prim:false
 -- integer
 -- before:floatTest: 
 -- computeAdr:isFirst::Address:E:"L"off:4 size:0 isFloat:False superAdj:0  ...
 -- computeAdr:2 :rec:"L"  E:"+ inx" :Address:E:"L"off:4 size:0 isFloat:Fal ...
 -- E:notAssign:+ inx
 -- $ObjectInvocation_Binary:getAdr::superAdj:0:on:0 "+ inx"
 -- $pattern:getAdr: "+ :  |    %basic 61 |    in V: var integer |    out R: var  ..."
 -- :Address:E:"L"off:4 size:0 isFloat:False superAdj:0 isUnique:False isVa ...
 -- ptn.ssUnitValueObj:false isFloat:false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "L"
 -- $var:loadArgs: "L: var integer"
 -- $ObjectInvocation_Unary:invoke: rec:"L" "L"
 -- E.ATd: "+  | --%basic 61]] | " unique: false
 -- adr::Address:E:"L"off:4 size:0 isFloat:False superAdj:0 isUnique:False  ...
 -- $var:invoke: newOff:4 "L: var integer"
 -- load::Address:E:"L"off:4 size:0 isFloat:False superAdj:0 isUnique:False ...
 -- isFloat: false
 pushg 4 
 -- OI:invoke:L:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "+ inx" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"L"off:4 size:0 isFloat:False ...
 -- rec: "L" E: "+ inx" isValueAssign: false
 -- $ObjectInvocation_Binary:loadArgs:staticOff:0 "+ inx"
 -- $pattern:loadArgs:E:"+ inx":descNo:0:top:0 "+ :  |    %basic 61 |    in V:  ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"+ inx" ActArg: "inx" isValue: false
 -- loadArgs:not:*: formalArgOf:"+ inx"  isCompositeValueObj:false
 -- $ObjectCall:gen: "inx"
 -- $Invocation:gen: "inx"
 -- needorigin:"inx" 
 -- needOrigin:E:"inx"  E.ATd:"inx: var integer" 
 -- needOrigin:datItem:leave
 -- computeAdr: "inx" 
 -- computeAdr:1 :rec:"none"  E:"inx" :Address:E:"none"off:0 size:0 isFloat ...
 -- $ObjectInvocation_Unary:pushThis: "inx"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "inx"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:1 
 -- goOrigin:do#S#89:encOG.IS.newOriginOff:2 :newOriginOff:2 
 rpushg 2 do#S#89:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:1 "inx"
 -- $var:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "inx: var intege ..."
 --  A::Address:E:"inx"off:0 size:0 isFloat:False superAdj:0 isUnique:False ...  ...i ...
 -- value_prim:false
 -- integer
 -- before:floatTest: 
 -- computeAdr:isFirst::Address:E:"inx"off:3 size:0 isFloat:False superAdj: ...
 -- computeAdr:isLast:E: "inx" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"inx"off:3 size:0 isFloat:Fal ...
 -- rec: "inx" E: "inx" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "inx"
 -- $var:loadArgs: "inx: var integer"
 -- invoke:after:loadArgsOf:"inx" :Address:E:"inx"off:3 size:0 isFloat:Fals ...
 -- $ObjectInvocation_Unary:invoke: rec:"inx" "inx"
 -- E.ATd: "inx" unique: false
 -- adr::Address:E:"inx"off:3 size:0 isFloat:False superAdj:0 isUnique:Fals ...
 -- $var:invoke: newOff:3 "inx: var integer"
 -- load::Address:E:"inx"off:3 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- isFloat: false
 pushg 3 
 -- OI:invoke:inx:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"inx" 
 -- loadArgs:after:Qgen:"+ inx" 
 -- formalArg:isPtn:"in V: var integer" :isBasicVal:true:valueObj:true
 -- :actArg:"inx" :isBasicVal:true
 -- inxObjectCall
 -- end:loadArgs:NonVirt:"+ inx" 
 -- invoke:after:loadArgsOf:"+ inx" :Address:E:"L"off:4 size:0 isFloat:Fals ...
 -- $ObjectInvocation_Binary:invoke: rec:"L" "+ inx"
 -- >top:0 descNo:0 
 -- E.ATd: "+  | --%basic 61]] | " unique: false
 -- adr::Address:E:"L"off:4 size:0 isFloat:False superAdj:0 isUnique:False  ...
 -- $pattern:invoke: "+ :  |    %basic 61 |    in V: var integer |    out R: var  ..."
 -- bodyC:
 plus
 -- OI:invoke:+ inx:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"+ inx" 
 -- loadArgs:after:Qgen:":= L + inx" 
 -- vAssign:fArg:"in V: var Value" 
 -- BINGO
 -- aaaa: in V: var Value
 -- end:loadArgs:NonVirt:":= L + inx" 
 -- invoke:after:loadArgsOf:":= L + inx" :Address:E:"i"off:3 size:0 isFloat ...
 -- $ObjectInvocation_Binary:invoke: rec:"i" ":= L + inx"
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Address:E:"i"off:3 size:0 isFloat:False superAdj:0 isUnique:False  ...
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "i" from: ":= L + inx" 
 -- assign:dstDI :"i: var integer" isUnitValueObj: false
 -- assign:arg: "L + inx" lab:"ObjectCall" UnitValObj :false ptn: false
 --  float: false DataItem:false arg.super:L + inx
 --  arg.super.ATd:"Invocation" "+ :  |    %basic 61 |    in V: var integer |     ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "pattern" 
 -- assign:simple value: 
 -- :Address:E:"i"off:3 size:0 isFloat:False superAdj:0 isUnique:False isVa ...
 -- store::Address:E:"i"off:3 size:0 isFloat:False superAdj:0 isUnique:Fals ...
 -- isValue:true isAdr:false descNo: 0 
 -- isFloat: false
 storeg 3 address:storeg
 -- OI:invoke::= L + inx:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= L + inx" 
 -- genclass:Qgen:stmt:"T.@put e :at i" 
 -- $ObjectCall:gen: "T.@put e :at i"
 -- $Invocation:gen: descNo: 0 top: 0 "T.@put e :at i"
 -- needorigin:"T.@put e :at i" 
 -- needOrigin:E:"@put e :at i"  E.ATd:"@put:  |    %basic 115 |    in put: ref ..." 
 -- computeAdr: "T.@put e :at i" 
 -- computeAdr:1 :rec:"none"  E:"T" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "T"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:2 "T"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:2 
 -- goOrigin:do#S#89:encOG.IS.newOriginOff:2 :newOriginOff:2 
 rpushg 2 do#S#89:origin
 -- goOrigin:A:1 
 -- goOrigin:@for::to:do#S#93:encOG.IS.newOriginOff:4 :newOriginOff:4 
 rpushg 4 @for::to:do#S#93:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:2 "T"
 -- $obj:getAdr:,newOff:4,isValue:"False",A.isValue:"False" "T: obj Indexed ..."
 --  A::Address:E:"T"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...T ...
 -- value_prim:false
 -- computeAdr:isFirst::Address:E:"none"off:4 size:0 isFloat:False superAdj ...
 -- computeAdr:2 :rec:"T"  E:"@put e :at i" :Address:E:"none"off:4 size:0 i ...
 -- E:notAssign:@put e :at i
 -- $ObjectInvocation_KeyWord:getAdr::superAdj:0:on:0 "@put e :at i"
 -- $pattern:getAdr: "@put:  |    %basic 115 |    in put: ref elm |    in at: var ..."
 -- :Address:E:"@put e :at i"off:4 size:0 isFloat:False superAdj:0 isUnique ...
 -- ptn.ssUnitValueObj:false isFloat:false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "T"
 -- $obj:loadArgs: "T: obj Indexed(L + S.length,Integer)"
 -- $ObjectInvocation_Unary:invoke: rec:"T" "T"
 -- E.ATd: "" unique: false
 -- adr::Address:E:"@put e :at i"off:4 size:0 isFloat:False superAdj:0 isUn ...
 -- $obj:invoke: newOff:4 "T: obj Indexed(L + S.length,Integer)"
 -- >Object:unique:false
 -- load::Address:E:"@put e :at i"off:4 size:0 isFloat:False superAdj:0 isU ...
 rpushg 4 
 -- OI:invoke:T:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "@put e :at i" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"@put e :at i"off:4 size:0 is ...
 -- rec: "T" E: "@put e :at i" isValueAssign: false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@put e :at i"
 -- $pattern:loadArgs:E:"@put e :at i":descNo:0:top:0 "@put:  |    %basic 115 ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"@put e :at i" ActArg: "e" isValue: false
 -- loadArgs:not:*: formalArgOf:"@put e :at i"  isCompositeValueObj:false
 -- $ObjectCall:gen: "e"
 -- $Invocation:gen: "e"
 -- needorigin:"e" 
 -- needOrigin:E:"e"  E.ATd:"e: var integer" 
 -- needOrigin:datItem:leave
 -- computeAdr: "e" 
 -- computeAdr:1 :rec:"none"  E:"e" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "e"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:2 "e"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:2 
 -- goOrigin:do#S#89:encOG.IS.newOriginOff:2 :newOriginOff:2 
 rpushg 2 do#S#89:origin
 -- goOrigin:A:1 
 -- goOrigin:@for::to:do#S#93:encOG.IS.newOriginOff:4 :newOriginOff:4 
 rpushg 4 @for::to:do#S#93:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:2 "e"
 -- $var:getAdr:,newOff:2,isValue:"True",A.isValue:"False" "e: var integer" ...
 --  A::Address:E:"e"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...e ...
 -- value_prim:false
 -- integer
 -- before:floatTest: 
 -- computeAdr:isFirst::Address:E:"e"off:2 size:0 isFloat:False superAdj:0  ...
 -- computeAdr:isLast:E: "e" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"e"off:2 size:0 isFloat:False ...
 -- rec: "e" E: "e" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "e"
 -- $var:loadArgs: "e: var integer"
 -- invoke:after:loadArgsOf:"e" :Address:E:"e"off:2 size:0 isFloat:False su ...
 -- $ObjectInvocation_Unary:invoke: rec:"e" "e"
 -- E.ATd: "e" unique: false
 -- adr::Address:E:"e"off:2 size:0 isFloat:False superAdj:0 isUnique:False  ...
 -- $var:invoke: newOff:2 "e: var integer"
 -- load::Address:E:"e"off:2 size:0 isFloat:False superAdj:0 isUnique:False ...
 -- isFloat: false
 pushg 2 
 -- OI:invoke:e:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"e" 
 -- loadArgs:after:Qgen:"@put e :at i" 
 -- formalArg:isPtn:"in put: ref elm" :isBasicVal:false:valueObj:false
 -- :actArg:"e" :isBasicVal:true
 -- eObjectCall
 -- end:loadArgs:NonVirt:"@put e :at i" 
 -- loadArgs:NonVirt:"@put e :at i" ActArg: "i" isValue: false
 -- loadArgs:not:*: formalArgOf:"@put e :at i"  isCompositeValueObj:false
 -- $ObjectCall:gen: "i"
 -- $Invocation:gen: "i"
 -- needorigin:"i" 
 -- needOrigin:E:"i"  E.ATd:"i: var integer" 
 -- needOrigin:datItem:leave
 -- computeAdr: "i" 
 -- computeAdr:1 :rec:"none"  E:"i" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "i"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:2 "i"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:2 
 -- goOrigin:do#S#89:encOG.IS.newOriginOff:2 :newOriginOff:2 
 rpushg 2 do#S#89:origin
 -- goOrigin:A:1 
 -- goOrigin:@for::to:do#S#93:encOG.IS.newOriginOff:4 :newOriginOff:4 
 rpushg 4 @for::to:do#S#93:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:2 "i"
 -- $var:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "i: var integer" ...
 --  A::Address:E:"i"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...i ...
 -- value_prim:false
 -- integer
 -- before:floatTest: 
 -- computeAdr:isFirst::Address:E:"i"off:3 size:0 isFloat:False superAdj:0  ...
 -- computeAdr:isLast:E: "i" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"i"off:3 size:0 isFloat:False ...
 -- rec: "i" E: "i" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "i"
 -- $var:loadArgs: "i: var integer"
 -- invoke:after:loadArgsOf:"i" :Address:E:"i"off:3 size:0 isFloat:False su ...
 -- $ObjectInvocation_Unary:invoke: rec:"i" "i"
 -- E.ATd: "i" unique: false
 -- adr::Address:E:"i"off:3 size:0 isFloat:False superAdj:0 isUnique:False  ...
 -- $var:invoke: newOff:3 "i: var integer"
 -- load::Address:E:"i"off:3 size:0 isFloat:False superAdj:0 isUnique:False ...
 -- isFloat: false
 pushg 3 
 -- OI:invoke:i:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"i" 
 -- loadArgs:after:Qgen:"@put e :at i" 
 -- formalArg:isPtn:"in at: var integer" :isBasicVal:true:valueObj:true
 -- :actArg:"i" :isBasicVal:true
 -- iObjectCall
 -- end:loadArgs:NonVirt:"@put e :at i" 
 -- invoke:after:loadArgsOf:"@put e :at i" :Address:E:"@put e :at i"off:4 s ...
 -- $ObjectInvocation_KeyWord:invoke: rec:"T" "@put e :at i"
 -- >top:0 descNo:0 
 -- E.ATd: "" unique: false
 -- adr::Address:E:"@put e :at i"off:4 size:0 isFloat:False superAdj:0 isUn ...
 -- $pattern:invoke: "@put:  |    %basic 115 |    in put: ref elm |    in at: var ..."
 -- Integer
 -- primitive
 xstoreg inx 1 0 1
1 inx
 -- OI:invoke:@put e :at i:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"@put e :at i" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:-4 vTopMax:1 rTop:9 rTopMax:9
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 93 :top:1 
 -- GenClass:@for::to:do#S#93 :varNo = 1 
 -- GenClass:@for::to:do#S#93:true -> var.genDone

class @for::to:do#S#93 93 4 91
 -- Store itemArgs
 tstOriginIsNone 
 rstore 4 origin
 -- super @for::to:do
 -- vdt:b
 --  1:86 2:0 3:0 4:0
 -- vdt:c:innerInx: 2  descNo: 93 
 -- vdtAdd: inx=2 descInx=93
 -- Super:sig none
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@for 1 :to S.length  | :d ..."
 -- $pattern:loadArgs:E:"@for 1 :to S.length  | :do  |    e := S.@get inx |    i  ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"@for 1 :to S.length  | :do  |    e := S.@get inx |    i :=  ..." A ..."1 ..." i ...true
 -- loadArgs:not:*: formalArgOf:"@for 1 :to S.length  | :do  |    e := S.@get i ..."   ...false
 -- $ObjectCall:gen: "1"
 -- $Invocation:gen: "1"
 -- needorigin:"1" 
 -- needOrigin:E:"1"  E.ATd:"integer: value |    %basic 1, 32 |    %globals |     ..." 
 -- LoadOrign:no:loadOrigin: "value |    %basic 1, 32 |    %globals |    %public |  ..." 
 -- IV:after:computeAdr:superAdj:4 
 -- rec: "1" E: "1" isValueAssign: false
 -- $ConstLiteral:loadArgs: "1"
 -- invoke:after:loadArgsOf:"1" 
 -- $ConstLiteral:invoke: "1"
 pushc 1
 -- invoke:after:E.invoke:"1" 
 -- loadArgs:after:Qgen:"@for 1 :to S.length  | :do  |    e := S.@get inx |    i  ..." 
 -- formalArg:isPtn:"in for: var integer" :isBasicVal:true:valueObj:true
 -- :actArg:"1" :isBasicVal:true
 -- 1ObjectCall
 -- convDone:false
 -- end:loadArgs:NonVirt:"@for 1 :to S.length  | :do  |    e := S.@get inx |    i ..." 
 -- loadArgs:NonVirt:"@for 1 :to S.length  | :do  |    e := S.@get inx |    i :=  ..." A ..."S ..." i ...false
 -- loadArgs:not:*: formalArgOf:"@for 1 :to S.length  | :do  |    e := S.@get i ..."   ...false
 -- $ObjectCall:gen: "S.length"
 -- $Invocation:gen: descNo: 29 top: 1 "S.length"
 -- needorigin:"S.length" 
 -- needOrigin:E:"length"  E.ATd:"length:  |    out V: var integer |    V := @g ..." 
 -- computeAdr: "S.length" 
 -- computeAdr:1 :rec:"none"  E:"S" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "S"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "S"
 -- AdjustOrigin:originOff: 4
 rpushg 4 origin
 -- goOrigin:A:1 
 -- goOrigin:doplus:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 doplus:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:4:on:1 "S"
 -- $ref:getAdr:,newOff:2,isValue:"False",A.isValue:"False" "in S: ref Stri ..."
 --  A::Address:E:"S"off:0 size:0 isFloat:False superAdj:4 isUnique:False i ...  ...i ...
 -- value_prim:false
 -- computeAdr:isFirst::Address:E:"none"off:2 size:0 isFloat:False superAdj ...
 -- computeAdr:2 :rec:"S"  E:"length" :Address:E:"none"off:2 size:0 isFloat ...
 -- E:notAssign:length
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "length"
 -- $pattern:getAdr: "length:  |    out V: var integer |    V := @get 0"
 -- :Address:E:"length"off:2 size:0 isFloat:False superAdj:0 isUnique:False ...
 -- ptn.ssUnitValueObj:false isFloat:false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "S"
 -- $ref:loadArgs: "in S: ref String"
 -- $ObjectInvocation_Unary:invoke: rec:"S" "S"
 -- E.ATd: "length" unique: false
 -- adr::Address:E:"length"off:2 size:0 isFloat:False superAdj:0 isUnique:F ...
 -- $ref:invoke: newOff:2 "in S: ref String"
 -- >Object:unique:false
 -- loadAdr::Address:E:"length"off:2 size:0 isFloat:False superAdj:0 isUniq ...
 rpushg 2 
 -- OI:invoke:S:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "length" 
 -- IV:after:computeAdr:superAdj:4 :Address:E:"length"off:2 size:0 isFloat: ...
 -- rec: "S" E: "length" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "length"
 -- $pattern:loadArgs:E:"length":descNo:29:top:1 "length:  |    out V: var in ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"length" :Address:E:"length"off:2 size:0 isFloa ...
 -- $ObjectInvocation_Unary:invoke: rec:"S" "length"
 -- >top:1 descNo:29 
 -- E.ATd: "length" unique: false
 -- adr::Address:E:"length"off:2 size:0 isFloat:False superAdj:0 isUnique:F ...
 -- $pattern:invoke: "length:  |    out V: var integer |    V := @get 0"
 -- Pattern:invoke:descNo:29  top:1  rec:"S" 
 -- ComputeVariantX
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- <>var
 -- ptn:invoke::isValObj:false:rtnValObj:true:"length:  |    out V: var integ ..." 
 -- rec=E:false:rec:"S" 
 -- kuk:pattern:rec.ATd:"in S: ref String" 
 invoke length 29 0 0
 -- useRtnVal:true:isVal:false:rtnValObj:true:rec=E:false"S" 
 -- OI:invoke:length:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"length" 
 -- loadArgs:after:Qgen:"@for 1 :to S.length  | :do  |    e := S.@get inx |    i  ..." 
 -- formalArg:isPtn:"in to: var integer" :isBasicVal:true:valueObj:true
 -- :actArg:"S.length" :isBasicVal:true
 -- S.lengthObjectCall
 -- end:loadArgs:NonVirt:"@for 1 :to S.length  | :do  |    e := S.@get inx |    i ..." 
 toSuper 28
 rtnInner
DO:
 mvStack 
 L1:
 L2:
 rtnInner
 end OSDV:0 objSize:4 isIndexed:0  vTop:1 vTopMax:1 rTop:0 rTopMax:0
 -- Handle VB: "" E: "@for 1 :to S.length  | :do  |    e := S.@get inx |    i :=  ..." 
 -- Virtual
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 91 :top:1 
 -- GenClass:doplus :varNo = 1 
 -- GenClass:doplus:true -> var.genDone

class doplus 91 1 94
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $Signature:gen: "doplus"
 -- $var:gen: "e: var integer"
 -- DI:isConst:false:isBasicValue:true:primNo:1 
 -- OGqual:integer:OGqual.isBasicValue:true:OGqual.isValueObj:true
 -- $var:gen: "i: var integer"
 -- DI:isConst:false:isBasicValue:true:primNo:1 
 -- OGqual:integer:OGqual.isBasicValue:true:OGqual.isValueObj:true
 -- $obj:gen: "T: obj Indexed(L + S.length,Integer)"
 -- DI:isConst:true:isBasicValue:false:primNo:114 
 -- OGqual:Indexed:OGqual.isBasicValue:false:OGqual.isValueObj:false
 -- $ObjectCall:gen: "Indexed(L + S.length,Integer)"
 -- $Invocation:gen: descNo: 0 top: 0 "Indexed(L + S.length,Integer)"
 -- needorigin:"Indexed(L + S.length,Integer)" 
 -- needOrigin:E:"Indexed(L + S.length,Integer)"  E.ATd:"Indexed:  |    %glob ..." 
 -- LoadOrign:no:loadOrigin: "%globals | %basic 114 | %public | in range: var Int ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "Indexed(L + S.length,Integer)" E: "Indexed(L + S.length,Integer)" i ...false
 -- $ObjectInvocation_Function:loadArgs:staticOff:0 "Indexed(L + S.length,I ..."
 -- $pattern:loadArgs:E:"Indexed(L + S.length,Integer)":descNo:0:top:0 "Ind ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"Indexed(L + S.length,Integer)" ActArg: "L + S.length" i ...false
 -- loadArgs:not:*: formalArgOf:"Indexed(L + S.length,Integer)"  isComposit ...false
 -- $ObjectCall:gen: "L + S.length"
 -- $Invocation:gen: descNo: 0 top: 0 "L + S.length"
 -- needorigin:"L + S.length" 
 -- needOrigin:E:"+ S.length"  E.ATd:"+ :  |    %basic 61 |    in V: var intege ..." 
 -- computeAdr: "L + S.length" 
 -- computeAdr:1 :rec:"none"  E:"L" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "L"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "L"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:1 
 -- goOrigin:doplus:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 doplus:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:1 "L"
 -- $var:getAdr:,newOff:4,isValue:"True",A.isValue:"False" "L: var integer" ...
 --  A::Address:E:"L"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...L ...
 -- value_prim:false
 -- integer
 -- before:floatTest: 
 -- computeAdr:isFirst::Address:E:"L"off:4 size:0 isFloat:False superAdj:0  ...
 -- computeAdr:2 :rec:"L"  E:"+ S.length" :Address:E:"L"off:4 size:0 isFloa ...
 -- E:notAssign:+ S.length
 -- $ObjectInvocation_Binary:getAdr::superAdj:0:on:0 "+ S.length"
 -- $pattern:getAdr: "+ :  |    %basic 61 |    in V: var integer |    out R: var  ..."
 -- :Address:E:"L"off:4 size:0 isFloat:False superAdj:0 isUnique:False isVa ...
 -- ptn.ssUnitValueObj:false isFloat:false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "L"
 -- $var:loadArgs: "L: var integer"
 -- $ObjectInvocation_Unary:invoke: rec:"L" "L"
 -- E.ATd: "+  | --%basic 61]] | " unique: false
 -- adr::Address:E:"L"off:4 size:0 isFloat:False superAdj:0 isUnique:False  ...
 -- $var:invoke: newOff:4 "L: var integer"
 -- load::Address:E:"L"off:4 size:0 isFloat:False superAdj:0 isUnique:False ...
 -- isFloat: false
 pushg 4 
 -- OI:invoke:L:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "+ S.length" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"L"off:4 size:0 isFloat:False ...
 -- rec: "L" E: "+ S.length" isValueAssign: false
 -- $ObjectInvocation_Binary:loadArgs:staticOff:0 "+ S.length"
 -- $pattern:loadArgs:E:"+ S.length":descNo:0:top:0 "+ :  |    %basic 61 |    i ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"+ S.length" ActArg: "S.length" isValue: false
 -- loadArgs:not:*: formalArgOf:"+ S.length"  isCompositeValueObj:false
 -- $ObjectCall:gen: "S.length"
 -- $Invocation:gen: descNo: 29 top: 1 "S.length"
 -- needorigin:"S.length" 
 -- needOrigin:E:"length"  E.ATd:"length:  |    out V: var integer |    V := @g ..." 
 -- computeAdr: "S.length" 
 -- computeAdr:1 :rec:"none"  E:"S" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "S"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "S"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:1 
 -- goOrigin:doplus:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 doplus:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:1 "S"
 -- $ref:getAdr:,newOff:2,isValue:"False",A.isValue:"False" "in S: ref Stri ..."
 --  A::Address:E:"S"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...i ...
 -- value_prim:false
 -- computeAdr:isFirst::Address:E:"none"off:2 size:0 isFloat:False superAdj ...
 -- computeAdr:2 :rec:"S"  E:"length" :Address:E:"none"off:2 size:0 isFloat ...
 -- E:notAssign:length
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "length"
 -- $pattern:getAdr: "length:  |    out V: var integer |    V := @get 0"
 -- :Address:E:"length"off:2 size:0 isFloat:False superAdj:0 isUnique:False ...
 -- ptn.ssUnitValueObj:false isFloat:false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "S"
 -- $ref:loadArgs: "in S: ref String"
 -- $ObjectInvocation_Unary:invoke: rec:"S" "S"
 -- E.ATd: "length" unique: false
 -- adr::Address:E:"length"off:2 size:0 isFloat:False superAdj:0 isUnique:F ...
 -- $ref:invoke: newOff:2 "in S: ref String"
 -- >Object:unique:false
 -- loadAdr::Address:E:"length"off:2 size:0 isFloat:False superAdj:0 isUniq ...
 rpushg 2 
 -- OI:invoke:S:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "length" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"length"off:2 size:0 isFloat: ...
 -- rec: "S" E: "length" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "length"
 -- $pattern:loadArgs:E:"length":descNo:29:top:1 "length:  |    out V: var in ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"length" :Address:E:"length"off:2 size:0 isFloa ...
 -- $ObjectInvocation_Unary:invoke: rec:"S" "length"
 -- >top:1 descNo:29 
 -- E.ATd: "length" unique: false
 -- adr::Address:E:"length"off:2 size:0 isFloat:False superAdj:0 isUnique:F ...
 -- $pattern:invoke: "length:  |    out V: var integer |    V := @get 0"
 -- Pattern:invoke:descNo:29  top:1  rec:"S" 
 -- ComputeVariantX
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- <>var
 -- ptn:invoke::isValObj:false:rtnValObj:true:"length:  |    out V: var integ ..." 
 -- rec=E:false:rec:"S" 
 -- kuk:pattern:rec.ATd:"in S: ref String" 
 invoke length 29 0 0
 -- useRtnVal:true:isVal:false:rtnValObj:true:rec=E:false"S" 
 -- OI:invoke:length:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"length" 
 -- loadArgs:after:Qgen:"+ S.length" 
 -- formalArg:isPtn:"in V: var integer" :isBasicVal:true:valueObj:true
 -- :actArg:"S.length" :isBasicVal:true
 -- S.lengthObjectCall
 -- end:loadArgs:NonVirt:"+ S.length" 
 -- invoke:after:loadArgsOf:"+ S.length" :Address:E:"L"off:4 size:0 isFloat ...
 -- $ObjectInvocation_Binary:invoke: rec:"L" "+ S.length"
 -- >top:0 descNo:0 
 -- E.ATd: "+  | --%basic 61]] | " unique: false
 -- adr::Address:E:"L"off:4 size:0 isFloat:False superAdj:0 isUnique:False  ...
 -- $pattern:invoke: "+ :  |    %basic 61 |    in V: var integer |    out R: var  ..."
 -- bodyC:
 plus
 -- OI:invoke:+ S.length:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"+ S.length" 
 -- loadArgs:after:Qgen:"Indexed(L + S.length,Integer)" 
 -- formalArg:isPtn:"in range: var Integer" :isBasicVal:true:valueObj:true
 -- :actArg:"L + S.length" :isBasicVal:true
 -- L + S.lengthObjectCall
 -- end:loadArgs:NonVirt:"Indexed(L + S.length,Integer)" 
 -- invoke:after:loadArgsOf:"Indexed(L + S.length,Integer)" 
 -- $ObjectInvocation_Function:invoke: rec:"Indexed(L + S.length,Integer)"  ...
 -- >top:0 descNo:0 
 -- $pattern:invoke: "Indexed:  |    %globals |    %basic 114 |    %public |    in  ..."
 pushThis 
 -- ComputeVariant:A:Indexed
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:%globals | %basic 114 | %public | in range: var Integer | in elm:<  ...
 -- :varNo:1 :allocDone:false
 -- :OG:Qalloc:B:Indexed:newDescNo:0 :objSize:0 
 -- OG:isObjectDesc:NewDescNo:107 IS.newDescNo:107 :objSize:0 varNo:1 %glob ...
 -- Items:Qalloc:objSize:0 
 -- Items:Qalloc:Super:C:objSize:0 originOff:0 
 -- dataitem:qalloc:range isValue:true isPrimitive: true isValObj: true isB ...true
 -- Pattern:Qalloc:elm
 -- Pattern:Qalloc:elm
 -- Pattern:Qalloc:length
 -- Pattern:Qalloc:length
 -- Pattern:Qalloc:@put::at
 -- Pattern:Qalloc:@get:
 -- Pattern:Qalloc:asString
 -- IS.newDescNo:107 IS.objSize:1 :%globals | %basic 114 | %public | in range: va ...
 -- computeVariant:newDescNo:107 IS:%globals | %basic 114 | %public | in range: v ...
 -- ComputeVariant:B:Indexed
 -- ObjTmpStack:add::genDone:false Indexed:%globals | %basic 114 | %public | in r ...
 pushc 1
 allocIndexed StaticRep 107 1 0
 pushThis 
 rstoreg 4 indexed
 -- OI:invoke:Indexed(L + S.length,Integer):unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"Indexed(L + S.length,Integer)" 
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"@for 1 :to L  | :do  |    e := @get inx |    T.@put e :at ..." 
 -- $ObjectGenerator:gen:"@for::to:do#S#92"IS.isempty! staticOff: 0 descNo: ...
 -- OG:gen:super:"" superDescNo:28 super.OG.top:1 
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 92  @for::to:do#S#92
 invoke @for::to:do#S#92 92 0 1
 rpop
 -- genclass:Qgen:stmt:"@for 1 :to S.length  | :do  |    e := S.@get inx |    i : ..." 
 -- $ObjectGenerator:gen:"@for::to:do#S#93"IS.isempty! staticOff: 0 descNo: ...
 -- OG:gen:super:"" superDescNo:28 super.OG.top:1 
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 93  @for::to:do#S#93
 invoke @for::to:do#S#93 93 0 1
 rpop
 -- genclass:Qgen:stmt:"V := T.asString" 
 -- $ObjectCall:gen: "V := T.asString"
 -- $Invocation:gen: descNo: 14 top: 1 "V := T.asString"
 -- needorigin:"V := T.asString" 
 -- needOrigin:E:":= T.asString"  E.ATd:":= :  |    %basic 8 |    in V: ref Val ..." 
 -- computeAdr: "V := T.asString" 
 -- computeAdr:1 :rec:"none"  E:"V" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "V"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "V"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:1 
 -- goOrigin:doplus:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 doplus:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:1 "V"
 -- $ref:getAdr:,newOff:3,isValue:"False",A.isValue:"False" "out V: ref Str ..."
 --  A::Address:E:"V"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...o ...
 -- value_prim:false
 -- computeAdr:isFirst::Address:E:"none"off:3 size:0 isFloat:False superAdj ...
 -- computeAdr:2 :rec:"V"  E:":= T.asString" :Address:E:"none"off:3 size:0  ...
 -- computeAdr:isAssign:rec: "V"  E:":= T.asString" 
 -- :Address:E:"none"off:3 size:0 isFloat:False superAdj:0 isUnique:False i ...
 -- computeAdr:isLast:E: ":= T.asString" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"none"off:3 size:0 isFloat:Fa ...
 -- rec: "V" E: ":= T.asString" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:3 ":= T.asString"
 -- $pattern:loadArgs:E:":= T.asString":descNo:14:top:1 ":= :  |    %basic 8 |  ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= T.asString" ActArg: "T.asString" isValue: false
 -- $ObjectCall:gen: "T.asString"
 -- $Invocation:gen: descNo: 0 top: 0 "T.asString"
 -- needorigin:"T.asString" 
 -- needOrigin:E:"asString"  E.ATd:"asString:  |    %basic 118 |    out S: ref  ..." 
 -- computeAdr: "T.asString" 
 -- computeAdr:1 :rec:"none"  E:"T" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "T"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "T"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "T"
 -- $obj:getAdr:,newOff:4,isValue:"False",A.isValue:"False" "T: obj Indexed ..."
 --  A::Address:E:"T"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...T ...
 -- value_prim:false
 -- computeAdr:isFirst::Address:E:"none"off:4 size:0 isFloat:False superAdj ...
 -- computeAdr:2 :rec:"T"  E:"asString" :Address:E:"none"off:4 size:0 isFlo ...
 -- E:notAssign:asString
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "asString"
 -- $pattern:getAdr: "asString:  |    %basic 118 |    out S: ref Object"
 -- :Address:E:"asString"off:4 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- ptn.ssUnitValueObj:false isFloat:false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "T"
 -- $obj:loadArgs: "T: obj Indexed(L + S.length,Integer)"
 -- $ObjectInvocation_Unary:invoke: rec:"T" "T"
 -- E.ATd: "asString" unique: false
 -- adr::Address:E:"asString"off:4 size:0 isFloat:False superAdj:0 isUnique ...
 -- $obj:invoke: newOff:4 "T: obj Indexed(L + S.length,Integer)"
 -- >Object:unique:false
 -- load::Address:E:"asString"off:4 size:0 isFloat:False superAdj:0 isUniqu ...
 rpushg 4 
 -- OI:invoke:T:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "asString" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"asString"off:4 size:0 isFloa ...
 -- rec: "T" E: "asString" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "asString"
 -- $pattern:loadArgs:E:"asString":descNo:0:top:0 "asString:  |    %basic 118 ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"asString" :Address:E:"asString"off:4 size:0 is ...
 -- $ObjectInvocation_Unary:invoke: rec:"T" "asString"
 -- >top:0 descNo:0 
 -- E.ATd: "asString" unique: false
 -- adr::Address:E:"asString"off:4 size:0 isFloat:False superAdj:0 isUnique ...
 -- $pattern:invoke: "asString:  |    %basic 118 |    out S: ref Object"
 %asString 118
 -- OI:invoke:asString:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"asString" 
 -- loadArgs:after:Qgen:":= T.asString" 
 -- vAssign:fArg:"in V: ref Value" 
 -- BINGO
 -- aaaa: in V: ref Value
 -- end:loadArgs:NonVirt:":= T.asString" 
 -- invoke:after:loadArgsOf:":= T.asString" :Address:E:"none"off:3 size:0 i ...
 -- $ObjectInvocation_Binary:invoke: rec:"V" ":= T.asString"
 -- >top:1 descNo:14 
 -- E.ATd: ":= " unique: false
 -- adr::Address:E:"none"off:3 size:0 isFloat:False superAdj:0 isUnique:Fal ...
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: ref Value"
 -- AssignPtn:invoke:rec: "V" from: ":= T.asString" 
 -- assign:dstDI :"out V: ref String" isUnitValueObj: false
 -- assign:arg: "T.asString" lab:"ObjectCall" UnitValObj :false ptn: false
 --  float: false DataItem:false arg.super:T.asString
 --  arg.super.ATd:"Invocation" "asString:  |    %basic 118 |    out S: ref Obj ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "pattern" 
 -- assign:reference: "V" 
 -- :Address:E:"none"off:3 size:0 isFloat:False superAdj:0 isUnique:False i ...
 -- store::Address:E:"none"off:3 size:0 isFloat:False superAdj:0 isUnique:F ...
 -- isValue:false isAdr:false descNo: 0 
 rswap
 rstoreg 3 
 -- OI:invoke::= T.asString:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= T.asString" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"doplus" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:4 isIndexed:0  vTop:0 vTopMax:0 rTop:2 rTopMax:3
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 94 :top:1 
 -- GenClass:+ :varNo = 1 
 -- GenClass:+:true -> var.genDone

class + 94 1 15
 -- Store itemArgs
 pushThis 
 rstoreg 2 S
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $Signature:gen: "+ "
 -- $ref:gen: "in S: ref String"
 -- DI:isConst:false:isBasicValue:false:primNo:5 
 -- OGqual:String:OGqual.isBasicValue:false:OGqual.isValueObj:false
 -- $ref:gen: "out V: ref String"
 -- DI:isConst:false:isBasicValue:false:primNo:5 
 -- OGqual:String:OGqual.isBasicValue:false:OGqual.isValueObj:false
 -- $var:gen: "L: var integer"
 -- DI:isConst:false:isBasicValue:true:primNo:1 
 -- OGqual:integer:OGqual.isBasicValue:true:OGqual.isValueObj:true
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"L := Length" 
 -- $ObjectCall:gen: "L := Length"
 -- $Invocation:gen: descNo: 4 top: 1 "L := Length"
 -- needorigin:"L := Length" 
 -- needOrigin:E:":= Length"  E.ATd:":= :  |    %basic 8 |    in V: var Value" 
 -- computeAdr: "L := Length" 
 -- computeAdr:1 :rec:"none"  E:"L" :Address:E:"none"off:0 size:0 isFloat:F ...
 -- $ObjectInvocation_Unary:pushThis: "L"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "L"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "L"
 -- $var:getAdr:,newOff:4,isValue:"True",A.isValue:"False" "L: var integer" ...
 --  A::Address:E:"L"off:0 size:0 isFloat:False superAdj:0 isUnique:False i ...  ...L ...
 -- value_prim:false
 -- integer
 -- before:floatTest: 
 -- computeAdr:isFirst::Address:E:"L"off:4 size:0 isFloat:False superAdj:0  ...
 -- computeAdr:2 :rec:"L"  E:":= Length" :Address:E:"L"off:4 size:0 isFloat ...
 -- computeAdr:isAssign:rec: "L"  E:":= Length" 
 -- :Address:E:"L"off:4 size:0 isFloat:False superAdj:0 isUnique:False isVa ...
 -- computeAdr:isLast:E: ":= Length" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"L"off:4 size:0 isFloat:False ...
 -- rec: "L" E: ":= Length" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:4 ":= Length"
 -- $pattern:loadArgs:E:":= Length":descNo:4:top:1 ":= :  |    %basic 8 |    in ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= Length" ActArg: "Length" isValue: false
 -- $ObjectCall:gen: "Length"
 -- $Invocation:gen: descNo: 29 top: 1 "Length"
 -- needorigin:"Length" 
 -- needOrigin:E:"Length"  E.ATd:"length:  |    out V: var integer |    V := @g ..." 
 -- computeAdr: "Length" 
 -- computeAdr:1 :rec:"none"  E:"Length" :Address:E:"none"off:0 size:0 isFl ...
 -- $ObjectInvocation_Unary:pushThis: "Length"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "Length"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:A:1 
 -- goOrigin:+:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 +:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:1 "Length"
 -- $pattern:getAdr: "length:  |    out V: var integer |    V := @get 0"
 -- :Address:E:"Length"off:0 size:0 isFloat:False superAdj:0 isUnique:False ...
 -- computeAdr:isFirst::Address:E:"Length"off:0 size:0 isFloat:False superA ...
 -- computeAdr:isLast:E: "Length" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"Length"off:0 size:0 isFloat: ...
 -- rec: "Length" E: "Length" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "Length"
 -- $pattern:loadArgs:E:"Length":descNo:29:top:1 "length:  |    out V: var in ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"Length" :Address:E:"Length"off:0 size:0 isFloa ...
 -- $ObjectInvocation_Unary:invoke: rec:"Length" "Length"
 -- >top:1 descNo:29 
 -- E.ATd: "length" unique: false
 -- adr::Address:E:"Length"off:0 size:0 isFloat:False superAdj:0 isUnique:F ...
 -- $pattern:invoke: "length:  |    out V: var integer |    V := @get 0"
 -- Pattern:invoke:descNo:29  top:1  rec:"Length" 
 -- ptn:invoke::isValObj:false:rtnValObj:true:"length:  |    out V: var integ ..." 
 -- rec=E:true:rec:"Length" 
 -- kuk:pattern:rec.ATd:"length:  |    out V: var integer |    V := @get 0" 
 invoke length 29 0 0
 -- useRtnVal:true:isVal:false:rtnValObj:true:rec=E:true"Length" 
 -- OI:invoke:Length:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"Length" 
 -- loadArgs:after:Qgen:":= Length" 
 -- vAssign:fArg:"in V: var Value" 
 -- BINGO
 -- aaaa: in V: var Value
 -- end:loadArgs:NonVirt:":= Length" 
 -- invoke:after:loadArgsOf:":= Length" :Address:E:"L"off:4 size:0 isFloat: ...
 -- $ObjectInvocation_Binary:invoke: rec:"L" ":= Length"
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Address:E:"L"off:4 size:0 isFloat:False superAdj:0 isUnique:False  ...
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "L" from: ":= Length" 
 -- assign:dstDI :"L: var integer" isUnitValueObj: false
 -- assign:arg: "Length" lab:"ObjectCall" UnitValObj :false ptn: false
 --  float: false DataItem:false arg.super:Length
 --  arg.super.ATd:"Invocation" "length:  |    out V: var integer |    V := @ge ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "pattern" 
 -- assign:simple value: 
 -- :Address:E:"L"off:4 size:0 isFloat:False superAdj:0 isUnique:False isVa ...
 -- store::Address:E:"L"off:4 size:0 isFloat:False superAdj:0 isUnique:Fals ...
 -- isValue:true isAdr:false descNo: 0 
 -- isFloat: false
 storeg 4 address:storeg
 -- OI:invoke::= Length:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= Length" 
 -- genclass:Qgen:stmt:"doplus | -- V: obj Indexed(Length + S.length) |  | -- V : ..." 
 -- $ObjectCall:gen: "doplus | -- V: obj Indexed(Length + S.length) |  | -- V :=  ..."
 -- $Invocation:gen: descNo: 91 top: 1 "doplus | -- V: obj Indexed(Length + S ..."
 -- needorigin:"doplus | -- V: obj Indexed(Length + S.length) |  | -- V := T[1:le ..." 
 -- needOrigin:E:"doplus"  E.ATd:"doplus:  |    e: var integer |    i: var inte ..." 
 -- computeAdr: "doplus | -- V: obj Indexed(Length + S.length) |  | -- V := T[1:l ..." 
 -- computeAdr:1 :rec:"none"  E:"doplus" :Address:E:"none"off:0 size:0 isFl ...
 -- $ObjectInvocation_Unary:pushThis: "doplus"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "doplus"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "doplus"
 -- $pattern:getAdr: "doplus:  |    e: var integer |    i: var integer |    T: ob ..."
 -- :Address:E:"doplus"off:0 size:0 isFloat:False superAdj:0 isUnique:False ...
 -- computeAdr:isFirst::Address:E:"doplus"off:0 size:0 isFloat:False superA ...
 -- computeAdr:isLast:E: "doplus" 
 -- IV:after:computeAdr:superAdj:0 :Address:E:"doplus"off:0 size:0 isFloat: ...
 -- rec: "doplus" E: "doplus" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "doplus"
 -- $pattern:loadArgs:E:"doplus":descNo:91:top:1 "doplus:  |    e: var intege ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"doplus" :Address:E:"doplus"off:0 size:0 isFloa ...
 -- $ObjectInvocation_Unary:invoke: rec:"doplus" "doplus"
 -- >top:1 descNo:91 
 -- E.ATd: "doplus" unique: false
 -- adr::Address:E:"doplus"off:0 size:0 isFloat:False superAdj:0 isUnique:F ...
 -- $pattern:invoke: "doplus:  |    e: var integer |    i: var integer |    T: ob ..."
 -- Pattern:invoke:descNo:91  top:1  rec:"doplus" 
 -- ptn:invoke::isValObj:false:rtnValObj:false:"doplus:  |    e: var integer |  ..." 
 -- rec=E:true:rec:"doplus" 
 -- kuk:pattern:rec.ATd:"doplus:  |    e: var integer |    i: var integer |    T: ..." 
 invoke doplus 91 0 0
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:true"doplus" 
 rpop
 -- OI:invoke:doplus:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"doplus" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"+" 
 setThisStack 
 pushThis 
 -- $ref:invoke: newOff:3 "out V: ref String"
 -- >Object:unique:false
 -- >adr=none
 rpushg 3 V
 rtn(D)
 end OSDV:0 objSize:4 isIndexed:0  vTop:-1 vTopMax:0 rTop:1 rTopMax:1
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:C: 107 :top:1 
 -- GenClass:Indexed :varNo = 1 
 -- GenClass:Indexed:true -> var.genDone

class Indexed 107 0 6
 -- Store itemArgs
 pushThis 
 storeg 1 range
 allocEventQ
 mvStack 
 -- $Signature:gen: "Indexed"
 -- $var:gen: "in range: var Integer"
 -- DI:isConst:false:isBasicValue:true:primNo:1 
 -- OGqual:integer:OGqual.isBasicValue:true:OGqual.isValueObj:true
 -- $pattern:gen: "in elm:< Object"
 -- vdt:d
 -- vdtAdd: inx=1 descInx=86
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%globals" 
 -- $Property:gen: "%globals"
 -- genclass:Qgen:stmt:"%basic 114" 
 -- $Property:gen: "%basic 114"
 -- genclass:Qgen:stmt:"%public" 
 -- $Property:gen: "%public"
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"Indexed" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:1  vTop:-1 vTopMax:0 rTop:2 rTopMax:2
 -- Virtual

class main 108 0 0
 pushThis 
 invoke BETAworld 85 0 1
 stop
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:1 rTopMax:1

class EventProcessor 109 0 0
 stop
 end OSDV:0 objSize:1 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0

class ThreadStub 110 0 0
DO:
 call(D)ThreadStub
 stop
 end OSDV:0 objSize:1 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- vdtAdd: inx=1 descInx=31
 -- vdtAdd: inx=1 descInx=95
 -- vdtAdd: inx=1 descInx=96
 -- vdtAdd: inx=2 descInx=97
 -- vdtAdd: inx=3 descInx=98
 -- vdtAdd: inx=1 descInx=99
 -- vdtAdd: inx=1 descInx=100
 -- vdtAdd: inx=1 descInx=101
 -- vdtAdd: inx=3 descInx=102
 -- vdtAdd: inx=4 descInx=103
 -- vdtAdd: inx=5 descInx=104
 -- vdtAdd: inx=1 descInx=105
 -- vdtAdd: inx=1 descInx=106
 -- vdtAdd: inx=1 descInx=87
 -- vdtAdd: inx=1 descInx=89

Class Value descInx: 1 originOff: 0 visibility: 0
allocE:
doE: 
1:	rtnV
2:	rtn D


Class universal descInx: 2 originOff: 0 visibility: 0
allocE:
doE: 
1:	rtnV
2:	rtn D


Class char descInx: 3 originOff: 0 visibility: 0
allocE:
doE: 
1:	rtnV
2:	rtn D


Class := descInx: 4 originOff: 1 visibility: 0
allocE:
1:	pushthis 
2:	storeg 3
4:	tstOriginNone 
5:	rstore 1
7:	store 2
9:	allocEventQ 1
11:	mvStack
12:	rtnEventQ 0
doE: 
14:	doEventQ 
15:	mvStack
16:	rtnEventQ 0
18:	setThisStack
19:	pushthis 
20:	rtn D


Class ascii descInx: 5 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	pushc 10
9:	pushthis 
10:	storeg 2
12:	pushc 13
14:	pushthis 
15:	storeg 3
17:	rtnEventQ 0
doE: 
19:	doEventQ 
20:	mvStack
21:	pushthis 
22:	pushthis 
23:	pushg 3
25:	storeg 4
27:	rtnEventQ 0
29:	setThisStack
30:	pushthis 
31:	rtn D


Class BETA descInx: 6 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	pushthis 
8:	invoke 5 2 1
14:	rpop 
15:	rtnEventQ 0
doE: 
17:	doEventQ 
18:	mvStack
19:	rtnEventQ 0
21:	setThisStack
22:	pushthis 
23:	rtn D


Class integer descInx: 7 originOff: 0 visibility: 0
allocE:
doE: 
1:	rtnV
2:	rtn D


Class Associations descInx: 8 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 0
doE: 
9:	doEventQ 
10:	mvStack
11:	rtnEventQ 0
13:	setThisStack
14:	pushthis 
15:	rtn D


Class keyboard descInx: 9 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 0
doE: 
9:	doEventQ 
10:	mvStack
11:	rtnEventQ 0
13:	setThisStack
14:	pushthis 
15:	rtn D


Class Lock descInx: 10 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 0
doE: 
9:	doEventQ 
10:	mvStack
11:	rtnEventQ 0
13:	setThisStack
14:	pushthis 
15:	rtn D


Class screen descInx: 11 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	pushthis 
8:	rpushg 1
10:	invoke 10 2 0
16:	rpop 
17:	rtnEventQ 0
doE: 
19:	doEventQ 
20:	mvStack
21:	rtnEventQ 0
23:	setThisStack
24:	pushthis 
25:	rtn D


Class BasicIO descInx: 12 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	pushthis 
8:	invoke 9 2 1
14:	rpop 
15:	pushthis 
16:	invoke 11 3 1
22:	rpop 
23:	rtnEventQ 0
doE: 
25:	doEventQ 
26:	mvStack
27:	rtnEventQ 0
29:	setThisStack
30:	pushthis 
31:	rtn D


Class List descInx: 13 originOff: 1 visibility: 0
allocE:
1:	pushthis 
2:	rstoreg 3
4:	pushthis 
5:	rstoreg 2
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 1
12:	mvStack
13:	rtnEventQ 0
doE: 
15:	doEventQ 
16:	mvStack
17:	rtnEventQ 0
19:	setThisStack
20:	pushthis 
21:	rtn D


Class := descInx: 14 originOff: 1 visibility: 0
allocE:
1:	pushthis 
2:	storeg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 1
9:	mvStack
10:	rtnEventQ 0
doE: 
12:	doEventQ 
13:	mvStack
14:	rtnEventQ 0
16:	setThisStack
17:	pushthis 
18:	rtn D


Class String descInx: 15 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 0
doE: 
9:	doEventQ 
10:	mvStack
11:	rtnEventQ 0
13:	setThisStack
14:	pushthis 
15:	rtn D


Class String descInx: 16 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	saveStringOrigin
7:	mvStack
8:	rtnEventQ 0
doE: 
10:	doEventQ 
11:	mvStack
12:	rtnEventQ 0
14:	setThisStack
15:	pushthis 
16:	rtn D


Class foo descInx: 17 originOff: 1 visibility: 0
allocE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 1
9:	mvStack
10:	rtnEventQ 0
doE: 
12:	doEventQ 
13:	mvStack
14:	rtnEventQ 0
16:	setThisStack
17:	pushthis 
18:	rtn D


Class @this: descInx: 18 originOff: 1 visibility: 0
allocE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 1
9:	mvStack
10:	rtnEventQ 0
doE: 
12:	doEventQ 
13:	mvStack
14:	rtnEventQ 0
16:	setThisStack
17:	pushthis 
18:	rtn D


Class Boolean descInx: 19 originOff: 0 visibility: 0
allocE:
doE: 
1:	rtnV
2:	rtn D


Class @if::then descInx: 20 originOff: 0 visibility: 0
allocE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 0
doE: 
9:	doEventQ 
10:	mvStack
11:	rtnEventQ 0
13:	setThisStack
14:	pushthis 
15:	rtn D


Class #S#22 descInx: 22 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 0
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushthis 
17:	rpushg 1
19:	rpushg 1
21:	rpushg 1
23:	rpushg 3
25:	rswap 
26:	rstoreg 3
28:	pushthis 
29:	rpushg 1
31:	rpushg 1
33:	pushthis 
34:	rpushg 1
36:	rpushg 1
38:	rpushg 3
40:	rpushg 2
42:	rswap 
43:	rstoreg 2
45:	break 1 1 23
51:	rtnEventQ 0
53:	setThisStack
54:	pushthis 
55:	rtn D


Class loop descInx: 23 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 0
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	innerP 1
16:	rpopThisObj
17:	pushthis 
18:	rpushg 1
20:	rpushg 3
22:	rpushg 3
24:	pushNone 
25:	57
26:	jmpFalse 37
29:	pushthis 
30:	invoke 22 0 1
36:	rpop 
37:	rtnEventQ 0
39:	setThisStack
40:	pushthis 
41:	rtn D


Class scan descInx: 24 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	innera 1
9:	rtnEventQ 0
doE: 
11:	doEventQ 
12:	mvStack
13:	pushthis 
14:	pushthis 
15:	rpushg 1
17:	rswap 
18:	rstoreg 3
20:	pushthis 
21:	pushthis 
22:	rpushg 1
24:	rpushg 2
26:	rswap 
27:	rstoreg 2
29:	pushthis 
30:	invoke 23 0 0
36:	rpop 
37:	rtnEventQ 0
39:	setThisStack
40:	pushthis 
41:	rtn D


Class #S#25 descInx: 25 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 0
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	sendv 1 0
21:	rpop 
22:	pushthis 
23:	rpushg 1
25:	rpushg 1
27:	rpushg 1
29:	pushthis 
30:	rpushg 1
32:	rpushg 1
34:	rpushg 1
36:	pushg 3
38:	pushc 1
40:	+
41:	storeg 3
43:	break 1 1 26
49:	rtnEventQ 0
51:	setThisStack
52:	pushthis 
53:	rtn D


Class loop descInx: 26 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 0
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushg 3
18:	pushthis 
19:	rpushg 1
21:	rpushg 1
23:	pushg 2
25:	le
26:	jmpFalse 37
29:	pushthis 
30:	invoke 25 0 1
36:	rpop 
37:	rtnEventQ 0
39:	setThisStack
40:	pushthis 
41:	rtn D


Class doIt descInx: 27 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	pushthis 
8:	invoke 26 2 1
14:	rpop 
15:	rtnEventQ 0
doE: 
17:	doEventQ 
18:	mvStack
19:	rtnEventQ 0
21:	setThisStack
22:	pushthis 
23:	rtn D


Class @for::to:do descInx: 28 originOff: 0 visibility: 0
allocE:
1:	pushthis 
2:	storeg 2
4:	pushthis 
5:	storeg 1
7:	allocEventQ 1
9:	mvStack
10:	innera 2
12:	rtnEventQ 0
doE: 
14:	doEventQ 
15:	mvStack
16:	pushthis 
17:	pushthis 
18:	pushg 1
20:	storeg 3
22:	pushthis 
23:	invoke 27 0 0
29:	rpop 
30:	pushthis 
31:	innerP 2
33:	rpopThisObj
34:	rtnEventQ 0
36:	setThisStack
37:	pushthis 
38:	rtn D


Class length descInx: 29 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 0
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	pushc 0
17:	xpushg 1 0 1
21:	storeg 2
23:	rtnEventQ 0
25:	setThisStack
26:	pushthis 
27:	pushg 2
29:	rtn D


Class put descInx: 30 originOff: 0 visibility: 0
allocE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 0
doE: 
9:	doEventQ 
10:	mvStack
11:	rtnEventQ 0
13:	setThisStack
14:	pushthis 
15:	rtn D


Class do#S#31 descInx: 31 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 0
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	rpushg 1
18:	pushthis 
19:	rpushg 1
21:	pushg 3
23:	xpushg 1 0 1
27:	%prim put 2
29:	rtnEventQ 0
31:	setThisStack
32:	pushthis 
33:	rtn D


Class print descInx: 33 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 0
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	invoke 34 0 1
18:	rpop 
19:	rtnEventQ 0
21:	setThisStack
22:	pushthis 
23:	rtn D


Class @for::to:do#S#34 descInx: 34 originOff: 4 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	invoke 29 0 0
17:	toSuper 28
enterE: 
20:	rtnInner
doE: 
21:	mvStack
22:	rtnInner


Class print descInx: 35 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 0
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 2
16:	invoke 33 0 0
22:	rpop 
23:	rtnEventQ 0
25:	setThisStack
26:	pushthis 
27:	rtn D


Class List descInx: 37 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	pushthis 
14:	pushText 1
16:	invoke 17 0 1
22:	pushthis 
23:	pushthis 
24:	pushText 8
26:	invoke 17 0 1
32:	pushNone 
33:	invoke 13 0 1
39:	invoke 13 0 1
45:	rswap 
46:	rstoreg 2
48:	pushthis 
49:	invoke 38 0 1
55:	rpop 
56:	rtnEventQ 0
58:	setThisStack
59:	pushthis 
60:	rtn D


Class scan#S#38 descInx: 38 originOff: 4 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 4
4:	pushthis 
5:	rpushg 4
7:	rpushg 2
9:	toSuper 24
enterE: 
12:	rtnInner
doE: 
13:	mvStack
14:	pushthis 
15:	pushthis 
16:	rpushg 2
18:	rswap 
19:	rstoreg 5
21:	pushthis 
22:	rpushg 5
24:	invoke 35 0 0
30:	rpop 
31:	rtnInner


Class Containers descInx: 39 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	pushthis 
8:	invoke 37 2 1
14:	rpop 
15:	rtnEventQ 0
doE: 
17:	doEventQ 
18:	mvStack
19:	rtnEventQ 0
21:	setThisStack
22:	pushthis 
23:	rtn D


Class float descInx: 40 originOff: 0 visibility: 0
allocE:
doE: 
1:	rtnV
2:	rtn D


Class toBase descInx: 41 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	store 2
6:	allocEventQ 1
8:	mvStack
9:	invokeVal 45 2
14:	innera 1
16:	rtnEventQ 0
doE: 
18:	doEventQ 
19:	mvStack
20:	pushthis 
21:	innerP 1
23:	rpopThisObj
24:	rtnEventQ 0
26:	setThisStack
27:	pushthis 
28:	pushc 3
30:	rtn D


Class fromBase descInx: 42 originOff: 1 visibility: 0
allocE:
1:	pushthis 
2:	fstoreg 3
4:	tstOriginNone 
5:	rstore 1
7:	store 2
9:	allocEventQ 1
11:	mvStack
12:	innera 1
14:	rtnEventQ 0
doE: 
16:	doEventQ 
17:	mvStack
18:	pushthis 
19:	innerP 1
21:	rpopThisObj
22:	rtnEventQ 0
24:	setThisStack
25:	pushthis 
26:	rtn D


Class putFloat descInx: 43 originOff: 1 visibility: 0
allocE:
1:	pushthis 
2:	fstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 1
9:	mvStack
10:	rtnEventQ 0
doE: 
12:	doEventQ 
13:	mvStack
14:	rtnEventQ 0
16:	setThisStack
17:	pushthis 
18:	pushg 4
20:	rtn D


Class print descInx: 44 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	store 2
6:	allocEventQ 1
8:	mvStack
9:	innera 1
11:	rtnEventQ 0
doE: 
13:	doEventQ 
14:	mvStack
15:	pushText 1
17:	invoke 33 0 0
23:	rpop 
24:	pushthis 
25:	innerP 1
27:	rpopThisObj
28:	pushc 58
30:	%prim put 2
32:	pushthis 
33:	rdouble 
34:	rpushg 1
36:	rswap 
37:	pushg 2
39:	fovpushg 1
41:26
42:	142
43:	vpop 
44:	rtnEventQ 0
46:	setThisStack
47:	pushthis 
48:	rtn D


Class Unit descInx: 45 originOff: 0 visibility: 0
allocE:
doE: 
1:	rtnV
2:	rtn D


Class shortName descInx: 46 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	pushthis 
8:	rpushg 1
10:	rpushg 1
12:	rpushg 1
14:	rpushg 7
16:	rpop 
17:	innera 1
19:	rtnEventQ 0
doE: 
21:	doEventQ 
22:	mvStack
23:	pushthis 
24:	innerP 1
26:	rpopThisObj
27:	rtnEventQ 0
29:	setThisStack
30:	pushthis 
31:	rpushg 2
33:	rtn D


Class gMult descInx: 47 originOff: 1 visibility: 0
allocE:
1:	jmpFalse 14
4:	pushthis 
5:	addOff 4
8:	vassign 2 0
11:	jmp 19
14:	invokeVal 45 3
19:	jmpFalse 32
22:	pushthis 
23:	addOff 2
26:	vassign 2 0
29:	jmp 37
32:	invokeVal 45 1
37:	tstOriginNone 
38:	rstore 1
40:	allocEventQ 1
42:	mvStack
43:	invokeVal 45 5
48:	rtnEventQ 0
doE: 
50:	doEventQ 
51:	mvStack
52:	pushthis 
53:	pushthis 
54:	fpushg 2
56:	pushthis 
57:	fpushg 4
59:	fmult 
60:	fstoreg 6
62:	rtnEventQ 0
64:	setThisStack
65:	pushthis 
66:	pushc 6
68:	rtn D


Class Dimension descInx: 48 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 0
doE: 
9:	doEventQ 
10:	mvStack
11:	rtnEventQ 0
13:	setThisStack
14:	pushthis 
15:	rtn D


Class shortName descInx: 49 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	toSuper 46
enterE: 
10:	rtnInner
doE: 
11:	mvStack
12:	pushthis 
13:	pushText 5
15:	rswap 
16:	rstoreg 2
18:	rtnInner


Class Area descInx: 50 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	toSuper 48
enterE: 
10:	rtnInner
doE: 
11:	mvStack
12:	rtnInner


Class print descInx: 51 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	store 2
6:	pushthis 
7:	rpushg 1
9:	pushthis 
10:	pushg 2
12:	toSuper 44
enterE: 
15:	rtnInner
doE: 
16:	mvStack
17:	pushText 14
19:	invoke 33 0 0
25:	rpop 
26:	rtnInner


Class SquareMeter descInx: 52 originOff: 0 visibility: 0
allocE:
1:	toSuper 45
enterE: 
4:	rtnInner
doE: 
5:	rtnInner


Class toBase descInx: 53 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	store 2
6:	pushthis 
7:	rpushg 1
9:	pushthis 
10:	pushg 2
12:	toSuper 41
enterE: 
15:	rtnInner
doE: 
16:	mvStack
17:	pushthis 
18:	pushthis 
19:	rdouble 
20:	rpushg 1
22:	rswap 
23:	pushg 2
25:	fovpushg 1
27:	addOff 3
30:	vassign 2 0
33:	rtnInner


Class fromBase descInx: 54 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	store 2
6:	pushthis 
7:	rpushg 1
9:	pushthis 
10:	pushg 2
12:	toSuper 42
enterE: 
15:	rtnInner
doE: 
16:	mvStack
17:	pushthis 
18:	rdouble 
19:	rpushg 1
21:	rswap 
22:	pushg 2
24:	pushthis 
25:	fpushg 3
27:	fovstoreg 1
29:	rtnInner


Class print descInx: 55 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	store 2
6:	pushthis 
7:	rpushg 1
9:	pushthis 
10:	pushg 2
12:	toSuper 44
enterE: 
15:	rtnInner
doE: 
16:	mvStack
17:	pushText 14
19:	invoke 33 0 0
25:	rpop 
26:	rtnInner


Class Meter descInx: 56 originOff: 0 visibility: 0
allocE:
1:	toSuper 45
enterE: 
4:	rtnInner
doE: 
5:	rtnInner


Class shortName descInx: 57 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	toSuper 46
enterE: 
10:	rtnInner
doE: 
11:	mvStack
12:	pushthis 
13:	pushText 5
15:	rswap 
16:	rstoreg 2
18:	rtnInner


Class Length descInx: 58 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	toSuper 48
enterE: 
10:	rtnInner
doE: 
11:	mvStack
12:	rtnInner


Class Mass descInx: 59 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	toSuper 48
enterE: 
10:	rtnInner
doE: 
11:	mvStack
12:	rtnInner


Class Time descInx: 60 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	toSuper 48
enterE: 
10:	rtnInner
doE: 
11:	mvStack
12:	rtnInner


Class shortName descInx: 61 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	toSuper 46
enterE: 
10:	rtnInner
doE: 
11:	mvStack
12:	pushthis 
13:	pushText 5
15:	rswap 
16:	rstoreg 2
18:	rtnInner


Class toBase descInx: 62 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	store 2
6:	pushthis 
7:	rpushg 1
9:	pushthis 
10:	pushg 2
12:	toSuper 41
enterE: 
15:	rtnInner
doE: 
16:	mvStack
17:	pushthis 
18:	pushthis 
19:	rdouble 
20:	rpushg 1
22:	rswap 
23:	pushg 2
25:	fovpushg 1
27:	pushc 60
29:	i2f
30:	fmult 
31:	addOff 3
34:	vassign 2 0
37:	rtnInner


Class fromBase descInx: 63 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	store 2
6:	pushthis 
7:	rpushg 1
9:	pushthis 
10:	pushg 2
12:	toSuper 42
enterE: 
15:	rtnInner
doE: 
16:	mvStack
17:	pushthis 
18:	rdouble 
19:	rpushg 1
21:	rswap 
22:	pushg 2
24:	pushthis 
25:	fpushg 3
27:	pushc 60
29:	i2f
30:	fdiv 
31:	fovstoreg 1
33:	rtnInner


Class print descInx: 64 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	store 2
6:	pushthis 
7:	rpushg 1
9:	pushthis 
10:	pushg 2
12:	toSuper 44
enterE: 
15:	rtnInner
doE: 
16:	mvStack
17:	pushText 14
19:	invoke 33 0 0
25:	rpop 
26:	rtnInner


Class Minutes descInx: 65 originOff: 0 visibility: 0
allocE:
1:	toSuper 45
enterE: 
4:	rtnInner
doE: 
5:	rtnInner


Class print descInx: 66 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	store 2
6:	pushthis 
7:	rpushg 1
9:	pushthis 
10:	pushg 2
12:	toSuper 44
enterE: 
15:	rtnInner
doE: 
16:	mvStack
17:	pushText 14
19:	invoke 33 0 0
25:	rpop 
26:	rtnInner


Class MperS descInx: 67 originOff: 0 visibility: 0
allocE:
1:	toSuper 45
enterE: 
4:	rtnInner
doE: 
5:	rtnInner


Class Velocity descInx: 68 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	toSuper 48
enterE: 
10:	rtnInner
doE: 
11:	mvStack
12:	rtnInner


Class Dimensions descInx: 69 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	pushthis 
8:	invoke 50 2 1
14:	rpop 
15:	pushthis 
16:	invoke 58 3 1
22:	rpop 
23:	pushthis 
24:	invoke 59 4 1
30:	rpop 
31:	pushthis 
32:	invoke 60 5 1
38:	rpop 
39:	pushthis 
40:	invoke 68 6 1
46:	rpop 
47:	rtnEventQ 0
doE: 
49:	doEventQ 
50:	mvStack
51:	rtnEventQ 0
53:	setThisStack
54:	pushthis 
55:	rtn D


Class LIB descInx: 70 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	pushthis 
8:	invoke 8 3 1
14:	rpop 
15:	pushthis 
16:	invoke 12 4 1
22:	rpop 
23:	pushthis 
24:	invoke 39 5 1
30:	rpop 
31:	pushthis 
32:	invoke 69 6 1
38:	rpop 
39:	pushthis 
40:	invoke 16 7 1
46:	rpop 
47:	rtnEventQ 0
doE: 
49:	doEventQ 
50:	mvStack
51:	rtnEventQ 0
53:	setThisStack
54:	pushthis 
55:	rtn D


Class print descInx: 71 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	store 2
6:	pushthis 
7:	rpushg 1
9:	pushthis 
10:	pushg 2
12:	toSuper 44
enterE: 
15:	rtnInner
doE: 
16:	mvStack
17:	pushText 14
19:	invoke 33 0 0
25:	rpop 
26:	rtnInner


Class KiloGram descInx: 72 originOff: 0 visibility: 0
allocE:
1:	toSuper 45
enterE: 
4:	rtnInner
doE: 
5:	rtnInner


Class toBase descInx: 73 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	store 2
6:	pushthis 
7:	rpushg 1
9:	pushthis 
10:	pushg 2
12:	toSuper 41
enterE: 
15:	rtnInner
doE: 
16:	mvStack
17:	pushthis 
18:	pushthis 
19:	rdouble 
20:	rpushg 1
22:	rswap 
23:	pushg 2
25:	fovpushg 1
27:	pushFloatConst 9460000000000000.000000
36:	fmult 
37:	addOff 3
40:	vassign 2 0
43:	rtnInner


Class fromBase descInx: 74 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	store 2
6:	pushthis 
7:	rpushg 1
9:	pushthis 
10:	pushg 2
12:	toSuper 42
enterE: 
15:	rtnInner
doE: 
16:	mvStack
17:	pushthis 
18:	rdouble 
19:	rpushg 1
21:	rswap 
22:	pushg 2
24:	pushthis 
25:	fpushg 3
27:	pushFloatConst 9460000000000000.000000
36:	fdiv 
37:	fovstoreg 1
39:	rtnInner


Class print descInx: 75 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	store 2
6:	pushthis 
7:	rpushg 1
9:	pushthis 
10:	pushg 2
12:	toSuper 44
enterE: 
15:	rtnInner
doE: 
16:	mvStack
17:	pushText 14
19:	invoke 33 0 0
25:	rpop 
26:	rtnInner


Class LightYear descInx: 76 originOff: 0 visibility: 0
allocE:
1:	toSuper 45
enterE: 
4:	rtnInner
doE: 
5:	rtnInner


Class toBase descInx: 77 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	store 2
6:	pushthis 
7:	rpushg 1
9:	pushthis 
10:	pushg 2
12:	toSuper 41
enterE: 
15:	rtnInner
doE: 
16:	mvStack
17:	pushthis 
18:	pushthis 
19:	rdouble 
20:	rpushg 1
22:	rswap 
23:	pushg 2
25:	fovpushg 1
27:	addOff 3
30:	vassign 2 0
33:	rtnInner


Class fromBase descInx: 78 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	store 2
6:	pushthis 
7:	rpushg 1
9:	pushthis 
10:	pushg 2
12:	toSuper 42
enterE: 
15:	rtnInner
doE: 
16:	mvStack
17:	pushthis 
18:	rdouble 
19:	rpushg 1
21:	rswap 
22:	pushg 2
24:	pushthis 
25:	fpushg 3
27:	fovstoreg 1
29:	rtnInner


Class print descInx: 79 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	store 2
6:	pushthis 
7:	rpushg 1
9:	pushthis 
10:	pushg 2
12:	toSuper 44
enterE: 
15:	rtnInner
doE: 
16:	mvStack
17:	pushText 14
19:	invoke 33 0 0
25:	rpop 
26:	rtnInner


Class Second descInx: 80 originOff: 0 visibility: 0
allocE:
1:	toSuper 45
enterE: 
4:	rtnInner
doE: 
5:	rtnInner


Class newline descInx: 81 originOff: 0 visibility: 0
allocE:
1:	allocEventQ 1
3:	mvStack
4:	rtnEventQ 0
doE: 
6:	doEventQ 
7:	mvStack
8:	pushc 10
10:	%prim put 2
12:	rtnEventQ 0
14:	setThisStack
15:	pushthis 
16:	rtn D


Class LibraEx descInx: 82 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	invokeVal 67 1
12:	invokeVal 67 3
17:	invokeVal 72 5
22:	invokeVal 72 7
27:	invokeVal 76 9
32:	invokeVal 80 11
37:	invokeVal 56 13
42:	invokeVal 56 17
47:	rtnEventQ 0
doE: 
49:	doEventQ 
50:	mvStack
51:	pushthis 
52:	pushFloatConst 1000000.000000
61:	fstoreg 4
63:	pushthis 
64:	pushc 40
66:	i2f
67:	fstoreg 6
69:	pushthis 
70:	pushc2 10000
73:	i2f
74:	fstoreg 8
76:	pushthis 
77:	pushc 70
79:	i2f
80:	fstoreg 10
82:	pushText 1
84:	invoke 33 0 0
90:	rpop 
91:	pushthis 
92:	fpushg 10
94:26
95:	142
96:	vpop 
97:	pushthis 
98:	pushthis 
99:	addOff 10
102:	invoke 73 0 1
108:	pushValue 2
110:	addOff 14
113:	vassign 2 0
116:	pushText 15
118:	invoke 33 0 0
124:	rpop 
125:	pushthis 
126:	fpushg 14
128:26
129:	142
130:	vpop 
131:	invoke 81 0 0
137:	rpop 
138:	pushthis 
139:	pushthis 
140:	fpushg 6
142:	pushthis 
143:	fpushg 8
145:	fplus 
146:	pushthis 
147:	fpushg 6
149:	fdiv 
150:	fstoreg 16
152:	pushthis 
153:	fpushg 16
155:26
156:	142
157:	vpop 
158:	invoke 81 0 0
164:	rpop 
165:	pushthis 
166:	pushthis 
167:	fpushg 16
169:	%prim log 141
171:	fstoreg 16
173:	pushText 29
175:	invoke 33 0 0
181:	rpop 
182:	pushthis 
183:	fpushg 16
185:26
186:	142
187:	vpop 
188:	invoke 81 0 0
194:	rpop 
195:	pushText 37
197:	invoke 33 0 0
203:	rpop 
204:	pushthis 
205:	fpushg 4
207:26
208:	142
209:	vpop 
210:	invoke 81 0 0
216:	rpop 
217:	invoke 81 0 0
223:	rpop 
224:	pushthis 
225:	pushthis 
226:	fpushg 4
228:	pushthis 
229:	fpushg 6
231:	pushthis 
232:	fpushg 8
234:	fplus 
235:	pushthis 
236:	fpushg 6
238:	fdiv 
239:	%prim log 141
241:	fmult 
242:	fstoreg 2
244:	pushText 52
246:	invoke 33 0 0
252:	rpop 
253:	pushthis 
254:	fpushg 10
256:26
257:	142
258:	vpop 
259:	pushText 66
261:	invoke 33 0 0
267:	rpop 
268:	pushthis 
269:	fpushg 2
271:26
272:	142
273:	vpop 
274:	pushthis 
275:	pushthis 
276:	addOff 10
279:	invoke 73 0 1
285:	pushValue 2
287:	addOff 18
290:	vassign 2 0
293:	pushthis 
294:	pushthis 
295:	fpushg 18
297:	pushthis 
298:	fpushg 2
300:	fdiv 
301:	fstoreg 12
303:	pushText 81
305:	invoke 33 0 0
311:	rpop 
312:	pushthis 
313:	fpushg 12
315:26
316:	142
317:	vpop 
318:	invoke 81 0 0
324:	rpop 
325:	rtnEventQ 0
327:	setThisStack
328:	pushthis 
329:	rtn D


Class demo descInx: 83 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	pushthis 
8:	invoke 82 2 1
14:	rpop 
15:	rtnEventQ 0
doE: 
17:	doEventQ 
18:	mvStack
19:	rtnEventQ 0
21:	setThisStack
22:	pushthis 
23:	rtn D


Class workspace descInx: 84 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	pushthis 
8:	invoke 83 2 1
14:	rpop 
15:	rtnEventQ 0
doE: 
17:	doEventQ 
18:	mvStack
19:	rtnEventQ 0
21:	setThisStack
22:	pushthis 
23:	rtn D


Class BETAworld descInx: 85 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	pushthis 
7:	saveBETAworld
8:	mvStack
9:	pushthis 
10:	invoke 6 2 1
16:	rpop 
17:	pushthis 
18:	invoke 70 3 1
24:	rpop 
25:	pushthis 
26:	invoke 84 4 1
32:	rpop 
33:	rtnEventQ 0
doE: 
35:	doEventQ 
36:	mvStack
37:	rtnEventQ 0
39:	setThisStack
40:	pushthis 
41:	rtn D


Class Object descInx: 86 originOff: 2 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 2
4:	allocEventQ 1
6:	mvStack
7:	innera 1
9:	rtnEventQ 0
doE: 
11:	doEventQ 
12:	mvStack
13:	pushthis 
14:	innerP 1
16:	rpopThisObj
17:	rtnEventQ 0
19:	setThisStack
20:	pushthis 
21:	rtn D


Class do#S#87 descInx: 87 originOff: 2 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 2
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 0
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 2
14:	rpushg 4
16:	pushthis 
17:	rpushg 2
19:	rpushg 4
21:	rpushg 1
23:	rpushg 1
25:	pushthis 
26:	rpushg 2
28:	pushg 3
30:	xpushg 1 0 1
34:	storeg 2
36:	pushthis 
37:	rpushg 2
39:	rpushg 4
41:	rpushg 4
43:	pushthis 
44:	rpushg 2
46:	rpushg 4
48:	pushg 2
50:	pushthis 
51:	rpushg 2
53:	pushg 3
55:	xstoreg 1 0 1 
59:	rtnEventQ 0
61:	setThisStack
62:	pushthis 
63:	rtn D


Class do#S#89 descInx: 89 originOff: 2 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 2
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 0
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 2
14:	rpushg 4
16:	pushthis 
17:	rpushg 2
19:	rpushg 4
21:	rpushg 1
23:	rpushg 2
25:	pushthis 
26:	rpushg 2
28:	pushg 3
30:	xpushg 1 0 1
34:	storeg 2
36:	pushthis 
37:	rpushg 2
39:	rpushg 4
41:	pushthis 
42:	rpushg 2
44:	rpushg 4
46:	rpushg 1
48:	pushg 4
50:	pushthis 
51:	rpushg 2
53:	pushg 3
55:	+
56:	storeg 3
58:	pushthis 
59:	rpushg 2
61:	rpushg 4
63:	rpushg 4
65:	pushthis 
66:	rpushg 2
68:	rpushg 4
70:	pushg 2
72:	pushthis 
73:	rpushg 2
75:	rpushg 4
77:	pushg 3
79:	xstoreg 1 0 1 
83:	rtnEventQ 0
85:	setThisStack
86:	pushthis 
87:	rtn D


Class doplus descInx: 91 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	pushthis 
8:	rpushg 1
10:	pushg 4
12:	pushthis 
13:	rpushg 1
15:	rpushg 2
17:	invoke 29 0 0
23:	+
24:	pushthis 
25:	pushc 1
27:	allocIndexed 107 1 0 
32:	pushthis 
33:	rstoreg 4
35:	rtnEventQ 0
doE: 
37:	doEventQ 
38:	mvStack
39:	pushthis 
40:	invoke 92 0 1
46:	rpop 
47:	pushthis 
48:	invoke 93 0 1
54:	rpop 
55:	pushthis 
56:	rpushg 1
58:	pushthis 
59:	rpushg 4
61:	%prim asString 118
63:	rswap 
64:	rstoreg 3
66:	rtnEventQ 0
68:	setThisStack
69:	pushthis 
70:	rtn D


Class @for::to:do#S#92 descInx: 92 originOff: 4 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	pushg 4
13:	toSuper 28
enterE: 
16:	rtnInner
doE: 
17:	mvStack
18:	rtnInner


Class @for::to:do#S#93 descInx: 93 originOff: 4 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	rpushg 2
13:	invoke 29 0 0
19:	toSuper 28
enterE: 
22:	rtnInner
doE: 
23:	mvStack
24:	rtnInner


Class + descInx: 94 originOff: 1 visibility: 0
allocE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 1
9:	mvStack
10:	rtnEventQ 0
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	pushthis 
16:	rpushg 1
18:	invoke 29 0 0
24:	storeg 4
26:	pushthis 
27:	invoke 91 0 0
33:	rpop 
34:	rtnEventQ 0
36:	setThisStack
37:	pushthis 
38:	rpushg 3
40:	rtn D


Class Vstub#SquareMeter#7 descInx: 95 originOff: 0 visibility: 0
allocE:
1:	rpushg 0
3:	invoke 52 0 1
9:	rtn D


Class Vstub#Meter#4 descInx: 96 originOff: 0 visibility: 0
allocE:
1:	rpushg 0
3:	invoke 56 0 1
9:	rtn D


Class Vstub#Meter#5 descInx: 97 originOff: 0 visibility: 0
allocE:
1:	rpushg 0
3:	invoke 56 0 1
9:	rtn D


Class Vstub#Meter#6 descInx: 98 originOff: 0 visibility: 0
allocE:
1:	invoke 52 0 1
7:	rtn D


Class Vstub#S#3 descInx: 99 originOff: 1 visibility: 0
allocE:
1:	invoke 56 0 1
7:	rtn D


Class Vstub#Minutes#9 descInx: 100 originOff: 0 visibility: 0
allocE:
1:	rpushg 0
3:	invoke 65 0 1
9:	rtn D


Class Vstub#MperS#2 descInx: 101 originOff: 0 visibility: 0
allocE:
1:	rpushg 0
3:	invoke 67 0 1
9:	rtn D


Class Vstub#S#10 descInx: 102 originOff: 1 visibility: 0
allocE:
1:	invoke 56 0 1
7:	rtn D


Class Vstub#S#11 descInx: 103 originOff: 1 visibility: 0
allocE:
1:	invoke 65 0 1
7:	rtn D


Class Vstub#S#12 descInx: 104 originOff: 1 visibility: 0
allocE:
1:	invoke 67 0 1
7:	rtn D


Class Vstub#KiloGram#13 descInx: 105 originOff: 0 visibility: 0
allocE:
1:	rpushg 0
3:	invoke 72 0 1
9:	rtn D


Class Vstub#Second#8 descInx: 106 originOff: 0 visibility: 0
allocE:
1:	rpushg 0
3:	invoke 80 0 1
9:	rtn D


Class Indexed descInx: 107 originOff: 0 visibility: 0
allocE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 0
doE: 
9:	doEventQ 
10:	mvStack
11:	rtnEventQ 0
13:	setThisStack
14:	pushthis 
15:	rtn D


Class main descInx: 108 originOff: 0 visibility: 0
allocE:
1:	pushthis 
2:	invoke 85 0 1
8:	stop 


Class EventProcessor descInx: 109 originOff: 0 visibility: 0
allocE:
1:	stop 


Class ThreadStub descInx: 110 originOff: 0 visibility: 0
allocE:
doE: 
1:	call D
3:	stop 

