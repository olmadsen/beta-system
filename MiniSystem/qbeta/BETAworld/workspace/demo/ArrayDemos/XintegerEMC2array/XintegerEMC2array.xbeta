XintegerEMC2array: obj 
   int2int: 
      in i: var integer
      out V: var integer
      inner(int2int)
   intint2int: 
      in i1: var integer
      in i2: var integer
      out V: var integer
      inner(intint2int)
   Array: 
      pos: var integer
      pos := 1
      noof: var integer
      rep: ref Indexed
      put: 
         in e: var integer
         out res: ref Array
         rep.@put e :at pos
         @if pos = rep.length :then 
            pos := 1 
         :else 
            pos := pos + 1
         res := this(Array)
      get: 
         out res: var integer
         res := rep.@get pos
         @if pos = rep.length :then 
            pos := 1 
         :else 
            pos := pos + 1
      nxt: 
         out res: var integer
         @if pos = noof :then 
            res := 999999 
         :else 
            res := rep.@get pos + 1
      prv: 
         out res: var integer
         @if pos = 1 :then 
            res := 999999 
         :else 
            res := rep.@get pos - 1
      forAll: 
         current: var integer
         -- inx: ?integer, dropped this and instead use pos
         
         pos := 1
         loop: 
            current := rep.@get pos
            inner(forAll)
            @if pos < noof :then 
               @restart loop
         loop
      forAllIndex: 
         inx: var integer
         pos := 1
         inx := pos
         loop: 
            inner(forAllIndex)
            pos := pos + 1
            inx := pos
            @if pos < noof :then 
               @restart loop
         loop
      fill: forAllIndex
         in v: var integer
         rep.@put v :at inx
      sum: 
         out s: var integer
         s := 0
         forAll
            s := s + current
      iadd: forAll
         in a: ref Array
         put(current + a.get)
      equal: 
         in a: ref Array
         out b: var boolean
         b := false
         @if get = a.get :then b := true
      greaterThan: 
         --skal egentlig generere et boolean array       
         in a: ref Array
         out b: var boolean
         b := false
         forAll
            @if get > a.get :then b := true
      print:< 
         "Array(".print
         inner(print)
         "): ".print
         @for 1 :to rep.length 
         :do 
            putint(rep.@get inx)
            ", ".print
         newline
      inner(Array)
   Range: 
      in low: var integer
      in upp: var integer
      noof: obj (upp - low) + 1
      check: 
         in inx: var integer
         @if (inx < low) || (inx > upp) :then 
            "index error in range".print
      print: 
         putint(low)
         put(':')
         putint(upp)
      @if noof < 1 :then 
         "range error\n".print
   D1_Array: Array
      in R: ref Range
      noof := R.noof
      rep := Indexed(noof,integer)
      putAt: 
         in inx: var integer
         in exp: var integer
         out res: ref Array
         R.check(inx)
         rep.@put exp :at (inx - R.low) + 1
         res := this(Array)
      getAt: 
         in inx: var integer
         out res: var integer
         R.check(inx)
         res := rep.@get (inx - R.low) + 1
      copy: 
         out c: ref D1_Array
         c := D1_Array(R)
         forAll
            c.put(current)
      like: 
         out result: ref D1_Array
         result := D1_array(R)
         result.forAllIndex
            putAt(inx,getAt(inx))
      forAllDo: 
         in Do:< int2int
         out result: ref D1_Array
         result:= D1_Array(R)
         forAll
            result.rep.@put Do(current) :at pos - 1
      add: 
         -- test at de har samme range
         -- det er slik NumPy har det
         in a: ref D1_Array
         out r: ref D1_Array
         r := D1_Array(a.R)
         r.forAllIndex
            r.put(get + a.getAt(inx))
      print::< 
         R.print
      inner(D1_Array)
   D2_Array: Array
      in R1: ref Range
      in R2: ref Range
      out res: ref D2_array
      rep := indexed(R1.noof * R2.noof,integer)
      res := this(D2_Array)
      putAt: 
         in inx1: var integer
         in inx2: var integer
         in exp: var integer
         out res: ref D2_Array
         R1.check(inx1)
         R2.check(inx2)
         repPos: var integer
         repPos := (inx1 - R1.low) * R2.noof + (1 + inx2 - R2.low)
         rep.@put exp :at repPos
      getAt: 
         in inx1: var integer
         in inx2: var integer
         out exp: var integer
         R1.check(inx1)
         R2.check(inx2)
         repPos: var integer
         repPos := (inx1 - R1.low) * R2.noof + (1 + inx2 - R2.low)
         exp := rep.@get repPos
      copy: 
         out c: ref D2_Array
         c := D2_Array(R1,R2)
         forAll
            c.put(current)
      slice_1_at: 
         in index: var integer
         out res: ref D1_Array
         res := D1_Array(R2)
            i: var integer
            i := 0
            res.forAllIndex
               res.putAt(inx,getAt(index + i))
               i := i + 1
      slice_2_at: 
         in index: var integer
         out res: ref D1_Array
         res := D1_Array(R1)
            i: var integer
            i := 0
            res.forAllIndex
               res.putAt(inx,getAt(index + i))
               i := i + 1
      asD1: 
         out result: ref D1_Array
         resRange: ref Range
         resRange := Range
         resRange.low := R1.low
         resRange.upp := (R1.upp - R1.low) * (R2.upp - R2.low)
         result := D1_Array(resRange)
      forAllDo: 
         in Do:< int2int
         out result: ref D2_Array
         result:= D2_Array(R1,R2)
         forAll
            result.rep.@put Do(current) :at pos - 1
      add: 
         in a: ref D2_Array
         out r: ref D2_Array
         r := D2_Array(R1,R2)
         r.forAllIndex
            r.put(get + a.getAt(inx))
      print::< 
         R1.print
         ",".print
         R2.print
      "D2_array:".print
   D1_ArrayAdd: 
      -- antar at de to arrays har samme range, men det skal evt checkes
      in a1: ref D1_array
      in a2: ref D1_Array
      out pa: ref D1_Array
      pa := D1_Array(a1.R)
      pa.forAllIndex
         pa.put(a1.get + a2.get)
   D2_ArrayAdd: 
      -- antar at de to arrays har samme range, men det skal evt checkes
      in a1: ref D1_array
      in a2: ref D2_Array
      out pa: ref D2_Array
      pa := D2_Array(a1.R,a2.R2)
      pa.forAllIndex
         pa.put(a1.get + a2.get)
   "integerArrayStart".print