RangeList: obj 
   int2int: 
      in i: var integer
      out V: var integer
      @inner int2int
   intint2int: 
      in i1: var integer
      in i2: var integer
      out V: var integer
      @inner intint2int
      --    List(head:?elmType, tail:?List):      
      
      --       elmType:< Object
      
      --       empty-> b:?boolean: 
      
      --          b:= (head=none)
      
      --          %inner empty
      
      --       first-> r:?elmType:
      
      --          r:= head
      
      --       second-> r:?elmType:
      
      --          r:= tail.head
      
      --       scan:
      
      --          current: ?elmType
      
      --          L: ? List
      
      --          L := %this List
      
      --          current := head
      
      --          loop: 
      
      --             %inner scan
      
      --             %if L.tail <> none %then% 
      
      --                 L := tail
      
      --                 current := L.head 
      
      --                 %restart loop
      
      --          loop
      
      --       length->len:?integer:
      
      --          len:=0
      
      --          scan
      
      --             len:=len+1
      
      --	     
      
      --       %inner List
      
   IntList: 
      in head: var integer
      in tail: ref IntList
      first: 
         out r: var integer
         r := head
      second: 
         out r: var integer
         r := tail.head
      scan: 
         current: var integer
         L: ref IntList
         L := @this IntList
         current := head
         loop: 
            @inner scan
            @if L.tail <> none :then 
               L := tail
               current := L.head
               @restart loop
         loop
      length: 
         out len: var integer
         len := 0
         scan
            len := len + 1
      @inner IntList
      --    RangeList: List      
      
      --       elmType::< Range
      
      --       %inner RangeList
      
   Range: 
      in low: var integer
      in upp: var integer
      noof: obj (upp - low) + 1
      check: 
         in inx: var integer
         @if (inx < low) || (inx > upp) :then 
            "index error in range".print
            putint(inx)
            putint(low)
            putint(upp)
            newline
      print: 
         "Range: ".print
         putint(low)
         put(':')
         putint(upp)
         " noof = ".print
         putint(noof)
         newline
      @if noof < 1 :then 
         "range error\n".print
   RangeList: 
      in head: ref Range
      in tail: ref RangeList
      empty: 
         out b: var boolean
         b := (head = none)
         @inner empty
      first: 
         out r: ref Range
         r := head
      second: 
         out r: ref Range
         r := tail.head
      add: 
         in r: ref Range
         @if head = none :then 
            head := r 
         :else 
            @if tail = none :then 
               tail := RangeList(r,none) 
            :else 
               tail.add(r)
      scan: 
         current: ref Range
         L: ref RangeList
         L := @this RangeList
         current := head
         loop: 
            @inner scan
            @if L.tail <> none :then 
               L := tail
               current := L.head
               @restart loop
         loop
      length: 
         out len: var integer
         len := 0
         scan
            len := len + 1
      @inner RangeList
   rl: ref RangeList
   r: ref Range
   r1: ref Range
   r2: ref Range
   IndexDim2: 
      in index1: var integer
      in index2: var integer
      @inner IndexDim2
   anIndexDim2: ref IndexDim2
   Slice: 
      in start: var integer
      in stop: var integer
      in step: var integer
      print: 
         "Slice: ".print
         putint(start)
         put(',')
         " stop= ".print
         putint(stop)
         " step=".print
         putint(step)
         newline
   SliceList: 
      in head: ref Slice
      in tail: ref SliceList
      empty: 
         out b: var boolean
         b := (head = none)
         @inner empty
      first: 
         out r: ref Slice
         r := head
      second: 
         out r: ref Slice
         r := tail.head
      scan: 
         x: var integer
         current: ref Slice
         L: ref SliceList
         L := @this SliceList
         current := head
         loop: 
            @inner scan
            @if L.tail <> none :then 
               L := tail
               current := L.head
               @restart loop
         loop
      length: 
         out len: var integer
         len := 0
         scan
            len := len + 1
      @inner SliceList
   ArrayList: 
      in head: ref Array
      in tail: ref ArrayList
      empty: 
         out b: var boolean
         b := (head = none)
         @inner empty
      first: 
         out r: ref Array
         r := head
      second: 
         out r: ref Array
         r := tail.head
      scan: 
         x: var integer
         current: ref Array
         L: ref ArrayList
         L := @this ArrayList
         current := head
         loop: 
            @inner scan
            @if L.tail <> none :then 
               L := tail
               current := L.head
               @restart loop
         loop
      length: 
         out len: var integer
         len := 0
         scan
            len := len + 1
      @inner ArrayList
   slice1: ref Slice
   slice2: ref Slice
   slice1 := Slice(1,3,2)
   slice2 := Slice(1,5,2)
   --    slice1.print
   
   --    slice2.print
   
   sl: ref SliceList
   sl := SliceList(slice1,SliceList(slice2,none))
   putint(sl.length)
   newline
   Array: 
      --       indexedRanges: ?Indexed(ndim,Range)
      --       inx:?integer
      --       inx:=1
      --       ranges.scan
      --          indexedRanges.%put current %at% inx
      --          inx:= inx+1
      --       indexedRanges.%put ranges.first %at% 1
      --       indexedRanges.%put ranges.second %at% 2
      -- R:? Indexed(ndim, Range)
      -- R:= Indexed(ndim, Range)
      -- inx:?integer
      -- inx:=1
      -- ranges.scan
      --   R.%put current %at% inx
      --   inx:= inx+1
      -- R.%put ranges.first %at% 1
      -- R.%put ranges.second %at% 2
      in ndim: var integer
      in ranges: ref RangeList
      R1: ref Range
      R2: ref Range
      R1 := ranges.first
      @if ndim = 2 :then R2 := ranges.second
      pos: var integer
      pos := 1
      noof: var integer
      -- qcompileren ville helst ikke have denne:
      
      -- %if R2 <> none %then% noof:= R1.noof * R2.noof %else% noof:= R1.noof
      
      noof := R1.noof * R2.noof
      --       "total noof = ".print
      
      --       putint(noof)
      
      --       newline    
      
      rep: ref Indexed
      rep := Indexed(noof,integer)
      put: 
         in e: var integer
         out res: ref Array
         rep.@put e :at pos
         @if pos = rep.length :then 
            pos := 1 
         :else 
            pos := pos + 1
         res := @this Array
      plainPut: 
         in e: var integer
         rep.@put e :at pos
      get: 
         out res: var integer
         res := rep.@get pos
         @if pos = rep.length :then 
            pos := 1 
         :else 
            pos := pos + 1
      plainGet: 
         out res: var integer
         res := rep.@get pos
      nxt: 
         out res: var integer
         @if pos = noof :then 
            res := 999999 
         :else 
            res := rep.@get pos + 1
      prv: 
         out res: var integer
         @if pos = 1 :then 
            res := 999999 
         :else 
            res := rep.@get pos - 1
      putAt: 
         in inx: var integer
         in exp: var integer
         @if R2 = none :then 
            R1.check(inx)
            rep.@put exp :at (inx - R1.low) + 1 
         :else 
            "wrong number of indices".print
            newline
      getAt: 
         in inx: var integer
         out res: var integer
         @if R2 = none :then 
            R1.check(inx)
            res := rep.@get (inx - R1.low) + 1 
         :else 
            "wrong number of indices".print
            newline
      putAtAt: 
         in inx1: var integer
         in inx2: var integer
         in exp: var integer
         repPosAux: var integer
         --          "putAtAt  ".print
         
         @if R2 <> none :then 
         --             "putAtAt R2<> none  ".print
         
            R1.check(inx1)
            R2.check(inx2)
            repPos: var integer
            repPosAux := (inx1 - R1.low) * R2.noof
            repPos := repPosAux + (1 + inx2 - R2.low)
            --             "repPos=".print
            
            --             putint(repPos)
            
            --             newline
            
            rep.@put exp :at repPos
      getAtAt: 
         in inx1: var integer
         in inx2: var integer
         out exp: var integer
         repPosAux: var integer
         @if R2 <> none :then 
         --             "getAtAt ".print
         
         --             putint(inx1)
         
         --             putint(inx2)
         
            R1.check(inx1)
            R2.check(inx2)
            repPos: var integer
            repPosAux := (inx1 - R1.low) * R2.noof
            repPos := repPosAux + (1 + inx2 - R2.low)
            --             "repPos= ".print
            
            --             putint(repPos)
            
            --             newline
            
            exp := rep.@get repPos 
         :else 
            "wrong number of indices".print
            newline
      realPutAt: 
         in il: ref IntList
         in exp: var integer
         inx1: var integer
         inx2: var integer
         repPos: var integer
         @if R2 <> none :then 
            inx1 := il.first
            inx2 := il.second
            R1.check(inx1)
            R2.check(inx2)
            repPos := (inx1 - R1.low) * R2.noof
            repPos := repPos + (1 + inx2 - R2.low)
            rep.@put exp :at repPos
      realGetAt: 
         in il: ref IntList
         out exp: var integer
         inx1: var integer
         inx2: var integer
         repPos: var integer
         @if R2 <> none :then 
            inx1 := il.first
            inx2 := il.second
            R1.check(inx1)
            R2.check(inx2)
            repPos := (inx1 - R1.low) * R2.noof
            repPos := repPos + (1 + inx2 - R2.low)
            exp := rep.@get repPos
      forAll: 
         current: var integer
         -- inx: ?integer, dropped this and instead use pos
         
         pos := 1
         loop: 
            current := rep.@get pos
            @inner forAll
            @if pos < noof :then 
               pos := pos + 1
               @restart loop
         loop
      forAllDo: 
         in f:< int2int
         current: var integer
         V: var integer
         -- inx: ?integer, dropped this and instead use pos
         
         pos := 1
         loop: 
            current := rep.@get pos
            V := f(current)
            @if pos < noof :then 
               pos := pos + 1
               @restart loop
         loop
         @inner forAllDo
      mapSum: 
         in f:< int2int
         out V: var integer
         current: var integer
         -- inx: ?integer, dropped this and instead use pos
         
         pos := 1
         V := 0
         loop: 
            current := rep.@get pos
            V := V + f(current)
            @if pos < noof :then 
               pos := pos + 1
               @restart loop
         loop
         @inner mapSum
      forAllIndex: 
         index: var integer
         pos := 0
         index := pos
         loop: 
            pos := pos + 1
            index := pos
            @inner forAllIndex
            @if pos < noof :then 
               @restart loop
         loop
      forAllIndex2: 
         index1: var integer
         index2: var integer
         @if ndim = 2 :then 
            index1 := R1.low - 1
            range1Loop: 
               index1 := index1 + 1
               index2 := R2.low - 1
               range2Loop: 
                  index2 := index2 + 1
                  @inner forAllIndex2
                  @if index2 < R2.upp :then 
                     @restart range2Loop
               range2Loop
               @if index1 < R1.upp :then 
                  @restart range1Loop
            range1Loop
      fill: 
         in v: var integer
         forAllIndex
            rep.@put v :at index
      fromFunction: 
         in f:< int2int
         pos := 1
         loop: 
            plainPut(f(pos))
            @if pos < noof :then 
               pos := pos + 1
               @restart loop
         loop
         pos := 1
         @inner fromFunction
      split: 
         in size: var integer
         out al: ref ArrayList
         ra: ref Array
         rl: ref RangeList
         al := ArrayList(none,none)
         @if ndim = 1 :then 
            rl := RangeList(Range(1,size),none)
            ra := Array(1,rl)
            @if (size < noof) :then 
         @inner split
      zeroes: 
         fill(0)
      zeroesLike: 
         out r: ref Array
         r := Array(ndim,ranges)
         r.fill(0)
      ones: 
         fill(1)
      onesLike: 
         out r: ref Array
         r := Array(ndim,ranges)
         r.fill(1)
      sum: 
         out s: var integer
         s := 0
         forAll
            s := s + current
      iadd: 
         in a: ref Array
         a.pos := 1
         forAll
            plainPut(current + a.get)
      iminus: 
         in a: ref Array
         a.pos := 1
         forAll
            plainPut(current - a.get)
      imult: 
         in a: ref Array
         a.pos := 1
         forAll
            plainPut(current * a.get)
            --       idiv(a: ? Array):
            
            --          a.pos :=1
            
            --          forAll
            
            --             plainPut(current / a.get)
            
      min: 
         out V: var integer
         V := plainGet
         forAll
            @if (current < V) :then 
               V := current
      indexAtMin: 
         out index: ref IndexDim2
         V: var integer
         V := getAtAt(R1.low,R2.low)
         --          "V = ".print
         
         --          putint(V)
         
         --          newline
         
         index := IndexDim2(0,0)
         index.index1 := R1.low
         index.index2 := R2.low
         --          "indexAtMin".print
         
         --          newline	  
         
         forAllIndex2
         --             "V = ".print
         
         --             putint(getAtAt(index1,index2))
         
         --             newline	  
         
            @if (getAtAt(index1,index2) < V) :then 
               V := getAtAt(index1,index2)
               index.index1 := index1
               index.index2 := index2
      max: 
         out V: var integer
         V := plainGet
         forAll
            @if (current > V) :then 
               V := current
      equal: 
         in a: ref Array
         out b: var boolean
         b := false
         forAll
            @if plainGet = a.get :then b := true
      countNonZero: 
         out count: var integer
         count := 0
         forAll
            @if (current <> 0) :then 
               count := count + 1
      slicing: 
         in sl: ref SliceList
         out a: ref Array
         sliceDim: var integer
         currentUpp: var integer
         newUpp: var integer
         il: ref IntList
         ila: ref IntList
         first: var integer
         second: var integer
         firsta: var integer
         seconda: var integer
         sliceDim := sl.length
         @if sliceDim <> ndim :then 
            "wrong slice dimension".print
            newline
         sliceRangeList: ref Rangelist
         sliceRangeList := RangeList(none,none)
         sliceRange: ref Range
         currentSlice: ref Slice
         currentRange: ref Range
         currentSlice := sl.first
         currentRange := ranges.first
         currentUpp := currentSlice.start
         newUpp := 0
         loop1: 
            currentUpp := currentUpp + currentSlice.step
            newUpp := newUpp + 1
            @if currentUpp > currentRange.upp :then 
               @leave loop1 
            :else 
               @restart loop1
         loop1
         sliceRange := Range(currentSlice.start,newUpp)
         --          sliceRange.print
         
         --          newline	  
         
         sliceRangeList.add(sliceRange)
         currentSlice := sl.second
         currentRange := ranges.second
         currentUpp := currentSlice.start
         newUpp := 0
         loop2: 
            currentUpp := currentUpp + currentSlice.step
            newUpp := newUpp + 1
            @if currentUpp > currentRange.upp :then 
               @leave loop2 
            :else 
               @restart loop2
         loop2
         sliceRange := Range(currentSlice.start,newUpp)
         --          sliceRange.print
         
         --          newline
         
         sliceRangeList.add(sliceRange)
         a := Array(sliceDim,sliceRangeList)
         first := sl.first.start
         second := sl.second.start
         firsta := 1
         seconda := 1
         firstLoop: 
            il := IntList(first,Intlist(second,none))
            ila := IntList(firsta,IntList(seconda,none))
            a.realPutAt(ila,realGetAt(il))
            secondLoop: 
               second := second + sl.second.step
               seconda := seconda + 1
               @if second > sl.second.stop :then 
                  @leave secondLoop 
               :else 
                  il := IntList(first,Intlist(second,none))
                  ila := IntList(firsta,IntList(seconda,none))
                  a.realPutAt(ila,realGetAt(il))
                  @restart secondLoop
            secondLoop
            second := sl.second.start
            first := first + sl.first.step
            seconda := 1
            firsta := firsta + 1
            @if first > sl.first.stop :then 
               @leave firstLoop 
            :else 
               @restart firstLoop
         firstLoop
      print: 
         "Array(".print
         R1.print
         ",".print
         R2.print
         "): ".print
         newline
         "noof = ".print
         putint(noof)
         newline
         "rep.length = ".print
         putint(rep.length)
         newline
         @for 1 :to rep.length 
         :do 
            "inx=".print
            putint(inx)
            ": ".print
            putint(rep.@get inx)
            ", ".print
            newline
            --       "generating array:".print
            
            --       newline
            
            --       putint(ranges.first.low)
            
            --       "..".print
            
            --       putint(ranges.first.upp)
            
            --       newline
            
            --       putint(ranges.second.low)
            
            --       "..".print
            
            --       putint(ranges.second.upp)
            
            --       newline
            
            --       "rep.length= ".print
            
            --       putint(rep.length)
            
            --       newline
            
      @inner Array
   zeroesLike: 
      in a: ref Array
      out r: ref Array
      r := Array(a.ndim,a.ranges)
      r.fill(0)
   onesLike: 
      in a: ref Array
      out r: ref Array
      r := Array(a.ndim,a.ranges)
      r.fill(1)
      --    copyTo(dst:? Array, src:? Array):      
      
      --       src.forallIndex
      
      --          dst.putAt(index, src.getAt(index))
      
   copyTo: 
      in dst: ref Array
      in src: ref Array
      src.forallIndex
         dst.pos = dst.pos + 1
         dst.plainPut(src.plainGet)
   actualF: int2int
      V := i + 1
      "  V = ".print
      putint(V)
      newline
   actualF1: int2int
      V := i + 99
      "  V = ".print
      putint(V)
      newline
   a: ref Array
   b: ref Array
   c: ref Array
   index1: var integer
   index2: var integer
   i: var integer
   r := Range(0,0)
   a := Array(2,RangeList(Range(1,4),RangeList(Range(1,6),none)))
   b := Array(2,RangeList(Range(1,4),RangeList(Range(1,6),none)))
   a.fill(3)
   --    a.print
   
   newline
   "copyTo".print
   newline
   copyTo(b,a)
   --    b.fill(3)
   
   --    b.print
   
   "a.sum = ".print
   putint(a.sum)
   newline
   @if a.equal(b) :then 
      "a equal b".print
      newline
   a.iadd(b)
   --    "after iadd".print
   
   --    newline
   
   --    a.print
   
   --    newline
   
   a.imult(b)
   "after imult".print
   --    newline
   
   --    a.print
   
   --    newline
   
   a.iminus(b)
   --    "after iminus".print
   
   --    newline
   
   --    a.print
   
   --    newline
   
   a.putAtAt(3,5,0)
   putint(a.getAtAt(3,5))
   --    newline
   
   --    a.print
   
   --    newline
   
   --    b.print
   
   --    newline
   
   indices: ref Intlist
   indices := IntList(2,IntList(4,none))
   a.realPutAt(indices,55)
   --    putint(a.realGetAt(indices))
   
   --    newline  
   
   a.realPutAt(IntList(1,IntList(1,none)),42)
   a.realPutAt(IntList(1,IntList(3,none)),42)
   a.realPutAt(IntList(1,IntList(5,none)),42)
   a.realPutAt(IntList(3,IntList(1,none)),42)
   a.realPutAt(IntList(3,IntList(3,none)),42)
   a.realPutAt(IntList(3,IntList(5,none)),41)
   a.putAtAt(3,5,0)
   a.print
   newline
   b := a.slicing(sl)
   --    b.print
   
   --    newline
   
   a.putAtAt(3,5,0)
   newline
   putint(a.countNonZero)
   newline
   c := b.zeroesLike
   --    c.print
   
   --    newline
   
   c := b.onesLike
   --    c.print
   
   --    newline
   
   c := zeroesLike(b)
   --    c.print
   
   --    newline
   
   c := onesLike(b)
   --    c.print
   
   --    newline
   
   c.forAllDo(#actualF)
   "mapsum= ".print
   putint(c.mapSum(#actualF))
   newline
   "min= ".print
   putint(a.min)
   newline
   "max= ".print
   putint(a.max)
   newline
   a.putAtAt(1,2,0)
   a.putAtAt(1,4,99)
   a.putAtAt(1,6,99)
   a.putAtAt(2,1,99)
   a.putAtAt(3,5,0)
   a.putAtAt(1,2,99)
   anIndexDim2 := a.indexAtMin
   "index1 = ".print
   putint(anIndexDim2.index1)
   "  index2 = ".print
   putint(anIndexDim2.index2)
   a.fromFunction(#actualF1)
   --    a.print
   
   --    newline
   