integerEMC2array: =
    int2int(e: ? integer) -> val:? integer:
        %inner int2int

    intint2int(i1: ? integer, i2: ? integer) -> val:? integer:
        %inner intint2int    
  

    Array(ndim: ? integer, ranges: ?Indexed(ndim, Range)):
       pos: ?integer
       pos := 1
       noof: ?integer
       rep: ?Indexed
       put(e: ? integer) -> res: ?Array:
           rep.%put e %at% pos
           %if pos = rep.length %then%
               pos:= 1
           %else%
               pos := pos + 1
           res := %this Array
       get -> res: ? integer:
           res:= rep.%get pos
           %if pos = rep.length %then%
               pos:= 1
           %else%
               pos := pos + 1
       nxt -> res: ? integer:
           %if pos = noof %then%
               res := 999999
           %else%
               res := rep.%get pos + 1
       prv -> res: ? integer:
           %if pos = 1 %then%
               res := 999999
           %else%
               res := rep.%get pos - 1

       forAll:
          current: ? integer
          -- inx: ?integer, dropped this and instead use pos
          pos := 1          
          loop:
              current := rep.%get pos
              %inner forAll       
              %if pos < noof %then%
                  %restart loop
          loop

       forAllIndex:
          inx: ? integer 
          pos:= 1
          inx:= pos         
          loop:
              %inner forAllIndex
              pos := pos + 1 
              inx:= pos       
              %if pos < noof %then%
                  %restart loop
          loop

       fill(v:? integer):
          forAllIndex
             rep.%put v %at% inx

       zeroes:
          fill(0)

       ones:
          fill(1) 

       sum -> s:? integer:
          s:= 0
          forAll
             s:= s+current

       iadd(a: ? Array):
          forAll
             put(current + a.get)

       iminus(a: ? Array):
          forAll
             put(current - a.get)


       imult(a: ? Array):
          forAll
             put(current * a.get)


       idiv(a: ? Array):
          forAll
             put(current / a.get)


       equal(a: ? Array) -> b: ? boolean:
          b:= false       
          forAll
             %if get = a.get %then% b:= true	  


       greaterThan(a: ? Array) -> b: ? boolean:
--        skal egentlig generere et boolean array       
          b:= false
          forAll
             %if get > a.get %then% b:= true

--       nonZero -> res:? list(integer):
          -- returns a list of indeces where the array elements are not 0
--          res:= list(integer)
--          forAllIndex
--             %if get = 0 %then% %else% res.insert(inx)

       countNonZero -> count: ? integer:
             count:=0
             forAll
                %if current = 0 %then% 
                    count := count 
                %else% 
                    count:= count + 1

--       extract(condition:< boolean)-> res:? list(integer):
--          res:= list(integer)
--          forAll
--             %if condition %then% res.insert(current)
       
       
--       array_(type: ? #Object) -> res:? Array:<
          -- Returns either a new reference to self if type is ElmType 
          -- or a new array of provided data type if type is different from the current type of the array.
--          %if type = ElmType %then%
--               res := %this Array
--        %else%
--             res := Array(type)
--          %inner array_

       print:<
          "Array(".print
          %inner print
          "): ".print
          %for 1 %to% rep.length %do%
               putint(rep.%get inx)
               ", ".print
          newline
       %inner Array

    Range(low: ?integer, upp:?integer):
         noof: = (upp - low) + 1
         check(inx: ?integer):
              %if (inx < low) || (inx > upp) %then%
                   "index error in range".print
         print:
            putint(low)
            put(':')
            putint(upp)

         %if noof < 1 %then%
             "range error\n".print


    D1_Array(R: ?Range): Array  
       noof:= R.noof
       rep:= Indexed(noof, integer)
       putAt(inx: ?integer, exp: ? integer) -> res: ?Array:
          R.check(inx)
          rep.%put exp %at% (inx - R.low) + 1
          res := %this Array
       getAt(inx: ?integer) -> res: ? integer:
           R.check(inx)
           res := rep.%get (inx - R.low) + 1

       copy -> c:? D1_Array:
          c:= D1_Array(R)
          forAll
             c.put(current)

       like -> result: ? D1_Array:
          result:= D1_array(R)
          result.forAllIndex
             putAt(inx, getAt(inx))	  

          
       forAllDo(Do:< int2int) -> result: ? D1_Array:
             result: = D1_Array(R)
             forAll         
                result.rep.%put Do(current) %at% pos-1

       fromFunction(f:< int2int) -> res:?D1_Array:
          res:= D1_Array(R)
          res.forAllIndex
             res.putAt(inx, f(inx))

       add(a:? D1_Array)-> res:? D1_Array:
          -- test at de har samme range
          -- det er slik NumPy har det
          res:= D1_Array(R)
          res.forAllIndex
             res.put(get + a.getAt(inx))

--       array_(type: ?#Object) -> res:? Array::
--          res:= D1_Array(ElmType, R)


       print::<
          R.print

       %inner D1_Array


    D2_Array(R1: ?Range, R2: ?Range) -> res: ?D2_array: Array
       rep:= indexed(R1.noof * R2.noof, integer)
       res := %this D2_Array
       putAt(inx1: ?integer, inx2: ?integer, exp: ? integer) -> res: ?D2_Array:
          R1.check(inx1)
          R2.check(inx2)
          repPos: ?integer
          repPos := (inx1 - R1.low) * R2.noof + (1 + inx2 - R2.low)
          rep.%put exp %at% repPos
       getAt(inx1: ?integer, inx2: ?integer) -> exp: ? integer:
          R1.check(inx1)
          R2.check(inx2)
          repPos: ?integer
          repPos := (inx1 - R1.low) * R2.noof + (1 + inx2 - R2.low)
          exp := rep.%get repPos

       copy -> c:? D2_Array:
          c:= D2_Array(R1,R2)
          forAll
             c.put(current)

       fromFunction(f:< intint2int) -> res:?D2_Array:
         inx1: ? integer
         inx2: ? integer
         res:= D2_Array(R1, R2)	  
         inx1:=R1.low-1
         inx2:=R2.low-1
         Loop1:
            inx1:= inx1+1
            %if inx1 > R1.upp %then% %leave Loop1
               Loop2:
                  inx2:= inx2+1
                  %if inx2 > R2.upp %then% %leave Loop2
                  res.putAt(inx1, inx2, f(inx1, inx2))
              	        

       slice_1_at(index:? integer) -> res: ? D1_Array:
           res:= D1_Array(R2)
              i:?integer
              i:=0
              res.forAllIndex
                 res.putAt(inx, getAt(index+i))
                 i:=i+1

       slice_2_at(index:? integer) -> res: ? D1_Array:
           res:= D1_Array(R1)
              i:?integer
              i:=0
              res.forAllIndex
                 res.putAt(inx, getAt(index+i))
                 i:=i+1
	
  
       asD1 -> result: ? D1_Array:
          resRange: ? Range
          resRange:= Range
          resRange.low:= R1.low
          resRange.upp:= (R1.upp-R1.low)*(R2.upp-R2.low)
          result:= D1_Array(resRange)
           	   
	   

       forAllDo(Do:< int2int) -> result: ? D2_Array: 
         
          result: = D2_Array(R1,R2)
          forAll                
             result.rep.%put Do(current) %at% pos-1

       add(a:? D2_Array)-> r:? D2_Array:
          r:= D2_Array(R1, R2)
          r.forAllIndex
             r.put(get + a.getAt(inx))

--       array_(type: ?#Object) -> res:? Array::
--          res:= D2_Array(ElmType, R1, R2)

       print::<
          R1.print
          ",".print
          R2.print
	  
       "D2_array:".print


    D1_ArrayAdd (a1: ? D1_Array, a2: ? D1_Array) -> pa:? D1_Array:
       -- antar at de to arrays har samme range, men det skal evt checkes
       pa:= D1_Array(a1.R)
       pa.forAllIndex
         pa.put(a1.get + a2.get)


    D2_ArrayAdd (a1: ? D2_Array, a2: ? D2_Array) -> pa:? D2_Array:
       -- antar at de to arrays har samme range, men det skal evt checkes
       pa:= D2_Array(a1.R1, a2.R2)
       pa.forAllIndex
         pa.put(a1.get + a2.get)

    
    tRange: Indexed(2,integer)
        dummy: ?integer

    r:? tRange

    testArray(ndim: ? integer, ranges: ?Indexed(ndim*2, integer)):
       %inner testArray

    ta:?testArray

    "integerArrayStart".print
   
    --r:= 2..3
    --putint(r(1))
    newline
 
    --ta:= testArray(2, 3..5, 2..3, 3..5, 2..3)





        
