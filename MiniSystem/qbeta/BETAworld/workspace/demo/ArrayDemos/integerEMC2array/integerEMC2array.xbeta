integerEMC2array: obj 
   int2int: 
      in e: var integer
      out V: var integer
      inner(int2int)
   intint2int: 
      in i1: var integer
      in i2: var integer
      out V: var integer
      inner(intint2int)
   Array: 
      in ndim: var integer
      in ranges: ref Indexed(ndim,Range)
      pos: var integer
      pos := 1
      noof: var integer
      rep: ref Indexed
      put: 
         in e: var integer
         out res: ref Array
         rep.@put e :at pos
         @if pos = rep.length :then 
            pos := 1 
         :else 
            pos := pos + 1
         res := this(Array)
      get: 
         out res: var integer
         res := rep.@get pos
         @if pos = rep.length :then 
            pos := 1 
         :else 
            pos := pos + 1
      nxt: 
         out res: var integer
         @if pos = noof :then 
            res := 999999 
         :else 
            res := rep.@get pos + 1
      prv: 
         out res: var integer
         @if pos = 1 :then 
            res := 999999 
         :else 
            res := rep.@get pos - 1
      forAll: 
         current: var integer
         -- inx: ?integer, dropped this and instead use pos
         
         pos := 1
         loop: 
            current := rep.@get pos
            inner(forAll)
            @if pos < noof :then 
               @restart loop
         loop
      forAllIndex: 
         inx: var integer
         pos := 1
         inx := pos
         loop: 
            inner(forAllIndex)
            pos := pos + 1
            inx := pos
            @if pos < noof :then 
               @restart loop
         loop
      fill: 
         in v: var integer
         forAllIndex
            rep.@put v :at inx
      zeroes: 
         fill(0)
      ones: 
         fill(1)
      sum: 
         out s: var integer
         s := 0
         forAll
            s := s + current
      iadd: 
         in a: ref Array
         forAll
            put(current + a.get)
      iminus: 
         in a: ref Array
         forAll
            put(current - a.get)
      imult: 
         in a: ref Array
         forAll
            put(current * a.get)
      idiv: 
         in a: ref Array
         forAll
            put(current / a.get)
      equal: 
         in a: ref Array
         out b: var boolean
         b := false
         forAll
            @if get = a.get :then b := true
      greaterThan: 
      --        skal egentlig generere et boolean array       
      
         in a: ref Array
         out b: var boolean
         b := false
         forAll
            @if get > a.get :then b := true
            --       nonZero -> res:? list(integer):
            
            -- returns a list of indeces where the array elements are not 0
            
            --          res:= list(integer)
            
            --          forAllIndex
            
            --             %if get = 0 %then% %else% res.insert(inx)
            
      countNonZero: 
         out count: var integer
         count := 0
         forAll
            @if current = 0 :then 
               count := count 
            :else 
               count := count + 1
      print:< 
         "Array(".print
         inner(print)
         "): ".print
         @for 1 :to rep.length 
         :repeat 
            putint(rep.@get inx)
            ", ".print
         newline
      inner(Array)
   Range: 
      in low: var integer
      in upp: var integer
      noof: obj (upp - low) + 1
      check: 
         in inx: var integer
         @if (inx < low) || (inx > upp) :then 
            "index error in range".print
      print: 
         putint(low)
         put(':')
         putint(upp)
      @if noof < 1 :then 
         "range error\n".print
   D1_Array: Array
      in R: ref Range
      noof := R.noof
      rep := Indexed(noof,integer)
      putAt: 
         in inx: var integer
         in exp: var integer
         out res: ref Array
         R.check(inx)
         rep.@put exp :at (inx - R.low) + 1
         res := this(Array)
      getAt: 
         in inx: var integer
         out res: var integer
         R.check(inx)
         res := rep.@get (inx - R.low) + 1
      copy: 
         out c: ref D1_Array
         c := D1_Array(R)
         forAll
            c.put(current)
      like: 
         out result: ref D1_Array
         result := D1_array(R)
         result.forAllIndex
            putAt(inx,getAt(inx))
      forAllDo: 
         in DoIt:< int2int
         out result: ref D1_Array
         -- result: obj D1_Array(R) original code!?
         result := D1_Array(R)
         forAll
            result.rep.@put DoIt(current) :at pos - 1
      fromFunction: 
         in f:< int2int
         out res: ref D1_Array
         res := D1_Array(R)
         res.forAllIndex
            res.putAt(inx,f(inx))
      add: 
         -- test at de har samme range
         -- det er slik NumPy har det
         in a: ref D1_Array
         out res: ref D1_Array
         res := D1_Array(R)
         res.forAllIndex
            res.put(get + a.getAt(inx))
            --       array_(type: ?#Object) -> res:? Array::
            
            --          res:= D1_Array(ElmType, R)
            
      print::< 
         R.print
      inner(D1_Array)
   D2_Array: Array
      in R1: ref Range
      in R2: ref Range
      out res: ref D2_array
      rep := indexed(R1.noof * R2.noof,integer)
      res := this(D2_Array)
      putAt: 
         in inx1: var integer
         in inx2: var integer
         in exp: var integer
         out res: ref D2_Array
         R1.check(inx1)
         R2.check(inx2)
         repPos: var integer
         repPos := (inx1 - R1.low) * R2.noof + (1 + inx2 - R2.low)
         rep.@put exp :at repPos
      getAt: 
         in inx1: var integer
         in inx2: var integer
         out exp: var integer
         R1.check(inx1)
         R2.check(inx2)
         repPos: var integer
         repPos := (inx1 - R1.low) * R2.noof + (1 + inx2 - R2.low)
         exp := rep.@get repPos
      copy: 
         out c: ref D2_Array
         c := D2_Array(R1,R2)
         forAll
            c.put(current)
      fromFunction: 
         in f:< intint2int
         out res: ref D2_Array
         inx1: var integer
         inx2: var integer
         res := D2_Array(R1,R2)
         inx1 := R1.low - 1
         inx2 := R2.low - 1
         Loop1: 
            inx1 := inx1 + 1
            @if inx1 > R1.upp :then @leave Loop1
               Loop2: 
                  inx2 := inx2 + 1
                  @if inx2 > R2.upp :then @leave Loop2
                  res.putAt(inx1,inx2,f(inx1,inx2))
      slice_1_at: 
         in index: var integer
         out res: ref D1_Array
         res := D1_Array(R2)
            i: var integer
            i := 0
            res.forAllIndex
               res.putAt(inx,getAt(index + i))
               i := i + 1
      slice_2_at: 
         in index: var integer
         out res: ref D1_Array
         res := D1_Array(R1)
            i: var integer
            i := 0
            res.forAllIndex
               res.putAt(inx,getAt(index + i))
               i := i + 1
      asD1: 
         out result: ref D1_Array
         resRange: ref Range
         resRange := Range
         resRange.low := R1.low
         resRange.upp := (R1.upp - R1.low) * (R2.upp - R2.low)
         result := D1_Array(resRange)
      forAllDo: 
         in DoIt:< int2int
         out result: ref D2_Array
         result:= D2_Array(R1,R2)
         forAll
            result.rep.@put DoIt(current) :at pos - 1
      add: 
         in a: ref D2_Array
         out r: ref D2_Array
         r := D2_Array(R1,R2)
         r.forAllIndex
            r.put(get + a.getAt(inx))
            --       array_(type: ?#Object) -> res:? Array::
            
            --          res:= D2_Array(ElmType, R1, R2)
            
      print::< 
         R1.print
         ",".print
         R2.print
      "D2_array:".print
   D1_ArrayAdd: 
      -- antar at de to arrays har samme range, men det skal evt checkes
      in a1: ref D1_Array
      in a2: ref D1_Array
      out pa: ref D1_Array
      pa := D1_Array(a1.R)
      pa.forAllIndex
         pa.put(a1.get + a2.get)
   D2_ArrayAdd: 
      -- antar at de to arrays har samme range, men det skal evt checkes
      in a1: ref D2_Array
      in a2: ref D2_Array
      out pa: ref D2_Array
      pa := D2_Array(a1.R1,a2.R2)
      pa.forAllIndex
         pa.put(a1.get + a2.get)
   tRange: Indexed(2,integer)
      dummy: var integer
   r: ref tRange
   testArray: 
      in ndim: var integer
      in ranges: ref Indexed(ndim * 2,integer)
      inner(testArray)
   ta: ref testArray
   "integerArrayStart".print
   --r:= 2..3
   
   --putint(r(1))
   
   newline
   --ta:= testArray(2, 3..5, 2..3, 3..5, 2..3)
   