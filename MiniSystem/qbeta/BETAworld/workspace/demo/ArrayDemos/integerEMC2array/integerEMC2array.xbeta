integerEMC2array: =
    Array:
       pos: ?integer
       pos := 1
       noof: ?integer
       rep: ?Indexed
       put(e: ? integer) -> res: ?Array:
           rep.%put e %at% pos
           %if pos = rep.length %then%
               pos:= 1
           %else%
               pos := pos + 1
           res := %this Array
       get -> res: ? integer:
           res:= rep.%get pos
           %if pos = rep.length %then%
               pos:= 1
           %else%
               pos := pos + 1
       nxt -> res: ? integer:
           %if pos = noof %then%
               res := 999999
           %else%
               res := rep.%get pos + 1
       prv -> res: ? integer:
           %if pos = 1 %then%
               res := 999999
           %else%
               res := rep.%get pos - 1

       forAll:
          current: ? integer
          -- inx: ?integer, dropped this and instead use pos
          pos := 1          
          loop:
              current := rep.%get pos
              %inner forAll       
              %if pos < noof %then%
                  %restart loop
          loop

       forAllIndex:
          inx: ? integer 
          pos:= 1
          inx:= pos         
          loop:
              %inner forAllIndex
              pos := pos + 1 
              inx:= pos       
              %if pos < noof %then%
                  %restart loop
          loop

       fill(v:? integer): forAllIndex
          rep.%put v %at% inx

       sum -> s:? integer:
          s:= 0
          forAll
             s:= s+current

       iadd(a: ? Array): forAll
             put(current + a.get)

       equal(a: ? Array) -> b: ? boolean:
          b:= false       
          forAll
             %if get = a.get %then% b:= true	  


       greaterThan(a: ? Array) -> b: ? boolean:
--        skal egentlig generere et boolean array       
          b:= false
          forAll
             %if get > a.get %then% b:= true

--       nonzero -> res:? list(integer):
          -- returns a list of indeces where the array elements are not 0
--          res:= list(integer)
--          forAllIndex
--             %if get = 0 %then% %else% res.insert(inx)


--       extract(condition:< boolean)-> res:? list(integer):
--          res:= list(integer)
--          forAll
--             %if condition %then% res.insert(current)
       
       
--       array_(type: ? #Object) -> res:? Array:<
          -- Returns either a new reference to self if type is ElmType 
          -- or a new array of provided data type if type is different from the current type of the array.
--          %if type = ElmType %then%
--               res := %this Array
--        %else%
--             res := Array(type)
--          %inner array_

       print:<
          "Array(".print
          %inner print
          "): ".print
          %for 1 %to% rep.length %do%
               putint(rep.%get inx)
               ", ".print
          newline
       %inner Array

    Range(low: ?integer, upp:?integer):
         noof: = (upp - low) + 1
         check(inx: ?integer):
              %if (inx < low) || (inx > upp) %then%
                   "index error in range".print
         print:
            putint(low)
            put(':')
            putint(upp)
         %if noof < 1 %then%
             "range error\n".print



    D1_Array(R: ?Range): Array  
       noof:= R.noof
       rep:= Indexed(noof, integer)
       putAt(inx: ?integer, exp: ? ElmType) -> res: ?Array:
          R.check(inx)
          rep.%put exp %at% (inx - R.low) + 1
          res := %this Array
       getAt(inx: ?integer) -> res: ? integer:
           R.check(inx)
           res := rep.%get (inx - R.low) + 1

       copy -> c:? D1_Array:
          c:= D1_Array(R)
          forAll
             c.put(current)

       like -> result: D1_Array:
          result:= D1_array(R)
          result.forAllIndex
             putAt(inx, getAt(inx))	  
       
	     
       int2int (e: ? integer) -> val:? integer:
          i: ? integer

          
       forAllDo(Do:< int2int) -> result: ? D1_Array:
             result: = D1_Array(R)
             forAll         
                result.rep.%put Do(current) %at% pos-1

       add(a:? D1_Array)-> r:? D1_Array:
          -- test at de har samme range
          -- det er slik NumPy har det
          r:= D1_Array(R)
          r.forAllIndex
             r.put(get + a.getAt(inx))

--       array_(type: ?#Object) -> res:? Array::
--          res:= D1_Array(ElmType, R)


       print::<
          R.print
       %inner D1_Array


    D2_Array(R1: ?Range, R2: ?Range) -> res: ?D2_array: Array
        rep:= indexed(R1.noof * R2.noof, integer)
        res := %this D2_Array
        putAt(inx1: ?integer, inx2: ?integer, exp: ? integer) -> res: ?D2_Array:
           R1.check(inx1)
           R2.check(inx2)
           repPos: ?integer
           repPos := (inx1 - R1.low) * R2.noof + (1 + inx2 - R2.low)
           rep.%put exp %at% repPos
        getAt(inx1: ?integer, inx2: ?integer) -> exp: ? intger:
           R1.check(inx1)
           R2.check(inx2)
           repPos: ?integer
           repPos := (inx1 - R1.low) * R2.noof + (1 + inx2 - R2.low)
           exp := rep.%get repPos

        copy -> c:? D2_Array:
           c:= D2_Array(R1,R2)
           forAll
              c.put(current)

        slice_1_at(index:? integer) -> res: ? D1_Array:
           res:= D1_Array(R2)
              i:?integer
              i:=0
              res.forAllIndex
                 res.putAt(inx, getAt(index+i))
                 i:=i+1

        slice_2_at(index:? integer) -> res: ? D1_Array:
           res:= D1_Array(R1)
              i:?integer
              i:=0
              res.forAllIndex
                 res.putAt(inx, getAt(index+i))
                 i:=i+1
	
  
        asD1 -> result: ? D1_Array:
           resRange:= Range
           resRange.low:= R1.low
           resRange.upp:= (R1.upp-R1.low)*(R2.upp-R2.low)
           result:= D1_Array(resRange)
           	   
	   

        forAllDo(Do:< int2int) -> result: ? D2_Array: 
         
           result: = D2_Array(R1,R2)
           forAll                
              result.rep.%put Do(current) %at% pos-1

        add(a:? D2_Array)-> r:? D2_Array:
           r:= D2_Array(R1, R2)
           r.forAllIndex
              r.put(get + a.getAt(inx))

--       array_(type: ?#Object) -> res:? Array::
--          res:= D2_Array(ElmType, R1, R2)

        print::<
           R1.print
           ",".print
           R2.print
        "D2_array:".print


    D1_ArrayAdd (a1,a2: ? D1_Array) -> pa:? D1_Array:
       -- antar at de to arrays har samme range, men det skal evt checkes
       pa:= D1_Array(a1.R)
       pa.forAllIndex
         pa.put(a1.get + a2.get)


    D2_ArrayAdd (a1,a2: ? D2_Array) -> pa:? D2_Array:
       -- antar at de to arrays har samme range, men det skal evt checkes
       pa:= D2_Array(a1.R, a2.R)
       pa.forAllIndex
         pa.put(a1.get + a2.get)

    "integerArrayStart".print




        
