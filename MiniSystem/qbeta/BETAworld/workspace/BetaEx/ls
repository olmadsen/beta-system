qBETA COMPILER: BetaEx.qbeta
**** openBetaModule: ~beta/OlmEx/test/test2
**** openBetaModule: '~beta/basiclib/betaenv'
**** openBetaModule: 'private/betaenvbody'
**** openBetaModule: 'betaenv_qbetabody'
**** openBetaModule: '~beta/sysutils/envstring'
**** openBetaModule: 'private/envstringbody'
**** openBetaModule: 'envstring_defaultbody'
**** openBetaModule: 'test3'
StdBetaModule: ~beta/OlmEx/test/test2
BetaProperties: 
ORIGIN '~beta/basiclib/betaenv' 
INCLUDE 'test3' 
BetaFragments:
BetaFragment:
---program:descriptor---(#  #)BetaFragment:
---lib:attributes---
foo: (# bar: @ (# snorf: @ (# X: @ integer;
               run: (#  do 'A' -> put #) #) #) #);
remoteEx: (# RRR: @ foo do 17 -> RRR.bar.snorf.X; RRR.bar.snorf.X; run #)
**** CHECKER  ****
empty
empty
empty

**** Semantic error:
run
Did not find a declaration of: "run"

**** Semantic error:
theloop
Did not find a declaration of: "theloop"

**** Semantic error:
skip
Did not find a declaration of: "skip"

**** Semantic error:
readDigits
Did not find a declaration of: "readDigits"

**** Semantic error:
l
Did not find a declaration of: "l"

**** Semantic error:
scanLoop
Did not find a declaration of: "scanLoop"

**** Semantic error:
skipBlanks
Did not find a declaration of: "skipBlanks"

**** Semantic error:
L
Did not find a declaration of: "L"

**** Semantic error:
L
Did not find a declaration of: "L"
**** ALLOC    ****
**** SET VIRTUAL BINDINGS ****
**** SEMCHECK ****
**** RESTRICTIONS ****
**** GENERATOR ****
**** Generator: StdBeta:
BetaFragments:alloc: betaenv
**** InnerImp:alloc: inner integerValue 
(# value: @ integer do inner integerValue exit value #)
**** InnerImp:alloc: inner length 
(* returns the length of THIS(stream) *)integerValue(#  do - 1 -> value; inner length #)
**** InnerImp:alloc: inner peek 
(* looks at the next character of THIS(stream) *)(# ch: @ char do inner peek exit ch #)
**** InnerImp:alloc: inner get 
(* reads a character from THIS(stream) *)(# ch: @ char do inner get exit ch #)
**** InnerImp:alloc: inner while 
(# ch: @ char;
   value: @ boolean enter ch do true -> value; inner while exit value #)
**** InnerImp:alloc: inner booleanValue 
(# value: @ boolean do inner booleanValue exit value #)
**** InnerImp:alloc: inner scan 
(* Scan chars from current position in THIS(stream) while
 * '(ch->while)=true'; perform INNER for each char being
 * scanned
 *)

(# while:< (# ch: @ char;
        value: @ boolean enter ch do true -> value; inner while exit value #);
   ch: @ char;
   whilecondition: @ while;
   testEOS: @ EOS;
   getPeek: @ peek;
   getCh: @ get
do <<SLOT betaenvStreamScan:dopart>>
exit this(stream)[]
#)
**** InnerImp:alloc: inner scanWhiteSpace 
(*Scan whitespace characters *)scan(# while::< (#  do ch -> ascii.isWhiteSpace -> value #) do inner scanWhiteSpace exit this(stream)[] #)
**** InnerImp:alloc: inner getNonBlank 
(* Reads first non-whitespace character from THIS(stream).
 * If called at end-of-stream the character 'ascii.fs' is
 * returned
 *)

(# ch: @ char;
   skipblanks: @ scanWhiteSpace;
   testEOS: @ EOS;
   getCh: @ get
do <<SLOT betaenvStreamGetNonBlank:dopart>>
exit ch
#)
**** InnerImp:alloc: inner  
**** InnerImp:alloc: inner  
**** InnerImp:alloc: inner exception 
(# <<SLOT exceptionLib:attributes>>;
   msg: @ 
     (*append text to this 'msg' variable to specify 
      * the exception error message for
      * this(exception)
      *)
     text;
   continue: @ 
     (*the value of this variable determines the 
      * control-flow behaviour of this(exception): 
      *    true:  continue execution after exception
      *    false: terminate execution by calling
      *           'stop'; default
      *)
     boolean;
   error: 
     (*used to define local exception conditions 
      * which can be handled separately.  All error's 
      * that are not handled separately will be 
      * handled by this(exception)
      *)
     
     (# <<SLOT errorExceptionLib:attributes>>
     do false -> continue;
        inner ;
        '**** Error processing\n' -> msg.prepend;
        (if not continue then
            this(exception)
        if)
     #);
   _notify: 
     (*used to define local notification conditions
      * which can be handled separately.  All
      * 'notify's that are not handled separately
      * will be handled by this(exception)
      *)
     error
     (# <<SLOT notifyExceptionLib:attributes>>
     do true -> continue; inner 
     #);
   propagate:< 
     (*if further bound to trueObject, this(exception) allows
      * propagation (i.e. this(exception will _not_ terminate)
      This is to make exception backward compatible *)
     booleanValue;
   termCode: @ integer
do (* Arg. To pattern 'stop'; initial failureTrace *)
   <<SLOT exceptionMain:dopart>>
#)
**** InnerImp:alloc: inner streamException 
exception(#  do inner streamException #)
**** InnerImp:alloc: inner syntaxError 
streamException
(# 
do <<SLOT betaenvStreamGetIntSyntaxError:dopart>>
#)
**** InnerImp:alloc: inner getint 
(*Reads an integer: skips whitespace characters and
 * returns the following digits.
 * 
 * See numberio.bet for more numerical output operations
 *)
integerValue(# syntaxError:< streamException
     (# 
     do <<SLOT betaenvStreamGetIntSyntaxError:dopart>>
     #);
   geti: @ <<SLOT betaenvStreamGetInt:descriptor>> do geti; inner getint #)
**** InnerImp:alloc: inner getAtom 
(*Returns the next atom (i.e. sequence of non-white
 * characters - skipping leading blanks)
 *)
(# txt: ^ text do &text[] -> txt[]; inner getAtom exit txt[] #)
**** InnerImp:alloc: inner getline 
(*Reads a sequence of characters until nl-character
 * appears and returns the characters read.
 *)
(# txt: ^ text;
   missing_newline:< 
     (*Called if last line of THIS(Stream) is
      * not terminated by a newline character.
      *)
     Object do &text[] -> txt[]; inner getline exit txt[] #)
**** InnerImp:alloc: inner syntaxError 
streamException
(# 
do <<SLOT betaenvStreamAsIntSyntaxError:dopart>>
#)
**** InnerImp:alloc: inner asInt 2
(*converts THIS(text) to an integer value, ignoring
 * leading and trailing whitespace.  See numberio.bet for
 * more numerical conversion operations.
 *)

(# i: @ integer;
   syntaxError:< streamException
     (# 
     do <<SLOT betaenvStreamAsIntSyntaxError:dopart>>
     #)
do <<SLOT betaenvStreamAsIntdopart:dopart>>
exit i
#)
**** InnerImp:alloc: inner put 
(*writes a character to THIS(stream) *)(# ch: @ char enter ch do inner put exit this(stream)[] #)
**** InnerImp:alloc: inner format 
(#  do inner format #)
**** InnerImp:alloc: inner putint 
(* Writes an integer to THIS(stream); The format may be
 * controlled by the 'signed', 'blankSign', 'width',
 * 'adjustLeft' and 'zeroPadding' variable attributes.
 * 'width' is extended if it is too small.  Examples:
 * '10->putint' yields: '10'; '10*pi->putint(# do 10->width;
 * true->adjustLeft #)' yields: '10 '; and '10->putint(# do
 * 10->width; true->zeroPadding #)' yields: '0000000010'.
 * 
 * See numberio.bet for more numerical output operations
 *)

(# n: @ integer;
   signed: @ 
     (*If integer is positive, a '+' will always be
      * displayed
      *)
     boolean;
   blankSign: @ 
     (*If integer is positive, a ' ' space is displayed as
      * the sign.  Ignored if 'signed=true'
      *)
     boolean;
   width: @ (*Minimum width *)
     integer;
   adjustLeft: @ 
     (* Specifies if the number is to be aligned left or
      * right, if padding of spaces is necessary to fill up
      * the specified width.
      *)
     boolean;
   zeroPadding: @ 
     (*width is padded with leading zero instead of
      * spaces.  Ignored if 'adjustLeft=true'
      *)
     boolean;
   format:< (#  do inner format #);
   puti: @ <<SLOT betaenvStreamPutInt:descriptor>>
enter n
do 1 -> width; format; inner putint; puti
exit this(stream)[]
#)
**** InnerImp:alloc: inner puttext 
(*Writes a text to THIS(stream). *)
(# txt: ^ text
enter txt[]
do (if txt[] <>  none then
       inner puttext
   if)
exit this(stream)[]
#)
**** InnerImp:alloc: inner putline 
(* 'puttext' followed by 'newline' *)(# T: ^ text;
   putT: @ puttext;
   newL: @ newline enter T[] do inner putline; T[] -> putT; newL exit this(stream)[] #)
**** InnerImp:alloc: inner scanAtom 2
(* Scan until first non-whitespace char.  Scan the next
 * sequence of non-whitespace chars.  Stop at first
 * whitespace char.  For each non-whitespace char an INNER
 * is performed. Usage: 'scanAtom(# do ch-><destination> #)'
 *)
(# ch: @ char do <<SLOT betaenvStreamScanAtom:dopart>> exit this(stream)[] #)
**** InnerImp:alloc: inner scanToNl 2
(*Scan all chars in current line including newline char *)
(# ch: @ char;
   getCh: @ get;
   missing_newline:< 
     (* Called if last line of THIS(Stream) is
      * not terminated by a newline character.
      *)
     Object
do <<SLOT betaenvStreamScanToNl:dopart>>
exit this(stream)[]
#)
**** InnerImp:alloc: inner EOSerror 
(*Raised from 'get' and 'peek' when attempted to read past
 * the end of the stream.
 *)
streamException
(# 
do 'Attempt to read past end-of-stream' -> msg.putline; inner EOSerror
#)
**** InnerImp:alloc: inner setPos 
(* sets current position in THIS(stream) to 'p' *)(# p: @ integer enter p do inner setPos exit this(stream)[] #)
**** InnerImp:alloc: inner length 
(*Returns the length of THIS(text) *)(#  do lgth -> value; inner length #)
**** InnerImp:alloc: inner equal 
(* Tests if THIS(text) is equal to the entered text.  If
 * 'NCS' is further bound to 'trueObject', the comparison
 * will be done Non Case Sensitive.
 *)
booleanValue
(# txt: ^ text;
   NCS:< booleanObject
enter txt[]
do <<SLOT betaenvTextEqual:dopart>>
#)
**** InnerImp:alloc: inner less 
(*Tests whether the entered text 'T1[1: length]' is less
 * than 'THIS(text)[1: T1.length]'.  The lexicographical
 * ordering is used.
 *)
booleanValue(# T1: ^ text enter T1[] do <<SLOT betaenvTextLess:dopart>> #)
**** InnerImp:alloc: inner greater 
(*Tests whether the entered text 'T1[1: length]' is
 * greater than 'THIS(text)[1: T1.length]'.  The
 * lexicographical ordering is used.
 *)
booleanValue(# T1: ^ text enter T1[] do <<SLOT betaenvTextGreater:dopart>> #)
**** InnerImp:alloc: inner peek 
(*Returns the character at current position; does not
 * update 'position'
 *)
(#  do <<SLOT betaenvTextPeek:dopart>> #)
**** InnerImp:alloc: inner charValue 
(# value: @ char do inner charValue exit value #)
**** InnerImp:alloc: inner inxGet 2
(*Returns the character at position 'i' *)charValue(# i: @ integer;
   iget: @ <<SLOT betaenvTextInxGet:descriptor>> enter i do iget #)
**** InnerImp:alloc: inner getAtom 
(* Returns the next atom (i.e. sequence of non-white
 * characters - skipping leading blanks)
 *)
(#  do <<SLOT betaenvTextGetAtom:dopart>> #)
**** InnerImp:alloc: inner getline 
(*Reads a sequence of characters until nl-character
 * appears and returns the characters read.
 *)
(#  do <<SLOT betaenvTextGetLine:dopart>> #)
**** InnerImp:alloc: inner put 
(*writes the character 'ch' at current position in
 * THIS(text); increments 'position'
 *)
(#  do <<SLOT betaenvTextPut:dopart>> #)
**** InnerImp:alloc: inner inxPut 2
(*Replaces the character at position 'i' *)(# ch: @ char;
   i: @ integer;
   iput: @ <<SLOT betaenvTextInxPut:descriptor>> enter (ch,i) do iput exit this(text)[] #)
**** InnerImp:alloc: inner puttext 
(#  do <<SLOT betaenvTextPuttext:dopart>> #)
**** InnerImp:alloc: inner append 
(* Appends a text to THIS(text); does not change 'position'
 *)
(# T1: ^ text enter T1[] do <<SLOT betaenvTextAppend:dopart>> exit this(text)[] #)
**** InnerImp:alloc: inner prepend 
(*Inserts the text in 'T1' in front of THIS(text); updates
 * current position to 'position+T1.length' if 'position>0'
 *)
(# T1: ^ text enter T1[] do <<SLOT betaenvTextPrepend:dopart>> exit this(text)[] #)
**** InnerImp:alloc: inner insert 
(*Inserts a text before the character at position 'inx'.
 * Note: inx<1 means inx=1; inx>length means inx=length+1.
 * If 'position>=inx' then 'position+T1.length->position'.
 *)
(# T1: ^ text;
   inx: @ integer enter (T1[],inx) do <<SLOT betaenvTextInsert:dopart>> exit this(text)[] #)
**** InnerImp:alloc: inner delete 2
(*Deletes THIS(text)[i: j]; updates current position:
 *      i<=position<j => i-1->position
 *      j<=position   => position-(j-i+1)->position
 *)
(# i,j: @ integer;
   deleteT: @ <<SLOT betaenvTextDelete:descriptor>> enter (i,j) do deleteT exit this(text)[] #)
**** InnerImp:alloc: inner sub 2
(* Returns a copy of THIS(text)[i:j].  If 'i<1', 'i' is
 * adjusted to 1. If 'j>length', 'j' is adjusted to
 * 'length'.  If (after adjustment) 'i>j', an empty text is
 * returned.
 *)
(# i,j: @ integer;
   T1: ^ text;
   subI: @ <<SLOT betaenvTextSub:descriptor>> enter (i,j) do subI exit T1[] #)
**** InnerImp:alloc: inner copy 2
(# T1: ^ text;
   copyI: @ <<SLOT betaenvTextCopy:descriptor>> do copyI exit T1[] #)
**** InnerImp:alloc: inner scanAll 
(for i: @ ForImpItem: lgth repeat
     T[i] -> ch; inner scanAll
for)
!!!! InnerImpl:origin is not ObjectDesc: ForImp (for i: @ ForImpItem: lgth repeat
     T[i] -> ch; inner scanAll
for)
**** InnerImp:alloc: inner integerObject 
integerValue(#  enter value do inner integerObject #)
**** InnerImp:alloc: inner from 
integerObject(#  do pos -> value; inner from #)
**** InnerImp:alloc: inner find 
(for -: @ ForImpItem: lgth - inx + 1 repeat
     (if ch = ascii.private.UPCASE[T[inx] + 1] then
         inner find
     if);
     inx + 1 -> inx
for)
!!!! InnerImpl:origin is not ObjectDesc: ForImp (for -: @ ForImpItem: lgth - inx + 1 repeat
     (if ch = ascii.private.UPCASE[T[inx] + 1] then
         inner find
     if);
     inx + 1 -> inx
for)
**** InnerImp:alloc: inner find 
(for -: @ ForImpItem: lgth - inx + 1 repeat
     (if ch = T[inx] then
         inner find
     if);
     inx + 1 -> inx
for)
!!!! InnerImpl:origin is not ObjectDesc: ForImp (for -: @ ForImpItem: lgth - inx + 1 repeat
     (if ch = T[inx] then
         inner find
     if);
     inx + 1 -> inx
for)
**** InnerImp:alloc: inner findAll 
(*As 'find', except that the entire text will be searched.
 * Replaces 'findCh' in previous versions of betaenv (v1.4
 * and earlier)
 *)
find(# from:: (#  do 0 -> value #) do inner findAll #)
**** InnerImp:alloc: inner from 
integerObject(#  do pos -> value; inner from #)
!!!! BetaNameDecl:alloc not handled:  ForImp
**** InnerImp:alloc: inner findText 2
(for -: @ ForImpItem: lgth - inx - txt.lgth + 2 repeat
     L:
       
       (# 
       do (for i: @ ForImpItem: txt.lgth repeat
               (if txt.T[i] <> ascii.private.UPCASE[T[inx + i - 1] + 1] then
                   leave L
               if)
          for);
          inner findText
       #);
     inx + 1 -> inx
for)
!!!! InnerImpl:origin is not ObjectDesc: ForImp (for -: @ ForImpItem: lgth - inx - txt.lgth + 2 repeat
     L:
       
       (# 
       do (for i: @ ForImpItem: txt.lgth repeat
               (if txt.T[i] <> ascii.private.UPCASE[T[inx + i - 1] + 1] then
                   leave L
               if)
          for);
          inner findText
       #);
     inx + 1 -> inx
for)
!!!! BetaNameDecl:alloc not handled:  ForImp
**** InnerImp:alloc: inner findText 2
(for -: @ ForImpItem: lgth - inx - txt.lgth + 2 repeat
     L:
       
       (# 
       do (for i: @ ForImpItem: txt.lgth repeat
               (if txt.T[i] <> T[inx + i - 1] then
                   leave L
               if)
          for);
          inner findText
       #);
     inx + 1 -> inx
for)
!!!! InnerImpl:origin is not ObjectDesc: ForImp (for -: @ ForImpItem: lgth - inx - txt.lgth + 2 repeat
     L:
       
       (# 
       do (for i: @ ForImpItem: txt.lgth repeat
               (if txt.T[i] <> T[inx + i - 1] then
                   leave L
               if)
          for);
          inner findText
       #);
     inx + 1 -> inx
for)
**** InnerImp:alloc: inner findTextAll 
(*As 'findText', except that the entire text will be
 * searched
 *)
findText(# from:: (#  do 0 -> value #) do inner findTextAll #)
**** InnerImp:alloc: inner  
**** InnerImp:alloc: inner  
**** InnerImp:alloc: inner  
**** InnerImp:alloc: inner setpos 
(#  do <<SLOT betaenvTextSetPos:dopart>> #)
**** InnerImp:alloc: inner getPos 
(#  do pos -> value; inner getPos #)
**** InnerImp:alloc: inner  
**** InnerImp:alloc: inner _new 
**** InnerImp:alloc: inner object 
(* General superpattern *)(# _struc: 
     (* Exit a pattern reference for THIS(Object).
      * Is now obsolete: the new form obj## is preferred
      * to the old form obj.struc
      *)
     (#  exit this(object)## #);
   _new: 
     (*returns a new object, that is qualified exactly
      * as THIS(object)
      *)
     
     (# newObj: ^ object;
        oType: ##object
     do this(object)## -> oType##; &oType[] -> newObj[]; inner _new
     exit newObj[]
     #);
   _state: 
     (*Pattern _state is for experimental purpose only
      * and using it may give undefined results 
      *)
     (# S: ##object enter S## do <<SLOT betaenv_state:doPart>> #) do inner object #)
**** InnerImp:alloc: inner charObject 
charValue(#  enter value do inner charObject #)
**** InnerImp:alloc: inner wcharValue 
(# value: @ wchar do inner wcharValue exit value #)
**** InnerImp:alloc: inner wcharObject 
wcharValue(#  enter value do inner wcharObject #)
**** InnerImp:alloc: inner trueValue 
booleanValue(#  do true -> value; inner trueValue #)
**** InnerImp:alloc: inner falseValue 
booleanValue(#  do false -> value; inner falseValue #)
**** InnerImp:alloc: inner booleanObject 
booleanValue(#  enter value do inner booleanObject #)
**** InnerImp:alloc: inner trueObject 
booleanObject(#  do true -> value; inner trueObject #)
**** InnerImp:alloc: inner falseObject 
booleanObject(#  do false -> value; inner falseObject #)
**** InnerImp:alloc: inner realValue 
(# value: @ real do inner realValue exit value #)
**** InnerImp:alloc: inner realObject 
realValue(#  enter value do inner realObject #)
**** InnerImp:alloc: inner textValue 
(# value: ^ text do inner textValue exit value[] #)
**** InnerImp:alloc: inner textObject 
textValue(#  enter value[] do inner textObject #)
**** InnerImp:alloc: inner  
**** InnerImp:alloc: inner  
**** InnerImp:alloc: inner  
**** InnerImp:alloc: inner  
**** InnerImp:alloc: inner  
**** InnerImp:alloc: inner  
**** InnerImp:alloc: inner  
**** InnerImp:alloc: inner  
**** InnerImp:alloc: inner  
**** InnerImp:alloc: inner scanAtom 2
(# scanA: ^ stream.scanAtom
do (if scanA[] =  none then
       &keyboard.scanAtom(#  do inner scanAtom #)[] -> scanA[]
   if);
   scanA
#)
**** InnerImp:alloc: inner  
**** InnerImp:alloc: inner  
**** InnerImp:alloc: inner forTo 
(* for 'inx' in [low:high] do INNER forTo *)(# low,high,inx: @ integer enter (low,high) do <<SLOT betaenvForTo:dopart>> #)
**** InnerImp:alloc: inner cycle 
(* Executes INNER forever *)(#  do <<SLOT betaenvCycle:dopart>> #)
**** InnerImp:alloc: inner while 
booleanValue(#  do true -> value; inner while #)
**** InnerImp:alloc: inner loop 
(# while:< booleanValue(#  do true -> value; inner while #);
   until:< booleanValue;
   whilecondition: @ while;
   untilcondition: @ until
do <<SLOT betaenvLoop:dopart>>
#)
**** InnerImp:alloc: inner quaError 
exception
(# 
do 'Qualification error' -> msg.append; inner quaError
#)
**** InnerImp:alloc: inner qua 
(* Pattern replacing the BETA language construct QUA.  To be
 * used as 't1[]->qua(# as::< Tn #)->t2[]'.  The 'qua' pattern
 * checks, whether 't1' is qualified by 'Tn'.  If not, the
 * 'quaError' exception is invoked.  Otherwise, a reference
 * qualified by 'Tn', and referring to the same object as 't1[]'
 * is referring, is returned.
 *)

(# as:< object;
   R: ^ object;
   thisObj: ^ as;
   quaError:< exception
     (# 
     do 'Qualification error' -> msg.append; inner quaError
     #)
enter R[]
do <<SLOT betaenvQua:dopart>>
exit thisObj[]
#)
**** InnerImp:alloc: inner testchar 
booleanValue(# ch: @ char enter ch do inner testchar #)
**** InnerImp:alloc: inner get 
(# type:< object;
   obj: ^ type;
   exact:< booleanValue;
   init:< (* Called if an object was created *)
     object
do <<SLOT betaenvObjectPoolGet:dopart>>
exit obj[]
#)
**** InnerImp:alloc: inner strucGet 
(# type: ##object;
   obj: ^ object;
   exact:< booleanValue;
   init:< (* Called if an object was created *)
     object
enter type##
do <<SLOT betaenvObjectPoolStrucGet:dopart>>
exit obj[]
#)
**** InnerImp:alloc: inner scan 
(for i: @ ForImpItem: private.top repeat
     (if private.table[i].type## = type## then
         private.table[i].obj[] -> current[]; inner scan
     if)
for)
!!!! InnerImpl:origin is not ObjectDesc: ForImp (for i: @ ForImpItem: private.top repeat
     (if private.table[i].type## = type## then
         private.table[i].obj[] -> current[]; inner scan
     if)
for)
**** InnerImp:alloc: inner scan 
(for i: @ ForImpItem: private.top repeat
     (if private.table[i].type## <=  type## then
         private.table[i].obj[] -> current[]; inner scan
     if)
for)
!!!! InnerImpl:origin is not ObjectDesc: ForImp (for i: @ ForImpItem: private.top repeat
     (if private.table[i].type## <=  type## then
         private.table[i].obj[] -> current[]; inner scan
     if)
for)
**** InnerImp:alloc: inner strucScan 
(for i: @ ForImpItem: private.top repeat
     (if private.table[i].type## = type## then
         private.table[i].obj[] -> current[]; inner strucScan
     if)
for)
!!!! InnerImpl:origin is not ObjectDesc: ForImp (for i: @ ForImpItem: private.top repeat
     (if private.table[i].type## = type## then
         private.table[i].obj[] -> current[]; inner strucScan
     if)
for)
**** InnerImp:alloc: inner strucScan 
(for i: @ ForImpItem: private.top repeat
     (if private.table[i].type## <=  type## then
         private.table[i].obj[] -> current[]; inner strucScan
     if)
for)
!!!! InnerImpl:origin is not ObjectDesc: ForImp (for i: @ ForImpItem: private.top repeat
     (if private.table[i].type## <=  type## then
         private.table[i].obj[] -> current[]; inner strucScan
     if)
for)
**** InnerImp:alloc: inner put 2
(*Puts a given object into 'objectPool'. If an object with
 * (at least) the qualification of the given object is
 * already present in 'objectPool', the exception
 * 'alreadyThere' is raised.
 *)
(# obj: ^ object;
   exact:< booleanValue;
   alreadyThere:< exception;
   putObj: @ <<SLOT betaenvObjectPoolPut:descriptor>> enter obj[] do putObj #)
**** InnerImp:alloc: inner  
**** InnerImp:alloc: inner  
**** InnerImp:alloc: inner  
**** InnerImp:alloc: inner notification 
exception(#  do true -> continue; inner notification #)
**** InnerImp:alloc: inner  
**** InnerImp:alloc: inner  
**** InnerImp:alloc: inner  
**** StdBetaModule:gen: '~beta/basiclib/betaenv'
exitP none  <<SLOT betaenvInitEnv:descriptor>>
**** Using StdBeta modules

(# <<SLOT lib:attributes>>;
   
   (*****************************************************************
    The simple patterns for simple values and variables.  These
    * simple patterns are treated special by the compiler.
...
**** gen %BetaModule:  %BetaModule "~beta/OlmEx/test/test2"
**** gen %BetaModule:  %BetaModule "~beta/OlmEx/test/test2"
**** REQUIRES ****
**** EXECUTE **** 
**** alloc betaenv


No of objects: 19

