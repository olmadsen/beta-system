
 CLASS BETAworld 21 1 BETA 2
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(Object) "
 -- INV:gen: "inner(Object)" 
 -- needorigin: "inner(Object)" 
 -- needOrigin:E: "inner(Object)"  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(Object)" rec: "inner(Object)" 
 -- doNeedOrigin:Ex: "inner(Object) "originIsValueObj: false origin.isPrimitiv
 --  e: true 
 -- KUK 
 -- after:needOrigin: "inner(Object)" 
 -- doNeedOrigin:E: "inner(Object)" 
 -- computeAdrX:superAdj: 0 "inner(Object)" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(Object)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(Object) "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:
 --  - 
 --  rec:  "inner(Object) "E:  "inner(Object) "
 -- INV:gen:E.loadArgs "inner(Object) "
 -- INV:gen:after:E.loadArgs "inner(Object) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(Object) ":A
 --  dr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F o
 --  riginIsValue:F:E:"inner(Object)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(Object) "ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"inner(Object)":rec:inner(Object) 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"inner(Object)":rec:inner(Object) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"inner(Object)":rec:inner(Object) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS BETAworld 1 1 Object 21
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 pushThis 
 saveBETAworld
 mvStack 
 pushThis 
 -- before objTmpStack:add:  2   "BETA "
 invoke BETA 2 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  33   "LIB "
 invoke LIB 33 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  102   "workspace "
 invoke workspace 102 4 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS BETA 2 1 BETAworld 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: 
 --  ascii: obj 
 --     asciiFoo: 
 --        msg1:  -- obj
 --           _put('F')
 --  DI:isConst: true :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  ascii 
 -- DI:off: 2 this: 
 --  ascii: obj 
 --     asciiFoo: 
 --        msg1:  -- obj
 --           _put('F')
 --  
 --  
 pushThis 
 -- before objTmpStack:add:  3   "ascii "
 invoke ascii 3 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- DI:gen: "console: ref ConsoleIF" DI:isConst: false :isBasicValue: false :primNo: 0 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:2 objSize:3 isIndexed:0

 CLASS ascii 3 1 BETA 2
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "nl: val 10" DI:isConst: true :isBasicValue: true :primNo: 1 
 -- DI:add:BP2:  nl 
 -- OG:before:super.gen: "10 "
 -- INV:gen: "10" 
 -- needorigin: "10" 
 -- needOrigin:E: "10"  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "10" rec: "10" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "10" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "10 "E:  "10 "
 -- INV:gen:E.loadArgs "10 "
 -- INV:gen:after:E.loadArgs "10 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "10 "
 pushc 10
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 pushThis 
 storeg nl 2
 -- DI:gen: "cr: val 13" DI:isConst: true :isBasicValue: true :primNo: 1 
 -- DI:add:BP2:  cr 
 -- OG:before:super.gen: "13 "
 -- INV:gen: "13" 
 -- needorigin: "13" 
 -- needOrigin:E: "13"  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "13" rec: "13" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "13" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "13 "E:  "13 "
 -- INV:gen:E.loadArgs "13 "
 -- INV:gen:after:E.loadArgs "13 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "13 "
 pushc 13
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 pushThis 
 storeg cr 3
 -- DI:gen: "null: val 0" DI:isConst: true :isBasicValue: true :primNo: 1 
 -- DI:add:BP2:  null 
 -- OG:before:super.gen: "0 "
 -- INV:gen: "0" 
 -- needorigin: "0" 
 -- needOrigin:E: "0"  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "0" rec: "0" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "0" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "0 "E:  "0 "
 -- INV:gen:E.loadArgs "0 "
 -- INV:gen:after:E.loadArgs "0 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0 "
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 pushThis 
 storeg null 4
 -- DI:gen: "newline: var char" DI:isConst: false :isBasicValue: true :primNo: 3 
 -- DI:add:BP1:  newline 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: 
 --  newline := nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  
 pushThis 
 -- AssignmentStatement:gen: 
 --  
 --  newline := nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  right.label: "ObjectGenerator "
 --  nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  
 -- OG:before:super.gen: "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin def
 --  ault:<lf>
 --  --asciiFoo.msg1 "
 -- INV:gen: 
 --  nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  
 pushc 10
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg ascii$3 5
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0

 CLASS Value 4 0 BETA 2 isValueObj
 mvStack 
 rtnAlloc 1
DO:
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:0 isIndexed:0

 CLASS integer 5 0 BETA 2 isValueObj
 mvStack 
 -- DI:gen: "_thisBasicValue: var Universal" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  _thisBasicValue 
 rtnAlloc 1
DO:
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS universal 6 0 BETA 2 isValueObj
 mvStack 
 rtnAlloc 1
DO:
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:0 isIndexed:0

 CLASS char 7 0 BETA 2 isValueObj
 mvStack 
 -- DI:gen: "_thisBasicValue: var Universal" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  _thisBasicValue 
 rtnAlloc 1
DO:
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS ConsoleIF 8 1 BETA 2
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS put 9 1 ConsoleIF 8
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS String 10 0 StringLib 82
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:2 objSize:0 isIndexed:1

 CLASS = 11 1 Value 4
 jmpFalse  L3
 pushThis 
 -- vassign:B: Veq off: 4 size: 2 mode: 0 
 vassign  4 2 0
 jmp L4
 L3:
 invokeVal  Veq 31 3
 rpop 
 L4:
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in Veq: var this(Value)" DI:isConst: false :isBasicValue: false :primNo: 18 
 -- DI:add:BP4:  Veq 
 -- inArg: in Veq: var this(Value) 
 -- DI:gen: "out Beq: var boolean" DI:isConst: false :isBasicValue: true :primNo: 4 
 -- DI:add:BP1:  Beq 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(= ) "
 -- INV:gen: "inner(= )" 
 -- needorigin: "inner(= )" 
 -- needOrigin:E: "inner(= )"  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(= )" rec: "inner(= )" 
 -- doNeedOrigin:Ex: "inner(= ) "originIsValueObj: false origin.isPrimitive: true 
 -- KUK 
 -- after:needOrigin: "inner(= )" 
 -- doNeedOrigin:E: "inner(= )" 
 -- computeAdrX:superAdj: 0 "inner(= )" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(= )" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(= ) "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:- 
 --  rec:  "inner(= ) "E:  "inner(= ) "
 -- INV:gen:E.loadArgs "inner(= ) "
 -- INV:gen:after:E.loadArgs "inner(= ) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(= ) ":Adr:o
 --  ff:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi
 --  nIsValue:F:E:"inner(= )":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(= ) "ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"inner(= )":rec:inner(= ) 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"inner(= )":rec:inner(= ) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"inner(= )":rec:inner(= ) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0

 CLASS = 13 1 String 10
 -- vdtTableCopy: I:1:11 I:2:0
 rShiftUp  1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- super =
 pushThis 
 rpushg iOrigin 1
 rShiftDown  1
 pushThis 
 rstoreg  Veq 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in Veq: var this(Value)" DI:isConst: false :isBasicValue: false :primNo: 18 
 -- DI:add:BP4:  Veq 
 -- inArg: in Veq: var this(Value) 
 -- DI:gen: "out Beq: var boolean" DI:isConst: false :isBasicValue: true :primNo: 4 
 -- DI:add:BP1:  Beq 
DO:
 doEventQ
 mvStack 
 L1:
 pushThis 
 -- before objTmpStack:add:  14   "loop "
 invoke loop 14 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS loop 14 1 = 13
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "c1: var char" DI:isConst: false :isBasicValue: true :primNo: 3 
 -- DI:add:BP1:  c1 
 -- DI:gen: "c2: var char" DI:isConst: false :isBasicValue: true :primNo: 3 
 -- DI:add:BP1:  c2 
 -- DI:gen: "L: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  L 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "L := length" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "L := length" right.label: "ObjectGenerator ""length" 
 -- OG:before:super.gen: "length "
 -- INV:gen: "length" 
 -- needorigin: "length" 
 -- needOrigin:E: "length"  E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  Ex: "length" rec: "length" 
 -- doNeedOrigin:Ex: "length "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "length" 
 -- doNeedOrigin:E: "length" 
 -- computeAdrX:superAdj: 0 "length" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "length" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 2 isValueObj: false 
 --  origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- items:goOrigin:encOG: "= "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg =$13 1
 -- computeAdrX:isLast:E:  "length "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 --  rec:  "length "E:  "length "
 -- INV:gen:E.loadArgs "length "
 -- INV:gen:after:E.loadArgs "length "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length ":Adr:off:0 
 --  size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVa
 --  lue:F:E:"length":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- ptn:invoke: "length "E: "length "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "length" 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"length":rec:length 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:0 size:0 isFloat:F isUnitVal:F superA
 --  dj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"length":rec:length nl; adrx: :Adr:off
 --  :2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI
 --  sValue:F:E:"length":rec:length 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"length":rec:length 
 --  adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"length":rec:length 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- assign:adr.store:A: 
 storeg loop$14 4
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "if (L <> Veq.length) :then 
 --     leave(loop) "
 -- INV:gen: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  
 -- needorigin: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  
 -- needOrigin:E: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  rec: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  
 -- Ex:loadOrign:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "if (L <> Veq.length) :then 
 --     leave(loop) "E:  "if (L <> Veq.length) :then 
 --     leave(loop) "
 -- INV:gen:E.loadArgs "if (L <> Veq.length) :then 
 --     leave(loop) "
 -- INV:gen:after:E.loadArgs "if (L <> Veq.length) :then 
 --     leave(loop) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (L <> Veq.length) :then 
 --     leave(loop) "
 -- OG:before:super.gen: "(L <> Veq.length) "
 -- INV:gen: "(L <> Veq.length)" 
 -- needorigin: "(L <> Veq.length)" 
 -- needOrigin:E: "(L <> Veq.length)"  E.ATd: 
 --  <>  : 
 --     %basic 55
 --     in V: var integer
 --     out B: var boolean
 --  Ex: "(L <> Veq.length)" rec: "(L <> Veq.length)" 
 -- doNeedOrigin:Ex: "(L <> Veq.length) "originIsValueObj: true origin.isPrim
 --  itive: false 
 -- KUK 
 -- after:needOrigin: "(L <> Veq.length)" 
 -- doNeedOrigin:E: "(L <> Veq.length)" 
 -- computeAdrX:superAdj: 0 "(L <> Veq.length)" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(L <> Veq.length)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "L <> Veq.length "superAdj: 0 
 -- computeAdrX:isLast:E:  "L <> Veq.length "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "L <> Veq.length "E:  "L <> Veq.length "
 -- INV:gen:E.loadArgs "L <> Veq.length "
 -- BinaryExp:loadArgs: "L <> Veq.length" superAdj: 0 
 -- INV:gen: "L" 
 -- needorigin: "L" 
 -- needOrigin:E: "L"  E.ATd: "L: var integer" Ex: "L" rec: "L" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L" 
 -- doNeedOrigin:E: "L" 
 -- computeAdrX:superAdj: 0 "L" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "L "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 --  rec:  "L "E:  "L "
 -- INV:gen:E.loadArgs "L "
 -- INV:gen:after:E.loadArgs "L "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L ":Adr:off:4 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"L":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- DI:invoke: "L: var integer" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"L":rec:L isNotRemote: true 
 pushg 4 loop$14
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:end:off: 4 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:4 size:0 isFloat:F isUnit
 --  Val:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- NonVirt: "<> Veq.length" "ObjectInvocation_Binary" ActArg: "Veq.length "isValue: false formalArg: "in V: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "<> Veq.length " isCompositeValueObj: false 
 -- OG:before:super.gen: "Veq.length "
 -- INV:gen: "Veq.length" 
 -- needorigin: "Veq.length" 
 -- needOrigin:E: "length"  E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  Ex: "length" rec: "Veq" 
 -- doNeedOrigin:Ex: "length "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "length" 
 -- doNeedOrigin:E: "length" 
 -- computeAdrX:superAdj: 0 "Veq.length" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Veq" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- computeAdrX:En: 2 pRec: "Veq" rec: "Veq" E: "length" 
 --  A.E: none 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "Veq" rec: "Veq" E: "length" 
 --  rec.ATd: "in Veq: var this(Value)" rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --     inner(= )
 --  
 --  recA: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"length":rec:- 
 --  pRecA: none 
 -- pRec: "Veq" rec: "Veq" E: "length" 
 --  false true 
 -- computeAdrX:before:rec:: "Veq" 
 -- OI:invoke:before:ATdx.invoke: var Veq 
 -- DI:invoke: "in Veq: var this(Value)" 
 -- isValueObj:isAdr: true objSize: 2  rec "Veq ",E: "length ""ObjectInvocation_
 --  Unary "E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"length":rec:Veq 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 rpushg loop$14 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- computeAdrX:after:rec.invoke: "Veq" 
 -- computeAdrX:isLast:E:  "length "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 --  rec:  "Veq "E:  "length "
 -- INV:gen:E.loadArgs "length "
 -- INV:gen:after:E.loadArgs "length "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length ":Adr:off:2 
 --  size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVa
 --  lue:F:E:"length":rec:Veq 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- ptn:invoke: "length "E: "length "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "Veq" 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"length":rec:Veq 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:2 size:0 isFloat:F isUnitVal:F superA
 --  dj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"length":rec:Veq nl; adrx: :Adr:off:2 
 --  size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVa
 --  lue:F:E:"length":rec:Veq 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 --  adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"length":rec:Veq 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "Veq.length ":isBasicVal: true 
 -- case:B: Veq.length ObjectGenerator 1 0 0 false false 
 -- end:loadArgs:NonVirt: "<> Veq.length "
 -- BinaryExp:loadArgs:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj
 --  :0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:after:E.loadArgs "L <> Veq.length "
 --  OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:T originIsValue:F:E:"L":rec:L 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L <> Veq.length ":Adr:off:4 size:0 i
 --  sFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:
 --  "L":rec:L 
 -- BinaryExp:invoke: "L "rec: "L <> Veq.length "
 -- M: "<> Veq.length ":Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:before:ATdx.invoke: pattern <>   
 -- ptn:invoke: "<>   "E: "<> Veq.length "ptnKind: 0 useRtnV: true 
 ne
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"<> Veq.length":rec:L nl; adrx: :Adr:o
 --  ff:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi
 --  nIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"<> Veq.length":rec:L 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  18   "$18 "
 invoke $18 18 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- AssignmentStatement:gen: "beq := true" 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- AssignmentStatement:gen: 
 --  "beq := true" right.label: "ObjectGenerator ""true" 
 -- OG:before:super.gen: "true "
 -- INV:gen: "true" 
 -- needorigin: "true" 
 -- needOrigin:E: "true"  E.ATd: 
 --  True: 
 --     %globals
 --     out B: var boolean
 --     B := 1
 --  Ex: "true" rec: "true" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  %globals
 --     out B: var boolean
 --     B := 1
 --  
 -- after:needOrigin: "true" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "true "E:  "true "
 -- INV:gen:E.loadArgs "true "
 -- INV:gen:after:E.loadArgs "true "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "true "
 -- OI:invoke:before:ATdx.invoke: pattern True 
 -- ptn:invoke: "True "E: "true "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "true" 
 --  adr:none 
 invoke True 23 0 0
 -- global:pushOut: B off: 1 
 pushg 1 
 -- callInvoke:after:pushOut: 1 
 -- GeneralPTN:invoke:after:callInvoke: 1 
 -- OI:invoke:V: nl; adrx: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0
 --   isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: 
 --  adrx: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg =$13 3
 -- assign:adr.store:B: 
 pushThis 
 -- before objTmpStack:add:  30   "for:to:repeat$30 "
 invoke for:to:repeat$30 30 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS length 15 1 String 10
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "out V: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  V 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "V := get[0] -- actually an index error, accessing length" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "V := get[0] -- actually an index error, accessing length" right.label: "ObjectGenerator ""get[0] -- actually an index error, accessing length" 
 -- OG:before:super.gen: "get[0] -- actually an index error, accessing length
 --   "
 -- INV:gen: "get[0] -- actually an index error, accessing length" 
 -- needorigin: "get[0] -- actually an index error, accessing length" 
 -- needOrigin:E: "get[0] -- actually an index error, accessing length"  E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  Ex: "get[0] -- actually an index error, accessing length" rec: "get[0] -- actually an index error, accessing length" 
 -- doNeedOrigin:Ex: "get[0] -- actually an index error, accessing length "or
 --  iginIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "get[0] -- actually an index error, accessing length" 
 -- doNeedOrigin:E: "get[0] -- actually an index error, accessing length" 
 -- computeAdrX:superAdj: 0 "get[0] -- actually an index error, accessing length" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "get[0] -- actually an index error, accessing length" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "length "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg length$15 1
 -- computeAdrX:isLast:E:  "get[0] -- actually an index error, accessing leng
 --  th "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually 
 --  an index error, accessing length":rec:- 
 --  rec:  "get[0] -- actually an index error, accessing length "E:  "get[0] -- 
 --  actually an index error, accessing length "
 -- INV:gen:E.loadArgs "get[0] -- actually an index error, accessing length "
 -- NonVirt: "get[0] -- actually an index error, accessing length" "ObjectInvocation_KeyWord" ActArg: "0 "isValue: true formalArg: "inx: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[0] -- actually an index error, accessin
 --  g length " isCompositeValueObj: false 
 -- OG:before:super.gen: "0 "
 -- INV:gen: "0" 
 -- needorigin: "0" 
 -- needOrigin:E: "0"  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "0" rec: "0" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "0" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "0 "E:  "0 "
 -- INV:gen:E.loadArgs "0 "
 -- INV:gen:after:E.loadArgs "0 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0 "
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "inx: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "0 ":isBasicVal: true 
 -- case:B: 0 ObjectGenerator 1 1 1 false true 
 -- end:loadArgs:NonVirt: "get[0] -- actually an index error, accessing lengt
 --  h "
 -- INV:gen:after:E.loadArgs "get[0] -- actually an index error, accessing le
 --  ngth "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[0] -- actuall
 --  y an index error, accessing length ":Adr:off:0 size:0 isFloat:F isUnitV
 --  al:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actua
 --  lly an index error, accessing length":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- ptn:invoke: "get[inx: var integer] "E: "get[0] -- actually an index error, 
 --  accessing length "ptnKind: 0 useRtnV: true 
 xpushg  inx 1 0 1
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, 
 --  accessing length":rec:get[0] -- actually an index error, accessing leng
 --  th 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, 
 --  accessing length":rec:get[0] -- actually an index error, accessing leng
 --  th 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error,
 --   accessing length":rec:get[0] -- actually an index error, accessing len
 --  gth 
 -- assign:adr.store:A: 
 storeg length$15 2
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS this 31 1 BETA 2
 pushThis 
 rstoreg  this 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in this: ref Object" DI:isConst: false :isBasicValue: false :primNo: 64 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS X_asString 32 1 Object 21
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "out S: var LIB.StringLib.String" DI:isConst: false :isBasicValue: false :primNo: 5 
 -- StringVar "out S: var LIB.StringLib.String "
 pushText ""
 pushThis 
 rstoreg  S 2
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(X_asString) "
 -- INV:gen: "inner(X_asString)" 
 -- needorigin: "inner(X_asString)" 
 -- needOrigin:E: "inner(X_asString)"  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(X_asString)" rec: "inner(X_asString)" 
 -- doNeedOrigin:Ex: "inner(X_asString) "originIsValueObj: false origin.isPrim
 --  itive: false 
 -- KUK 
 -- after:needOrigin: "inner(X_asString)" 
 -- doNeedOrigin:E: "inner(X_asString)" 
 -- computeAdrX:superAdj: 0 "inner(X_asString)" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(X_asString)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(X_asString) "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":
 --  rec:- 
 --  rec:  "inner(X_asString) "E:  "inner(X_asString) "
 -- INV:gen:E.loadArgs "inner(X_asString) "
 -- INV:gen:after:E.loadArgs "inner(X_asString) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(X_asString)
 --   ":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue
 --  :F originIsValue:F:E:"inner(X_asString)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(X_asString) "ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:inner(X_asSt
 --  ring) 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:inner(X_asSt
 --  ring) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:inner(X_asS
 --  tring) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS LIB 33 1 BETAworld 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 pushThis 
 -- before objTmpStack:add:  34   "BasicIO "
 invoke BasicIO 34 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  38   "Dimensions "
 invoke Dimensions 38 4 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  82   "StringLib "
 invoke StringLib 82 5 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- DI:gen: "x_dummy_LIB: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  x_dummy_LIB 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0

 CLASS BasicIO 34 1 LIB 33
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: 
 --  keyboard: obj 
 --     %Public
 --     readLine: 
 --        out M: var LIB.StringLib.String
 --  DI:isConst: true :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  keyboard 
 -- DI:off: 2 this: 
 --  keyboard: obj 
 --     %Public
 --     readLine: 
 --        out M: var LIB.StringLib.String
 --  
 --  
 pushThis 
 -- before objTmpStack:add:  35   "keyboard "
 invoke keyboard 35 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- DI:gen: 
 --  screen: obj 
 --     L: obj Lock
 --     %Public
 --     init: 
 --  DI:isConst: true :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  screen 
 -- DI:off: 3 this: 
 --  screen: obj 
 --     L: obj Lock
 --     %Public
 --     init: 
 --  
 --  
 pushThis 
 -- before objTmpStack:add:  36   "screen "
 invoke screen 36 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS keyboard 35 1 BasicIO 34
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS screen 36 1 BasicIO 34
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "L: obj Lock" DI:isConst: true :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  L 
 -- DI:off: 2 this: "L: obj Lock" 
 --  
 -- OG:before:super.gen: "Lock "
 -- INV:gen: "Lock" 
 -- needorigin: "Lock" 
 -- needOrigin:E: "Lock"  E.ATd: 
 --  Lock: 
 --     dummy: var integer
 --     %Public
 --     M: var integer
 --  Ex: "Lock" rec: "Lock" 
 -- doNeedOrigin:Ex: "Lock "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "Lock" 
 -- doNeedOrigin:E: "Lock" 
 -- computeAdrX:superAdj: 0 "Lock" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Lock" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "screen "on: 1 isValueObj: false 
 --  origin: BasicIO origin:isValueObj: false 
 rpushg screen$36 1
 -- computeAdrX:isLast:E:  "Lock "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:- 
 --  rec:  "Lock "E:  "Lock "
 -- INV:gen:E.loadArgs "Lock "
 -- INV:gen:after:E.loadArgs "Lock "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "Lock ":Adr:off:0 si
 --  ze:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValu
 --  e:F:E:"Lock":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern Lock 
 -- ptn:invoke: "Lock "E: "Lock "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 2 rec: "Lock" 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"Lock":rec:Lock 
 invoke Lock 37 2 1
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"Lock":rec:Lock nl; adrx: :Adr:off:-1 
 --  size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVa
 --  lue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"Lock":rec:Lock 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"Lock":rec:Lock 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS Lock 37 1 BasicIO 34
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "dummy: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  dummy 
 -- DI:gen: "M: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  M 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS Dimensions 38 1 LIB 33
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 pushThis 
 -- before objTmpStack:add:  66   "Area "
 invoke Area 66 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  72   "Length "
 invoke Length 72 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS Dimension 39 1 Dimensions 38
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(Dimension) "
 -- INV:gen: "inner(Dimension)" 
 -- needorigin: "inner(Dimension)" 
 -- needOrigin:E: "inner(Dimension)"  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(Dimension)" rec: "inner(Dimension)" 
 -- doNeedOrigin:Ex: "inner(Dimension) "originIsValueObj: false origin.isPrimi
 --  tive: false 
 -- KUK 
 -- after:needOrigin: "inner(Dimension)" 
 -- doNeedOrigin:E: "inner(Dimension)" 
 -- computeAdrX:superAdj: 0 "inner(Dimension)" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(Dimension)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(Dimension) "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Dimension)":r
 --  ec:- 
 --  rec:  "inner(Dimension) "E:  "inner(Dimension) "
 -- INV:gen:E.loadArgs "inner(Dimension) "
 -- INV:gen:after:E.loadArgs "inner(Dimension) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(Dimension) ":
 --  Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F 
 --  originIsValue:F:E:"inner(Dimension)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(Dimension) "ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  8
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"inner(Dimension)":rec:inner(Dimensi
 --  on) 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"inner(Dimension)":rec:inner(Dimensi
 --  on) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"inner(Dimension)":rec:inner(Dimens
 --  ion) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS PrimaryUnit#44 44 1 Dimension$39 39 isVstub
 invoke Unit 40 0 1
 pushThis 
 rstoreg   2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS MultArgL#45 45 1 Dimension$39 39 isVstub
 invoke Unit 40 0 1
 pushThis 
 rstoreg   2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS MultArgR#46 46 1 Dimension$39 39 isVstub
 invoke Unit 40 0 1
 pushThis 
 rstoreg   2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS MultRes#47 47 1 Dimension$39 39 isVstub
 invoke Unit 40 0 1
 pushThis 
 rstoreg   2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS Unit 40 0 Dimension 39 isValueObj
 mvStack 
 -- DI:gen: "magnitude: var Float" DI:isConst: false :isBasicValue: true :primNo: 9 
 -- DI:add:BP1:  magnitude 
 rtnAlloc 1
DO:
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS float 48 0 BETA 2 isValueObj
 mvStack 
 -- DI:gen: "_thisBasicValue: var Float" DI:isConst: false :isBasicValue: true :primNo: 9 
 -- DI:add:BP1:  _thisBasicValue 
 rtnAlloc 1
DO:
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS toPrimary 49 1 Unit 40
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "out base: var PrimaryUnit" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  base 
 -- DI:off: 2 this: "out base: var PrimaryUnit" 
 --  
 -- OG:before:super.gen: "PrimaryUnit "
 -- INV:gen: "PrimaryUnit" 
 -- needorigin: "PrimaryUnit" 
 -- needOrigin:E: "PrimaryUnit"  E.ATd: "PrimaryUnit:< Unit" Ex: "PrimaryUnit" rec: "PrimaryUnit" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 --  
 -- after:needOrigin: "PrimaryUnit" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "PrimaryUnit "E:  "PrimaryUnit "
 -- INV:gen:E.loadArgs "PrimaryUnit "
 -- INV:gen:after:E.loadArgs "PrimaryUnit "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "PrimaryUnit "
 -- OI:invoke:before:ATdx.invoke: pattern PrimaryUnit 
 -- ptn:invoke: "PrimaryUnit "E: "PrimaryUnit "ptnKind: 1 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 1 staticOff: 2 rec: "PrimaryUnit" 
 --  adr:none 
 invokeVal  PrimaryUnit 40 1
 rpop 
 -- OI:invoke:V: nl; adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0
 --   isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(toPrimary) "
 -- INV:gen: "inner(toPrimary)" 
 -- needorigin: "inner(toPrimary)" 
 -- needOrigin:E: "inner(toPrimary)"  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(toPrimary)" rec: "inner(toPrimary)" 
 -- doNeedOrigin:Ex: "inner(toPrimary) "originIsValueObj: false origin.isPrimi
 --  tive: false 
 -- KUK 
 -- after:needOrigin: "inner(toPrimary)" 
 -- doNeedOrigin:E: "inner(toPrimary)" 
 -- computeAdrX:superAdj: 0 "inner(toPrimary)" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(toPrimary)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(toPrimary) "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(toPrimary)":r
 --  ec:- 
 --  rec:  "inner(toPrimary) "E:  "inner(toPrimary) "
 -- INV:gen:E.loadArgs "inner(toPrimary) "
 -- INV:gen:after:E.loadArgs "inner(toPrimary) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(toPrimary) ":
 --  Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F 
 --  originIsValue:F:E:"inner(toPrimary)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(toPrimary) "ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"inner(toPrimary)":rec:inner(toPrima
 --  ry) 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"inner(toPrimary)":rec:inner(toPrima
 --  ry) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"inner(toPrimary)":rec:inner(toPrim
 --  ary) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS fromPrimary 50 1 Unit 40
 jmpFalse  L3
 pushThis 
 -- vassign:B: base off: 2 size: 2 mode: 0 
 vassign  2 2 0
 jmp L4
 L3:
 invokeVal  base 40 1
 rpop 
 L4:
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in base: var PrimaryUnit" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  base 
 -- inArg: in base: var PrimaryUnit 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(fromPrimary) "
 -- INV:gen: "inner(fromPrimary)" 
 -- needorigin: "inner(fromPrimary)" 
 -- needOrigin:E: "inner(fromPrimary)"  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(fromPrimary)" rec: "inner(fromPrimary)" 
 -- doNeedOrigin:Ex: "inner(fromPrimary) "originIsValueObj: false origin.isPri
 --  mitive: false 
 -- KUK 
 -- after:needOrigin: "inner(fromPrimary)" 
 -- doNeedOrigin:E: "inner(fromPrimary)" 
 -- computeAdrX:superAdj: 0 "inner(fromPrimary)" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(fromPrimary)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(fromPrimary) "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(fromPrimary)"
 --  :rec:- 
 --  rec:  "inner(fromPrimary) "E:  "inner(fromPrimary) "
 -- INV:gen:E.loadArgs "inner(fromPrimary) "
 -- INV:gen:after:E.loadArgs "inner(fromPrimary) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(fromPrimary
 --  ) ":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValu
 --  e:F originIsValue:F:E:"inner(fromPrimary)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(fromPrimary) "ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"inner(fromPrimary)":rec:inner(fromP
 --  rimary) 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"inner(fromPrimary)":rec:inner(fromP
 --  rimary) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"inner(fromPrimary)":rec:inner(from
 --  Primary) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS print 51 1 Unit 40
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: ""Unit:".print "
 -- INV:gen: ""Unit:".print" 
 -- needorigin: ""Unit:".print" 
 -- needOrigin:E: "print"  E.ATd: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeat
 --  Ex: ""Unit:"" rec: ""Unit:"" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 --  
 -- after:needOrigin: ""Unit:"" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  ""Unit:" "E:  ""Unit:" "
 -- INV:gen:E.loadArgs ""Unit:" "
 -- INV:gen:after:E.loadArgs ""Unit:" "
 --  OIadr: 
 pushText "Unit:"
 -- IV:gen:checkTail: ""Unit:".print "E: ""Unit:" "tail: "print " not isLast: false 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: ""Unit:"" 
 --  adr:none 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: nl; adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:
 --  0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- OG:before:super.gen: "inner(print) "
 -- INV:gen: "inner(print)" 
 -- needorigin: "inner(print)" 
 -- needOrigin:E: "inner(print)"  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(print)" rec: "inner(print)" 
 -- doNeedOrigin:Ex: "inner(print) "originIsValueObj: false origin.isPrimitive
 --  : false 
 -- KUK 
 -- after:needOrigin: "inner(print)" 
 -- doNeedOrigin:E: "inner(print)" 
 -- computeAdrX:superAdj: 0 "inner(print)" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(print)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(print) "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(print)":rec:-
 --   
 --  rec:  "inner(print) "E:  "inner(print) "
 -- INV:gen:E.loadArgs "inner(print) "
 -- INV:gen:after:E.loadArgs "inner(print) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(print) ":Ad
 --  r:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F or
 --  iginIsValue:F:E:"inner(print)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(print) "ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"inner(print)":rec:inner(print) 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"inner(print)":rec:inner(print) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"inner(print)":rec:inner(print) 
 -- OG:before:super.gen: "put(':') "
 -- INV:gen: "put(':')" 
 -- needorigin: "put(':')" 
 -- needOrigin:E: "put(':')"  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put(':')" rec: "put(':')" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put(':')" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put(':') "E:  "put(':') "
 -- INV:gen:E.loadArgs "put(':') "
 -- NonVirt: "put(':')" "ObjectInvocation_KeyWord" ActArg: "':' "isValue: true formalArg: "in ch: val char" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(':') " isCompositeValueObj: false 
 -- OG:before:super.gen: "':' "
 -- INV:gen: "':'" 
 -- needorigin: "':'" 
 -- needOrigin:E: "':'"  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  Ex: "':'" rec: "':'" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  
 -- after:needOrigin: "':'" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "':' "E:  "':' "
 -- INV:gen:E.loadArgs "':' "
 -- INV:gen:after:E.loadArgs "':' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "':' "
 pushc 58
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "':' ":isBasicVal: true 
 -- case:B: ':' ObjectGenerator 3 3 3 false true 
 -- end:loadArgs:NonVirt: "put(':') "
 -- INV:gen:after:E.loadArgs "put(':') "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(':') "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put(':') "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- OG:before:super.gen: "putFloat(magnitude) "
 -- INV:gen: "putFloat(magnitude)" 
 -- needorigin: "putFloat(magnitude)" 
 -- needOrigin:E: "putFloat(magnitude)"  E.ATd: 
 --  putFloat: 
 --     %basic 142
 --     in X: var Float
 --     out V: var integer
 --  Ex: "putFloat(magnitude)" rec: "putFloat(magnitude)" 
 -- doNeedOrigin:Ex: "putFloat(magnitude) "originIsValueObj: false origin.isPr
 --  imitive: false 
 -- KUK 
 -- after:needOrigin: "putFloat(magnitude)" 
 -- doNeedOrigin:E: "putFloat(magnitude)" 
 -- computeAdrX:superAdj: 0 "putFloat(magnitude)" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "putFloat(magnitude)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "putFloat(magnitude) "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putFloat(magnitude)
 --  ":rec:- 
 --  rec:  "putFloat(magnitude) "E:  "putFloat(magnitude) "
 -- INV:gen:E.loadArgs "putFloat(magnitude) "
 -- NonVirt: "putFloat(magnitude)" "ObjectInvocation_KeyWord" ActArg: "magnitude "isValue: false formalArg: "in X: var Float" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "putFloat(magnitude) " isCompositeValueObj: false 
 -- OG:before:super.gen: "magnitude "
 -- INV:gen: "magnitude" 
 -- needorigin: "magnitude" 
 -- needOrigin:E: "magnitude"  E.ATd: "magnitude: var Float" Ex: "magnitude" rec: "magnitude" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "magnitude" 
 -- doNeedOrigin:E: "magnitude" 
 -- computeAdrX:superAdj: 0 "magnitude" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "magnitude" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "print "on: 1 isValueObj: false 
 --  origin: Unit origin:isValueObj: true 
 rpushg print$51 1
 -- computeAdrX:isLast:E:  "magnitude "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:1 size:0 isFloat:T isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 --  rec:  "magnitude "E:  "magnitude "
 -- INV:gen:E.loadArgs "magnitude "
 -- INV:gen:after:E.loadArgs "magnitude "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude ":Adr:off
 --  :1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originI
 --  sValue:T:E:"magnitude":rec:- 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- DI:invoke: "magnitude: var Float" 
 -- load: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:T:E:"magnitude":rec:magnitude isNotRemote: true 
 -- load:isValue:E: "magnitude "originIsValue: true E.ATd:isValueObj: true 
 -- E.ATd: "magnitude: var Float" 
 --  E.ATd.origin: 
 --  %unit "U", 1
 --  %public
 --  magnitude: var Float
 --  thisUnit:< Unit
 --  
 --  (E.ATd.origin.ogOfScope): 
 --  Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 --  
 fvpushg 1 Unit$40
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- INV:gen:end:off: 1 
 -- OG:gen:end: OIadr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- actualArg:isPtn: false formalArg:isPtn: "in X: var Float ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "magnitude ":isBasicVal: true 
 -- case:B: magnitude ObjectGenerator 9 0 9 false false 
 -- end:loadArgs:NonVirt: "putFloat(magnitude) "
 -- INV:gen:after:E.loadArgs "putFloat(magnitude) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "putFloat(magnitud
 --  e) ":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVal
 --  ue:F originIsValue:F:E:"putFloat(magnitude)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern putFloat 
 -- ptn:invoke: "putFloat "E: "putFloat(magnitude) "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "putFloat(magnitude)" 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"putFloat(magnitude)":rec:putFloat(magnitude) 
 %printf_prim 142
 vpop
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"putFloat(magnitude)":rec:putFloat(m
 --  agnitude) nl; adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"putFloat(magnitude)":rec:putFloat(m
 --  agnitude) 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"putFloat(magnitude)":rec:putFloat(
 --  magnitude) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS print 52 1 String 10
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 pushThis 
 -- before objTmpStack:add:  55   "for:to:repeat$55 "
 invoke for:to:repeat$55 55 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS for:to:repeat 28 0 BETA 2
 pushThis 
 storeg integer$5 2
 pushThis 
 storeg integer$5 1
 allocEventQ
 mvStack 
 -- DI:gen: "inx: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  inx 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "inx := first" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "inx := first" right.label: "ObjectGenerator ""first" 
 -- OG:before:super.gen: "first "
 -- INV:gen: "first" 
 -- needorigin: "first" 
 -- needOrigin:E: "first"  E.ATd: "first: var integer" Ex: "first" rec: "first" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "first" 
 -- doNeedOrigin:E: "first" 
 -- computeAdrX:superAdj: 0 "first" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "first" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "first "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:1 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:- 
 --  rec:  "first "E:  "first "
 -- INV:gen:E.loadArgs "first "
 -- INV:gen:after:E.loadArgs "first "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "first ":Adr:off:1 s
 --  ize:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsVal
 --  ue:F:E:"first":rec:- 
 -- OI:invoke:before:ATdx.invoke: var first 
 -- DI:invoke: "first: var integer" 
 -- load: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"first":rec:first isNotRemote: true 
 pushg 1 for:to:repeat$28
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"first":rec:first 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"first":rec:first 
 -- INV:gen:end:off: 1 
 -- OG:gen:end: OIadr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"first":rec:first 
 -- assign:adr.store:A: 
 storeg for:to:repeat$28 3
 -- assign:adr.store:B: 
 pushThis 
 -- before objTmpStack:add:  57   "_doIt "
 invoke _doIt 57 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:1 objSize:3 isIndexed:0

 CLASS repeat#29 29 0 for:to:repeat$28 28 isVstub
 invoke Object 21 0 0
 pushThis 
 rstoreg   2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:1 objSize:3 isIndexed:0

 CLASS _doIt 57 1 for:to:repeat 28
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  :else 
 --     inx := inx "
 -- INV:gen: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  
 -- needorigin: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  
 -- needOrigin:E: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  rec: 
 --  if (inx <= last) :then 
 --     repeat
 -- \
 --      inx := inx + 1
 --     restart(_doIt)
 --  
 -- Ex:loadOrign:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  :else 
 --     inx := inx "E:  "if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  :else 
 --     inx := inx "
 -- INV:gen:E.loadArgs "if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  :else 
 --     inx := inx "
 -- INV:gen:after:E.loadArgs "if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  :else 
 --     inx := inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThenElse "if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  :else 
 --     inx := inx "
 -- OG:before:super.gen: "(inx <= last) "
 -- INV:gen: "(inx <= last)" 
 -- needorigin: "(inx <= last)" 
 -- needOrigin:E: "(inx <= last)"  E.ATd: 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  Ex: "(inx <= last)" rec: "(inx <= last)" 
 -- doNeedOrigin:Ex: "(inx <= last) "originIsValueObj: true origin.isPrimitiv
 --  e: false 
 -- KUK 
 -- after:needOrigin: "(inx <= last)" 
 -- doNeedOrigin:E: "(inx <= last)" 
 -- computeAdrX:superAdj: 0 "(inx <= last)" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(inx <= last)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "inx <= last "superAdj: 0 
 -- computeAdrX:isLast:E:  "inx <= last "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "inx <= last "E:  "inx <= last "
 -- INV:gen:E.loadArgs "inx <= last "
 -- BinaryExp:loadArgs: "inx <= last" superAdj: 0 
 -- INV:gen: "inx" 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" Ex: "inx" rec: "inx" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx" 
 -- doNeedOrigin:E: "inx" 
 -- computeAdrX:superAdj: 0 "inx" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "_doIt "on: 1 isValueObj: false 
 --  origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$57 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx ":Adr:off:3 siz
 --  e:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue
 --  :F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 3 for:to:repeat$28
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnit
 --  Val:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- NonVirt: "<= last" "ObjectInvocation_Binary" ActArg: "last "isValue: false formalArg: "in Veq: var this(Value)" 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "<= last " isCompositeValueObj: true 
 -- OG:before:super.gen: "last "
 -- INV:gen: "last" 
 -- needorigin: "last" 
 -- needOrigin:E: "last"  E.ATd: "last: var integer" Ex: "last" rec: "last" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "last" 
 -- doNeedOrigin:E: "last" 
 -- computeAdrX:superAdj: 0 "last" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "last" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "_doIt "on: 1 isValueObj: false 
 --  origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$57 1
 -- computeAdrX:isLast:E:  "last "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:- 
 --  rec:  "last "E:  "last "
 -- INV:gen:E.loadArgs "last "
 -- INV:gen:after:E.loadArgs "last "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "last ":Adr:off:2 si
 --  ze:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValu
 --  e:F:E:"last":rec:- 
 -- OI:invoke:before:ATdx.invoke: var last 
 -- DI:invoke: "last: var integer" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"last":rec:last isNotRemote: true 
 pushg 2 for:to:repeat$28
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"last":rec:last 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"last":rec:last 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"last":rec:last 
 -- vEq: 
 -- end:loadArgs:NonVirt: "<= last "
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj
 --  :0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:after:E.loadArgs "inx <= last "
 --  OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:T originIsValue:F:E:"inx":rec:inx 
 -- IV:E.invoke:useRtnVal: true E: BinOp "inx <= last ":Adr:off:3 size:0 isFlo
 --  at:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx
 --  ":rec:inx 
 -- BinaryExp:invoke: "inx "rec: "inx <= last "
 -- M: "<= last ":Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:
 --  F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:before:ATdx.invoke: pattern <=   
 -- ptn:invoke: "<=   "E: "<= last "ptnKind: 1 useRtnV: true 
 -- E: "<= last" rec: "inx ""Invocation "OGx: "integer" 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- rec.ATd: "inx: var integer" 
 -- bobs: 1 OGx: "integer" 
 -- 
 le
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"<= last":rec:inx nl; adrx: :Adr:off:0
 --   size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsV
 --  alue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"<= last":rec:inx 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  59   "$59 "
 invoke $59 59 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L5
 L4:
 pushThis 
 -- before objTmpStack:add:  62   "$62 "
 invoke $62 62 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 L5:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $59 59 1 _doIt 57
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "repeat "
 -- INV:gen: "repeat" 
 -- needorigin: "repeat" 
 -- needOrigin:E: "repeat"  E.ATd: "repeat:< object" Ex: "repeat" rec: "repeat" 
 -- doNeedOrigin:Ex: "repeat "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "repeat" 
 -- doNeedOrigin:E: "repeat" 
 -- computeAdrX:superAdj: 0 "repeat" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "repeat" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$59 "on: 2 isValueObj: false 
 --  origin: _doIt origin:isValueObj: false 
 rpushg $59$59 1
 -- items:goOrigin:encOG: "_doIt "on: 1 isValueObj: false 
 --  origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$57 1
 -- computeAdrX:isLast:E:  "repeat "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:- 
 --  rec:  "repeat "E:  "repeat "
 -- INV:gen:E.loadArgs "repeat "
 -- INV:gen:after:E.loadArgs "repeat "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "repeat ":Adr:off:0 
 --  size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVa
 --  lue:F:E:"repeat":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern repeat 
 -- ptn:invoke: "repeat "E: "repeat "ptnKind: 1 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 1 staticOff: 0 rec: "repeat" 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"repeat":rec:repeat 
 invokev 2 0 repeat$29$29 0
 -- GeneralPTN:invoke:after:pushOut: 
 rpop 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"repeat":rec:repeat nl; adrx: :Adr:off
 --  :-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origin
 --  IsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"repeat":rec:repeat 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"repeat":rec:repeat 
 -- AssignmentStatement:gen: "inx := inx + 1" 
 pushThis 
 -- items:goOrigin:encOG: "$59 "on: 2 isValueObj: false 
 --  origin: _doIt origin:isValueObj: false 
 rpushg $59$59 1
 -- items:goOrigin:encOG: "_doIt "on: 1 isValueObj: false 
 --  origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$57 1
 -- AssignmentStatement:gen: 
 --  "inx := inx + 1" right.label: "ObjectGenerator ""inx + 1" 
 -- OG:before:super.gen: "inx + 1 "
 -- INV:gen: "inx + 1" 
 -- needorigin: "inx + 1" 
 -- needOrigin:E: "inx + 1"  E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  Ex: "inx + 1" rec: "inx + 1" 
 -- doNeedOrigin:Ex: "inx + 1 "originIsValueObj: true origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inx + 1" 
 -- doNeedOrigin:E: "inx + 1" 
 -- computeAdrX:superAdj: 0 "inx + 1" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx + 1" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "inx + 1 "superAdj: 0 
 -- computeAdrX:isLast:E:  "inx + 1 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "inx + 1 "E:  "inx + 1 "
 -- INV:gen:E.loadArgs "inx + 1 "
 -- BinaryExp:loadArgs: "inx + 1" superAdj: 0 
 -- INV:gen: "inx" 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" Ex: "inx" rec: "inx" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx" 
 -- doNeedOrigin:E: "inx" 
 -- computeAdrX:superAdj: 0 "inx" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$59 "on: 2 isValueObj: false 
 --  origin: _doIt origin:isValueObj: false 
 rpushg $59$59 1
 -- items:goOrigin:encOG: "_doIt "on: 1 isValueObj: false 
 --  origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$57 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx ":Adr:off:3 siz
 --  e:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue
 --  :F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 3 for:to:repeat$28
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnit
 --  Val:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- NonVirt: "+ 1" "ObjectInvocation_Binary" ActArg: "1 "isValue: true formalArg: "in V: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ 1 " isCompositeValueObj: false 
 -- OG:before:super.gen: "1 "
 -- INV:gen: "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "1" rec: "1" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "1" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "1 "E:  "1 "
 -- INV:gen:E.loadArgs "1 "
 -- INV:gen:after:E.loadArgs "1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1 "
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- end:loadArgs:NonVirt: "+ 1 "
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj
 --  :0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:after:E.loadArgs "inx + 1 "
 --  OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:T originIsValue:F:E:"inx":rec:inx 
 -- IV:E.invoke:useRtnVal: true E: BinOp "inx + 1 ":Adr:off:3 size:0 isFloat:F
 --   isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":re
 --  c:inx 
 -- BinaryExp:invoke: "inx "rec: "inx + 1 "
 -- M: "+ 1 ":Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F is
 --  Value:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- ptn:invoke: "+   "E: "+ 1 "ptnKind: 0 useRtnV: true 
 plus
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"+ 1":rec:inx nl; adrx: :Adr:off:0 siz
 --  e:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue
 --  :F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"+ 1":rec:inx 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg for:to:repeat$28 3
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "restart(_doIt) "
 -- INV:gen: "restart(_doIt)" 
 -- needorigin: "restart(_doIt)" 
 -- needOrigin:E: "restart(_doIt)"  E.ATd: 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  Ex: "restart(_doIt)" rec: "restart(_doIt)" 
 -- doNeedOrigin:Ex: "restart(_doIt) "originIsValueObj: false origin.isPrimiti
 --  ve: false 
 -- KUK 
 -- after:needOrigin: "restart(_doIt)" 
 -- doNeedOrigin:E: "restart(_doIt)" 
 -- computeAdrX:superAdj: 0 "restart(_doIt)" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "restart(_doIt)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "restart(_doIt) "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec
 --  :- 
 --  rec:  "restart(_doIt) "E:  "restart(_doIt) "
 -- INV:gen:E.loadArgs "restart(_doIt) "
 -- INV:gen:after:E.loadArgs "restart(_doIt) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "restart(_doIt) ":
 --  Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F 
 --  originIsValue:F:E:"restart(_doIt)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern restart(V: var integer) 
 -- ptn:invoke: "restart(V: var integer) "E: "restart(_doIt) "ptnKind: 0 useRtn
 --  V: false 
 break  1 1 57 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:restart(_doIt) 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:restart(_doIt) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:restart(_doIt)
 --   
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $62 62 1 _doIt 57
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "inx := inx" 
 pushThis 
 -- items:goOrigin:encOG: "$62 "on: 2 isValueObj: false 
 --  origin: _doIt origin:isValueObj: false 
 rpushg $62$62 1
 -- items:goOrigin:encOG: "_doIt "on: 1 isValueObj: false 
 --  origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$57 1
 -- AssignmentStatement:gen: 
 --  "inx := inx" right.label: "ObjectGenerator ""inx" 
 -- OG:before:super.gen: "inx "
 -- INV:gen: "inx" 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" Ex: "inx" rec: "inx" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx" 
 -- doNeedOrigin:E: "inx" 
 -- computeAdrX:superAdj: 0 "inx" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$62 "on: 2 isValueObj: false 
 --  origin: _doIt origin:isValueObj: false 
 rpushg $62$62 1
 -- items:goOrigin:encOG: "_doIt "on: 1 isValueObj: false 
 --  origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$57 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx ":Adr:off:3 siz
 --  e:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue
 --  :F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 3 for:to:repeat$28
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- assign:adr.store:A: 
 storeg for:to:repeat$28 3
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS if:then 20 0 BETA 2
 pushThis 
 storeg Boolean$83 1
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:1 objSize:1 isIndexed:0

 CLASS thenPart#22 22 0 if:then$20 20 isVstub
 invoke Object 21 0 0
 pushThis 
 rstoreg   2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:1 objSize:3 isIndexed:0

 CLASS repeat$53 53 1 for:to:repeat$55 55
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "put(get[inx]) "
 -- INV:gen: "put(get[inx])" 
 -- needorigin: "put(get[inx])" 
 -- needOrigin:E: "put(get[inx])"  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put(get[inx])" rec: "put(get[inx])" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put(get[inx])" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put(get[inx]) "E:  "put(get[inx]) "
 -- INV:gen:E.loadArgs "put(get[inx]) "
 -- NonVirt: "put(get[inx])" "ObjectInvocation_KeyWord" ActArg: "get[inx] "isValue: false formalArg: "in ch: val char" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(get[inx]) " isCompositeValueObj: false 
 -- OG:before:super.gen: "get[inx] "
 -- INV:gen: "get[inx]" 
 -- needorigin: "get[inx]" 
 -- needOrigin:E: "get[inx]"  E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  Ex: "get[inx]" rec: "get[inx]" 
 -- doNeedOrigin:Ex: "get[inx] "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "get[inx]" 
 -- doNeedOrigin:E: "get[inx]" 
 -- computeAdrX:superAdj: 0 "get[inx]" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "get[inx]" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$53 "on: 3 isValueObj: false 
 --  origin: for:to:repeat$55 origin:isValueObj: false 
 rpushg repeat$53$53 1
 -- items:goOrigin:encOG: "for:to:repeat$55 "on: 2 isValueObj: false 
 --  origin: print origin:isValueObj: false 
 rpushg for:to:repeat$55$55 4
 -- items:goOrigin:encOG: "print "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg print$52 1
 -- computeAdrX:isLast:E:  "get[inx] "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 --  rec:  "get[inx] "E:  "get[inx] "
 -- INV:gen:E.loadArgs "get[inx] "
 -- NonVirt: "get[inx]" "ObjectInvocation_KeyWord" ActArg: "inx "isValue: false formalArg: "inx: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx] " isCompositeValueObj: false 
 -- OG:before:super.gen: "inx "
 -- INV:gen: "inx" 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" Ex: "inx" rec: "inx" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx" 
 -- doNeedOrigin:E: "inx" 
 -- computeAdrX:superAdj: 0 "inx" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$53 "on: 1 isValueObj: false 
 --  origin: for:to:repeat$55 origin:isValueObj: false 
 rpushg repeat$53$53 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx ":Adr:off:3 siz
 --  e:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue
 --  :F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 3 for:to:repeat$55$55
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "get[inx] "
 -- INV:gen:after:E.loadArgs "get[inx] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx] ":Adr:of
 --  f:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origin
 --  IsValue:F:E:"get[inx]":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- ptn:invoke: "get[inx: var integer] "E: "get[inx] "ptnKind: 0 useRtnV: true 
 xpushg  inx 1 0 1
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "get[inx] ":isBasicVal: true 
 -- case:B: get[inx] ObjectGenerator 3 117 117 false false 
 -- end:loadArgs:NonVirt: "put(get[inx]) "
 -- INV:gen:after:E.loadArgs "put(get[inx]) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(get[inx]) "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put(get[inx]) "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS put 54 0 BETA 2
 pushThis 
 storeg char$7 1
 allocEventQ
 mvStack 
 -- DI:gen: "in ch: val char" DI:isConst: true :isBasicValue: true :primNo: 3 
 -- DI:add:BP1:  ch 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS for:to:repeat$55 55 4 print 52
 -- vdtTableCopy: I:1:28 V:2:29
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- NonVirt: 
 --  for(1):to(length):repeat
 --     put(get[inx])
 --  
 --  "ObjectInvocation_KeyWord" ActArg: "1 "isValue: true formalArg: "first: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "for(1):to(length):repeat
 --     put(get[inx])
 --   " isCompositeValueObj: false 
 -- OG:before:super.gen: "1 "
 -- INV:gen: "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "1" rec: "1" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "1" 
 -- IV:after:computeAdr:superAdj: 4 
 --  rec:  "1 "E:  "1 "
 -- INV:gen:E.loadArgs "1 "
 -- INV:gen:after:E.loadArgs "1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1 "
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "first: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- end:loadArgs:NonVirt: "for(1):to(length):repeat
 --     put(get[inx])
 --   "
 -- NonVirt: 
 --  for(1):to(length):repeat
 --     put(get[inx])
 --  
 --  "ObjectInvocation_KeyWord" ActArg: "length "isValue: false formalArg: "last: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "for(1):to(length):repeat
 --     put(get[inx])
 --   " isCompositeValueObj: false 
 -- OG:before:super.gen: "length "
 -- INV:gen: "length" 
 -- needorigin: "length" 
 -- needOrigin:E: "length"  E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  Ex: "length" rec: "length" 
 -- doNeedOrigin:Ex: "length "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "length" 
 -- doNeedOrigin:E: "length" 
 -- computeAdrX:superAdj: 4 "length" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "length" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 rpushg print$52 4
 -- items:goOrigin:encOG: "print "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg print$52 1
 -- computeAdrX:isLast:E:  "length "
 -- IV:after:computeAdr:superAdj: 4 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 --  rec:  "length "E:  "length "
 -- INV:gen:E.loadArgs "length "
 -- INV:gen:after:E.loadArgs "length "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length ":Adr:off:0 
 --  size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsVa
 --  lue:F:E:"length":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- ptn:invoke: "length "E: "length "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "length" 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F
 --   originIsValue:F:E:"length":rec:length 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:0 size:0 isFloat:F isUnitVal:F superA
 --  dj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUn
 --  ique:F isValue:F originIsValue:F:E:"length":rec:length nl; adrx: :Adr:off
 --  :2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originI
 --  sValue:F:E:"length":rec:length 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUn
 --  ique:F isValue:F originIsValue:F:E:"length":rec:length 
 --  adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isVa
 --  lue:F originIsValue:F:E:"length":rec:length 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isU
 --  nique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- actualArg:isPtn: true formalArg:isPtn: "last: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "length ":isBasicVal: true 
 -- case:B: length ObjectGenerator 1 0 0 false false 
 -- end:loadArgs:NonVirt: "for(1):to(length):repeat
 --     put(get[inx])
 --   "
 pushThis 
 storeg integer$5 2
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- DI:gen: "inx: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  inx 
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0

 CLASS putFloat 56 1 BETA 2
 pushThis 
 fstoreg 2 X
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in X: var Float" DI:isConst: false :isBasicValue: true :primNo: 9 
 -- DI:add:BP1:  X 
 -- DI:gen: "out V: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  V 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS symbol 63 1 Dimension 39
 allocEventQ
 mvStack 
 -- DI:gen: "out T: var StringLib.String" DI:isConst: false :isBasicValue: false :primNo: 5 
 -- StringVar "out T: var StringLib.String "
 pushText ""
 pushThis 
 rstoreg  T 2
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(Symbol) "
 -- INV:gen: "inner(Symbol)" 
 -- needorigin: "inner(Symbol)" 
 -- needOrigin:E: "inner(Symbol)"  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(Symbol)" rec: "inner(Symbol)" 
 -- doNeedOrigin:Ex: "inner(Symbol) "originIsValueObj: false origin.isPrimitiv
 --  e: false 
 -- KUK 
 -- after:needOrigin: "inner(Symbol)" 
 -- doNeedOrigin:E: "inner(Symbol)" 
 -- computeAdrX:superAdj: 0 "inner(Symbol)" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(Symbol)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(Symbol) "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Symbol)":rec:
 --  - 
 --  rec:  "inner(Symbol) "E:  "inner(Symbol) "
 -- INV:gen:E.loadArgs "inner(Symbol) "
 -- INV:gen:after:E.loadArgs "inner(Symbol) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(Symbol) ":A
 --  dr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F o
 --  riginIsValue:F:E:"inner(Symbol)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(Symbol) "ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"inner(Symbol)":rec:inner(Symbol) 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"inner(Symbol)":rec:inner(Symbol) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"inner(Symbol)":rec:inner(Symbol) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS gMult 64 1 Dimension 39
 jmpFalse  L3
 pushThis 
 -- vassign:B: R off: 4 size: 2 mode: 0 
 vassign  4 2 0
 jmp L4
 L3:
 invokeVal  R 40 3
 rpop 
 L4:
 jmpFalse  L5
 pushThis 
 -- vassign:B: L off: 2 size: 2 mode: 0 
 vassign  2 2 0
 jmp L6
 L5:
 invokeVal  L 40 1
 rpop 
 L6:
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in L: var MultArgL" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  L 
 -- inArg: in L: var MultArgL 
 -- DI:gen: "in R: var MultArgR" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  R 
 -- inArg: in R: var MultArgR 
 -- DI:gen: "out U: var MultRes" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  U 
 -- DI:off: 6 this: "out U: var MultRes" 
 --  
 -- OG:before:super.gen: "MultRes "
 -- INV:gen: "MultRes" 
 -- needorigin: "MultRes" 
 -- needOrigin:E: "MultRes"  E.ATd: "MultRes:< Unit" Ex: "MultRes" rec: "MultRes" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 --  
 -- after:needOrigin: "MultRes" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "MultRes "E:  "MultRes "
 -- INV:gen:E.loadArgs "MultRes "
 -- INV:gen:after:E.loadArgs "MultRes "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "MultRes "
 -- OI:invoke:before:ATdx.invoke: pattern MultRes 
 -- ptn:invoke: "MultRes "E: "MultRes "ptnKind: 1 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 1 staticOff: 6 rec: "MultRes" 
 --  adr:none 
 invokeVal  MultRes 40 5
 rpop 
 -- OI:invoke:V: nl; adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0
 --   isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "U.magnitude := L.magnitude * R.magnitude" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "U.magnitude := L.magnitude * R.magnitude" right.label: "ObjectGenerator ""L.magnitude * R.magnitude" 
 -- OG:before:super.gen: "L.magnitude * R.magnitude "
 -- INV:gen: "L.magnitude * R.magnitude" 
 -- needorigin: "L.magnitude * R.magnitude" 
 -- needOrigin:E: "L.magnitude * R.magnitude"  E.ATd: 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  Ex: "L.magnitude * R.magnitude" rec: "L.magnitude * R.magnitude" 
 -- doNeedOrigin:Ex: "L.magnitude * R.magnitude "originIsValueObj: true origi
 --  n.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "L.magnitude * R.magnitude" 
 -- doNeedOrigin:E: "L.magnitude * R.magnitude" 
 -- computeAdrX:superAdj: 0 "L.magnitude * R.magnitude" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L.magnitude * R.magnitude" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "L.magnitude * R.magnitude "superAdj: 0 
 -- computeAdrX:isLast:E:  "L.magnitude * R.magnitude "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "L.magnitude * R.magnitude "E:  "L.magnitude * R.magnitude "
 -- INV:gen:E.loadArgs "L.magnitude * R.magnitude "
 -- BinaryExp:loadArgs: "L.magnitude * R.magnitude" superAdj: 0 
 -- INV:gen: "L.magnitude" 
 -- needorigin: "L.magnitude" 
 -- needOrigin:E: "magnitude"  E.ATd: "magnitude: var Float" Ex: none rec: "L" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "magnitude" 
 -- doNeedOrigin:E: "magnitude" 
 -- computeAdrX:superAdj: 0 "L.magnitude" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "L" rec: "L" E: "magnitude" 
 --  A.E: "L "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T
 --   originIsValue:F:E:"L":rec:- 
 -- computeAdrX:isLast:E:  "magnitude "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:T isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 --  rec:  "L "E:  "magnitude "
 -- INV:gen:E.loadArgs "magnitude "
 -- INV:gen:after:E.loadArgs "magnitude "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude ":Adr:off
 --  :2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originI
 --  sValue:F:E:"L":rec:- 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- DI:invoke: "magnitude: var Float" 
 -- load: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"magnitude":rec:L isNotRemote: false 
 fpushg 2 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"magnitude":rec:L 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"magnitude":rec:L 
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:2 size:0 isFloat:T isUnit
 --  Val:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec
 --  :L 
 -- NonVirt: "* R.magnitude" "ObjectInvocation_Binary" ActArg: "R.magnitude "isValue: false formalArg: "in V: var float" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- OG:before:super.gen: "R.magnitude "
 -- INV:gen: "R.magnitude" 
 -- needorigin: "R.magnitude" 
 -- needOrigin:E: "magnitude"  E.ATd: "magnitude: var Float" Ex: none rec: "R" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "magnitude" 
 -- doNeedOrigin:E: "magnitude" 
 -- computeAdrX:superAdj: 0 "R.magnitude" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "R" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "R" rec: "R" E: "magnitude" 
 --  A.E: "R "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T
 --   originIsValue:F:E:"R":rec:- 
 -- computeAdrX:isLast:E:  "magnitude "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:T isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 --  rec:  "R "E:  "magnitude "
 -- INV:gen:E.loadArgs "magnitude "
 -- INV:gen:after:E.loadArgs "magnitude "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude ":Adr:off
 --  :4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originI
 --  sValue:F:E:"R":rec:- 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- DI:invoke: "magnitude: var Float" 
 -- load: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"magnitude":rec:R isNotRemote: false 
 fpushg 4 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"magnitude":rec:R 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"magnitude":rec:R 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"magnitude":rec:R 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var float ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "R.magnitude ":isBasicVal: true 
 -- case:B: R.magnitude ObjectGenerator 9 0 9 false false 
 -- end:loadArgs:NonVirt: "* R.magnitude "
 -- BinaryExp:loadArgs:end: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj
 --  :0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:L 
 -- INV:gen:after:E.loadArgs "L.magnitude * R.magnitude "
 --  OIadr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:T originIsValue:F:E:"magnitude":rec:L 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L.magnitude * R.magnitude ":Adr:off:
 --  2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIs
 --  Value:F:E:"magnitude":rec:L 
 -- BinaryExp:invoke: "L.magnitude "rec: "L.magnitude * R.magnitude "
 -- M: "* R.magnitude ":Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"magnitude":rec:L 
 -- OI:invoke:before:ATdx.invoke: pattern *   
 -- ptn:invoke: "*   "E: "* R.magnitude "ptnKind: 0 useRtnV: true 
 fmult
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"* R.magnitude":rec:L.magnitude nl; a
 --  drx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVal
 --  ue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"* R.magnitude":rec:L.magnitude 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 fstoreg 6 address:storeg
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:7 isIndexed:0

 CLASS Area 66 1 Dimensions 38
 -- vdtTableCopy: I:1:39 V:2:44 V:3:63 V:4:45 V:5:46 V:6:47 V:7:64 I:8:0
 tstOriginIsNone 
 rstore  1 origin
 -- super Dimension
 -- computeAdrX:superAdj: 1 "Dimension" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Dimension" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 rpushg Dimensions$38 1
 -- computeAdrX:isLast:E:  "Dimension "
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 rtnAlloc 1
 toSuper 39
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0

 CLASS PrimaryUnit#67 67 1 Area$66 66 isVstub
 invoke SquareMeter 68 0 1
 pushThis 
 rstoreg   2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS SquareMeter 68 0 Area 66 isValueObj
 -- vdtTableCopy: I:1:40 V:2:0 V:3:0 V:4:0 V:5:0 V:6:0 V:7:49 V:8:50 V:9:51
 -- super Unit
 -- DI:gen: "magnitude: var Float" DI:isConst: false :isBasicValue: true :primNo: 9 
 -- DI:add:BP1:  magnitude 
 rtnAlloc 1
 toSuper 40
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS print 70 1 SquareMeter 68
 -- vdtTableCopy: I:1:51 I:2:0
 tstOriginIsNone 
 rstore  1 origin
 -- super print
 pushThis 
 rpushg iOrigin 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 rtnAlloc 1
 toSuper 51
DO:
 mvStack 
 L1:
 -- OG:before:super.gen: ""SquareMeter".print "
 -- INV:gen: ""SquareMeter".print" 
 -- needorigin: ""SquareMeter".print" 
 -- needOrigin:E: "print"  E.ATd: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeat
 --  Ex: ""SquareMeter"" rec: ""SquareMeter"" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 --  
 -- after:needOrigin: ""SquareMeter"" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  ""SquareMeter" "E:  ""SquareMeter" "
 -- INV:gen:E.loadArgs ""SquareMeter" "
 -- INV:gen:after:E.loadArgs ""SquareMeter" "
 --  OIadr: 
 pushText "SquareMeter"
 -- IV:gen:checkTail: ""SquareMeter".print "E: ""SquareMeter" "tail: "print " not
 --   isLast: false 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: ""SquareMeter"" 
 --  adr:none 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: nl; adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:
 --  0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0

 CLASS symbol 71 1 Area 66
 -- vdtTableCopy: I:1:63 I:2:0
 -- super symbol
 allocEventQ
 -- DI:gen: "out T: var StringLib.String" DI:isConst: false :isBasicValue: false :primNo: 5 
 -- StringVar "out T: var StringLib.String "
 pushText ""
 pushThis 
 rstoreg  T 2
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 rtnAlloc 1
 toSuper 63
DO:
 mvStack 
 L1:
 -- AssignmentStatement:gen: "T := "A"" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "T := "A"" right.label: "ObjectGenerator """A"" 
 -- OG:before:super.gen: ""A" "
 -- INV:gen: ""A"" 
 -- needorigin: ""A"" 
 -- needOrigin:E: ""A""  E.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 --  Ex: ""A"" rec: ""A"" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 --  
 -- after:needOrigin: ""A"" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  ""A" "E:  ""A" "
 -- INV:gen:E.loadArgs ""A" "
 -- INV:gen:after:E.loadArgs ""A" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: String: ""A" "
 pushText "A"
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 rswap 0
 rstoreg  EisNone 2
   ;; vTop(0,0)=[] rTop(-2,1)=[]
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS Length 72 1 Dimensions 38
 -- vdtTableCopy: I:1:39 V:2:44 V:3:63 V:4:45 V:5:46 V:6:47 V:7:64 I:8:0
 tstOriginIsNone 
 rstore  1 origin
 -- super Dimension
 -- computeAdrX:superAdj: 1 "Dimension" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Dimension" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 rpushg Dimensions$38 1
 -- computeAdrX:isLast:E:  "Dimension "
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 rtnAlloc 1
 toSuper 39
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0

 CLASS PrimaryUnit#73 73 1 Length$72 72 isVstub
 invoke Meter 74 0 1
 pushThis 
 rstoreg   2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS Meter 74 0 Length 72 isValueObj
 -- vdtTableCopy: I:1:40 V:2:0 V:3:0 V:4:0 V:5:0 V:6:0 V:7:49 V:8:50 V:9:51
 -- super Unit
 -- DI:gen: "magnitude: var Float" DI:isConst: false :isBasicValue: true :primNo: 9 
 -- DI:add:BP1:  magnitude 
 rtnAlloc 1
 toSuper 40
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS toPrimary 78 1 Meter 74
 -- vdtTableCopy: I:1:49 I:2:0
 tstOriginIsNone 
 rstore  1 origin
 -- super toPrimary
 pushThis 
 rpushg iOrigin 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- DI:gen: "out base: var PrimaryUnit" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  base 
 -- DI:off: 2 this: "out base: var PrimaryUnit" 
 --  
 -- OG:before:super.gen: "PrimaryUnit "
 -- INV:gen: "PrimaryUnit" 
 -- needorigin: "PrimaryUnit" 
 -- needOrigin:E: "PrimaryUnit"  E.ATd: "PrimaryUnit:< Unit" Ex: "PrimaryUnit" rec: "PrimaryUnit" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 --  
 -- after:needOrigin: "PrimaryUnit" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "PrimaryUnit "E:  "PrimaryUnit "
 -- INV:gen:E.loadArgs "PrimaryUnit "
 -- INV:gen:after:E.loadArgs "PrimaryUnit "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "PrimaryUnit "
 -- OI:invoke:before:ATdx.invoke: pattern PrimaryUnit 
 -- ptn:invoke: "PrimaryUnit "E: "PrimaryUnit "ptnKind: 1 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 1 staticOff: 2 rec: "PrimaryUnit" 
 --  adr:none 
 invokeVal  PrimaryUnit 40 1
 rpop 
 -- OI:invoke:V: nl; adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0
 --   isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 rtnAlloc 1
 toSuper 49
DO:
 mvStack 
 L1:
 -- AssignmentStatement:gen: "base.magnitude := magnitude" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "base.magnitude := magnitude" right.label: "ObjectGenerator ""magnitude" 
 -- OG:before:super.gen: "magnitude "
 -- INV:gen: "magnitude" 
 -- needorigin: "magnitude" 
 -- needOrigin:E: "magnitude"  E.ATd: "magnitude: var Float" Ex: "magnitude" rec: "magnitude" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "magnitude" 
 -- doNeedOrigin:E: "magnitude" 
 -- computeAdrX:superAdj: 0 "magnitude" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "magnitude" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "toPrimary "on: 1 isValueObj: false 
 --  origin: Meter origin:isValueObj: true 
 rpushg toPrimary$78 1
 -- computeAdrX:isLast:E:  "magnitude "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:1 size:0 isFloat:T isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 --  rec:  "magnitude "E:  "magnitude "
 -- INV:gen:E.loadArgs "magnitude "
 -- INV:gen:after:E.loadArgs "magnitude "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude ":Adr:off
 --  :1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originI
 --  sValue:T:E:"magnitude":rec:- 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- DI:invoke: "magnitude: var Float" 
 -- load: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:T:E:"magnitude":rec:magnitude isNotRemote: true 
 -- load:isValue:E: "magnitude "originIsValue: true E.ATd:isValueObj: true 
 -- E.ATd: "magnitude: var Float" 
 --  E.ATd.origin: 
 --  %unit "U", 1
 --  %public
 --  magnitude: var Float
 --  thisUnit:< Unit
 --  
 --  (E.ATd.origin.ogOfScope): 
 --  Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 --  
 fvpushg 1 Meter$74
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- INV:gen:end:off: 1 
 -- OG:gen:end: OIadr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- assign:adr.store:A: 
 fstoreg 2 address:storeg
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:3 isIndexed:0

 CLASS fromPrimary 79 1 Meter 74
 -- vdtTableCopy: I:1:50 I:2:0
 tstOriginIsNone 
 rstore  1 origin
 -- super fromPrimary
 pushThis 
 rpushg iOrigin 1
 jmpFalse  L3
 pushThis 
 -- vassign:B: base off: 2 size: 2 mode: 0 
 vassign  2 2 0
 jmp L4
 L3:
 invokeVal  base 40 1
 rpop 
 L4:
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- DI:gen: "in base: var PrimaryUnit" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  base 
 -- inArg: in base: var PrimaryUnit 
 rtnAlloc 1
 toSuper 50
DO:
 mvStack 
 L1:
 -- AssignmentStatement:gen: "magnitude := base.magnitude" 
 pushThis 
 -- items:goOrigin:encOG: "fromPrimary "on: 1 isValueObj: false 
 --  origin: Meter origin:isValueObj: true 
 rpushg fromPrimary$79 1
 -- AssignmentStatement:gen: 
 --  "magnitude := base.magnitude" right.label: "ObjectGenerator ""base.magnitude" 
 -- OG:before:super.gen: "base.magnitude "
 -- INV:gen: "base.magnitude" 
 -- needorigin: "base.magnitude" 
 -- needOrigin:E: "magnitude"  E.ATd: "magnitude: var Float" Ex: none rec: "base" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "magnitude" 
 -- doNeedOrigin:E: "magnitude" 
 -- computeAdrX:superAdj: 0 "base.magnitude" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "base" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "base" rec: "base" E: "magnitude" 
 --  A.E: "base "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T
 --   originIsValue:F:E:"base":rec:- 
 -- computeAdrX:isLast:E:  "magnitude "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:T isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 --  rec:  "base "E:  "magnitude "
 -- INV:gen:E.loadArgs "magnitude "
 -- INV:gen:after:E.loadArgs "magnitude "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude ":Adr:off
 --  :2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originI
 --  sValue:F:E:"base":rec:- 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- DI:invoke: "magnitude: var Float" 
 -- load: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"magnitude":rec:base isNotRemote: false 
 fpushg 2 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- assign:adr.store:A: 
 fvstoreg  1 
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:3 isIndexed:0

 CLASS print 80 1 Meter 74
 -- vdtTableCopy: I:1:51 I:2:0
 tstOriginIsNone 
 rstore  1 origin
 -- super print
 pushThis 
 rpushg iOrigin 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 rtnAlloc 1
 toSuper 51
DO:
 mvStack 
 L1:
 -- OG:before:super.gen: ""Meter".print "
 -- INV:gen: ""Meter".print" 
 -- needorigin: ""Meter".print" 
 -- needOrigin:E: "print"  E.ATd: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeat
 --  Ex: ""Meter"" rec: ""Meter"" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 --  
 -- after:needOrigin: ""Meter"" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  ""Meter" "E:  ""Meter" "
 -- INV:gen:E.loadArgs ""Meter" "
 -- INV:gen:after:E.loadArgs ""Meter" "
 --  OIadr: 
 pushText "Meter"
 -- IV:gen:checkTail: ""Meter".print "E: ""Meter" "tail: "print " not isLast: false 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: ""Meter"" 
 --  adr:none 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: nl; adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:
 --  0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0

 CLASS symbol 81 1 Length 72
 -- vdtTableCopy: I:1:63 I:2:0
 -- super symbol
 allocEventQ
 -- DI:gen: "out T: var StringLib.String" DI:isConst: false :isBasicValue: false :primNo: 5 
 -- StringVar "out T: var StringLib.String "
 pushText ""
 pushThis 
 rstoreg  T 2
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 rtnAlloc 1
 toSuper 63
DO:
 mvStack 
 L1:
 -- AssignmentStatement:gen: "T := "L"" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "T := "L"" right.label: "ObjectGenerator """L"" 
 -- OG:before:super.gen: ""L" "
 -- INV:gen: ""L"" 
 -- needorigin: ""L"" 
 -- needOrigin:E: ""L""  E.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 --  Ex: ""L"" rec: ""L"" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 --  
 -- after:needOrigin: ""L"" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  ""L" "E:  ""L" "
 -- INV:gen:E.loadArgs ""L" "
 -- INV:gen:after:E.loadArgs ""L" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: String: ""L" "
 pushText "L"
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 rswap 0
 rstoreg  EisNone 2
   ;; vTop(0,0)=[] rTop(-2,1)=[]
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS StringLib 82 1 LIB 33
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 saveStringOrigin
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $18 18 1 loop 14
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "leave(loop) "
 -- INV:gen: "leave(loop)" 
 -- needorigin: "leave(loop)" 
 -- needOrigin:E: "leave(loop)"  E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  Ex: "leave(loop)" rec: "leave(loop)" 
 -- doNeedOrigin:Ex: "leave(loop) "originIsValueObj: false origin.isPrimitive:
 --   false 
 -- KUK 
 -- after:needOrigin: "leave(loop)" 
 -- doNeedOrigin:E: "leave(loop)" 
 -- computeAdrX:superAdj: 0 "leave(loop)" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "leave(loop)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "leave(loop) "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:- 
 --  rec:  "leave(loop) "E:  "leave(loop) "
 -- INV:gen:E.loadArgs "leave(loop) "
 -- INV:gen:after:E.loadArgs "leave(loop) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "leave(loop) ":Adr
 --  :off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori
 --  ginIsValue:F:E:"leave(loop)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- ptn:invoke: "leave(V: var integer) "E: "leave(loop) "ptnKind: 0 useRtnV: false 
 break  1 2 14 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS Boolean 83 0 BETA 2 isValueObj
 mvStack 
 -- DI:gen: "_thisBasicValue: var Universal" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  _thisBasicValue 
 rtnAlloc 1
DO:
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS True 23 0 BETA 2
 allocEventQ
 mvStack 
 -- DI:gen: "out B: var boolean" DI:isConst: false :isBasicValue: true :primNo: 4 
 -- DI:add:BP1:  B 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "B := 1" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "B := 1" right.label: "ObjectGenerator ""1" 
 -- OG:before:super.gen: "1 "
 -- INV:gen: "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "1" rec: "1" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "1" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "1 "E:  "1 "
 -- INV:gen:E.loadArgs "1 "
 -- INV:gen:after:E.loadArgs "1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1 "
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg True$23 1
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS repeat$24 24 1 for:to:repeat$30 30
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "c1 := get[inx]" 
 pushThis 
 -- items:goOrigin:encOG: "repeat$24 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30 "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- AssignmentStatement:gen: 
 --  "c1 := get[inx]" right.label: "ObjectGenerator ""get[inx]" 
 -- OG:before:super.gen: "get[inx] "
 -- INV:gen: "get[inx]" 
 -- needorigin: "get[inx]" 
 -- needOrigin:E: "get[inx]"  E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  Ex: "get[inx]" rec: "get[inx]" 
 -- doNeedOrigin:Ex: "get[inx] "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "get[inx]" 
 -- doNeedOrigin:E: "get[inx]" 
 -- computeAdrX:superAdj: 0 "get[inx]" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "get[inx]" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$24 "on: 4 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30 "on: 3 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- items:goOrigin:encOG: "loop "on: 2 isValueObj: false 
 --  origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- items:goOrigin:encOG: "= "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg =$13 1
 -- computeAdrX:isLast:E:  "get[inx] "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 --  rec:  "get[inx] "E:  "get[inx] "
 -- INV:gen:E.loadArgs "get[inx] "
 -- NonVirt: "get[inx]" "ObjectInvocation_KeyWord" ActArg: "inx "isValue: false formalArg: "inx: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx] " isCompositeValueObj: false 
 -- OG:before:super.gen: "inx "
 -- INV:gen: "inx" 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" Ex: "inx" rec: "inx" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx" 
 -- doNeedOrigin:E: "inx" 
 -- computeAdrX:superAdj: 0 "inx" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$24 "on: 1 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx ":Adr:off:3 siz
 --  e:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue
 --  :F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 3 for:to:repeat$30$30
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "get[inx] "
 -- INV:gen:after:E.loadArgs "get[inx] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx] ":Adr:of
 --  f:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origin
 --  IsValue:F:E:"get[inx]":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- ptn:invoke: "get[inx: var integer] "E: "get[inx] "ptnKind: 0 useRtnV: true 
 xpushg  inx 1 0 1
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- assign:adr.store:A: 
 storeg loop$14 2
 -- assign:adr.store:B: 
 -- AssignmentStatement:gen: "c2 := Veq.get[inx]" 
 pushThis 
 -- items:goOrigin:encOG: "repeat$24 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30 "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- AssignmentStatement:gen: 
 --  "c2 := Veq.get[inx]" right.label: "ObjectGenerator ""Veq.get[inx]" 
 -- OG:before:super.gen: "Veq.get[inx] "
 -- INV:gen: "Veq.get[inx]" 
 -- needorigin: "Veq.get[inx]" 
 -- needOrigin:E: "get[inx]"  E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  Ex: "get[inx]" rec: "Veq" 
 -- doNeedOrigin:Ex: "get[inx] "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "get[inx]" 
 -- doNeedOrigin:E: "get[inx]" 
 -- computeAdrX:superAdj: 0 "Veq.get[inx]" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Veq" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$24 "on: 3 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30 "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- computeAdrX:En: 2 pRec: "Veq" rec: "Veq" E: "get[inx]" 
 --  A.E: none 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "Veq" rec: "Veq" E: "get[inx]" 
 --  rec.ATd: "in Veq: var this(Value)" rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --     inner(= )
 --  
 --  recA: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"get[inx]":rec:- 
 --  pRecA: none 
 -- pRec: "Veq" rec: "Veq" E: "get[inx]" 
 --  false true 
 -- computeAdrX:before:rec:: "Veq" 
 -- OI:invoke:before:ATdx.invoke: var Veq 
 -- DI:invoke: "in Veq: var this(Value)" 
 -- isValueObj:isAdr: true objSize: 2  rec "Veq ",E: "get[inx] ""ObjectInvocatio
 --  n_KeyWord "E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"get[inx]":rec:Veq 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 rpushg repeat$24$24 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- computeAdrX:after:rec.invoke: "Veq" 
 -- computeAdrX:isLast:E:  "get[inx] "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 --  rec:  "Veq "E:  "get[inx] "
 -- INV:gen:E.loadArgs "get[inx] "
 -- NonVirt: "get[inx]" "ObjectInvocation_KeyWord" ActArg: "inx "isValue: false formalArg: "inx: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx] " isCompositeValueObj: false 
 -- OG:before:super.gen: "inx "
 -- INV:gen: "inx" 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" Ex: "inx" rec: "inx" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx" 
 -- doNeedOrigin:E: "inx" 
 -- computeAdrX:superAdj: 0 "inx" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$24 "on: 1 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx ":Adr:off:3 siz
 --  e:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue
 --  :F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 3 for:to:repeat$30$30
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "get[inx] "
 -- INV:gen:after:E.loadArgs "get[inx] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx] ":Adr:of
 --  f:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origin
 --  IsValue:F:E:"get[inx]":rec:Veq 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- ptn:invoke: "get[inx: var integer] "E: "get[inx] "ptnKind: 0 useRtnV: true 
 xpushg  inx 1 0 1
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- assign:adr.store:A: 
 storeg loop$14 3
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop) "
 -- INV:gen: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  
 -- needorigin: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  
 -- needOrigin:E: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  rec: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  
 -- Ex:loadOrign:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop) "E:  "if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop) "
 -- INV:gen:E.loadArgs "if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop) "
 -- INV:gen:after:E.loadArgs "if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop) "
 -- OG:before:super.gen: "(c1 <> c2) "
 -- INV:gen: "(c1 <> c2)" 
 -- needorigin: "(c1 <> c2)" 
 -- needOrigin:E: "(c1 <> c2)"  E.ATd: 
 --  <>  : 
 --     %basic 55
 --     in V: var char
 --     out B: var boolean
 --  Ex: "(c1 <> c2)" rec: "(c1 <> c2)" 
 -- doNeedOrigin:Ex: "(c1 <> c2) "originIsValueObj: true origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(c1 <> c2)" 
 -- doNeedOrigin:E: "(c1 <> c2)" 
 -- computeAdrX:superAdj: 0 "(c1 <> c2)" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(c1 <> c2)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "c1 <> c2 "superAdj: 0 
 -- computeAdrX:isLast:E:  "c1 <> c2 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "c1 <> c2 "E:  "c1 <> c2 "
 -- INV:gen:E.loadArgs "c1 <> c2 "
 -- BinaryExp:loadArgs: "c1 <> c2" superAdj: 0 
 -- INV:gen: "c1" 
 -- needorigin: "c1" 
 -- needOrigin:E: "c1"  E.ATd: "c1: var char" Ex: "c1" rec: "c1" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "c1" 
 -- doNeedOrigin:E: "c1" 
 -- computeAdrX:superAdj: 0 "c1" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "c1" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$24 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30 "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- computeAdrX:isLast:E:  "c1 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 --  rec:  "c1 "E:  "c1 "
 -- INV:gen:E.loadArgs "c1 "
 -- INV:gen:after:E.loadArgs "c1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c1 ":Adr:off:2 size
 --  :0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:
 --  F:E:"c1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var c1 
 -- DI:invoke: "c1: var char" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"c1":rec:c1 isNotRemote: true 
 pushg 2 loop$14
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:2 size:0 isFloat:F isUnit
 --  Val:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- NonVirt: "<> c2" "ObjectInvocation_Binary" ActArg: "c2 "isValue: false formalArg: "in V: var char" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "<> c2 " isCompositeValueObj: false 
 -- OG:before:super.gen: "c2 "
 -- INV:gen: "c2" 
 -- needorigin: "c2" 
 -- needOrigin:E: "c2"  E.ATd: "c2: var char" Ex: "c2" rec: "c2" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "c2" 
 -- doNeedOrigin:E: "c2" 
 -- computeAdrX:superAdj: 0 "c2" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "c2" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$24 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30 "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- computeAdrX:isLast:E:  "c2 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 --  rec:  "c2 "E:  "c2 "
 -- INV:gen:E.loadArgs "c2 "
 -- INV:gen:after:E.loadArgs "c2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c2 ":Adr:off:3 size
 --  :0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:
 --  F:E:"c2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var c2 
 -- DI:invoke: "c2: var char" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"c2":rec:c2 isNotRemote: true 
 pushg 3 loop$14
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var char ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "c2 ":isBasicVal: true 
 -- case:B: c2 ObjectGenerator 3 0 3 false false 
 -- end:loadArgs:NonVirt: "<> c2 "
 -- BinaryExp:loadArgs:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj
 --  :0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:after:E.loadArgs "c1 <> c2 "
 --  OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:T originIsValue:F:E:"c1":rec:c1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "c1 <> c2 ":Adr:off:2 size:0 isFloat:
 --  F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":re
 --  c:c1 
 -- BinaryExp:invoke: "c1 "rec: "c1 <> c2 "
 -- M: "<> c2 ":Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F 
 --  isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:before:ATdx.invoke: pattern <>   
 -- ptn:invoke: "<>   "E: "<> c2 "ptnKind: 0 useRtnV: true 
 ne
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"<> c2":rec:c1 nl; adrx: :Adr:off:0 si
 --  ze:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValu
 --  e:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"<> c2":rec:c1 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  26   "$26 "
 invoke $26 26 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $26 26 1 repeat$24 24
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "Beq := false" 
 pushThis 
 -- items:goOrigin:encOG: "$26 "on: 4 isValueObj: false 
 --  origin: repeat$24 origin:isValueObj: false 
 rpushg $26$26 1
 -- items:goOrigin:encOG: "repeat$24 "on: 3 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30 "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- AssignmentStatement:gen: 
 --  "Beq := false" right.label: "ObjectGenerator ""false" 
 -- OG:before:super.gen: "false "
 -- INV:gen: "false" 
 -- needorigin: "false" 
 -- needOrigin:E: "false"  E.ATd: 
 --  False: 
 --     %globals
 --     out B: var boolean
 --     B := 0
 --  Ex: "false" rec: "false" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  %globals
 --     out B: var boolean
 --     B := 0
 --  
 -- after:needOrigin: "false" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "false "E:  "false "
 -- INV:gen:E.loadArgs "false "
 -- INV:gen:after:E.loadArgs "false "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "false "
 -- OI:invoke:before:ATdx.invoke: pattern False 
 -- ptn:invoke: "False "E: "false "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "false" 
 --  adr:none 
 invoke False 27 0 0
 -- global:pushOut: B off: 1 
 pushg 1 
 -- callInvoke:after:pushOut: 1 
 -- GeneralPTN:invoke:after:callInvoke: 1 
 -- OI:invoke:V: nl; adrx: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0
 --   isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: 
 --  adrx: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg =$13 3
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "leave(loop) "
 -- INV:gen: "leave(loop)" 
 -- needorigin: "leave(loop)" 
 -- needOrigin:E: "leave(loop)"  E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  Ex: "leave(loop)" rec: "leave(loop)" 
 -- doNeedOrigin:Ex: "leave(loop) "originIsValueObj: false origin.isPrimitive:
 --   false 
 -- KUK 
 -- after:needOrigin: "leave(loop)" 
 -- doNeedOrigin:E: "leave(loop)" 
 -- computeAdrX:superAdj: 0 "leave(loop)" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "leave(loop)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "leave(loop) "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:- 
 --  rec:  "leave(loop) "E:  "leave(loop) "
 -- INV:gen:E.loadArgs "leave(loop) "
 -- INV:gen:after:E.loadArgs "leave(loop) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "leave(loop) ":Adr
 --  :off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori
 --  ginIsValue:F:E:"leave(loop)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- ptn:invoke: "leave(V: var integer) "E: "leave(loop) "ptnKind: 0 useRtnV: false 
 break  3 2 14 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS False 27 0 BETA 2
 allocEventQ
 mvStack 
 -- DI:gen: "out B: var boolean" DI:isConst: false :isBasicValue: true :primNo: 4 
 -- DI:add:BP1:  B 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "B := 0" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "B := 0" right.label: "ObjectGenerator ""0" 
 -- OG:before:super.gen: "0 "
 -- INV:gen: "0" 
 -- needorigin: "0" 
 -- needOrigin:E: "0"  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "0" rec: "0" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "0" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "0 "E:  "0 "
 -- INV:gen:E.loadArgs "0 "
 -- INV:gen:after:E.loadArgs "0 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0 "
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg False$27 1
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS for:to:repeat$30 30 4 loop 14
 -- vdtTableCopy: I:1:28 V:2:29
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- NonVirt: 
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --  "ObjectInvocation_KeyWord" ActArg: "1 "isValue: true formalArg: "first: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --        Beq := false
 --        leave(loop)
 --   " isCompositeValueObj: false 
 -- OG:before:super.gen: "1 "
 -- INV:gen: "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "1" rec: "1" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "1" 
 -- IV:after:computeAdr:superAdj: 4 
 --  rec:  "1 "E:  "1 "
 -- INV:gen:E.loadArgs "1 "
 -- INV:gen:after:E.loadArgs "1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1 "
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "first: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- end:loadArgs:NonVirt: "for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --        Beq := false
 --        leave(loop)
 --   "
 -- NonVirt: 
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --  "ObjectInvocation_KeyWord" ActArg: "length "isValue: false formalArg: "last: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --        Beq := false
 --        leave(loop)
 --   " isCompositeValueObj: false 
 -- OG:before:super.gen: "length "
 -- INV:gen: "length" 
 -- needorigin: "length" 
 -- needOrigin:E: "length"  E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  Ex: "length" rec: "length" 
 -- doNeedOrigin:Ex: "length "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "length" 
 -- doNeedOrigin:E: "length" 
 -- computeAdrX:superAdj: 4 "length" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "length" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 rpushg loop$14 4
 -- items:goOrigin:encOG: "loop "on: 2 isValueObj: false 
 --  origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- items:goOrigin:encOG: "= "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg =$13 1
 -- computeAdrX:isLast:E:  "length "
 -- IV:after:computeAdr:superAdj: 4 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 --  rec:  "length "E:  "length "
 -- INV:gen:E.loadArgs "length "
 -- INV:gen:after:E.loadArgs "length "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length ":Adr:off:0 
 --  size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsVa
 --  lue:F:E:"length":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- ptn:invoke: "length "E: "length "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "length" 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F
 --   originIsValue:F:E:"length":rec:length 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:0 size:0 isFloat:F isUnitVal:F superA
 --  dj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUn
 --  ique:F isValue:F originIsValue:F:E:"length":rec:length nl; adrx: :Adr:off
 --  :2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originI
 --  sValue:F:E:"length":rec:length 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUn
 --  ique:F isValue:F originIsValue:F:E:"length":rec:length 
 --  adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isVa
 --  lue:F originIsValue:F:E:"length":rec:length 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isU
 --  nique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- actualArg:isPtn: true formalArg:isPtn: "last: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "length ":isBasicVal: true 
 -- case:B: length ObjectGenerator 1 0 0 false false 
 -- end:loadArgs:NonVirt: "for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --        Beq := false
 --        leave(loop)
 --   "
 pushThis 
 storeg integer$5 2
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- DI:gen: "inx: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  inx 
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0

 CLASS <= 58 1 Value 4
 jmpFalse  L3
 pushThis 
 -- vassign:B: Veq off: 4 size: 2 mode: 0 
 vassign  4 2 0
 jmp L4
 L3:
 invokeVal  Veq 31 3
 rpop 
 L4:
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in Veq: var this(Value)" DI:isConst: false :isBasicValue: false :primNo: 18 
 -- DI:add:BP4:  Veq 
 -- inArg: in Veq: var this(Value) 
 -- DI:gen: "out Beq: var boolean" DI:isConst: false :isBasicValue: true :primNo: 4 
 -- DI:add:BP1:  Beq 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0

 CLASS <= 84 1 String 10
 -- vdtTableCopy: I:1:58
 rShiftUp  1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- super <=
 pushThis 
 rpushg iOrigin 1
 rShiftDown  1
 pushThis 
 rstoreg  Veq 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in Veq: var this(Value)" DI:isConst: false :isBasicValue: false :primNo: 18 
 -- DI:add:BP4:  Veq 
 -- inArg: in Veq: var this(Value) 
 -- DI:gen: "out Beq: var boolean" DI:isConst: false :isBasicValue: true :primNo: 4 
 -- DI:add:BP1:  Beq 
 -- DI:gen: 
 --  loop: obj 
 --     -- "Hello"  <= "World" since H <= W
 --     -- "Qweabc" <= "Qwevwxy" since a <= e
 --     -- "Qweayc" <= "Qwexby"
 --  DI:isConst: true :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  loop 
 -- DI:off: 4 this: 
 --  loop: obj 
 --     -- "Hello"  <= "World" since H <= W
 --     -- "Qweabc" <= "Qwevwxy" since a <= e
 --     -- "Qweayc" <= "Qwexby"
 --  
 --  
 pushThis 
 -- before objTmpStack:add:  85   "loop "
 invoke loop 85 4 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS loop 85 1 <= 84
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "L: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  L 
 -- DI:gen: "L1: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  L1 
 -- DI:gen: "L2: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  L2 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: 
 --  L1 := length
 --  -- min length of this and V
 --  
 pushThis 
 -- AssignmentStatement:gen: 
 --  
 --  L1 := length
 --  -- min length of this and V
 --  right.label: "ObjectGenerator "
 --  length
 --  -- min length of this and V
 --  
 -- OG:before:super.gen: "length
 --  -- min length of this and V "
 -- INV:gen: 
 --  length
 --  -- min length of this and V
 --  
 -- needorigin: 
 --  length
 --  -- min length of this and V
 --  
 -- needOrigin:E: 
 --  length
 --  -- min length of this and V
 --   E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  Ex: 
 --  length
 --  -- min length of this and V
 --  rec: 
 --  length
 --  -- min length of this and V
 --  
 -- doNeedOrigin:Ex: "length
 --  -- min length of this and V "originIsValueObj: false origin.isPrimitive
 --  : false 
 -- KUK 
 -- after:needOrigin: 
 --  length
 --  -- min length of this and V
 --  
 -- doNeedOrigin:E: 
 --  length
 --  -- min length of this and V
 --  
 -- computeAdrX:superAdj: 0 
 --  length
 --  -- min length of this and V
 --  
 -- computeAdrX:En: 1 pRec: none rec: none E: 
 --  length
 --  -- min length of this and V
 --  
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 2 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$85 1
 -- items:goOrigin:encOG: "<= "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg <=$84 1
 -- computeAdrX:isLast:E:  "length
 --  -- min length of this and V "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length
 --  -- min length of this and V":rec:- 
 --  rec:  "length
 --  -- min length of this and V "E:  "length
 --  -- min length of this and V "
 -- INV:gen:E.loadArgs "length
 --  -- min length of this and V "
 -- INV:gen:after:E.loadArgs "length
 --  -- min length of this and V "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length
 --  -- min length of this and V ":Adr:off:0 size:0 isFloat:F isUnitVal:F s
 --  uperAdj:0 isUnique:F isValue:F originIsValue:F:E:"length
 --  -- min length of this and V":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- ptn:invoke: "length "E: "length
 --  -- min length of this and V "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: 
 --  length
 --  -- min length of this and V
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"length
 --  -- min length of this and V":rec:length
 --  -- min length of this and V 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:0 size:0 isFloat:F isUnitVal:F superA
 --  dj:0 isUnique:F isValue:F originIsValue:F:E:"length
 --  -- min length of this and V":rec:length
 --  -- min length of this and V 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"length
 --  -- min length of this and V":rec:length
 --  -- min length of this and V nl; adrx: :Adr:off:2 size:0 isFloat:F isUnit
 --  Val:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length
 --  -- min length of this and V":rec:length
 --  -- min length of this and V 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"length
 --  -- min length of this and V":rec:length
 --  -- min length of this and V 
 --  adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"length
 --  -- min length of this and V":rec:length
 --  -- min length of this and V 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"length
 --  -- min length of this and V":rec:length
 --  -- min length of this and V 
 -- assign:adr.store:A: 
 storeg loop$85 3
 -- assign:adr.store:B: 
 -- AssignmentStatement:gen: "L2 := Veq.length" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "L2 := Veq.length" right.label: "ObjectGenerator ""Veq.length" 
 -- OG:before:super.gen: "Veq.length "
 -- INV:gen: "Veq.length" 
 -- needorigin: "Veq.length" 
 -- needOrigin:E: "length"  E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  Ex: "length" rec: "Veq" 
 -- doNeedOrigin:Ex: "length "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "length" 
 -- doNeedOrigin:E: "length" 
 -- computeAdrX:superAdj: 0 "Veq.length" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Veq" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$85 1
 -- computeAdrX:En: 2 pRec: "Veq" rec: "Veq" E: "length" 
 --  A.E: none 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "Veq" rec: "Veq" E: "length" 
 --  rec.ATd: "in Veq: var this(Value)" rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 --  recA: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"length":rec:- 
 --  pRecA: none 
 -- pRec: "Veq" rec: "Veq" E: "length" 
 --  false true 
 -- computeAdrX:before:rec:: "Veq" 
 -- OI:invoke:before:ATdx.invoke: var Veq 
 -- DI:invoke: "in Veq: var this(Value)" 
 -- isValueObj:isAdr: true objSize: 2  rec "Veq ",E: "length ""ObjectInvocation_
 --  Unary "E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"length":rec:Veq 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 rpushg loop$85 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- computeAdrX:after:rec.invoke: "Veq" 
 -- computeAdrX:isLast:E:  "length "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 --  rec:  "Veq "E:  "length "
 -- INV:gen:E.loadArgs "length "
 -- INV:gen:after:E.loadArgs "length "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length ":Adr:off:2 
 --  size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVa
 --  lue:F:E:"length":rec:Veq 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- ptn:invoke: "length "E: "length "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "Veq" 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"length":rec:Veq 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:2 size:0 isFloat:F isUnitVal:F superA
 --  dj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"length":rec:Veq nl; adrx: :Adr:off:2 
 --  size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVa
 --  lue:F:E:"length":rec:Veq 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 --  adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"length":rec:Veq 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- assign:adr.store:A: 
 storeg loop$85 4
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2 "
 -- INV:gen: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  
 -- needorigin: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  
 -- needOrigin:E: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  rec: 
 --  if (L1 < L2) :then 
 --     L := L1
 -- \
 --   :else 
 --     L := L2
 --  
 -- Ex:loadOrign:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2 "E:  "if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2 "
 -- INV:gen:E.loadArgs "if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2 "
 -- INV:gen:after:E.loadArgs "if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThenElse "if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2 "
 -- OG:before:super.gen: "(L1 < L2) "
 -- INV:gen: "(L1 < L2)" 
 -- needorigin: "(L1 < L2)" 
 -- needOrigin:E: "(L1 < L2)"  E.ATd: 
 --  <  : 
 --     %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  Ex: "(L1 < L2)" rec: "(L1 < L2)" 
 -- doNeedOrigin:Ex: "(L1 < L2) "originIsValueObj: true origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(L1 < L2)" 
 -- doNeedOrigin:E: "(L1 < L2)" 
 -- computeAdrX:superAdj: 0 "(L1 < L2)" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(L1 < L2)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "L1 < L2 "superAdj: 0 
 -- computeAdrX:isLast:E:  "L1 < L2 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "L1 < L2 "E:  "L1 < L2 "
 -- INV:gen:E.loadArgs "L1 < L2 "
 -- BinaryExp:loadArgs: "L1 < L2" superAdj: 0 
 -- INV:gen: "L1" 
 -- needorigin: "L1" 
 -- needOrigin:E: "L1"  E.ATd: "L1: var integer" Ex: "L1" rec: "L1" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L1" 
 -- doNeedOrigin:E: "L1" 
 -- computeAdrX:superAdj: 0 "L1" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L1" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "L1 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 --  rec:  "L1 "E:  "L1 "
 -- INV:gen:E.loadArgs "L1 "
 -- INV:gen:after:E.loadArgs "L1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L1 ":Adr:off:3 size
 --  :0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:
 --  F:E:"L1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- DI:invoke: "L1: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"L1":rec:L1 isNotRemote: true 
 pushg 3 loop$85
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnit
 --  Val:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- NonVirt: "< L2" "ObjectInvocation_Binary" ActArg: "L2 "isValue: false formalArg: "in V: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "< L2 " isCompositeValueObj: false 
 -- OG:before:super.gen: "L2 "
 -- INV:gen: "L2" 
 -- needorigin: "L2" 
 -- needOrigin:E: "L2"  E.ATd: "L2: var integer" Ex: "L2" rec: "L2" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L2" 
 -- doNeedOrigin:E: "L2" 
 -- computeAdrX:superAdj: 0 "L2" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L2" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "L2 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 --  rec:  "L2 "E:  "L2 "
 -- INV:gen:E.loadArgs "L2 "
 -- INV:gen:after:E.loadArgs "L2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L2 ":Adr:off:4 size
 --  :0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:
 --  F:E:"L2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- DI:invoke: "L2: var integer" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"L2":rec:L2 isNotRemote: true 
 pushg 4 loop$85
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "L2 ":isBasicVal: true 
 -- case:B: L2 ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "< L2 "
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj
 --  :0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:after:E.loadArgs "L1 < L2 "
 --  OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:T originIsValue:F:E:"L1":rec:L1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L1 < L2 ":Adr:off:3 size:0 isFloat:F
 --   isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec
 --  :L1 
 -- BinaryExp:invoke: "L1 "rec: "L1 < L2 "
 -- M: "< L2 ":Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F i
 --  sValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:before:ATdx.invoke: pattern <   
 -- ptn:invoke: "<   "E: "< L2 "ptnKind: 0 useRtnV: true 
 lt
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"< L2":rec:L1 nl; adrx: :Adr:off:0 siz
 --  e:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue
 --  :F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"< L2":rec:L1 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  87   "$87 "
 invoke $87 87 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L5
 L4:
 pushThis 
 -- before objTmpStack:add:  88   "$88 "
 invoke $88 88 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 L5:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- OG:before:super.gen: "matchEq "
 -- INV:gen: "matchEq" 
 -- needorigin: "matchEq" 
 -- needOrigin:E: "matchEq"  E.ATd: 
 --  matchEq: 
 --     inx: var integer
 --     c1: var char
 --     c2: var char
 --  Ex: "matchEq" rec: "matchEq" 
 -- doNeedOrigin:Ex: "matchEq "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "matchEq" 
 -- doNeedOrigin:E: "matchEq" 
 -- computeAdrX:superAdj: 0 "matchEq" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "matchEq" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "matchEq "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:- 
 --  rec:  "matchEq "E:  "matchEq "
 -- INV:gen:E.loadArgs "matchEq "
 -- INV:gen:after:E.loadArgs "matchEq "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "matchEq ":Adr:off:0
 --   size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsV
 --  alue:F:E:"matchEq":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern matchEq 
 -- ptn:invoke: "matchEq "E: "matchEq "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "matchEq" 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"matchEq":rec:matchEq 
 invoke matchEq 89 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"matchEq":rec:matchEq nl; adrx: :Adr:o
 --  ff:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F orig
 --  inIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"matchEq":rec:matchEq 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"matchEq":rec:matchEq 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS $87 87 1 loop 85
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "L := L1" 
 pushThis 
 -- items:goOrigin:encOG: "$87 "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $87$87 1
 -- AssignmentStatement:gen: 
 --  "L := L1" right.label: "ObjectGenerator ""L1" 
 -- OG:before:super.gen: "L1 "
 -- INV:gen: "L1" 
 -- needorigin: "L1" 
 -- needOrigin:E: "L1"  E.ATd: "L1: var integer" Ex: "L1" rec: "L1" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L1" 
 -- doNeedOrigin:E: "L1" 
 -- computeAdrX:superAdj: 0 "L1" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L1" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$87 "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $87$87 1
 -- computeAdrX:isLast:E:  "L1 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 --  rec:  "L1 "E:  "L1 "
 -- INV:gen:E.loadArgs "L1 "
 -- INV:gen:after:E.loadArgs "L1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L1 ":Adr:off:3 size
 --  :0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:
 --  F:E:"L1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- DI:invoke: "L1: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"L1":rec:L1 isNotRemote: true 
 pushg 3 loop$85
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- assign:adr.store:A: 
 storeg loop$85 2
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $88 88 1 loop 85
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "L := L2" 
 pushThis 
 -- items:goOrigin:encOG: "$88 "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $88$88 1
 -- AssignmentStatement:gen: 
 --  "L := L2" right.label: "ObjectGenerator ""L2" 
 -- OG:before:super.gen: "L2 "
 -- INV:gen: "L2" 
 -- needorigin: "L2" 
 -- needOrigin:E: "L2"  E.ATd: "L2: var integer" Ex: "L2" rec: "L2" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L2" 
 -- doNeedOrigin:E: "L2" 
 -- computeAdrX:superAdj: 0 "L2" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L2" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$88 "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $88$88 1
 -- computeAdrX:isLast:E:  "L2 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 --  rec:  "L2 "E:  "L2 "
 -- INV:gen:E.loadArgs "L2 "
 -- INV:gen:after:E.loadArgs "L2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L2 ":Adr:off:4 size
 --  :0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:
 --  F:E:"L2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- DI:invoke: "L2: var integer" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"L2":rec:L2 isNotRemote: true 
 pushg 4 loop$85
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- assign:adr.store:A: 
 storeg loop$85 2
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS matchEq 89 1 loop 85
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "inx: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  inx 
 -- DI:gen: "c1: var char" DI:isConst: false :isBasicValue: true :primNo: 3 
 -- DI:add:BP1:  c1 
 -- DI:gen: "c2: var char" DI:isConst: false :isBasicValue: true :primNo: 3 
 -- DI:add:BP1:  c2 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 pushThis 
 -- before objTmpStack:add:  90   "isEmpty "
 invoke isEmpty 90 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  93   "loop "
 invoke loop 93 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  96   "doit "
 invoke doit 96 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS isEmpty 90 1 matchEq 89
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq) "
 -- INV:gen: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  
 -- needorigin: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  
 -- needOrigin:E: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  rec: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  
 -- Ex:loadOrign:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq) "E:  "if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq) "
 -- INV:gen:E.loadArgs "if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq) "
 -- INV:gen:after:E.loadArgs "if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq) "
 -- OG:before:super.gen: "(L1 = 0) "
 -- INV:gen: "(L1 = 0)" 
 -- needorigin: "(L1 = 0)" 
 -- needOrigin:E: "(L1 = 0)"  E.ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  Ex: "(L1 = 0)" rec: "(L1 = 0)" 
 -- doNeedOrigin:Ex: "(L1 = 0) "originIsValueObj: true origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(L1 = 0)" 
 -- doNeedOrigin:E: "(L1 = 0)" 
 -- computeAdrX:superAdj: 0 "(L1 = 0)" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(L1 = 0)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "L1 = 0 "superAdj: 0 
 -- computeAdrX:isLast:E:  "L1 = 0 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "L1 = 0 "E:  "L1 = 0 "
 -- INV:gen:E.loadArgs "L1 = 0 "
 -- BinaryExp:loadArgs: "L1 = 0" superAdj: 0 
 -- INV:gen: "L1" 
 -- needorigin: "L1" 
 -- needOrigin:E: "L1"  E.ATd: "L1: var integer" Ex: "L1" rec: "L1" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L1" 
 -- doNeedOrigin:E: "L1" 
 -- computeAdrX:superAdj: 0 "L1" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L1" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "isEmpty "on: 2 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$90 1
 -- items:goOrigin:encOG: "matchEq "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$89 1
 -- computeAdrX:isLast:E:  "L1 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 --  rec:  "L1 "E:  "L1 "
 -- INV:gen:E.loadArgs "L1 "
 -- INV:gen:after:E.loadArgs "L1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L1 ":Adr:off:3 size
 --  :0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:
 --  F:E:"L1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- DI:invoke: "L1: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"L1":rec:L1 isNotRemote: true 
 pushg 3 loop$85
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnit
 --  Val:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- NonVirt: "= 0" "ObjectInvocation_Binary" ActArg: "0 "isValue: true formalArg: "in Veq: var this(Value)" 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "= 0 " isCompositeValueObj: true 
 -- OG:before:super.gen: "0 "
 -- INV:gen: "0" 
 -- needorigin: "0" 
 -- needOrigin:E: "0"  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "0" rec: "0" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "0" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "0 "E:  "0 "
 -- INV:gen:E.loadArgs "0 "
 -- INV:gen:after:E.loadArgs "0 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0 "
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- vEq: 
 -- end:loadArgs:NonVirt: "= 0 "
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj
 --  :0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:after:E.loadArgs "L1 = 0 "
 --  OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:T originIsValue:F:E:"L1":rec:L1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L1 = 0 ":Adr:off:3 size:0 isFloat:F 
 --  isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:
 --  L1 
 -- BinaryExp:invoke: "L1 "rec: "L1 = 0 "
 -- M: "= 0 ":Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F is
 --  Value:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:before:ATdx.invoke: pattern =   
 -- ptn:invoke: "=   "E: "= 0 "ptnKind: 1 useRtnV: true 
 -- E: "= 0" rec: "L1 ""Invocation "OGx: "integer" 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- rec.ATd: "L1: var integer" 
 -- bobs: 1 OGx: "integer" 
 -- 
 eq
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"= 0":rec:L1 nl; adrx: :Adr:off:0 size
 --  :0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:
 --  F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"= 0":rec:L1 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  91   "$91 "
 invoke $91 91 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- OG:before:super.gen: "if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq) "
 -- INV:gen: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  
 -- needorigin: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  
 -- needOrigin:E: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  rec: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  
 -- Ex:loadOrign:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq) "E:  "if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq) "
 -- INV:gen:E.loadArgs "if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq) "
 -- INV:gen:after:E.loadArgs "if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq) "
 -- OG:before:super.gen: "(L2 = 0) "
 -- INV:gen: "(L2 = 0)" 
 -- needorigin: "(L2 = 0)" 
 -- needOrigin:E: "(L2 = 0)"  E.ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  Ex: "(L2 = 0)" rec: "(L2 = 0)" 
 -- doNeedOrigin:Ex: "(L2 = 0) "originIsValueObj: true origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(L2 = 0)" 
 -- doNeedOrigin:E: "(L2 = 0)" 
 -- computeAdrX:superAdj: 0 "(L2 = 0)" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(L2 = 0)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "L2 = 0 "superAdj: 0 
 -- computeAdrX:isLast:E:  "L2 = 0 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "L2 = 0 "E:  "L2 = 0 "
 -- INV:gen:E.loadArgs "L2 = 0 "
 -- BinaryExp:loadArgs: "L2 = 0" superAdj: 0 
 -- INV:gen: "L2" 
 -- needorigin: "L2" 
 -- needOrigin:E: "L2"  E.ATd: "L2: var integer" Ex: "L2" rec: "L2" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L2" 
 -- doNeedOrigin:E: "L2" 
 -- computeAdrX:superAdj: 0 "L2" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L2" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "isEmpty "on: 2 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$90 1
 -- items:goOrigin:encOG: "matchEq "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$89 1
 -- computeAdrX:isLast:E:  "L2 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 --  rec:  "L2 "E:  "L2 "
 -- INV:gen:E.loadArgs "L2 "
 -- INV:gen:after:E.loadArgs "L2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L2 ":Adr:off:4 size
 --  :0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:
 --  F:E:"L2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- DI:invoke: "L2: var integer" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"L2":rec:L2 isNotRemote: true 
 pushg 4 loop$85
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- INV:gen:end:off: 4 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:4 size:0 isFloat:F isUnit
 --  Val:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- NonVirt: "= 0" "ObjectInvocation_Binary" ActArg: "0 "isValue: true formalArg: "in Veq: var this(Value)" 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "= 0 " isCompositeValueObj: true 
 -- OG:before:super.gen: "0 "
 -- INV:gen: "0" 
 -- needorigin: "0" 
 -- needOrigin:E: "0"  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "0" rec: "0" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "0" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "0 "E:  "0 "
 -- INV:gen:E.loadArgs "0 "
 -- INV:gen:after:E.loadArgs "0 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0 "
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- vEq: 
 -- end:loadArgs:NonVirt: "= 0 "
 -- BinaryExp:loadArgs:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj
 --  :0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- INV:gen:after:E.loadArgs "L2 = 0 "
 --  OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:T originIsValue:F:E:"L2":rec:L2 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L2 = 0 ":Adr:off:4 size:0 isFloat:F 
 --  isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:
 --  L2 
 -- BinaryExp:invoke: "L2 "rec: "L2 = 0 "
 -- M: "= 0 ":Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F is
 --  Value:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:before:ATdx.invoke: pattern =   
 -- ptn:invoke: "=   "E: "= 0 "ptnKind: 1 useRtnV: true 
 -- E: "= 0" rec: "L2 ""Invocation "OGx: "integer" 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- rec.ATd: "L2: var integer" 
 -- bobs: 1 OGx: "integer" 
 -- 
 eq
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"= 0":rec:L2 nl; adrx: :Adr:off:0 size
 --  :0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:
 --  F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"= 0":rec:L2 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L7
 L6:
 pushThis 
 -- before objTmpStack:add:  92   "$92 "
 invoke $92 92 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 L7:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $91 91 1 isEmpty 90
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "Beq := L1 <= L2" 
 pushThis 
 -- items:goOrigin:encOG: "$91 "on: 4 isValueObj: false 
 --  origin: isEmpty origin:isValueObj: false 
 rpushg $91$91 1
 -- items:goOrigin:encOG: "isEmpty "on: 3 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$90 1
 -- items:goOrigin:encOG: "matchEq "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$89 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$85 1
 -- AssignmentStatement:gen: 
 --  "Beq := L1 <= L2" right.label: "ObjectGenerator ""L1 <= L2" 
 -- OG:before:super.gen: "L1 <= L2 "
 -- INV:gen: "L1 <= L2" 
 -- needorigin: "L1 <= L2" 
 -- needOrigin:E: "L1 <= L2"  E.ATd: 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  Ex: "L1 <= L2" rec: "L1 <= L2" 
 -- doNeedOrigin:Ex: "L1 <= L2 "originIsValueObj: true origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "L1 <= L2" 
 -- doNeedOrigin:E: "L1 <= L2" 
 -- computeAdrX:superAdj: 0 "L1 <= L2" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L1 <= L2" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "L1 <= L2 "superAdj: 0 
 -- computeAdrX:isLast:E:  "L1 <= L2 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "L1 <= L2 "E:  "L1 <= L2 "
 -- INV:gen:E.loadArgs "L1 <= L2 "
 -- BinaryExp:loadArgs: "L1 <= L2" superAdj: 0 
 -- INV:gen: "L1" 
 -- needorigin: "L1" 
 -- needOrigin:E: "L1"  E.ATd: "L1: var integer" Ex: "L1" rec: "L1" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L1" 
 -- doNeedOrigin:E: "L1" 
 -- computeAdrX:superAdj: 0 "L1" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L1" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$91 "on: 3 isValueObj: false 
 --  origin: isEmpty origin:isValueObj: false 
 rpushg $91$91 1
 -- items:goOrigin:encOG: "isEmpty "on: 2 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$90 1
 -- items:goOrigin:encOG: "matchEq "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$89 1
 -- computeAdrX:isLast:E:  "L1 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 --  rec:  "L1 "E:  "L1 "
 -- INV:gen:E.loadArgs "L1 "
 -- INV:gen:after:E.loadArgs "L1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L1 ":Adr:off:3 size
 --  :0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:
 --  F:E:"L1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- DI:invoke: "L1: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"L1":rec:L1 isNotRemote: true 
 pushg 3 loop$85
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnit
 --  Val:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- NonVirt: "<= L2" "ObjectInvocation_Binary" ActArg: "L2 "isValue: false formalArg: "in Veq: var this(Value)" 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "<= L2 " isCompositeValueObj: true 
 -- OG:before:super.gen: "L2 "
 -- INV:gen: "L2" 
 -- needorigin: "L2" 
 -- needOrigin:E: "L2"  E.ATd: "L2: var integer" Ex: "L2" rec: "L2" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L2" 
 -- doNeedOrigin:E: "L2" 
 -- computeAdrX:superAdj: 0 "L2" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L2" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$91 "on: 3 isValueObj: false 
 --  origin: isEmpty origin:isValueObj: false 
 rpushg $91$91 1
 -- items:goOrigin:encOG: "isEmpty "on: 2 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$90 1
 -- items:goOrigin:encOG: "matchEq "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$89 1
 -- computeAdrX:isLast:E:  "L2 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 --  rec:  "L2 "E:  "L2 "
 -- INV:gen:E.loadArgs "L2 "
 -- INV:gen:after:E.loadArgs "L2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L2 ":Adr:off:4 size
 --  :0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:
 --  F:E:"L2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- DI:invoke: "L2: var integer" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"L2":rec:L2 isNotRemote: true 
 pushg 4 loop$85
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- vEq: 
 -- end:loadArgs:NonVirt: "<= L2 "
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj
 --  :0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:after:E.loadArgs "L1 <= L2 "
 --  OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:T originIsValue:F:E:"L1":rec:L1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L1 <= L2 ":Adr:off:3 size:0 isFloat:
 --  F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":re
 --  c:L1 
 -- BinaryExp:invoke: "L1 "rec: "L1 <= L2 "
 -- M: "<= L2 ":Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F 
 --  isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:before:ATdx.invoke: pattern <=   
 -- ptn:invoke: "<=   "E: "<= L2 "ptnKind: 1 useRtnV: true 
 -- E: "<= L2" rec: "L1 ""Invocation "OGx: "integer" 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- rec.ATd: "L1: var integer" 
 -- bobs: 1 OGx: "integer" 
 -- 
 le
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"<= L2":rec:L1 nl; adrx: :Adr:off:0 si
 --  ze:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValu
 --  e:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"<= L2":rec:L1 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg <=$84 3
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "leave(matchEq) "
 -- INV:gen: "leave(matchEq)" 
 -- needorigin: "leave(matchEq)" 
 -- needOrigin:E: "leave(matchEq)"  E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  Ex: "leave(matchEq)" rec: "leave(matchEq)" 
 -- doNeedOrigin:Ex: "leave(matchEq) "originIsValueObj: false origin.isPrimiti
 --  ve: false 
 -- KUK 
 -- after:needOrigin: "leave(matchEq)" 
 -- doNeedOrigin:E: "leave(matchEq)" 
 -- computeAdrX:superAdj: 0 "leave(matchEq)" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "leave(matchEq)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "leave(matchEq) "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec
 --  :- 
 --  rec:  "leave(matchEq) "E:  "leave(matchEq) "
 -- INV:gen:E.loadArgs "leave(matchEq) "
 -- INV:gen:after:E.loadArgs "leave(matchEq) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "leave(matchEq) ":
 --  Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F 
 --  originIsValue:F:E:"leave(matchEq)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- ptn:invoke: "leave(V: var integer) "E: "leave(matchEq) "ptnKind: 0 useRtnV:
 --   false 
 break  2 2 89 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq)
 --   
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $92 92 1 isEmpty 90
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "Beq := false" 
 pushThis 
 -- items:goOrigin:encOG: "$92 "on: 4 isValueObj: false 
 --  origin: isEmpty origin:isValueObj: false 
 rpushg $92$92 1
 -- items:goOrigin:encOG: "isEmpty "on: 3 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$90 1
 -- items:goOrigin:encOG: "matchEq "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$89 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$85 1
 -- AssignmentStatement:gen: 
 --  "Beq := false" right.label: "ObjectGenerator ""false" 
 -- OG:before:super.gen: "false "
 -- INV:gen: "false" 
 -- needorigin: "false" 
 -- needOrigin:E: "false"  E.ATd: 
 --  False: 
 --     %globals
 --     out B: var boolean
 --     B := 0
 --  Ex: "false" rec: "false" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  %globals
 --     out B: var boolean
 --     B := 0
 --  
 -- after:needOrigin: "false" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "false "E:  "false "
 -- INV:gen:E.loadArgs "false "
 -- INV:gen:after:E.loadArgs "false "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "false "
 -- OI:invoke:before:ATdx.invoke: pattern False 
 -- ptn:invoke: "False "E: "false "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "false" 
 --  adr:none 
 invoke False 27 0 0
 -- global:pushOut: B off: 1 
 pushg 1 
 -- callInvoke:after:pushOut: 1 
 -- GeneralPTN:invoke:after:callInvoke: 1 
 -- OI:invoke:V: nl; adrx: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0
 --   isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: 
 --  adrx: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg <=$84 3
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "leave(matchEq) "
 -- INV:gen: "leave(matchEq)" 
 -- needorigin: "leave(matchEq)" 
 -- needOrigin:E: "leave(matchEq)"  E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  Ex: "leave(matchEq)" rec: "leave(matchEq)" 
 -- doNeedOrigin:Ex: "leave(matchEq) "originIsValueObj: false origin.isPrimiti
 --  ve: false 
 -- KUK 
 -- after:needOrigin: "leave(matchEq)" 
 -- doNeedOrigin:E: "leave(matchEq)" 
 -- computeAdrX:superAdj: 0 "leave(matchEq)" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "leave(matchEq)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "leave(matchEq) "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec
 --  :- 
 --  rec:  "leave(matchEq) "E:  "leave(matchEq) "
 -- INV:gen:E.loadArgs "leave(matchEq) "
 -- INV:gen:after:E.loadArgs "leave(matchEq) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "leave(matchEq) ":
 --  Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F 
 --  originIsValue:F:E:"leave(matchEq)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- ptn:invoke: "leave(V: var integer) "E: "leave(matchEq) "ptnKind: 0 useRtnV:
 --   false 
 break  2 2 89 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq)
 --   
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS loop 93 1 matchEq 89
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "inx := inx + 1" 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$93 1
 -- AssignmentStatement:gen: 
 --  "inx := inx + 1" right.label: "ObjectGenerator ""inx + 1" 
 -- OG:before:super.gen: "inx + 1 "
 -- INV:gen: "inx + 1" 
 -- needorigin: "inx + 1" 
 -- needOrigin:E: "inx + 1"  E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  Ex: "inx + 1" rec: "inx + 1" 
 -- doNeedOrigin:Ex: "inx + 1 "originIsValueObj: true origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inx + 1" 
 -- doNeedOrigin:E: "inx + 1" 
 -- computeAdrX:superAdj: 0 "inx + 1" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx + 1" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "inx + 1 "superAdj: 0 
 -- computeAdrX:isLast:E:  "inx + 1 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "inx + 1 "E:  "inx + 1 "
 -- INV:gen:E.loadArgs "inx + 1 "
 -- BinaryExp:loadArgs: "inx + 1" superAdj: 0 
 -- INV:gen: "inx" 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" Ex: "inx" rec: "inx" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx" 
 -- doNeedOrigin:E: "inx" 
 -- computeAdrX:superAdj: 0 "inx" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$93 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx ":Adr:off:2 siz
 --  e:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue
 --  :F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 2 matchEq$89
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:2 size:0 isFloat:F isUnit
 --  Val:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- NonVirt: "+ 1" "ObjectInvocation_Binary" ActArg: "1 "isValue: true formalArg: "in V: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ 1 " isCompositeValueObj: false 
 -- OG:before:super.gen: "1 "
 -- INV:gen: "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "1" rec: "1" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "1" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "1 "E:  "1 "
 -- INV:gen:E.loadArgs "1 "
 -- INV:gen:after:E.loadArgs "1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1 "
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- end:loadArgs:NonVirt: "+ 1 "
 -- BinaryExp:loadArgs:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj
 --  :0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:after:E.loadArgs "inx + 1 "
 --  OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:T originIsValue:F:E:"inx":rec:inx 
 -- IV:E.invoke:useRtnVal: true E: BinOp "inx + 1 ":Adr:off:2 size:0 isFloat:F
 --   isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":re
 --  c:inx 
 -- BinaryExp:invoke: "inx "rec: "inx + 1 "
 -- M: "+ 1 ":Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F is
 --  Value:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- ptn:invoke: "+   "E: "+ 1 "ptnKind: 0 useRtnV: true 
 plus
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"+ 1":rec:inx nl; adrx: :Adr:off:0 siz
 --  e:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue
 --  :F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"+ 1":rec:inx 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg matchEq$89 2
 -- assign:adr.store:B: 
 -- AssignmentStatement:gen: "c1 := get[inx]" 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$93 1
 -- AssignmentStatement:gen: 
 --  "c1 := get[inx]" right.label: "ObjectGenerator ""get[inx]" 
 -- OG:before:super.gen: "get[inx] "
 -- INV:gen: "get[inx]" 
 -- needorigin: "get[inx]" 
 -- needOrigin:E: "get[inx]"  E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  Ex: "get[inx]" rec: "get[inx]" 
 -- doNeedOrigin:Ex: "get[inx] "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "get[inx]" 
 -- doNeedOrigin:E: "get[inx]" 
 -- computeAdrX:superAdj: 0 "get[inx]" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "get[inx]" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 4 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$93 1
 -- items:goOrigin:encOG: "matchEq "on: 3 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$89 1
 -- items:goOrigin:encOG: "loop "on: 2 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$85 1
 -- items:goOrigin:encOG: "<= "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg <=$84 1
 -- computeAdrX:isLast:E:  "get[inx] "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 --  rec:  "get[inx] "E:  "get[inx] "
 -- INV:gen:E.loadArgs "get[inx] "
 -- NonVirt: "get[inx]" "ObjectInvocation_KeyWord" ActArg: "inx "isValue: false formalArg: "inx: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx] " isCompositeValueObj: false 
 -- OG:before:super.gen: "inx "
 -- INV:gen: "inx" 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" Ex: "inx" rec: "inx" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx" 
 -- doNeedOrigin:E: "inx" 
 -- computeAdrX:superAdj: 0 "inx" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$93 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx ":Adr:off:2 siz
 --  e:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue
 --  :F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 2 matchEq$89
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "get[inx] "
 -- INV:gen:after:E.loadArgs "get[inx] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx] ":Adr:of
 --  f:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origin
 --  IsValue:F:E:"get[inx]":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- ptn:invoke: "get[inx: var integer] "E: "get[inx] "ptnKind: 0 useRtnV: true 
 xpushg  inx 1 0 1
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- assign:adr.store:A: 
 storeg matchEq$89 3
 -- assign:adr.store:B: 
 -- AssignmentStatement:gen: "c2 := Veq.get[inx]" 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$93 1
 -- AssignmentStatement:gen: 
 --  "c2 := Veq.get[inx]" right.label: "ObjectGenerator ""Veq.get[inx]" 
 -- OG:before:super.gen: "Veq.get[inx] "
 -- INV:gen: "Veq.get[inx]" 
 -- needorigin: "Veq.get[inx]" 
 -- needOrigin:E: "get[inx]"  E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  Ex: "get[inx]" rec: "Veq" 
 -- doNeedOrigin:Ex: "get[inx] "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "get[inx]" 
 -- doNeedOrigin:E: "get[inx]" 
 -- computeAdrX:superAdj: 0 "Veq.get[inx]" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Veq" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 3 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$93 1
 -- items:goOrigin:encOG: "matchEq "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$89 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$85 1
 -- computeAdrX:En: 2 pRec: "Veq" rec: "Veq" E: "get[inx]" 
 --  A.E: none 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "Veq" rec: "Veq" E: "get[inx]" 
 --  rec.ATd: "in Veq: var this(Value)" rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 --  recA: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"get[inx]":rec:- 
 --  pRecA: none 
 -- pRec: "Veq" rec: "Veq" E: "get[inx]" 
 --  false true 
 -- computeAdrX:before:rec:: "Veq" 
 -- OI:invoke:before:ATdx.invoke: var Veq 
 -- DI:invoke: "in Veq: var this(Value)" 
 -- isValueObj:isAdr: true objSize: 2  rec "Veq ",E: "get[inx] ""ObjectInvocatio
 --  n_KeyWord "E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"get[inx]":rec:Veq 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 rpushg loop$93 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- computeAdrX:after:rec.invoke: "Veq" 
 -- computeAdrX:isLast:E:  "get[inx] "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 --  rec:  "Veq "E:  "get[inx] "
 -- INV:gen:E.loadArgs "get[inx] "
 -- NonVirt: "get[inx]" "ObjectInvocation_KeyWord" ActArg: "inx "isValue: false formalArg: "inx: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx] " isCompositeValueObj: false 
 -- OG:before:super.gen: "inx "
 -- INV:gen: "inx" 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" Ex: "inx" rec: "inx" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx" 
 -- doNeedOrigin:E: "inx" 
 -- computeAdrX:superAdj: 0 "inx" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$93 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx ":Adr:off:2 siz
 --  e:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue
 --  :F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 2 matchEq$89
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "get[inx] "
 -- INV:gen:after:E.loadArgs "get[inx] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx] ":Adr:of
 --  f:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origin
 --  IsValue:F:E:"get[inx]":rec:Veq 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- ptn:invoke: "get[inx: var integer] "E: "get[inx] "ptnKind: 0 useRtnV: true 
 xpushg  inx 1 0 1
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- assign:adr.store:A: 
 storeg matchEq$89 4
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop) "
 -- INV:gen: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  
 -- needorigin: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  
 -- needOrigin:E: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  rec: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  
 -- Ex:loadOrign:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop) "E:  "if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop) "
 -- INV:gen:E.loadArgs "if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop) "
 -- INV:gen:after:E.loadArgs "if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop) "
 -- OG:before:super.gen: "(c1 = c2) "
 -- INV:gen: "(c1 = c2)" 
 -- needorigin: "(c1 = c2)" 
 -- needOrigin:E: "(c1 = c2)"  E.ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  Ex: "(c1 = c2)" rec: "(c1 = c2)" 
 -- doNeedOrigin:Ex: "(c1 = c2) "originIsValueObj: true origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(c1 = c2)" 
 -- doNeedOrigin:E: "(c1 = c2)" 
 -- computeAdrX:superAdj: 0 "(c1 = c2)" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(c1 = c2)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "c1 = c2 "superAdj: 0 
 -- computeAdrX:isLast:E:  "c1 = c2 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "c1 = c2 "E:  "c1 = c2 "
 -- INV:gen:E.loadArgs "c1 = c2 "
 -- BinaryExp:loadArgs: "c1 = c2" superAdj: 0 
 -- INV:gen: "c1" 
 -- needorigin: "c1" 
 -- needOrigin:E: "c1"  E.ATd: "c1: var char" Ex: "c1" rec: "c1" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "c1" 
 -- doNeedOrigin:E: "c1" 
 -- computeAdrX:superAdj: 0 "c1" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "c1" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$93 1
 -- computeAdrX:isLast:E:  "c1 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 --  rec:  "c1 "E:  "c1 "
 -- INV:gen:E.loadArgs "c1 "
 -- INV:gen:after:E.loadArgs "c1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c1 ":Adr:off:3 size
 --  :0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:
 --  F:E:"c1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var c1 
 -- DI:invoke: "c1: var char" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"c1":rec:c1 isNotRemote: true 
 pushg 3 matchEq$89
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnit
 --  Val:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- NonVirt: "= c2" "ObjectInvocation_Binary" ActArg: "c2 "isValue: false formalArg: "in Veq: var this(Value)" 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "= c2 " isCompositeValueObj: true 
 -- OG:before:super.gen: "c2 "
 -- INV:gen: "c2" 
 -- needorigin: "c2" 
 -- needOrigin:E: "c2"  E.ATd: "c2: var char" Ex: "c2" rec: "c2" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "c2" 
 -- doNeedOrigin:E: "c2" 
 -- computeAdrX:superAdj: 0 "c2" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "c2" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$93 1
 -- computeAdrX:isLast:E:  "c2 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 --  rec:  "c2 "E:  "c2 "
 -- INV:gen:E.loadArgs "c2 "
 -- INV:gen:after:E.loadArgs "c2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c2 ":Adr:off:4 size
 --  :0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:
 --  F:E:"c2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var c2 
 -- DI:invoke: "c2: var char" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"c2":rec:c2 isNotRemote: true 
 pushg 4 matchEq$89
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- vEq: 
 -- end:loadArgs:NonVirt: "= c2 "
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj
 --  :0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:after:E.loadArgs "c1 = c2 "
 --  OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:T originIsValue:F:E:"c1":rec:c1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "c1 = c2 ":Adr:off:3 size:0 isFloat:F
 --   isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec
 --  :c1 
 -- BinaryExp:invoke: "c1 "rec: "c1 = c2 "
 -- M: "= c2 ":Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F i
 --  sValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:before:ATdx.invoke: pattern =   
 -- ptn:invoke: "=   "E: "= c2 "ptnKind: 1 useRtnV: true 
 -- E: "= c2" rec: "c1 ""Invocation "OGx: "char" 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- rec.ATd: "c1: var char" 
 -- bobs: 3 OGx: "char" 
 -- 
 eq
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"= c2":rec:c1 nl; adrx: :Adr:off:0 siz
 --  e:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue
 --  :F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"= c2":rec:c1 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  94   "$94 "
 invoke $94 94 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $94 94 1 loop 93
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "if (inx < L) :then 
 --     restart(loop) "
 -- INV:gen: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  
 -- needorigin: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  
 -- needOrigin:E: 
 --  if (inx < L) :then 
 --     restart(loop)
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  rec: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  
 -- Ex:loadOrign:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "if (inx < L) :then 
 --     restart(loop) "E:  "if (inx < L) :then 
 --     restart(loop) "
 -- INV:gen:E.loadArgs "if (inx < L) :then 
 --     restart(loop) "
 -- INV:gen:after:E.loadArgs "if (inx < L) :then 
 --     restart(loop) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (inx < L) :then 
 --     restart(loop) "
 -- OG:before:super.gen: "(inx < L) "
 -- INV:gen: "(inx < L)" 
 -- needorigin: "(inx < L)" 
 -- needOrigin:E: "(inx < L)"  E.ATd: 
 --  <  : 
 --     %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  Ex: "(inx < L)" rec: "(inx < L)" 
 -- doNeedOrigin:Ex: "(inx < L) "originIsValueObj: true origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(inx < L)" 
 -- doNeedOrigin:E: "(inx < L)" 
 -- computeAdrX:superAdj: 0 "(inx < L)" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(inx < L)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "inx < L "superAdj: 0 
 -- computeAdrX:isLast:E:  "inx < L "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "inx < L "E:  "inx < L "
 -- INV:gen:E.loadArgs "inx < L "
 -- BinaryExp:loadArgs: "inx < L" superAdj: 0 
 -- INV:gen: "inx" 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" Ex: "inx" rec: "inx" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx" 
 -- doNeedOrigin:E: "inx" 
 -- computeAdrX:superAdj: 0 "inx" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$94 "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $94$94 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$93 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx ":Adr:off:2 siz
 --  e:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue
 --  :F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 2 matchEq$89
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:2 size:0 isFloat:F isUnit
 --  Val:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- NonVirt: "< L" "ObjectInvocation_Binary" ActArg: "L "isValue: false formalArg: "in V: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "< L " isCompositeValueObj: false 
 -- OG:before:super.gen: "L "
 -- INV:gen: "L" 
 -- needorigin: "L" 
 -- needOrigin:E: "L"  E.ATd: "L: var integer" Ex: "L" rec: "L" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L" 
 -- doNeedOrigin:E: "L" 
 -- computeAdrX:superAdj: 0 "L" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$94 "on: 3 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $94$94 1
 -- items:goOrigin:encOG: "loop "on: 2 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$93 1
 -- items:goOrigin:encOG: "matchEq "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$89 1
 -- computeAdrX:isLast:E:  "L "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 --  rec:  "L "E:  "L "
 -- INV:gen:E.loadArgs "L "
 -- INV:gen:after:E.loadArgs "L "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L ":Adr:off:2 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"L":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- DI:invoke: "L: var integer" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"L":rec:L isNotRemote: true 
 pushg 2 loop$85
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "L ":isBasicVal: true 
 -- case:B: L ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "< L "
 -- BinaryExp:loadArgs:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj
 --  :0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:after:E.loadArgs "inx < L "
 --  OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:T originIsValue:F:E:"inx":rec:inx 
 -- IV:E.invoke:useRtnVal: true E: BinOp "inx < L ":Adr:off:2 size:0 isFloat:F
 --   isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":re
 --  c:inx 
 -- BinaryExp:invoke: "inx "rec: "inx < L "
 -- M: "< L ":Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F is
 --  Value:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:before:ATdx.invoke: pattern <   
 -- ptn:invoke: "<   "E: "< L "ptnKind: 0 useRtnV: true 
 lt
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"< L":rec:inx nl; adrx: :Adr:off:0 siz
 --  e:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue
 --  :F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"< L":rec:inx 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  95   "$95 "
 invoke $95 95 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $95 95 1 $94 94
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "restart(loop) "
 -- INV:gen: "restart(loop)" 
 -- needorigin: "restart(loop)" 
 -- needOrigin:E: "restart(loop)"  E.ATd: 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  Ex: "restart(loop)" rec: "restart(loop)" 
 -- doNeedOrigin:Ex: "restart(loop) "originIsValueObj: false origin.isPrimitiv
 --  e: false 
 -- KUK 
 -- after:needOrigin: "restart(loop)" 
 -- doNeedOrigin:E: "restart(loop)" 
 -- computeAdrX:superAdj: 0 "restart(loop)" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "restart(loop)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "restart(loop) "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:
 --  - 
 --  rec:  "restart(loop) "E:  "restart(loop) "
 -- INV:gen:E.loadArgs "restart(loop) "
 -- INV:gen:after:E.loadArgs "restart(loop) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "restart(loop) ":A
 --  dr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F o
 --  riginIsValue:F:E:"restart(loop)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern restart(V: var integer) 
 -- ptn:invoke: "restart(V: var integer) "E: "restart(loop) "ptnKind: 0 useRtnV
 --  : false 
 break  2 1 93 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS doit 96 1 matchEq 89
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 --     Beq := c1 < c2
 --     leave(matchEq) "
 -- INV:gen: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 --  
 -- needorigin: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 --  
 -- needOrigin:E: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 --  rec: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 -- \
 --      leave(matchEq)
 --  :else 
 --  
 -- Ex:loadOrign:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 --     Beq := c1 < c2
 --     leave(matchEq) "E:  "if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 --     Beq := c1 < c2
 --     leave(matchEq) "
 -- INV:gen:E.loadArgs "if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 --     Beq := c1 < c2
 --     leave(matchEq) "
 -- INV:gen:after:E.loadArgs "if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 --     Beq := c1 < c2
 --     leave(matchEq) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThenElse "if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 --     Beq := c1 < c2
 --     leave(matchEq) "
 -- OG:before:super.gen: "(c1 = c2) "
 -- INV:gen: "(c1 = c2)" 
 -- needorigin: "(c1 = c2)" 
 -- needOrigin:E: "(c1 = c2)"  E.ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  Ex: "(c1 = c2)" rec: "(c1 = c2)" 
 -- doNeedOrigin:Ex: "(c1 = c2) "originIsValueObj: true origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(c1 = c2)" 
 -- doNeedOrigin:E: "(c1 = c2)" 
 -- computeAdrX:superAdj: 0 "(c1 = c2)" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(c1 = c2)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "c1 = c2 "superAdj: 0 
 -- computeAdrX:isLast:E:  "c1 = c2 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "c1 = c2 "E:  "c1 = c2 "
 -- INV:gen:E.loadArgs "c1 = c2 "
 -- BinaryExp:loadArgs: "c1 = c2" superAdj: 0 
 -- INV:gen: "c1" 
 -- needorigin: "c1" 
 -- needOrigin:E: "c1"  E.ATd: "c1: var char" Ex: "c1" rec: "c1" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "c1" 
 -- doNeedOrigin:E: "c1" 
 -- computeAdrX:superAdj: 0 "c1" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "c1" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "doit "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$96 1
 -- computeAdrX:isLast:E:  "c1 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 --  rec:  "c1 "E:  "c1 "
 -- INV:gen:E.loadArgs "c1 "
 -- INV:gen:after:E.loadArgs "c1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c1 ":Adr:off:3 size
 --  :0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:
 --  F:E:"c1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var c1 
 -- DI:invoke: "c1: var char" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"c1":rec:c1 isNotRemote: true 
 pushg 3 matchEq$89
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnit
 --  Val:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- NonVirt: "= c2" "ObjectInvocation_Binary" ActArg: "c2 "isValue: false formalArg: "in Veq: var this(Value)" 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "= c2 " isCompositeValueObj: true 
 -- OG:before:super.gen: "c2 "
 -- INV:gen: "c2" 
 -- needorigin: "c2" 
 -- needOrigin:E: "c2"  E.ATd: "c2: var char" Ex: "c2" rec: "c2" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "c2" 
 -- doNeedOrigin:E: "c2" 
 -- computeAdrX:superAdj: 0 "c2" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "c2" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "doit "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$96 1
 -- computeAdrX:isLast:E:  "c2 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 --  rec:  "c2 "E:  "c2 "
 -- INV:gen:E.loadArgs "c2 "
 -- INV:gen:after:E.loadArgs "c2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c2 ":Adr:off:4 size
 --  :0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:
 --  F:E:"c2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var c2 
 -- DI:invoke: "c2: var char" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"c2":rec:c2 isNotRemote: true 
 pushg 4 matchEq$89
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- vEq: 
 -- end:loadArgs:NonVirt: "= c2 "
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj
 --  :0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:after:E.loadArgs "c1 = c2 "
 --  OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:T originIsValue:F:E:"c1":rec:c1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "c1 = c2 ":Adr:off:3 size:0 isFloat:F
 --   isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec
 --  :c1 
 -- BinaryExp:invoke: "c1 "rec: "c1 = c2 "
 -- M: "= c2 ":Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F i
 --  sValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:before:ATdx.invoke: pattern =   
 -- ptn:invoke: "=   "E: "= c2 "ptnKind: 1 useRtnV: true 
 -- E: "= c2" rec: "c1 ""Invocation "OGx: "char" 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- rec.ATd: "c1: var char" 
 -- bobs: 3 OGx: "char" 
 -- 
 eq
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"= c2":rec:c1 nl; adrx: :Adr:off:0 siz
 --  e:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue
 --  :F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"= c2":rec:c1 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  97   "$97 "
 invoke $97 97 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L5
 L4:
 pushThis 
 -- before objTmpStack:add:  98   "$98 "
 invoke $98 98 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 L5:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $97 97 1 doit 96
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "Beq := L1 <= L2" 
 pushThis 
 -- items:goOrigin:encOG: "$97 "on: 4 isValueObj: false 
 --  origin: doit origin:isValueObj: false 
 rpushg $97$97 1
 -- items:goOrigin:encOG: "doit "on: 3 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$96 1
 -- items:goOrigin:encOG: "matchEq "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$89 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$85 1
 -- AssignmentStatement:gen: 
 --  "Beq := L1 <= L2" right.label: "ObjectGenerator ""L1 <= L2" 
 -- OG:before:super.gen: "L1 <= L2 "
 -- INV:gen: "L1 <= L2" 
 -- needorigin: "L1 <= L2" 
 -- needOrigin:E: "L1 <= L2"  E.ATd: 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  Ex: "L1 <= L2" rec: "L1 <= L2" 
 -- doNeedOrigin:Ex: "L1 <= L2 "originIsValueObj: true origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "L1 <= L2" 
 -- doNeedOrigin:E: "L1 <= L2" 
 -- computeAdrX:superAdj: 0 "L1 <= L2" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L1 <= L2" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "L1 <= L2 "superAdj: 0 
 -- computeAdrX:isLast:E:  "L1 <= L2 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "L1 <= L2 "E:  "L1 <= L2 "
 -- INV:gen:E.loadArgs "L1 <= L2 "
 -- BinaryExp:loadArgs: "L1 <= L2" superAdj: 0 
 -- INV:gen: "L1" 
 -- needorigin: "L1" 
 -- needOrigin:E: "L1"  E.ATd: "L1: var integer" Ex: "L1" rec: "L1" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L1" 
 -- doNeedOrigin:E: "L1" 
 -- computeAdrX:superAdj: 0 "L1" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L1" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$97 "on: 3 isValueObj: false 
 --  origin: doit origin:isValueObj: false 
 rpushg $97$97 1
 -- items:goOrigin:encOG: "doit "on: 2 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$96 1
 -- items:goOrigin:encOG: "matchEq "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$89 1
 -- computeAdrX:isLast:E:  "L1 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 --  rec:  "L1 "E:  "L1 "
 -- INV:gen:E.loadArgs "L1 "
 -- INV:gen:after:E.loadArgs "L1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L1 ":Adr:off:3 size
 --  :0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:
 --  F:E:"L1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- DI:invoke: "L1: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"L1":rec:L1 isNotRemote: true 
 pushg 3 loop$85
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnit
 --  Val:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- NonVirt: "<= L2" "ObjectInvocation_Binary" ActArg: "L2 "isValue: false formalArg: "in Veq: var this(Value)" 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "<= L2 " isCompositeValueObj: true 
 -- OG:before:super.gen: "L2 "
 -- INV:gen: "L2" 
 -- needorigin: "L2" 
 -- needOrigin:E: "L2"  E.ATd: "L2: var integer" Ex: "L2" rec: "L2" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L2" 
 -- doNeedOrigin:E: "L2" 
 -- computeAdrX:superAdj: 0 "L2" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L2" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$97 "on: 3 isValueObj: false 
 --  origin: doit origin:isValueObj: false 
 rpushg $97$97 1
 -- items:goOrigin:encOG: "doit "on: 2 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$96 1
 -- items:goOrigin:encOG: "matchEq "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$89 1
 -- computeAdrX:isLast:E:  "L2 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 --  rec:  "L2 "E:  "L2 "
 -- INV:gen:E.loadArgs "L2 "
 -- INV:gen:after:E.loadArgs "L2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L2 ":Adr:off:4 size
 --  :0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:
 --  F:E:"L2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- DI:invoke: "L2: var integer" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"L2":rec:L2 isNotRemote: true 
 pushg 4 loop$85
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- vEq: 
 -- end:loadArgs:NonVirt: "<= L2 "
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj
 --  :0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:after:E.loadArgs "L1 <= L2 "
 --  OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:T originIsValue:F:E:"L1":rec:L1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L1 <= L2 ":Adr:off:3 size:0 isFloat:
 --  F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":re
 --  c:L1 
 -- BinaryExp:invoke: "L1 "rec: "L1 <= L2 "
 -- M: "<= L2 ":Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F 
 --  isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:before:ATdx.invoke: pattern <=   
 -- ptn:invoke: "<=   "E: "<= L2 "ptnKind: 1 useRtnV: true 
 -- E: "<= L2" rec: "L1 ""Invocation "OGx: "integer" 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- rec.ATd: "L1: var integer" 
 -- bobs: 1 OGx: "integer" 
 -- 
 le
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"<= L2":rec:L1 nl; adrx: :Adr:off:0 si
 --  ze:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValu
 --  e:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"<= L2":rec:L1 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg <=$84 3
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "leave(matchEq) "
 -- INV:gen: "leave(matchEq)" 
 -- needorigin: "leave(matchEq)" 
 -- needOrigin:E: "leave(matchEq)"  E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  Ex: "leave(matchEq)" rec: "leave(matchEq)" 
 -- doNeedOrigin:Ex: "leave(matchEq) "originIsValueObj: false origin.isPrimiti
 --  ve: false 
 -- KUK 
 -- after:needOrigin: "leave(matchEq)" 
 -- doNeedOrigin:E: "leave(matchEq)" 
 -- computeAdrX:superAdj: 0 "leave(matchEq)" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "leave(matchEq)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "leave(matchEq) "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec
 --  :- 
 --  rec:  "leave(matchEq) "E:  "leave(matchEq) "
 -- INV:gen:E.loadArgs "leave(matchEq) "
 -- INV:gen:after:E.loadArgs "leave(matchEq) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "leave(matchEq) ":
 --  Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F 
 --  originIsValue:F:E:"leave(matchEq)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- ptn:invoke: "leave(V: var integer) "E: "leave(matchEq) "ptnKind: 0 useRtnV:
 --   false 
 break  2 2 89 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq)
 --   
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $98 98 1 doit 96
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "Beq := c1 < c2" 
 pushThis 
 -- items:goOrigin:encOG: "$98 "on: 4 isValueObj: false 
 --  origin: doit origin:isValueObj: false 
 rpushg $98$98 1
 -- items:goOrigin:encOG: "doit "on: 3 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$96 1
 -- items:goOrigin:encOG: "matchEq "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$89 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$85 1
 -- AssignmentStatement:gen: 
 --  "Beq := c1 < c2" right.label: "ObjectGenerator ""c1 < c2" 
 -- OG:before:super.gen: "c1 < c2 "
 -- INV:gen: "c1 < c2" 
 -- needorigin: "c1 < c2" 
 -- needOrigin:E: "c1 < c2"  E.ATd: 
 --  <  : 
 --     %basic 51
 --     in V: var char
 --     out B: var boolean
 --  Ex: "c1 < c2" rec: "c1 < c2" 
 -- doNeedOrigin:Ex: "c1 < c2 "originIsValueObj: true origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "c1 < c2" 
 -- doNeedOrigin:E: "c1 < c2" 
 -- computeAdrX:superAdj: 0 "c1 < c2" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "c1 < c2" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "c1 < c2 "superAdj: 0 
 -- computeAdrX:isLast:E:  "c1 < c2 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "c1 < c2 "E:  "c1 < c2 "
 -- INV:gen:E.loadArgs "c1 < c2 "
 -- BinaryExp:loadArgs: "c1 < c2" superAdj: 0 
 -- INV:gen: "c1" 
 -- needorigin: "c1" 
 -- needOrigin:E: "c1"  E.ATd: "c1: var char" Ex: "c1" rec: "c1" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "c1" 
 -- doNeedOrigin:E: "c1" 
 -- computeAdrX:superAdj: 0 "c1" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "c1" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$98 "on: 2 isValueObj: false 
 --  origin: doit origin:isValueObj: false 
 rpushg $98$98 1
 -- items:goOrigin:encOG: "doit "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$96 1
 -- computeAdrX:isLast:E:  "c1 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 --  rec:  "c1 "E:  "c1 "
 -- INV:gen:E.loadArgs "c1 "
 -- INV:gen:after:E.loadArgs "c1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c1 ":Adr:off:3 size
 --  :0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:
 --  F:E:"c1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var c1 
 -- DI:invoke: "c1: var char" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"c1":rec:c1 isNotRemote: true 
 pushg 3 matchEq$89
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnit
 --  Val:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- NonVirt: "< c2" "ObjectInvocation_Binary" ActArg: "c2 "isValue: false formalArg: "in V: var char" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "< c2 " isCompositeValueObj: false 
 -- OG:before:super.gen: "c2 "
 -- INV:gen: "c2" 
 -- needorigin: "c2" 
 -- needOrigin:E: "c2"  E.ATd: "c2: var char" Ex: "c2" rec: "c2" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "c2" 
 -- doNeedOrigin:E: "c2" 
 -- computeAdrX:superAdj: 0 "c2" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "c2" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$98 "on: 2 isValueObj: false 
 --  origin: doit origin:isValueObj: false 
 rpushg $98$98 1
 -- items:goOrigin:encOG: "doit "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$96 1
 -- computeAdrX:isLast:E:  "c2 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 --  rec:  "c2 "E:  "c2 "
 -- INV:gen:E.loadArgs "c2 "
 -- INV:gen:after:E.loadArgs "c2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c2 ":Adr:off:4 size
 --  :0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:
 --  F:E:"c2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var c2 
 -- DI:invoke: "c2: var char" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"c2":rec:c2 isNotRemote: true 
 pushg 4 matchEq$89
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var char ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "c2 ":isBasicVal: true 
 -- case:B: c2 ObjectGenerator 3 0 3 false false 
 -- end:loadArgs:NonVirt: "< c2 "
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj
 --  :0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:after:E.loadArgs "c1 < c2 "
 --  OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:T originIsValue:F:E:"c1":rec:c1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "c1 < c2 ":Adr:off:3 size:0 isFloat:F
 --   isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec
 --  :c1 
 -- BinaryExp:invoke: "c1 "rec: "c1 < c2 "
 -- M: "< c2 ":Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F i
 --  sValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:before:ATdx.invoke: pattern <   
 -- ptn:invoke: "<   "E: "< c2 "ptnKind: 0 useRtnV: true 
 lt
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"< c2":rec:c1 nl; adrx: :Adr:off:0 siz
 --  e:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue
 --  :F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"< c2":rec:c1 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg <=$84 3
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "leave(matchEq) "
 -- INV:gen: "leave(matchEq)" 
 -- needorigin: "leave(matchEq)" 
 -- needOrigin:E: "leave(matchEq)"  E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  Ex: "leave(matchEq)" rec: "leave(matchEq)" 
 -- doNeedOrigin:Ex: "leave(matchEq) "originIsValueObj: false origin.isPrimiti
 --  ve: false 
 -- KUK 
 -- after:needOrigin: "leave(matchEq)" 
 -- doNeedOrigin:E: "leave(matchEq)" 
 -- computeAdrX:superAdj: 0 "leave(matchEq)" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "leave(matchEq)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "leave(matchEq) "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec
 --  :- 
 --  rec:  "leave(matchEq) "E:  "leave(matchEq) "
 -- INV:gen:E.loadArgs "leave(matchEq) "
 -- INV:gen:after:E.loadArgs "leave(matchEq) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "leave(matchEq) ":
 --  Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F 
 --  originIsValue:F:E:"leave(matchEq)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- ptn:invoke: "leave(V: var integer) "E: "leave(matchEq) "ptnKind: 0 useRtnV:
 --   false 
 break  2 2 89 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq)
 --   
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS puttext 100 1 ConsoleIF 8
 pushThis 
 rstoreg  T 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(puttext) "
 -- INV:gen: "inner(puttext)" 
 -- needorigin: "inner(puttext)" 
 -- needOrigin:E: "inner(puttext)"  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(puttext)" rec: "inner(puttext)" 
 -- doNeedOrigin:Ex: "inner(puttext) "originIsValueObj: false origin.isPrimiti
 --  ve: false 
 -- KUK 
 -- after:needOrigin: "inner(puttext)" 
 -- doNeedOrigin:E: "inner(puttext)" 
 -- computeAdrX:superAdj: 0 "inner(puttext)" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(puttext)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(puttext) "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec
 --  :- 
 --  rec:  "inner(puttext) "E:  "inner(puttext) "
 -- INV:gen:E.loadArgs "inner(puttext) "
 -- INV:gen:after:E.loadArgs "inner(puttext) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(puttext) ":
 --  Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F 
 --  originIsValue:F:E:"inner(puttext)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(puttext) "ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:inner(puttext) 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:inner(puttext) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:inner(puttext)
 --   
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS putint 101 1 ConsoleIF 8
 pushThis 
 storeg integer$5 2
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(putint) "
 -- INV:gen: "inner(putint)" 
 -- needorigin: "inner(putint)" 
 -- needOrigin:E: "inner(putint)"  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(putint)" rec: "inner(putint)" 
 -- doNeedOrigin:Ex: "inner(putint) "originIsValueObj: false origin.isPrimitiv
 --  e: false 
 -- KUK 
 -- after:needOrigin: "inner(putint)" 
 -- doNeedOrigin:E: "inner(putint)" 
 -- computeAdrX:superAdj: 0 "inner(putint)" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(putint)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(putint) "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:
 --  - 
 --  rec:  "inner(putint) "E:  "inner(putint) "
 -- INV:gen:E.loadArgs "inner(putint) "
 -- INV:gen:after:E.loadArgs "inner(putint) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(putint) ":A
 --  dr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F o
 --  riginIsValue:F:E:"inner(putint)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(putint) "ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"inner(putint)":rec:inner(putint) 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"inner(putint)":rec:inner(putint) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"inner(putint)":rec:inner(putint) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS workspace 102 1 BETAworld 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 pushThis 
 -- before objTmpStack:add:  103   "tinyS "
 invoke tinyS 103 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS tinyS 103 1 workspace 102
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: 
 --  R_foo: obj  -- off: 2
 --     X: var char
 --     C_foo: 
 --        put(x)
 --  DI:isConst: true :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  R_foo 
 -- DI:off: 2 this: 
 --  R_foo: obj  -- off: 2
 --     X: var char
 --     C_foo: 
 --        put(x)
 --  
 --  
 pushThis 
 -- before objTmpStack:add:  104   "R_foo "
 invoke R_foo 104 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- DI:gen: 
 --  S_foo: obj  -- off: 3
 --     cx: val 'e'
 --  DI:isConst: true :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  S_foo 
 -- DI:off: 3 this: 
 --  S_foo: obj  -- off: 3
 --     cx: val 'e'
 --  
 --  
 pushThis 
 -- before objTmpStack:add:  105   "S_foo "
 invoke S_foo 105 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- DI:gen: "cst: val 100" DI:isConst: true :isBasicValue: true :primNo: 1 
 -- DI:add:BP2:  cst 
 -- OG:before:super.gen: "100 "
 -- INV:gen: "100" 
 -- needorigin: "100" 
 -- needOrigin:E: "100"  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "100" rec: "100" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "100" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "100 "E:  "100 "
 -- INV:gen:E.loadArgs "100 "
 -- INV:gen:after:E.loadArgs "100 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "100 "
 pushc 100
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 pushThis 
 storeg cst 4
 -- DI:gen: 
 --  ch: var Char -- off: 5
 --  --xxx: obj X_foo
 --  DI:isConst: false :isBasicValue: true :primNo: 3 
 -- DI:add:BP1:  ch 
 -- DI:gen: "XX_foo: ref nest_foo" DI:isConst: false :isBasicValue: false :primNo: 0 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "A_foo "
 -- INV:gen: "A_foo" 
 -- needorigin: "A_foo" 
 -- needOrigin:E: "A_foo"  E.ATd: 
 --  A_foo: 
 --     put('a')
 --  Ex: "A_foo" rec: "A_foo" 
 -- doNeedOrigin:Ex: "A_foo "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "A_foo" 
 -- doNeedOrigin:E: "A_foo" 
 -- computeAdrX:superAdj: 0 "A_foo" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "A_foo" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "A_foo "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"A_foo":rec:- 
 --  rec:  "A_foo "E:  "A_foo "
 -- INV:gen:E.loadArgs "A_foo "
 -- INV:gen:after:E.loadArgs "A_foo "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "A_foo ":Adr:off:0 s
 --  ize:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVal
 --  ue:F:E:"A_foo":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern A_foo 
 -- ptn:invoke: "A_foo "E: "A_foo "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "A_foo" 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"A_foo":rec:A_foo 
 invoke A_foo 106 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"A_foo":rec:A_foo nl; adrx: :Adr:off:-
 --  1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIs
 --  Value:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"A_foo":rec:A_foo 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"A_foo":rec:A_foo 
 -- OG:before:super.gen: "B_foo('b') "
 -- INV:gen: "B_foo('b')" 
 -- needorigin: "B_foo('b')" 
 -- needOrigin:E: "B_foo('b')"  E.ATd: 
 --  B_foo(B: var Char): 
 --     put(B)
 --  Ex: "B_foo('b')" rec: "B_foo('b')" 
 -- doNeedOrigin:Ex: "B_foo('b') "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "B_foo('b')" 
 -- doNeedOrigin:E: "B_foo('b')" 
 -- computeAdrX:superAdj: 0 "B_foo('b')" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "B_foo('b')" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "B_foo('b') "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"B_foo('b')":rec:- 
 --  rec:  "B_foo('b') "E:  "B_foo('b') "
 -- INV:gen:E.loadArgs "B_foo('b') "
 -- NonVirt: "B_foo('b')" "ObjectInvocation_KeyWord" ActArg: "'b' "isValue: true formalArg: "B: var Char" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "B_foo('b') " isCompositeValueObj: false 
 -- OG:before:super.gen: "'b' "
 -- INV:gen: "'b'" 
 -- needorigin: "'b'" 
 -- needOrigin:E: "'b'"  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  Ex: "'b'" rec: "'b'" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  
 -- after:needOrigin: "'b'" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "'b' "E:  "'b' "
 -- INV:gen:E.loadArgs "'b' "
 -- INV:gen:after:E.loadArgs "'b' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "'b' "
 pushc 98
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "B: var Char ":isBasicVal: true :v
 --  alueObj: true 
 --  :actArg: "'b' ":isBasicVal: true 
 -- case:B: 'b' ObjectGenerator 3 3 3 false true 
 -- end:loadArgs:NonVirt: "B_foo('b') "
 -- INV:gen:after:E.loadArgs "B_foo('b') "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "B_foo('b') ":Adr:
 --  off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F orig
 --  inIsValue:F:E:"B_foo('b')":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern B_foo(B: var Char) 
 -- ptn:invoke: "B_foo(B: var Char) "E: "B_foo('b') "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "B_foo('b')" 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"B_foo('b')":rec:B_foo('b') 
 invoke B_foo 107 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"B_foo('b')":rec:B_foo('b') nl; adrx:
 --   :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:
 --  F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"B_foo('b')":rec:B_foo('b') 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"B_foo('b')":rec:B_foo('b') 
 -- AssignmentStatement:gen: "R_foo.X := 'c'" 
 pushThis 
 -- computeAdrG:pRec: "R_foo" E: "X" 
 -- OI:invoke:before:ATdx.invoke: obj R_foo 
 -- DI:invoke: 
 --  R_foo: obj  -- off: 2
 --     X: var char
 --     C_foo: 
 --        put(x)
 --  
 -- >Object:unique: false 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"X":rec:R_foo isNotRemote: false 
 rpushg tinyS$103 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"X":rec:R_foo 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"X":rec:R_foo 
 -- AssignmentStatement:gen: 
 --  "R_foo.X := 'c'" right.label: "ObjectGenerator ""'c'" 
 -- OG:before:super.gen: "'c' "
 -- INV:gen: "'c'" 
 -- needorigin: "'c'" 
 -- needOrigin:E: "'c'"  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  Ex: "'c'" rec: "'c'" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  
 -- after:needOrigin: "'c'" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "'c' "E:  "'c' "
 -- INV:gen:E.loadArgs "'c' "
 -- INV:gen:after:E.loadArgs "'c' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "'c' "
 pushc 99
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg tinyS$103 2
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "R_foo.C_foo "
 -- INV:gen: "R_foo.C_foo" 
 -- needorigin: "R_foo.C_foo" 
 -- needOrigin:E: "C_foo"  E.ATd: 
 --  C_foo: 
 --     put(x)
 --  Ex: "C_foo" rec: "R_foo" 
 -- doNeedOrigin:Ex: "C_foo "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "C_foo" 
 -- doNeedOrigin:E: "C_foo" 
 -- computeAdrX:superAdj: 0 "R_foo.C_foo" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "R_foo" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "R_foo" rec: "R_foo" E: "C_foo" 
 --  A.E: none 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "R_foo" rec: "R_foo" E: "C_foo" 
 --  rec.ATd: 
 --  R_foo: obj  -- off: 2
 --     X: var char
 --     C_foo: 
 --        put(x)
 --  rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  %visible LIB.Dimensions
 --     A_foo: 
 --        put('a')
 --     B_foo(B: var Char): 
 --  
 --  recA: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"C_foo":rec:- 
 --  pRecA: none 
 -- pRec: "R_foo" rec: "R_foo" E: "C_foo" 
 --  false false 
 -- computeAdrX:before:rec:: "R_foo" 
 -- OI:invoke:before:ATdx.invoke: obj R_foo 
 -- DI:invoke: 
 --  R_foo: obj  -- off: 2
 --     X: var char
 --     C_foo: 
 --        put(x)
 --  
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"C_foo":rec:R_foo 
 rpushg tinyS$103 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"C_foo":rec:R_foo 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"C_foo":rec:R_foo 
 -- computeAdrX:after:rec.invoke: "R_foo" 
 -- computeAdrX:isLast:E:  "C_foo "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"C_foo":rec:R_foo 
 --  rec:  "R_foo "E:  "C_foo "
 -- INV:gen:E.loadArgs "C_foo "
 -- INV:gen:after:E.loadArgs "C_foo "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "C_foo ":Adr:off:2 s
 --  ize:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVal
 --  ue:F:E:"C_foo":rec:R_foo 
 -- OI:invoke:before:ATdx.invoke: pattern C_foo 
 -- ptn:invoke: "C_foo "E: "C_foo "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "R_foo" 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"C_foo":rec:R_foo 
 invoke C_foo 108 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"C_foo":rec:R_foo nl; adrx: :Adr:off:-
 --  1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIs
 --  Value:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"C_foo":rec:R_foo 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"C_foo":rec:R_foo 
 -- AssignmentStatement:gen: "ch := cst" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "ch := cst" right.label: "ObjectGenerator ""cst" 
 -- OG:before:super.gen: "cst "
 -- INV:gen: "cst" 
 pushc 100
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg tinyS$103 5
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "put(ch) "
 -- INV:gen: "put(ch)" 
 -- needorigin: "put(ch)" 
 -- needOrigin:E: "put(ch)"  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put(ch)" rec: "put(ch)" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put(ch)" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put(ch) "E:  "put(ch) "
 -- INV:gen:E.loadArgs "put(ch) "
 -- NonVirt: "put(ch)" "ObjectInvocation_KeyWord" ActArg: "ch "isValue: false formalArg: "in ch: val char" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(ch) " isCompositeValueObj: false 
 -- OG:before:super.gen: "ch "
 -- INV:gen: "ch" 
 -- needorigin: "ch" 
 -- needOrigin:E: "ch"  E.ATd: 
 --  ch: var Char -- off: 5
 --  --xxx: obj X_foo
 --  Ex: "ch" rec: "ch" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "ch" 
 -- doNeedOrigin:E: "ch" 
 -- computeAdrX:superAdj: 0 "ch" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "ch" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "ch "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:5 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"ch":rec:- 
 --  rec:  "ch "E:  "ch "
 -- INV:gen:E.loadArgs "ch "
 -- INV:gen:after:E.loadArgs "ch "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "ch ":Adr:off:5 size
 --  :0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:
 --  F:E:"ch":rec:- 
 -- OI:invoke:before:ATdx.invoke: var ch 
 -- DI:invoke: 
 --  ch: var Char -- off: 5
 --  --xxx: obj X_foo
 --  
 -- load: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"ch":rec:ch isNotRemote: true 
 pushg 5 tinyS$103
 -- OI:invoke:V: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"ch":rec:ch 
 -- OI:invoke:X: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"ch":rec:ch 
 -- INV:gen:end:off: 5 
 -- OG:gen:end: OIadr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"ch":rec:ch 
 -- actualArg:isPtn: false formalArg:isPtn: "in ch: val char ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "ch ":isBasicVal: true 
 -- case:B: ch ObjectGenerator 3 0 3 false false 
 -- end:loadArgs:NonVirt: "put(ch) "
 -- INV:gen:after:E.loadArgs "put(ch) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(ch) "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put(ch) "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- AssignmentStatement:gen: "ch := S_foo.cx" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "ch := S_foo.cx" right.label: "ObjectGenerator ""S_foo.cx" 
 -- OG:before:super.gen: "S_foo.cx "
 -- INV:gen: "S_foo.cx" 
 pushc 101
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg tinyS$103 5
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "put(ch) "
 -- INV:gen: "put(ch)" 
 -- needorigin: "put(ch)" 
 -- needOrigin:E: "put(ch)"  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put(ch)" rec: "put(ch)" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put(ch)" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put(ch) "E:  "put(ch) "
 -- INV:gen:E.loadArgs "put(ch) "
 -- NonVirt: "put(ch)" "ObjectInvocation_KeyWord" ActArg: "ch "isValue: false formalArg: "in ch: val char" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(ch) " isCompositeValueObj: false 
 -- OG:before:super.gen: "ch "
 -- INV:gen: "ch" 
 -- needorigin: "ch" 
 -- needOrigin:E: "ch"  E.ATd: 
 --  ch: var Char -- off: 5
 --  --xxx: obj X_foo
 --  Ex: "ch" rec: "ch" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "ch" 
 -- doNeedOrigin:E: "ch" 
 -- computeAdrX:superAdj: 0 "ch" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "ch" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "ch "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:5 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"ch":rec:- 
 --  rec:  "ch "E:  "ch "
 -- INV:gen:E.loadArgs "ch "
 -- INV:gen:after:E.loadArgs "ch "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "ch ":Adr:off:5 size
 --  :0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:
 --  F:E:"ch":rec:- 
 -- OI:invoke:before:ATdx.invoke: var ch 
 -- DI:invoke: 
 --  ch: var Char -- off: 5
 --  --xxx: obj X_foo
 --  
 -- load: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"ch":rec:ch isNotRemote: true 
 pushg 5 tinyS$103
 -- OI:invoke:V: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"ch":rec:ch 
 -- OI:invoke:X: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"ch":rec:ch 
 -- INV:gen:end:off: 5 
 -- OG:gen:end: OIadr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"ch":rec:ch 
 -- actualArg:isPtn: false formalArg:isPtn: "in ch: val char ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "ch ":isBasicVal: true 
 -- case:B: ch ObjectGenerator 3 0 3 false false 
 -- end:loadArgs:NonVirt: "put(ch) "
 -- INV:gen:after:E.loadArgs "put(ch) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(ch) "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put(ch) "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- OG:before:super.gen: "nest_foo "
 -- INV:gen: "nest_foo" 
 -- needorigin: "nest_foo" 
 -- needOrigin:E: "nest_foo"  E.ATd: 
 --  nest_foo: 
 --     C: var char
 --     C := ch + 1
 --     C := cst + 3
 --  Ex: "nest_foo" rec: "nest_foo" 
 -- doNeedOrigin:Ex: "nest_foo "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "nest_foo" 
 -- doNeedOrigin:E: "nest_foo" 
 -- computeAdrX:superAdj: 0 "nest_foo" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "nest_foo" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "nest_foo "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"nest_foo":rec:- 
 --  rec:  "nest_foo "E:  "nest_foo "
 -- INV:gen:E.loadArgs "nest_foo "
 -- INV:gen:after:E.loadArgs "nest_foo "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "nest_foo ":Adr:off:
 --  0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIs
 --  Value:F:E:"nest_foo":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern nest_foo 
 -- ptn:invoke: "nest_foo "E: "nest_foo "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "nest_foo" 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"nest_foo":rec:nest_foo 
 invoke nest_foo 109 0 1
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"nest_foo":rec:nest_foo nl; adrx: :Adr
 --  :off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F or
 --  iginIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"nest_foo":rec:nest_foo 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"nest_foo":rec:nest_foo 
 -- AssignmentStatement:gen: "ch := 103" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "ch := 103" right.label: "ObjectGenerator ""103" 
 -- OG:before:super.gen: "103 "
 -- INV:gen: "103" 
 -- needorigin: "103" 
 -- needOrigin:E: "103"  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "103" rec: "103" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "103" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "103 "E:  "103 "
 -- INV:gen:E.loadArgs "103 "
 -- INV:gen:after:E.loadArgs "103 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "103 "
 pushc 103
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg tinyS$103 5
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "asg_foo "
 -- INV:gen: "asg_foo" 
 -- needorigin: "asg_foo" 
 -- needOrigin:E: "asg_foo"  E.ATd: 
 --  asg_foo: 
 --     nl: val 102
 --     newline: var integer -- off: 3
 --     fox: obj  -- off: 4
 --  Ex: "asg_foo" rec: "asg_foo" 
 -- doNeedOrigin:Ex: "asg_foo "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "asg_foo" 
 -- doNeedOrigin:E: "asg_foo" 
 -- computeAdrX:superAdj: 0 "asg_foo" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "asg_foo" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "asg_foo "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asg_foo":rec:- 
 --  rec:  "asg_foo "E:  "asg_foo "
 -- INV:gen:E.loadArgs "asg_foo "
 -- INV:gen:after:E.loadArgs "asg_foo "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "asg_foo ":Adr:off:0
 --   size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsV
 --  alue:F:E:"asg_foo":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern asg_foo 
 -- ptn:invoke: "asg_foo "E: "asg_foo "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "asg_foo" 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"asg_foo":rec:asg_foo 
 invoke asg_foo 111 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"asg_foo":rec:asg_foo nl; adrx: :Adr:o
 --  ff:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F orig
 --  inIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"asg_foo":rec:asg_foo 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"asg_foo":rec:asg_foo 
 -- OG:before:super.gen: "try_val "
 -- INV:gen: "try_val" 
 -- needorigin: "try_val" 
 -- needOrigin:E: "try_val"  E.ATd: 
 --  try_val: 
 --     X: var float -- off: 2
 --     V_val: var V_foo -- off: 4
 --     V_val.X := 'j'
 --  Ex: "try_val" rec: "try_val" 
 -- doNeedOrigin:Ex: "try_val "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "try_val" 
 -- doNeedOrigin:E: "try_val" 
 -- computeAdrX:superAdj: 0 "try_val" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "try_val" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "try_val "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"try_val":rec:- 
 --  rec:  "try_val "E:  "try_val "
 -- INV:gen:E.loadArgs "try_val "
 -- INV:gen:after:E.loadArgs "try_val "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "try_val ":Adr:off:0
 --   size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsV
 --  alue:F:E:"try_val":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern try_val 
 -- ptn:invoke: "try_val "E: "try_val "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "try_val" 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"try_val":rec:try_val 
 invoke try_val 113 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"try_val":rec:try_val nl; adrx: :Adr:o
 --  ff:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F orig
 --  inIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"try_val":rec:try_val 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"try_val":rec:try_val 
 -- OG:before:super.gen: "string_foo "
 -- INV:gen: "string_foo" 
 -- needorigin: "string_foo" 
 -- needOrigin:E: "string_foo"  E.ATd: 
 --  string_foo: 
 --     S: var String
 --     R: ref Record
 --     T: ref Record
 --  Ex: "string_foo" rec: "string_foo" 
 -- doNeedOrigin:Ex: "string_foo "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "string_foo" 
 -- doNeedOrigin:E: "string_foo" 
 -- computeAdrX:superAdj: 0 "string_foo" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "string_foo" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "string_foo "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"string_foo":rec:- 
 --  rec:  "string_foo "E:  "string_foo "
 -- INV:gen:E.loadArgs "string_foo "
 -- INV:gen:after:E.loadArgs "string_foo "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "string_foo ":Adr:of
 --  f:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origin
 --  IsValue:F:E:"string_foo":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern string_foo 
 -- ptn:invoke: "string_foo "E: "string_foo "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "string_foo" 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"string_foo":rec:string_foo 
 invoke string_foo 119 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"string_foo":rec:string_foo nl; adrx:
 --   :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:
 --  F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"string_foo":rec:string_foo 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"string_foo":rec:string_foo 
 -- OG:before:super.gen: "point_foo "
 -- INV:gen: "point_foo" 
 -- needorigin: "point_foo" 
 -- needOrigin:E: "point_foo"  E.ATd: 
 --  point_foo: 
 --     P1: var Point('r','s')
 --     P2: var Point(0,0)
 --     P3: var PositivePoint('x','y')
 --  Ex: "point_foo" rec: "point_foo" 
 -- doNeedOrigin:Ex: "point_foo "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "point_foo" 
 -- doNeedOrigin:E: "point_foo" 
 -- computeAdrX:superAdj: 0 "point_foo" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "point_foo" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "point_foo "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"point_foo":rec:- 
 --  rec:  "point_foo "E:  "point_foo "
 -- INV:gen:E.loadArgs "point_foo "
 -- INV:gen:after:E.loadArgs "point_foo "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "point_foo ":Adr:off
 --  :0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI
 --  sValue:F:E:"point_foo":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern point_foo 
 -- ptn:invoke: "point_foo "E: "point_foo "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "point_foo" 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"point_foo":rec:point_foo 
 invoke point_foo 122 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"point_foo":rec:point_foo nl; adrx: :A
 --  dr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F 
 --  originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"point_foo":rec:point_foo 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"point_foo":rec:point_foo 
 -- OG:before:super.gen: "put('z') "
 -- INV:gen: "put('z')" 
 -- needorigin: "put('z')" 
 -- needOrigin:E: "put('z')"  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put('z')" rec: "put('z')" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put('z')" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put('z') "E:  "put('z') "
 -- INV:gen:E.loadArgs "put('z') "
 -- NonVirt: "put('z')" "ObjectInvocation_KeyWord" ActArg: "'z' "isValue: true formalArg: "in ch: val char" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put('z') " isCompositeValueObj: false 
 -- OG:before:super.gen: "'z' "
 -- INV:gen: "'z'" 
 -- needorigin: "'z'" 
 -- needOrigin:E: "'z'"  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  Ex: "'z'" rec: "'z'" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  
 -- after:needOrigin: "'z'" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "'z' "E:  "'z' "
 -- INV:gen:E.loadArgs "'z' "
 -- INV:gen:after:E.loadArgs "'z' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "'z' "
 pushc 122
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "'z' ":isBasicVal: true 
 -- case:B: 'z' ObjectGenerator 3 3 3 false true 
 -- end:loadArgs:NonVirt: "put('z') "
 -- INV:gen:after:E.loadArgs "put('z') "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put('z') "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put('z') "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- OG:before:super.gen: "newline "
 -- INV:gen: "newline" 
 -- needorigin: "newline" 
 -- needOrigin:E: "newline"  E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  Ex: "newline" rec: "newline" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  %globals
 --     put(10)
 --  
 -- after:needOrigin: "newline" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "newline "E:  "newline "
 -- INV:gen:E.loadArgs "newline "
 -- INV:gen:after:E.loadArgs "newline "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "newline "
 -- OI:invoke:before:ATdx.invoke: pattern newline 
 -- ptn:invoke: "newline "E: "newline "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "newline" 
 --  adr:none 
 invoke newline 129 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: nl; adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:
 --  0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- OG:before:super.gen: "virt_foo "
 -- INV:gen: "virt_foo" 
 -- needorigin: "virt_foo" 
 -- needOrigin:E: "virt_foo"  E.ATd: 
 --  virt_foo: 
 --     R1: ref Record
 --     R2: obj ShowRecord("CD")
 --     R1 := ShowRecord("AB")
 --  Ex: "virt_foo" rec: "virt_foo" 
 -- doNeedOrigin:Ex: "virt_foo "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "virt_foo" 
 -- doNeedOrigin:E: "virt_foo" 
 -- computeAdrX:superAdj: 0 "virt_foo" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "virt_foo" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "virt_foo "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"virt_foo":rec:- 
 --  rec:  "virt_foo "E:  "virt_foo "
 -- INV:gen:E.loadArgs "virt_foo "
 -- INV:gen:after:E.loadArgs "virt_foo "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "virt_foo ":Adr:off:
 --  0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIs
 --  Value:F:E:"virt_foo":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern virt_foo 
 -- ptn:invoke: "virt_foo "E: "virt_foo "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "virt_foo" 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"virt_foo":rec:virt_foo 
 invoke virt_foo 130 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"virt_foo":rec:virt_foo nl; adrx: :Adr
 --  :off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F or
 --  iginIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"virt_foo":rec:virt_foo 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"virt_foo":rec:virt_foo 
 -- OG:before:super.gen: "if ((ch = 'Q') && (cst = 100)) :then 
 --     put('Q')
 --  :else 
 --     put('E') "
 -- INV:gen: 
 --  if ((ch = 'Q') && (cst = 100)) :then 
 --     put('Q')
 --  :else 
 --     put('E')
 --  
 -- needorigin: 
 --  if ((ch = 'Q') && (cst = 100)) :then 
 --     put('Q')
 --  :else 
 --     put('E')
 --  
 -- needOrigin:E: 
 --  if ((ch = 'Q') && (cst = 100)) :then 
 --     put('Q')
 --  :else 
 --     put('E')
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if ((ch = 'Q') && (cst = 100)) :then 
 --     put('Q')
 --  :else 
 --     put('E')
 --  rec: 
 --  if ((ch = 'Q') && (cst = 100)) :then 
 --     put('Q')
 -- \
 --   :else 
 --     put('E')
 --  
 -- Ex:loadOrign:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if ((ch = 'Q') && (cst = 100)) :then 
 --     put('Q')
 --  :else 
 --     put('E')
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "if ((ch = 'Q') && (cst = 100)) :then 
 --     put('Q')
 --  :else 
 --     put('E') "E:  "if ((ch = 'Q') && (cst = 100)) :then 
 --     put('Q')
 --  :else 
 --     put('E') "
 -- INV:gen:E.loadArgs "if ((ch = 'Q') && (cst = 100)) :then 
 --     put('Q')
 --  :else 
 --     put('E') "
 -- INV:gen:after:E.loadArgs "if ((ch = 'Q') && (cst = 100)) :then 
 --     put('Q')
 --  :else 
 --     put('E') "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThenElse "if ((ch = 'Q') && (cst = 100)) 
 --  :then 
 --     put('Q')
 --  :else 
 --     put('E') "
 -- OG:before:super.gen: "((ch = 'Q') && (cst = 100)) "
 -- INV:gen: "((ch = 'Q') && (cst = 100))" 
 -- needorigin: "((ch = 'Q') && (cst = 100))" 
 -- needOrigin:E: "((ch = 'Q') && (cst = 100))"  E.ATd: 
 --  &&  : 
 --     %basic 70
 --     in B: var boolean
 --     out R: var boolean
 --  Ex: "((ch = 'Q') && (cst = 100))" rec: "((ch = 'Q') && (cst = 100))" 
 -- doNeedOrigin:Ex: "((ch = 'Q') && (cst = 100)) "originIsValueObj: true ori
 --  gin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "((ch = 'Q') && (cst = 100))" 
 -- doNeedOrigin:E: "((ch = 'Q') && (cst = 100))" 
 -- computeAdrX:superAdj: 0 "((ch = 'Q') && (cst = 100))" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "((ch = 'Q') && (cst = 100))" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "(ch = 'Q') && (cst = 100) "superAdj: 0 
 -- computeAdrX:isLast:E:  "(ch = 'Q') && (cst = 100) "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "(ch = 'Q') && (cst = 100) "E:  "(ch = 'Q') && (cst = 100) "
 -- INV:gen:E.loadArgs "(ch = 'Q') && (cst = 100) "
 -- BinaryExp:loadArgs: "(ch = 'Q') && (cst = 100)" superAdj: 0 
 -- INV:gen: "(ch = 'Q')" 
 -- needorigin: "(ch = 'Q')" 
 -- needOrigin:E: "(ch = 'Q')"  E.ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  Ex: "(ch = 'Q')" rec: "(ch = 'Q')" 
 -- doNeedOrigin:Ex: "(ch = 'Q') "originIsValueObj: true origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(ch = 'Q')" 
 -- doNeedOrigin:E: "(ch = 'Q')" 
 -- computeAdrX:superAdj: 0 "(ch = 'Q')" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(ch = 'Q')" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "ch = 'Q' "superAdj: 0 
 -- computeAdrX:isLast:E:  "ch = 'Q' "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "ch = 'Q' "E:  "ch = 'Q' "
 -- INV:gen:E.loadArgs "ch = 'Q' "
 -- BinaryExp:loadArgs: "ch = 'Q'" superAdj: 0 
 -- INV:gen: "ch" 
 -- needorigin: "ch" 
 -- needOrigin:E: "ch"  E.ATd: 
 --  ch: var Char -- off: 5
 --  --xxx: obj X_foo
 --  Ex: "ch" rec: "ch" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "ch" 
 -- doNeedOrigin:E: "ch" 
 -- computeAdrX:superAdj: 0 "ch" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "ch" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "ch "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:5 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"ch":rec:- 
 --  rec:  "ch "E:  "ch "
 -- INV:gen:E.loadArgs "ch "
 -- INV:gen:after:E.loadArgs "ch "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "ch ":Adr:off:5 size
 --  :0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:
 --  F:E:"ch":rec:- 
 -- OI:invoke:before:ATdx.invoke: var ch 
 -- DI:invoke: 
 --  ch: var Char -- off: 5
 --  --xxx: obj X_foo
 --  
 -- load: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"ch":rec:ch isNotRemote: true 
 pushg 5 tinyS$103
 -- OI:invoke:V: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"ch":rec:ch 
 -- OI:invoke:X: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"ch":rec:ch 
 -- INV:gen:end:off: 5 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:5 size:0 isFloat:F isUnit
 --  Val:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"ch":rec:ch 
 -- NonVirt: "= 'Q'" "ObjectInvocation_Binary" ActArg: "'Q' "isValue: true formalArg: "in Veq: var this(Value)" 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "= 'Q' " isCompositeValueObj: true 
 -- OG:before:super.gen: "'Q' "
 -- INV:gen: "'Q'" 
 -- needorigin: "'Q'" 
 -- needOrigin:E: "'Q'"  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  Ex: "'Q'" rec: "'Q'" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  
 -- after:needOrigin: "'Q'" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "'Q' "E:  "'Q' "
 -- INV:gen:E.loadArgs "'Q' "
 -- INV:gen:after:E.loadArgs "'Q' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "'Q' "
 pushc 81
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- vEq: 
 -- end:loadArgs:NonVirt: "= 'Q' "
 -- BinaryExp:loadArgs:end: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj
 --  :0 isUnique:F isValue:T originIsValue:F:E:"ch":rec:ch 
 -- INV:gen:after:E.loadArgs "ch = 'Q' "
 --  OIadr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:T originIsValue:F:E:"ch":rec:ch 
 -- IV:E.invoke:useRtnVal: true E: BinOp "ch = 'Q' ":Adr:off:5 size:0 isFloat:
 --  F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"ch":re
 --  c:ch 
 -- BinaryExp:invoke: "ch "rec: "ch = 'Q' "
 -- M: "= 'Q' ":Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F 
 --  isValue:T originIsValue:F:E:"ch":rec:ch 
 -- OI:invoke:before:ATdx.invoke: pattern =   
 -- ptn:invoke: "=   "E: "= 'Q' "ptnKind: 1 useRtnV: true 
 -- E: "= 'Q'" rec: "ch ""Invocation "OGx: 
 --  Char -- off: 5
 --  --xxx: obj X_foo
 --  
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- rec.ATd: 
 --  ch: var Char -- off: 5
 --  --xxx: obj X_foo
 --  
 -- bobs: 3 OGx: 
 --  Char -- off: 5
 --  --xxx: obj X_foo
 --  
 -- 
 eq
 -- OI:invoke:V: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"= 'Q'":rec:ch nl; adrx: :Adr:off:0 si
 --  ze:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValu
 --  e:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"= 'Q'":rec:ch 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 -- NonVirt: "&& (cst = 100)" "ObjectInvocation_Binary" ActArg: "(cst = 100) "isValue: false formalArg: "in B: var boolean" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "&& (cst = 100) " isCompositeValueObj: false 
 -- OG:before:super.gen: "(cst = 100) "
 -- INV:gen: "(cst = 100)" 
 -- needorigin: "(cst = 100)" 
 -- needOrigin:E: "(cst = 100)"  E.ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  Ex: "(cst = 100)" rec: "(cst = 100)" 
 -- doNeedOrigin:Ex: "(cst = 100) "originIsValueObj: true origin.isPrimitive:
 --   false 
 -- KUK 
 -- after:needOrigin: "(cst = 100)" 
 -- doNeedOrigin:E: "(cst = 100)" 
 -- computeAdrX:superAdj: 0 "(cst = 100)" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(cst = 100)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "cst = 100 "superAdj: 0 
 -- computeAdrX:isLast:E:  "cst = 100 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "cst = 100 "E:  "cst = 100 "
 -- INV:gen:E.loadArgs "cst = 100 "
 -- BinaryExp:loadArgs: "cst = 100" superAdj: 0 
 -- INV:gen: "cst" 
 pushc 100
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 -- NonVirt: "= 100" "ObjectInvocation_Binary" ActArg: "100 "isValue: true formalArg: "in Veq: var this(Value)" 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "= 100 " isCompositeValueObj: true 
 -- OG:before:super.gen: "100 "
 -- INV:gen: "100" 
 -- needorigin: "100" 
 -- needOrigin:E: "100"  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "100" rec: "100" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "100" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "100 "E:  "100 "
 -- INV:gen:E.loadArgs "100 "
 -- INV:gen:after:E.loadArgs "100 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "100 "
 pushc 100
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- vEq: 
 -- end:loadArgs:NonVirt: "= 100 "
 -- BinaryExp:loadArgs:end: 
 -- INV:gen:after:E.loadArgs "cst = 100 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: BinOp "cst = 100 ":Adr:off:0 size:0 isFloat
 --  :F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none"
 --  :rec:- 
 -- BinaryExp:invoke: "cst "rec: "cst = 100 "
 -- M: "= 100 ":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F 
 --  isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern =   
 -- ptn:invoke: "=   "E: "= 100 "ptnKind: 1 useRtnV: true 
 -- E: "= 100" rec: "cst ""Invocation "OGx: "100" 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- rec.ATd: "cst: val 100" 
 -- bobs: 1 OGx: "100" 
 -- 
 eq
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"= 100":rec:cst nl; adrx: :Adr:off:0 s
 --  ize:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVal
 --  ue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"= 100":rec:cst 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in B: var boolean ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "(cst = 100) ":isBasicVal: true 
 -- case:B: (cst = 100) ObjectGenerator 4 50 50 false false 
 -- end:loadArgs:NonVirt: "&& (cst = 100) "
 -- BinaryExp:loadArgs:end: 
 -- INV:gen:after:E.loadArgs "(ch = 'Q') && (cst = 100) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: BinOp "(ch = 'Q') && (cst = 100) ":Adr:off:
 --  0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIs
 --  Value:F:E:"none":rec:- 
 -- BinaryExp:invoke: "(ch = 'Q') "rec: "(ch = 'Q') && (cst = 100) "
 -- M: "&& (cst = 100) ":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern &&   
 -- ptn:invoke: "&&   "E: "&& (cst = 100) "ptnKind: 0 useRtnV: true 
 andd
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"&& (cst = 100)":rec:(ch = 'Q') nl; a
 --  drx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVal
 --  ue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"&& (cst = 100)":rec:(ch = 'Q') 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  135   "$135 "
 invoke $135 135 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L5
 L4:
 pushThis 
 -- before objTmpStack:add:  136   "$136 "
 invoke $136 136 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 L5:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- OG:before:super.gen: "string_foo_LE "
 -- INV:gen: "string_foo_LE" 
 -- needorigin: "string_foo_LE" 
 -- needOrigin:E: "string_foo_LE"  E.ATd: 
 --  string_foo_LE: 
 --     S1: var StringLib.String
 --     S2: obj "Hello"
 --     S1 := "Hello"
 --  Ex: "string_foo_LE" rec: "string_foo_LE" 
 -- doNeedOrigin:Ex: "string_foo_LE "originIsValueObj: false origin.isPrimitiv
 --  e: false 
 -- KUK 
 -- after:needOrigin: "string_foo_LE" 
 -- doNeedOrigin:E: "string_foo_LE" 
 -- computeAdrX:superAdj: 0 "string_foo_LE" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "string_foo_LE" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "string_foo_LE "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"string_foo_LE":rec:
 --  - 
 --  rec:  "string_foo_LE "E:  "string_foo_LE "
 -- INV:gen:E.loadArgs "string_foo_LE "
 -- INV:gen:after:E.loadArgs "string_foo_LE "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "string_foo_LE ":Adr
 --  :off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori
 --  ginIsValue:F:E:"string_foo_LE":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern string_foo_LE 
 -- ptn:invoke: "string_foo_LE "E: "string_foo_LE "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "string_foo_LE" 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"string_foo_LE":rec:string_foo_LE 
 invoke string_foo_LE 137 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"string_foo_LE":rec:string_foo_LE nl;
 --   adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F is
 --  Value:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"string_foo_LE":rec:string_foo_LE 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"string_foo_LE":rec:string_foo_LE 
 -- OG:before:super.gen: "I2F_foo
 --  --cmpSwap_foo "
 -- INV:gen: 
 --  I2F_foo
 --  --cmpSwap_foo
 --  
 -- needorigin: 
 --  I2F_foo
 --  --cmpSwap_foo
 --  
 -- needOrigin:E: "I2F_foo"  E.ATd: 
 --  I2F_foo: 
 --     x: var Float
 --     i: var integer
 --     X := 12
 --  Ex: "I2F_foo" rec: "I2F_foo" 
 -- doNeedOrigin:Ex: "I2F_foo "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "I2F_foo" 
 -- doNeedOrigin:E: "I2F_foo" 
 -- computeAdrX:superAdj: 0 
 --  I2F_foo
 --  --cmpSwap_foo
 --  
 -- computeAdrX:En: 1 pRec: none rec: none E: "I2F_foo" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "I2F_foo "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"I2F_foo":rec:- 
 --  rec:  "I2F_foo "E:  "I2F_foo "
 -- INV:gen:E.loadArgs "I2F_foo "
 -- INV:gen:after:E.loadArgs "I2F_foo "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "I2F_foo ":Adr:off:0
 --   size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsV
 --  alue:F:E:"I2F_foo":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern I2F_foo 
 -- ptn:invoke: "I2F_foo "E: "I2F_foo "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "I2F_foo" 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"I2F_foo":rec:I2F_foo 
 invoke I2F_foo 140 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"I2F_foo":rec:I2F_foo nl; adrx: :Adr:o
 --  ff:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F orig
 --  inIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"I2F_foo":rec:I2F_foo 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"I2F_foo":rec:I2F_foo 
 -- OG:before:super.gen: "newline "
 -- INV:gen: "newline" 
 -- needorigin: "newline" 
 -- needOrigin:E: "newline"  E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  Ex: "newline" rec: "newline" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  %globals
 --     put(10)
 --  
 -- after:needOrigin: "newline" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "newline "E:  "newline "
 -- INV:gen:E.loadArgs "newline "
 -- INV:gen:after:E.loadArgs "newline "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "newline "
 -- OI:invoke:before:ATdx.invoke: pattern newline 
 -- ptn:invoke: "newline "E: "newline "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "newline" 
 --  adr:none 
 invoke newline 129 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: nl; adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:
 --  0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- OG:before:super.gen: "unit_foo "
 -- INV:gen: "unit_foo" 
 -- needorigin: "unit_foo" 
 -- needOrigin:E: "unit_foo"  E.ATd: 
 --  unit_foo: 
 --     l_foo: var Length.Meter
 --     a_foo: var Area.SquareMeter
 --     l_foo := 10"m"
 --  Ex: "unit_foo" rec: "unit_foo" 
 -- doNeedOrigin:Ex: "unit_foo "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "unit_foo" 
 -- doNeedOrigin:E: "unit_foo" 
 -- computeAdrX:superAdj: 0 "unit_foo" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "unit_foo" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "unit_foo "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"unit_foo":rec:- 
 --  rec:  "unit_foo "E:  "unit_foo "
 -- INV:gen:E.loadArgs "unit_foo "
 -- INV:gen:after:E.loadArgs "unit_foo "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "unit_foo ":Adr:off:
 --  0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIs
 --  Value:F:E:"unit_foo":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern unit_foo 
 -- ptn:invoke: "unit_foo "E: "unit_foo "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "unit_foo" 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"unit_foo":rec:unit_foo 
 invoke unit_foo 151 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"unit_foo":rec:unit_foo nl; adrx: :Adr
 --  :off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F or
 --  iginIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"unit_foo":rec:unit_foo 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"unit_foo":rec:unit_foo 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:6 isIndexed:0

 CLASS R_foo 104 1 tinyS 103
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "X: var char" DI:isConst: false :isBasicValue: true :primNo: 3 
 -- DI:add:BP1:  X 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS S_foo 105 1 tinyS 103
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "cx: val 'e'" DI:isConst: true :isBasicValue: true :primNo: 3 
 -- DI:add:BP2:  cx 
 -- OG:before:super.gen: "'e' "
 -- INV:gen: "'e'" 
 -- needorigin: "'e'" 
 -- needOrigin:E: "'e'"  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  Ex: "'e'" rec: "'e'" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  
 -- after:needOrigin: "'e'" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "'e' "E:  "'e' "
 -- INV:gen:E.loadArgs "'e' "
 -- INV:gen:after:E.loadArgs "'e' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "'e' "
 pushc 101
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 pushThis 
 storeg cx 2
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS nest_foo 109 1 tinyS 103
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "C: var char" DI:isConst: false :isBasicValue: true :primNo: 3 
 -- DI:add:BP1:  C 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "C := ch + 1" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "C := ch + 1" right.label: "ObjectGenerator ""ch + 1" 
 -- OG:before:super.gen: "ch + 1 "
 -- INV:gen: "ch + 1" 
 -- needorigin: "ch + 1" 
 -- needOrigin:E: "ch + 1"  E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var char
 --     out R: var char
 --  Ex: "ch + 1" rec: "ch + 1" 
 -- doNeedOrigin:Ex: "ch + 1 "originIsValueObj: true origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "ch + 1" 
 -- doNeedOrigin:E: "ch + 1" 
 -- computeAdrX:superAdj: 0 "ch + 1" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "ch + 1" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "ch + 1 "superAdj: 0 
 -- computeAdrX:isLast:E:  "ch + 1 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "ch + 1 "E:  "ch + 1 "
 -- INV:gen:E.loadArgs "ch + 1 "
 -- BinaryExp:loadArgs: "ch + 1" superAdj: 0 
 -- INV:gen: "ch" 
 -- needorigin: "ch" 
 -- needOrigin:E: "ch"  E.ATd: 
 --  ch: var Char -- off: 5
 --  --xxx: obj X_foo
 --  Ex: "ch" rec: "ch" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "ch" 
 -- doNeedOrigin:E: "ch" 
 -- computeAdrX:superAdj: 0 "ch" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "ch" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "nest_foo "on: 1 isValueObj: false 
 --  origin: tinyS origin:isValueObj: false 
 rpushg nest_foo$109 1
 -- computeAdrX:isLast:E:  "ch "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:5 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"ch":rec:- 
 --  rec:  "ch "E:  "ch "
 -- INV:gen:E.loadArgs "ch "
 -- INV:gen:after:E.loadArgs "ch "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "ch ":Adr:off:5 size
 --  :0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:
 --  F:E:"ch":rec:- 
 -- OI:invoke:before:ATdx.invoke: var ch 
 -- DI:invoke: 
 --  ch: var Char -- off: 5
 --  --xxx: obj X_foo
 --  
 -- load: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"ch":rec:ch isNotRemote: true 
 pushg 5 tinyS$103
 -- OI:invoke:V: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"ch":rec:ch 
 -- OI:invoke:X: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"ch":rec:ch 
 -- INV:gen:end:off: 5 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:5 size:0 isFloat:F isUnit
 --  Val:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"ch":rec:ch 
 -- NonVirt: "+ 1" "ObjectInvocation_Binary" ActArg: "1 "isValue: true formalArg: "in V: var char" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ 1 " isCompositeValueObj: false 
 -- OG:before:super.gen: "1 "
 -- INV:gen: "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "1" rec: "1" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "1" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "1 "E:  "1 "
 -- INV:gen:E.loadArgs "1 "
 -- INV:gen:after:E.loadArgs "1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1 "
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var char ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 3 1 1 false true 
 -- end:loadArgs:NonVirt: "+ 1 "
 -- BinaryExp:loadArgs:end: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj
 --  :0 isUnique:F isValue:T originIsValue:F:E:"ch":rec:ch 
 -- INV:gen:after:E.loadArgs "ch + 1 "
 --  OIadr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:T originIsValue:F:E:"ch":rec:ch 
 -- IV:E.invoke:useRtnVal: true E: BinOp "ch + 1 ":Adr:off:5 size:0 isFloat:F 
 --  isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"ch":rec:
 --  ch 
 -- BinaryExp:invoke: "ch "rec: "ch + 1 "
 -- M: "+ 1 ":Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F is
 --  Value:T originIsValue:F:E:"ch":rec:ch 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- ptn:invoke: "+   "E: "+ 1 "ptnKind: 0 useRtnV: true 
 plus
 -- OI:invoke:V: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"+ 1":rec:ch nl; adrx: :Adr:off:0 size
 --  :0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:
 --  F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"+ 1":rec:ch 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg nest_foo$109 2
 -- assign:adr.store:B: 
 -- AssignmentStatement:gen: "C := cst + 3" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "C := cst + 3" right.label: "ObjectGenerator ""cst + 3" 
 -- OG:before:super.gen: "cst + 3 "
 -- INV:gen: "cst + 3" 
 -- needorigin: "cst + 3" 
 -- needOrigin:E: "cst + 3"  E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  Ex: "cst + 3" rec: "cst + 3" 
 -- doNeedOrigin:Ex: "cst + 3 "originIsValueObj: true origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "cst + 3" 
 -- doNeedOrigin:E: "cst + 3" 
 -- computeAdrX:superAdj: 0 "cst + 3" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "cst + 3" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "cst + 3 "superAdj: 0 
 -- computeAdrX:isLast:E:  "cst + 3 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "cst + 3 "E:  "cst + 3 "
 -- INV:gen:E.loadArgs "cst + 3 "
 -- BinaryExp:loadArgs: "cst + 3" superAdj: 0 
 -- INV:gen: "cst" 
 pushc 100
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 -- NonVirt: "+ 3" "ObjectInvocation_Binary" ActArg: "3 "isValue: true formalArg: "in V: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ 3 " isCompositeValueObj: false 
 -- OG:before:super.gen: "3 "
 -- INV:gen: "3" 
 -- needorigin: "3" 
 -- needOrigin:E: "3"  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "3" rec: "3" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "3" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "3 "E:  "3 "
 -- INV:gen:E.loadArgs "3 "
 -- INV:gen:after:E.loadArgs "3 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "3 "
 pushc 3
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "3 ":isBasicVal: true 
 -- case:B: 3 ObjectGenerator 1 1 1 false true 
 -- end:loadArgs:NonVirt: "+ 3 "
 -- BinaryExp:loadArgs:end: 
 -- INV:gen:after:E.loadArgs "cst + 3 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: BinOp "cst + 3 ":Adr:off:0 size:0 isFloat:F
 --   isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":r
 --  ec:- 
 -- BinaryExp:invoke: "cst "rec: "cst + 3 "
 -- M: "+ 3 ":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F is
 --  Value:F originIsValue:T:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- ptn:invoke: "+   "E: "+ 3 "ptnKind: 0 useRtnV: true 
 plus
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:T:E:"+ 3":rec:cst nl; adrx: :Adr:off:0 siz
 --  e:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue
 --  :F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:T:E:"+ 3":rec:cst 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg nest_foo$109 2
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS A_foo 106 1 tinyS 103
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "put('a') "
 -- INV:gen: "put('a')" 
 -- needorigin: "put('a')" 
 -- needOrigin:E: "put('a')"  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put('a')" rec: "put('a')" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put('a')" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put('a') "E:  "put('a') "
 -- INV:gen:E.loadArgs "put('a') "
 -- NonVirt: "put('a')" "ObjectInvocation_KeyWord" ActArg: "'a' "isValue: true formalArg: "in ch: val char" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put('a') " isCompositeValueObj: false 
 -- OG:before:super.gen: "'a' "
 -- INV:gen: "'a'" 
 -- needorigin: "'a'" 
 -- needOrigin:E: "'a'"  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  Ex: "'a'" rec: "'a'" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  
 -- after:needOrigin: "'a'" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "'a' "E:  "'a' "
 -- INV:gen:E.loadArgs "'a' "
 -- INV:gen:after:E.loadArgs "'a' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "'a' "
 pushc 97
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "'a' ":isBasicVal: true 
 -- case:B: 'a' ObjectGenerator 3 3 3 false true 
 -- end:loadArgs:NonVirt: "put('a') "
 -- INV:gen:after:E.loadArgs "put('a') "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put('a') "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put('a') "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS B_foo 107 1 tinyS 103
 pushThis 
 storeg char$7 2
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "put(B) "
 -- INV:gen: "put(B)" 
 -- needorigin: "put(B)" 
 -- needOrigin:E: "put(B)"  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put(B)" rec: "put(B)" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put(B)" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put(B) "E:  "put(B) "
 -- INV:gen:E.loadArgs "put(B) "
 -- NonVirt: "put(B)" "ObjectInvocation_KeyWord" ActArg: "B "isValue: false formalArg: "in ch: val char" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(B) " isCompositeValueObj: false 
 -- OG:before:super.gen: "B "
 -- INV:gen: "B" 
 -- needorigin: "B" 
 -- needOrigin:E: "B"  E.ATd: "B: var Char" Ex: "B" rec: "B" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "B" 
 -- doNeedOrigin:E: "B" 
 -- computeAdrX:superAdj: 0 "B" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "B" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "B "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 --  rec:  "B "E:  "B "
 -- INV:gen:E.loadArgs "B "
 -- INV:gen:after:E.loadArgs "B "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "B ":Adr:off:2 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"B":rec:- 
 -- OI:invoke:before:ATdx.invoke: var B 
 -- DI:invoke: "B: var Char" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"B":rec:B isNotRemote: true 
 pushg 2 B_foo$107
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"B":rec:B 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"B":rec:B 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"B":rec:B 
 -- actualArg:isPtn: false formalArg:isPtn: "in ch: val char ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "B ":isBasicVal: true 
 -- case:B: B ObjectGenerator 3 0 3 false false 
 -- end:loadArgs:NonVirt: "put(B) "
 -- INV:gen:after:E.loadArgs "put(B) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(B) "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put(B) "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS C_foo 108 1 R_foo 104
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "put(x) "
 -- INV:gen: "put(x)" 
 -- needorigin: "put(x)" 
 -- needOrigin:E: "put(x)"  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put(x)" rec: "put(x)" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put(x)" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put(x) "E:  "put(x) "
 -- INV:gen:E.loadArgs "put(x) "
 -- NonVirt: "put(x)" "ObjectInvocation_KeyWord" ActArg: "x "isValue: false formalArg: "in ch: val char" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(x) " isCompositeValueObj: false 
 -- OG:before:super.gen: "x "
 -- INV:gen: "x" 
 -- needorigin: "x" 
 -- needOrigin:E: "x"  E.ATd: "X: var char" Ex: "x" rec: "x" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "x" 
 -- doNeedOrigin:E: "x" 
 -- computeAdrX:superAdj: 0 "x" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "x" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "C_foo "on: 1 isValueObj: false 
 --  origin: R_foo origin:isValueObj: false 
 rpushg C_foo$108 1
 -- computeAdrX:isLast:E:  "x "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"x":rec:- 
 --  rec:  "x "E:  "x "
 -- INV:gen:E.loadArgs "x "
 -- INV:gen:after:E.loadArgs "x "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "x ":Adr:off:2 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"x":rec:- 
 -- OI:invoke:before:ATdx.invoke: var X 
 -- DI:invoke: "X: var char" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"x":rec:x isNotRemote: true 
 pushg 2 R_foo$104
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"x":rec:x 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"x":rec:x 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"x":rec:x 
 -- actualArg:isPtn: false formalArg:isPtn: "in ch: val char ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "x ":isBasicVal: true 
 -- case:B: x ObjectGenerator 3 0 3 false false 
 -- end:loadArgs:NonVirt: "put(x) "
 -- INV:gen:after:E.loadArgs "put(x) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(x) "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put(x) "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS asg_foo 111 1 tinyS 103
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "nl: val 102" DI:isConst: true :isBasicValue: true :primNo: 1 
 -- DI:add:BP2:  nl 
 -- OG:before:super.gen: "102 "
 -- INV:gen: "102" 
 -- needorigin: "102" 
 -- needOrigin:E: "102"  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "102" rec: "102" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "102" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "102 "E:  "102 "
 -- INV:gen:E.loadArgs "102 "
 -- INV:gen:after:E.loadArgs "102 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "102 "
 pushc 102
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 pushThis 
 storeg nl 2
 -- DI:gen: "newline: var integer -- off: 3" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  newline 
 -- DI:gen: 
 --  fox: obj  -- off: 4
 --     x: var char
 --  DI:isConst: true :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  fox 
 -- DI:off: 4 this: 
 --  fox: obj  -- off: 4
 --     x: var char
 --  
 --  
 pushThis 
 -- before objTmpStack:add:  112   "fox "
 invoke fox 112 4 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "Newline := nl" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "Newline := nl" right.label: "ObjectGenerator ""nl" 
 -- OG:before:super.gen: "nl "
 -- INV:gen: "nl" 
 pushc 102
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg asg_foo$111 3
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "put(newline) "
 -- INV:gen: "put(newline)" 
 -- needorigin: "put(newline)" 
 -- needOrigin:E: "put(newline)"  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put(newline)" rec: "put(newline)" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put(newline)" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put(newline) "E:  "put(newline) "
 -- INV:gen:E.loadArgs "put(newline) "
 -- NonVirt: "put(newline)" "ObjectInvocation_KeyWord" ActArg: "newline "isValue: false formalArg: "in ch: val char" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(newline) " isCompositeValueObj: false 
 -- OG:before:super.gen: "newline "
 -- INV:gen: "newline" 
 -- needorigin: "newline" 
 -- needOrigin:E: "newline"  E.ATd: "newline: var integer -- off: 3" Ex: "newline" rec: "newline" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "newline" 
 -- doNeedOrigin:E: "newline" 
 -- computeAdrX:superAdj: 0 "newline" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "newline" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "newline "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"newline":rec:- 
 --  rec:  "newline "E:  "newline "
 -- INV:gen:E.loadArgs "newline "
 -- INV:gen:after:E.loadArgs "newline "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "newline ":Adr:off:3
 --   size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsV
 --  alue:F:E:"newline":rec:- 
 -- OI:invoke:before:ATdx.invoke: var newline 
 -- DI:invoke: "newline: var integer -- off: 3" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"newline":rec:newline isNotRemote: true 
 pushg 3 asg_foo$111
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"newline":rec:newline 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"newline":rec:newline 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"newline":rec:newline 
 -- actualArg:isPtn: false formalArg:isPtn: "in ch: val char ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "newline ":isBasicVal: true 
 -- case:B: newline ObjectGenerator 3 0 1 false false 
 -- end:loadArgs:NonVirt: "put(newline) "
 -- INV:gen:after:E.loadArgs "put(newline) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(newline) "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put(newline) "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- AssignmentStatement:gen: "fox.x := ch" 
 pushThis 
 -- computeAdrG:pRec: "fox" E: "x" 
 -- OI:invoke:before:ATdx.invoke: obj fox 
 -- DI:invoke: 
 --  fox: obj  -- off: 4
 --     x: var char
 --  
 -- >Object:unique: false 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"x":rec:fox isNotRemote: false 
 rpushg asg_foo$111 4
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"x":rec:fox 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"x":rec:fox 
 -- AssignmentStatement:gen: 
 --  "fox.x := ch" right.label: "ObjectGenerator ""ch" 
 -- OG:before:super.gen: "ch "
 -- INV:gen: "ch" 
 -- needorigin: "ch" 
 -- needOrigin:E: "ch"  E.ATd: 
 --  ch: var Char -- off: 5
 --  --xxx: obj X_foo
 --  Ex: "ch" rec: "ch" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "ch" 
 -- doNeedOrigin:E: "ch" 
 -- computeAdrX:superAdj: 0 "ch" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "ch" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "asg_foo "on: 1 isValueObj: false 
 --  origin: tinyS origin:isValueObj: false 
 rpushg asg_foo$111 1
 -- computeAdrX:isLast:E:  "ch "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:5 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"ch":rec:- 
 --  rec:  "ch "E:  "ch "
 -- INV:gen:E.loadArgs "ch "
 -- INV:gen:after:E.loadArgs "ch "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "ch ":Adr:off:5 size
 --  :0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:
 --  F:E:"ch":rec:- 
 -- OI:invoke:before:ATdx.invoke: var ch 
 -- DI:invoke: 
 --  ch: var Char -- off: 5
 --  --xxx: obj X_foo
 --  
 -- load: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"ch":rec:ch isNotRemote: true 
 pushg 5 tinyS$103
 -- OI:invoke:V: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"ch":rec:ch 
 -- OI:invoke:X: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"ch":rec:ch 
 -- INV:gen:end:off: 5 
 -- OG:gen:end: OIadr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"ch":rec:ch 
 -- assign:adr.store:A: 
 storeg asg_foo$111 2
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "put(fox.x) "
 -- INV:gen: "put(fox.x)" 
 -- needorigin: "put(fox.x)" 
 -- needOrigin:E: "put(fox.x)"  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put(fox.x)" rec: "put(fox.x)" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put(fox.x)" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put(fox.x) "E:  "put(fox.x) "
 -- INV:gen:E.loadArgs "put(fox.x) "
 -- NonVirt: "put(fox.x)" "ObjectInvocation_KeyWord" ActArg: "fox.x "isValue: false formalArg: "in ch: val char" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(fox.x) " isCompositeValueObj: false 
 -- OG:before:super.gen: "fox.x "
 -- INV:gen: "fox.x" 
 -- needorigin: "fox.x" 
 -- needOrigin:E: "x"  E.ATd: "x: var char" Ex: none rec: "fox" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "x" 
 -- doNeedOrigin:E: "x" 
 -- computeAdrX:superAdj: 0 "fox.x" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "fox" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "fox" rec: "fox" E: "x" 
 --  A.E: none 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "fox" rec: "fox" E: "x" 
 --  rec.ATd: 
 --  fox: obj  -- off: 4
 --     x: var char
 --  rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  nl: val 102
 --     newline: var integer -- off: 3
 --     fox: obj  -- off: 4
 --        x: var char
 --  
 --  recA: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"x":rec:- 
 --  pRecA: none 
 -- pRec: "fox" rec: "fox" E: "x" 
 --  false false 
 -- computeAdrX:before:rec:: "fox" 
 -- OI:invoke:before:ATdx.invoke: obj fox 
 -- DI:invoke: 
 --  fox: obj  -- off: 4
 --     x: var char
 --  
 -- >Object:unique: false 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"x":rec:fox isNotRemote: false 
 rpushg asg_foo$111 4
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"x":rec:fox 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"x":rec:fox 
 -- computeAdrX:after:rec.invoke: "fox" 
 -- computeAdrX:isLast:E:  "x "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"x":rec:- 
 --  rec:  "fox "E:  "x "
 -- INV:gen:E.loadArgs "x "
 -- INV:gen:after:E.loadArgs "x "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "x ":Adr:off:2 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"x":rec:- 
 -- OI:invoke:before:ATdx.invoke: var x 
 -- DI:invoke: "x: var char" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"x":rec:fox isNotRemote: false 
 pushg 2 asg_foo$111
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"x":rec:fox 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"x":rec:fox 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"x":rec:fox 
 -- actualArg:isPtn: false formalArg:isPtn: "in ch: val char ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "fox.x ":isBasicVal: true 
 -- case:B: fox.x ObjectGenerator 3 0 3 false false 
 -- end:loadArgs:NonVirt: "put(fox.x) "
 -- INV:gen:after:E.loadArgs "put(fox.x) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(fox.x) "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put(fox.x) "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- AssignmentStatement:gen: "fox.x := fox.x + 1" 
 pushThis 
 -- computeAdrG:pRec: "fox" E: "x" 
 -- OI:invoke:before:ATdx.invoke: obj fox 
 -- DI:invoke: 
 --  fox: obj  -- off: 4
 --     x: var char
 --  
 -- >Object:unique: false 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"x":rec:fox isNotRemote: false 
 rpushg asg_foo$111 4
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"x":rec:fox 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"x":rec:fox 
 -- AssignmentStatement:gen: 
 --  "fox.x := fox.x + 1" right.label: "ObjectGenerator ""fox.x + 1" 
 -- OG:before:super.gen: "fox.x + 1 "
 -- INV:gen: "fox.x + 1" 
 -- needorigin: "fox.x + 1" 
 -- needOrigin:E: "fox.x + 1"  E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var char
 --     out R: var char
 --  Ex: "fox.x + 1" rec: "fox.x + 1" 
 -- doNeedOrigin:Ex: "fox.x + 1 "originIsValueObj: true origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "fox.x + 1" 
 -- doNeedOrigin:E: "fox.x + 1" 
 -- computeAdrX:superAdj: 0 "fox.x + 1" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "fox.x + 1" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "fox.x + 1 "superAdj: 0 
 -- computeAdrX:isLast:E:  "fox.x + 1 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "fox.x + 1 "E:  "fox.x + 1 "
 -- INV:gen:E.loadArgs "fox.x + 1 "
 -- BinaryExp:loadArgs: "fox.x + 1" superAdj: 0 
 -- INV:gen: "fox.x" 
 -- needorigin: "fox.x" 
 -- needOrigin:E: "x"  E.ATd: "x: var char" Ex: none rec: "fox" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "x" 
 -- doNeedOrigin:E: "x" 
 -- computeAdrX:superAdj: 0 "fox.x" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "fox" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "fox" rec: "fox" E: "x" 
 --  A.E: none 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "fox" rec: "fox" E: "x" 
 --  rec.ATd: 
 --  fox: obj  -- off: 4
 --     x: var char
 --  rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  nl: val 102
 --     newline: var integer -- off: 3
 --     fox: obj  -- off: 4
 --        x: var char
 --  
 --  recA: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"x":rec:- 
 --  pRecA: none 
 -- pRec: "fox" rec: "fox" E: "x" 
 --  false false 
 -- computeAdrX:before:rec:: "fox" 
 -- OI:invoke:before:ATdx.invoke: obj fox 
 -- DI:invoke: 
 --  fox: obj  -- off: 4
 --     x: var char
 --  
 -- >Object:unique: false 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"x":rec:fox isNotRemote: false 
 rpushg asg_foo$111 4
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"x":rec:fox 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"x":rec:fox 
 -- computeAdrX:after:rec.invoke: "fox" 
 -- computeAdrX:isLast:E:  "x "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"x":rec:- 
 --  rec:  "fox "E:  "x "
 -- INV:gen:E.loadArgs "x "
 -- INV:gen:after:E.loadArgs "x "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "x ":Adr:off:2 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"x":rec:- 
 -- OI:invoke:before:ATdx.invoke: var x 
 -- DI:invoke: "x: var char" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"x":rec:fox isNotRemote: false 
 pushg 2 asg_foo$111
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"x":rec:fox 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"x":rec:fox 
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:2 size:0 isFloat:F isUnit
 --  Val:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"x":rec:fox 
 -- NonVirt: "+ 1" "ObjectInvocation_Binary" ActArg: "1 "isValue: true formalArg: "in V: var char" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ 1 " isCompositeValueObj: false 
 -- OG:before:super.gen: "1 "
 -- INV:gen: "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "1" rec: "1" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "1" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "1 "E:  "1 "
 -- INV:gen:E.loadArgs "1 "
 -- INV:gen:after:E.loadArgs "1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1 "
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var char ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 3 1 1 false true 
 -- end:loadArgs:NonVirt: "+ 1 "
 -- BinaryExp:loadArgs:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj
 --  :0 isUnique:F isValue:T originIsValue:F:E:"x":rec:fox 
 -- INV:gen:after:E.loadArgs "fox.x + 1 "
 --  OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:T originIsValue:F:E:"x":rec:fox 
 -- IV:E.invoke:useRtnVal: true E: BinOp "fox.x + 1 ":Adr:off:2 size:0 isFloat
 --  :F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"x":re
 --  c:fox 
 -- BinaryExp:invoke: "fox.x "rec: "fox.x + 1 "
 -- M: "+ 1 ":Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F is
 --  Value:T originIsValue:F:E:"x":rec:fox 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- ptn:invoke: "+   "E: "+ 1 "ptnKind: 0 useRtnV: true 
 plus
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"+ 1":rec:fox.x nl; adrx: :Adr:off:0 s
 --  ize:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVal
 --  ue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"+ 1":rec:fox.x 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg asg_foo$111 2
 -- assign:adr.store:B: 
 -- AssignmentStatement:gen: "ch := fox.x" 
 pushThis 
 -- items:goOrigin:encOG: "asg_foo "on: 1 isValueObj: false 
 --  origin: tinyS origin:isValueObj: false 
 rpushg asg_foo$111 1
 -- AssignmentStatement:gen: 
 --  "ch := fox.x" right.label: "ObjectGenerator ""fox.x" 
 -- OG:before:super.gen: "fox.x "
 -- INV:gen: "fox.x" 
 -- needorigin: "fox.x" 
 -- needOrigin:E: "x"  E.ATd: "x: var char" Ex: none rec: "fox" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "x" 
 -- doNeedOrigin:E: "x" 
 -- computeAdrX:superAdj: 0 "fox.x" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "fox" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "fox" rec: "fox" E: "x" 
 --  A.E: none 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "fox" rec: "fox" E: "x" 
 --  rec.ATd: 
 --  fox: obj  -- off: 4
 --     x: var char
 --  rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  nl: val 102
 --     newline: var integer -- off: 3
 --     fox: obj  -- off: 4
 --        x: var char
 --  
 --  recA: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"x":rec:- 
 --  pRecA: none 
 -- pRec: "fox" rec: "fox" E: "x" 
 --  false false 
 -- computeAdrX:before:rec:: "fox" 
 -- OI:invoke:before:ATdx.invoke: obj fox 
 -- DI:invoke: 
 --  fox: obj  -- off: 4
 --     x: var char
 --  
 -- >Object:unique: false 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"x":rec:fox isNotRemote: false 
 rpushg asg_foo$111 4
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"x":rec:fox 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"x":rec:fox 
 -- computeAdrX:after:rec.invoke: "fox" 
 -- computeAdrX:isLast:E:  "x "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"x":rec:- 
 --  rec:  "fox "E:  "x "
 -- INV:gen:E.loadArgs "x "
 -- INV:gen:after:E.loadArgs "x "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "x ":Adr:off:2 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"x":rec:- 
 -- OI:invoke:before:ATdx.invoke: var x 
 -- DI:invoke: "x: var char" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"x":rec:fox isNotRemote: false 
 pushg 2 asg_foo$111
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"x":rec:fox 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"x":rec:fox 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"x":rec:fox 
 -- assign:adr.store:A: 
 storeg tinyS$103 5
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "put(ch) "
 -- INV:gen: "put(ch)" 
 -- needorigin: "put(ch)" 
 -- needOrigin:E: "put(ch)"  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put(ch)" rec: "put(ch)" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put(ch)" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put(ch) "E:  "put(ch) "
 -- INV:gen:E.loadArgs "put(ch) "
 -- NonVirt: "put(ch)" "ObjectInvocation_KeyWord" ActArg: "ch "isValue: false formalArg: "in ch: val char" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(ch) " isCompositeValueObj: false 
 -- OG:before:super.gen: "ch "
 -- INV:gen: "ch" 
 -- needorigin: "ch" 
 -- needOrigin:E: "ch"  E.ATd: 
 --  ch: var Char -- off: 5
 --  --xxx: obj X_foo
 --  Ex: "ch" rec: "ch" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "ch" 
 -- doNeedOrigin:E: "ch" 
 -- computeAdrX:superAdj: 0 "ch" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "ch" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "asg_foo "on: 1 isValueObj: false 
 --  origin: tinyS origin:isValueObj: false 
 rpushg asg_foo$111 1
 -- computeAdrX:isLast:E:  "ch "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:5 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"ch":rec:- 
 --  rec:  "ch "E:  "ch "
 -- INV:gen:E.loadArgs "ch "
 -- INV:gen:after:E.loadArgs "ch "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "ch ":Adr:off:5 size
 --  :0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:
 --  F:E:"ch":rec:- 
 -- OI:invoke:before:ATdx.invoke: var ch 
 -- DI:invoke: 
 --  ch: var Char -- off: 5
 --  --xxx: obj X_foo
 --  
 -- load: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"ch":rec:ch isNotRemote: true 
 pushg 5 tinyS$103
 -- OI:invoke:V: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"ch":rec:ch 
 -- OI:invoke:X: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"ch":rec:ch 
 -- INV:gen:end:off: 5 
 -- OG:gen:end: OIadr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"ch":rec:ch 
 -- actualArg:isPtn: false formalArg:isPtn: "in ch: val char ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "ch ":isBasicVal: true 
 -- case:B: ch ObjectGenerator 3 0 3 false false 
 -- end:loadArgs:NonVirt: "put(ch) "
 -- INV:gen:after:E.loadArgs "put(ch) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(ch) "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put(ch) "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- AssignmentStatement:gen: "fox.x := 'i'" 
 pushThis 
 -- computeAdrG:pRec: "fox" E: "x" 
 -- OI:invoke:before:ATdx.invoke: obj fox 
 -- DI:invoke: 
 --  fox: obj  -- off: 4
 --     x: var char
 --  
 -- >Object:unique: false 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"x":rec:fox isNotRemote: false 
 rpushg asg_foo$111 4
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"x":rec:fox 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"x":rec:fox 
 -- AssignmentStatement:gen: 
 --  "fox.x := 'i'" right.label: "ObjectGenerator ""'i'" 
 -- OG:before:super.gen: "'i' "
 -- INV:gen: "'i'" 
 -- needorigin: "'i'" 
 -- needOrigin:E: "'i'"  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  Ex: "'i'" rec: "'i'" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  
 -- after:needOrigin: "'i'" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "'i' "E:  "'i' "
 -- INV:gen:E.loadArgs "'i' "
 -- INV:gen:after:E.loadArgs "'i' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "'i' "
 pushc 105
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg asg_foo$111 2
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "put(fox.x) "
 -- INV:gen: "put(fox.x)" 
 -- needorigin: "put(fox.x)" 
 -- needOrigin:E: "put(fox.x)"  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put(fox.x)" rec: "put(fox.x)" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put(fox.x)" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put(fox.x) "E:  "put(fox.x) "
 -- INV:gen:E.loadArgs "put(fox.x) "
 -- NonVirt: "put(fox.x)" "ObjectInvocation_KeyWord" ActArg: "fox.x "isValue: false formalArg: "in ch: val char" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(fox.x) " isCompositeValueObj: false 
 -- OG:before:super.gen: "fox.x "
 -- INV:gen: "fox.x" 
 -- needorigin: "fox.x" 
 -- needOrigin:E: "x"  E.ATd: "x: var char" Ex: none rec: "fox" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "x" 
 -- doNeedOrigin:E: "x" 
 -- computeAdrX:superAdj: 0 "fox.x" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "fox" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "fox" rec: "fox" E: "x" 
 --  A.E: none 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "fox" rec: "fox" E: "x" 
 --  rec.ATd: 
 --  fox: obj  -- off: 4
 --     x: var char
 --  rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  nl: val 102
 --     newline: var integer -- off: 3
 --     fox: obj  -- off: 4
 --        x: var char
 --  
 --  recA: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"x":rec:- 
 --  pRecA: none 
 -- pRec: "fox" rec: "fox" E: "x" 
 --  false false 
 -- computeAdrX:before:rec:: "fox" 
 -- OI:invoke:before:ATdx.invoke: obj fox 
 -- DI:invoke: 
 --  fox: obj  -- off: 4
 --     x: var char
 --  
 -- >Object:unique: false 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"x":rec:fox isNotRemote: false 
 rpushg asg_foo$111 4
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"x":rec:fox 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"x":rec:fox 
 -- computeAdrX:after:rec.invoke: "fox" 
 -- computeAdrX:isLast:E:  "x "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"x":rec:- 
 --  rec:  "fox "E:  "x "
 -- INV:gen:E.loadArgs "x "
 -- INV:gen:after:E.loadArgs "x "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "x ":Adr:off:2 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"x":rec:- 
 -- OI:invoke:before:ATdx.invoke: var x 
 -- DI:invoke: "x: var char" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"x":rec:fox isNotRemote: false 
 pushg 2 asg_foo$111
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"x":rec:fox 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"x":rec:fox 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"x":rec:fox 
 -- actualArg:isPtn: false formalArg:isPtn: "in ch: val char ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "fox.x ":isBasicVal: true 
 -- case:B: fox.x ObjectGenerator 3 0 3 false false 
 -- end:loadArgs:NonVirt: "put(fox.x) "
 -- INV:gen:after:E.loadArgs "put(fox.x) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(fox.x) "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put(fox.x) "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS fox 112 1 asg_foo 111
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "x: var char" DI:isConst: false :isBasicValue: true :primNo: 3 
 -- DI:add:BP1:  x 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS try_val 113 1 tinyS 103
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "X: var float -- off: 2" DI:isConst: false :isBasicValue: true :primNo: 9 
 -- DI:add:BP1:  X 
 -- DI:gen: "V_val: var V_foo -- off: 4" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  V_val 
 -- DI:off: 4 this: "V_val: var V_foo -- off: 4" 
 --  
 -- OG:before:super.gen: "V_foo -- off: 4 "
 -- INV:gen: "V_foo -- off: 4" 
 -- needorigin: "V_foo -- off: 4" 
 -- needOrigin:E: "V_foo -- off: 4"  E.ATd: 
 --  V_foo: Value
 --     Q: var integer -- 4 in tinyS
 --     X: var integer -- 5 in tinyS
 --     V_bar: 
 --  Ex: "V_foo -- off: 4" rec: "V_foo -- off: 4" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  Value
 --     Q: var integer -- 4 in tinyS
 --     X: var integer -- 5 in tinyS
 --     V_bar: 
 --  
 -- after:needOrigin: "V_foo -- off: 4" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "V_foo -- off: 4 "E:  "V_foo -- off: 4 "
 -- INV:gen:E.loadArgs "V_foo -- off: 4 "
 -- INV:gen:after:E.loadArgs "V_foo -- off: 4 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "V_foo -- off: 4 "
 -- OI:invoke:before:ATdx.invoke: pattern V_foo 
 -- ptn:invoke: "V_foo "E: "V_foo -- off: 4 "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 4 rec: "V_foo -- off: 4" 
 --  adr:none 
 invokeVal  V_foo 114 3
 rpop 
 -- OI:invoke:V: nl; adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0
 --   isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "V_val.X := 'j'" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "V_val.X := 'j'" right.label: "ObjectGenerator ""'j'" 
 -- OG:before:super.gen: "'j' "
 -- INV:gen: "'j'" 
 -- needorigin: "'j'" 
 -- needOrigin:E: "'j'"  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  Ex: "'j'" rec: "'j'" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  
 -- after:needOrigin: "'j'" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "'j' "E:  "'j' "
 -- INV:gen:E.loadArgs "'j' "
 -- INV:gen:after:E.loadArgs "'j' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "'j' "
 pushc 106
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg try_val$113 5
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "V_val.X "
 -- INV:gen: "V_val.X" 
 -- needorigin: "V_val.X" 
 -- needOrigin:E: "X"  E.ATd: "X: var integer -- 5 in tinyS" Ex: none rec: "V_val" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "X" 
 -- doNeedOrigin:E: "X" 
 -- computeAdrX:superAdj: 0 "V_val.X" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "V_val" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "V_val" rec: "V_val" E: "X" 
 --  A.E: "V_val "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T
 --   originIsValue:F:E:"V_val":rec:- 
 -- computeAdrX:isLast:E:  "X "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:5 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V_val":rec:- 
 --  rec:  "V_val "E:  "X "
 -- INV:gen:E.loadArgs "X "
 -- INV:gen:after:E.loadArgs "X "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "X ":Adr:off:5 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"V_val":rec:- 
 -- OI:invoke:before:ATdx.invoke: var X 
 -- DI:invoke: "X: var integer -- 5 in tinyS" 
 -- load: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"X":rec:V_val isNotRemote: false 
 pushg 5 try_val$113
 -- OI:invoke:V: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"X":rec:V_val 
 -- OI:invoke:X: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"X":rec:V_val 
 -- INV:gen:end:off: 5 
 -- OG:gen:end: OIadr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"X":rec:V_val 
 -- OG:before:super.gen: "put(':') "
 -- INV:gen: "put(':')" 
 -- needorigin: "put(':')" 
 -- needOrigin:E: "put(':')"  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put(':')" rec: "put(':')" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put(':')" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put(':') "E:  "put(':') "
 -- INV:gen:E.loadArgs "put(':') "
 -- NonVirt: "put(':')" "ObjectInvocation_KeyWord" ActArg: "':' "isValue: true formalArg: "in ch: val char" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(':') " isCompositeValueObj: false 
 -- OG:before:super.gen: "':' "
 -- INV:gen: "':'" 
 -- needorigin: "':'" 
 -- needOrigin:E: "':'"  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  Ex: "':'" rec: "':'" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  
 -- after:needOrigin: "':'" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "':' "E:  "':' "
 -- INV:gen:E.loadArgs "':' "
 -- INV:gen:after:E.loadArgs "':' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "':' "
 pushc 58
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "':' ":isBasicVal: true 
 -- case:B: ':' ObjectGenerator 3 3 3 false true 
 -- end:loadArgs:NonVirt: "put(':') "
 -- INV:gen:after:E.loadArgs "put(':') "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(':') "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put(':') "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- OG:before:super.gen: "put(V_val.X) "
 -- INV:gen: "put(V_val.X)" 
 -- needorigin: "put(V_val.X)" 
 -- needOrigin:E: "put(V_val.X)"  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put(V_val.X)" rec: "put(V_val.X)" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put(V_val.X)" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put(V_val.X) "E:  "put(V_val.X) "
 -- INV:gen:E.loadArgs "put(V_val.X) "
 -- NonVirt: "put(V_val.X)" "ObjectInvocation_KeyWord" ActArg: "V_val.X "isValue: false formalArg: "in ch: val char" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(V_val.X) " isCompositeValueObj: false 
 -- OG:before:super.gen: "V_val.X "
 -- INV:gen: "V_val.X" 
 -- needorigin: "V_val.X" 
 -- needOrigin:E: "X"  E.ATd: "X: var integer -- 5 in tinyS" Ex: none rec: "V_val" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "X" 
 -- doNeedOrigin:E: "X" 
 -- computeAdrX:superAdj: 0 "V_val.X" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "V_val" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "V_val" rec: "V_val" E: "X" 
 --  A.E: "V_val "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T
 --   originIsValue:F:E:"V_val":rec:- 
 -- computeAdrX:isLast:E:  "X "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:5 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V_val":rec:- 
 --  rec:  "V_val "E:  "X "
 -- INV:gen:E.loadArgs "X "
 -- INV:gen:after:E.loadArgs "X "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "X ":Adr:off:5 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"V_val":rec:- 
 -- OI:invoke:before:ATdx.invoke: var X 
 -- DI:invoke: "X: var integer -- 5 in tinyS" 
 -- load: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"X":rec:V_val isNotRemote: false 
 pushg 5 try_val$113
 -- OI:invoke:V: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"X":rec:V_val 
 -- OI:invoke:X: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"X":rec:V_val 
 -- INV:gen:end:off: 5 
 -- OG:gen:end: OIadr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"X":rec:V_val 
 -- actualArg:isPtn: false formalArg:isPtn: "in ch: val char ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "V_val.X ":isBasicVal: true 
 -- case:B: V_val.X ObjectGenerator 3 0 1 false false 
 -- end:loadArgs:NonVirt: "put(V_val.X) "
 -- INV:gen:after:E.loadArgs "put(V_val.X) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(V_val.X) "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put(V_val.X) "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- OG:before:super.gen: "V_val.V_bar "
 -- INV:gen: "V_val.V_bar" 
 -- needorigin: "V_val.V_bar" 
 -- needOrigin:E: "V_bar"  E.ATd: 
 --  V_bar: 
 --     X := 'k'
 --     put(X)
 --  Ex: "V_bar" rec: "V_val" 
 -- doNeedOrigin:Ex: "V_bar "originIsValueObj: true origin.isPrimitive: false 
 -- origin:isValueObj: "V_foo "
 -- after:needOrigin: "V_bar" 
 -- doNeedOrigin:E: "V_bar" 
 -- computeAdrX:superAdj: 0 "V_val.V_bar" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "V_val" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "V_val" rec: "V_val" E: "V_bar" 
 --  A.E: "V_val "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T
 --   originIsValue:F:E:"V_val":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "V_val" rec: "V_val" E: "V_bar" 
 --  rec.ATd: "V_val: var V_foo -- off: 4" rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  X: var float -- off: 2
 --     V_val: var V_foo -- off: 4
 --     V_val.X := 'j'
 --     V_val.X
 --  
 --  recA: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"V_val":rec:- 
 --  pRecA: none 
 -- pRec: "V_val" rec: "V_val" E: "V_bar" 
 --  false true 
 -- computeAdrX:before:rec:: "V_val" 
 -- OI:invoke:before:ATdx.invoke: var V_val 
 -- DI:invoke: "V_val: var V_foo -- off: 4" 
 -- isValueObj:isAdr: true objSize: 2  rec "V_val ",E: "V_bar ""ObjectInvocation
 --  _Unary "E.isCompositeValueObj: false 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T
 --   originIsValue:F:E:"V_bar":rec:V_val 
 -- Address:loadAdr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"V_bar":rec:V_val 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain "V_bar" cmpAndSwap: false rec: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"V_bar":rec:V_val 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"V_bar":rec:V_val 
 -- computeAdrX:after:rec.invoke: "V_val" 
 -- computeAdrX:isLast:E:  "V_bar "
 -- originIsValueObj: 
 --  X: var float -- off: 2
 --  V_val: var V_foo -- off: 4
 --  V_val.X := 'j'
 --  V_val.X
 --  
 -- rec = E: false 0 
 -- call:mkValueProxy false true 
 -- mkValueProxy:INV: "V_val.V_bar" E: "V_bar" rec: "V_val" E.ATd: 
 --  V_bar: 
 --     X := 'k'
 --     put(X)
 --  
 -- CreateProxyW:E: "V_bar "E.ATd.origin.encOG:OGid "V_foo "origin:descNo: 114 "ti
 --  nyS ""V_val.V_bar" 
 --  rec.ATd: "V_val: var V_foo -- off: 4 "rec.ATd.newOff: 4 0 
 rdouble 0
 -- son: "V_val" 
 -- son: "V_bar" 
 -- recOfE: "V_val "recOfE.ATd: "V_val: var V_foo -- off: 4" 
 -- first: "V_foo -- off: 4 "ObjectInvocation_Unary first.origin.encOG: "try_val
 --   "
 -- items:goOrigin:encOG: "try_val "on: 1 isValueObj: false 
 --  origin: tinyS origin:isValueObj: false 
 rpushg try_val$113 1
 -- after:Ey.loadOrigin: 
 -- Adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVal
 --  ue:F originIsValue:F:E:"V_foo -- off: 4":rec:- 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"V_foo -- off: 4":rec:- 
 -- Address:loadAdr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"V_foo -- off: 4":rec:- 
 -- after:A.loadAdr 
 mkValueProxy 114 3
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V_bar":rec:V_val 
 --  rec:  "V_val "E:  "V_bar "
 -- INV:gen:E.loadArgs "V_bar "
 -- INV:gen:after:E.loadArgs "V_bar "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "V_bar ":Adr:off:4 s
 --  ize:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsVal
 --  ue:F:E:"V_bar":rec:V_val 
 -- OI:invoke:before:ATdx.invoke: pattern V_bar 
 -- ptn:invoke: "V_bar "E: "V_bar "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "V_val" 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T
 --   originIsValue:F:E:"V_bar":rec:V_val 
 invoke V_bar 115 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"V_bar":rec:V_val nl; adrx: :Adr:off:-
 --  1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIs
 --  Value:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"V_bar":rec:V_val 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"V_bar":rec:V_val 
 -- AssignmentStatement:gen: "X := 3.14" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "X := 3.14" right.label: "ObjectGenerator ""3.14" 
 -- OG:before:super.gen: "3.14 "
 -- INV:gen: "3.14" 
 -- needorigin: "3.14" 
 -- needOrigin:E: "3.14"  E.ATd: 
 --  float: Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var Float
 --  Ex: "3.14" rec: "3.14" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var Float
 --  
 -- after:needOrigin: "3.14" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "3.14 "E:  "3.14 "
 -- INV:gen:E.loadArgs "3.14 "
 -- INV:gen:after:E.loadArgs "3.14 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: FloatLiteral "3.14 "
 pushFloatConst 3.140000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 fstoreg 2 address:storeg
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "if (X = 3.14) :then 
 --     put('l')
 --  :else 
 --     putfloat(X) "
 -- INV:gen: 
 --  if (X = 3.14) :then 
 --     put('l')
 --  :else 
 --     putfloat(X)
 --  
 -- needorigin: 
 --  if (X = 3.14) :then 
 --     put('l')
 --  :else 
 --     putfloat(X)
 --  
 -- needOrigin:E: 
 --  if (X = 3.14) :then 
 --     put('l')
 --  :else 
 --     putfloat(X)
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (X = 3.14) :then 
 --     put('l')
 --  :else 
 --     putfloat(X)
 --  rec: 
 --  if (X = 3.14) :then 
 --     put('l')
 -- \
 --   :else 
 --     putfloat(X)
 --  
 -- Ex:loadOrign:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (X = 3.14) :then 
 --     put('l')
 --  :else 
 --     putfloat(X)
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "if (X = 3.14) :then 
 --     put('l')
 --  :else 
 --     putfloat(X) "E:  "if (X = 3.14) :then 
 --     put('l')
 --  :else 
 --     putfloat(X) "
 -- INV:gen:E.loadArgs "if (X = 3.14) :then 
 --     put('l')
 --  :else 
 --     putfloat(X) "
 -- INV:gen:after:E.loadArgs "if (X = 3.14) :then 
 --     put('l')
 --  :else 
 --     putfloat(X) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThenElse "if (X = 3.14) :then 
 --     put('l')
 --  :else 
 --     putfloat(X) "
 -- OG:before:super.gen: "(X = 3.14) "
 -- INV:gen: "(X = 3.14)" 
 -- needorigin: "(X = 3.14)" 
 -- needOrigin:E: "(X = 3.14)"  E.ATd: 
 --  =  : 
 --     %basic 122
 --     in V: var float
 --     out B: var boolean
 --  Ex: "(X = 3.14)" rec: "(X = 3.14)" 
 -- doNeedOrigin:Ex: "(X = 3.14) "originIsValueObj: true origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(X = 3.14)" 
 -- doNeedOrigin:E: "(X = 3.14)" 
 -- computeAdrX:superAdj: 0 "(X = 3.14)" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(X = 3.14)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "X = 3.14 "superAdj: 0 
 -- computeAdrX:isLast:E:  "X = 3.14 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "X = 3.14 "E:  "X = 3.14 "
 -- INV:gen:E.loadArgs "X = 3.14 "
 -- BinaryExp:loadArgs: "X = 3.14" superAdj: 0 
 -- INV:gen: "X" 
 -- needorigin: "X" 
 -- needOrigin:E: "X"  E.ATd: "X: var float -- off: 2" Ex: "X" rec: "X" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "X" 
 -- doNeedOrigin:E: "X" 
 -- computeAdrX:superAdj: 0 "X" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "X" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "X "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:T isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X":rec:- 
 --  rec:  "X "E:  "X "
 -- INV:gen:E.loadArgs "X "
 -- INV:gen:after:E.loadArgs "X "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "X ":Adr:off:2 size:
 --  0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"X":rec:- 
 -- OI:invoke:before:ATdx.invoke: var X 
 -- DI:invoke: "X: var float -- off: 2" 
 -- load: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"X":rec:X isNotRemote: true 
 fpushg 2 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"X":rec:X 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"X":rec:X 
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:2 size:0 isFloat:T isUnit
 --  Val:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X":rec:X 
 -- NonVirt: "= 3.14" "ObjectInvocation_Binary" ActArg: "3.14 "isValue: true formalArg: "in V: var float" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "= 3.14 " isCompositeValueObj: false 
 -- OG:before:super.gen: "3.14 "
 -- INV:gen: "3.14" 
 -- needorigin: "3.14" 
 -- needOrigin:E: "3.14"  E.ATd: 
 --  float: Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var Float
 --  Ex: "3.14" rec: "3.14" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var Float
 --  
 -- after:needOrigin: "3.14" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "3.14 "E:  "3.14 "
 -- INV:gen:E.loadArgs "3.14 "
 -- INV:gen:after:E.loadArgs "3.14 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: FloatLiteral "3.14 "
 pushFloatConst 3.140000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var float ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "3.14 ":isBasicVal: true 
 -- case:B: 3.14 ObjectGenerator 9 9 9 false true 
 -- end:loadArgs:NonVirt: "= 3.14 "
 -- BinaryExp:loadArgs:end: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj
 --  :0 isUnique:F isValue:T originIsValue:F:E:"X":rec:X 
 -- INV:gen:after:E.loadArgs "X = 3.14 "
 --  OIadr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:T originIsValue:F:E:"X":rec:X 
 -- IV:E.invoke:useRtnVal: true E: BinOp "X = 3.14 ":Adr:off:2 size:0 isFloat:
 --  T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X":rec
 --  :X 
 -- BinaryExp:invoke: "X "rec: "X = 3.14 "
 -- M: "= 3.14 ":Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F
 --   isValue:T originIsValue:F:E:"X":rec:X 
 -- OI:invoke:before:ATdx.invoke: pattern =   
 -- ptn:invoke: "=   "E: "= 3.14 "ptnKind: 0 useRtnV: true 
 feq
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"= 3.14":rec:X nl; adrx: :Adr:off:0 si
 --  ze:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValu
 --  e:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"= 3.14":rec:X 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  117   "$117 "
 invoke $117 117 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L5
 L4:
 pushThis 
 -- before objTmpStack:add:  118   "$118 "
 invoke $118 118 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 L5:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0

 CLASS V_foo 114 0 tinyS 103 isValueObj
 mvStack 
 -- DI:gen: "Q: var integer -- 4 in tinyS" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  Q 
 -- DI:gen: "X: var integer -- 5 in tinyS" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  X 
 rtnAlloc 1
DO:
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS V_bar 115 1 V_foo 114
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "X := 'k'" 
 pushThis 
 -- items:goOrigin:encOG: "V_bar "on: 1 isValueObj: false 
 --  origin: V_foo origin:isValueObj: true 
 rpushg V_bar$115 1
 -- AssignmentStatement:gen: 
 --  "X := 'k'" right.label: "ObjectGenerator ""'k'" 
 -- OG:before:super.gen: "'k' "
 -- INV:gen: "'k'" 
 -- needorigin: "'k'" 
 -- needOrigin:E: "'k'"  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  Ex: "'k'" rec: "'k'" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  
 -- after:needOrigin: "'k'" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "'k' "E:  "'k' "
 -- INV:gen:E.loadArgs "'k' "
 -- INV:gen:after:E.loadArgs "'k' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "'k' "
 pushc 107
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 vstoreg  2
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "put(X) "
 -- INV:gen: "put(X)" 
 -- needorigin: "put(X)" 
 -- needOrigin:E: "put(X)"  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put(X)" rec: "put(X)" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put(X)" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put(X) "E:  "put(X) "
 -- INV:gen:E.loadArgs "put(X) "
 -- NonVirt: "put(X)" "ObjectInvocation_KeyWord" ActArg: "X "isValue: false formalArg: "in ch: val char" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(X) " isCompositeValueObj: false 
 -- OG:before:super.gen: "X "
 -- INV:gen: "X" 
 -- needorigin: "X" 
 -- needOrigin:E: "X"  E.ATd: "X: var integer -- 5 in tinyS" Ex: "X" rec: "X" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "X" 
 -- doNeedOrigin:E: "X" 
 -- computeAdrX:superAdj: 0 "X" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "X" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "V_bar "on: 1 isValueObj: false 
 --  origin: V_foo origin:isValueObj: true 
 rpushg V_bar$115 1
 -- computeAdrX:isLast:E:  "X "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:T:E:"X":rec:- 
 --  rec:  "X "E:  "X "
 -- INV:gen:E.loadArgs "X "
 -- INV:gen:after:E.loadArgs "X "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "X ":Adr:off:2 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T
 --  :E:"X":rec:- 
 -- OI:invoke:before:ATdx.invoke: var X 
 -- DI:invoke: "X: var integer -- 5 in tinyS" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:T:E:"X":rec:X isNotRemote: true 
 vpushg 2 V_foo$114
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:T:E:"X":rec:X 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:T:E:"X":rec:X 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:T:E:"X":rec:X 
 -- actualArg:isPtn: false formalArg:isPtn: "in ch: val char ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "X ":isBasicVal: true 
 -- case:B: X ObjectGenerator 3 0 1 false false 
 -- end:loadArgs:NonVirt: "put(X) "
 -- INV:gen:after:E.loadArgs "put(X) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(X) "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put(X) "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $117 117 1 try_val 113
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "put('l') "
 -- INV:gen: "put('l')" 
 -- needorigin: "put('l')" 
 -- needOrigin:E: "put('l')"  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put('l')" rec: "put('l')" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put('l')" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put('l') "E:  "put('l') "
 -- INV:gen:E.loadArgs "put('l') "
 -- NonVirt: "put('l')" "ObjectInvocation_KeyWord" ActArg: "'l' "isValue: true formalArg: "in ch: val char" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put('l') " isCompositeValueObj: false 
 -- OG:before:super.gen: "'l' "
 -- INV:gen: "'l'" 
 -- needorigin: "'l'" 
 -- needOrigin:E: "'l'"  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  Ex: "'l'" rec: "'l'" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  
 -- after:needOrigin: "'l'" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "'l' "E:  "'l' "
 -- INV:gen:E.loadArgs "'l' "
 -- INV:gen:after:E.loadArgs "'l' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "'l' "
 pushc 108
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "'l' ":isBasicVal: true 
 -- case:B: 'l' ObjectGenerator 3 3 3 false true 
 -- end:loadArgs:NonVirt: "put('l') "
 -- INV:gen:after:E.loadArgs "put('l') "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put('l') "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put('l') "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $118 118 1 try_val 113
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "putfloat(X) "
 -- INV:gen: "putfloat(X)" 
 -- needorigin: "putfloat(X)" 
 -- needOrigin:E: "putfloat(X)"  E.ATd: 
 --  putFloat: 
 --     %basic 142
 --     in X: var Float
 --     out V: var integer
 --  Ex: "putfloat(X)" rec: "putfloat(X)" 
 -- doNeedOrigin:Ex: "putfloat(X) "originIsValueObj: false origin.isPrimitive:
 --   false 
 -- KUK 
 -- after:needOrigin: "putfloat(X)" 
 -- doNeedOrigin:E: "putfloat(X)" 
 -- computeAdrX:superAdj: 0 "putfloat(X)" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "putfloat(X)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "putfloat(X) "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putfloat(X)":rec:- 
 --  rec:  "putfloat(X) "E:  "putfloat(X) "
 -- INV:gen:E.loadArgs "putfloat(X) "
 -- NonVirt: "putfloat(X)" "ObjectInvocation_KeyWord" ActArg: "X "isValue: false formalArg: "in X: var Float" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "putfloat(X) " isCompositeValueObj: false 
 -- OG:before:super.gen: "X "
 -- INV:gen: "X" 
 -- needorigin: "X" 
 -- needOrigin:E: "X"  E.ATd: "X: var float -- off: 2" Ex: "X" rec: "X" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "X" 
 -- doNeedOrigin:E: "X" 
 -- computeAdrX:superAdj: 0 "X" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "X" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$118 "on: 1 isValueObj: false 
 --  origin: try_val origin:isValueObj: false 
 rpushg $118$118 1
 -- computeAdrX:isLast:E:  "X "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:T isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X":rec:- 
 --  rec:  "X "E:  "X "
 -- INV:gen:E.loadArgs "X "
 -- INV:gen:after:E.loadArgs "X "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "X ":Adr:off:2 size:
 --  0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"X":rec:- 
 -- OI:invoke:before:ATdx.invoke: var X 
 -- DI:invoke: "X: var float -- off: 2" 
 -- load: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"X":rec:X isNotRemote: true 
 fpushg 2 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"X":rec:X 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"X":rec:X 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"X":rec:X 
 -- actualArg:isPtn: false formalArg:isPtn: "in X: var Float ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "X ":isBasicVal: true 
 -- case:B: X ObjectGenerator 9 0 9 false false 
 -- end:loadArgs:NonVirt: "putfloat(X) "
 -- INV:gen:after:E.loadArgs "putfloat(X) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "putfloat(X) ":Adr
 --  :off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori
 --  ginIsValue:F:E:"putfloat(X)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern putFloat 
 -- ptn:invoke: "putFloat "E: "putfloat(X) "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "putfloat(X)" 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"putfloat(X)":rec:putfloat(X) 
 %printf_prim 142
 vpop
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"putfloat(X)":rec:putfloat(X) nl; adr
 --  x: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue
 --  :F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"putfloat(X)":rec:putfloat(X) 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"putfloat(X)":rec:putfloat(X) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS string_foo 119 1 tinyS 103
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "S: var String" DI:isConst: false :isBasicValue: false :primNo: 5 
 -- StringVar "S: var String "
 pushText ""
 pushThis 
 rstoreg  S 2
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 -- DI:gen: "R: ref Record" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:gen: "T: ref Record" DI:isConst: false :isBasicValue: false :primNo: 0 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "S := "mno"" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "S := "mno"" right.label: "ObjectGenerator """mno"" 
 -- OG:before:super.gen: ""mno" "
 -- INV:gen: ""mno"" 
 -- needorigin: ""mno"" 
 -- needOrigin:E: ""mno""  E.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 --  Ex: ""mno"" rec: ""mno"" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 --  
 -- after:needOrigin: ""mno"" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  ""mno" "E:  ""mno" "
 -- INV:gen:E.loadArgs ""mno" "
 -- INV:gen:after:E.loadArgs ""mno" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: String: ""mno" "
 pushText "mno"
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 rswap 0
 rstoreg  EisNone 2
   ;; vTop(0,0)=[] rTop(-2,1)=[]
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "S.print "
 -- INV:gen: "S.print" 
 -- needorigin: "S.print" 
 -- needOrigin:E: "print"  E.ATd: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeat
 --  Ex: "print" rec: "S" 
 -- doNeedOrigin:Ex: "print "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "print" 
 -- doNeedOrigin:E: "print" 
 -- computeAdrX:superAdj: 0 "S.print" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "S" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "S" rec: "S" E: "print" 
 --  A.E: none 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "S" rec: "S" E: "print" 
 --  rec.ATd: "S: var String" rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  S: var String
 --     R: ref Record
 --     T: ref Record
 --     S := "mno"
 --  
 --  recA: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"print":rec:- 
 --  pRecA: none 
 -- pRec: "S" rec: "S" E: "print" 
 --  false false 
 -- computeAdrX:before:rec:: "S" 
 -- OI:invoke:before:ATdx.invoke: var S 
 -- DI:invoke: "S: var String" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"print":rec:S 
 rpushg string_foo$119 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"print":rec:S 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"print":rec:S 
 -- computeAdrX:after:rec.invoke: "S" 
 -- computeAdrX:isLast:E:  "print "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:S 
 --  rec:  "S "E:  "print "
 -- INV:gen:E.loadArgs "print "
 -- INV:gen:after:E.loadArgs "print "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print ":Adr:off:2 s
 --  ize:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVal
 --  ue:F:E:"print":rec:S 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "S" 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"print":rec:S 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"print":rec:S nl; adrx: :Adr:off:-1 si
 --  ze:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValu
 --  e:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"print":rec:S 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"print":rec:S 
 -- AssignmentStatement:gen: "R := record("pq")" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "R := record("pq")" right.label: "ObjectGenerator ""record("pq")" 
 -- OG:before:super.gen: "record("pq") "
 -- INV:gen: "record("pq")" 
 -- needorigin: "record("pq")" 
 -- needOrigin:E: "record("pq")"  E.ATd: 
 --  Record(S: var String): 
 --     print: 
 --        S.print
 --     show:< 
 --  Ex: "record("pq")" rec: "record("pq")" 
 -- doNeedOrigin:Ex: "record("pq") "originIsValueObj: false origin.isPrimitive
 --  : false 
 -- KUK 
 -- after:needOrigin: "record("pq")" 
 -- doNeedOrigin:E: "record("pq")" 
 -- computeAdrX:superAdj: 0 "record("pq")" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "record("pq")" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "string_foo "on: 1 isValueObj: false 
 --  origin: tinyS origin:isValueObj: false 
 rpushg string_foo$119 1
 -- computeAdrX:isLast:E:  "record("pq") "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"record("pq")":rec:-
 --   
 --  rec:  "record("pq") "E:  "record("pq") "
 -- INV:gen:E.loadArgs "record("pq") "
 -- NonVirt: "record("pq")" "ObjectInvocation_KeyWord" ActArg: ""pq" "isValue: false formalArg: "S: var String" 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "record("pq") " isCompositeValueObj: false 
 -- OG:before:super.gen: ""pq" "
 -- INV:gen: ""pq"" 
 -- needorigin: ""pq"" 
 -- needOrigin:E: ""pq""  E.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 --  Ex: ""pq"" rec: ""pq"" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 --  
 -- after:needOrigin: ""pq"" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  ""pq" "E:  ""pq" "
 -- INV:gen:E.loadArgs ""pq" "
 -- INV:gen:after:E.loadArgs ""pq" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: String: ""pq" "
 pushText "pq"
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "S: var String ":isBasicVal: false :
 --  valueObj: false 
 --  :actArg: ""pq" ":isBasicVal: false 
 -- case:B: "pq" ObjectGenerator 5 5 5 false false 
 -- end:loadArgs:NonVirt: "record("pq") "
 -- INV:gen:after:E.loadArgs "record("pq") "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "record("pq") ":Ad
 --  r:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F or
 --  iginIsValue:F:E:"record("pq")":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern Record(S: var String) 
 -- ptn:invoke: "Record(S: var String) "E: "record("pq") "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "record("pq")" 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"record("pq")":rec:record("pq") 
 invoke Record 120 0 1
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"record("pq")":rec:record("pq") nl; a
 --  drx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"record("pq")":rec:record("pq") 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"record("pq")":rec:record("pq") 
 -- assign:adr.store:A: 
 rswap 0
 rstoreg  EisNone 3
   ;; vTop(0,0)=[] rTop(-4,1)=[]
 -- assign:adr.store:B: 
 -- AssignmentStatement:gen: "T := R" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "T := R" right.label: "ObjectGenerator ""R" 
 -- OG:before:super.gen: "R "
 -- INV:gen: "R" 
 -- needorigin: "R" 
 -- needOrigin:E: "R"  E.ATd: "R: ref Record" Ex: "R" rec: "R" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "R" 
 -- doNeedOrigin:E: "R" 
 -- computeAdrX:superAdj: 0 "R" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "R" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "R "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "R "E:  "R "
 -- INV:gen:E.loadArgs "R "
 -- INV:gen:after:E.loadArgs "R "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "R ":Adr:off:3 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F
 --  :E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: ref R 
 -- DI:invoke: "R: ref Record" 
 -- >Object:unique: false 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"R":rec:R isNotRemote: true 
 rpushg string_foo$119 3
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"R":rec:R 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"R":rec:R 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"R":rec:R 
 -- assign:adr.store:A: 
 rswap 0
 rstoreg  EisNone 4
   ;; vTop(0,0)=[] rTop(-6,1)=[]
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "T.print "
 -- INV:gen: "T.print" 
 -- needorigin: "T.print" 
 -- needOrigin:E: "print"  E.ATd: 
 --  print: 
 --     S.print
 --  Ex: "print" rec: "T" 
 -- doNeedOrigin:Ex: "print "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "print" 
 -- doNeedOrigin:E: "print" 
 -- computeAdrX:superAdj: 0 "T.print" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "T" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "T" rec: "T" E: "print" 
 --  A.E: none 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "T" rec: "T" E: "print" 
 --  rec.ATd: "T: ref Record" rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  S: var String
 --     R: ref Record
 --     T: ref Record
 --     S := "mno"
 --  
 --  recA: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"print":rec:- 
 --  pRecA: none 
 -- pRec: "T" rec: "T" E: "print" 
 --  false false 
 -- computeAdrX:before:rec:: "T" 
 -- OI:invoke:before:ATdx.invoke: ref T 
 -- DI:invoke: "T: ref Record" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"print":rec:T 
 rpushg string_foo$119 4
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"print":rec:T 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"print":rec:T 
 -- computeAdrX:after:rec.invoke: "T" 
 -- computeAdrX:isLast:E:  "print "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:T 
 --  rec:  "T "E:  "print "
 -- INV:gen:E.loadArgs "print "
 -- INV:gen:after:E.loadArgs "print "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print ":Adr:off:4 s
 --  ize:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVal
 --  ue:F:E:"print":rec:T 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "T" 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"print":rec:T 
 invoke print 121 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"print":rec:T nl; adrx: :Adr:off:-1 si
 --  ze:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValu
 --  e:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"print":rec:T 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"print":rec:T 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS Record 120 1 tinyS 103
 pushThis 
 rstoreg  S 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS show 132 1 Record 120
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(show) "
 -- INV:gen: "inner(show)" 
 -- needorigin: "inner(show)" 
 -- needOrigin:E: "inner(show)"  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(show)" rec: "inner(show)" 
 -- doNeedOrigin:Ex: "inner(show) "originIsValueObj: false origin.isPrimitive:
 --   false 
 -- KUK 
 -- after:needOrigin: "inner(show)" 
 -- doNeedOrigin:E: "inner(show)" 
 -- computeAdrX:superAdj: 0 "inner(show)" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(show)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(show) "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(show)":rec:- 
 --  rec:  "inner(show) "E:  "inner(show) "
 -- INV:gen:E.loadArgs "inner(show) "
 -- INV:gen:after:E.loadArgs "inner(show) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(show) ":Adr
 --  :off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori
 --  ginIsValue:F:E:"inner(show)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(show) "ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"inner(show)":rec:inner(show) 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"inner(show)":rec:inner(show) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"inner(show)":rec:inner(show) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS print 121 1 Record 120
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "S.print "
 -- INV:gen: "S.print" 
 -- needorigin: "S.print" 
 -- needOrigin:E: "print"  E.ATd: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeat
 --  Ex: "print" rec: "S" 
 -- doNeedOrigin:Ex: "print "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "print" 
 -- doNeedOrigin:E: "print" 
 -- computeAdrX:superAdj: 0 "S.print" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "S" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "print "on: 1 isValueObj: false 
 --  origin: Record origin:isValueObj: false 
 rpushg print$121 1
 -- computeAdrX:En: 2 pRec: "S" rec: "S" E: "print" 
 --  A.E: none 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "S" rec: "S" E: "print" 
 --  rec.ATd: "S: var String" rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  print: 
 --        S.print
 --     show:< 
 --        inner(show)
 --  
 --  recA: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"print":rec:- 
 --  pRecA: none 
 -- pRec: "S" rec: "S" E: "print" 
 --  false false 
 -- computeAdrX:before:rec:: "S" 
 -- OI:invoke:before:ATdx.invoke: var S 
 -- DI:invoke: "S: var String" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"print":rec:S 
 rpushg print$121 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"print":rec:S 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"print":rec:S 
 -- computeAdrX:after:rec.invoke: "S" 
 -- computeAdrX:isLast:E:  "print "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:S 
 --  rec:  "S "E:  "print "
 -- INV:gen:E.loadArgs "print "
 -- INV:gen:after:E.loadArgs "print "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print ":Adr:off:2 s
 --  ize:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVal
 --  ue:F:E:"print":rec:S 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "S" 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"print":rec:S 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"print":rec:S nl; adrx: :Adr:off:-1 si
 --  ze:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValu
 --  e:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"print":rec:S 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"print":rec:S 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS point_foo 122 1 tinyS 103
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "P1: var Point('r','s')" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  P1 
 -- DI:off: 2 this: "P1: var Point('r','s')" 
 --  
 -- OG:before:super.gen: "Point('r','s') "
 -- INV:gen: "Point('r','s')" 
 -- needorigin: "Point('r','s')" 
 -- needOrigin:E: "Point('r','s')"  E.ATd: 
 --  point(x: var integer,y: var integer): Value
 --     move(dx: var integer,dy: var integer): 
 --        x := x + dx
 --        y := y + dy
 --  Ex: "Point('r','s')" rec: "Point('r','s')" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  Value
 --     move(dx: var integer,dy: var integer): 
 --        x := x + dx
 --        y := y + dy
 --  
 -- after:needOrigin: "Point('r','s')" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "Point('r','s') "E:  "Point('r','s') "
 -- INV:gen:E.loadArgs "Point('r','s') "
 -- NonVirt: "Point('r','s')" "ObjectInvocation_Function" ActArg: "'r' "isValue: true formalArg: "x: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "Point('r','s') " isCompositeValueObj: false 
 -- OG:before:super.gen: "'r' "
 -- INV:gen: "'r'" 
 -- needorigin: "'r'" 
 -- needOrigin:E: "'r'"  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  Ex: "'r'" rec: "'r'" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  
 -- after:needOrigin: "'r'" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "'r' "E:  "'r' "
 -- INV:gen:E.loadArgs "'r' "
 -- INV:gen:after:E.loadArgs "'r' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "'r' "
 pushc 114
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "x: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "'r' ":isBasicVal: true 
 -- case:B: 'r' ObjectGenerator 1 3 3 false true 
 -- end:loadArgs:NonVirt: "Point('r','s') "
 -- NonVirt: "Point('r','s')" "ObjectInvocation_Function" ActArg: "'s' "isValue: true formalArg: "y: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "Point('r','s') " isCompositeValueObj: false 
 -- OG:before:super.gen: "'s' "
 -- INV:gen: "'s'" 
 -- needorigin: "'s'" 
 -- needOrigin:E: "'s'"  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  Ex: "'s'" rec: "'s'" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  
 -- after:needOrigin: "'s'" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "'s' "E:  "'s' "
 -- INV:gen:E.loadArgs "'s' "
 -- INV:gen:after:E.loadArgs "'s' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "'s' "
 pushc 115
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "y: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "'s' ":isBasicVal: true 
 -- case:B: 's' ObjectGenerator 1 3 3 false true 
 -- end:loadArgs:NonVirt: "Point('r','s') "
 -- INV:gen:after:E.loadArgs "Point('r','s') "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Function "Point('r','s') "
 -- OI:invoke:before:ATdx.invoke: pattern point(x: var integer,y: var integer
 --  ) 
 -- ptn:invoke: "point(x: var integer,y: var integer) "E: "Point('r','s') "ptnK
 --  ind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 2 rec: "Point('r','s')" 
 --  adr:none 
 invokeVal  point 123 1
 rpop 
 -- OI:invoke:V: nl; adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0
 --   isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- DI:gen: "P2: var Point(0,0)" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  P2 
 -- DI:off: 4 this: "P2: var Point(0,0)" 
 --  
 -- OG:before:super.gen: "Point(0,0) "
 -- INV:gen: "Point(0,0)" 
 -- needorigin: "Point(0,0)" 
 -- needOrigin:E: "Point(0,0)"  E.ATd: 
 --  point(x: var integer,y: var integer): Value
 --     move(dx: var integer,dy: var integer): 
 --        x := x + dx
 --        y := y + dy
 --  Ex: "Point(0,0)" rec: "Point(0,0)" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  Value
 --     move(dx: var integer,dy: var integer): 
 --        x := x + dx
 --        y := y + dy
 --  
 -- after:needOrigin: "Point(0,0)" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "Point(0,0) "E:  "Point(0,0) "
 -- INV:gen:E.loadArgs "Point(0,0) "
 -- NonVirt: "Point(0,0)" "ObjectInvocation_Function" ActArg: "0 "isValue: true formalArg: "x: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "Point(0,0) " isCompositeValueObj: false 
 -- OG:before:super.gen: "0 "
 -- INV:gen: "0" 
 -- needorigin: "0" 
 -- needOrigin:E: "0"  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "0" rec: "0" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "0" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "0 "E:  "0 "
 -- INV:gen:E.loadArgs "0 "
 -- INV:gen:after:E.loadArgs "0 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0 "
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "x: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "0 ":isBasicVal: true 
 -- case:B: 0 ObjectGenerator 1 1 1 false true 
 -- end:loadArgs:NonVirt: "Point(0,0) "
 -- NonVirt: "Point(0,0)" "ObjectInvocation_Function" ActArg: "0 "isValue: true formalArg: "y: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "Point(0,0) " isCompositeValueObj: false 
 -- OG:before:super.gen: "0 "
 -- INV:gen: "0" 
 -- needorigin: "0" 
 -- needOrigin:E: "0"  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "0" rec: "0" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "0" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "0 "E:  "0 "
 -- INV:gen:E.loadArgs "0 "
 -- INV:gen:after:E.loadArgs "0 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0 "
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "y: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "0 ":isBasicVal: true 
 -- case:B: 0 ObjectGenerator 1 1 1 false true 
 -- end:loadArgs:NonVirt: "Point(0,0) "
 -- INV:gen:after:E.loadArgs "Point(0,0) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Function "Point(0,0) "
 -- OI:invoke:before:ATdx.invoke: pattern point(x: var integer,y: var integer
 --  ) 
 -- ptn:invoke: "point(x: var integer,y: var integer) "E: "Point(0,0) "ptnKind:
 --   0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 4 rec: "Point(0,0)" 
 --  adr:none 
 invokeVal  point 123 3
 rpop 
 -- OI:invoke:V: nl; adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0
 --   isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- DI:gen: "P3: var PositivePoint('x','y')" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  P3 
 -- DI:off: 6 this: "P3: var PositivePoint('x','y')" 
 --  
 -- OG:before:super.gen: "PositivePoint('x','y') "
 -- INV:gen: "PositivePoint('x','y')" 
 -- needorigin: "PositivePoint('x','y')" 
 -- needOrigin:E: "PositivePoint('x','y')"  E.ATd: 
 --  PositivePoint: Point
 --     check::< 
 --        print
 --  Ex: "PositivePoint('x','y')" rec: "PositivePoint('x','y')" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  Point
 --     check::< 
 --        print
 --  
 -- after:needOrigin: "PositivePoint('x','y')" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "PositivePoint('x','y') "E:  "PositivePoint('x','y') "
 -- INV:gen:E.loadArgs "PositivePoint('x','y') "
 -- NonVirt: "PositivePoint('x','y')" "ObjectInvocation_Function" ActArg: "'x' "isValue: true formalArg: "x: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "PositivePoint('x','y') " isCompositeValueOb
 --  j: false 
 -- OG:before:super.gen: "'x' "
 -- INV:gen: "'x'" 
 -- needorigin: "'x'" 
 -- needOrigin:E: "'x'"  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  Ex: "'x'" rec: "'x'" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  
 -- after:needOrigin: "'x'" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "'x' "E:  "'x' "
 -- INV:gen:E.loadArgs "'x' "
 -- INV:gen:after:E.loadArgs "'x' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "'x' "
 pushc 120
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "x: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "'x' ":isBasicVal: true 
 -- case:B: 'x' ObjectGenerator 1 3 3 false true 
 -- end:loadArgs:NonVirt: "PositivePoint('x','y') "
 -- NonVirt: "PositivePoint('x','y')" "ObjectInvocation_Function" ActArg: "'y' "isValue: true formalArg: "y: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "PositivePoint('x','y') " isCompositeValueOb
 --  j: false 
 -- OG:before:super.gen: "'y' "
 -- INV:gen: "'y'" 
 -- needorigin: "'y'" 
 -- needOrigin:E: "'y'"  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  Ex: "'y'" rec: "'y'" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  
 -- after:needOrigin: "'y'" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "'y' "E:  "'y' "
 -- INV:gen:E.loadArgs "'y' "
 -- INV:gen:after:E.loadArgs "'y' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "'y' "
 pushc 121
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "y: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "'y' ":isBasicVal: true 
 -- case:B: 'y' ObjectGenerator 1 3 3 false true 
 -- end:loadArgs:NonVirt: "PositivePoint('x','y') "
 -- INV:gen:after:E.loadArgs "PositivePoint('x','y') "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Function "PositivePoint('x
 --  ','y') "
 -- OI:invoke:before:ATdx.invoke: pattern PositivePoint 
 -- ptn:invoke: "PositivePoint "E: "PositivePoint('x','y') "ptnKind: 0 useRtnV:
 --   false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 6 rec: "PositivePoint('x','y')" 
 --  adr:none 
 invokeVal  PositivePoint 124 5
 rpop 
 -- OI:invoke:V: nl; adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0
 --   isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "P1.print "
 -- INV:gen: "P1.print" 
 -- needorigin: "P1.print" 
 -- needOrigin:E: "print"  E.ATd: 
 --  print: 
 --     put(x)
 --     put(y)
 --  Ex: "print" rec: "P1" 
 -- doNeedOrigin:Ex: "print "originIsValueObj: true origin.isPrimitive: false 
 -- origin:isValueObj: "point "
 -- after:needOrigin: "print" 
 -- doNeedOrigin:E: "print" 
 -- computeAdrX:superAdj: 0 "P1.print" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "P1" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "P1" rec: "P1" E: "print" 
 --  A.E: "P1 "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T
 --   originIsValue:F:E:"P1":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "P1" rec: "P1" E: "print" 
 --  rec.ATd: "P1: var Point('r','s')" rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  P1: var Point('r','s')
 --     P2: var Point(0,0)
 --     P3: var PositivePoint('x','y')
 --     P1.print
 --  
 --  recA: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"P1":rec:- 
 --  pRecA: none 
 -- pRec: "P1" rec: "P1" E: "print" 
 --  false true 
 -- computeAdrX:before:rec:: "P1" 
 -- OI:invoke:before:ATdx.invoke: var P1 
 -- DI:invoke: "P1: var Point('r','s')" 
 -- isValueObj:isAdr: true objSize: 2  rec "P1 ",E: "print ""ObjectInvocation_Un
 --  ary "E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T
 --   originIsValue:F:E:"print":rec:P1 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"print":rec:P1 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain "print" cmpAndSwap: false rec: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"print":rec:P1 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"print":rec:P1 
 -- computeAdrX:after:rec.invoke: "P1" 
 -- computeAdrX:isLast:E:  "print "
 -- originIsValueObj: 
 --  P1: var Point('r','s')
 --  P2: var Point(0,0)
 --  P3: var PositivePoint('x','y')
 --  P1.print
 --  
 -- rec = E: false 0 
 -- call:mkValueProxy false true 
 -- mkValueProxy:INV: "P1.print" E: "print" rec: "P1" E.ATd: 
 --  print: 
 --     put(x)
 --     put(y)
 --  
 -- CreateProxyW:E: "print "E.ATd.origin.encOG:OGid "point "origin:descNo: 123 "ti
 --  nyS ""P1.print" 
 --  rec.ATd: "P1: var Point('r','s') "rec.ATd.newOff: 2 0 
 rdouble 0
 -- son: "P1" 
 -- son: "print" 
 -- recOfE: "P1 "recOfE.ATd: "P1: var Point('r','s')" 
 -- first: "Point('r','s') "ObjectInvocation_Function first.origin.encOG: "point
 --  _foo "
 -- items:goOrigin:encOG: "point_foo "on: 1 isValueObj: false 
 --  origin: tinyS origin:isValueObj: false 
 rpushg point_foo$122 1
 -- after:Ey.loadOrigin: 
 -- Adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVal
 --  ue:F originIsValue:F:E:"Point('r','s')":rec:- 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"Point('r','s')":rec:- 
 -- Address:loadAdr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"Point('r','s')":rec:- 
 -- after:A.loadAdr 
 mkValueProxy 123 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:P1 
 --  rec:  "P1 "E:  "print "
 -- INV:gen:E.loadArgs "print "
 -- INV:gen:after:E.loadArgs "print "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print ":Adr:off:2 s
 --  ize:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsVal
 --  ue:F:E:"print":rec:P1 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "P1" 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T
 --   originIsValue:F:E:"print":rec:P1 
 invoke print 125 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"print":rec:P1 nl; adrx: :Adr:off:-1 s
 --  ize:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVal
 --  ue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"print":rec:P1 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"print":rec:P1 
 -- AssignmentStatement:gen: "P1 := Point('t','u')" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "P1 := Point('t','u')" right.label: "ObjectGenerator ""Point('t','u')" 
 -- OG:before:super.gen: "Point('t','u') "
 -- INV:gen: "Point('t','u')" 
 -- needorigin: "Point('t','u')" 
 -- needOrigin:E: "Point('t','u')"  E.ATd: 
 --  point(x: var integer,y: var integer): Value
 --     move(dx: var integer,dy: var integer): 
 --        x := x + dx
 --        y := y + dy
 --  Ex: "Point('t','u')" rec: "Point('t','u')" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  Value
 --     move(dx: var integer,dy: var integer): 
 --        x := x + dx
 --        y := y + dy
 --  
 -- after:needOrigin: "Point('t','u')" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "Point('t','u') "E:  "Point('t','u') "
 -- INV:gen:E.loadArgs "Point('t','u') "
 -- NonVirt: "Point('t','u')" "ObjectInvocation_Function" ActArg: "'t' "isValue: true formalArg: "x: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "Point('t','u') " isCompositeValueObj: false 
 -- OG:before:super.gen: "'t' "
 -- INV:gen: "'t'" 
 -- needorigin: "'t'" 
 -- needOrigin:E: "'t'"  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  Ex: "'t'" rec: "'t'" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  
 -- after:needOrigin: "'t'" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "'t' "E:  "'t' "
 -- INV:gen:E.loadArgs "'t' "
 -- INV:gen:after:E.loadArgs "'t' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "'t' "
 pushc 116
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "x: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "'t' ":isBasicVal: true 
 -- case:B: 't' ObjectGenerator 1 3 3 false true 
 -- end:loadArgs:NonVirt: "Point('t','u') "
 -- NonVirt: "Point('t','u')" "ObjectInvocation_Function" ActArg: "'u' "isValue: true formalArg: "y: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "Point('t','u') " isCompositeValueObj: false 
 -- OG:before:super.gen: "'u' "
 -- INV:gen: "'u'" 
 -- needorigin: "'u'" 
 -- needOrigin:E: "'u'"  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  Ex: "'u'" rec: "'u'" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  
 -- after:needOrigin: "'u'" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "'u' "E:  "'u' "
 -- INV:gen:E.loadArgs "'u' "
 -- INV:gen:after:E.loadArgs "'u' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "'u' "
 pushc 117
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "y: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "'u' ":isBasicVal: true 
 -- case:B: 'u' ObjectGenerator 1 3 3 false true 
 -- end:loadArgs:NonVirt: "Point('t','u') "
 -- INV:gen:after:E.loadArgs "Point('t','u') "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Function "Point('t','u') "
 -- OI:invoke:before:ATdx.invoke: pattern point(x: var integer,y: var integer
 --  ) 
 -- ptn:invoke: "point(x: var integer,y: var integer) "E: "Point('t','u') "ptnK
 --  ind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "Point('t','u')" 
 --  adr:none 
 -- kuk: 
 pushc 0
 -- OI:invoke:V: nl; adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0
 --   isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 vpop
 saveAndSetThis 
 invokeVal  point 123 1
 rpop 
 restoreThis   -- assign:adr.store:B: 
 -- OG:before:super.gen: "P1.print "
 -- INV:gen: "P1.print" 
 -- needorigin: "P1.print" 
 -- needOrigin:E: "print"  E.ATd: 
 --  print: 
 --     put(x)
 --     put(y)
 --  Ex: "print" rec: "P1" 
 -- doNeedOrigin:Ex: "print "originIsValueObj: true origin.isPrimitive: false 
 -- origin:isValueObj: "point "
 -- after:needOrigin: "print" 
 -- doNeedOrigin:E: "print" 
 -- computeAdrX:superAdj: 0 "P1.print" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "P1" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "P1" rec: "P1" E: "print" 
 --  A.E: "P1 "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T
 --   originIsValue:F:E:"P1":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "P1" rec: "P1" E: "print" 
 --  rec.ATd: "P1: var Point('r','s')" rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  P1: var Point('r','s')
 --     P2: var Point(0,0)
 --     P3: var PositivePoint('x','y')
 --     P1.print
 --  
 --  recA: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"P1":rec:- 
 --  pRecA: none 
 -- pRec: "P1" rec: "P1" E: "print" 
 --  false true 
 -- computeAdrX:before:rec:: "P1" 
 -- OI:invoke:before:ATdx.invoke: var P1 
 -- DI:invoke: "P1: var Point('r','s')" 
 -- isValueObj:isAdr: true objSize: 2  rec "P1 ",E: "print ""ObjectInvocation_Un
 --  ary "E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T
 --   originIsValue:F:E:"print":rec:P1 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"print":rec:P1 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain "print" cmpAndSwap: false rec: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"print":rec:P1 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"print":rec:P1 
 -- computeAdrX:after:rec.invoke: "P1" 
 -- computeAdrX:isLast:E:  "print "
 -- originIsValueObj: 
 --  P1: var Point('r','s')
 --  P2: var Point(0,0)
 --  P3: var PositivePoint('x','y')
 --  P1.print
 --  
 -- rec = E: false 0 
 -- call:mkValueProxy false true 
 -- mkValueProxy:INV: "P1.print" E: "print" rec: "P1" E.ATd: 
 --  print: 
 --     put(x)
 --     put(y)
 --  
 -- CreateProxyW:E: "print "E.ATd.origin.encOG:OGid "point "origin:descNo: 123 "ti
 --  nyS ""P1.print" 
 --  rec.ATd: "P1: var Point('r','s') "rec.ATd.newOff: 2 0 
 rdouble 0
 -- son: "P1" 
 -- son: "print" 
 -- recOfE: "P1 "recOfE.ATd: "P1: var Point('r','s')" 
 -- first: "Point('r','s') "ObjectInvocation_Function first.origin.encOG: "point
 --  _foo "
 -- items:goOrigin:encOG: "point_foo "on: 1 isValueObj: false 
 --  origin: tinyS origin:isValueObj: false 
 rpushg point_foo$122 1
 -- after:Ey.loadOrigin: 
 -- Adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVal
 --  ue:F originIsValue:F:E:"Point('r','s')":rec:- 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"Point('r','s')":rec:- 
 -- Address:loadAdr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"Point('r','s')":rec:- 
 -- after:A.loadAdr 
 mkValueProxy 123 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:P1 
 --  rec:  "P1 "E:  "print "
 -- INV:gen:E.loadArgs "print "
 -- INV:gen:after:E.loadArgs "print "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print ":Adr:off:2 s
 --  ize:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsVal
 --  ue:F:E:"print":rec:P1 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "P1" 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T
 --   originIsValue:F:E:"print":rec:P1 
 invoke print 125 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"print":rec:P1 nl; adrx: :Adr:off:-1 s
 --  ize:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVal
 --  ue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"print":rec:P1 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"print":rec:P1 
 -- OG:before:super.gen: "P1.move(2,2) "
 -- INV:gen: "P1.move(2,2)" 
 -- needorigin: "P1.move(2,2)" 
 -- needOrigin:E: "move(2,2)"  E.ATd: 
 --  move(dx: var integer,dy: var integer): 
 --     x := x + dx
 --     y := y + dy
 --  Ex: "move(2,2)" rec: "P1" 
 -- doNeedOrigin:Ex: "move(2,2) "originIsValueObj: true origin.isPrimitive: false 
 -- origin:isValueObj: "point "
 -- after:needOrigin: "move(2,2)" 
 -- doNeedOrigin:E: "move(2,2)" 
 -- computeAdrX:superAdj: 0 "P1.move(2,2)" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "P1" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "P1" rec: "P1" E: "move(2,2)" 
 --  A.E: "P1 "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T
 --   originIsValue:F:E:"P1":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "P1" rec: "P1" E: "move(2,2)" 
 --  rec.ATd: "P1: var Point('r','s')" rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  P1: var Point('r','s')
 --     P2: var Point(0,0)
 --     P3: var PositivePoint('x','y')
 --     P1.print
 --  
 --  recA: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"P1":rec:- 
 --  pRecA: none 
 -- pRec: "P1" rec: "P1" E: "move(2,2)" 
 --  false true 
 -- computeAdrX:before:rec:: "P1" 
 -- OI:invoke:before:ATdx.invoke: var P1 
 -- DI:invoke: "P1: var Point('r','s')" 
 -- isValueObj:isAdr: true objSize: 2  rec "P1 ",E: "move(2,2) ""ObjectInvocatio
 --  n_Function "E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T
 --   originIsValue:F:E:"move(2,2)":rec:P1 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"move(2,2)":rec:P1 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain "move(2,2)" cmpAndSwap: false rec: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"move(2,2)":rec:P1 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"move(2,2)":rec:P1 
 -- computeAdrX:after:rec.invoke: "P1" 
 -- computeAdrX:isLast:E:  "move(2,2) "
 -- originIsValueObj: 
 --  P1: var Point('r','s')
 --  P2: var Point(0,0)
 --  P3: var PositivePoint('x','y')
 --  P1.print
 --  
 -- rec = E: false 0 
 -- call:mkValueProxy false true 
 -- mkValueProxy:INV: "P1.move(2,2)" E: "move(2,2)" rec: "P1" E.ATd: 
 --  move(dx: var integer,dy: var integer): 
 --     x := x + dx
 --     y := y + dy
 --  
 -- CreateProxyW:E: "move(2,2) "E.ATd.origin.encOG:OGid "point "origin:descNo: 123 "t
 --  inyS ""P1.move(2,2)" 
 --  rec.ATd: "P1: var Point('r','s') "rec.ATd.newOff: 2 0 
 rdouble 0
 -- son: "P1" 
 -- son: "move(2,2)" 
 -- recOfE: "P1 "recOfE.ATd: "P1: var Point('r','s')" 
 -- first: "Point('r','s') "ObjectInvocation_Function first.origin.encOG: "point
 --  _foo "
 -- items:goOrigin:encOG: "point_foo "on: 1 isValueObj: false 
 --  origin: tinyS origin:isValueObj: false 
 rpushg point_foo$122 1
 -- after:Ey.loadOrigin: 
 -- Adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVal
 --  ue:F originIsValue:F:E:"Point('r','s')":rec:- 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"Point('r','s')":rec:- 
 -- Address:loadAdr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"Point('r','s')":rec:- 
 -- after:A.loadAdr 
 mkValueProxy 123 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"move(2,2)":rec:P1 
 --  rec:  "P1 "E:  "move(2,2) "
 -- INV:gen:E.loadArgs "move(2,2) "
 -- NonVirt: "move(2,2)" "ObjectInvocation_Function" ActArg: "2 "isValue: true formalArg: "dx: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "move(2,2) " isCompositeValueObj: false 
 -- OG:before:super.gen: "2 "
 -- INV:gen: "2" 
 -- needorigin: "2" 
 -- needOrigin:E: "2"  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "2" rec: "2" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "2" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "2 "E:  "2 "
 -- INV:gen:E.loadArgs "2 "
 -- INV:gen:after:E.loadArgs "2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "2 "
 pushc 2
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "dx: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "2 ":isBasicVal: true 
 -- case:B: 2 ObjectGenerator 1 1 1 false true 
 -- end:loadArgs:NonVirt: "move(2,2) "
 -- NonVirt: "move(2,2)" "ObjectInvocation_Function" ActArg: "2 "isValue: true formalArg: "dy: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "move(2,2) " isCompositeValueObj: false 
 -- OG:before:super.gen: "2 "
 -- INV:gen: "2" 
 -- needorigin: "2" 
 -- needOrigin:E: "2"  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "2" rec: "2" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "2" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "2 "E:  "2 "
 -- INV:gen:E.loadArgs "2 "
 -- INV:gen:after:E.loadArgs "2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "2 "
 pushc 2
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "dy: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "2 ":isBasicVal: true 
 -- case:B: 2 ObjectGenerator 1 1 1 false true 
 -- end:loadArgs:NonVirt: "move(2,2) "
 -- INV:gen:after:E.loadArgs "move(2,2) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Function "move(2,2) ":Adr:
 --  off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T orig
 --  inIsValue:F:E:"move(2,2)":rec:P1 
 -- OI:invoke:before:ATdx.invoke: pattern move(dx: var integer,dy: var intege
 --  r) 
 -- ptn:invoke: "move(dx: var integer,dy: var integer) "E: "move(2,2) "ptnKind:
 --   0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "P1" 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T
 --   originIsValue:F:E:"move(2,2)":rec:P1 
 invoke move 126 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"move(2,2)":rec:P1 nl; adrx: :Adr:off:
 --  -1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI
 --  sValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"move(2,2)":rec:P1 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"move(2,2)":rec:P1 
 -- AssignmentStatement:gen: "P2 := P1" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "P2 := P1" right.label: "ObjectGenerator ""P1" 
 -- OG:before:super.gen: "P1 "
 -- INV:gen: "P1" 
 -- needorigin: "P1" 
 -- needOrigin:E: "P1"  E.ATd: "P1: var Point('r','s')" Ex: "P1" rec: "P1" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "P1" 
 -- doNeedOrigin:E: "P1" 
 -- computeAdrX:superAdj: 0 "P1" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "P1" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "P1 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"P1":rec:- 
 --  rec:  "P1 "E:  "P1 "
 -- INV:gen:E.loadArgs "P1 "
 -- INV:gen:after:E.loadArgs "P1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "P1 ":Adr:off:2 size
 --  :0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:
 --  F:E:"P1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var P1 
 -- DI:invoke: "P1: var Point('r','s')" 
 -- isValueObj:isAdr: false objSize: 2  rec "P1 ",E: "P1 ""ObjectInvocation_Unary
 --   "E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T
 --   originIsValue:F:E:"P1":rec:P1 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"P1":rec:P1 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain "P1" cmpAndSwap: false rec: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"P1":rec:P1 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"P1":rec:P1 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"P1":rec:P1 
 -- right.super.ATd:not:none 
 -- right.super.ATd.OG.super.ATd:not:none 
 -- pushValue: B: off: 2 size: 2 descNo: 123 P1 
 pushvalue  off:2 size:2 descNo: 123
 -- after:pushValue:OIadrOff: 2 adr.off: 4 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T
 --   originIsValue:F:E:"P1":rec:P1 
 --  :Adr:off:4 size:2 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T
 --   originIsValue:F:E:"P2":rec:- 
 -- assign:adr.store:A: 
 -- vassign:A: "P2 "off: 4 size: 2 mode: 0 
 vassign  4 2 0
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "P2.print "
 -- INV:gen: "P2.print" 
 -- needorigin: "P2.print" 
 -- needOrigin:E: "print"  E.ATd: 
 --  print: 
 --     put(x)
 --     put(y)
 --  Ex: "print" rec: "P2" 
 -- doNeedOrigin:Ex: "print "originIsValueObj: true origin.isPrimitive: false 
 -- origin:isValueObj: "point "
 -- after:needOrigin: "print" 
 -- doNeedOrigin:E: "print" 
 -- computeAdrX:superAdj: 0 "P2.print" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "P2" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "P2" rec: "P2" E: "print" 
 --  A.E: "P2 "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T
 --   originIsValue:F:E:"P2":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "P2" rec: "P2" E: "print" 
 --  rec.ATd: "P2: var Point(0,0)" rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  P1: var Point('r','s')
 --     P2: var Point(0,0)
 --     P3: var PositivePoint('x','y')
 --     P1.print
 --  
 --  recA: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"P2":rec:- 
 --  pRecA: none 
 -- pRec: "P2" rec: "P2" E: "print" 
 --  false true 
 -- computeAdrX:before:rec:: "P2" 
 -- OI:invoke:before:ATdx.invoke: var P2 
 -- DI:invoke: "P2: var Point(0,0)" 
 -- isValueObj:isAdr: true objSize: 2  rec "P2 ",E: "print ""ObjectInvocation_Un
 --  ary "E.isCompositeValueObj: false 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T
 --   originIsValue:F:E:"print":rec:P2 
 -- Address:loadAdr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"print":rec:P2 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain "print" cmpAndSwap: false rec: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"print":rec:P2 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"print":rec:P2 
 -- computeAdrX:after:rec.invoke: "P2" 
 -- computeAdrX:isLast:E:  "print "
 -- originIsValueObj: 
 --  P1: var Point('r','s')
 --  P2: var Point(0,0)
 --  P3: var PositivePoint('x','y')
 --  P1.print
 --  
 -- rec = E: false 0 
 -- call:mkValueProxy false true 
 -- mkValueProxy:INV: "P2.print" E: "print" rec: "P2" E.ATd: 
 --  print: 
 --     put(x)
 --     put(y)
 --  
 -- CreateProxyW:E: "print "E.ATd.origin.encOG:OGid "point "origin:descNo: 123 "ti
 --  nyS ""P2.print" 
 --  rec.ATd: "P2: var Point(0,0) "rec.ATd.newOff: 4 0 
 rdouble 0
 -- son: "P2" 
 -- son: "print" 
 -- recOfE: "P2 "recOfE.ATd: "P2: var Point(0,0)" 
 -- first: "Point(0,0) "ObjectInvocation_Function first.origin.encOG: "point_foo
 --   "
 -- items:goOrigin:encOG: "point_foo "on: 1 isValueObj: false 
 --  origin: tinyS origin:isValueObj: false 
 rpushg point_foo$122 1
 -- after:Ey.loadOrigin: 
 -- Adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVal
 --  ue:F originIsValue:F:E:"Point(0,0)":rec:- 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"Point(0,0)":rec:- 
 -- Address:loadAdr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"Point(0,0)":rec:- 
 -- after:A.loadAdr 
 mkValueProxy 123 3
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:P2 
 --  rec:  "P2 "E:  "print "
 -- INV:gen:E.loadArgs "print "
 -- INV:gen:after:E.loadArgs "print "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print ":Adr:off:4 s
 --  ize:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsVal
 --  ue:F:E:"print":rec:P2 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "P2" 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T
 --   originIsValue:F:E:"print":rec:P2 
 invoke print 125 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"print":rec:P2 nl; adrx: :Adr:off:-1 s
 --  ize:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVal
 --  ue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"print":rec:P2 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"print":rec:P2 
 -- OG:before:super.gen: "P3.check "
 -- INV:gen: "P3.check" 
 -- needorigin: "P3.check" 
 -- needOrigin:E: "check"  E.ATd: 
 --  check::< 
 --     print
 --  Ex: "check" rec: "P3" 
 -- doNeedOrigin:Ex: "check "originIsValueObj: true origin.isPrimitive: false 
 -- origin:isValueObj: "PositivePoint "
 -- after:needOrigin: "check" 
 -- doNeedOrigin:E: "check" 
 -- computeAdrX:superAdj: 0 "P3.check" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "P3" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "P3" rec: "P3" E: "check" 
 --  A.E: "P3 "
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T
 --   originIsValue:F:E:"P3":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "P3" rec: "P3" E: "check" 
 --  rec.ATd: "P3: var PositivePoint('x','y')" rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  P1: var Point('r','s')
 --     P2: var Point(0,0)
 --     P3: var PositivePoint('x','y')
 --     P1.print
 --  
 --  recA: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"P3":rec:- 
 --  pRecA: none 
 -- pRec: "P3" rec: "P3" E: "check" 
 --  false true 
 -- computeAdrX:before:rec:: "P3" 
 -- OI:invoke:before:ATdx.invoke: var P3 
 -- DI:invoke: "P3: var PositivePoint('x','y')" 
 -- isValueObj:isAdr: true objSize: 2  rec "P3 ",E: "check ""ObjectInvocation_Un
 --  ary "E.isCompositeValueObj: false 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T
 --   originIsValue:F:E:"check":rec:P3 
 -- Address:loadAdr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"check":rec:P3 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain "check" cmpAndSwap: false rec: 
 -- OI:invoke:V: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"check":rec:P3 
 -- OI:invoke:X: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"check":rec:P3 
 -- computeAdrX:after:rec.invoke: "P3" 
 -- computeAdrX:isLast:E:  "check "
 -- originIsValueObj: 
 --  P1: var Point('r','s')
 --  P2: var Point(0,0)
 --  P3: var PositivePoint('x','y')
 --  P1.print
 --  
 -- rec = E: false 0 
 -- call:mkValueProxy false true 
 -- mkValueProxy:INV: "P3.check" E: "check" rec: "P3" E.ATd: 
 --  check::< 
 --     print
 --  
 -- CreateProxyW:E: "check "E.ATd.origin.encOG:OGid "PositivePoint "origin:desc
 --  No: 124 "tinyS ""P3.check" 
 --  rec.ATd: "P3: var PositivePoint('x','y') "rec.ATd.newOff: 6 0 
 rdouble 0
 -- son: "P3" 
 -- son: "check" 
 -- recOfE: "P3 "recOfE.ATd: "P3: var PositivePoint('x','y')" 
 -- first: "PositivePoint('x','y') "ObjectInvocation_Function first.origin.enc
 --  OG: "point_foo "
 -- items:goOrigin:encOG: "point_foo "on: 1 isValueObj: false 
 --  origin: tinyS origin:isValueObj: false 
 rpushg point_foo$122 1
 -- after:Ey.loadOrigin: 
 -- Adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVal
 --  ue:F originIsValue:F:E:"PositivePoint('x','y')":rec:- 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"PositivePoint('x','y')":rec:- 
 -- Address:loadAdr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"PositivePoint('x','y')":rec:- 
 -- after:A.loadAdr 
 mkValueProxy 124 5
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:6 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"check":rec:P3 
 --  rec:  "P3 "E:  "check "
 -- INV:gen:E.loadArgs "check "
 -- INV:gen:after:E.loadArgs "check "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "check ":Adr:off:6 s
 --  ize:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsVal
 --  ue:F:E:"check":rec:P3 
 -- OI:invoke:before:ATdx.invoke: pattern check 
 -- ptn:invoke: "check "E: "check "ptnKind: 2 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 2 staticOff: 0 rec: "P3" 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T
 --   originIsValue:F:E:"check":rec:P3 
 invoke check 128 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- OI:invoke:V: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"check":rec:P3 nl; adrx: :Adr:off:-1 s
 --  ize:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVal
 --  ue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"check":rec:P3 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 6 
 -- OG:gen:end: OIadr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"check":rec:P3 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:7 isIndexed:0

 CLASS point 123 0 tinyS 103 isValueObj
 pushThis 
 vstoreg integer$5 2
 pushThis 
 vstoreg integer$5 1
 mvStack 
 rtnAlloc 1
DO:
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS check 127 1 point 123
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(check) "
 -- INV:gen: "inner(check)" 
 -- needorigin: "inner(check)" 
 -- needOrigin:E: "inner(check)"  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(check)" rec: "inner(check)" 
 -- doNeedOrigin:Ex: "inner(check) "originIsValueObj: false origin.isPrimitive
 --  : false 
 -- KUK 
 -- after:needOrigin: "inner(check)" 
 -- doNeedOrigin:E: "inner(check)" 
 -- computeAdrX:superAdj: 0 "inner(check)" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(check)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(check) "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(check)":rec:-
 --   
 --  rec:  "inner(check) "E:  "inner(check) "
 -- INV:gen:E.loadArgs "inner(check) "
 -- INV:gen:after:E.loadArgs "inner(check) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(check) ":Ad
 --  r:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F or
 --  iginIsValue:F:E:"inner(check)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(check) "ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"inner(check)":rec:inner(check) 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"inner(check)":rec:inner(check) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"inner(check)":rec:inner(check) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS PositivePoint 124 0 tinyS 103 isValueObj
 -- vdtTableCopy: I:1:123 V:2:0 V:3:0 V:4:127
 -- super point
 pushThis 
 vstoreg integer$5 2
 pushThis 
 vstoreg integer$5 1
 rtnAlloc 1
 toSuper 123
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS check 128 1 PositivePoint 124
 -- vdtTableCopy: I:1:127 I:2:0
 tstOriginIsNone 
 rstore  1 origin
 -- super check
 pushThis 
 rpushg iOrigin 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 rtnAlloc 1
 toSuper 127
DO:
 mvStack 
 L1:
 -- OG:before:super.gen: "print "
 -- INV:gen: "print" 
 -- needorigin: "print" 
 -- needOrigin:E: "print"  E.ATd: 
 --  print: 
 --     put(x)
 --     put(y)
 --  Ex: "print" rec: "print" 
 -- doNeedOrigin:Ex: "print "originIsValueObj: true origin.isPrimitive: false 
 -- origin:isValueObj: "point "
 -- after:needOrigin: "print" 
 -- doNeedOrigin:E: "print" 
 -- computeAdrX:superAdj: 0 "print" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "print" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "check "on: 1 isValueObj: false 
 --  origin: PositivePoint origin:isValueObj: true 
 rpushg check$128 1
 -- computeAdrX:isLast:E:  "print "
 -- originIsValueObj: "print" 
 -- rec = E: true 1 
 -- no:call:mkValueProxy true true "print ""print "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:T:E:"print":rec:- 
 --  rec:  "print "E:  "print "
 -- INV:gen:E.loadArgs "print "
 -- INV:gen:after:E.loadArgs "print "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print ":Adr:off:0 s
 --  ize:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVal
 --  ue:T:E:"print":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "print" 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:T:E:"print":rec:print 
 invoke print 125 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:T:E:"print":rec:print nl; adrx: :Adr:off:-
 --  1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIs
 --  Value:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:T:E:"print":rec:print 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:T:E:"print":rec:print 
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0

 CLASS print 125 1 point 123
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "put(x) "
 -- INV:gen: "put(x)" 
 -- needorigin: "put(x)" 
 -- needOrigin:E: "put(x)"  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put(x)" rec: "put(x)" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put(x)" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put(x) "E:  "put(x) "
 -- INV:gen:E.loadArgs "put(x) "
 -- NonVirt: "put(x)" "ObjectInvocation_KeyWord" ActArg: "x "isValue: false formalArg: "in ch: val char" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(x) " isCompositeValueObj: false 
 -- OG:before:super.gen: "x "
 -- INV:gen: "x" 
 -- needorigin: "x" 
 -- needOrigin:E: "x"  E.ATd: "x: var integer" Ex: "x" rec: "x" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "x" 
 -- doNeedOrigin:E: "x" 
 -- computeAdrX:superAdj: 0 "x" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "x" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "print "on: 1 isValueObj: false 
 --  origin: point origin:isValueObj: true 
 rpushg print$125 1
 -- computeAdrX:isLast:E:  "x "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:1 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:T:E:"x":rec:- 
 --  rec:  "x "E:  "x "
 -- INV:gen:E.loadArgs "x "
 -- INV:gen:after:E.loadArgs "x "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "x ":Adr:off:1 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T
 --  :E:"x":rec:- 
 -- OI:invoke:before:ATdx.invoke: var x 
 -- DI:invoke: "x: var integer" 
 -- load: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:T:E:"x":rec:x isNotRemote: true 
 vpushg 1 point$123
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:T:E:"x":rec:x 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:T:E:"x":rec:x 
 -- INV:gen:end:off: 1 
 -- OG:gen:end: OIadr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:T:E:"x":rec:x 
 -- actualArg:isPtn: false formalArg:isPtn: "in ch: val char ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "x ":isBasicVal: true 
 -- case:B: x ObjectGenerator 3 0 1 false false 
 -- end:loadArgs:NonVirt: "put(x) "
 -- INV:gen:after:E.loadArgs "put(x) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(x) "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put(x) "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- OG:before:super.gen: "put(y) "
 -- INV:gen: "put(y)" 
 -- needorigin: "put(y)" 
 -- needOrigin:E: "put(y)"  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put(y)" rec: "put(y)" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put(y)" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put(y) "E:  "put(y) "
 -- INV:gen:E.loadArgs "put(y) "
 -- NonVirt: "put(y)" "ObjectInvocation_KeyWord" ActArg: "y "isValue: false formalArg: "in ch: val char" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(y) " isCompositeValueObj: false 
 -- OG:before:super.gen: "y "
 -- INV:gen: "y" 
 -- needorigin: "y" 
 -- needOrigin:E: "y"  E.ATd: "y: var integer" Ex: "y" rec: "y" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "y" 
 -- doNeedOrigin:E: "y" 
 -- computeAdrX:superAdj: 0 "y" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "y" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "print "on: 1 isValueObj: false 
 --  origin: point origin:isValueObj: true 
 rpushg print$125 1
 -- computeAdrX:isLast:E:  "y "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:T:E:"y":rec:- 
 --  rec:  "y "E:  "y "
 -- INV:gen:E.loadArgs "y "
 -- INV:gen:after:E.loadArgs "y "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "y ":Adr:off:2 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T
 --  :E:"y":rec:- 
 -- OI:invoke:before:ATdx.invoke: var y 
 -- DI:invoke: "y: var integer" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:T:E:"y":rec:y isNotRemote: true 
 vpushg 2 point$123
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:T:E:"y":rec:y 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:T:E:"y":rec:y 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:T:E:"y":rec:y 
 -- actualArg:isPtn: false formalArg:isPtn: "in ch: val char ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "y ":isBasicVal: true 
 -- case:B: y ObjectGenerator 3 0 1 false false 
 -- end:loadArgs:NonVirt: "put(y) "
 -- INV:gen:after:E.loadArgs "put(y) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(y) "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put(y) "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS move 126 1 point 123
 pushThis 
 storeg integer$5 3
 pushThis 
 storeg integer$5 2
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "x := x + dx" 
 pushThis 
 -- items:goOrigin:encOG: "move "on: 1 isValueObj: false 
 --  origin: point origin:isValueObj: true 
 rpushg move$126 1
 -- AssignmentStatement:gen: 
 --  "x := x + dx" right.label: "ObjectGenerator ""x + dx" 
 -- OG:before:super.gen: "x + dx "
 -- INV:gen: "x + dx" 
 -- needorigin: "x + dx" 
 -- needOrigin:E: "x + dx"  E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  Ex: "x + dx" rec: "x + dx" 
 -- doNeedOrigin:Ex: "x + dx "originIsValueObj: true origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "x + dx" 
 -- doNeedOrigin:E: "x + dx" 
 -- computeAdrX:superAdj: 0 "x + dx" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "x + dx" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "x + dx "superAdj: 0 
 -- computeAdrX:isLast:E:  "x + dx "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "x + dx "E:  "x + dx "
 -- INV:gen:E.loadArgs "x + dx "
 -- BinaryExp:loadArgs: "x + dx" superAdj: 0 
 -- INV:gen: "x" 
 -- needorigin: "x" 
 -- needOrigin:E: "x"  E.ATd: "x: var integer" Ex: "x" rec: "x" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "x" 
 -- doNeedOrigin:E: "x" 
 -- computeAdrX:superAdj: 0 "x" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "x" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "move "on: 1 isValueObj: false 
 --  origin: point origin:isValueObj: true 
 rpushg move$126 1
 -- computeAdrX:isLast:E:  "x "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:1 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:T:E:"x":rec:- 
 --  rec:  "x "E:  "x "
 -- INV:gen:E.loadArgs "x "
 -- INV:gen:after:E.loadArgs "x "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "x ":Adr:off:1 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T
 --  :E:"x":rec:- 
 -- OI:invoke:before:ATdx.invoke: var x 
 -- DI:invoke: "x: var integer" 
 -- load: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:T:E:"x":rec:x isNotRemote: true 
 vpushg 1 point$123
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:T:E:"x":rec:x 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:T:E:"x":rec:x 
 -- INV:gen:end:off: 1 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:1 size:0 isFloat:F isUnit
 --  Val:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"x":rec:x 
 -- NonVirt: "+ dx" "ObjectInvocation_Binary" ActArg: "dx "isValue: false formalArg: "in V: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ dx " isCompositeValueObj: false 
 -- OG:before:super.gen: "dx "
 -- INV:gen: "dx" 
 -- needorigin: "dx" 
 -- needOrigin:E: "dx"  E.ATd: "dx: var integer" Ex: "dx" rec: "dx" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "dx" 
 -- doNeedOrigin:E: "dx" 
 -- computeAdrX:superAdj: 0 "dx" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "dx" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "dx "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"dx":rec:- 
 --  rec:  "dx "E:  "dx "
 -- INV:gen:E.loadArgs "dx "
 -- INV:gen:after:E.loadArgs "dx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "dx ":Adr:off:2 size
 --  :0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:
 --  F:E:"dx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var dx 
 -- DI:invoke: "dx: var integer" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"dx":rec:dx isNotRemote: true 
 pushg 2 move$126
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"dx":rec:dx 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"dx":rec:dx 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"dx":rec:dx 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "dx ":isBasicVal: true 
 -- case:B: dx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "+ dx "
 -- BinaryExp:loadArgs:end: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj
 --  :0 isUnique:F isValue:T originIsValue:T:E:"x":rec:x 
 -- INV:gen:after:E.loadArgs "x + dx "
 --  OIadr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:T originIsValue:T:E:"x":rec:x 
 -- IV:E.invoke:useRtnVal: true E: BinOp "x + dx ":Adr:off:1 size:0 isFloat:F 
 --  isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"x":rec:x
 --   
 -- BinaryExp:invoke: "x "rec: "x + dx "
 -- M: "+ dx ":Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F i
 --  sValue:T originIsValue:T:E:"x":rec:x 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- ptn:invoke: "+   "E: "+ dx "ptnKind: 0 useRtnV: true 
 plus
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:T:E:"+ dx":rec:x nl; adrx: :Adr:off:0 size
 --  :0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:
 --  F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:T:E:"+ dx":rec:x 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 vstoreg  1
 -- assign:adr.store:B: 
 -- AssignmentStatement:gen: "y := y + dy" 
 pushThis 
 -- items:goOrigin:encOG: "move "on: 1 isValueObj: false 
 --  origin: point origin:isValueObj: true 
 rpushg move$126 1
 -- AssignmentStatement:gen: 
 --  "y := y + dy" right.label: "ObjectGenerator ""y + dy" 
 -- OG:before:super.gen: "y + dy "
 -- INV:gen: "y + dy" 
 -- needorigin: "y + dy" 
 -- needOrigin:E: "y + dy"  E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  Ex: "y + dy" rec: "y + dy" 
 -- doNeedOrigin:Ex: "y + dy "originIsValueObj: true origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "y + dy" 
 -- doNeedOrigin:E: "y + dy" 
 -- computeAdrX:superAdj: 0 "y + dy" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "y + dy" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "y + dy "superAdj: 0 
 -- computeAdrX:isLast:E:  "y + dy "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "y + dy "E:  "y + dy "
 -- INV:gen:E.loadArgs "y + dy "
 -- BinaryExp:loadArgs: "y + dy" superAdj: 0 
 -- INV:gen: "y" 
 -- needorigin: "y" 
 -- needOrigin:E: "y"  E.ATd: "y: var integer" Ex: "y" rec: "y" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "y" 
 -- doNeedOrigin:E: "y" 
 -- computeAdrX:superAdj: 0 "y" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "y" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "move "on: 1 isValueObj: false 
 --  origin: point origin:isValueObj: true 
 rpushg move$126 1
 -- computeAdrX:isLast:E:  "y "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:T:E:"y":rec:- 
 --  rec:  "y "E:  "y "
 -- INV:gen:E.loadArgs "y "
 -- INV:gen:after:E.loadArgs "y "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "y ":Adr:off:2 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T
 --  :E:"y":rec:- 
 -- OI:invoke:before:ATdx.invoke: var y 
 -- DI:invoke: "y: var integer" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:T:E:"y":rec:y isNotRemote: true 
 vpushg 2 point$123
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:T:E:"y":rec:y 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:T:E:"y":rec:y 
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:2 size:0 isFloat:F isUnit
 --  Val:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"y":rec:y 
 -- NonVirt: "+ dy" "ObjectInvocation_Binary" ActArg: "dy "isValue: false formalArg: "in V: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ dy " isCompositeValueObj: false 
 -- OG:before:super.gen: "dy "
 -- INV:gen: "dy" 
 -- needorigin: "dy" 
 -- needOrigin:E: "dy"  E.ATd: "dy: var integer" Ex: "dy" rec: "dy" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "dy" 
 -- doNeedOrigin:E: "dy" 
 -- computeAdrX:superAdj: 0 "dy" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "dy" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "dy "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"dy":rec:- 
 --  rec:  "dy "E:  "dy "
 -- INV:gen:E.loadArgs "dy "
 -- INV:gen:after:E.loadArgs "dy "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "dy ":Adr:off:3 size
 --  :0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:
 --  F:E:"dy":rec:- 
 -- OI:invoke:before:ATdx.invoke: var dy 
 -- DI:invoke: "dy: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"dy":rec:dy isNotRemote: true 
 pushg 3 move$126
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"dy":rec:dy 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"dy":rec:dy 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"dy":rec:dy 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "dy ":isBasicVal: true 
 -- case:B: dy ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "+ dy "
 -- BinaryExp:loadArgs:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj
 --  :0 isUnique:F isValue:T originIsValue:T:E:"y":rec:y 
 -- INV:gen:after:E.loadArgs "y + dy "
 --  OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:T originIsValue:T:E:"y":rec:y 
 -- IV:E.invoke:useRtnVal: true E: BinOp "y + dy ":Adr:off:2 size:0 isFloat:F 
 --  isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"y":rec:y
 --   
 -- BinaryExp:invoke: "y "rec: "y + dy "
 -- M: "+ dy ":Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F i
 --  sValue:T originIsValue:T:E:"y":rec:y 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- ptn:invoke: "+   "E: "+ dy "ptnKind: 0 useRtnV: true 
 plus
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:T:E:"+ dy":rec:y nl; adrx: :Adr:off:0 size
 --  :0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:
 --  F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:T:E:"+ dy":rec:y 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 vstoreg  2
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS newline 129 0 BETA 2
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "put(10) "
 -- INV:gen: "put(10)" 
 -- needorigin: "put(10)" 
 -- needOrigin:E: "put(10)"  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put(10)" rec: "put(10)" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put(10)" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put(10) "E:  "put(10) "
 -- INV:gen:E.loadArgs "put(10) "
 -- NonVirt: "put(10)" "ObjectInvocation_KeyWord" ActArg: "10 "isValue: true formalArg: "in ch: val char" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(10) " isCompositeValueObj: false 
 -- OG:before:super.gen: "10 "
 -- INV:gen: "10" 
 -- needorigin: "10" 
 -- needOrigin:E: "10"  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "10" rec: "10" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "10" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "10 "E:  "10 "
 -- INV:gen:E.loadArgs "10 "
 -- INV:gen:after:E.loadArgs "10 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "10 "
 pushc 10
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "10 ":isBasicVal: true 
 -- case:B: 10 ObjectGenerator 3 1 1 false true 
 -- end:loadArgs:NonVirt: "put(10) "
 -- INV:gen:after:E.loadArgs "put(10) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(10) "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put(10) "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:0 isIndexed:0

 CLASS virt_foo 130 1 tinyS 103
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "R1: ref Record" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:gen: "R2: obj ShowRecord("CD")" DI:isConst: true :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  R2 
 -- DI:off: 3 this: "R2: obj ShowRecord("CD")" 
 --  
 -- OG:before:super.gen: "ShowRecord("CD") "
 -- INV:gen: "ShowRecord("CD")" 
 -- needorigin: "ShowRecord("CD")" 
 -- needOrigin:E: "ShowRecord("CD")"  E.ATd: 
 --  ShowRecord: Record
 --     show::< 
 --        print
 --  Ex: "ShowRecord("CD")" rec: "ShowRecord("CD")" 
 -- doNeedOrigin:Ex: "ShowRecord("CD") "originIsValueObj: false origin.isPrimi
 --  tive: false 
 -- KUK 
 -- after:needOrigin: "ShowRecord("CD")" 
 -- doNeedOrigin:E: "ShowRecord("CD")" 
 -- computeAdrX:superAdj: 0 "ShowRecord("CD")" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "ShowRecord("CD")" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "virt_foo "on: 1 isValueObj: false 
 --  origin: tinyS origin:isValueObj: false 
 rpushg virt_foo$130 1
 -- computeAdrX:isLast:E:  "ShowRecord("CD") "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"ShowRecord("CD")":r
 --  ec:- 
 --  rec:  "ShowRecord("CD") "E:  "ShowRecord("CD") "
 -- INV:gen:E.loadArgs "ShowRecord("CD") "
 -- NonVirt: "ShowRecord("CD")" "ObjectInvocation_KeyWord" ActArg: ""CD" "isValue: false formalArg: "S: var String" 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "ShowRecord("CD") " isCompositeValueObj: false 
 -- OG:before:super.gen: ""CD" "
 -- INV:gen: ""CD"" 
 -- needorigin: ""CD"" 
 -- needOrigin:E: ""CD""  E.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 --  Ex: ""CD"" rec: ""CD"" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 --  
 -- after:needOrigin: ""CD"" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  ""CD" "E:  ""CD" "
 -- INV:gen:E.loadArgs ""CD" "
 -- INV:gen:after:E.loadArgs ""CD" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: String: ""CD" "
 pushText "CD"
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "S: var String ":isBasicVal: false :
 --  valueObj: false 
 --  :actArg: ""CD" ":isBasicVal: false 
 -- case:B: "CD" ObjectGenerator 5 5 5 false false 
 -- end:loadArgs:NonVirt: "ShowRecord("CD") "
 -- INV:gen:after:E.loadArgs "ShowRecord("CD") "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "ShowRecord("CD") ":
 --  Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F 
 --  originIsValue:F:E:"ShowRecord("CD")":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern ShowRecord 
 -- ptn:invoke: "ShowRecord "E: "ShowRecord("CD") "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 3 rec: "ShowRecord("CD")" 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"ShowRecord("CD")":rec:ShowRecord("CD") 
 invoke ShowRecord 131 3 1
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"ShowRecord("CD")":rec:ShowRecord("C
 --  D") nl; adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUniqu
 --  e:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"ShowRecord("CD")":rec:ShowRecord("C
 --  D") 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"ShowRecord("CD")":rec:ShowRecord("
 --  CD") 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "R1 := ShowRecord("AB")" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "R1 := ShowRecord("AB")" right.label: "ObjectGenerator ""ShowRecord("AB")" 
 -- OG:before:super.gen: "ShowRecord("AB") "
 -- INV:gen: "ShowRecord("AB")" 
 -- needorigin: "ShowRecord("AB")" 
 -- needOrigin:E: "ShowRecord("AB")"  E.ATd: 
 --  ShowRecord: Record
 --     show::< 
 --        print
 --  Ex: "ShowRecord("AB")" rec: "ShowRecord("AB")" 
 -- doNeedOrigin:Ex: "ShowRecord("AB") "originIsValueObj: false origin.isPrimi
 --  tive: false 
 -- KUK 
 -- after:needOrigin: "ShowRecord("AB")" 
 -- doNeedOrigin:E: "ShowRecord("AB")" 
 -- computeAdrX:superAdj: 0 "ShowRecord("AB")" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "ShowRecord("AB")" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "virt_foo "on: 1 isValueObj: false 
 --  origin: tinyS origin:isValueObj: false 
 rpushg virt_foo$130 1
 -- computeAdrX:isLast:E:  "ShowRecord("AB") "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"ShowRecord("AB")":r
 --  ec:- 
 --  rec:  "ShowRecord("AB") "E:  "ShowRecord("AB") "
 -- INV:gen:E.loadArgs "ShowRecord("AB") "
 -- NonVirt: "ShowRecord("AB")" "ObjectInvocation_KeyWord" ActArg: ""AB" "isValue: false formalArg: "S: var String" 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "ShowRecord("AB") " isCompositeValueObj: false 
 -- OG:before:super.gen: ""AB" "
 -- INV:gen: ""AB"" 
 -- needorigin: ""AB"" 
 -- needOrigin:E: ""AB""  E.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 --  Ex: ""AB"" rec: ""AB"" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 --  
 -- after:needOrigin: ""AB"" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  ""AB" "E:  ""AB" "
 -- INV:gen:E.loadArgs ""AB" "
 -- INV:gen:after:E.loadArgs ""AB" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: String: ""AB" "
 pushText "AB"
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "S: var String ":isBasicVal: false :
 --  valueObj: false 
 --  :actArg: ""AB" ":isBasicVal: false 
 -- case:B: "AB" ObjectGenerator 5 5 5 false false 
 -- end:loadArgs:NonVirt: "ShowRecord("AB") "
 -- INV:gen:after:E.loadArgs "ShowRecord("AB") "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "ShowRecord("AB") ":
 --  Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F 
 --  originIsValue:F:E:"ShowRecord("AB")":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern ShowRecord 
 -- ptn:invoke: "ShowRecord "E: "ShowRecord("AB") "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "ShowRecord("AB")" 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"ShowRecord("AB")":rec:ShowRecord("AB") 
 invoke ShowRecord 131 0 1
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"ShowRecord("AB")":rec:ShowRecord("A
 --  B") nl; adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUniqu
 --  e:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"ShowRecord("AB")":rec:ShowRecord("A
 --  B") 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"ShowRecord("AB")":rec:ShowRecord("
 --  AB") 
 -- assign:adr.store:A: 
 rswap 0
 rstoreg  EisNone 2
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "R1.show "
 -- INV:gen: "R1.show" 
 -- needorigin: "R1.show" 
 -- needOrigin:E: "show"  E.ATd: 
 --  show:< 
 --     inner(show)
 --  Ex: "show" rec: "R1" 
 -- doNeedOrigin:Ex: "show "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "show" 
 -- doNeedOrigin:E: "show" 
 -- computeAdrX:superAdj: 0 "R1.show" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "R1" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "R1" rec: "R1" E: "show" 
 --  A.E: none 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "R1" rec: "R1" E: "show" 
 --  rec.ATd: "R1: ref Record" rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  R1: ref Record
 --     R2: obj ShowRecord("CD")
 --     R1 := ShowRecord("AB")
 --     R1.show
 --  
 --  recA: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"show":rec:- 
 --  pRecA: none 
 -- pRec: "R1" rec: "R1" E: "show" 
 --  false false 
 -- computeAdrX:before:rec:: "R1" 
 -- OI:invoke:before:ATdx.invoke: ref R1 
 -- DI:invoke: "R1: ref Record" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"show":rec:R1 
 rpushg virt_foo$130 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"show":rec:R1 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"show":rec:R1 
 -- computeAdrX:after:rec.invoke: "R1" 
 -- computeAdrX:isLast:E:  "show "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"show":rec:R1 
 --  rec:  "R1 "E:  "show "
 -- INV:gen:E.loadArgs "show "
 -- INV:gen:after:E.loadArgs "show "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "show ":Adr:off:2 si
 --  ze:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValu
 --  e:F:E:"show":rec:R1 
 -- OI:invoke:before:ATdx.invoke: pattern show 
 -- ptn:invoke: "show "E: "show "ptnKind: 1 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 1 staticOff: 0 rec: "R1" 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"show":rec:R1 
 invokev 2 0 show$132 0
 -- GeneralPTN:invoke:after:pushOut: 
 rpop 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"show":rec:R1 nl; adrx: :Adr:off:-1 si
 --  ze:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValu
 --  e:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"show":rec:R1 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"show":rec:R1 
 -- OG:before:super.gen: "R2.show "
 -- INV:gen: "R2.show" 
 -- needorigin: "R2.show" 
 -- needOrigin:E: "show"  E.ATd: 
 --  show::< 
 --     print
 --  Ex: "show" rec: "R2" 
 -- doNeedOrigin:Ex: "show "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "show" 
 -- doNeedOrigin:E: "show" 
 -- computeAdrX:superAdj: 0 "R2.show" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "R2" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "R2" rec: "R2" E: "show" 
 --  A.E: none 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "R2" rec: "R2" E: "show" 
 --  rec.ATd: "R2: obj ShowRecord("CD")" rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  R1: ref Record
 --     R2: obj ShowRecord("CD")
 --     R1 := ShowRecord("AB")
 --     R1.show
 --  
 --  recA: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"show":rec:- 
 --  pRecA: none 
 -- pRec: "R2" rec: "R2" E: "show" 
 --  false false 
 -- computeAdrX:before:rec:: "R2" 
 -- OI:invoke:before:ATdx.invoke: obj R2 
 -- DI:invoke: "R2: obj ShowRecord("CD")" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"show":rec:R2 
 rpushg virt_foo$130 3
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"show":rec:R2 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"show":rec:R2 
 -- computeAdrX:after:rec.invoke: "R2" 
 -- computeAdrX:isLast:E:  "show "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"show":rec:R2 
 --  rec:  "R2 "E:  "show "
 -- INV:gen:E.loadArgs "show "
 -- INV:gen:after:E.loadArgs "show "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "show ":Adr:off:3 si
 --  ze:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValu
 --  e:F:E:"show":rec:R2 
 -- OI:invoke:before:ATdx.invoke: pattern show 
 -- ptn:invoke: "show "E: "show "ptnKind: 2 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 2 staticOff: 0 rec: "R2" 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"show":rec:R2 
 invoke show 133 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"show":rec:R2 nl; adrx: :Adr:off:-1 si
 --  ze:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValu
 --  e:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"show":rec:R2 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"show":rec:R2 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS ShowRecord 131 1 tinyS 103
 -- vdtTableCopy: I:1:120 V:2:132
 rShiftUp  1
 tstOriginIsNone 
 rstore  1 origin
 -- super Record
 -- computeAdrX:superAdj: 1 "Record" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Record" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 rpushg tinyS$103 1
 -- computeAdrX:isLast:E:  "Record "
 rShiftDown  1
 pushThis 
 rstoreg  S 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 rtnAlloc 1
 toSuper 120
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS show 133 1 ShowRecord 131
 -- vdtTableCopy: I:1:132 I:2:0
 tstOriginIsNone 
 rstore  1 origin
 -- super show
 pushThis 
 rpushg iOrigin 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 rtnAlloc 1
 toSuper 132
DO:
 mvStack 
 L1:
 -- OG:before:super.gen: "print "
 -- INV:gen: "print" 
 -- needorigin: "print" 
 -- needOrigin:E: "print"  E.ATd: 
 --  print: 
 --     S.print
 --  Ex: "print" rec: "print" 
 -- doNeedOrigin:Ex: "print "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "print" 
 -- doNeedOrigin:E: "print" 
 -- computeAdrX:superAdj: 0 "print" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "print" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "show "on: 1 isValueObj: false 
 --  origin: ShowRecord origin:isValueObj: false 
 rpushg show$133 1
 -- computeAdrX:isLast:E:  "print "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:- 
 --  rec:  "print "E:  "print "
 -- INV:gen:E.loadArgs "print "
 -- INV:gen:after:E.loadArgs "print "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print ":Adr:off:0 s
 --  ize:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVal
 --  ue:F:E:"print":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "print" 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"print":rec:print 
 invoke print 121 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"print":rec:print nl; adrx: :Adr:off:-
 --  1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIs
 --  Value:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"print":rec:print 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"print":rec:print 
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $135 135 1 tinyS 103
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "put('Q') "
 -- INV:gen: "put('Q')" 
 -- needorigin: "put('Q')" 
 -- needOrigin:E: "put('Q')"  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put('Q')" rec: "put('Q')" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put('Q')" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put('Q') "E:  "put('Q') "
 -- INV:gen:E.loadArgs "put('Q') "
 -- NonVirt: "put('Q')" "ObjectInvocation_KeyWord" ActArg: "'Q' "isValue: true formalArg: "in ch: val char" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put('Q') " isCompositeValueObj: false 
 -- OG:before:super.gen: "'Q' "
 -- INV:gen: "'Q'" 
 -- needorigin: "'Q'" 
 -- needOrigin:E: "'Q'"  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  Ex: "'Q'" rec: "'Q'" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  
 -- after:needOrigin: "'Q'" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "'Q' "E:  "'Q' "
 -- INV:gen:E.loadArgs "'Q' "
 -- INV:gen:after:E.loadArgs "'Q' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "'Q' "
 pushc 81
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "'Q' ":isBasicVal: true 
 -- case:B: 'Q' ObjectGenerator 3 3 3 false true 
 -- end:loadArgs:NonVirt: "put('Q') "
 -- INV:gen:after:E.loadArgs "put('Q') "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put('Q') "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put('Q') "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $136 136 1 tinyS 103
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "put('E') "
 -- INV:gen: "put('E')" 
 -- needorigin: "put('E')" 
 -- needOrigin:E: "put('E')"  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put('E')" rec: "put('E')" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put('E')" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put('E') "E:  "put('E') "
 -- INV:gen:E.loadArgs "put('E') "
 -- NonVirt: "put('E')" "ObjectInvocation_KeyWord" ActArg: "'E' "isValue: true formalArg: "in ch: val char" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put('E') " isCompositeValueObj: false 
 -- OG:before:super.gen: "'E' "
 -- INV:gen: "'E'" 
 -- needorigin: "'E'" 
 -- needOrigin:E: "'E'"  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  Ex: "'E'" rec: "'E'" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  
 -- after:needOrigin: "'E'" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "'E' "E:  "'E' "
 -- INV:gen:E.loadArgs "'E' "
 -- INV:gen:after:E.loadArgs "'E' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "'E' "
 pushc 69
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "'E' ":isBasicVal: true 
 -- case:B: 'E' ObjectGenerator 3 3 3 false true 
 -- end:loadArgs:NonVirt: "put('E') "
 -- INV:gen:after:E.loadArgs "put('E') "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put('E') "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put('E') "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS string_foo_LE 137 1 tinyS 103
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "S1: var StringLib.String" DI:isConst: false :isBasicValue: false :primNo: 5 
 -- StringVar "S1: var StringLib.String "
 pushText ""
 pushThis 
 rstoreg  S1 2
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 -- DI:gen: "S2: obj "Hello"" DI:isConst: true :isBasicValue: false :primNo: 5 
 -- DI:add:BP3:  S2 
 -- OG:before:super.gen: ""Hello" "
 -- INV:gen: ""Hello"" 
 -- needorigin: ""Hello"" 
 -- needOrigin:E: ""Hello""  E.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 --  Ex: ""Hello"" rec: ""Hello"" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 --  
 -- after:needOrigin: ""Hello"" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  ""Hello" "E:  ""Hello" "
 -- INV:gen:E.loadArgs ""Hello" "
 -- INV:gen:after:E.loadArgs ""Hello" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: String: ""Hello" "
 pushText "Hello"
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 pushThis 
 rstoreg  string_foo_LE$137 3
   ;; vTop(0,0)=[] rTop(-2,1)=[]
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "S1 := "Hello"" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "S1 := "Hello"" right.label: "ObjectGenerator """Hello"" 
 -- OG:before:super.gen: ""Hello" "
 -- INV:gen: ""Hello"" 
 -- needorigin: ""Hello"" 
 -- needOrigin:E: ""Hello""  E.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 --  Ex: ""Hello"" rec: ""Hello"" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 --  
 -- after:needOrigin: ""Hello"" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  ""Hello" "E:  ""Hello" "
 -- INV:gen:E.loadArgs ""Hello" "
 -- INV:gen:after:E.loadArgs ""Hello" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: String: ""Hello" "
 pushText "Hello"
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 rswap 0
 rstoreg  EisNone 2
   ;; vTop(0,0)=[] rTop(-3,1)=[]
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "if (S1 <= S2) :then 
 --     put('F')
 --  :else 
 --     put('?') "
 -- INV:gen: 
 --  if (S1 <= S2) :then 
 --     put('F')
 --  :else 
 --     put('?')
 --  
 -- needorigin: 
 --  if (S1 <= S2) :then 
 --     put('F')
 --  :else 
 --     put('?')
 --  
 -- needOrigin:E: 
 --  if (S1 <= S2) :then 
 --     put('F')
 --  :else 
 --     put('?')
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (S1 <= S2) :then 
 --     put('F')
 --  :else 
 --     put('?')
 --  rec: 
 --  if (S1 <= S2) :then 
 --     put('F')
 -- \
 --   :else 
 --     put('?')
 --  
 -- Ex:loadOrign:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (S1 <= S2) :then 
 --     put('F')
 --  :else 
 --     put('?')
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "if (S1 <= S2) :then 
 --     put('F')
 --  :else 
 --     put('?') "E:  "if (S1 <= S2) :then 
 --     put('F')
 --  :else 
 --     put('?') "
 -- INV:gen:E.loadArgs "if (S1 <= S2) :then 
 --     put('F')
 --  :else 
 --     put('?') "
 -- INV:gen:after:E.loadArgs "if (S1 <= S2) :then 
 --     put('F')
 --  :else 
 --     put('?') "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThenElse "if (S1 <= S2) :then 
 --     put('F')
 --  :else 
 --     put('?') "
 -- OG:before:super.gen: "(S1 <= S2) "
 -- INV:gen: "(S1 <= S2)" 
 -- needorigin: "(S1 <= S2)" 
 -- needOrigin:E: "(S1 <= S2)"  E.ATd: 
 --  <=  :: 
 --     loop: obj 
 --        matchEq: 
 --           inx: var integer
 --  Ex: "(S1 <= S2)" rec: "(S1 <= S2)" 
 -- doNeedOrigin:Ex: "(S1 <= S2) "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(S1 <= S2)" 
 -- doNeedOrigin:E: "(S1 <= S2)" 
 -- computeAdrX:superAdj: 0 "(S1 <= S2)" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(S1 <= S2)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "S1 <= S2 "superAdj: 0 
 -- computeAdrX:isLast:E:  "S1 <= S2 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "S1 <= S2 "E:  "S1 <= S2 "
 -- INV:gen:E.loadArgs "S1 <= S2 "
 -- BinaryExp:loadArgs: "S1 <= S2" superAdj: 0 
 -- INV:gen: "S1" 
 -- needorigin: "S1" 
 -- needOrigin:E: "S1"  E.ATd: "S1: var StringLib.String" Ex: "S1" rec: "S1" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "S1" 
 -- doNeedOrigin:E: "S1" 
 -- computeAdrX:superAdj: 0 "S1" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "S1" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "S1 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "S1 "E:  "S1 "
 -- INV:gen:E.loadArgs "S1 "
 -- INV:gen:after:E.loadArgs "S1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "S1 ":Adr:off:2 size
 --  :0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:
 --  F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: var S1 
 -- DI:invoke: "S1: var StringLib.String" 
 -- >Object:unique: false 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"S1":rec:S1 isNotRemote: true 
 rpushg string_foo_LE$137 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"S1":rec:S1 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"S1":rec:S1 
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:2 size:0 isFloat:F isUnit
 --  Val:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"S1":rec:S1 
 -- NonVirt: "<= S2" "ObjectInvocation_Binary" ActArg: "S2 "isValue: false formalArg: "in Veq: var this(Value)" 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "<= S2 " isCompositeValueObj: true 
 -- OG:before:super.gen: "S2 "
 -- INV:gen: "S2" 
 -- needorigin: "S2" 
 -- needOrigin:E: "S2"  E.ATd: "S2: obj "Hello"" Ex: "S2" rec: "S2" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "S2" 
 -- doNeedOrigin:E: "S2" 
 -- computeAdrX:superAdj: 0 "S2" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "S2" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "S2 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "S2 "E:  "S2 "
 -- INV:gen:E.loadArgs "S2 "
 -- INV:gen:after:E.loadArgs "S2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "S2 ":Adr:off:3 size
 --  :0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:
 --  F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: obj S2 
 -- DI:invoke: "S2: obj "Hello"" 
 -- >Object:unique: false 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"S2":rec:S2 isNotRemote: true 
 rpushg string_foo_LE$137 3
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"S2":rec:S2 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"S2":rec:S2 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"S2":rec:S2 
 -- actualArg:isPtn: false formalArg:isPtn: "in Veq: var this(Value) ":isBasic
 --  Val: false :valueObj: true 
 --  :actArg: "S2 ":isBasicVal: false 
 -- case:B: S2 ObjectGenerator 18 0 5 true false 
 -- end:loadArgs:NonVirt: "<= S2 "
 -- BinaryExp:loadArgs:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj
 --  :0 isUnique:F isValue:F originIsValue:F:E:"S1":rec:S1 
 -- INV:gen:after:E.loadArgs "S1 <= S2 "
 --  OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"S1":rec:S1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "S1 <= S2 ":Adr:off:2 size:0 isFloat:
 --  F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"S1":re
 --  c:S1 
 -- BinaryExp:invoke: "S1 "rec: "S1 <= S2 "
 -- M: "<= S2 ":Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F 
 --  isValue:F originIsValue:F:E:"S1":rec:S1 
 -- OI:invoke:before:ATdx.invoke: pattern <=   
 -- ptn:invoke: "<=   "E: "<= S2 "ptnKind: 3 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 rec: "S1" 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"<= S2":rec:S1 
 invokev 3 0 <=$84 0
 -- global:pushOut: Beq off: 3 
 pushg 3 <=$84
 -- GeneralPTN:invoke:after:pushOut: 
 -- GeneralPTN:invoke:end: 3 :Adr:off:2 size:0 isFloat:F isUnitVal:F superA
 --  dj:0 isUnique:F isValue:F originIsValue:F:E:"<= S2":rec:S1 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"<= S2":rec:S1 nl; adrx: :Adr:off:3 si
 --  ze:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValu
 --  e:F:E:"<= S2":rec:S1 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"<= S2":rec:S1 
 --  adrx: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"<= S2":rec:S1 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  138   "$138 "
 invoke $138 138 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L5
 L4:
 pushThis 
 -- before objTmpStack:add:  139   "$139 "
 invoke $139 139 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 L5:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS $138 138 1 string_foo_LE 137
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "put('F') "
 -- INV:gen: "put('F')" 
 -- needorigin: "put('F')" 
 -- needOrigin:E: "put('F')"  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put('F')" rec: "put('F')" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put('F')" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put('F') "E:  "put('F') "
 -- INV:gen:E.loadArgs "put('F') "
 -- NonVirt: "put('F')" "ObjectInvocation_KeyWord" ActArg: "'F' "isValue: true formalArg: "in ch: val char" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put('F') " isCompositeValueObj: false 
 -- OG:before:super.gen: "'F' "
 -- INV:gen: "'F'" 
 -- needorigin: "'F'" 
 -- needOrigin:E: "'F'"  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  Ex: "'F'" rec: "'F'" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  
 -- after:needOrigin: "'F'" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "'F' "E:  "'F' "
 -- INV:gen:E.loadArgs "'F' "
 -- INV:gen:after:E.loadArgs "'F' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "'F' "
 pushc 70
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "'F' ":isBasicVal: true 
 -- case:B: 'F' ObjectGenerator 3 3 3 false true 
 -- end:loadArgs:NonVirt: "put('F') "
 -- INV:gen:after:E.loadArgs "put('F') "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put('F') "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put('F') "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $139 139 1 string_foo_LE 137
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "put('?') "
 -- INV:gen: "put('?')" 
 -- needorigin: "put('?')" 
 -- needOrigin:E: "put('?')"  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put('?')" rec: "put('?')" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put('?')" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put('?') "E:  "put('?') "
 -- INV:gen:E.loadArgs "put('?') "
 -- NonVirt: "put('?')" "ObjectInvocation_KeyWord" ActArg: "'?' "isValue: true formalArg: "in ch: val char" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put('?') " isCompositeValueObj: false 
 -- OG:before:super.gen: "'?' "
 -- INV:gen: "'?'" 
 -- needorigin: "'?'" 
 -- needOrigin:E: "'?'"  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  Ex: "'?'" rec: "'?'" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  
 -- after:needOrigin: "'?'" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "'?' "E:  "'?' "
 -- INV:gen:E.loadArgs "'?' "
 -- INV:gen:after:E.loadArgs "'?' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "'?' "
 pushc 63
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "'?' ":isBasicVal: true 
 -- case:B: '?' ObjectGenerator 3 3 3 false true 
 -- end:loadArgs:NonVirt: "put('?') "
 -- INV:gen:after:E.loadArgs "put('?') "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put('?') "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put('?') "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS I2F_foo 140 1 tinyS 103
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "x: var Float" DI:isConst: false :isBasicValue: true :primNo: 9 
 -- DI:add:BP1:  x 
 -- DI:gen: "i: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  i 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "X := 12" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "X := 12" right.label: "ObjectGenerator ""12" 
 -- OG:before:super.gen: "12 "
 -- INV:gen: "12" 
 -- needorigin: "12" 
 -- needOrigin:E: "12"  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "12" rec: "12" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "12" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "12 "E:  "12 "
 -- INV:gen:E.loadArgs "12 "
 -- INV:gen:after:E.loadArgs "12 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "12 "
 pushc 12
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 i2f
 -- assign:adr.store:A: 
 fstoreg 2 address:storeg
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "put(' ') "
 -- INV:gen: "put(' ')" 
 -- needorigin: "put(' ')" 
 -- needOrigin:E: "put(' ')"  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put(' ')" rec: "put(' ')" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put(' ')" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put(' ') "E:  "put(' ') "
 -- INV:gen:E.loadArgs "put(' ') "
 -- NonVirt: "put(' ')" "ObjectInvocation_KeyWord" ActArg: "' ' "isValue: true formalArg: "in ch: val char" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(' ') " isCompositeValueObj: false 
 -- OG:before:super.gen: "' ' "
 -- INV:gen: "' '" 
 -- needorigin: "' '" 
 -- needOrigin:E: "' '"  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  Ex: "' '" rec: "' '" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  
 -- after:needOrigin: "' '" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "' ' "E:  "' ' "
 -- INV:gen:E.loadArgs "' ' "
 -- INV:gen:after:E.loadArgs "' ' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "' ' "
 pushc 32
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "' ' ":isBasicVal: true 
 -- case:B: ' ' ObjectGenerator 3 3 3 false true 
 -- end:loadArgs:NonVirt: "put(' ') "
 -- INV:gen:after:E.loadArgs "put(' ') "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(' ') "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put(' ') "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- OG:before:super.gen: "putfloat(x) -- 12.0 "
 -- INV:gen: "putfloat(x) -- 12.0" 
 -- needorigin: "putfloat(x) -- 12.0" 
 -- needOrigin:E: "putfloat(x)"  E.ATd: 
 --  putFloat: 
 --     %basic 142
 --     in X: var Float
 --     out V: var integer
 --  Ex: "putfloat(x)" rec: "putfloat(x)" 
 -- doNeedOrigin:Ex: "putfloat(x) "originIsValueObj: false origin.isPrimitive:
 --   false 
 -- KUK 
 -- after:needOrigin: "putfloat(x)" 
 -- doNeedOrigin:E: "putfloat(x)" 
 -- computeAdrX:superAdj: 0 "putfloat(x) -- 12.0" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "putfloat(x)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "putfloat(x) "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putfloat(x)":rec:- 
 --  rec:  "putfloat(x) "E:  "putfloat(x) "
 -- INV:gen:E.loadArgs "putfloat(x) "
 -- NonVirt: "putfloat(x)" "ObjectInvocation_KeyWord" ActArg: "x "isValue: false formalArg: "in X: var Float" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "putfloat(x) " isCompositeValueObj: false 
 -- OG:before:super.gen: "x "
 -- INV:gen: "x" 
 -- needorigin: "x" 
 -- needOrigin:E: "x"  E.ATd: "x: var Float" Ex: "x" rec: "x" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "x" 
 -- doNeedOrigin:E: "x" 
 -- computeAdrX:superAdj: 0 "x" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "x" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "x "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:T isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"x":rec:- 
 --  rec:  "x "E:  "x "
 -- INV:gen:E.loadArgs "x "
 -- INV:gen:after:E.loadArgs "x "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "x ":Adr:off:2 size:
 --  0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"x":rec:- 
 -- OI:invoke:before:ATdx.invoke: var x 
 -- DI:invoke: "x: var Float" 
 -- load: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"x":rec:x isNotRemote: true 
 fpushg 2 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"x":rec:x 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"x":rec:x 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"x":rec:x 
 -- actualArg:isPtn: false formalArg:isPtn: "in X: var Float ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "x ":isBasicVal: true 
 -- case:B: x ObjectGenerator 9 0 9 false false 
 -- end:loadArgs:NonVirt: "putfloat(x) "
 -- INV:gen:after:E.loadArgs "putfloat(x) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "putfloat(x) ":Adr
 --  :off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori
 --  ginIsValue:F:E:"putfloat(x)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern putFloat 
 -- ptn:invoke: "putFloat "E: "putfloat(x) "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "putfloat(x)" 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"putfloat(x)":rec:putfloat(x) 
 %printf_prim 142
 vpop
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"putfloat(x)":rec:putfloat(x) nl; adr
 --  x: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue
 --  :F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"putfloat(x)":rec:putfloat(x) 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"putfloat(x)":rec:putfloat(x) 
 -- AssignmentStatement:gen: "i := 3.14" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "i := 3.14" right.label: "ObjectGenerator ""3.14" 
 -- OG:before:super.gen: "3.14 "
 -- INV:gen: "3.14" 
 -- needorigin: "3.14" 
 -- needOrigin:E: "3.14"  E.ATd: 
 --  float: Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var Float
 --  Ex: "3.14" rec: "3.14" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var Float
 --  
 -- after:needOrigin: "3.14" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "3.14 "E:  "3.14 "
 -- INV:gen:E.loadArgs "3.14 "
 -- INV:gen:after:E.loadArgs "3.14 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: FloatLiteral "3.14 "
 pushFloatConst 3.140000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 f2i
 -- assign:adr.store:A: 
 storeg I2F_foo$140 4
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "put(' ') "
 -- INV:gen: "put(' ')" 
 -- needorigin: "put(' ')" 
 -- needOrigin:E: "put(' ')"  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put(' ')" rec: "put(' ')" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put(' ')" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put(' ') "E:  "put(' ') "
 -- INV:gen:E.loadArgs "put(' ') "
 -- NonVirt: "put(' ')" "ObjectInvocation_KeyWord" ActArg: "' ' "isValue: true formalArg: "in ch: val char" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(' ') " isCompositeValueObj: false 
 -- OG:before:super.gen: "' ' "
 -- INV:gen: "' '" 
 -- needorigin: "' '" 
 -- needOrigin:E: "' '"  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  Ex: "' '" rec: "' '" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  
 -- after:needOrigin: "' '" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "' ' "E:  "' ' "
 -- INV:gen:E.loadArgs "' ' "
 -- INV:gen:after:E.loadArgs "' ' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "' ' "
 pushc 32
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "' ' ":isBasicVal: true 
 -- case:B: ' ' ObjectGenerator 3 3 3 false true 
 -- end:loadArgs:NonVirt: "put(' ') "
 -- INV:gen:after:E.loadArgs "put(' ') "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(' ') "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put(' ') "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- OG:before:super.gen: "putint(i) -- 3 "
 -- INV:gen: "putint(i) -- 3" 
 -- needorigin: "putint(i) -- 3" 
 -- needOrigin:E: "putint(i)"  E.ATd: 
 --  putint: 
 --     %globals
 --     in V: var integer
 --     D: obj Indexed(20,#integer)
 --  Ex: "putint(i)" rec: "putint(i)" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  %globals
 --     in V: var integer
 --     D: obj Indexed(20,#integer)
 --     L: var integer
 --  
 -- after:needOrigin: "putint(i)" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "putint(i) "E:  "putint(i) "
 -- INV:gen:E.loadArgs "putint(i) "
 -- NonVirt: "putint(i)" "ObjectInvocation_KeyWord" ActArg: "i "isValue: false formalArg: "in V: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "putint(i) " isCompositeValueObj: false 
 -- OG:before:super.gen: "i "
 -- INV:gen: "i" 
 -- needorigin: "i" 
 -- needOrigin:E: "i"  E.ATd: "i: var integer" Ex: "i" rec: "i" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "i" 
 -- doNeedOrigin:E: "i" 
 -- computeAdrX:superAdj: 0 "i" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "i" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "i "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 --  rec:  "i "E:  "i "
 -- INV:gen:E.loadArgs "i "
 -- INV:gen:after:E.loadArgs "i "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "i ":Adr:off:4 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"i":rec:- 
 -- OI:invoke:before:ATdx.invoke: var i 
 -- DI:invoke: "i: var integer" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"i":rec:i isNotRemote: true 
 pushg 4 I2F_foo$140
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "i ":isBasicVal: true 
 -- case:B: i ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "putint(i) "
 -- INV:gen:after:E.loadArgs "putint(i) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "putint(i) "
 -- OI:invoke:before:ATdx.invoke: pattern putint 
 -- ptn:invoke: "putint "E: "putint(i) "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "putint(i)" 
 --  adr:none 
 invoke putint 141 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: nl; adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:
 --  0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- AssignmentStatement:gen: "i := 19" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "i := 19" right.label: "ObjectGenerator ""19" 
 -- OG:before:super.gen: "19 "
 -- INV:gen: "19" 
 -- needorigin: "19" 
 -- needOrigin:E: "19"  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "19" rec: "19" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "19" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "19 "E:  "19 "
 -- INV:gen:E.loadArgs "19 "
 -- INV:gen:after:E.loadArgs "19 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "19 "
 pushc 19
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg I2F_foo$140 4
 -- assign:adr.store:B: 
 -- AssignmentStatement:gen: "x := i" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "x := i" right.label: "ObjectGenerator ""i" 
 -- OG:before:super.gen: "i "
 -- INV:gen: "i" 
 -- needorigin: "i" 
 -- needOrigin:E: "i"  E.ATd: "i: var integer" Ex: "i" rec: "i" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "i" 
 -- doNeedOrigin:E: "i" 
 -- computeAdrX:superAdj: 0 "i" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "i" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "i "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 --  rec:  "i "E:  "i "
 -- INV:gen:E.loadArgs "i "
 -- INV:gen:after:E.loadArgs "i "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "i ":Adr:off:4 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"i":rec:- 
 -- OI:invoke:before:ATdx.invoke: var i 
 -- DI:invoke: "i: var integer" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"i":rec:i isNotRemote: true 
 pushg 4 I2F_foo$140
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"i":rec:i 
 i2f
 -- assign:adr.store:A: 
 fstoreg 2 address:storeg
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "put(' ') "
 -- INV:gen: "put(' ')" 
 -- needorigin: "put(' ')" 
 -- needOrigin:E: "put(' ')"  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put(' ')" rec: "put(' ')" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put(' ')" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put(' ') "E:  "put(' ') "
 -- INV:gen:E.loadArgs "put(' ') "
 -- NonVirt: "put(' ')" "ObjectInvocation_KeyWord" ActArg: "' ' "isValue: true formalArg: "in ch: val char" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(' ') " isCompositeValueObj: false 
 -- OG:before:super.gen: "' ' "
 -- INV:gen: "' '" 
 -- needorigin: "' '" 
 -- needOrigin:E: "' '"  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  Ex: "' '" rec: "' '" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  
 -- after:needOrigin: "' '" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "' ' "E:  "' ' "
 -- INV:gen:E.loadArgs "' ' "
 -- INV:gen:after:E.loadArgs "' ' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "' ' "
 pushc 32
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "' ' ":isBasicVal: true 
 -- case:B: ' ' ObjectGenerator 3 3 3 false true 
 -- end:loadArgs:NonVirt: "put(' ') "
 -- INV:gen:after:E.loadArgs "put(' ') "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(' ') "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put(' ') "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- OG:before:super.gen: "putfloat(x) -- 19 "
 -- INV:gen: "putfloat(x) -- 19" 
 -- needorigin: "putfloat(x) -- 19" 
 -- needOrigin:E: "putfloat(x)"  E.ATd: 
 --  putFloat: 
 --     %basic 142
 --     in X: var Float
 --     out V: var integer
 --  Ex: "putfloat(x)" rec: "putfloat(x)" 
 -- doNeedOrigin:Ex: "putfloat(x) "originIsValueObj: false origin.isPrimitive:
 --   false 
 -- KUK 
 -- after:needOrigin: "putfloat(x)" 
 -- doNeedOrigin:E: "putfloat(x)" 
 -- computeAdrX:superAdj: 0 "putfloat(x) -- 19" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "putfloat(x)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "putfloat(x) "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putfloat(x)":rec:- 
 --  rec:  "putfloat(x) "E:  "putfloat(x) "
 -- INV:gen:E.loadArgs "putfloat(x) "
 -- NonVirt: "putfloat(x)" "ObjectInvocation_KeyWord" ActArg: "x "isValue: false formalArg: "in X: var Float" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "putfloat(x) " isCompositeValueObj: false 
 -- OG:before:super.gen: "x "
 -- INV:gen: "x" 
 -- needorigin: "x" 
 -- needOrigin:E: "x"  E.ATd: "x: var Float" Ex: "x" rec: "x" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "x" 
 -- doNeedOrigin:E: "x" 
 -- computeAdrX:superAdj: 0 "x" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "x" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "x "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:T isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"x":rec:- 
 --  rec:  "x "E:  "x "
 -- INV:gen:E.loadArgs "x "
 -- INV:gen:after:E.loadArgs "x "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "x ":Adr:off:2 size:
 --  0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"x":rec:- 
 -- OI:invoke:before:ATdx.invoke: var x 
 -- DI:invoke: "x: var Float" 
 -- load: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"x":rec:x isNotRemote: true 
 fpushg 2 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"x":rec:x 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"x":rec:x 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"x":rec:x 
 -- actualArg:isPtn: false formalArg:isPtn: "in X: var Float ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "x ":isBasicVal: true 
 -- case:B: x ObjectGenerator 9 0 9 false false 
 -- end:loadArgs:NonVirt: "putfloat(x) "
 -- INV:gen:after:E.loadArgs "putfloat(x) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "putfloat(x) ":Adr
 --  :off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori
 --  ginIsValue:F:E:"putfloat(x)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern putFloat 
 -- ptn:invoke: "putFloat "E: "putfloat(x) "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "putfloat(x)" 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"putfloat(x)":rec:putfloat(x) 
 %printf_prim 142
 vpop
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"putfloat(x)":rec:putfloat(x) nl; adr
 --  x: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue
 --  :F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"putfloat(x)":rec:putfloat(x) 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"putfloat(x)":rec:putfloat(x) 
 -- AssignmentStatement:gen: "x := 2.04" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "x := 2.04" right.label: "ObjectGenerator ""2.04" 
 -- OG:before:super.gen: "2.04 "
 -- INV:gen: "2.04" 
 -- needorigin: "2.04" 
 -- needOrigin:E: "2.04"  E.ATd: 
 --  float: Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var Float
 --  Ex: "2.04" rec: "2.04" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var Float
 --  
 -- after:needOrigin: "2.04" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "2.04 "E:  "2.04 "
 -- INV:gen:E.loadArgs "2.04 "
 -- INV:gen:after:E.loadArgs "2.04 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: FloatLiteral "2.04 "
 pushFloatConst 2.040000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 fstoreg 2 address:storeg
 -- assign:adr.store:B: 
 -- AssignmentStatement:gen: "i := x" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "i := x" right.label: "ObjectGenerator ""x" 
 -- OG:before:super.gen: "x "
 -- INV:gen: "x" 
 -- needorigin: "x" 
 -- needOrigin:E: "x"  E.ATd: "x: var Float" Ex: "x" rec: "x" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "x" 
 -- doNeedOrigin:E: "x" 
 -- computeAdrX:superAdj: 0 "x" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "x" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "x "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:T isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"x":rec:- 
 --  rec:  "x "E:  "x "
 -- INV:gen:E.loadArgs "x "
 -- INV:gen:after:E.loadArgs "x "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "x ":Adr:off:2 size:
 --  0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"x":rec:- 
 -- OI:invoke:before:ATdx.invoke: var x 
 -- DI:invoke: "x: var Float" 
 -- load: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"x":rec:x isNotRemote: true 
 fpushg 2 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"x":rec:x 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"x":rec:x 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"x":rec:x 
 f2i
 -- assign:adr.store:A: 
 storeg I2F_foo$140 4
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "put(' ') "
 -- INV:gen: "put(' ')" 
 -- needorigin: "put(' ')" 
 -- needOrigin:E: "put(' ')"  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put(' ')" rec: "put(' ')" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put(' ')" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put(' ') "E:  "put(' ') "
 -- INV:gen:E.loadArgs "put(' ') "
 -- NonVirt: "put(' ')" "ObjectInvocation_KeyWord" ActArg: "' ' "isValue: true formalArg: "in ch: val char" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(' ') " isCompositeValueObj: false 
 -- OG:before:super.gen: "' ' "
 -- INV:gen: "' '" 
 -- needorigin: "' '" 
 -- needOrigin:E: "' '"  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  Ex: "' '" rec: "' '" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  
 -- after:needOrigin: "' '" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "' ' "E:  "' ' "
 -- INV:gen:E.loadArgs "' ' "
 -- INV:gen:after:E.loadArgs "' ' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "' ' "
 pushc 32
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "' ' ":isBasicVal: true 
 -- case:B: ' ' ObjectGenerator 3 3 3 false true 
 -- end:loadArgs:NonVirt: "put(' ') "
 -- INV:gen:after:E.loadArgs "put(' ') "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(' ') "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put(' ') "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- OG:before:super.gen: "putint(i) -- 2 "
 -- INV:gen: "putint(i) -- 2" 
 -- needorigin: "putint(i) -- 2" 
 -- needOrigin:E: "putint(i)"  E.ATd: 
 --  putint: 
 --     %globals
 --     in V: var integer
 --     D: obj Indexed(20,#integer)
 --  Ex: "putint(i)" rec: "putint(i)" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  %globals
 --     in V: var integer
 --     D: obj Indexed(20,#integer)
 --     L: var integer
 --  
 -- after:needOrigin: "putint(i)" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "putint(i) "E:  "putint(i) "
 -- INV:gen:E.loadArgs "putint(i) "
 -- NonVirt: "putint(i)" "ObjectInvocation_KeyWord" ActArg: "i "isValue: false formalArg: "in V: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "putint(i) " isCompositeValueObj: false 
 -- OG:before:super.gen: "i "
 -- INV:gen: "i" 
 -- needorigin: "i" 
 -- needOrigin:E: "i"  E.ATd: "i: var integer" Ex: "i" rec: "i" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "i" 
 -- doNeedOrigin:E: "i" 
 -- computeAdrX:superAdj: 0 "i" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "i" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "i "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 --  rec:  "i "E:  "i "
 -- INV:gen:E.loadArgs "i "
 -- INV:gen:after:E.loadArgs "i "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "i ":Adr:off:4 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"i":rec:- 
 -- OI:invoke:before:ATdx.invoke: var i 
 -- DI:invoke: "i: var integer" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"i":rec:i isNotRemote: true 
 pushg 4 I2F_foo$140
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "i ":isBasicVal: true 
 -- case:B: i ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "putint(i) "
 -- INV:gen:after:E.loadArgs "putint(i) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "putint(i) "
 -- OI:invoke:before:ATdx.invoke: pattern putint 
 -- ptn:invoke: "putint "E: "putint(i) "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "putint(i)" 
 --  adr:none 
 invoke putint 141 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: nl; adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:
 --  0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- AssignmentStatement:gen: "x := x + 7" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "x := x + 7" right.label: "ObjectGenerator ""x + 7" 
 -- OG:before:super.gen: "x + 7 "
 -- INV:gen: "x + 7" 
 -- needorigin: "x + 7" 
 -- needOrigin:E: "x + 7"  E.ATd: 
 --  +  : 
 --     %basic 109
 --     in V: var float
 --     out R: var float
 --  Ex: "x + 7" rec: "x + 7" 
 -- doNeedOrigin:Ex: "x + 7 "originIsValueObj: true origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "x + 7" 
 -- doNeedOrigin:E: "x + 7" 
 -- computeAdrX:superAdj: 0 "x + 7" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "x + 7" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "x + 7 "superAdj: 0 
 -- computeAdrX:isLast:E:  "x + 7 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "x + 7 "E:  "x + 7 "
 -- INV:gen:E.loadArgs "x + 7 "
 -- BinaryExp:loadArgs: "x + 7" superAdj: 0 
 -- INV:gen: "x" 
 -- needorigin: "x" 
 -- needOrigin:E: "x"  E.ATd: "x: var Float" Ex: "x" rec: "x" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "x" 
 -- doNeedOrigin:E: "x" 
 -- computeAdrX:superAdj: 0 "x" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "x" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "x "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:T isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"x":rec:- 
 --  rec:  "x "E:  "x "
 -- INV:gen:E.loadArgs "x "
 -- INV:gen:after:E.loadArgs "x "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "x ":Adr:off:2 size:
 --  0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"x":rec:- 
 -- OI:invoke:before:ATdx.invoke: var x 
 -- DI:invoke: "x: var Float" 
 -- load: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"x":rec:x isNotRemote: true 
 fpushg 2 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"x":rec:x 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"x":rec:x 
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:2 size:0 isFloat:T isUnit
 --  Val:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"x":rec:x 
 -- NonVirt: "+ 7" "ObjectInvocation_Binary" ActArg: "7 "isValue: true formalArg: "in V: var float" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ 7 " isCompositeValueObj: false 
 -- OG:before:super.gen: "7 "
 -- INV:gen: "7" 
 -- needorigin: "7" 
 -- needOrigin:E: "7"  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "7" rec: "7" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "7" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "7 "E:  "7 "
 -- INV:gen:E.loadArgs "7 "
 -- INV:gen:after:E.loadArgs "7 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "7 "
 pushc 7
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var float ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "7 ":isBasicVal: true 
 -- case:B: 7 ObjectGenerator 9 1 1 false true 
 i2f
 -- end:loadArgs:NonVirt: "+ 7 "
 -- BinaryExp:loadArgs:end: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj
 --  :0 isUnique:F isValue:T originIsValue:F:E:"x":rec:x 
 -- INV:gen:after:E.loadArgs "x + 7 "
 --  OIadr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:T originIsValue:F:E:"x":rec:x 
 -- IV:E.invoke:useRtnVal: true E: BinOp "x + 7 ":Adr:off:2 size:0 isFloat:T i
 --  sUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"x":rec:x 
 -- BinaryExp:invoke: "x "rec: "x + 7 "
 -- M: "+ 7 ":Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F is
 --  Value:T originIsValue:F:E:"x":rec:x 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- ptn:invoke: "+   "E: "+ 7 "ptnKind: 0 useRtnV: true 
 fplus
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"+ 7":rec:x nl; adrx: :Adr:off:0 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F
 --  :E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"+ 7":rec:x 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 fstoreg 2 address:storeg
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "put(' ') "
 -- INV:gen: "put(' ')" 
 -- needorigin: "put(' ')" 
 -- needOrigin:E: "put(' ')"  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put(' ')" rec: "put(' ')" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put(' ')" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put(' ') "E:  "put(' ') "
 -- INV:gen:E.loadArgs "put(' ') "
 -- NonVirt: "put(' ')" "ObjectInvocation_KeyWord" ActArg: "' ' "isValue: true formalArg: "in ch: val char" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(' ') " isCompositeValueObj: false 
 -- OG:before:super.gen: "' ' "
 -- INV:gen: "' '" 
 -- needorigin: "' '" 
 -- needOrigin:E: "' '"  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  Ex: "' '" rec: "' '" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  
 -- after:needOrigin: "' '" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "' ' "E:  "' ' "
 -- INV:gen:E.loadArgs "' ' "
 -- INV:gen:after:E.loadArgs "' ' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "' ' "
 pushc 32
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "' ' ":isBasicVal: true 
 -- case:B: ' ' ObjectGenerator 3 3 3 false true 
 -- end:loadArgs:NonVirt: "put(' ') "
 -- INV:gen:after:E.loadArgs "put(' ') "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(' ') "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put(' ') "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- OG:before:super.gen: "putfloat(x) -- 9.04 "
 -- INV:gen: "putfloat(x) -- 9.04" 
 -- needorigin: "putfloat(x) -- 9.04" 
 -- needOrigin:E: "putfloat(x)"  E.ATd: 
 --  putFloat: 
 --     %basic 142
 --     in X: var Float
 --     out V: var integer
 --  Ex: "putfloat(x)" rec: "putfloat(x)" 
 -- doNeedOrigin:Ex: "putfloat(x) "originIsValueObj: false origin.isPrimitive:
 --   false 
 -- KUK 
 -- after:needOrigin: "putfloat(x)" 
 -- doNeedOrigin:E: "putfloat(x)" 
 -- computeAdrX:superAdj: 0 "putfloat(x) -- 9.04" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "putfloat(x)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "putfloat(x) "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putfloat(x)":rec:- 
 --  rec:  "putfloat(x) "E:  "putfloat(x) "
 -- INV:gen:E.loadArgs "putfloat(x) "
 -- NonVirt: "putfloat(x)" "ObjectInvocation_KeyWord" ActArg: "x "isValue: false formalArg: "in X: var Float" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "putfloat(x) " isCompositeValueObj: false 
 -- OG:before:super.gen: "x "
 -- INV:gen: "x" 
 -- needorigin: "x" 
 -- needOrigin:E: "x"  E.ATd: "x: var Float" Ex: "x" rec: "x" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "x" 
 -- doNeedOrigin:E: "x" 
 -- computeAdrX:superAdj: 0 "x" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "x" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "x "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:T isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"x":rec:- 
 --  rec:  "x "E:  "x "
 -- INV:gen:E.loadArgs "x "
 -- INV:gen:after:E.loadArgs "x "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "x ":Adr:off:2 size:
 --  0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"x":rec:- 
 -- OI:invoke:before:ATdx.invoke: var x 
 -- DI:invoke: "x: var Float" 
 -- load: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"x":rec:x isNotRemote: true 
 fpushg 2 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"x":rec:x 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"x":rec:x 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"x":rec:x 
 -- actualArg:isPtn: false formalArg:isPtn: "in X: var Float ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "x ":isBasicVal: true 
 -- case:B: x ObjectGenerator 9 0 9 false false 
 -- end:loadArgs:NonVirt: "putfloat(x) "
 -- INV:gen:after:E.loadArgs "putfloat(x) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "putfloat(x) ":Adr
 --  :off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori
 --  ginIsValue:F:E:"putfloat(x)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern putFloat 
 -- ptn:invoke: "putFloat "E: "putfloat(x) "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "putfloat(x)" 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"putfloat(x)":rec:putfloat(x) 
 %printf_prim 142
 vpop
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"putfloat(x)":rec:putfloat(x) nl; adr
 --  x: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue
 --  :F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"putfloat(x)":rec:putfloat(x) 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"putfloat(x)":rec:putfloat(x) 
 -- AssignmentStatement:gen: "x := 12 + x -- 12 + x is evaluated as int - problay in loadargs" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "x := 12 + x -- 12 + x is evaluated as int - problay in loadargs" right.label: "ObjectGenerator ""12 + x -- 12 + x is evaluated as int - problay in loadargs" 
 -- OG:before:super.gen: "12 + x -- 12 + x is evaluated as int - problay in l
 --  oadargs "
 -- INV:gen: "12 + x -- 12 + x is evaluated as int - problay in loadargs" 
 -- needorigin: "12 + x -- 12 + x is evaluated as int - problay in loadargs" 
 -- needOrigin:E: "12 + x -- 12 + x is evaluated as int - problay in loadargs"  E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  Ex: "12 + x -- 12 + x is evaluated as int - problay in loadargs" rec: "12 + x -- 12 + x is evaluated as int - problay in loadargs" 
 -- doNeedOrigin:Ex: "12 + x -- 12 + x is evaluated as int - problay in loada
 --  rgs "originIsValueObj: true origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "12 + x -- 12 + x is evaluated as int - problay in loadargs" 
 -- doNeedOrigin:E: "12 + x -- 12 + x is evaluated as int - problay in loadargs" 
 -- computeAdrX:superAdj: 0 "12 + x -- 12 + x is evaluated as int - problay in loadargs" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "12 + x -- 12 + x is evaluated as int - problay in loadargs" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "12 + x -- 12 + x is evaluated as int - probl
 --  ay in loadargs "superAdj: 0 
 -- computeAdrX:isLast:E:  "12 + x -- 12 + x is evaluated as int - problay in
 --   loadargs "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "12 + x -- 12 + x is evaluated as int - problay in loadargs "E:  "12 
 --  + x -- 12 + x is evaluated as int - problay in loadargs "
 -- INV:gen:E.loadArgs "12 + x -- 12 + x is evaluated as int - problay in loa
 --  dargs "
 -- BinaryExp:loadArgs: "12 + x -- 12 + x is evaluated as int - problay in loadargs" superAdj: 0 
 -- INV:gen: "12" 
 -- needorigin: "12" 
 -- needOrigin:E: "12"  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "12" rec: "12" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "12" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "12 "E:  "12 "
 -- INV:gen:E.loadArgs "12 "
 -- INV:gen:after:E.loadArgs "12 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "12 "
 pushc 12
 -- INV:gen:end:off: 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 -- NonVirt: "+ x -- 12 + x is evaluated as int - problay in loadargs" "ObjectInvocation_Binary" ActArg: "x -- 12 + x is evaluated as int - problay in loadargs "i
 --  sValue: false formalArg: "in V: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ x -- 12 + x is evaluated as int - problay
 --   in loadargs " isCompositeValueObj: false 
 -- OG:before:super.gen: "x -- 12 + x is evaluated as int - problay in loadar
 --  gs "
 -- INV:gen: "x -- 12 + x is evaluated as int - problay in loadargs" 
 -- needorigin: "x -- 12 + x is evaluated as int - problay in loadargs" 
 -- needOrigin:E: "x -- 12 + x is evaluated as int - problay in loadargs"  E.ATd: "x: var Float" Ex: "x -- 12 + x is evaluated as int - problay in loadargs" rec: "x -- 12 + x is evaluated as int - problay in loadargs" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "x -- 12 + x is evaluated as int - problay in loadargs" 
 -- doNeedOrigin:E: "x -- 12 + x is evaluated as int - problay in loadargs" 
 -- computeAdrX:superAdj: 0 "x -- 12 + x is evaluated as int - problay in loadargs" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "x -- 12 + x is evaluated as int - problay in loadargs" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "x -- 12 + x is evaluated as int - problay in load
 --  args "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:T isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"x -- 12 + x is eval
 --  uated as int - problay in loadargs":rec:- 
 --  rec:  "x -- 12 + x is evaluated as int - problay in loadargs "E:  "x -- 12 
 --  + x is evaluated as int - problay in loadargs "
 -- INV:gen:E.loadArgs "x -- 12 + x is evaluated as int - problay in loadargs
 --   "
 -- INV:gen:after:E.loadArgs "x -- 12 + x is evaluated as int - problay in lo
 --  adargs "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "x -- 12 + x is eval
 --  uated as int - problay in loadargs ":Adr:off:2 size:0 isFloat:T isUnitV
 --  al:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"x -- 12 + x is 
 --  evaluated as int - problay in loadargs":rec:- 
 -- OI:invoke:before:ATdx.invoke: var x 
 -- DI:invoke: "x: var Float" 
 -- load: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"x -- 12 + x is evaluated as int - problay in l
 --  oadargs":rec:x -- 12 + x is evaluated as int - problay in loadargs isNot
 --  Remote: true 
 fpushg 2 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"x -- 12 + x is evaluated as int - p
 --  roblay in loadargs":rec:x -- 12 + x is evaluated as int - problay in lo
 --  adargs 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"x -- 12 + x is evaluated as int - p
 --  roblay in loadargs":rec:x -- 12 + x is evaluated as int - problay in lo
 --  adargs 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"x -- 12 + x is evaluated as int - 
 --  problay in loadargs":rec:x -- 12 + x is evaluated as int - problay in l
 --  oadargs 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "x -- 12 + x is evaluated as int - problay in loadargs ":isBasic
 --  Val: true 
 -- case:B: x -- 12 + x is evaluated as int - problay in loadargs ObjectGener
 --  ator 1 0 9 false false 
 f2i
 -- end:loadArgs:NonVirt: "+ x -- 12 + x is evaluated as int - problay in loa
 --  dargs "
 -- BinaryExp:loadArgs:end: 
 -- INV:gen:after:E.loadArgs "12 + x -- 12 + x is evaluated as int - problay 
 --  in loadargs "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: BinOp "12 + x -- 12 + x is evaluated as int
 --   - problay in loadargs ":Adr:off:0 size:0 isFloat:F isUnitVal:F superAd
 --  j:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:invoke: "12 "rec: "12 + x -- 12 + x is evaluated as int - problay
 --   in loadargs "
 -- M: "+ x -- 12 + x is evaluated as int - problay in loadargs ":Adr:off:0 s
 --  ize:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVal
 --  ue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- ptn:invoke: "+   "E: "+ x -- 12 + x is evaluated as int - problay in loadar
 --  gs "ptnKind: 0 useRtnV: true 
 plus
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"+ x -- 12 + x is evaluated as int -
 --   problay in loadargs":rec:12 nl; adrx: :Adr:off:0 size:0 isFloat:F isUnit
 --  Val:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"+ x -- 12 + x is evaluated as int -
 --   problay in loadargs":rec:12 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 i2f
 -- assign:adr.store:A: 
 fstoreg 2 address:storeg
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "put(' ') "
 -- INV:gen: "put(' ')" 
 -- needorigin: "put(' ')" 
 -- needOrigin:E: "put(' ')"  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put(' ')" rec: "put(' ')" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put(' ')" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put(' ') "E:  "put(' ') "
 -- INV:gen:E.loadArgs "put(' ') "
 -- NonVirt: "put(' ')" "ObjectInvocation_KeyWord" ActArg: "' ' "isValue: true formalArg: "in ch: val char" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(' ') " isCompositeValueObj: false 
 -- OG:before:super.gen: "' ' "
 -- INV:gen: "' '" 
 -- needorigin: "' '" 
 -- needOrigin:E: "' '"  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  Ex: "' '" rec: "' '" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  
 -- after:needOrigin: "' '" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "' ' "E:  "' ' "
 -- INV:gen:E.loadArgs "' ' "
 -- INV:gen:after:E.loadArgs "' ' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "' ' "
 pushc 32
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "' ' ":isBasicVal: true 
 -- case:B: ' ' ObjectGenerator 3 3 3 false true 
 -- end:loadArgs:NonVirt: "put(' ') "
 -- INV:gen:after:E.loadArgs "put(' ') "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(' ') "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put(' ') "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- OG:before:super.gen: "putfloat(x) -- 21.04 NOT correct,  "
 -- INV:gen: "putfloat(x) -- 21.04 NOT correct, " 
 -- needorigin: "putfloat(x) -- 21.04 NOT correct, " 
 -- needOrigin:E: "putfloat(x)"  E.ATd: 
 --  putFloat: 
 --     %basic 142
 --     in X: var Float
 --     out V: var integer
 --  Ex: "putfloat(x)" rec: "putfloat(x)" 
 -- doNeedOrigin:Ex: "putfloat(x) "originIsValueObj: false origin.isPrimitive:
 --   false 
 -- KUK 
 -- after:needOrigin: "putfloat(x)" 
 -- doNeedOrigin:E: "putfloat(x)" 
 -- computeAdrX:superAdj: 0 "putfloat(x) -- 21.04 NOT correct, " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "putfloat(x)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "putfloat(x) "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putfloat(x)":rec:- 
 --  rec:  "putfloat(x) "E:  "putfloat(x) "
 -- INV:gen:E.loadArgs "putfloat(x) "
 -- NonVirt: "putfloat(x)" "ObjectInvocation_KeyWord" ActArg: "x "isValue: false formalArg: "in X: var Float" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "putfloat(x) " isCompositeValueObj: false 
 -- OG:before:super.gen: "x "
 -- INV:gen: "x" 
 -- needorigin: "x" 
 -- needOrigin:E: "x"  E.ATd: "x: var Float" Ex: "x" rec: "x" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "x" 
 -- doNeedOrigin:E: "x" 
 -- computeAdrX:superAdj: 0 "x" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "x" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "x "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:T isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"x":rec:- 
 --  rec:  "x "E:  "x "
 -- INV:gen:E.loadArgs "x "
 -- INV:gen:after:E.loadArgs "x "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "x ":Adr:off:2 size:
 --  0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"x":rec:- 
 -- OI:invoke:before:ATdx.invoke: var x 
 -- DI:invoke: "x: var Float" 
 -- load: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"x":rec:x isNotRemote: true 
 fpushg 2 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"x":rec:x 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"x":rec:x 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"x":rec:x 
 -- actualArg:isPtn: false formalArg:isPtn: "in X: var Float ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "x ":isBasicVal: true 
 -- case:B: x ObjectGenerator 9 0 9 false false 
 -- end:loadArgs:NonVirt: "putfloat(x) "
 -- INV:gen:after:E.loadArgs "putfloat(x) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "putfloat(x) ":Adr
 --  :off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori
 --  ginIsValue:F:E:"putfloat(x)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern putFloat 
 -- ptn:invoke: "putFloat "E: "putfloat(x) "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "putfloat(x)" 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"putfloat(x)":rec:putfloat(x) 
 %printf_prim 142
 vpop
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"putfloat(x)":rec:putfloat(x) nl; adr
 --  x: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue
 --  :F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"putfloat(x)":rec:putfloat(x) 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"putfloat(x)":rec:putfloat(x) 
 -- AssignmentStatement:gen: "i := i + 6.6" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "i := i + 6.6" right.label: "ObjectGenerator ""i + 6.6" 
 -- OG:before:super.gen: "i + 6.6 "
 -- INV:gen: "i + 6.6" 
 -- needorigin: "i + 6.6" 
 -- needOrigin:E: "i + 6.6"  E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  Ex: "i + 6.6" rec: "i + 6.6" 
 -- doNeedOrigin:Ex: "i + 6.6 "originIsValueObj: true origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "i + 6.6" 
 -- doNeedOrigin:E: "i + 6.6" 
 -- computeAdrX:superAdj: 0 "i + 6.6" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "i + 6.6" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "i + 6.6 "superAdj: 0 
 -- computeAdrX:isLast:E:  "i + 6.6 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "i + 6.6 "E:  "i + 6.6 "
 -- INV:gen:E.loadArgs "i + 6.6 "
 -- BinaryExp:loadArgs: "i + 6.6" superAdj: 0 
 -- INV:gen: "i" 
 -- needorigin: "i" 
 -- needOrigin:E: "i"  E.ATd: "i: var integer" Ex: "i" rec: "i" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "i" 
 -- doNeedOrigin:E: "i" 
 -- computeAdrX:superAdj: 0 "i" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "i" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "i "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 --  rec:  "i "E:  "i "
 -- INV:gen:E.loadArgs "i "
 -- INV:gen:after:E.loadArgs "i "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "i ":Adr:off:4 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"i":rec:- 
 -- OI:invoke:before:ATdx.invoke: var i 
 -- DI:invoke: "i: var integer" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"i":rec:i isNotRemote: true 
 pushg 4 I2F_foo$140
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- INV:gen:end:off: 4 
 i2f
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:4 size:0 isFloat:F isUnit
 --  Val:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- NonVirt: "+ 6.6" "ObjectInvocation_Binary" ActArg: "6.6 "isValue: true formalArg: "in V: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ 6.6 " isCompositeValueObj: false 
 -- OG:before:super.gen: "6.6 "
 -- INV:gen: "6.6" 
 -- needorigin: "6.6" 
 -- needOrigin:E: "6.6"  E.ATd: 
 --  float: Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var Float
 --  Ex: "6.6" rec: "6.6" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var Float
 --  
 -- after:needOrigin: "6.6" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "6.6 "E:  "6.6 "
 -- INV:gen:E.loadArgs "6.6 "
 -- INV:gen:after:E.loadArgs "6.6 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: FloatLiteral "6.6 "
 pushFloatConst 6.600000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "6.6 ":isBasicVal: true 
 -- case:B: 6.6 ObjectGenerator 1 9 9 false true 
 f2i
 -- end:loadArgs:NonVirt: "+ 6.6 "
 -- BinaryExp:loadArgs:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj
 --  :0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- INV:gen:after:E.loadArgs "i + 6.6 "
 --  OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:T originIsValue:F:E:"i":rec:i 
 -- IV:E.invoke:useRtnVal: true E: BinOp "i + 6.6 ":Adr:off:4 size:0 isFloat:F
 --   isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:
 --  i 
 -- BinaryExp:invoke: "i "rec: "i + 6.6 "
 -- M: "+ 6.6 ":Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F 
 --  isValue:T originIsValue:F:E:"i":rec:i 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- ptn:invoke: "+   "E: "+ 6.6 "ptnKind: 0 useRtnV: true 
 plus
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"+ 6.6":rec:i nl; adrx: :Adr:off:0 siz
 --  e:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue
 --  :F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"+ 6.6":rec:i 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg I2F_foo$140 4
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "put(' ') "
 -- INV:gen: "put(' ')" 
 -- needorigin: "put(' ')" 
 -- needOrigin:E: "put(' ')"  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put(' ')" rec: "put(' ')" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put(' ')" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put(' ') "E:  "put(' ') "
 -- INV:gen:E.loadArgs "put(' ') "
 -- NonVirt: "put(' ')" "ObjectInvocation_KeyWord" ActArg: "' ' "isValue: true formalArg: "in ch: val char" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(' ') " isCompositeValueObj: false 
 -- OG:before:super.gen: "' ' "
 -- INV:gen: "' '" 
 -- needorigin: "' '" 
 -- needOrigin:E: "' '"  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  Ex: "' '" rec: "' '" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  
 -- after:needOrigin: "' '" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "' ' "E:  "' ' "
 -- INV:gen:E.loadArgs "' ' "
 -- INV:gen:after:E.loadArgs "' ' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "' ' "
 pushc 32
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "' ' ":isBasicVal: true 
 -- case:B: ' ' ObjectGenerator 3 3 3 false true 
 -- end:loadArgs:NonVirt: "put(' ') "
 -- INV:gen:after:E.loadArgs "put(' ') "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(' ') "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put(' ') "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- OG:before:super.gen: "putint(i) -- 8 "
 -- INV:gen: "putint(i) -- 8" 
 -- needorigin: "putint(i) -- 8" 
 -- needOrigin:E: "putint(i)"  E.ATd: 
 --  putint: 
 --     %globals
 --     in V: var integer
 --     D: obj Indexed(20,#integer)
 --  Ex: "putint(i)" rec: "putint(i)" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  %globals
 --     in V: var integer
 --     D: obj Indexed(20,#integer)
 --     L: var integer
 --  
 -- after:needOrigin: "putint(i)" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "putint(i) "E:  "putint(i) "
 -- INV:gen:E.loadArgs "putint(i) "
 -- NonVirt: "putint(i)" "ObjectInvocation_KeyWord" ActArg: "i "isValue: false formalArg: "in V: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "putint(i) " isCompositeValueObj: false 
 -- OG:before:super.gen: "i "
 -- INV:gen: "i" 
 -- needorigin: "i" 
 -- needOrigin:E: "i"  E.ATd: "i: var integer" Ex: "i" rec: "i" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "i" 
 -- doNeedOrigin:E: "i" 
 -- computeAdrX:superAdj: 0 "i" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "i" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "i "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 --  rec:  "i "E:  "i "
 -- INV:gen:E.loadArgs "i "
 -- INV:gen:after:E.loadArgs "i "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "i ":Adr:off:4 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"i":rec:- 
 -- OI:invoke:before:ATdx.invoke: var i 
 -- DI:invoke: "i: var integer" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"i":rec:i isNotRemote: true 
 pushg 4 I2F_foo$140
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "i ":isBasicVal: true 
 -- case:B: i ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "putint(i) "
 -- INV:gen:after:E.loadArgs "putint(i) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "putint(i) "
 -- OI:invoke:before:ATdx.invoke: pattern putint 
 -- ptn:invoke: "putint "E: "putint(i) "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "putint(i)" 
 --  adr:none 
 invoke putint 141 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: nl; adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:
 --  0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- AssignmentStatement:gen: "i := 5.5 + i" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "i := 5.5 + i" right.label: "ObjectGenerator ""5.5 + i" 
 -- OG:before:super.gen: "5.5 + i "
 -- INV:gen: "5.5 + i" 
 -- needorigin: "5.5 + i" 
 -- needOrigin:E: "5.5 + i"  E.ATd: 
 --  +  : 
 --     %basic 109
 --     in V: var float
 --     out R: var float
 --  Ex: "5.5 + i" rec: "5.5 + i" 
 -- doNeedOrigin:Ex: "5.5 + i "originIsValueObj: true origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "5.5 + i" 
 -- doNeedOrigin:E: "5.5 + i" 
 -- computeAdrX:superAdj: 0 "5.5 + i" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "5.5 + i" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "5.5 + i "superAdj: 0 
 -- computeAdrX:isLast:E:  "5.5 + i "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "5.5 + i "E:  "5.5 + i "
 -- INV:gen:E.loadArgs "5.5 + i "
 -- BinaryExp:loadArgs: "5.5 + i" superAdj: 0 
 -- INV:gen: "5.5" 
 -- needorigin: "5.5" 
 -- needOrigin:E: "5.5"  E.ATd: 
 --  float: Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var Float
 --  Ex: "5.5" rec: "5.5" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var Float
 --  
 -- after:needOrigin: "5.5" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "5.5 "E:  "5.5 "
 -- INV:gen:E.loadArgs "5.5 "
 -- INV:gen:after:E.loadArgs "5.5 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: FloatLiteral "5.5 "
 pushFloatConst 5.500000
 -- INV:gen:end:off: 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 -- NonVirt: "+ i" "ObjectInvocation_Binary" ActArg: "i "isValue: false formalArg: "in V: var float" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ i " isCompositeValueObj: false 
 -- OG:before:super.gen: "i "
 -- INV:gen: "i" 
 -- needorigin: "i" 
 -- needOrigin:E: "i"  E.ATd: "i: var integer" Ex: "i" rec: "i" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "i" 
 -- doNeedOrigin:E: "i" 
 -- computeAdrX:superAdj: 0 "i" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "i" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "i "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 --  rec:  "i "E:  "i "
 -- INV:gen:E.loadArgs "i "
 -- INV:gen:after:E.loadArgs "i "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "i ":Adr:off:4 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"i":rec:- 
 -- OI:invoke:before:ATdx.invoke: var i 
 -- DI:invoke: "i: var integer" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"i":rec:i isNotRemote: true 
 pushg 4 I2F_foo$140
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var float ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "i ":isBasicVal: true 
 -- case:B: i ObjectGenerator 9 0 1 false false 
 i2f
 -- end:loadArgs:NonVirt: "+ i "
 -- BinaryExp:loadArgs:end: 
 -- INV:gen:after:E.loadArgs "5.5 + i "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: BinOp "5.5 + i ":Adr:off:0 size:0 isFloat:F
 --   isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":r
 --  ec:- 
 -- BinaryExp:invoke: "5.5 "rec: "5.5 + i "
 -- M: "+ i ":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F is
 --  Value:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- ptn:invoke: "+   "E: "+ i "ptnKind: 0 useRtnV: true 
 fplus
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"+ i":rec:5.5 nl; adrx: :Adr:off:0 siz
 --  e:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue
 --  :F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"+ i":rec:5.5 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 f2i
 -- assign:adr.store:A: 
 storeg I2F_foo$140 4
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "put(' ') "
 -- INV:gen: "put(' ')" 
 -- needorigin: "put(' ')" 
 -- needOrigin:E: "put(' ')"  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put(' ')" rec: "put(' ')" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put(' ')" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put(' ') "E:  "put(' ') "
 -- INV:gen:E.loadArgs "put(' ') "
 -- NonVirt: "put(' ')" "ObjectInvocation_KeyWord" ActArg: "' ' "isValue: true formalArg: "in ch: val char" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(' ') " isCompositeValueObj: false 
 -- OG:before:super.gen: "' ' "
 -- INV:gen: "' '" 
 -- needorigin: "' '" 
 -- needOrigin:E: "' '"  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  Ex: "' '" rec: "' '" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  
 -- after:needOrigin: "' '" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "' ' "E:  "' ' "
 -- INV:gen:E.loadArgs "' ' "
 -- INV:gen:after:E.loadArgs "' ' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "' ' "
 pushc 32
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "' ' ":isBasicVal: true 
 -- case:B: ' ' ObjectGenerator 3 3 3 false true 
 -- end:loadArgs:NonVirt: "put(' ') "
 -- INV:gen:after:E.loadArgs "put(' ') "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(' ') "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put(' ') "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- OG:before:super.gen: "putint(i) -- 13 "
 -- INV:gen: "putint(i) -- 13" 
 -- needorigin: "putint(i) -- 13" 
 -- needOrigin:E: "putint(i)"  E.ATd: 
 --  putint: 
 --     %globals
 --     in V: var integer
 --     D: obj Indexed(20,#integer)
 --  Ex: "putint(i)" rec: "putint(i)" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  %globals
 --     in V: var integer
 --     D: obj Indexed(20,#integer)
 --     L: var integer
 --  
 -- after:needOrigin: "putint(i)" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "putint(i) "E:  "putint(i) "
 -- INV:gen:E.loadArgs "putint(i) "
 -- NonVirt: "putint(i)" "ObjectInvocation_KeyWord" ActArg: "i "isValue: false formalArg: "in V: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "putint(i) " isCompositeValueObj: false 
 -- OG:before:super.gen: "i "
 -- INV:gen: "i" 
 -- needorigin: "i" 
 -- needOrigin:E: "i"  E.ATd: "i: var integer" Ex: "i" rec: "i" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "i" 
 -- doNeedOrigin:E: "i" 
 -- computeAdrX:superAdj: 0 "i" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "i" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "i "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 --  rec:  "i "E:  "i "
 -- INV:gen:E.loadArgs "i "
 -- INV:gen:after:E.loadArgs "i "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "i ":Adr:off:4 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"i":rec:- 
 -- OI:invoke:before:ATdx.invoke: var i 
 -- DI:invoke: "i: var integer" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"i":rec:i isNotRemote: true 
 pushg 4 I2F_foo$140
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "i ":isBasicVal: true 
 -- case:B: i ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "putint(i) "
 -- INV:gen:after:E.loadArgs "putint(i) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "putint(i) "
 -- OI:invoke:before:ATdx.invoke: pattern putint 
 -- ptn:invoke: "putint "E: "putint(i) "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "putint(i)" 
 --  adr:none 
 invoke putint 141 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: nl; adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:
 --  0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS putint 141 0 BETA 2
 pushThis 
 storeg integer$5 1
 allocEventQ
 mvStack 
 -- DI:gen: "in V: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  V 
 -- DI:gen: "D: obj Indexed(20,#integer)" DI:isConst: true :isBasicValue: false :primNo: 114 
 -- DI:add:BP4:  D 
 -- DI:off: 2 this: "D: obj Indexed(20,#integer)" 
 --  
 -- OG:before:super.gen: "Indexed(20,#integer) "
 -- INV:gen: "Indexed(20,#integer)" 
 -- needorigin: "Indexed(20,#integer)" 
 -- needOrigin:E: "Indexed(20,#integer)"  E.ATd: 
 --  Indexed: 
 --     %globals
 --     %basic 114
 --     %public
 --  Ex: "Indexed(20,#integer)" rec: "Indexed(20,#integer)" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  %globals
 --     %basic 114
 --     %public
 --     in range: var Integer
 --  
 -- after:needOrigin: "Indexed(20,#integer)" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "Indexed(20,#integer) "E:  "Indexed(20,#integer) "
 -- INV:gen:E.loadArgs "Indexed(20,#integer) "
 -- NonVirt: "Indexed(20,#integer)" "ObjectInvocation_Function" ActArg: "20 "isValue: true formalArg: "in range: var Integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "Indexed(20,#integer) " isCompositeValueObj:
 --   false 
 -- OG:before:super.gen: "20 "
 -- INV:gen: "20" 
 -- needorigin: "20" 
 -- needOrigin:E: "20"  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "20" rec: "20" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "20" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "20 "E:  "20 "
 -- INV:gen:E.loadArgs "20 "
 -- INV:gen:after:E.loadArgs "20 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "20 "
 pushc 20
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in range: var Integer ":isBasicVa
 --  l: true :valueObj: true 
 --  :actArg: "20 ":isBasicVal: true 
 -- case:B: 20 ObjectGenerator 1 1 1 false true 
 -- end:loadArgs:NonVirt: "Indexed(20,#integer) "
 -- INV:gen:after:E.loadArgs "Indexed(20,#integer) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Function "Indexed(20,#inte
 --  ger) "
 -- OI:invoke:before:ATdx.invoke: pattern Indexed 
 -- ptn:invoke: "Indexed "E: "Indexed(20,#integer) "ptnKind: 0 useRtnV: false 
 pushThis 
 pushc 1
 allocIndexed putint$141 142 1 0
 pushThis 
 rstoreg  putint$141 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- DI:gen: "L: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  L 
 -- DI:gen: "isNeg: var Boolean" DI:isConst: false :isBasicValue: true :primNo: 4 
 -- DI:add:BP1:  isNeg 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "isNeg := V < 0" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "isNeg := V < 0" right.label: "ObjectGenerator ""V < 0" 
 -- OG:before:super.gen: "V < 0 "
 -- INV:gen: "V < 0" 
 -- needorigin: "V < 0" 
 -- needOrigin:E: "V < 0"  E.ATd: 
 --  <  : 
 --     %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  Ex: "V < 0" rec: "V < 0" 
 -- doNeedOrigin:Ex: "V < 0 "originIsValueObj: true origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "V < 0" 
 -- doNeedOrigin:E: "V < 0" 
 -- computeAdrX:superAdj: 0 "V < 0" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "V < 0" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "V < 0 "superAdj: 0 
 -- computeAdrX:isLast:E:  "V < 0 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "V < 0 "E:  "V < 0 "
 -- INV:gen:E.loadArgs "V < 0 "
 -- BinaryExp:loadArgs: "V < 0" superAdj: 0 
 -- INV:gen: "V" 
 -- needorigin: "V" 
 -- needOrigin:E: "V"  E.ATd: "in V: var integer" Ex: "V" rec: "V" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "V" 
 -- doNeedOrigin:E: "V" 
 -- computeAdrX:superAdj: 0 "V" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "V" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "V "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:1 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 --  rec:  "V "E:  "V "
 -- INV:gen:E.loadArgs "V "
 -- INV:gen:after:E.loadArgs "V "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "V ":Adr:off:1 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"V":rec:- 
 -- OI:invoke:before:ATdx.invoke: var V 
 -- DI:invoke: "in V: var integer" 
 -- load: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"V":rec:V isNotRemote: true 
 pushg 1 putint$141
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- INV:gen:end:off: 1 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:1 size:0 isFloat:F isUnit
 --  Val:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- NonVirt: "< 0" "ObjectInvocation_Binary" ActArg: "0 "isValue: true formalArg: "in V: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "< 0 " isCompositeValueObj: false 
 -- OG:before:super.gen: "0 "
 -- INV:gen: "0" 
 -- needorigin: "0" 
 -- needOrigin:E: "0"  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "0" rec: "0" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "0" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "0 "E:  "0 "
 -- INV:gen:E.loadArgs "0 "
 -- INV:gen:after:E.loadArgs "0 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0 "
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "0 ":isBasicVal: true 
 -- case:B: 0 ObjectGenerator 1 1 1 false true 
 -- end:loadArgs:NonVirt: "< 0 "
 -- BinaryExp:loadArgs:end: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj
 --  :0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- INV:gen:after:E.loadArgs "V < 0 "
 --  OIadr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:T originIsValue:F:E:"V":rec:V 
 -- IV:E.invoke:useRtnVal: true E: BinOp "V < 0 ":Adr:off:1 size:0 isFloat:F i
 --  sUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- BinaryExp:invoke: "V "rec: "V < 0 "
 -- M: "< 0 ":Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F is
 --  Value:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:before:ATdx.invoke: pattern <   
 -- ptn:invoke: "<   "E: "< 0 "ptnKind: 0 useRtnV: true 
 lt
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"< 0":rec:V nl; adrx: :Adr:off:0 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F
 --  :E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"< 0":rec:V 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg putint$141 4
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "if (isNeg) :then 
 --     V := 0 - V "
 -- INV:gen: 
 --  if (isNeg) :then 
 --     V := 0 - V
 --  
 -- needorigin: 
 --  if (isNeg) :then 
 --     V := 0 - V
 --  
 -- needOrigin:E: 
 --  if (isNeg) :then 
 --     V := 0 - V
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (isNeg) :then 
 --     V := 0 - V
 --  rec: 
 --  if (isNeg) :then 
 --     V := 0 - V
 --  
 -- Ex:loadOrign:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (isNeg) :then 
 --     V := 0 - V
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "if (isNeg) :then 
 --     V := 0 - V "E:  "if (isNeg) :then 
 --     V := 0 - V "
 -- INV:gen:E.loadArgs "if (isNeg) :then 
 --     V := 0 - V "
 -- INV:gen:after:E.loadArgs "if (isNeg) :then 
 --     V := 0 - V "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (isNeg) :then 
 --     V := 0 - V "
 -- OG:before:super.gen: "(isNeg) "
 -- INV:gen: "(isNeg)" 
 -- needorigin: "(isNeg)" 
 -- needOrigin:E: "(isNeg)"  E.ATd: "isNeg: var Boolean" Ex: "(isNeg)" rec: "(isNeg)" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "(isNeg)" 
 -- doNeedOrigin:E: "(isNeg)" 
 -- computeAdrX:superAdj: 0 "(isNeg)" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(isNeg)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "isNeg "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 --  rec:  "isNeg "E:  "isNeg "
 -- INV:gen:E.loadArgs "isNeg "
 -- INV:gen:after:E.loadArgs "isNeg "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "isNeg ":Adr:off:4 s
 --  ize:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsVal
 --  ue:F:E:"isNeg":rec:- 
 -- OI:invoke:before:ATdx.invoke: var isNeg 
 -- DI:invoke: "isNeg: var Boolean" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"isNeg":rec:isNeg isNotRemote: true 
 pushg 4 putint$141
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"isNeg":rec:isNeg 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"isNeg":rec:isNeg 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"isNeg":rec:isNeg 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  144   "$144 "
 invoke $144 144 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 pushThis 
 -- before objTmpStack:add:  152   "loop "
 invoke loop 152 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OG:before:super.gen: "if (isNeg) :then 
 --     put('-') "
 -- INV:gen: 
 --  if (isNeg) :then 
 --     put('-')
 --  
 -- needorigin: 
 --  if (isNeg) :then 
 --     put('-')
 --  
 -- needOrigin:E: 
 --  if (isNeg) :then 
 --     put('-')
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (isNeg) :then 
 --     put('-')
 --  rec: 
 --  if (isNeg) :then 
 --     put('-')
 --  
 -- Ex:loadOrign:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (isNeg) :then 
 --     put('-')
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "if (isNeg) :then 
 --     put('-') "E:  "if (isNeg) :then 
 --     put('-') "
 -- INV:gen:E.loadArgs "if (isNeg) :then 
 --     put('-') "
 -- INV:gen:after:E.loadArgs "if (isNeg) :then 
 --     put('-') "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (isNeg) :then 
 --     put('-') "
 -- OG:before:super.gen: "(isNeg) "
 -- INV:gen: "(isNeg)" 
 -- needorigin: "(isNeg)" 
 -- needOrigin:E: "(isNeg)"  E.ATd: "isNeg: var Boolean" Ex: "(isNeg)" rec: "(isNeg)" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "(isNeg)" 
 -- doNeedOrigin:E: "(isNeg)" 
 -- computeAdrX:superAdj: 0 "(isNeg)" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(isNeg)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "isNeg "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 --  rec:  "isNeg "E:  "isNeg "
 -- INV:gen:E.loadArgs "isNeg "
 -- INV:gen:after:E.loadArgs "isNeg "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "isNeg ":Adr:off:4 s
 --  ize:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsVal
 --  ue:F:E:"isNeg":rec:- 
 -- OI:invoke:before:ATdx.invoke: var isNeg 
 -- DI:invoke: "isNeg: var Boolean" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"isNeg":rec:isNeg isNotRemote: true 
 pushg 4 putint$141
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"isNeg":rec:isNeg 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"isNeg":rec:isNeg 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"isNeg":rec:isNeg 
 jmpFalse  L7
 L6:
 pushThis 
 -- before objTmpStack:add:  146   "$146 "
 invoke $146 146 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 L7:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 pushThis 
 -- before objTmpStack:add:  149   "for:to:repeat$149 "
 invoke for:to:repeat$149 149 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS Indexed 142 0 BETA 2
 pushThis 
 storeg integer$5 1
 allocEventQ
 mvStack 
 -- DI:gen: "in range: var Integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  range 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:1

 CLASS $144 144 1 putint 141
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "V := 0 - V" 
 pushThis 
 -- items:goOrigin:encOG: "$144 "on: 1 isValueObj: false 
 --  origin: putint origin:isValueObj: false 
 rpushg $144$144 1
 -- AssignmentStatement:gen: 
 --  "V := 0 - V" right.label: "ObjectGenerator ""0 - V" 
 -- OG:before:super.gen: "0 - V "
 -- INV:gen: "0 - V" 
 -- needorigin: "0 - V" 
 -- needOrigin:E: "0 - V"  E.ATd: 
 --  -  : 
 --     %basic 62
 --     in V: var integer
 --     out R: var integer
 --  Ex: "0 - V" rec: "0 - V" 
 -- doNeedOrigin:Ex: "0 - V "originIsValueObj: true origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "0 - V" 
 -- doNeedOrigin:E: "0 - V" 
 -- computeAdrX:superAdj: 0 "0 - V" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "0 - V" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "0 - V "superAdj: 0 
 -- computeAdrX:isLast:E:  "0 - V "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "0 - V "E:  "0 - V "
 -- INV:gen:E.loadArgs "0 - V "
 -- BinaryExp:loadArgs: "0 - V" superAdj: 0 
 -- INV:gen: "0" 
 -- needorigin: "0" 
 -- needOrigin:E: "0"  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "0" rec: "0" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "0" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "0 "E:  "0 "
 -- INV:gen:E.loadArgs "0 "
 -- INV:gen:after:E.loadArgs "0 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0 "
 pushc 0
 -- INV:gen:end:off: 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 -- NonVirt: "- V" "ObjectInvocation_Binary" ActArg: "V "isValue: false formalArg: "in V: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "- V " isCompositeValueObj: false 
 -- OG:before:super.gen: "V "
 -- INV:gen: "V" 
 -- needorigin: "V" 
 -- needOrigin:E: "V"  E.ATd: "in V: var integer" Ex: "V" rec: "V" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "V" 
 -- doNeedOrigin:E: "V" 
 -- computeAdrX:superAdj: 0 "V" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "V" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$144 "on: 1 isValueObj: false 
 --  origin: putint origin:isValueObj: false 
 rpushg $144$144 1
 -- computeAdrX:isLast:E:  "V "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:1 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 --  rec:  "V "E:  "V "
 -- INV:gen:E.loadArgs "V "
 -- INV:gen:after:E.loadArgs "V "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "V ":Adr:off:1 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"V":rec:- 
 -- OI:invoke:before:ATdx.invoke: var V 
 -- DI:invoke: "in V: var integer" 
 -- load: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"V":rec:V isNotRemote: true 
 pushg 1 putint$141
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- INV:gen:end:off: 1 
 -- OG:gen:end: OIadr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "V ":isBasicVal: true 
 -- case:B: V ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "- V "
 -- BinaryExp:loadArgs:end: 
 -- INV:gen:after:E.loadArgs "0 - V "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: BinOp "0 - V ":Adr:off:0 size:0 isFloat:F i
 --  sUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec
 --  :- 
 -- BinaryExp:invoke: "0 "rec: "0 - V "
 -- M: "- V ":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F is
 --  Value:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern -   
 -- ptn:invoke: "-   "E: "- V "ptnKind: 0 useRtnV: true 
 minus
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"- V":rec:0 nl; adrx: :Adr:off:0 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F
 --  :E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"- V":rec:0 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg putint$141 1
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS loop 152 1 putint 141
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "L := L + 1" 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: putint origin:isValueObj: false 
 rpushg loop$152 1
 -- AssignmentStatement:gen: 
 --  "L := L + 1" right.label: "ObjectGenerator ""L + 1" 
 -- OG:before:super.gen: "L + 1 "
 -- INV:gen: "L + 1" 
 -- needorigin: "L + 1" 
 -- needOrigin:E: "L + 1"  E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  Ex: "L + 1" rec: "L + 1" 
 -- doNeedOrigin:Ex: "L + 1 "originIsValueObj: true origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "L + 1" 
 -- doNeedOrigin:E: "L + 1" 
 -- computeAdrX:superAdj: 0 "L + 1" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L + 1" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "L + 1 "superAdj: 0 
 -- computeAdrX:isLast:E:  "L + 1 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "L + 1 "E:  "L + 1 "
 -- INV:gen:E.loadArgs "L + 1 "
 -- BinaryExp:loadArgs: "L + 1" superAdj: 0 
 -- INV:gen: "L" 
 -- needorigin: "L" 
 -- needOrigin:E: "L"  E.ATd: "L: var integer" Ex: "L" rec: "L" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L" 
 -- doNeedOrigin:E: "L" 
 -- computeAdrX:superAdj: 0 "L" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: putint origin:isValueObj: false 
 rpushg loop$152 1
 -- computeAdrX:isLast:E:  "L "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 --  rec:  "L "E:  "L "
 -- INV:gen:E.loadArgs "L "
 -- INV:gen:after:E.loadArgs "L "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L ":Adr:off:3 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"L":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- DI:invoke: "L: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"L":rec:L isNotRemote: true 
 pushg 3 putint$141
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnit
 --  Val:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- NonVirt: "+ 1" "ObjectInvocation_Binary" ActArg: "1 "isValue: true formalArg: "in V: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ 1 " isCompositeValueObj: false 
 -- OG:before:super.gen: "1 "
 -- INV:gen: "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "1" rec: "1" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "1" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "1 "E:  "1 "
 -- INV:gen:E.loadArgs "1 "
 -- INV:gen:after:E.loadArgs "1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1 "
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- end:loadArgs:NonVirt: "+ 1 "
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj
 --  :0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:after:E.loadArgs "L + 1 "
 --  OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:T originIsValue:F:E:"L":rec:L 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L + 1 ":Adr:off:3 size:0 isFloat:F i
 --  sUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- BinaryExp:invoke: "L "rec: "L + 1 "
 -- M: "+ 1 ":Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F is
 --  Value:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- ptn:invoke: "+   "E: "+ 1 "ptnKind: 0 useRtnV: true 
 plus
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"+ 1":rec:L nl; adrx: :Adr:off:0 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F
 --  :E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"+ 1":rec:L 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg putint$141 3
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "D.put(V /% 10):at[L] "
 -- INV:gen: "D.put(V /% 10):at[L]" 
 -- needorigin: "D.put(V /% 10):at[L]" 
 -- needOrigin:E: "put(V /% 10):at[L]"  E.ATd: 
 --  put(V: var integer):at[inx: var integer]: 
 --     %basic 115
 --  Ex: "put(V /% 10):at[L]" rec: "D" 
 -- doNeedOrigin:Ex: "put(V /% 10):at[L] "originIsValueObj: false origin.isPri
 --  mitive: false 
 -- KUK 
 -- after:needOrigin: "put(V /% 10):at[L]" 
 -- doNeedOrigin:E: "put(V /% 10):at[L]" 
 -- computeAdrX:superAdj: 0 "D.put(V /% 10):at[L]" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "D" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: putint origin:isValueObj: false 
 rpushg loop$152 1
 -- computeAdrX:En: 2 pRec: "D" rec: "D" E: "put(V /% 10):at[L]" 
 --  A.E: none 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "D" rec: "D" E: "put(V /% 10):at[L]" 
 --  rec.ATd: "D: obj Indexed(20,#integer)" rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  %globals
 --     in V: var integer
 --     D: obj Indexed(20,#integer)
 --     L: var integer
 --  
 --  recA: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"put(V /% 10):at[L]":rec:- 
 --  pRecA: none 
 -- pRec: "D" rec: "D" E: "put(V /% 10):at[L]" 
 --  false false 
 -- computeAdrX:before:rec:: "D" 
 -- OI:invoke:before:ATdx.invoke: obj D 
 -- DI:invoke: "D: obj Indexed(20,#integer)" 
 -- >Object:unique: false 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"put(V /% 10):at[L]":rec:D isNotRemote: false 
 rpushg loop$152 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"put(V /% 10):at[L]":rec:D 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"put(V /% 10):at[L]":rec:D 
 -- computeAdrX:after:rec.invoke: "D" 
 -- computeAdrX:isLast:E:  "put(V /% 10):at[L] "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(V /% 10):at[L]"
 --  :rec:D 
 --  rec:  "D "E:  "put(V /% 10):at[L] "
 -- INV:gen:E.loadArgs "put(V /% 10):at[L] "
 -- NonVirt: "put(V /% 10):at[L]" "ObjectInvocation_KeyWord" ActArg: "V /% 10 "isValue: false formalArg: "V: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(V /% 10):at[L] " isCompositeValueObj: false 
 -- OG:before:super.gen: "V /% 10 "
 -- INV:gen: "V /% 10" 
 -- needorigin: "V /% 10" 
 -- needOrigin:E: "V /% 10"  E.ATd: 
 --  /%  : 
 --     %basic 69
 --     in V: var integer
 --     out R: var integer
 --  Ex: "V /% 10" rec: "V /% 10" 
 -- doNeedOrigin:Ex: "V /% 10 "originIsValueObj: true origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "V /% 10" 
 -- doNeedOrigin:E: "V /% 10" 
 -- computeAdrX:superAdj: 0 "V /% 10" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "V /% 10" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "V /% 10 "superAdj: 0 
 -- computeAdrX:isLast:E:  "V /% 10 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "V /% 10 "E:  "V /% 10 "
 -- INV:gen:E.loadArgs "V /% 10 "
 -- BinaryExp:loadArgs: "V /% 10" superAdj: 0 
 -- INV:gen: "V" 
 -- needorigin: "V" 
 -- needOrigin:E: "V"  E.ATd: "in V: var integer" Ex: "V" rec: "V" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "V" 
 -- doNeedOrigin:E: "V" 
 -- computeAdrX:superAdj: 0 "V" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "V" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: putint origin:isValueObj: false 
 rpushg loop$152 1
 -- computeAdrX:isLast:E:  "V "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:1 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 --  rec:  "V "E:  "V "
 -- INV:gen:E.loadArgs "V "
 -- INV:gen:after:E.loadArgs "V "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "V ":Adr:off:1 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"V":rec:- 
 -- OI:invoke:before:ATdx.invoke: var V 
 -- DI:invoke: "in V: var integer" 
 -- load: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"V":rec:V isNotRemote: true 
 pushg 1 putint$141
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- INV:gen:end:off: 1 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:1 size:0 isFloat:F isUnit
 --  Val:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- NonVirt: "/% 10" "ObjectInvocation_Binary" ActArg: "10 "isValue: true formalArg: "in V: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "/% 10 " isCompositeValueObj: false 
 -- OG:before:super.gen: "10 "
 -- INV:gen: "10" 
 -- needorigin: "10" 
 -- needOrigin:E: "10"  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "10" rec: "10" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "10" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "10 "E:  "10 "
 -- INV:gen:E.loadArgs "10 "
 -- INV:gen:after:E.loadArgs "10 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "10 "
 pushc 10
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "10 ":isBasicVal: true 
 -- case:B: 10 ObjectGenerator 1 1 1 false true 
 -- end:loadArgs:NonVirt: "/% 10 "
 -- BinaryExp:loadArgs:end: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj
 --  :0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- INV:gen:after:E.loadArgs "V /% 10 "
 --  OIadr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:T originIsValue:F:E:"V":rec:V 
 -- IV:E.invoke:useRtnVal: true E: BinOp "V /% 10 ":Adr:off:1 size:0 isFloat:F
 --   isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:
 --  V 
 -- BinaryExp:invoke: "V "rec: "V /% 10 "
 -- M: "/% 10 ":Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F 
 --  isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:before:ATdx.invoke: pattern /%   
 -- ptn:invoke: "/%   "E: "/% 10 "ptnKind: 0 useRtnV: true 
 modd
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"/% 10":rec:V nl; adrx: :Adr:off:0 siz
 --  e:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue
 --  :F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"/% 10":rec:V 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "V: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "V /% 10 ":isBasicVal: true 
 -- case:B: V /% 10 ObjectGenerator 1 69 69 false false 
 -- end:loadArgs:NonVirt: "put(V /% 10):at[L] "
 -- NonVirt: "put(V /% 10):at[L]" "ObjectInvocation_KeyWord" ActArg: "L "isValue: false formalArg: "inx: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(V /% 10):at[L] " isCompositeValueObj: false 
 -- OG:before:super.gen: "L "
 -- INV:gen: "L" 
 -- needorigin: "L" 
 -- needOrigin:E: "L"  E.ATd: "L: var integer" Ex: "L" rec: "L" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L" 
 -- doNeedOrigin:E: "L" 
 -- computeAdrX:superAdj: 0 "L" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: putint origin:isValueObj: false 
 rpushg loop$152 1
 -- computeAdrX:isLast:E:  "L "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 --  rec:  "L "E:  "L "
 -- INV:gen:E.loadArgs "L "
 -- INV:gen:after:E.loadArgs "L "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L ":Adr:off:3 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"L":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- DI:invoke: "L: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"L":rec:L isNotRemote: true 
 pushg 3 putint$141
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "L ":isBasicVal: true 
 -- case:B: L ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "put(V /% 10):at[L] "
 -- INV:gen:after:E.loadArgs "put(V /% 10):at[L] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(V /% 10):at[L
 --  ] ":Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValu
 --  e:F originIsValue:F:E:"put(V /% 10):at[L]":rec:D 
 -- OI:invoke:before:ATdx.invoke: pattern put(V: var integer):at[inx: var int
 --  eger] 
 -- ptn:invoke: "put(V: var integer):at[inx: var integer] "E: "put(V /% 10):at[
 --  L] "ptnKind: 0 useRtnV: false 
 xstoreg  inx 1 0 1
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"put(V /% 10):at[L]":rec:D 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"put(V /% 10):at[L]":rec:D 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"put(V /% 10):at[L]":rec:D 
 -- AssignmentStatement:gen: "V := V // 10" 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: putint origin:isValueObj: false 
 rpushg loop$152 1
 -- AssignmentStatement:gen: 
 --  "V := V // 10" right.label: "ObjectGenerator ""V // 10" 
 -- OG:before:super.gen: "V // 10 "
 -- INV:gen: "V // 10" 
 -- needorigin: "V // 10" 
 -- needOrigin:E: "V // 10"  E.ATd: 
 --  //  : 
 --     %basic 68
 --     in V: var integer
 --     out B: var integer
 --  Ex: "V // 10" rec: "V // 10" 
 -- doNeedOrigin:Ex: "V // 10 "originIsValueObj: true origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "V // 10" 
 -- doNeedOrigin:E: "V // 10" 
 -- computeAdrX:superAdj: 0 "V // 10" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "V // 10" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "V // 10 "superAdj: 0 
 -- computeAdrX:isLast:E:  "V // 10 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "V // 10 "E:  "V // 10 "
 -- INV:gen:E.loadArgs "V // 10 "
 -- BinaryExp:loadArgs: "V // 10" superAdj: 0 
 -- INV:gen: "V" 
 -- needorigin: "V" 
 -- needOrigin:E: "V"  E.ATd: "in V: var integer" Ex: "V" rec: "V" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "V" 
 -- doNeedOrigin:E: "V" 
 -- computeAdrX:superAdj: 0 "V" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "V" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: putint origin:isValueObj: false 
 rpushg loop$152 1
 -- computeAdrX:isLast:E:  "V "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:1 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 --  rec:  "V "E:  "V "
 -- INV:gen:E.loadArgs "V "
 -- INV:gen:after:E.loadArgs "V "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "V ":Adr:off:1 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"V":rec:- 
 -- OI:invoke:before:ATdx.invoke: var V 
 -- DI:invoke: "in V: var integer" 
 -- load: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"V":rec:V isNotRemote: true 
 pushg 1 putint$141
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- INV:gen:end:off: 1 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:1 size:0 isFloat:F isUnit
 --  Val:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- NonVirt: "// 10" "ObjectInvocation_Binary" ActArg: "10 "isValue: true formalArg: "in V: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "// 10 " isCompositeValueObj: false 
 -- OG:before:super.gen: "10 "
 -- INV:gen: "10" 
 -- needorigin: "10" 
 -- needOrigin:E: "10"  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "10" rec: "10" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "10" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "10 "E:  "10 "
 -- INV:gen:E.loadArgs "10 "
 -- INV:gen:after:E.loadArgs "10 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "10 "
 pushc 10
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "10 ":isBasicVal: true 
 -- case:B: 10 ObjectGenerator 1 1 1 false true 
 -- end:loadArgs:NonVirt: "// 10 "
 -- BinaryExp:loadArgs:end: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj
 --  :0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- INV:gen:after:E.loadArgs "V // 10 "
 --  OIadr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:T originIsValue:F:E:"V":rec:V 
 -- IV:E.invoke:useRtnVal: true E: BinOp "V // 10 ":Adr:off:1 size:0 isFloat:F
 --   isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:
 --  V 
 -- BinaryExp:invoke: "V "rec: "V // 10 "
 -- M: "// 10 ":Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F 
 --  isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:before:ATdx.invoke: pattern //   
 -- ptn:invoke: "//   "E: "// 10 "ptnKind: 0 useRtnV: true 
 idiv
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"// 10":rec:V nl; adrx: :Adr:off:0 siz
 --  e:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue
 --  :F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"// 10":rec:V 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg putint$141 1
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "if (V > 0) :then 
 --     restart(loop) "
 -- INV:gen: 
 --  if (V > 0) :then 
 --     restart(loop)
 --  
 -- needorigin: 
 --  if (V > 0) :then 
 --     restart(loop)
 --  
 -- needOrigin:E: 
 --  if (V > 0) :then 
 --     restart(loop)
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (V > 0) :then 
 --     restart(loop)
 --  rec: 
 --  if (V > 0) :then 
 --     restart(loop)
 --  
 -- Ex:loadOrign:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (V > 0) :then 
 --     restart(loop)
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "if (V > 0) :then 
 --     restart(loop) "E:  "if (V > 0) :then 
 --     restart(loop) "
 -- INV:gen:E.loadArgs "if (V > 0) :then 
 --     restart(loop) "
 -- INV:gen:after:E.loadArgs "if (V > 0) :then 
 --     restart(loop) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (V > 0) :then 
 --     restart(loop) "
 -- OG:before:super.gen: "(V > 0) "
 -- INV:gen: "(V > 0)" 
 -- needorigin: "(V > 0)" 
 -- needOrigin:E: "(V > 0)"  E.ATd: 
 --  >  : 
 --     %basic 53
 --     in V: var integer
 --     out B: var boolean
 --  Ex: "(V > 0)" rec: "(V > 0)" 
 -- doNeedOrigin:Ex: "(V > 0) "originIsValueObj: true origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(V > 0)" 
 -- doNeedOrigin:E: "(V > 0)" 
 -- computeAdrX:superAdj: 0 "(V > 0)" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(V > 0)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "V > 0 "superAdj: 0 
 -- computeAdrX:isLast:E:  "V > 0 "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "V > 0 "E:  "V > 0 "
 -- INV:gen:E.loadArgs "V > 0 "
 -- BinaryExp:loadArgs: "V > 0" superAdj: 0 
 -- INV:gen: "V" 
 -- needorigin: "V" 
 -- needOrigin:E: "V"  E.ATd: "in V: var integer" Ex: "V" rec: "V" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "V" 
 -- doNeedOrigin:E: "V" 
 -- computeAdrX:superAdj: 0 "V" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "V" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: putint origin:isValueObj: false 
 rpushg loop$152 1
 -- computeAdrX:isLast:E:  "V "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:1 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 --  rec:  "V "E:  "V "
 -- INV:gen:E.loadArgs "V "
 -- INV:gen:after:E.loadArgs "V "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "V ":Adr:off:1 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"V":rec:- 
 -- OI:invoke:before:ATdx.invoke: var V 
 -- DI:invoke: "in V: var integer" 
 -- load: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"V":rec:V isNotRemote: true 
 pushg 1 putint$141
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- INV:gen:end:off: 1 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:1 size:0 isFloat:F isUnit
 --  Val:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- NonVirt: "> 0" "ObjectInvocation_Binary" ActArg: "0 "isValue: true formalArg: "in V: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "> 0 " isCompositeValueObj: false 
 -- OG:before:super.gen: "0 "
 -- INV:gen: "0" 
 -- needorigin: "0" 
 -- needOrigin:E: "0"  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "0" rec: "0" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "0" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "0 "E:  "0 "
 -- INV:gen:E.loadArgs "0 "
 -- INV:gen:after:E.loadArgs "0 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0 "
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "0 ":isBasicVal: true 
 -- case:B: 0 ObjectGenerator 1 1 1 false true 
 -- end:loadArgs:NonVirt: "> 0 "
 -- BinaryExp:loadArgs:end: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj
 --  :0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- INV:gen:after:E.loadArgs "V > 0 "
 --  OIadr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:T originIsValue:F:E:"V":rec:V 
 -- IV:E.invoke:useRtnVal: true E: BinOp "V > 0 ":Adr:off:1 size:0 isFloat:F i
 --  sUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- BinaryExp:invoke: "V "rec: "V > 0 "
 -- M: "> 0 ":Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F is
 --  Value:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:before:ATdx.invoke: pattern >   
 -- ptn:invoke: ">   "E: "> 0 "ptnKind: 0 useRtnV: true 
 gt
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"> 0":rec:V nl; adrx: :Adr:off:0 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F
 --  :E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"> 0":rec:V 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  157   "$157 "
 invoke $157 157 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $157 157 1 loop 152
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "restart(loop) "
 -- INV:gen: "restart(loop)" 
 -- needorigin: "restart(loop)" 
 -- needOrigin:E: "restart(loop)"  E.ATd: 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  Ex: "restart(loop)" rec: "restart(loop)" 
 -- doNeedOrigin:Ex: "restart(loop) "originIsValueObj: false origin.isPrimitiv
 --  e: false 
 -- KUK 
 -- after:needOrigin: "restart(loop)" 
 -- doNeedOrigin:E: "restart(loop)" 
 -- computeAdrX:superAdj: 0 "restart(loop)" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "restart(loop)" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "restart(loop) "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:
 --  - 
 --  rec:  "restart(loop) "E:  "restart(loop) "
 -- INV:gen:E.loadArgs "restart(loop) "
 -- INV:gen:after:E.loadArgs "restart(loop) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "restart(loop) ":A
 --  dr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F o
 --  riginIsValue:F:E:"restart(loop)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern restart(V: var integer) 
 -- ptn:invoke: "restart(V: var integer) "E: "restart(loop) "ptnKind: 0 useRtnV
 --  : false 
 break  1 1 152 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $146 146 1 putint 141
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "put('-') "
 -- INV:gen: "put('-')" 
 -- needorigin: "put('-')" 
 -- needOrigin:E: "put('-')"  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put('-')" rec: "put('-')" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put('-')" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put('-') "E:  "put('-') "
 -- INV:gen:E.loadArgs "put('-') "
 -- NonVirt: "put('-')" "ObjectInvocation_KeyWord" ActArg: "'-' "isValue: true formalArg: "in ch: val char" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put('-') " isCompositeValueObj: false 
 -- OG:before:super.gen: "'-' "
 -- INV:gen: "'-'" 
 -- needorigin: "'-'" 
 -- needOrigin:E: "'-'"  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  Ex: "'-'" rec: "'-'" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  
 -- after:needOrigin: "'-'" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "'-' "E:  "'-' "
 -- INV:gen:E.loadArgs "'-' "
 -- INV:gen:after:E.loadArgs "'-' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "'-' "
 pushc 45
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "'-' ":isBasicVal: true 
 -- case:B: '-' ObjectGenerator 3 3 3 false true 
 -- end:loadArgs:NonVirt: "put('-') "
 -- INV:gen:after:E.loadArgs "put('-') "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put('-') "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put('-') "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS repeat$147 147 1 for:to:repeat$149 149
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "i: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  i 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "i := L + 1 - inx" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "i := L + 1 - inx" right.label: "ObjectGenerator ""L + 1 - inx" 
 -- OG:before:super.gen: "L + 1 - inx "
 -- INV:gen: "L + 1 - inx" 
 -- needorigin: "L + 1 - inx" 
 -- needOrigin:E: "L + 1 - inx"  E.ATd: 
 --  -  : 
 --     %basic 62
 --     in V: var integer
 --     out R: var integer
 --  Ex: "L + 1 - inx" rec: "L + 1 - inx" 
 -- doNeedOrigin:Ex: "L + 1 - inx "originIsValueObj: true origin.isPrimitive:
 --   false 
 -- KUK 
 -- after:needOrigin: "L + 1 - inx" 
 -- doNeedOrigin:E: "L + 1 - inx" 
 -- computeAdrX:superAdj: 0 "L + 1 - inx" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L + 1 - inx" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "L + 1 - inx "superAdj: 0 
 -- computeAdrX:isLast:E:  "L + 1 - inx "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "L + 1 - inx "E:  "L + 1 - inx "
 -- INV:gen:E.loadArgs "L + 1 - inx "
 -- BinaryExp:loadArgs: "L + 1 - inx" superAdj: 0 
 -- BinaryExp:gen: "L + 1 "
 -- INV:gen: "L" 
 -- needorigin: "L" 
 -- needOrigin:E: "L"  E.ATd: "L: var integer" Ex: "L" rec: "L" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L" 
 -- doNeedOrigin:E: "L" 
 -- computeAdrX:superAdj: 0 "L" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$147 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$149 origin:isValueObj: false 
 rpushg repeat$147$147 1
 -- items:goOrigin:encOG: "for:to:repeat$149 "on: 1 isValueObj: false 
 --  origin: putint origin:isValueObj: false 
 rpushg for:to:repeat$149$149 4
 -- computeAdrX:isLast:E:  "L "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 --  rec:  "L "E:  "L "
 -- INV:gen:E.loadArgs "L "
 -- INV:gen:after:E.loadArgs "L "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L ":Adr:off:3 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"L":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- DI:invoke: "L: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"L":rec:L isNotRemote: true 
 pushg 3 putint$141
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:end:off: 3 
 -- BinaryExp:gen:before:loadargs "L + 1 "
 -- A: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue
 --  :T originIsValue:F:E:"L":rec:L 
 -- NonVirt: "+ 1" "ObjectInvocation_Binary" ActArg: "1 "isValue: true formalArg: "in V: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ 1 " isCompositeValueObj: false 
 -- OG:before:super.gen: "1 "
 -- INV:gen: "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "1" rec: "1" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "1" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "1 "E:  "1 "
 -- INV:gen:E.loadArgs "1 "
 -- INV:gen:after:E.loadArgs "1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1 "
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- end:loadArgs:NonVirt: "+ 1 "
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- ptn:invoke: "+   "E: "+ 1 "ptnKind: 0 useRtnV: true 
 plus
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"+ 1":rec:+ 1 nl; adrx: :Adr:off:0 siz
 --  e:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue
 --  :F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"+ 1":rec:+ 1 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:gen:before:end "L + 1 "
 -- Madr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"+ 1":rec:+ 1 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 -- NonVirt: "- inx" "ObjectInvocation_Binary" ActArg: "inx "isValue: false formalArg: "in V: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "- inx " isCompositeValueObj: false 
 -- OG:before:super.gen: "inx "
 -- INV:gen: "inx" 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" Ex: "inx" rec: "inx" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx" 
 -- doNeedOrigin:E: "inx" 
 -- computeAdrX:superAdj: 0 "inx" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$147 "on: 1 isValueObj: false 
 --  origin: for:to:repeat$149 origin:isValueObj: false 
 rpushg repeat$147$147 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx ":Adr:off:3 siz
 --  e:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue
 --  :F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 3 for:to:repeat$149$149
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "- inx "
 -- BinaryExp:loadArgs:end: 
 -- INV:gen:after:E.loadArgs "L + 1 - inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L + 1 - inx ":Adr:off:0 size:0 isFlo
 --  at:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"non
 --  e":rec:- 
 -- BinaryExp:invoke: "L + 1 "rec: "L + 1 - inx "
 -- M: "- inx ":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F 
 --  isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern -   
 -- ptn:invoke: "-   "E: "- inx "ptnKind: 0 useRtnV: true 
 minus
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"- inx":rec:L + 1 nl; adrx: :Adr:off:0
 --   size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsV
 --  alue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"- inx":rec:L + 1 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg repeat$147$147 2
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "put('0' + D.get[i]) "
 -- INV:gen: "put('0' + D.get[i])" 
 -- needorigin: "put('0' + D.get[i])" 
 -- needOrigin:E: "put('0' + D.get[i])"  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put('0' + D.get[i])" rec: "put('0' + D.get[i])" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put('0' + D.get[i])" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put('0' + D.get[i]) "E:  "put('0' + D.get[i]) "
 -- INV:gen:E.loadArgs "put('0' + D.get[i]) "
 -- NonVirt: "put('0' + D.get[i])" "ObjectInvocation_KeyWord" ActArg: "'0' + D.get[i] "isValue: false formalArg: "in ch: val char" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put('0' + D.get[i]) " isCompositeValueObj: false 
 -- OG:before:super.gen: "'0' + D.get[i] "
 -- INV:gen: "'0' + D.get[i]" 
 -- needorigin: "'0' + D.get[i]" 
 -- needOrigin:E: "'0' + D.get[i]"  E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var char
 --     out R: var char
 --  Ex: "'0' + D.get[i]" rec: "'0' + D.get[i]" 
 -- doNeedOrigin:Ex: "'0' + D.get[i] "originIsValueObj: true origin.isPrimiti
 --  ve: false 
 -- KUK 
 -- after:needOrigin: "'0' + D.get[i]" 
 -- doNeedOrigin:E: "'0' + D.get[i]" 
 -- computeAdrX:superAdj: 0 "'0' + D.get[i]" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "'0' + D.get[i]" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "'0' + D.get[i] "superAdj: 0 
 -- computeAdrX:isLast:E:  "'0' + D.get[i] "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "'0' + D.get[i] "E:  "'0' + D.get[i] "
 -- INV:gen:E.loadArgs "'0' + D.get[i] "
 -- BinaryExp:loadArgs: "'0' + D.get[i]" superAdj: 0 
 -- INV:gen: "'0'" 
 -- needorigin: "'0'" 
 -- needOrigin:E: "'0'"  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  Ex: "'0'" rec: "'0'" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  
 -- after:needOrigin: "'0'" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "'0' "E:  "'0' "
 -- INV:gen:E.loadArgs "'0' "
 -- INV:gen:after:E.loadArgs "'0' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "'0' "
 pushc 48
 -- INV:gen:end:off: 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 -- NonVirt: "+ D.get[i]" "ObjectInvocation_Binary" ActArg: "D.get[i] "isValue: false formalArg: "in V: var char" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ D.get[i] " isCompositeValueObj: false 
 -- OG:before:super.gen: "D.get[i] "
 -- INV:gen: "D.get[i]" 
 -- needorigin: "D.get[i]" 
 -- needOrigin:E: "get[i]"  E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 116
 --     out V: var integer
 --  Ex: "get[i]" rec: "D" 
 -- doNeedOrigin:Ex: "get[i] "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "get[i]" 
 -- doNeedOrigin:E: "get[i]" 
 -- computeAdrX:superAdj: 0 "D.get[i]" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "D" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$147 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$149 origin:isValueObj: false 
 rpushg repeat$147$147 1
 -- items:goOrigin:encOG: "for:to:repeat$149 "on: 1 isValueObj: false 
 --  origin: putint origin:isValueObj: false 
 rpushg for:to:repeat$149$149 4
 -- computeAdrX:En: 2 pRec: "D" rec: "D" E: "get[i]" 
 --  A.E: none 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "D" rec: "D" E: "get[i]" 
 --  rec.ATd: "D: obj Indexed(20,#integer)" rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  %globals
 --     in V: var integer
 --     D: obj Indexed(20,#integer)
 --     L: var integer
 --  
 --  recA: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"get[i]":rec:- 
 --  pRecA: none 
 -- pRec: "D" rec: "D" E: "get[i]" 
 --  false false 
 -- computeAdrX:before:rec:: "D" 
 -- OI:invoke:before:ATdx.invoke: obj D 
 -- DI:invoke: "D: obj Indexed(20,#integer)" 
 -- >Object:unique: false 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"get[i]":rec:D isNotRemote: false 
 rpushg repeat$147$147 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"get[i]":rec:D 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"get[i]":rec:D 
 -- computeAdrX:after:rec.invoke: "D" 
 -- computeAdrX:isLast:E:  "get[i] "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[i]":rec:D 
 --  rec:  "D "E:  "get[i] "
 -- INV:gen:E.loadArgs "get[i] "
 -- NonVirt: "get[i]" "ObjectInvocation_KeyWord" ActArg: "i "isValue: false formalArg: "inx: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[i] " isCompositeValueObj: false 
 -- OG:before:super.gen: "i "
 -- INV:gen: "i" 
 -- needorigin: "i" 
 -- needOrigin:E: "i"  E.ATd: "i: var integer" Ex: "i" rec: "i" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "i" 
 -- doNeedOrigin:E: "i" 
 -- computeAdrX:superAdj: 0 "i" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "i" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "i "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 --  rec:  "i "E:  "i "
 -- INV:gen:E.loadArgs "i "
 -- INV:gen:after:E.loadArgs "i "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "i ":Adr:off:2 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"i":rec:- 
 -- OI:invoke:before:ATdx.invoke: var i 
 -- DI:invoke: "i: var integer" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"i":rec:i isNotRemote: true 
 pushg 2 repeat$147$147
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "i ":isBasicVal: true 
 -- case:B: i ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "get[i] "
 -- INV:gen:after:E.loadArgs "get[i] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[i] ":Adr:off:
 --  2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIs
 --  Value:F:E:"get[i]":rec:D 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- ptn:invoke: "get[inx: var integer] "E: "get[i] "ptnKind: 0 useRtnV: true 
 xpushg  inx 1 0 1
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"get[i]":rec:D 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"get[i]":rec:D 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"get[i]":rec:D 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var char ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "D.get[i] ":isBasicVal: true 
 -- case:B: D.get[i] ObjectGenerator 3 116 116 false false 
 -- end:loadArgs:NonVirt: "+ D.get[i] "
 -- BinaryExp:loadArgs:end: 
 -- INV:gen:after:E.loadArgs "'0' + D.get[i] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: BinOp "'0' + D.get[i] ":Adr:off:0 size:0 is
 --  Float:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"
 --  none":rec:- 
 -- BinaryExp:invoke: "'0' "rec: "'0' + D.get[i] "
 -- M: "+ D.get[i] ":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUniq
 --  ue:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- ptn:invoke: "+   "E: "+ D.get[i] "ptnKind: 0 useRtnV: true 
 plus
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"+ D.get[i]":rec:'0' nl; adrx: :Adr:of
 --  f:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origin
 --  IsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"+ D.get[i]":rec:'0' 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "'0' + D.get[i] ":isBasicVal: true 
 -- case:B: '0' + D.get[i] ObjectGenerator 3 61 61 false false 
 -- end:loadArgs:NonVirt: "put('0' + D.get[i]) "
 -- INV:gen:after:E.loadArgs "put('0' + D.get[i]) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put('0' + D.get[i
 --  ]) "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put('0' + D.get[i]) "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS for:to:repeat$149 149 4 putint 141
 -- vdtTableCopy: I:1:28 V:2:29
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- NonVirt: 
 --  for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])
 --  "ObjectInvocation_KeyWord" ActArg: "1 "isValue: true formalArg: "first: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])
 --   " isCompositeValueObj: false 
 -- OG:before:super.gen: "1 "
 -- INV:gen: "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "1" rec: "1" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "1" 
 -- IV:after:computeAdr:superAdj: 4 
 --  rec:  "1 "E:  "1 "
 -- INV:gen:E.loadArgs "1 "
 -- INV:gen:after:E.loadArgs "1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1 "
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "first: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- end:loadArgs:NonVirt: "for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])
 --   "
 -- NonVirt: 
 --  for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])
 --  "ObjectInvocation_KeyWord" ActArg: "L "isValue: false formalArg: "last: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])
 --   " isCompositeValueObj: false 
 -- OG:before:super.gen: "L "
 -- INV:gen: "L" 
 -- needorigin: "L" 
 -- needOrigin:E: "L"  E.ATd: "L: var integer" Ex: "L" rec: "L" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L" 
 -- doNeedOrigin:E: "L" 
 -- computeAdrX:superAdj: 4 "L" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 rpushg putint$141 4
 -- computeAdrX:isLast:E:  "L "
 -- IV:after:computeAdr:superAdj: 4 :Adr:off:3 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 --  rec:  "L "E:  "L "
 -- INV:gen:E.loadArgs "L "
 -- INV:gen:after:E.loadArgs "L "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L ":Adr:off:3 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"L":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- DI:invoke: "L: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"L":rec:L isNotRemote: true 
 pushg 3 putint$141
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- actualArg:isPtn: false formalArg:isPtn: "last: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "L ":isBasicVal: true 
 -- case:B: L ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])
 --   "
 pushThis 
 storeg integer$5 2
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- DI:gen: "inx: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  inx 
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0

 CLASS unit_foo 151 1 tinyS 103
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "l_foo: var Length.Meter" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  l_foo 
 -- DI:off: 2 this: "l_foo: var Length.Meter" 
 --  
 -- OG:before:super.gen: "Length.Meter "
 -- INV:gen: "Length.Meter" 
 -- needorigin: "Length.Meter" 
 -- needOrigin:E: "Meter"  E.ATd: 
 --  Meter: Unit
 --     %unit "m", 1
 --     %Public
 --     thisUnit:: Meter
 --  Ex: "Meter" rec: "Length" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  Unit
 --     %unit "m", 1
 --     %Public
 --     thisUnit:: Meter
 --  
 -- after:needOrigin: "Meter" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "Length "E:  "Meter "
 -- INV:gen:E.loadArgs "Meter "
 -- INV:gen:after:E.loadArgs "Meter "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "Meter "
 -- OI:invoke:before:ATdx.invoke: pattern Meter 
 -- ptn:invoke: "Meter "E: "Meter "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 2 rec: "Length" 
 --  adr:none 
 invokeVal  Meter 74 1
 rpop 
 -- OI:invoke:V: nl; adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0
 --   isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- DI:gen: "a_foo: var Area.SquareMeter" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  a_foo 
 -- DI:off: 4 this: "a_foo: var Area.SquareMeter" 
 --  
 -- OG:before:super.gen: "Area.SquareMeter "
 -- INV:gen: "Area.SquareMeter" 
 -- needorigin: "Area.SquareMeter" 
 -- needOrigin:E: "SquareMeter"  E.ATd: 
 --  SquareMeter: Unit
 --     %unit "m2", 1
 --     %Public
 --     thisUnit:: SquareMeter
 --  Ex: "SquareMeter" rec: "Area" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  Unit
 --     %unit "m2", 1
 --     %Public
 --     thisUnit:: SquareMeter
 --  
 -- after:needOrigin: "SquareMeter" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "Area "E:  "SquareMeter "
 -- INV:gen:E.loadArgs "SquareMeter "
 -- INV:gen:after:E.loadArgs "SquareMeter "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "SquareMeter "
 -- OI:invoke:before:ATdx.invoke: pattern SquareMeter 
 -- ptn:invoke: "SquareMeter "E: "SquareMeter "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 4 rec: "Area" 
 --  adr:none 
 invokeVal  SquareMeter 68 3
 rpop 
 -- OI:invoke:V: nl; adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0
 --   isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "l_foo := 10"m"" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "l_foo := 10"m"" right.label: "ObjectGenerator ""10"m"" 
 -- OG:before:super.gen: "10"m" "
 -- INV:gen: "10"m"" 
 -- needorigin: "10"m"" 
 -- needOrigin:E: "10"m""  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "10"m"" rec: "10"m"" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "10"m"" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "10"m" "E:  "10"m" "
 -- INV:gen:E.loadArgs "10"m" "
 -- INV:gen:after:E.loadArgs "10"m" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "10"m" "
 pushc 10
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 i2f
 -- assign:adr.store:A: 
 fstoreg 2 address:storeg
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "l_foo.print "
 -- INV:gen: "l_foo.print" 
 -- needorigin: "l_foo.print" 
 -- needOrigin:E: "print"  E.ATd: 
 --  print:: 
 --     "Meter".print
 --  Ex: "print" rec: "l_foo" 
 -- doNeedOrigin:Ex: "print "originIsValueObj: true origin.isPrimitive: false 
 -- origin:isValueObj: "Meter "
 -- after:needOrigin: "print" 
 -- doNeedOrigin:E: "print" 
 -- computeAdrX:superAdj: 0 "l_foo.print" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "l_foo" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "l_foo" rec: "l_foo" E: "print" 
 --  A.E: "l_foo "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T
 --   originIsValue:F:E:"l_foo":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "l_foo" rec: "l_foo" E: "print" 
 --  rec.ATd: "l_foo: var Length.Meter" rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  l_foo: var Length.Meter
 --     a_foo: var Area.SquareMeter
 --     l_foo := 10"m"
 --     l_foo.print
 --  
 --  recA: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"l_foo":rec:- 
 --  pRecA: none 
 -- pRec: "l_foo" rec: "l_foo" E: "print" 
 --  false true 
 -- computeAdrX:before:rec:: "l_foo" 
 -- OI:invoke:before:ATdx.invoke: var l_foo 
 -- DI:invoke: "l_foo: var Length.Meter" 
 -- isValueObj:isAdr: true objSize: 2  rec "l_foo ",E: "print ""ObjectInvocation
 --  _Unary "E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T
 --   originIsValue:F:E:"print":rec:l_foo 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"print":rec:l_foo 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain "print" cmpAndSwap: false rec: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"print":rec:l_foo 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"print":rec:l_foo 
 -- computeAdrX:after:rec.invoke: "l_foo" 
 -- computeAdrX:isLast:E:  "print "
 -- originIsValueObj: 
 --  l_foo: var Length.Meter
 --  a_foo: var Area.SquareMeter
 --  l_foo := 10"m"
 --  l_foo.print
 --  
 -- rec = E: false 0 
 -- call:mkValueProxy false true 
 -- mkValueProxy:INV: "l_foo.print" E: "print" rec: "l_foo" E.ATd: 
 --  print:: 
 --     "Meter".print
 --  
 -- CreateProxyW:E: "print "E.ATd.origin.encOG:OGid "Meter "origin:descNo: 74 "Le
 --  ngth ""l_foo.print" 
 --  rec.ATd: "l_foo: var Length.Meter "rec.ATd.newOff: 2 0 
 rdouble 0
 -- son: "l_foo" 
 -- son: "print" 
 -- recOfE: "l_foo "recOfE.ATd: "l_foo: var Length.Meter" 
 -- first: "Length "ObjectInvocation_Unary first.origin.encOG: "unit_foo "
 -- items:goOrigin:encOG: "unit_foo "on: 1 isValueObj: false 
 --  origin: tinyS origin:isValueObj: false 
 rpushg unit_foo$151 1
 -- items:goOrigin:encOG: "tinyS "on: 2 isValueObj: false 
 --  origin: workspace origin:isValueObj: false 
 rpushg tinyS$103 1
 -- items:goOrigin:encOG: "workspace "on: 1 isValueObj: false 
 --  origin: BETAworld origin:isValueObj: false 
 rpushg workspace$102 1
 rpushg LIB 3
 rpushg Dimensions 4
 -- after:Ey.loadOrigin: 
 -- Adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVal
 --  ue:F originIsValue:F:E:"none":rec:- 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- Address:loadAdr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"none":rec:- 
 rpushg EisNone 3
 -- after:A.loadAdr 
 mkValueProxy 74 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:l_foo 
 --  rec:  "l_foo "E:  "print "
 -- INV:gen:E.loadArgs "print "
 -- INV:gen:after:E.loadArgs "print "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print ":Adr:off:2 s
 --  ize:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsVal
 --  ue:F:E:"print":rec:l_foo 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 rec: "l_foo" 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T
 --   originIsValue:F:E:"print":rec:l_foo 
 invoke print 80 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"print":rec:l_foo nl; adrx: :Adr:off:-
 --  1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIs
 --  Value:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"print":rec:l_foo 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"print":rec:l_foo 
 -- AssignmentStatement:gen: "a_foo := l_foo * 12"m"" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "a_foo := l_foo * 12"m"" right.label: "ObjectGenerator ""l_foo * 12"m"" 
 -- OG:before:super.gen: "l_foo * 12"m" "
 -- INV:gen: "l_foo * 12"m"" 
 -- needorigin: "l_foo * 12"m"" 
 -- needOrigin:E: "l_foo * 12"m""  E.ATd: 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  Ex: "l_foo * 12"m"" rec: "l_foo * 12"m"" 
 -- doNeedOrigin:Ex: "l_foo * 12"m" "originIsValueObj: true origin.isPrimitiv
 --  e: false 
 -- KUK 
 -- after:needOrigin: "l_foo * 12"m"" 
 -- doNeedOrigin:E: "l_foo * 12"m"" 
 -- computeAdrX:superAdj: 0 "l_foo * 12"m"" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "l_foo * 12"m"" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "l_foo * 12"m" "superAdj: 0 
 -- computeAdrX:isLast:E:  "l_foo * 12"m" "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "l_foo * 12"m" "E:  "l_foo * 12"m" "
 -- INV:gen:E.loadArgs "l_foo * 12"m" "
 -- BinaryExp:loadArgs: "l_foo * 12"m"" superAdj: 0 
 -- INV:gen: "l_foo" 
 -- needorigin: "l_foo" 
 -- needOrigin:E: "l_foo"  E.ATd: "l_foo: var Length.Meter" Ex: "l_foo" rec: "l_foo" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "l_foo" 
 -- doNeedOrigin:E: "l_foo" 
 -- computeAdrX:superAdj: 0 "l_foo" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "l_foo" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "l_foo "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:T
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"l_foo":rec:- 
 --  rec:  "l_foo "E:  "l_foo "
 -- INV:gen:E.loadArgs "l_foo "
 -- INV:gen:after:E.loadArgs "l_foo "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "l_foo ":Adr:off:2 s
 --  ize:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsVal
 --  ue:F:E:"l_foo":rec:- 
 -- OI:invoke:before:ATdx.invoke: var l_foo 
 -- DI:invoke: "l_foo: var Length.Meter" 
 -- isValueObj:isAdr: false objSize: 2  rec "l_foo ",E: "l_foo ""ObjectInvocation
 --  _Unary "E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T
 --   originIsValue:F:E:"l_foo":rec:l_foo 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"l_foo":rec:l_foo 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:isUnitVal 
 fpushg 2 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"l_foo":rec:l_foo 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"l_foo":rec:l_foo 
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:2 size:0 isFloat:F isUnit
 --  Val:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"l_foo":rec:l_f
 --  oo 
 -- NonVirt: "* 12"m"" "ObjectInvocation_Binary" ActArg: "12"m" "isValue: true formalArg: "in V: var float" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- OG:before:super.gen: "12"m" "
 -- INV:gen: "12"m"" 
 -- needorigin: "12"m"" 
 -- needOrigin:E: "12"m""  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "12"m"" rec: "12"m"" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "12"m"" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "12"m" "E:  "12"m" "
 -- INV:gen:E.loadArgs "12"m" "
 -- INV:gen:after:E.loadArgs "12"m" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "12"m" "
 pushc 12
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var float ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "12"m" ":isBasicVal: true 
 -- case:B: 12"m" ObjectGenerator 9 1 1 false true 
 i2f
 -- end:loadArgs:NonVirt: "* 12"m" "
 -- BinaryExp:loadArgs:end: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj
 --  :0 isUnique:F isValue:T originIsValue:F:E:"l_foo":rec:l_foo 
 -- INV:gen:after:E.loadArgs "l_foo * 12"m" "
 --  OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isV
 --  alue:T originIsValue:F:E:"l_foo":rec:l_foo 
 -- IV:E.invoke:useRtnVal: true E: BinOp "l_foo * 12"m" ":Adr:off:2 size:0 isF
 --  loat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"l
 --  _foo":rec:l_foo 
 -- BinaryExp:invoke: "l_foo "rec: "l_foo * 12"m" "
 -- M: "* 12"m" ":Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:
 --  F isValue:T originIsValue:F:E:"l_foo":rec:l_foo 
 -- OI:invoke:before:ATdx.invoke: pattern *   
 -- ptn:invoke: "*   "E: "* 12"m" "ptnKind: 0 useRtnV: true 
 fmult
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"* 12"m"":rec:l_foo nl; adrx: :Adr:off
 --  :0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI
 --  sValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"* 12"m"":rec:l_foo 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 fstoreg 4 address:storeg
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "a_foo.print "
 -- INV:gen: "a_foo.print" 
 -- needorigin: "a_foo.print" 
 -- needOrigin:E: "print"  E.ATd: 
 --  print:: 
 --     "SquareMeter".print
 --  Ex: "print" rec: "a_foo" 
 -- doNeedOrigin:Ex: "print "originIsValueObj: true origin.isPrimitive: false 
 -- origin:isValueObj: "SquareMeter "
 -- after:needOrigin: "print" 
 -- doNeedOrigin:E: "print" 
 -- computeAdrX:superAdj: 0 "a_foo.print" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "a_foo" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "a_foo" rec: "a_foo" E: "print" 
 --  A.E: "a_foo "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T
 --   originIsValue:F:E:"a_foo":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "a_foo" rec: "a_foo" E: "print" 
 --  rec.ATd: "a_foo: var Area.SquareMeter" rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  l_foo: var Length.Meter
 --     a_foo: var Area.SquareMeter
 --     l_foo := 10"m"
 --     l_foo.print
 --  
 --  recA: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"a_foo":rec:- 
 --  pRecA: none 
 -- pRec: "a_foo" rec: "a_foo" E: "print" 
 --  false true 
 -- computeAdrX:before:rec:: "a_foo" 
 -- OI:invoke:before:ATdx.invoke: var a_foo 
 -- DI:invoke: "a_foo: var Area.SquareMeter" 
 -- isValueObj:isAdr: true objSize: 2  rec "a_foo ",E: "print ""ObjectInvocation
 --  _Unary "E.isCompositeValueObj: false 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T
 --   originIsValue:F:E:"print":rec:a_foo 
 -- Address:loadAdr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"print":rec:a_foo 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain "print" cmpAndSwap: false rec: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"print":rec:a_foo 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"print":rec:a_foo 
 -- computeAdrX:after:rec.invoke: "a_foo" 
 -- computeAdrX:isLast:E:  "print "
 -- originIsValueObj: 
 --  l_foo: var Length.Meter
 --  a_foo: var Area.SquareMeter
 --  l_foo := 10"m"
 --  l_foo.print
 --  
 -- rec = E: false 0 
 -- call:mkValueProxy false true 
 -- mkValueProxy:INV: "a_foo.print" E: "print" rec: "a_foo" E.ATd: 
 --  print:: 
 --     "SquareMeter".print
 --  
 -- CreateProxyW:E: "print "E.ATd.origin.encOG:OGid "SquareMeter "origin:descNo
 --  : 68 "Area ""a_foo.print" 
 --  rec.ATd: "a_foo: var Area.SquareMeter "rec.ATd.newOff: 4 0 
 rdouble 0
 -- son: "a_foo" 
 -- son: "print" 
 -- recOfE: "a_foo "recOfE.ATd: "a_foo: var Area.SquareMeter" 
 -- first: "Area "ObjectInvocation_Unary first.origin.encOG: "unit_foo "
 -- items:goOrigin:encOG: "unit_foo "on: 1 isValueObj: false 
 --  origin: tinyS origin:isValueObj: false 
 rpushg unit_foo$151 1
 -- items:goOrigin:encOG: "tinyS "on: 2 isValueObj: false 
 --  origin: workspace origin:isValueObj: false 
 rpushg tinyS$103 1
 -- items:goOrigin:encOG: "workspace "on: 1 isValueObj: false 
 --  origin: BETAworld origin:isValueObj: false 
 rpushg workspace$102 1
 rpushg LIB 3
 rpushg Dimensions 4
 -- after:Ey.loadOrigin: 
 -- Adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVal
 --  ue:F originIsValue:F:E:"none":rec:- 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"none":rec:- 
 rpushg EisNone 2
 -- after:A.loadAdr 
 mkValueProxy 68 3
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:a_foo 
 --  rec:  "a_foo "E:  "print "
 -- INV:gen:E.loadArgs "print "
 -- INV:gen:after:E.loadArgs "print "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print ":Adr:off:4 s
 --  ize:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsVal
 --  ue:F:E:"print":rec:a_foo 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 rec: "a_foo" 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T
 --   originIsValue:F:E:"print":rec:a_foo 
 invoke print 70 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"print":rec:a_foo nl; adrx: :Adr:off:-
 --  1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIs
 --  Value:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"print":rec:a_foo 
 --  adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"print":rec:a_foo 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0

 CLASS + 158 1 String 10
 pushThis 
 rstoreg  S 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in S: var String" DI:isConst: false :isBasicValue: false :primNo: 5 
 -- DI:gen: "out V: var String" DI:isConst: false :isBasicValue: false :primNo: 5 
 -- StringVar "out V: var String "
 pushText ""
 pushThis 
 rstoreg  V 3
   ;; vTop(0,0)=[] rTop(-3,0)=[]
 -- DI:gen: "L: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  L 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "L := Length" 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "L := Length" right.label: "ObjectGenerator ""Length" 
 -- OG:before:super.gen: "Length "
 -- INV:gen: "Length" 
 -- needorigin: "Length" 
 -- needOrigin:E: "Length"  E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  Ex: "Length" rec: "Length" 
 -- doNeedOrigin:Ex: "Length "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "Length" 
 -- doNeedOrigin:E: "Length" 
 -- computeAdrX:superAdj: 0 "Length" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Length" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "+ "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg +$158 1
 -- computeAdrX:isLast:E:  "Length "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:- 
 --  rec:  "Length "E:  "Length "
 -- INV:gen:E.loadArgs "Length "
 -- INV:gen:after:E.loadArgs "Length "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "Length ":Adr:off:0 
 --  size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVa
 --  lue:F:E:"Length":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- ptn:invoke: "length "E: "Length "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "Length" 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"Length":rec:Length 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:0 size:0 isFloat:F isUnitVal:F superA
 --  dj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"Length":rec:Length nl; adrx: :Adr:off
 --  :2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI
 --  sValue:F:E:"Length":rec:Length 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 --  adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"Length":rec:Length 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 -- assign:adr.store:A: 
 storeg +$158 4
 -- assign:adr.store:B: 
 pushThis 
 -- before objTmpStack:add:  159   "doplus "
 invoke doplus 159 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS doplus 159 1 + 158
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "e: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  e 
 -- DI:gen: "i: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  i 
 -- DI:gen: "T: obj Indexed(L + S.length,Integer)" DI:isConst: true :isBasicValue: false :primNo: 114 
 -- DI:add:BP4:  T 
 -- DI:off: 4 this: "T: obj Indexed(L + S.length,Integer)" 
 --  
 -- OG:before:super.gen: "Indexed(L + S.length,Integer) "
 -- INV:gen: "Indexed(L + S.length,Integer)" 
 -- needorigin: "Indexed(L + S.length,Integer)" 
 -- needOrigin:E: "Indexed(L + S.length,Integer)"  E.ATd: 
 --  Indexed: 
 --     %globals
 --     %basic 114
 --     %public
 --  Ex: "Indexed(L + S.length,Integer)" rec: "Indexed(L + S.length,Integer)" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  %globals
 --     %basic 114
 --     %public
 --     in range: var Integer
 --  
 -- after:needOrigin: "Indexed(L + S.length,Integer)" 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "Indexed(L + S.length,Integer) "E:  "Indexed(L + S.length,Integer) "
 -- INV:gen:E.loadArgs "Indexed(L + S.length,Integer) "
 -- NonVirt: "Indexed(L + S.length,Integer)" "ObjectInvocation_Function" ActArg: "L + S.length "isValue: false formalArg: "in range: var Integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "Indexed(L + S.length,Integer) " isComposite
 --  ValueObj: false 
 -- OG:before:super.gen: "L + S.length "
 -- INV:gen: "L + S.length" 
 -- needorigin: "L + S.length" 
 -- needOrigin:E: "L + S.length"  E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  Ex: "L + S.length" rec: "L + S.length" 
 -- doNeedOrigin:Ex: "L + S.length "originIsValueObj: true origin.isPrimitive
 --  : false 
 -- KUK 
 -- after:needOrigin: "L + S.length" 
 -- doNeedOrigin:E: "L + S.length" 
 -- computeAdrX:superAdj: 0 "L + S.length" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L + S.length" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "L + S.length "superAdj: 0 
 -- computeAdrX:isLast:E:  "L + S.length "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "L + S.length "E:  "L + S.length "
 -- INV:gen:E.loadArgs "L + S.length "
 -- BinaryExp:loadArgs: "L + S.length" superAdj: 0 
 -- INV:gen: "L" 
 -- needorigin: "L" 
 -- needOrigin:E: "L"  E.ATd: "L: var integer" Ex: "L" rec: "L" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L" 
 -- doNeedOrigin:E: "L" 
 -- computeAdrX:superAdj: 0 "L" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "doplus "on: 1 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$159 1
 -- computeAdrX:isLast:E:  "L "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 --  rec:  "L "E:  "L "
 -- INV:gen:E.loadArgs "L "
 -- INV:gen:after:E.loadArgs "L "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L ":Adr:off:4 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"L":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- DI:invoke: "L: var integer" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"L":rec:L isNotRemote: true 
 pushg 4 +$158
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:end:off: 4 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:4 size:0 isFloat:F isUnit
 --  Val:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- NonVirt: "+ S.length" "ObjectInvocation_Binary" ActArg: "S.length "isValue: false formalArg: "in V: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ S.length " isCompositeValueObj: false 
 -- OG:before:super.gen: "S.length "
 -- INV:gen: "S.length" 
 -- needorigin: "S.length" 
 -- needOrigin:E: "length"  E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  Ex: "length" rec: "S" 
 -- doNeedOrigin:Ex: "length "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "length" 
 -- doNeedOrigin:E: "length" 
 -- computeAdrX:superAdj: 0 "S.length" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "S" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "doplus "on: 1 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$159 1
 -- computeAdrX:En: 2 pRec: "S" rec: "S" E: "length" 
 --  A.E: none 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "S" rec: "S" E: "length" 
 --  rec.ATd: "in S: var String" rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  in S: var String
 --     out V: var String
 --     L: var integer
 --     L := Length
 --  
 --  recA: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"length":rec:- 
 --  pRecA: none 
 -- pRec: "S" rec: "S" E: "length" 
 --  false false 
 -- computeAdrX:before:rec:: "S" 
 -- OI:invoke:before:ATdx.invoke: var S 
 -- DI:invoke: "in S: var String" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"length":rec:S 
 rpushg doplus$159 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- computeAdrX:after:rec.invoke: "S" 
 -- computeAdrX:isLast:E:  "length "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 --  rec:  "S "E:  "length "
 -- INV:gen:E.loadArgs "length "
 -- INV:gen:after:E.loadArgs "length "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length ":Adr:off:2 
 --  size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVa
 --  lue:F:E:"length":rec:S 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- ptn:invoke: "length "E: "length "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "S" 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"length":rec:S 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:2 size:0 isFloat:F isUnitVal:F superA
 --  dj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"length":rec:S nl; adrx: :Adr:off:2 si
 --  ze:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValu
 --  e:F:E:"length":rec:S 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"length":rec:S 
 --  adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"length":rec:S 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "S.length ":isBasicVal: true 
 -- case:B: S.length ObjectGenerator 1 0 0 false false 
 -- end:loadArgs:NonVirt: "+ S.length "
 -- BinaryExp:loadArgs:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj
 --  :0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:after:E.loadArgs "L + S.length "
 --  OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:T originIsValue:F:E:"L":rec:L 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L + S.length ":Adr:off:4 size:0 isFl
 --  oat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L"
 --  :rec:L 
 -- BinaryExp:invoke: "L "rec: "L + S.length "
 -- M: "+ S.length ":Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUniq
 --  ue:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- ptn:invoke: "+   "E: "+ S.length "ptnKind: 0 useRtnV: true 
 plus
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"+ S.length":rec:L nl; adrx: :Adr:off:
 --  0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIs
 --  Value:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"+ S.length":rec:L 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in range: var Integer ":isBasicVa
 --  l: true :valueObj: true 
 --  :actArg: "L + S.length ":isBasicVal: true 
 -- case:B: L + S.length ObjectGenerator 1 61 61 false false 
 -- end:loadArgs:NonVirt: "Indexed(L + S.length,Integer) "
 -- INV:gen:after:E.loadArgs "Indexed(L + S.length,Integer) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Function "Indexed(L + S.le
 --  ngth,Integer) "
 -- OI:invoke:before:ATdx.invoke: pattern Indexed 
 -- ptn:invoke: "Indexed "E: "Indexed(L + S.length,Integer) "ptnKind: 0 useRtnV
 --  : false 
 pushThis 
 pushc 1
 allocIndexed doplus$159 142 1 0
 pushThis 
 rstoreg  doplus$159 4
   ;; vTop(2,2)=[0/0,0/0] rTop(-4,0)=[]
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 pushThis 
 -- before objTmpStack:add:  161   "for:to:repeat$161 "
 invoke for:to:repeat$161 161 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  163   "for:to:repeat$163 "
 invoke for:to:repeat$163 163 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 is
 --  Unique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- AssignmentStatement:gen: 
 --  V := T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 pushThis 
 -- items:goOrigin:encOG: "doplus "on: 1 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$159 1
 -- AssignmentStatement:gen: 
 --  
 --  V := T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  right.label: "ObjectGenerator "
 --  T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- OG:before:super.gen: "T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "
 -- INV:gen: 
 --  T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- needorigin: 
 --  T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- needOrigin:E: 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --   E.ATd: 
 --  asString: 
 --     %basic 118
 --     out S: var LIB.StringLib.String
 --  Ex: 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  rec: "T" 
 -- doNeedOrigin:Ex: "asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "originIsValueObj: false origin.i
 --  sPrimitive: false 
 -- KUK 
 -- after:needOrigin: 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- doNeedOrigin:E: 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- computeAdrX:superAdj: 0 
 --  T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- computeAdrX:En: 1 pRec: none rec: none E: "T" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "T" rec: "T" E: 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 --  A.E: none 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "T" rec: "T" E: 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 --  rec.ATd: "T: obj Indexed(L + S.length,Integer)" rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  e: var integer
 --     i: var integer
 --     T: obj Indexed(L + S.length,Integer)
 --     for(1):to(L):repeat
 --  
 --  recA: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:- 
 --  pRecA: none 
 -- pRec: "T" rec: "T" E: 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 --  false false 
 -- computeAdrX:before:rec:: "T" 
 -- OI:invoke:before:ATdx.invoke: obj T 
 -- DI:invoke: "T: obj Indexed(L + S.length,Integer)" 
 -- >Object:unique: false 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:T isNotRemote: false 
 rpushg doplus$159 4
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:T 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:T 
 -- computeAdrX:after:rec.invoke: "T" 
 -- computeAdrX:isLast:E:  "asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:T 
 --  rec:  "T "E:  "asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "
 -- INV:gen:E.loadArgs "asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "
 -- INV:gen:after:E.loadArgs "asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] ":Adr:off:4 size:0 isFloat:F isU
 --  nitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:T 
 -- OI:invoke:before:ATdx.invoke: pattern asString 
 -- ptn:invoke: "asString "E: "asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "ptnKind: 0 useRtnV: true 
 %asString 118
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:T 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:T 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:T 
 -- assign:adr.store:A: 
 rswap 0
 rstoreg  EisNone 3
   ;; vTop(2,2)=[0/0,0/0] rTop(-8,0)=[]
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS repeat$160 160 1 for:to:repeat$161 161
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "e := get[inx]" 
 pushThis 
 -- items:goOrigin:encOG: "repeat$160 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$161 origin:isValueObj: false 
 rpushg repeat$160$160 1
 -- items:goOrigin:encOG: "for:to:repeat$161 "on: 1 isValueObj: false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$161$161 4
 -- AssignmentStatement:gen: 
 --  "e := get[inx]" right.label: "ObjectGenerator ""get[inx]" 
 -- OG:before:super.gen: "get[inx] "
 -- INV:gen: "get[inx]" 
 -- needorigin: "get[inx]" 
 -- needOrigin:E: "get[inx]"  E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  Ex: "get[inx]" rec: "get[inx]" 
 -- doNeedOrigin:Ex: "get[inx] "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "get[inx]" 
 -- doNeedOrigin:E: "get[inx]" 
 -- computeAdrX:superAdj: 0 "get[inx]" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "get[inx]" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$160 "on: 4 isValueObj: false 
 --  origin: for:to:repeat$161 origin:isValueObj: false 
 rpushg repeat$160$160 1
 -- items:goOrigin:encOG: "for:to:repeat$161 "on: 3 isValueObj: false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$161$161 4
 -- items:goOrigin:encOG: "doplus "on: 2 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$159 1
 -- items:goOrigin:encOG: "+ "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg +$158 1
 -- computeAdrX:isLast:E:  "get[inx] "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 --  rec:  "get[inx] "E:  "get[inx] "
 -- INV:gen:E.loadArgs "get[inx] "
 -- NonVirt: "get[inx]" "ObjectInvocation_KeyWord" ActArg: "inx "isValue: false formalArg: "inx: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx] " isCompositeValueObj: false 
 -- OG:before:super.gen: "inx "
 -- INV:gen: "inx" 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" Ex: "inx" rec: "inx" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx" 
 -- doNeedOrigin:E: "inx" 
 -- computeAdrX:superAdj: 0 "inx" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$160 "on: 1 isValueObj: false 
 --  origin: for:to:repeat$161 origin:isValueObj: false 
 rpushg repeat$160$160 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx ":Adr:off:3 siz
 --  e:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue
 --  :F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 3 for:to:repeat$161$161
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "get[inx] "
 -- INV:gen:after:E.loadArgs "get[inx] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx] ":Adr:of
 --  f:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origin
 --  IsValue:F:E:"get[inx]":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- ptn:invoke: "get[inx: var integer] "E: "get[inx] "ptnKind: 0 useRtnV: true 
 xpushg  inx 1 0 1
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- assign:adr.store:A: 
 storeg doplus$159 2
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "T.put(e):at[inx] "
 -- INV:gen: "T.put(e):at[inx]" 
 -- needorigin: "T.put(e):at[inx]" 
 -- needOrigin:E: "put(e):at[inx]"  E.ATd: 
 --  put(V: var integer):at[inx: var integer]: 
 --     %basic 115
 --  Ex: "put(e):at[inx]" rec: "T" 
 -- doNeedOrigin:Ex: "put(e):at[inx] "originIsValueObj: false origin.isPrimiti
 --  ve: false 
 -- KUK 
 -- after:needOrigin: "put(e):at[inx]" 
 -- doNeedOrigin:E: "put(e):at[inx]" 
 -- computeAdrX:superAdj: 0 "T.put(e):at[inx]" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "T" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$160 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$161 origin:isValueObj: false 
 rpushg repeat$160$160 1
 -- items:goOrigin:encOG: "for:to:repeat$161 "on: 1 isValueObj: false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$161$161 4
 -- computeAdrX:En: 2 pRec: "T" rec: "T" E: "put(e):at[inx]" 
 --  A.E: none 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "T" rec: "T" E: "put(e):at[inx]" 
 --  rec.ATd: "T: obj Indexed(L + S.length,Integer)" rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  e: var integer
 --     i: var integer
 --     T: obj Indexed(L + S.length,Integer)
 --     for(1):to(L):repeat
 --  
 --  recA: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"put(e):at[inx]":rec:- 
 --  pRecA: none 
 -- pRec: "T" rec: "T" E: "put(e):at[inx]" 
 --  false false 
 -- computeAdrX:before:rec:: "T" 
 -- OI:invoke:before:ATdx.invoke: obj T 
 -- DI:invoke: "T: obj Indexed(L + S.length,Integer)" 
 -- >Object:unique: false 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"put(e):at[inx]":rec:T isNotRemote: false 
 rpushg repeat$160$160 4
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- computeAdrX:after:rec.invoke: "T" 
 -- computeAdrX:isLast:E:  "put(e):at[inx] "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec
 --  :T 
 --  rec:  "T "E:  "put(e):at[inx] "
 -- INV:gen:E.loadArgs "put(e):at[inx] "
 -- NonVirt: "put(e):at[inx]" "ObjectInvocation_KeyWord" ActArg: "e "isValue: false formalArg: "V: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(e):at[inx] " isCompositeValueObj: false 
 -- OG:before:super.gen: "e "
 -- INV:gen: "e" 
 -- needorigin: "e" 
 -- needOrigin:E: "e"  E.ATd: "e: var integer" Ex: "e" rec: "e" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "e" 
 -- doNeedOrigin:E: "e" 
 -- computeAdrX:superAdj: 0 "e" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "e" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$160 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$161 origin:isValueObj: false 
 rpushg repeat$160$160 1
 -- items:goOrigin:encOG: "for:to:repeat$161 "on: 1 isValueObj: false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$161$161 4
 -- computeAdrX:isLast:E:  "e "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 --  rec:  "e "E:  "e "
 -- INV:gen:E.loadArgs "e "
 -- INV:gen:after:E.loadArgs "e "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "e ":Adr:off:2 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"e":rec:- 
 -- OI:invoke:before:ATdx.invoke: var e 
 -- DI:invoke: "e: var integer" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"e":rec:e isNotRemote: true 
 pushg 2 doplus$159
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- actualArg:isPtn: false formalArg:isPtn: "V: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "e ":isBasicVal: true 
 -- case:B: e ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "put(e):at[inx] "
 -- NonVirt: "put(e):at[inx]" "ObjectInvocation_KeyWord" ActArg: "inx "isValue: false formalArg: "inx: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(e):at[inx] " isCompositeValueObj: false 
 -- OG:before:super.gen: "inx "
 -- INV:gen: "inx" 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" Ex: "inx" rec: "inx" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx" 
 -- doNeedOrigin:E: "inx" 
 -- computeAdrX:superAdj: 0 "inx" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$160 "on: 1 isValueObj: false 
 --  origin: for:to:repeat$161 origin:isValueObj: false 
 rpushg repeat$160$160 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx ":Adr:off:3 siz
 --  e:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue
 --  :F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 3 for:to:repeat$161$161
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "put(e):at[inx] "
 -- INV:gen:after:E.loadArgs "put(e):at[inx] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(e):at[inx] ":
 --  Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F 
 --  originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- OI:invoke:before:ATdx.invoke: pattern put(V: var integer):at[inx: var int
 --  eger] 
 -- ptn:invoke: "put(V: var integer):at[inx: var integer] "E: "put(e):at[inx] "p
 --  tnKind: 0 useRtnV: false 
 xstoreg  inx 1 0 1
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS for:to:repeat$161 161 4 doplus 159
 -- vdtTableCopy: I:1:28 V:2:29
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- NonVirt: 
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --  
 --  "ObjectInvocation_KeyWord" ActArg: "1 "isValue: true formalArg: "first: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --   " isCompositeValueObj: false 
 -- OG:before:super.gen: "1 "
 -- INV:gen: "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "1" rec: "1" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "1" 
 -- IV:after:computeAdr:superAdj: 4 
 --  rec:  "1 "E:  "1 "
 -- INV:gen:E.loadArgs "1 "
 -- INV:gen:after:E.loadArgs "1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1 "
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "first: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- end:loadArgs:NonVirt: "for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --   "
 -- NonVirt: 
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --  
 --  "ObjectInvocation_KeyWord" ActArg: "L "isValue: false formalArg: "last: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --   " isCompositeValueObj: false 
 -- OG:before:super.gen: "L "
 -- INV:gen: "L" 
 -- needorigin: "L" 
 -- needOrigin:E: "L"  E.ATd: "L: var integer" Ex: "L" rec: "L" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L" 
 -- doNeedOrigin:E: "L" 
 -- computeAdrX:superAdj: 4 "L" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 rpushg doplus$159 4
 -- items:goOrigin:encOG: "doplus "on: 1 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$159 1
 -- computeAdrX:isLast:E:  "L "
 -- IV:after:computeAdr:superAdj: 4 :Adr:off:4 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 --  rec:  "L "E:  "L "
 -- INV:gen:E.loadArgs "L "
 -- INV:gen:after:E.loadArgs "L "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L ":Adr:off:4 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"L":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- DI:invoke: "L: var integer" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"L":rec:L isNotRemote: true 
 pushg 4 +$158
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- actualArg:isPtn: false formalArg:isPtn: "last: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "L ":isBasicVal: true 
 -- case:B: L ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --   "
 pushThis 
 storeg integer$5 2
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- DI:gen: "inx: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  inx 
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0

 CLASS repeat$162 162 1 for:to:repeat$163 163
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "e := S.get[inx]" 
 pushThis 
 -- items:goOrigin:encOG: "repeat$162 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$163 origin:isValueObj: false 
 rpushg repeat$162$162 1
 -- items:goOrigin:encOG: "for:to:repeat$163 "on: 1 isValueObj: false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$163$163 4
 -- AssignmentStatement:gen: 
 --  "e := S.get[inx]" right.label: "ObjectGenerator ""S.get[inx]" 
 -- OG:before:super.gen: "S.get[inx] "
 -- INV:gen: "S.get[inx]" 
 -- needorigin: "S.get[inx]" 
 -- needOrigin:E: "get[inx]"  E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  Ex: "get[inx]" rec: "S" 
 -- doNeedOrigin:Ex: "get[inx] "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "get[inx]" 
 -- doNeedOrigin:E: "get[inx]" 
 -- computeAdrX:superAdj: 0 "S.get[inx]" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "S" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$162 "on: 3 isValueObj: false 
 --  origin: for:to:repeat$163 origin:isValueObj: false 
 rpushg repeat$162$162 1
 -- items:goOrigin:encOG: "for:to:repeat$163 "on: 2 isValueObj: false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$163$163 4
 -- items:goOrigin:encOG: "doplus "on: 1 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$159 1
 -- computeAdrX:En: 2 pRec: "S" rec: "S" E: "get[inx]" 
 --  A.E: none 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "S" rec: "S" E: "get[inx]" 
 --  rec.ATd: "in S: var String" rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  in S: var String
 --     out V: var String
 --     L: var integer
 --     L := Length
 --  
 --  recA: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"get[inx]":rec:- 
 --  pRecA: none 
 -- pRec: "S" rec: "S" E: "get[inx]" 
 --  false false 
 -- computeAdrX:before:rec:: "S" 
 -- OI:invoke:before:ATdx.invoke: var S 
 -- DI:invoke: "in S: var String" 
 -- >Object:unique: false 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"get[inx]":rec:S isNotRemote: false 
 rpushg repeat$162$162 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- computeAdrX:after:rec.invoke: "S" 
 -- computeAdrX:isLast:E:  "get[inx] "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 --  rec:  "S "E:  "get[inx] "
 -- INV:gen:E.loadArgs "get[inx] "
 -- NonVirt: "get[inx]" "ObjectInvocation_KeyWord" ActArg: "inx "isValue: false formalArg: "inx: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx] " isCompositeValueObj: false 
 -- OG:before:super.gen: "inx "
 -- INV:gen: "inx" 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" Ex: "inx" rec: "inx" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx" 
 -- doNeedOrigin:E: "inx" 
 -- computeAdrX:superAdj: 0 "inx" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$162 "on: 1 isValueObj: false 
 --  origin: for:to:repeat$163 origin:isValueObj: false 
 rpushg repeat$162$162 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx ":Adr:off:3 siz
 --  e:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue
 --  :F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 3 for:to:repeat$163$163
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "get[inx] "
 -- INV:gen:after:E.loadArgs "get[inx] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx] ":Adr:of
 --  f:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origin
 --  IsValue:F:E:"get[inx]":rec:S 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- ptn:invoke: "get[inx: var integer] "E: "get[inx] "ptnKind: 0 useRtnV: true 
 xpushg  inx 1 0 1
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- assign:adr.store:A: 
 storeg doplus$159 2
 -- assign:adr.store:B: 
 -- AssignmentStatement:gen: "i := L + inx" 
 pushThis 
 -- items:goOrigin:encOG: "repeat$162 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$163 origin:isValueObj: false 
 rpushg repeat$162$162 1
 -- items:goOrigin:encOG: "for:to:repeat$163 "on: 1 isValueObj: false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$163$163 4
 -- AssignmentStatement:gen: 
 --  "i := L + inx" right.label: "ObjectGenerator ""L + inx" 
 -- OG:before:super.gen: "L + inx "
 -- INV:gen: "L + inx" 
 -- needorigin: "L + inx" 
 -- needOrigin:E: "L + inx"  E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  Ex: "L + inx" rec: "L + inx" 
 -- doNeedOrigin:Ex: "L + inx "originIsValueObj: true origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "L + inx" 
 -- doNeedOrigin:E: "L + inx" 
 -- computeAdrX:superAdj: 0 "L + inx" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L + inx" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "L + inx "superAdj: 0 
 -- computeAdrX:isLast:E:  "L + inx "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "L + inx "E:  "L + inx "
 -- INV:gen:E.loadArgs "L + inx "
 -- BinaryExp:loadArgs: "L + inx" superAdj: 0 
 -- INV:gen: "L" 
 -- needorigin: "L" 
 -- needOrigin:E: "L"  E.ATd: "L: var integer" Ex: "L" rec: "L" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L" 
 -- doNeedOrigin:E: "L" 
 -- computeAdrX:superAdj: 0 "L" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$162 "on: 3 isValueObj: false 
 --  origin: for:to:repeat$163 origin:isValueObj: false 
 rpushg repeat$162$162 1
 -- items:goOrigin:encOG: "for:to:repeat$163 "on: 2 isValueObj: false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$163$163 4
 -- items:goOrigin:encOG: "doplus "on: 1 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$159 1
 -- computeAdrX:isLast:E:  "L "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 --  rec:  "L "E:  "L "
 -- INV:gen:E.loadArgs "L "
 -- INV:gen:after:E.loadArgs "L "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L ":Adr:off:4 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"L":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- DI:invoke: "L: var integer" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"L":rec:L isNotRemote: true 
 pushg 4 +$158
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:end:off: 4 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:4 size:0 isFloat:F isUnit
 --  Val:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- NonVirt: "+ inx" "ObjectInvocation_Binary" ActArg: "inx "isValue: false formalArg: "in V: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ inx " isCompositeValueObj: false 
 -- OG:before:super.gen: "inx "
 -- INV:gen: "inx" 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" Ex: "inx" rec: "inx" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx" 
 -- doNeedOrigin:E: "inx" 
 -- computeAdrX:superAdj: 0 "inx" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$162 "on: 1 isValueObj: false 
 --  origin: for:to:repeat$163 origin:isValueObj: false 
 rpushg repeat$162$162 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx ":Adr:off:3 siz
 --  e:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue
 --  :F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 3 for:to:repeat$163$163
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "+ inx "
 -- BinaryExp:loadArgs:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj
 --  :0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:after:E.loadArgs "L + inx "
 --  OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV
 --  alue:T originIsValue:F:E:"L":rec:L 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L + inx ":Adr:off:4 size:0 isFloat:F
 --   isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:
 --  L 
 -- BinaryExp:invoke: "L "rec: "L + inx "
 -- M: "+ inx ":Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F 
 --  isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- ptn:invoke: "+   "E: "+ inx "ptnKind: 0 useRtnV: true 
 plus
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"+ inx":rec:L nl; adrx: :Adr:off:0 siz
 --  e:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue
 --  :F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"+ inx":rec:L 
 --  adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg doplus$159 3
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "T.put(e):at[i] "
 -- INV:gen: "T.put(e):at[i]" 
 -- needorigin: "T.put(e):at[i]" 
 -- needOrigin:E: "put(e):at[i]"  E.ATd: 
 --  put(V: var integer):at[inx: var integer]: 
 --     %basic 115
 --  Ex: "put(e):at[i]" rec: "T" 
 -- doNeedOrigin:Ex: "put(e):at[i] "originIsValueObj: false origin.isPrimitive
 --  : false 
 -- KUK 
 -- after:needOrigin: "put(e):at[i]" 
 -- doNeedOrigin:E: "put(e):at[i]" 
 -- computeAdrX:superAdj: 0 "T.put(e):at[i]" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "T" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$162 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$163 origin:isValueObj: false 
 rpushg repeat$162$162 1
 -- items:goOrigin:encOG: "for:to:repeat$163 "on: 1 isValueObj: false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$163$163 4
 -- computeAdrX:En: 2 pRec: "T" rec: "T" E: "put(e):at[i]" 
 --  A.E: none 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "T" rec: "T" E: "put(e):at[i]" 
 --  rec.ATd: "T: obj Indexed(L + S.length,Integer)" rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  e: var integer
 --     i: var integer
 --     T: obj Indexed(L + S.length,Integer)
 --     for(1):to(L):repeat
 --  
 --  recA: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"put(e):at[i]":rec:- 
 --  pRecA: none 
 -- pRec: "T" rec: "T" E: "put(e):at[i]" 
 --  false false 
 -- computeAdrX:before:rec:: "T" 
 -- OI:invoke:before:ATdx.invoke: obj T 
 -- DI:invoke: "T: obj Indexed(L + S.length,Integer)" 
 -- >Object:unique: false 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"put(e):at[i]":rec:T isNotRemote: false 
 rpushg repeat$162$162 4
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- computeAdrX:after:rec.invoke: "T" 
 -- computeAdrX:isLast:E:  "put(e):at[i] "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T
 --   
 --  rec:  "T "E:  "put(e):at[i] "
 -- INV:gen:E.loadArgs "put(e):at[i] "
 -- NonVirt: "put(e):at[i]" "ObjectInvocation_KeyWord" ActArg: "e "isValue: false formalArg: "V: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(e):at[i] " isCompositeValueObj: false 
 -- OG:before:super.gen: "e "
 -- INV:gen: "e" 
 -- needorigin: "e" 
 -- needOrigin:E: "e"  E.ATd: "e: var integer" Ex: "e" rec: "e" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "e" 
 -- doNeedOrigin:E: "e" 
 -- computeAdrX:superAdj: 0 "e" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "e" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$162 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$163 origin:isValueObj: false 
 rpushg repeat$162$162 1
 -- items:goOrigin:encOG: "for:to:repeat$163 "on: 1 isValueObj: false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$163$163 4
 -- computeAdrX:isLast:E:  "e "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 --  rec:  "e "E:  "e "
 -- INV:gen:E.loadArgs "e "
 -- INV:gen:after:E.loadArgs "e "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "e ":Adr:off:2 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"e":rec:- 
 -- OI:invoke:before:ATdx.invoke: var e 
 -- DI:invoke: "e: var integer" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"e":rec:e isNotRemote: true 
 pushg 2 doplus$159
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- actualArg:isPtn: false formalArg:isPtn: "V: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "e ":isBasicVal: true 
 -- case:B: e ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "put(e):at[i] "
 -- NonVirt: "put(e):at[i]" "ObjectInvocation_KeyWord" ActArg: "i "isValue: false formalArg: "inx: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(e):at[i] " isCompositeValueObj: false 
 -- OG:before:super.gen: "i "
 -- INV:gen: "i" 
 -- needorigin: "i" 
 -- needOrigin:E: "i"  E.ATd: "i: var integer" Ex: "i" rec: "i" 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "i" 
 -- doNeedOrigin:E: "i" 
 -- computeAdrX:superAdj: 0 "i" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "i" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$162 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$163 origin:isValueObj: false 
 rpushg repeat$162$162 1
 -- items:goOrigin:encOG: "for:to:repeat$163 "on: 1 isValueObj: false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$163$163 4
 -- computeAdrX:isLast:E:  "i "
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 --  rec:  "i "E:  "i "
 -- INV:gen:E.loadArgs "i "
 -- INV:gen:after:E.loadArgs "i "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "i ":Adr:off:3 size:
 --  0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F
 --  :E:"i":rec:- 
 -- OI:invoke:before:ATdx.invoke: var i 
 -- DI:invoke: "i: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:T originIsValue:F:E:"i":rec:i isNotRemote: true 
 pushg 3 doplus$159
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "i ":isBasicVal: true 
 -- case:B: i ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "put(e):at[i] "
 -- INV:gen:after:E.loadArgs "put(e):at[i] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(e):at[i] ":Ad
 --  r:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F or
 --  iginIsValue:F:E:"put(e):at[i]":rec:T 
 -- OI:invoke:before:ATdx.invoke: pattern put(V: var integer):at[inx: var int
 --  eger] 
 -- ptn:invoke: "put(V: var integer):at[inx: var integer] "E: "put(e):at[i] "pt
 --  nKind: 0 useRtnV: false 
 xstoreg  inx 1 0 1
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS for:to:repeat$163 163 4 doplus 159
 -- vdtTableCopy: I:1:28 V:2:29
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- NonVirt: 
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 --  "ObjectInvocation_KeyWord" ActArg: "1 "isValue: true formalArg: "first: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 --   " isCompositeValueObj: false 
 -- OG:before:super.gen: "1 "
 -- INV:gen: "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  Ex: "1" rec: "1" 
 -- Ex:loadOrign:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  
 -- after:needOrigin: "1" 
 -- IV:after:computeAdr:superAdj: 4 
 --  rec:  "1 "E:  "1 "
 -- INV:gen:E.loadArgs "1 "
 -- INV:gen:after:E.loadArgs "1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1 "
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "first: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- end:loadArgs:NonVirt: "for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 --   "
 -- NonVirt: 
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 --  "ObjectInvocation_KeyWord" ActArg: "S.length "isValue: false formalArg: "last: var integer" 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 --   " isCompositeValueObj: false 
 -- OG:before:super.gen: "S.length "
 -- INV:gen: "S.length" 
 -- needorigin: "S.length" 
 -- needOrigin:E: "length"  E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  Ex: "length" rec: "S" 
 -- doNeedOrigin:Ex: "length "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "length" 
 -- doNeedOrigin:E: "length" 
 -- computeAdrX:superAdj: 4 "S.length" 
 -- computeAdrX:En: 1 pRec: none rec: none E: "S" 
 --  A.E: none 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 pushThis 
 rpushg doplus$159 4
 -- items:goOrigin:encOG: "doplus "on: 1 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$159 1
 -- computeAdrX:En: 2 pRec: "S" rec: "S" E: "length" 
 --  A.E: none 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "S" rec: "S" E: "length" 
 --  rec.ATd: "in S: var String" rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  in S: var String
 --     out V: var String
 --     L: var integer
 --     L := Length
 --  
 --  recA: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"length":rec:- 
 --  pRecA: none 
 -- pRec: "S" rec: "S" E: "length" 
 --  false false 
 -- computeAdrX:before:rec:: "S" 
 -- OI:invoke:before:ATdx.invoke: var S 
 -- DI:invoke: "in S: var String" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"length":rec:S 
 rpushg doplus$159 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- computeAdrX:after:rec.invoke: "S" 
 -- computeAdrX:isLast:E:  "length "
 -- IV:after:computeAdr:superAdj: 4 :Adr:off:2 size:0 isFloat:F isUnitVal:F
 --   superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 --  rec:  "S "E:  "length "
 -- INV:gen:E.loadArgs "length "
 -- INV:gen:after:E.loadArgs "length "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length ":Adr:off:2 
 --  size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVa
 --  lue:F:E:"length":rec:S 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- ptn:invoke: "length "E: "length "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "S" 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F
 --   originIsValue:F:E:"length":rec:S 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:2 size:0 isFloat:F isUnitVal:F superA
 --  dj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"length":rec:S nl; adrx: :Adr:off:2 si
 --  ze:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValu
 --  e:F:E:"length":rec:S 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUn
 --  ique:F isValue:F originIsValue:F:E:"length":rec:S 
 --  adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa
 --  lue:F originIsValue:F:E:"length":rec:S 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isU
 --  nique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- actualArg:isPtn: true formalArg:isPtn: "last: var integer ":isBasicVal: true :
 --  valueObj: true 
 --  :actArg: "S.length ":isBasicVal: true 
 -- case:B: S.length ObjectGenerator 1 0 0 false false 
 -- end:loadArgs:NonVirt: "for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 --   "
 pushThis 
 storeg integer$5 2
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- DI:gen: "inx: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  inx 
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0

 CLASS asString 164 1 Indexed 142
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "out S: var LIB.StringLib.String" DI:isConst: false :isBasicValue: false :primNo: 5 
 -- StringVar "out S: var LIB.StringLib.String "
 pushText ""
 pushThis 
 rstoreg  S 2
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS valProx 165 1 Object 0
 END OSDV:0 objSize:4 isIndexed:0

 CLASS VM 166 0 Object 0
 L1:
 pushThis 
 invoke BETAworld 1 0 1
 stop
 L2:
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS EventProcessor 167 0 Object 0
 stop
 END OSDV:0 objSize:1 isIndexed:0

 CLASS ThreadStub 168 0 Object 0
DO:
 call(D)ThreadStub
 stop
 END OSDV:0 objSize:1 isIndexed:0

Class BETAworld descInx:1 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	pushthis 
7:	saveBETAworld
8:	mvStack
allocE: 
9:	pushthis 
10:	invoke 2 2 1
16:	rpop 
17:	pushthis 
18:	invoke 33 3 1
24:	rpop 
25:	pushthis 
26:	invoke 102 4 1
32:	rpop 
33:	rtnAlloc 1
doE: 
35:	doEventQ 
36:	mvStack
37:	setThisStack
38:	pushthis 
39:	rtn D


Class BETA descInx:2 objSize:3 originOff: 1 visibility: 2
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 3 2 1
14:	rpop 
15:	rtnAlloc 1
doE: 
17:	doEventQ 
18:	mvStack
19:	setThisStack
20:	pushthis 
21:	rtn D


Class ascii descInx:3 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushc 10
9:	pushthis 
10:	storeg 2
12:	pushc 13
14:	pushthis 
15:	storeg 3
17:	pushc 0
19:	pushthis 
20:	storeg 4
22:	rtnAlloc 1
doE: 
24:	doEventQ 
25:	mvStack
26:	pushthis 
27:	pushc 10
29:	storeg 5
31:	setThisStack
32:	pushthis 
33:	rtn D


Class Value descInx:4 objSize:0 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	mvStack
allocE: 
2:	rtnAlloc 1
doE: 
4:	mvStack
5:	setThisStack
6:	pushthis 
7:	rtn D


Class integer descInx:5 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	mvStack
allocE: 
2:	rtnAlloc 1
doE: 
4:	mvStack
5:	setThisStack
6:	pushthis 
7:	rtn D


Class universal descInx:6 objSize:0 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	mvStack
allocE: 
2:	rtnAlloc 1
doE: 
4:	mvStack
5:	setThisStack
6:	pushthis 
7:	rtn D


Class char descInx:7 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	mvStack
allocE: 
2:	rtnAlloc 1
doE: 
4:	mvStack
5:	setThisStack
6:	pushthis 
7:	rtn D


Class ConsoleIF descInx:8 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class put descInx:9 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class String descInx:10 objSize:0 originOff: 0 visibility: 2
storeOrgAndArgsE:
1:	allocEventQ 1
3:	mvStack
allocE: 
4:	rtnAlloc 1
doE: 
6:	doEventQ 
7:	mvStack
8:	setThisStack
9:	pushthis 
10:	rtn D


Class = descInx:11 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	jmpFalse 13
4:	pushthis 
5:	vassign 4 2 0
10:	jmp 20
13:	invokeVal 31 3 0
19:	rpop 
20:	tstOriginNone 
21:	rstore 1
23:	allocEventQ 0
25:	mvStack
allocE: 
26:	rtnAlloc 1
doE: 
28:	doEventQ 
29:	mvStack
30:	pushthis 
31:	innerP 2
33:	rpopThisObj
34:	setThisStack
35:	pushthis 
36:	rtn D


Class = descInx:13 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	rshiftup 1
3:	tstOriginNone 
4:	rstore 1
6:	allocEventQ 0
8:	pushthis 
9:	rpushg 1
11:	rshiftdown 1
13:	pushthis 
14:	rstoreg 2
16:	tstOriginNone 
17:	rstore 1
19:	allocEventQ 0
21:	mvStack
allocE: 
doE: 
22:	doEventQ 
23:	mvStack
24:	pushthis 
25:	invoke 14 0 0
31:	rpop 
32:	setThisStack
33:	pushthis 
34:	rtn D


Class loop descInx:14 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	rpushg 1
17:	invoke 15 0 0
23:	pushg 2
25:	storeg 4
27:	pushthis 
28:	pushg 4
30:	pushthis 
31:	rpushg 1
33:	rpushg 2
35:	invoke 15 0 0
41:	pushg 2
43:	ne 
44:	jmpFalse 55
47:	pushthis 
48:	invoke 18 0 0
54:	rpop 
55:	pushthis 
56:	rpushg 1
58:	invoke 23 0 0
64:	pushg 1
66:	storeg 3
68:	pushthis 
69:	invoke 30 0 0
75:	rpop 
76:	setThisStack
77:	pushthis 
78:	rtn D


Class length descInx:15 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	pushc 0
17:	xpushg 1 0 1
21:	storeg 2
23:	setThisStack
24:	pushthis 
25:	rtn D


Class $18 descInx:18 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	break 1 2 14 0
18:	setThisStack
19:	pushthis 
20:	rtn D


Class if:then descInx:20 objSize:1 originOff: 0 visibility: 1
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class BETAworld descInx:21 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	innerP 2
14:	rpopThisObj
15:	setThisStack
16:	pushthis 
17:	rtn D


Class thenPart#22 descInx:22 objSize:3 originOff: 0 visibility: 1
storeOrgAndArgsE:
1:	invoke 21 0 0
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class True descInx:23 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
3:	mvStack
allocE: 
4:	rtnAlloc 1
doE: 
6:	doEventQ 
7:	mvStack
8:	pushthis 
9:	pushc 1
11:	storeg 1
13:	setThisStack
14:	pushthis 
15:	rtn D


Class repeat$24 descInx:24 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	pushthis 
17:	rpushg 1
19:	rpushg 4
21:	rpushg 1
23:	rpushg 1
25:	pushthis 
26:	rpushg 1
28:	pushg 3
30:	xpushg 1 0 1
34:	storeg 2
36:	pushthis 
37:	rpushg 1
39:	rpushg 4
41:	pushthis 
42:	rpushg 1
44:	rpushg 4
46:	rpushg 1
48:	rpushg 2
50:	pushthis 
51:	rpushg 1
53:	pushg 3
55:	xpushg 1 0 1
59:	storeg 3
61:	pushthis 
62:	rpushg 1
64:	rpushg 4
66:	pushg 2
68:	pushthis 
69:	rpushg 1
71:	rpushg 4
73:	pushg 3
75:	ne 
76:	jmpFalse 87
79:	pushthis 
80:	invoke 26 0 0
86:	rpop 
87:	setThisStack
88:	pushthis 
89:	rtn D


Class $26 descInx:26 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 4
18:	rpushg 1
20:	invoke 27 0 0
26:	pushg 1
28:	storeg 3
30:	break 3 2 14 0
37:	setThisStack
38:	pushthis 
39:	rtn D


Class False descInx:27 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
3:	mvStack
allocE: 
4:	rtnAlloc 1
doE: 
6:	doEventQ 
7:	mvStack
8:	pushthis 
9:	pushc 0
11:	storeg 1
13:	setThisStack
14:	pushthis 
15:	rtn D


Class for:to:repeat descInx:28 objSize:3 originOff: 0 visibility: 1
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 2
4:	pushthis 
5:	storeg 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	pushthis 
16:	pushg 1
18:	storeg 3
20:	pushthis 
21:	invoke 57 0 0
27:	rpop 
28:	setThisStack
29:	pushthis 
30:	rtn D


Class repeat#29 descInx:29 objSize:3 originOff: 0 visibility: 1
storeOrgAndArgsE:
1:	invoke 21 0 0
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class for:to:repeat$30 descInx:30 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	rpushg 1
13:	invoke 15 0 0
19:	pushg 2
21:	pushthis 
22:	storeg 2
24:	pushthis 
25:	storeg 1
27:	allocEventQ 0
allocE: 
29:	rtnAlloc 1
31:	toSuper 28
doE: 
34:	mvStack
35:	rtnInner


Class this descInx:31 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	setThisStack
15:	pushthis 
16:	rtn D


Class X_asString descInx:32 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushText 1
9:	pushthis 
10:	rstoreg 2
12:	rtnAlloc 1
doE: 
14:	doEventQ 
15:	mvStack
16:	pushthis 
17:	innerP 2
19:	rpopThisObj
20:	setThisStack
21:	pushthis 
22:	rtn D


Class LIB descInx:33 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 34 3 1
14:	rpop 
15:	pushthis 
16:	invoke 38 4 1
22:	rpop 
23:	pushthis 
24:	invoke 82 5 1
30:	rpop 
31:	rtnAlloc 1
doE: 
33:	doEventQ 
34:	mvStack
35:	setThisStack
36:	pushthis 
37:	rtn D


Class BasicIO descInx:34 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 35 2 1
14:	rpop 
15:	pushthis 
16:	invoke 36 3 1
22:	rpop 
23:	rtnAlloc 1
doE: 
25:	doEventQ 
26:	mvStack
27:	setThisStack
28:	pushthis 
29:	rtn D


Class keyboard descInx:35 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class screen descInx:36 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	rpushg 1
10:	invoke 37 2 1
16:	rpop 
17:	rtnAlloc 1
doE: 
19:	doEventQ 
20:	mvStack
21:	setThisStack
22:	pushthis 
23:	rtn D


Class Lock descInx:37 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class Dimensions descInx:38 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 66 2 1
14:	rpop 
15:	pushthis 
16:	invoke 72 3 1
22:	rpop 
23:	rtnAlloc 1
doE: 
25:	doEventQ 
26:	mvStack
27:	setThisStack
28:	pushthis 
29:	rtn D


Class Dimension descInx:39 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	innerP 8
14:	rpopThisObj
15:	setThisStack
16:	pushthis 
17:	rtn D


Class Unit descInx:40 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	mvStack
allocE: 
2:	rtnAlloc 1
doE: 
4:	mvStack
5:	setThisStack
6:	pushthis 
7:	rtn D


Class PrimaryUnit#44 descInx:44 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	invoke 40 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class MultArgL#45 descInx:45 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	invoke 40 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class MultArgR#46 descInx:46 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	invoke 40 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class MultRes#47 descInx:47 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	invoke 40 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class float descInx:48 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	mvStack
allocE: 
2:	rtnAlloc 1
doE: 
4:	mvStack
5:	setThisStack
6:	pushthis 
7:	rtn D


Class toPrimary descInx:49 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	invokeVal 40 1 0
13:	rpop 
14:	rtnAlloc 1
doE: 
16:	doEventQ 
17:	mvStack
18:	pushthis 
19:	innerP 2
21:	rpopThisObj
22:	setThisStack
23:	pushthis 
24:	rtn D


Class fromPrimary descInx:50 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	jmpFalse 13
4:	pushthis 
5:	vassign 2 2 0
10:	jmp 20
13:	invokeVal 40 1 0
19:	rpop 
20:	tstOriginNone 
21:	rstore 1
23:	allocEventQ 0
25:	mvStack
allocE: 
26:	rtnAlloc 1
doE: 
28:	doEventQ 
29:	mvStack
30:	pushthis 
31:	innerP 2
33:	rpopThisObj
34:	setThisStack
35:	pushthis 
36:	rtn D


Class print descInx:51 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushText 1
13:	invoke 52 0 0
19:	rpop 
20:	pushthis 
21:	innerP 2
23:	rpopThisObj
24:	pushc 58
26:	%prim put 2
28:	pushthis 
29:	rpushg 1
31:	fvpushg 1
33:	%prim printf 142
35:	vpop 
36:	setThisStack
37:	pushthis 
38:	rtn D


Class print descInx:52 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	invoke 55 0 0
18:	rpop 
19:	setThisStack
20:	pushthis 
21:	rtn D


Class repeat$53 descInx:53 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	rpushg 1
18:	pushthis 
19:	rpushg 1
21:	pushg 3
23:	xpushg 1 0 1
27:	%prim put 2
29:	setThisStack
30:	pushthis 
31:	rtn D


Class put descInx:54 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class for:to:repeat$55 descInx:55 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	invoke 15 0 0
17:	pushg 2
19:	pushthis 
20:	storeg 2
22:	pushthis 
23:	storeg 1
25:	allocEventQ 0
allocE: 
27:	rtnAlloc 1
29:	toSuper 28
doE: 
32:	mvStack
33:	rtnInner


Class putFloat descInx:56 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	fstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	setThisStack
15:	pushthis 
16:	rtn D


Class _doIt descInx:57 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushg 3
16:	pushthis 
17:	rpushg 1
19:	pushg 2
21:	le
22:	jmpFalse 36
25:	pushthis 
26:	invoke 59 0 0
32:	rpop 
33:	jmp 44
36:	pushthis 
37:	invoke 62 0 0
43:	rpop 
44:	setThisStack
45:	pushthis 
46:	rtn D


Class <= descInx:58 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	jmpFalse 13
4:	pushthis 
5:	vassign 4 2 0
10:	jmp 20
13:	invokeVal 31 3 0
19:	rpop 
20:	tstOriginNone 
21:	rstore 1
23:	allocEventQ 0
25:	mvStack
allocE: 
26:	rtnAlloc 1
doE: 
28:	doEventQ 
29:	mvStack
30:	setThisStack
31:	pushthis 
32:	rtn D


Class $59 descInx:59 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	invokev 2 0 0
20:	rpop 
21:	pushthis 
22:	rpushg 1
24:	rpushg 1
26:	pushthis 
27:	rpushg 1
29:	rpushg 1
31:	pushg 3
33:	pushc 1
35:	+
36:	storeg 3
38:	break 1 1 57 0
45:	setThisStack
46:	pushthis 
47:	rtn D


Class $62 descInx:62 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushthis 
17:	rpushg 1
19:	rpushg 1
21:	pushg 3
23:	storeg 3
25:	setThisStack
26:	pushthis 
27:	rtn D


Class symbol descInx:63 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
3:	mvStack
allocE: 
4:	pushText 1
6:	pushthis 
7:	rstoreg 2
9:	rtnAlloc 1
doE: 
11:	doEventQ 
12:	mvStack
13:	pushthis 
14:	innerP 2
16:	rpopThisObj
17:	setThisStack
18:	pushthis 
19:	rtn D


Class gMult descInx:64 objSize:7 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	jmpFalse 13
4:	pushthis 
5:	vassign 4 2 0
10:	jmp 20
13:	invokeVal 40 3 0
19:	rpop 
20:	jmpFalse 32
23:	pushthis 
24:	vassign 2 2 0
29:	jmp 39
32:	invokeVal 40 1 0
38:	rpop 
39:	tstOriginNone 
40:	rstore 1
42:	allocEventQ 0
44:	mvStack
allocE: 
45:	invokeVal 40 5 0
51:	rpop 
52:	rtnAlloc 1
doE: 
54:	doEventQ 
55:	mvStack
56:	pushthis 
57:	pushthis 
58:	fpushg 2
60:	pushthis 
61:	fpushg 4
63:	fmult 
64:	fstoreg 6
66:	setThisStack
67:	pushthis 
68:	rtn D


Class Area descInx:66 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 39
doE: 
17:	mvStack
18:	rtnInner


Class PrimaryUnit#67 descInx:67 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	invoke 68 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class SquareMeter descInx:68 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
1:	rtnAlloc 1
3:	toSuper 40
doE: 
6:	mvStack
7:	rtnInner


Class print descInx:70 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 51
doE: 
17:	mvStack
18:	pushText 14
20:	invoke 52 0 0
26:	rpop 
27:	rtnInner


Class symbol descInx:71 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
allocE: 
3:	pushText 5
5:	pushthis 
6:	rstoreg 2
8:	rtnAlloc 1
10:	toSuper 63
doE: 
13:	mvStack
14:	pushthis 
15:	pushText 6
17:	rswap 0
19:	rstoreg 2
21:	rtnInner


Class Length descInx:72 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 39
doE: 
17:	mvStack
18:	rtnInner


Class PrimaryUnit#73 descInx:73 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	invoke 74 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class Meter descInx:74 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
1:	rtnAlloc 1
3:	toSuper 40
doE: 
6:	mvStack
7:	rtnInner


Class toPrimary descInx:78 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	invokeVal 40 1 0
18:	rpop 
19:	rtnAlloc 1
21:	toSuper 49
doE: 
24:	mvStack
25:	pushthis 
26:	pushthis 
27:	rpushg 1
29:	fvpushg 1
31:	fstoreg 2
33:	rtnInner


Class fromPrimary descInx:79 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	jmpFalse 19
10:	pushthis 
11:	vassign 2 2 0
16:	jmp 26
19:	invokeVal 40 1 0
25:	rpop 
26:	tstOriginNone 
27:	rstore 1
29:	allocEventQ 0
allocE: 
31:	rtnAlloc 1
33:	toSuper 50
doE: 
36:	mvStack
37:	pushthis 
38:	rpushg 1
40:	pushthis 
41:	fpushg 2
43:	fvstoreg 1
45:	rtnInner


Class print descInx:80 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 51
doE: 
17:	mvStack
18:	pushText 14
20:	invoke 52 0 0
26:	rpop 
27:	rtnInner


Class symbol descInx:81 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
allocE: 
3:	pushText 5
5:	pushthis 
6:	rstoreg 2
8:	rtnAlloc 1
10:	toSuper 63
doE: 
13:	mvStack
14:	pushthis 
15:	pushText 6
17:	rswap 0
19:	rstoreg 2
21:	rtnInner


Class StringLib descInx:82 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	saveStringOrigin
7:	mvStack
allocE: 
8:	rtnAlloc 1
doE: 
10:	doEventQ 
11:	mvStack
12:	setThisStack
13:	pushthis 
14:	rtn D


Class Boolean descInx:83 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	mvStack
allocE: 
2:	rtnAlloc 1
doE: 
4:	mvStack
5:	setThisStack
6:	pushthis 
7:	rtn D


Class <= descInx:84 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	rshiftup 1
3:	tstOriginNone 
4:	rstore 1
6:	allocEventQ 0
8:	pushthis 
9:	rpushg 1
11:	rshiftdown 1
13:	pushthis 
14:	rstoreg 2
16:	tstOriginNone 
17:	rstore 1
19:	allocEventQ 0
21:	mvStack
allocE: 
22:	pushthis 
23:	invoke 85 4 1
29:	rpop 
doE: 
30:	doEventQ 
31:	mvStack
32:	setThisStack
33:	pushthis 
34:	rtn D


Class loop descInx:85 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	rpushg 1
17:	invoke 15 0 0
23:	pushg 2
25:	storeg 3
27:	pushthis 
28:	pushthis 
29:	rpushg 1
31:	rpushg 2
33:	invoke 15 0 0
39:	pushg 2
41:	storeg 4
43:	pushthis 
44:	pushg 3
46:	pushthis 
47:	pushg 4
49:	lt
50:	jmpFalse 64
53:	pushthis 
54:	invoke 87 0 0
60:	rpop 
61:	jmp 72
64:	pushthis 
65:	invoke 88 0 0
71:	rpop 
72:	pushthis 
73:	invoke 89 0 0
79:	rpop 
80:	setThisStack
81:	pushthis 
82:	rtn D


Class $87 descInx:87 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushthis 
15:	rpushg 1
17:	pushg 3
19:	storeg 2
21:	setThisStack
22:	pushthis 
23:	rtn D


Class $88 descInx:88 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushthis 
15:	rpushg 1
17:	pushg 4
19:	storeg 2
21:	setThisStack
22:	pushthis 
23:	rtn D


Class matchEq descInx:89 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	invoke 90 0 0
18:	rpop 
19:	pushthis 
20:	invoke 93 0 0
26:	rpop 
27:	pushthis 
28:	invoke 96 0 0
34:	rpop 
35:	setThisStack
36:	pushthis 
37:	rtn D


Class isEmpty descInx:90 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushg 3
18:	pushc 0
20:	eq 
21:	jmpFalse 32
24:	pushthis 
25:	invoke 91 0 0
31:	rpop 
32:	pushthis 
33:	rpushg 1
35:	rpushg 1
37:	pushg 4
39:	pushc 0
41:	eq 
42:	jmpFalse 53
45:	pushthis 
46:	invoke 92 0 0
52:	rpop 
53:	setThisStack
54:	pushthis 
55:	rtn D


Class $91 descInx:91 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 1
20:	pushthis 
21:	rpushg 1
23:	rpushg 1
25:	rpushg 1
27:	pushg 3
29:	pushthis 
30:	rpushg 1
32:	rpushg 1
34:	rpushg 1
36:	pushg 4
38:	le
39:	storeg 3
41:	break 2 2 89 0
48:	setThisStack
49:	pushthis 
50:	rtn D


Class $92 descInx:92 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 1
20:	invoke 27 0 0
26:	pushg 1
28:	storeg 3
30:	break 2 2 89 0
37:	setThisStack
38:	pushthis 
39:	rtn D


Class loop descInx:93 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushthis 
15:	rpushg 1
17:	pushg 2
19:	pushc 1
21:	+
22:	storeg 2
24:	pushthis 
25:	rpushg 1
27:	pushthis 
28:	rpushg 1
30:	rpushg 1
32:	rpushg 1
34:	rpushg 1
36:	pushthis 
37:	rpushg 1
39:	pushg 2
41:	xpushg 1 0 1
45:	storeg 3
47:	pushthis 
48:	rpushg 1
50:	pushthis 
51:	rpushg 1
53:	rpushg 1
55:	rpushg 1
57:	rpushg 2
59:	pushthis 
60:	rpushg 1
62:	pushg 2
64:	xpushg 1 0 1
68:	storeg 4
70:	pushthis 
71:	rpushg 1
73:	pushg 3
75:	pushthis 
76:	rpushg 1
78:	pushg 4
80:	eq 
81:	jmpFalse 92
84:	pushthis 
85:	invoke 94 0 0
91:	rpop 
92:	setThisStack
93:	pushthis 
94:	rtn D


Class $94 descInx:94 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushg 2
18:	pushthis 
19:	rpushg 1
21:	rpushg 1
23:	rpushg 1
25:	pushg 2
27:	lt
28:	jmpFalse 39
31:	pushthis 
32:	invoke 95 0 0
38:	rpop 
39:	setThisStack
40:	pushthis 
41:	rtn D


Class $95 descInx:95 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	break 2 1 93 0
18:	setThisStack
19:	pushthis 
20:	rtn D


Class doit descInx:96 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushg 3
16:	pushthis 
17:	rpushg 1
19:	pushg 4
21:	eq 
22:	jmpFalse 36
25:	pushthis 
26:	invoke 97 0 0
32:	rpop 
33:	jmp 44
36:	pushthis 
37:	invoke 98 0 0
43:	rpop 
44:	setThisStack
45:	pushthis 
46:	rtn D


Class $97 descInx:97 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 1
20:	pushthis 
21:	rpushg 1
23:	rpushg 1
25:	rpushg 1
27:	pushg 3
29:	pushthis 
30:	rpushg 1
32:	rpushg 1
34:	rpushg 1
36:	pushg 4
38:	le
39:	storeg 3
41:	break 2 2 89 0
48:	setThisStack
49:	pushthis 
50:	rtn D


Class $98 descInx:98 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 1
20:	pushthis 
21:	rpushg 1
23:	rpushg 1
25:	pushg 3
27:	pushthis 
28:	rpushg 1
30:	rpushg 1
32:	pushg 4
34:	lt
35:	storeg 3
37:	break 2 2 89 0
44:	setThisStack
45:	pushthis 
46:	rtn D


Class puttext descInx:100 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	innerP 2
17:	rpopThisObj
18:	setThisStack
19:	pushthis 
20:	rtn D


Class putint descInx:101 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	innerP 2
17:	rpopThisObj
18:	setThisStack
19:	pushthis 
20:	rtn D


Class workspace descInx:102 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 103 2 1
14:	rpop 
15:	rtnAlloc 1
doE: 
17:	doEventQ 
18:	mvStack
19:	setThisStack
20:	pushthis 
21:	rtn D


Class tinyS descInx:103 objSize:6 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 104 2 1
14:	rpop 
15:	pushthis 
16:	invoke 105 3 1
22:	rpop 
23:	pushc 100
25:	pushthis 
26:	storeg 4
28:	rtnAlloc 1
doE: 
30:	doEventQ 
31:	mvStack
32:	pushthis 
33:	invoke 106 0 0
39:	rpop 
40:	pushthis 
41:	pushc 98
43:	invoke 107 0 0
49:	rpop 
50:	pushthis 
51:	rpushg 2
53:	pushc 99
55:	storeg 2
57:	pushthis 
58:	rpushg 2
60:	invoke 108 0 0
66:	rpop 
67:	pushthis 
68:	pushc 100
70:	storeg 5
72:	pushthis 
73:	pushg 5
75:	%prim put 2
77:	pushthis 
78:	pushc 101
80:	storeg 5
82:	pushthis 
83:	pushg 5
85:	%prim put 2
87:	pushthis 
88:	invoke 109 0 1
94:	rpop 
95:	pushthis 
96:	pushc 103
98:	storeg 5
100:	pushthis 
101:	invoke 111 0 0
107:	rpop 
108:	pushthis 
109:	invoke 113 0 0
115:	rpop 
116:	pushthis 
117:	invoke 119 0 0
123:	rpop 
124:	pushthis 
125:	invoke 122 0 0
131:	rpop 
132:	pushc 122
134:	%prim put 2
136:	invoke 129 0 0
142:	rpop 
143:	pushthis 
144:	invoke 130 0 0
150:	rpop 
151:	pushthis 
152:	pushg 5
154:	pushc 81
156:	eq 
157:	pushc 100
159:	pushc 100
161:	eq 
162:	andd
163:	jmpFalse 177
166:	pushthis 
167:	invoke 135 0 0
173:	rpop 
174:	jmp 185
177:	pushthis 
178:	invoke 136 0 0
184:	rpop 
185:	pushthis 
186:	invoke 137 0 0
192:	rpop 
193:	pushthis 
194:	invoke 140 0 0
200:	rpop 
201:	invoke 129 0 0
207:	rpop 
208:	pushthis 
209:	invoke 151 0 0
215:	rpop 
216:	setThisStack
217:	pushthis 
218:	rtn D


Class R_foo descInx:104 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class S_foo descInx:105 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushc 101
9:	pushthis 
10:	storeg 2
12:	rtnAlloc 1
doE: 
14:	doEventQ 
15:	mvStack
16:	setThisStack
17:	pushthis 
18:	rtn D


Class A_foo descInx:106 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushc 97
13:	%prim put 2
15:	setThisStack
16:	pushthis 
17:	rtn D


Class B_foo descInx:107 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	pushg 2
17:	%prim put 2
19:	setThisStack
20:	pushthis 
21:	rtn D


Class C_foo descInx:108 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushg 2
16:	%prim put 2
18:	setThisStack
19:	pushthis 
20:	rtn D


Class nest_foo descInx:109 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	pushg 5
17:	pushc 1
19:	+
20:	storeg 2
22:	pushthis 
23:	pushc 100
25:	pushc 3
27:	+
28:	storeg 2
30:	setThisStack
31:	pushthis 
32:	rtn D


Class asg_foo descInx:111 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushc 102
9:	pushthis 
10:	storeg 2
12:	pushthis 
13:	invoke 112 4 1
19:	rpop 
20:	rtnAlloc 1
doE: 
22:	doEventQ 
23:	mvStack
24:	pushthis 
25:	pushc 102
27:	storeg 3
29:	pushthis 
30:	pushg 3
32:	%prim put 2
34:	pushthis 
35:	rpushg 4
37:	pushthis 
38:	rpushg 1
40:	pushg 5
42:	storeg 2
44:	pushthis 
45:	rpushg 4
47:	pushg 2
49:	%prim put 2
51:	pushthis 
52:	rpushg 4
54:	pushthis 
55:	rpushg 4
57:	pushg 2
59:	pushc 1
61:	+
62:	storeg 2
64:	pushthis 
65:	rpushg 1
67:	pushthis 
68:	rpushg 4
70:	pushg 2
72:	storeg 5
74:	pushthis 
75:	rpushg 1
77:	pushg 5
79:	%prim put 2
81:	pushthis 
82:	rpushg 4
84:	pushc 105
86:	storeg 2
88:	pushthis 
89:	rpushg 4
91:	pushg 2
93:	%prim put 2
95:	setThisStack
96:	pushthis 
97:	rtn D


Class fox descInx:112 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class try_val descInx:113 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	invokeVal 114 3 0
13:	rpop 
14:	rtnAlloc 1
doE: 
16:	doEventQ 
17:	mvStack
18:	pushthis 
19:	pushc 106
21:	storeg 5
23:	pushthis 
24:	pushg 5
26:	pushc 58
28:	%prim put 2
30:	pushthis 
31:	pushg 5
33:	%prim put 2
35:	pushthis 
36:	rdouble 
37:	rpushg 1
39:	mkValueProxy 114 3 0 0
46:	invoke 115 0 0
52:	rpop 
53:	pushthis 
54:	pushFloatConst 3.140000
63:	fstoreg 2
65:	pushthis 
66:	fpushg 2
68:	pushFloatConst 3.140000
77:	feq
78:	jmpFalse 92
81:	pushthis 
82:	invoke 117 0 0
88:	rpop 
89:	jmp 100
92:	pushthis 
93:	invoke 118 0 0
99:	rpop 
100:	setThisStack
101:	pushthis 
102:	rtn D


Class V_foo descInx:114 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	mvStack
allocE: 
2:	rtnAlloc 1
doE: 
4:	mvStack
5:	setThisStack
6:	pushthis 
7:	rtn D


Class V_bar descInx:115 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushc 107
16:	vstoreg 2
18:	pushthis 
19:	rpushg 1
21:	vpushg 2
23:	%prim put 2
25:	setThisStack
26:	pushthis 
27:	rtn D


Class $117 descInx:117 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushc 108
13:	%prim put 2
15:	setThisStack
16:	pushthis 
17:	rtn D


Class $118 descInx:118 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	fpushg 2
16:	%prim printf 142
18:	vpop 
19:	setThisStack
20:	pushthis 
21:	rtn D


Class string_foo descInx:119 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushText 1
9:	pushthis 
10:	rstoreg 2
12:	rtnAlloc 1
doE: 
14:	doEventQ 
15:	mvStack
16:	pushthis 
17:	pushText 2
19:	rswap 0
21:	rstoreg 2
23:	pushthis 
24:	rpushg 2
26:	invoke 52 0 0
32:	rpop 
33:	pushthis 
34:	pushthis 
35:	rpushg 1
37:	pushText 6
39:	invoke 120 0 1
45:	rswap 0
47:	rstoreg 3
49:	pushthis 
50:	pushthis 
51:	rpushg 3
53:	rswap 0
55:	rstoreg 4
57:	pushthis 
58:	rpushg 4
60:	invoke 121 0 0
66:	rpop 
67:	setThisStack
68:	pushthis 
69:	rtn D


Class Record descInx:120 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 1
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	setThisStack
15:	pushthis 
16:	rtn D


Class print descInx:121 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 2
16:	invoke 52 0 0
22:	rpop 
23:	setThisStack
24:	pushthis 
25:	rtn D


Class point_foo descInx:122 objSize:7 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushc 114
9:	pushc 115
11:	invokeVal 123 1 0
17:	rpop 
18:	pushc 0
20:	pushc 0
22:	invokeVal 123 3 0
28:	rpop 
29:	pushc 120
31:	pushc 121
33:	invokeVal 124 5 0
39:	rpop 
40:	rtnAlloc 1
doE: 
42:	doEventQ 
43:	mvStack
44:	pushthis 
45:	rdouble 
46:	rpushg 1
48:	mkValueProxy 123 1 0 0
55:	invoke 125 0 0
61:	rpop 
62:	pushthis 
63:	pushc 116
65:	pushc 117
67:	pushc 0
69:	vpop 
70:	saveAndSetThis 
71:	invokeVal 123 1 0
77:	rpop 
78:	restoreThis 
79:	pushthis 
80:	rdouble 
81:	rpushg 1
83:	mkValueProxy 123 1 0 0
90:	invoke 125 0 0
96:	rpop 
97:	pushthis 
98:	rdouble 
99:	rpushg 1
101:	mkValueProxy 123 1 0 0
108:	pushc 2
110:	pushc 2
112:	invoke 126 0 0
118:	rpop 
119:	pushthis 
120:	pushthis 
121:	pushValue 2 2
125:	vassign 4 2 0
130:	pushthis 
131:	rdouble 
132:	rpushg 1
134:	mkValueProxy 123 3 0 0
141:	invoke 125 0 0
147:	rpop 
148:	pushthis 
149:	rdouble 
150:	rpushg 1
152:	mkValueProxy 124 5 0 0
159:	invoke 128 0 0
165:	rpop 
166:	setThisStack
167:	pushthis 
168:	rtn D


Class point descInx:123 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	vstoreg 2
4:	pushthis 
5:	vstoreg 1
7:	mvStack
allocE: 
8:	rtnAlloc 1
doE: 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class PositivePoint descInx:124 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	vstoreg 2
4:	pushthis 
5:	vstoreg 1
allocE: 
7:	rtnAlloc 1
9:	toSuper 123
doE: 
12:	mvStack
13:	rtnInner


Class print descInx:125 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	vpushg 1
16:	%prim put 2
18:	pushthis 
19:	rpushg 1
21:	vpushg 2
23:	%prim put 2
25:	setThisStack
26:	pushthis 
27:	rtn D


Class move descInx:126 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 3
4:	pushthis 
5:	storeg 2
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
12:	mvStack
allocE: 
13:	rtnAlloc 1
doE: 
15:	doEventQ 
16:	mvStack
17:	pushthis 
18:	rpushg 1
20:	pushthis 
21:	rpushg 1
23:	vpushg 1
25:	pushthis 
26:	pushg 2
28:	+
29:	vstoreg 1
31:	pushthis 
32:	rpushg 1
34:	pushthis 
35:	rpushg 1
37:	vpushg 2
39:	pushthis 
40:	pushg 3
42:	+
43:	vstoreg 2
45:	setThisStack
46:	pushthis 
47:	rtn D


Class check descInx:127 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	innerP 2
14:	rpopThisObj
15:	setThisStack
16:	pushthis 
17:	rtn D


Class check descInx:128 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 127
doE: 
17:	mvStack
18:	pushthis 
19:	rpushg 1
21:	invoke 125 0 0
27:	rpop 
28:	rtnInner


Class newline descInx:129 objSize:0 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
3:	mvStack
allocE: 
4:	rtnAlloc 1
doE: 
6:	doEventQ 
7:	mvStack
8:	pushc 10
10:	%prim put 2
12:	setThisStack
13:	pushthis 
14:	rtn D


Class virt_foo descInx:130 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushthis 
8:	rpushg 1
10:	pushText 1
12:	invoke 131 3 1
18:	rpop 
19:	rtnAlloc 1
doE: 
21:	doEventQ 
22:	mvStack
23:	pushthis 
24:	pushthis 
25:	rpushg 1
27:	pushText 4
29:	invoke 131 0 1
35:	rswap 0
37:	rstoreg 2
39:	pushthis 
40:	rpushg 2
42:	invokev 2 0 0
46:	rpop 
47:	pushthis 
48:	rpushg 3
50:	invoke 133 0 0
56:	rpop 
57:	setThisStack
58:	pushthis 
59:	rtn D


Class ShowRecord descInx:131 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	rshiftup 1
3:	tstOriginNone 
4:	rstore 1
6:	pushthis 
7:	rpushg 1
9:	rshiftdown 1
11:	pushthis 
12:	rstoreg 2
14:	tstOriginNone 
15:	rstore 1
17:	allocEventQ 1
allocE: 
19:	rtnAlloc 1
21:	toSuper 120
doE: 
24:	mvStack
25:	rtnInner


Class show descInx:132 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	innerP 2
14:	rpopThisObj
15:	setThisStack
16:	pushthis 
17:	rtn D


Class show descInx:133 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 132
doE: 
17:	mvStack
18:	pushthis 
19:	rpushg 1
21:	invoke 121 0 0
27:	rpop 
28:	rtnInner


Class $135 descInx:135 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushc 81
13:	%prim put 2
15:	setThisStack
16:	pushthis 
17:	rtn D


Class $136 descInx:136 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushc 69
13:	%prim put 2
15:	setThisStack
16:	pushthis 
17:	rtn D


Class string_foo_LE descInx:137 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushText 1
9:	pushthis 
10:	rstoreg 2
12:	pushText 2
14:	pushthis 
15:	rstoreg 3
17:	rtnAlloc 1
doE: 
19:	doEventQ 
20:	mvStack
21:	pushthis 
22:	pushText 8
24:	rswap 0
26:	rstoreg 2
28:	pushthis 
29:	rpushg 2
31:	pushthis 
32:	rpushg 3
34:	invokev 3 0 0
38:	pushg 3
40:	jmpFalse 54
43:	pushthis 
44:	invoke 138 0 0
50:	rpop 
51:	jmp 62
54:	pushthis 
55:	invoke 139 0 0
61:	rpop 
62:	setThisStack
63:	pushthis 
64:	rtn D


Class $138 descInx:138 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushc 70
13:	%prim put 2
15:	setThisStack
16:	pushthis 
17:	rtn D


Class $139 descInx:139 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushc 63
13:	%prim put 2
15:	setThisStack
16:	pushthis 
17:	rtn D


Class I2F_foo descInx:140 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushc 12
14:	i2f
15:	fstoreg 2
17:	pushc 32
19:	%prim put 2
21:	pushthis 
22:	fpushg 2
24:	%prim printf 142
26:	vpop 
27:	pushthis 
28:	pushFloatConst 3.140000
37:	f2i
38:	storeg 4
40:	pushc 32
42:	%prim put 2
44:	pushthis 
45:	pushg 4
47:	invoke 141 0 0
53:	rpop 
54:	pushthis 
55:	pushc 19
57:	storeg 4
59:	pushthis 
60:	pushthis 
61:	pushg 4
63:	i2f
64:	fstoreg 2
66:	pushc 32
68:	%prim put 2
70:	pushthis 
71:	fpushg 2
73:	%prim printf 142
75:	vpop 
76:	pushthis 
77:	pushFloatConst 2.040000
86:	fstoreg 2
88:	pushthis 
89:	pushthis 
90:	fpushg 2
92:	f2i
93:	storeg 4
95:	pushc 32
97:	%prim put 2
99:	pushthis 
100:	pushg 4
102:	invoke 141 0 0
108:	rpop 
109:	pushthis 
110:	pushthis 
111:	fpushg 2
113:	pushc 7
115:	i2f
116:	fplus 
117:	fstoreg 2
119:	pushc 32
121:	%prim put 2
123:	pushthis 
124:	fpushg 2
126:	%prim printf 142
128:	vpop 
129:	pushthis 
130:	pushc 12
132:	pushthis 
133:	fpushg 2
135:	f2i
136:	+
137:	i2f
138:	fstoreg 2
140:	pushc 32
142:	%prim put 2
144:	pushthis 
145:	fpushg 2
147:	%prim printf 142
149:	vpop 
150:	pushthis 
151:	pushthis 
152:	pushg 4
154:	i2f
155:	pushFloatConst 6.600000
164:	f2i
165:	+
166:	storeg 4
168:	pushc 32
170:	%prim put 2
172:	pushthis 
173:	pushg 4
175:	invoke 141 0 0
181:	rpop 
182:	pushthis 
183:	pushFloatConst 5.500000
192:	pushthis 
193:	pushg 4
195:	i2f
196:	fplus 
197:	f2i
198:	storeg 4
200:	pushc 32
202:	%prim put 2
204:	pushthis 
205:	pushg 4
207:	invoke 141 0 0
213:	rpop 
214:	setThisStack
215:	pushthis 
216:	rtn D


Class putint descInx:141 objSize:4 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushc 20
9:	pushthis 
10:	pushc 1
12:	allocIndexed 142 1 0 
17:	pushthis 
18:	rstoreg 2
20:	rtnAlloc 1
doE: 
22:	doEventQ 
23:	mvStack
24:	pushthis 
25:	pushthis 
26:	pushg 1
28:	pushc 0
30:	lt
31:	storeg 4
33:	pushthis 
34:	pushg 4
36:	jmpFalse 47
39:	pushthis 
40:	invoke 144 0 0
46:	rpop 
47:	pushthis 
48:	invoke 152 0 0
54:	rpop 
55:	pushthis 
56:	pushg 4
58:	jmpFalse 69
61:	pushthis 
62:	invoke 146 0 0
68:	rpop 
69:	pushthis 
70:	invoke 149 0 0
76:	rpop 
77:	setThisStack
78:	pushthis 
79:	rtn D


Class Indexed descInx:142 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class $144 descInx:144 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushc 0
16:	pushthis 
17:	rpushg 1
19:	pushg 1
21:	-
22:	storeg 1
24:	setThisStack
25:	pushthis 
26:	rtn D


Class $146 descInx:146 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushc 45
13:	%prim put 2
15:	setThisStack
16:	pushthis 
17:	rtn D


Class repeat$147 descInx:147 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	rpushg 4
17:	pushg 3
19:	pushc 1
21:	+
22:	pushthis 
23:	rpushg 1
25:	pushg 3
27:	-
28:	storeg 2
30:	pushc 48
32:	pushthis 
33:	rpushg 1
35:	rpushg 4
37:	rpushg 2
39:	pushthis 
40:	pushg 2
42:	xpushg 1 0 1
46:	+
47:	%prim put 2
49:	setThisStack
50:	pushthis 
51:	rtn D


Class for:to:repeat$149 descInx:149 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	pushg 3
11:	pushthis 
12:	storeg 2
14:	pushthis 
15:	storeg 1
17:	allocEventQ 0
allocE: 
19:	rtnAlloc 1
21:	toSuper 28
doE: 
24:	mvStack
25:	rtnInner


Class unit_foo descInx:151 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	invokeVal 74 1 0
13:	rpop 
14:	invokeVal 68 3 0
20:	rpop 
21:	rtnAlloc 1
doE: 
23:	doEventQ 
24:	mvStack
25:	pushthis 
26:	pushc 10
28:	i2f
29:	fstoreg 2
31:	pushthis 
32:	rdouble 
33:	rpushg 1
35:	rpushg 1
37:	rpushg 1
39:	rpushg 3
41:	rpushg 4
43:	rpushg 3
45:	mkValueProxy 74 1 0 0
52:	invoke 80 0 0
58:	rpop 

59:	pushthis 

60:	pushthis 
61:	fpushg 2
63:	pushc 12
65:	i2f
66:	fmult 
67:	fstoreg 4
69:	pushthis 
70:	rdouble 
71:	rpushg 1
73:	rpushg 1
75:	rpushg 1
77:	rpushg 3
79:	rpushg 4
81:	rpushg 2
83:	mkValueProxy 68 3 0 0
90:	invoke 70 0 0
96:	rpop 
97:	setThisStack
98:	pushthis 
99:	rtn D


Class loop descInx:152 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushthis 
15:	rpushg 1
17:	pushg 3
19:	pushc 1
21:	+
22:	storeg 3
24:	pushthis 
25:	rpushg 1
27:	rpushg 2
29:	pushthis 
30:	rpushg 1
32:	pushg 1
34:	pushc 10
36:	modd
37:	pushthis 
38:	rpushg 1
40:	pushg 3
42:	xstoreg 1 0 1 
46:	pushthis 
47:	rpushg 1
49:	pushthis 
50:	rpushg 1
52:	pushg 1
54:	pushc 10
56:	idiv
57:	storeg 1
59:	pushthis 
60:	rpushg 1
62:	pushg 1
64:	pushc 0
66:	gt 
67:	jmpFalse 78
70:	pushthis 
71:	invoke 157 0 0
77:	rpop 
78:	setThisStack
79:	pushthis 
80:	rtn D


Class $157 descInx:157 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	break 1 1 152 0
18:	setThisStack
19:	pushthis 
20:	rtn D


Class + descInx:158 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	pushText 1
12:	pushthis 
13:	rstoreg 3
15:	rtnAlloc 1
doE: 
17:	doEventQ 
18:	mvStack
19:	pushthis 
20:	pushthis 
21:	rpushg 1
23:	invoke 15 0 0
29:	pushg 2
31:	storeg 4
33:	pushthis 
34:	invoke 159 0 0
40:	rpop 
41:	setThisStack
42:	pushthis 
43:	rtn D


Class doplus descInx:159 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushthis 
8:	rpushg 1
10:	pushg 4
12:	pushthis 
13:	rpushg 1
15:	rpushg 2
17:	invoke 15 0 0
23:	pushg 2
25:	+
26:	pushthis 
27:	pushc 1
29:	allocIndexed 142 1 0 
34:	pushthis 
35:	rstoreg 4
37:	rtnAlloc 1
doE: 
39:	doEventQ 
40:	mvStack
41:	pushthis 
42:	invoke 161 0 0
48:	rpop 
49:	pushthis 
50:	invoke 163 0 0
56:	rpop 
57:	pushthis 
58:	rpushg 1
60:	pushthis 
61:	rpushg 4
63:	%prim asString 118
65:	rswap 0
67:	rstoreg 3
69:	setThisStack
70:	pushthis 
71:	rtn D


Class repeat$160 descInx:160 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	pushthis 
17:	rpushg 1
19:	rpushg 4
21:	rpushg 1
23:	rpushg 1
25:	pushthis 
26:	rpushg 1
28:	pushg 3
30:	xpushg 1 0 1
34:	storeg 2
36:	pushthis 
37:	rpushg 1
39:	rpushg 4
41:	rpushg 4
43:	pushthis 
44:	rpushg 1
46:	rpushg 4
48:	pushg 2
50:	pushthis 
51:	rpushg 1
53:	pushg 3
55:	xstoreg 1 0 1 
59:	setThisStack
60:	pushthis 
61:	rtn D


Class for:to:repeat$161 descInx:161 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	pushg 4
13:	pushthis 
14:	storeg 2
16:	pushthis 
17:	storeg 1
19:	allocEventQ 0
allocE: 
21:	rtnAlloc 1
23:	toSuper 28
doE: 
26:	mvStack
27:	rtnInner


Class repeat$162 descInx:162 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	pushthis 
17:	rpushg 1
19:	rpushg 4
21:	rpushg 1
23:	rpushg 2
25:	pushthis 
26:	rpushg 1
28:	pushg 3
30:	xpushg 1 0 1
34:	storeg 2
36:	pushthis 
37:	rpushg 1
39:	rpushg 4
41:	pushthis 
42:	rpushg 1
44:	rpushg 4
46:	rpushg 1
48:	pushg 4
50:	pushthis 
51:	rpushg 1
53:	pushg 3
55:	+
56:	storeg 3
58:	pushthis 
59:	rpushg 1
61:	rpushg 4
63:	rpushg 4
65:	pushthis 
66:	rpushg 1
68:	rpushg 4
70:	pushg 2
72:	pushthis 
73:	rpushg 1
75:	rpushg 4
77:	pushg 3
79:	xstoreg 1 0 1 
83:	setThisStack
84:	pushthis 
85:	rtn D


Class for:to:repeat$163 descInx:163 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	rpushg 2
13:	invoke 15 0 0
19:	pushg 2
21:	pushthis 
22:	storeg 2
24:	pushthis 
25:	storeg 1
27:	allocEventQ 0
allocE: 
29:	rtnAlloc 1
31:	toSuper 28
doE: 
34:	mvStack
35:	rtnInner


Class asString descInx:164 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushText 1
9:	pushthis 
10:	rstoreg 2
12:	rtnAlloc 1
doE: 
14:	doEventQ 
15:	mvStack
16:	setThisStack
17:	pushthis 
18:	rtn D


Class valProx descInx:165 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	0


Class VM descInx:166 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	invoke 1 0 1
8:	stop 
9:	rtn D


Class EventProcessor descInx:167 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	stop 


Class ThreadStub descInx:168 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
doE: 
1:	call D
3:	stop 

