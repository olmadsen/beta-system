
 CLASS BETAworld 21 1 BETA 2
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:a
 -- OG:before:super.gen: "inner(Object) "
 -- INV:gen: "inner(Object) " 
 -- needorigin: "inner(Object) " 
 -- needOrigin:E: "inner(Object) "  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(Object) " rec: "inner(Object) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  E.ATd.desc: 
 --  %basic 101
 --  in inner: ref Object
 --  E.ATd.IT: 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- doNeedOrigin:Ex: "inner(Object) "originIsValueObj: false 
 --  origin.isPrimitive: true 
 -- KUK 
 -- after:needOrigin: "inner(Object) " 
 -- doNeedOrigin:E: "inner(Object) " 
 -- computeAdrX:superAdj: 0 "inner(Object) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(Object) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(Object) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:- 
 --  rec:  "inner(Object) "E:  "inner(Object) "
 -- INV:gen:E.loadArgs "inner(Object) "
 -- INV:gen:after:E.loadArgs "inner(Object) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  inner(Object) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(Object) "ptnKind: 0 useRtnV: 
 --  false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:inner(Object) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:inner(Object) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:inner(Object) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS BETAworld 1 1 Object 21
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 pushThis 
 saveBETAworld
 mvStack 
 pushThis 
 -- before objTmpStack:add:  2   "BETA "
 invoke BETA 2 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  33   "LIB "
 invoke LIB 33 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  127   "workspace "
 invoke workspace 127 4 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS BETA 2 1 BETAworld 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: 
 --  ascii: obj 
 --     asciiFoo: 
 --        msg1:  -- obj
 --           _put('F')DI:isConst: true isBasicValue: false primNo: 0 
 -- DI:isConst: ascii 
 -- DI:off: 2 this: 
 --  ascii: obj 
 --     asciiFoo: 
 --        msg1:  -- obj
 --           _put('F')
 --  
 pushThis 
 -- before objTmpStack:add:  3   "ascii "
 invoke ascii 3 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- DI:gen: "console: ref ConsoleIF " DI:isConst: false 
 --  isBasicValue: false primNo: 0 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:2 objSize:3 isIndexed:0

 CLASS ascii 3 1 BETA 2
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "nl: val 10 " DI:isConst: true isBasicValue: true 
 --  primNo: 1 
 -- DI:valueObj: nl 
 -- OG:before:super.gen: "10 "
 -- INV:gen: "10 " 
 -- needorigin: "10 " 
 -- needOrigin:E: "10 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "10 " rec: "10 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "10 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "10 "E:  "10 "
 -- INV:gen:E.loadArgs "10 "
 -- INV:gen:after:E.loadArgs "10 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "10 "
 pushc 10
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- DI:store:basicValue: off: 1 NewOff: 2 
 pushThis 
 storeg nl 2
 -- DI:gen: "cr: val 13 " DI:isConst: true isBasicValue: true 
 --  primNo: 1 
 -- DI:valueObj: cr 
 -- OG:before:super.gen: "13 "
 -- INV:gen: "13 " 
 -- needorigin: "13 " 
 -- needOrigin:E: "13 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "13 " rec: "13 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "13 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "13 "E:  "13 "
 -- INV:gen:E.loadArgs "13 "
 -- INV:gen:after:E.loadArgs "13 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "13 "
 pushc 13
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- DI:store:basicValue: off: 2 NewOff: 3 
 pushThis 
 storeg cr 3
 -- DI:gen: "null: val 0 " DI:isConst: true isBasicValue: true 
 --  primNo: 1 
 -- DI:valueObj: null 
 -- OG:before:super.gen: "0 "
 -- INV:gen: "0 " 
 -- needorigin: "0 " 
 -- needOrigin:E: "0 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "0 " rec: "0 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "0 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "0 "E:  "0 "
 -- INV:gen:E.loadArgs "0 "
 -- INV:gen:after:E.loadArgs "0 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0 "
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- DI:store:basicValue: off: 3 NewOff: 4 
 pushThis 
 storeg null 4
 -- DI:gen: "newline: var char " DI:isConst: false isBasicValue: 
 --  true primNo: 3 
 -- DI:gen:primitiveType: newline 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: 
 --  newline := nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  
 pushThis 
 -- AssignmentStatement:gen: 
 --  
 --  newline := nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  right.label: "ObjectGenerator "
 --  nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  
 -- OG:before:super.gen: "
 --  nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1 "
 -- INV:gen: 
 --  nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  
 pushc 10
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg ascii$3 5
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0

 CLASS Value 4 0 BETA 2 isValueObj
 mvStack 
 rtnAlloc 1
DO:
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:0 isIndexed:0

 CLASS integer 5 0 BETA 2 isValueObj
 mvStack 
 -- DI:gen: "_thisBasicValue: var Universal " DI:isConst: false 
 --  isBasicValue: true primNo: 1 
 -- DI:gen:primitiveType: _thisBasicValue 
 rtnAlloc 1
DO:
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS universal 6 0 BETA 2 isValueObj
 mvStack 
 rtnAlloc 1
DO:
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:0 isIndexed:0

 CLASS char 7 0 BETA 2 isValueObj
 mvStack 
 -- DI:gen: "_thisBasicValue: var Universal " DI:isConst: false 
 --  isBasicValue: true primNo: 1 
 -- DI:gen:primitiveType: _thisBasicValue 
 rtnAlloc 1
DO:
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS ConsoleIF 8 1 BETA 2
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS put 9 1 ConsoleIF 8
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS String 10 0 StringLib 107
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:2 objSize:0 isIndexed:1

 CLASS = 11 1 Value 4
 jmpFalse  L3
 pushThis 
 -- vassign:B: Veq off: 4 size: 2 mode: 0 
 vassign  4 2 0
 jmp L4
 L3:
 invokeVal  Veq 31 3
 rpop 
 L4:
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in Veq: var this(Value) " DI:isConst: false 
 --  isBasicValue: false primNo: 18 
 -- DI:isConst: Veq 
 -- inArg: in Veq: var this(Value) 
 -- DI:gen: "out Beq: var boolean " DI:isConst: false isBasicValue: 
 --  true primNo: 4 
 -- DI:gen:primitiveType: Beq 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(= ) "
 -- INV:gen: "inner(= ) " 
 -- needorigin: "inner(= ) " 
 -- needOrigin:E: "inner(= ) "  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(= ) " rec: "inner(= ) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  E.ATd.desc: 
 --  %basic 101
 --  in inner: ref Object
 --  E.ATd.IT: 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- doNeedOrigin:Ex: "inner(= ) "originIsValueObj: false 
 --  origin.isPrimitive: true 
 -- KUK 
 -- after:needOrigin: "inner(= ) " 
 -- doNeedOrigin:E: "inner(= ) " 
 -- computeAdrX:superAdj: 0 "inner(= ) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(= ) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(= ) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:- 
 --  rec:  "inner(= ) "E:  "inner(= ) "
 -- INV:gen:E.loadArgs "inner(= ) "
 -- INV:gen:after:E.loadArgs "inner(= ) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  inner(= ) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(= ) "ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:inner(= ) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:inner(= ) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:inner(= ) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0

 CLASS = 13 1 String 10
 -- vdtTableCopy: I:1:11 I:2:0
 rShiftUp  1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- super =
 pushThis 
 rpushg iOrigin 1
 rShiftDown  1
 pushThis 
 rstoreg  Veq 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in Veq: var this(Value) " DI:isConst: false 
 --  isBasicValue: false primNo: 18 
 -- DI:isConst: Veq 
 -- inArg: in Veq: var this(Value) 
 -- DI:gen: "out Beq: var boolean " DI:isConst: false isBasicValue: 
 --  true primNo: 4 
 -- DI:gen:primitiveType: Beq 
DO:
 doEventQ
 mvStack 
 L1:
 pushThis 
 -- before objTmpStack:add:  14   "loop "
 invoke loop 14 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS loop 14 1 = 13
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "c1: var char " DI:isConst: false isBasicValue: true 
 --  primNo: 3 
 -- DI:gen:primitiveType: c1 
 -- DI:gen: "c2: var char " DI:isConst: false isBasicValue: true 
 --  primNo: 3 
 -- DI:gen:primitiveType: c2 
 -- DI:gen: "L: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: L 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "L := length " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "L := length " right.label: "ObjectGenerator ""length " 
 -- OG:before:super.gen: "length "
 -- INV:gen: "length " 
 -- needorigin: "length " 
 -- needOrigin:E: "length "  E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  Ex: "length " rec: "length " E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  E.ATd.desc: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  E.ATd.IT: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- doNeedOrigin:Ex: "length "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "length " 
 -- doNeedOrigin:E: "length " 
 -- computeAdrX:superAdj: 0 "length " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "length " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 2 isValueObj: false 
 --  origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- items:goOrigin:encOG: "= "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg =$13 1
 -- computeAdrX:isLast:E:  "length "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 --  rec:  "length "E:  "length "
 -- INV:gen:E.loadArgs "length "
 -- INV:gen:after:E.loadArgs "length "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- ptn:invoke: "length "E: "length "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "length " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- assign:adr.store:A: 
 storeg loop$14 4
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "if (L <> Veq.length) :then 
 --     leave(loop) "
 -- INV:gen: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  
 -- needorigin: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  
 -- needOrigin:E: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  rec: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 -- \
 --      %globals inSub
 --  E.ATd.desc: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  E.ATd.IT: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "if (L <> Veq.length) :then 
 --     leave(loop) "E:  "
 --  if (L <> Veq.length) :then 
 --     leave(loop) "
 -- INV:gen:E.loadArgs "if (L <> Veq.length) :then 
 --     leave(loop) "
 -- INV:gen:after:E.loadArgs "
 --  if (L <> Veq.length) :then 
 --     leave(loop) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "
 --  if (L <> Veq.length) :then 
 --     leave(loop) "
 -- OG:before:super.gen: "(L <> Veq.length) "
 -- INV:gen: "(L <> Veq.length) " 
 -- needorigin: "(L <> Veq.length) " 
 -- needOrigin:E: "(L <> Veq.length) "  E.ATd: 
 --  <>  : 
 --     %basic 55
 --     in V: var integer
 --     out B: var boolean
 --  Ex: "(L <> Veq.length) " rec: "(L <> Veq.length) " E.ATd: 
 --  <>  : 
 --     %basic 55
 --     in V: var integer
 --     out B: var boolean
 --  E.ATd.desc: 
 --  %basic 55
 --  in V: var integer
 --  out B: var boolean
 --  E.ATd.IT: 
 --  %basic 55
 --  in V: var integer
 --  out B: var boolean
 -- \
 --   
 -- doNeedOrigin:Ex: "(L <> Veq.length) "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(L <> Veq.length) " 
 -- doNeedOrigin:E: "(L <> Veq.length) " 
 -- computeAdrX:superAdj: 0 "(L <> Veq.length) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(L <> Veq.length) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "L <> Veq.length "superAdj: 0 
 -- computeAdrX:isLast:E:  "L <> Veq.length "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "L <> Veq.length "E:  "L <> Veq.length "
 -- INV:gen:E.loadArgs "L <> Veq.length "
 -- BinaryExp:loadArgs: "L <> Veq.length " superAdj: 0 
 -- INV:gen: "L " 
 -- needorigin: "L " 
 -- needOrigin:E: "L "  E.ATd: "L: var integer " Ex: "L " rec: "L " 
 --  E.ATd: "L: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L " 
 -- doNeedOrigin:E: "L " 
 -- computeAdrX:superAdj: 0 "L " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "L "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 --  rec:  "L "E:  "L "
 -- INV:gen:E.loadArgs "L "
 -- INV:gen:after:E.loadArgs "L "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- DI:invoke: "L: var integer " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L isNotRemote: true 
 pushg 4 loop$14
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:end:off: 4 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- NonVirt: "<> Veq.length " "ObjectInvocation_Binary " ActArg: "
 --  Veq.length "isValue: false formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "<> Veq.length "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "Veq.length "
 -- INV:gen: "Veq.length " 
 -- needorigin: "Veq.length " 
 -- needOrigin:E: "length "  E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  Ex: "length " rec: "Veq " E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  E.ATd.desc: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  E.ATd.IT: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- doNeedOrigin:Ex: "length "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "length " 
 -- doNeedOrigin:E: "length " 
 -- computeAdrX:superAdj: 0 "Veq.length " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Veq " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- computeAdrX:En: 2 pRec: "Veq " rec: "Veq " E: "length " 
 --  A.E: none 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "Veq " rec: "Veq " E: "length " 
 --  rec.ATd: "in Veq: var this(Value) " rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --     inner(= )
 --  
 --  recA: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 --  pRecA: none 
 -- pRec: "Veq " rec: "Veq " E: "length " 
 --  false true 
 -- computeAdrX:before:rec:: "Veq " 
 -- OI:invoke:before:ATdx.invoke: var Veq 
 -- DI:invoke: "in Veq: var this(Value) " 
 -- isValueObj:isAdr: true objSize: 2  rec "Veq ",E: "length ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- Address:loadAdr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 rpushg loop$14 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- computeAdrX:after:rec.invoke: "Veq " 
 -- computeAdrX:isLast:E:  "length "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 --  rec:  "Veq "E:  "length "
 -- INV:gen:E.loadArgs "length "
 -- INV:gen:after:E.loadArgs "length "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- ptn:invoke: "length "E: "length "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "Veq " 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "Veq.length ":isBasicVal: true 
 -- case:B: Veq.length ObjectGenerator 1 0 0 false false 
 -- end:loadArgs:NonVirt: "<> Veq.length "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:after:E.loadArgs "L <> Veq.length "
 --  OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L <> Veq.length "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- BinaryExp:invoke: "L "rec: "L <> Veq.length "
 -- M: "<> Veq.length "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:before:ATdx.invoke: pattern <>   
 -- ptn:invoke: "<>   "E: "<> Veq.length "ptnKind: 0 useRtnV: true 
 ne
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<> Veq.length":rec:L 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<> Veq.length":rec:L 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  18   "$18 "
 invoke $18 18 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- AssignmentStatement:gen: "beq := true " 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- AssignmentStatement:gen: 
 --  "beq := true " right.label: "ObjectGenerator ""true " 
 -- OG:before:super.gen: "true "
 -- INV:gen: "true " 
 -- needorigin: "true " 
 -- needOrigin:E: "true "  E.ATd: 
 --  True: 
 --     %globals
 --     out B: var boolean
 --     B := 1
 --  Ex: "true " rec: "true " E.ATd: 
 --  True: 
 --     %globals
 --     out B: var boolean
 --     B := 1
 --  E.ATd.desc: 
 --  %globals
 --  out B: var boolean
 --  B := 1
 --  E.ATd.IT: 
 --  %globals
 --  out B: var boolean
 --  B := 1
 -- \
 --   
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %globals
 --     out B: var boolean
 --     B := 1
 --  
 -- after:needOrigin: "true " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "true "E:  "true "
 -- INV:gen:E.loadArgs "true "
 -- INV:gen:after:E.loadArgs "true "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "true "
 -- OI:invoke:before:ATdx.invoke: pattern True 
 -- ptn:invoke: "True "E: "true "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "true " 
 --  adr:none 
 invoke True 23 0 0
 -- global:pushOut: B off: 1 
 pushg 1 
 -- callInvoke:after:pushOut: 1 
 -- GeneralPTN:invoke:after:callInvoke: 1 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg =$13 3
 -- assign:adr.store:B: 
 pushThis 
 -- before objTmpStack:add:  30   "for:to:repeat$30 "
 invoke for:to:repeat$30 30 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS length 15 1 String 10
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "out V: var integer " DI:isConst: false isBasicValue: 
 --  true primNo: 1 
 -- DI:gen:primitiveType: V 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "
 --  V := get[0] -- actually an index error, accessing length " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "V := get[0] -- actually an index error, accessing length " 
 --  right.label: "ObjectGenerator ""
 --  get[0] -- actually an index error, accessing length " 
 -- OG:before:super.gen: "
 --  get[0] -- actually an index error, accessing length "
 -- INV:gen: "get[0] -- actually an index error, accessing length " 
 -- needorigin: "
 --  get[0] -- actually an index error, accessing length " 
 -- needOrigin:E: "
 --  get[0] -- actually an index error, accessing length "  E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  Ex: "get[0] -- actually an index error, accessing length " rec: "
 --  get[0] -- actually an index error, accessing length " E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  E.ATd.desc: 
 --  %basic 117
 --  out ch: var char
 --  E.ATd.IT: 
 --  %basic 117
 --  out ch: var char
 --  
 -- doNeedOrigin:Ex: "
 --  get[0] -- actually an index error, accessing length "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "
 --  get[0] -- actually an index error, accessing length " 
 -- doNeedOrigin:E: "
 --  get[0] -- actually an index error, accessing length " 
 -- computeAdrX:superAdj: 0 "
 --  get[0] -- actually an index error, accessing length " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "
 --  get[0] -- actually an index error, accessing length " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "length "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg length$15 1
 -- computeAdrX:isLast:E:  "
 --  get[0] -- actually an index error, accessing length "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, accessing length":rec:- 
 --  rec:  "get[0] -- actually an index error, accessing length "E:  "
 --  get[0] -- actually an index error, accessing length "
 -- INV:gen:E.loadArgs "
 --  get[0] -- actually an index error, accessing length "
 -- NonVirt: "get[0] -- actually an index error, accessing length " "
 --  ObjectInvocation_KeyWord " ActArg: "0 "isValue: true formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  get[0] -- actually an index error, accessing length " isCompositeValueObj: false 
 -- OG:before:super.gen: "0 "
 -- INV:gen: "0 " 
 -- needorigin: "0 " 
 -- needOrigin:E: "0 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "0 " rec: "0 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "0 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "0 "E:  "0 "
 -- INV:gen:E.loadArgs "0 "
 -- INV:gen:after:E.loadArgs "0 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0 "
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "0 ":isBasicVal: true 
 -- case:B: 0 ObjectGenerator 1 1 1 false true 
 -- end:loadArgs:NonVirt: "
 --  get[0] -- actually an index error, accessing length "
 -- INV:gen:after:E.loadArgs "
 --  get[0] -- actually an index error, accessing length "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "
 --  get[0] -- actually an index error, accessing length "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, accessing length":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- ptn:invoke: "get[inx: var integer] "E: "
 --  get[0] -- actually an index error, accessing length "ptnKind: 0 useRtnV: true 
 xpushg  inx 1 0 1
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, accessing length":rec:get[0] -- actually an index error, accessing length 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, accessing length":rec:get[0] -- actually an index error, accessing length 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, accessing length":rec:get[0] -- actually an index error, accessing length 
 -- assign:adr.store:A: 
 storeg length$15 2
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS this 31 1 BETA 2
 pushThis 
 rstoreg  this 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in this: ref Object " DI:isConst: false isBasicValue: 
 --  false primNo: 64 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS X_asString 32 1 Object 21
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "out S: var LIB.StringLib.String " DI:isConst: false 
 --  isBasicValue: false primNo: 5 
 -- DI:StringVar "out S: var LIB.StringLib.String "
 pushText ""
 pushThis 
 rstoreg  S 2
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(X_asString) "
 -- INV:gen: "inner(X_asString) " 
 -- needorigin: "inner(X_asString) " 
 -- needOrigin:E: "inner(X_asString) "  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(X_asString) " rec: "inner(X_asString) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  E.ATd.desc: 
 --  %basic 101
 --  in inner: ref Object
 --  E.ATd.IT: 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- doNeedOrigin:Ex: "inner(X_asString) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inner(X_asString) " 
 -- doNeedOrigin:E: "inner(X_asString) " 
 -- computeAdrX:superAdj: 0 "inner(X_asString) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(X_asString) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(X_asString) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:- 
 --  rec:  "inner(X_asString) "E:  "inner(X_asString) "
 -- INV:gen:E.loadArgs "inner(X_asString) "
 -- INV:gen:after:E.loadArgs "inner(X_asString) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  inner(X_asString) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(X_asString) "ptnKind: 0 useRtnV: 
 --  false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:inner(X_asString) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:inner(X_asString) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:inner(X_asString) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS LIB 33 1 BETAworld 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 pushThis 
 -- before objTmpStack:add:  34   "BasicIO "
 invoke BasicIO 34 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  38   "Dimensions "
 invoke Dimensions 38 4 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  107   "StringLib "
 invoke StringLib 107 5 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- DI:gen: "x_dummy_LIB: var integer " DI:isConst: false 
 --  isBasicValue: true primNo: 1 
 -- DI:gen:primitiveType: x_dummy_LIB 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0

 CLASS BasicIO 34 1 LIB 33
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: 
 --  keyboard: obj 
 --     %Public
 --     readLine: 
 --        out M: var LIB.StringLib.StringDI:isConst: true isBasicValue: false primNo: 0 
 -- DI:isConst: keyboard 
 -- DI:off: 2 this: 
 --  keyboard: obj 
 --     %Public
 --     readLine: 
 --        out M: var LIB.StringLib.String
 --  
 pushThis 
 -- before objTmpStack:add:  35   "keyboard "
 invoke keyboard 35 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- DI:gen: 
 --  screen: obj 
 --     L: obj Lock
 --     %Public
 --     init: DI:isConst: true isBasicValue: false primNo: 0 
 -- DI:isConst: screen 
 -- DI:off: 3 this: 
 --  screen: obj 
 --     L: obj Lock
 --     %Public
 --     init: 
 --  
 pushThis 
 -- before objTmpStack:add:  36   "screen "
 invoke screen 36 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS keyboard 35 1 BasicIO 34
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS screen 36 1 BasicIO 34
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "L: obj Lock " DI:isConst: true isBasicValue: false 
 --  primNo: 0 
 -- DI:isConst: L 
 -- DI:off: 2 this: "L: obj Lock " 
 --  
 -- OG:before:super.gen: "Lock "
 -- INV:gen: "Lock " 
 -- needorigin: "Lock " 
 -- needOrigin:E: "Lock "  E.ATd: 
 --  Lock: 
 --     dummy: var integer
 --     %Public
 --     M: var integerEx: "Lock " rec: "Lock " E.ATd: 
 --  Lock: 
 --     dummy: var integer
 --     %Public
 --     M: var integerE.ATd.desc: 
 --  dummy: var integer
 --  %Public
 --  M: var integer
 --  init: E.ATd.IT: 
 --  dummy: var integer
 --  %Public
 --  M: var integer
 --  init: 
 -- doNeedOrigin:Ex: "Lock "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "Lock " 
 -- doNeedOrigin:E: "Lock " 
 -- computeAdrX:superAdj: 0 "Lock " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Lock " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "screen "on: 1 isValueObj: false 
 --  origin: BasicIO origin:isValueObj: false 
 rpushg screen$36 1
 -- computeAdrX:isLast:E:  "Lock "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:- 
 --  rec:  "Lock "E:  "Lock "
 -- INV:gen:E.loadArgs "Lock "
 -- INV:gen:after:E.loadArgs "Lock "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "Lock "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern Lock 
 -- ptn:invoke: "Lock "E: "Lock "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 2 rec: "Lock " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:Lock 
 invoke Lock 37 2 1
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:Lock 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:Lock 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:Lock 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS Lock 37 1 BasicIO 34
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "dummy: var integer " DI:isConst: false isBasicValue: 
 --  true primNo: 1 
 -- DI:gen:primitiveType: dummy 
 -- DI:gen: "M: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: M 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS Dimensions 38 1 LIB 33
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 pushThis 
 -- before objTmpStack:add:  66   "AngularAcceleration "
 invoke AngularAcceleration 66 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  70   "Area "
 invoke Area 70 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  76   "Energy "
 invoke Energy 76 4 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  84   "Force "
 invoke Force 84 5 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  89   "Length "
 invoke Length 89 6 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  99   "Mass "
 invoke Mass 99 7 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  100   "Time "
 invoke Time 100 8 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:8 isIndexed:0

 CLASS Dimension 39 1 Dimensions 38
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(Dimension) "
 -- INV:gen: "inner(Dimension) " 
 -- needorigin: "inner(Dimension) " 
 -- needOrigin:E: "inner(Dimension) "  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(Dimension) " rec: "inner(Dimension) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  E.ATd.desc: 
 --  %basic 101
 --  in inner: ref Object
 --  E.ATd.IT: 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- doNeedOrigin:Ex: "inner(Dimension) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inner(Dimension) " 
 -- doNeedOrigin:E: "inner(Dimension) " 
 -- computeAdrX:superAdj: 0 "inner(Dimension) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(Dimension) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(Dimension) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Dimension)":rec:- 
 --  rec:  "inner(Dimension) "E:  "inner(Dimension) "
 -- INV:gen:E.loadArgs "inner(Dimension) "
 -- INV:gen:after:E.loadArgs "inner(Dimension) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  inner(Dimension) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Dimension)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(Dimension) "ptnKind: 0 useRtnV: 
 --  false 
 pushThis 
 innerP  8
 rpopThisObj 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Dimension)":rec:inner(Dimension) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Dimension)":rec:inner(Dimension) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Dimension)":rec:inner(Dimension) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS PrimaryUnit#44 44 1 Dimension$39 39 isVstub
 invoke Unit 40 0 1
 pushThis 
 rstoreg   2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS MultArgL#45 45 1 Dimension$39 39 isVstub
 invoke Unit 40 0 1
 pushThis 
 rstoreg   2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS MultArgR#46 46 1 Dimension$39 39 isVstub
 invoke Unit 40 0 1
 pushThis 
 rstoreg   2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS MultRes#47 47 1 Dimension$39 39 isVstub
 invoke Unit 40 0 1
 pushThis 
 rstoreg   2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS Unit 40 0 Dimension 39 isValueObj
 mvStack 
 -- DI:gen: "magnitude: var Float " DI:isConst: false isBasicValue: 
 --  true primNo: 9 
 -- DI:gen:primitiveType: magnitude 
 rtnAlloc 1
DO:
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS float 48 0 BETA 2 isValueObj
 mvStack 
 -- DI:gen: "_thisBasicValue: var Float " DI:isConst: false 
 --  isBasicValue: true primNo: 9 
 -- DI:gen:primitiveType: _thisBasicValue 
 rtnAlloc 1
DO:
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS toPrimary 49 1 Unit 40
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "out base: var PrimaryUnit " DI:isConst: false 
 --  isBasicValue: false primNo: 0 
 -- DI:isConst: base 
 -- DI:off: 2 this: "out base: var PrimaryUnit " 
 --  
 -- OG:before:super.gen: "PrimaryUnit "
 -- INV:gen: "PrimaryUnit " 
 -- needorigin: "PrimaryUnit " 
 -- needOrigin:E: "PrimaryUnit "  E.ATd: "PrimaryUnit:< Unit " Ex: "
 --  PrimaryUnit " rec: "PrimaryUnit " E.ATd: "PrimaryUnit:< Unit " E.ATd.desc: 
 --  %unit "U", 1
 --  %public
 --  magnitude: var Float
 --  thisUnit:< UnitE.ATd.IT: " " 
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 -- after:needOrigin: "PrimaryUnit " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "PrimaryUnit "E:  "PrimaryUnit "
 -- INV:gen:E.loadArgs "PrimaryUnit "
 -- INV:gen:after:E.loadArgs "PrimaryUnit "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "
 --  PrimaryUnit "
 -- OI:invoke:before:ATdx.invoke: pattern PrimaryUnit 
 -- ptn:invoke: "PrimaryUnit "E: "PrimaryUnit "ptnKind: 1 useRtnV: 
 --  false 
 -- GeneralPTN:invoke:ptnKind: 1 staticOff: 2 rec: "PrimaryUnit " 
 --  adr:none 
 invokeVal  PrimaryUnit 40 1
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(toPrimary) "
 -- INV:gen: "inner(toPrimary) " 
 -- needorigin: "inner(toPrimary) " 
 -- needOrigin:E: "inner(toPrimary) "  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(toPrimary) " rec: "inner(toPrimary) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  E.ATd.desc: 
 --  %basic 101
 --  in inner: ref Object
 --  E.ATd.IT: 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- doNeedOrigin:Ex: "inner(toPrimary) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inner(toPrimary) " 
 -- doNeedOrigin:E: "inner(toPrimary) " 
 -- computeAdrX:superAdj: 0 "inner(toPrimary) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(toPrimary) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(toPrimary) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(toPrimary)":rec:- 
 --  rec:  "inner(toPrimary) "E:  "inner(toPrimary) "
 -- INV:gen:E.loadArgs "inner(toPrimary) "
 -- INV:gen:after:E.loadArgs "inner(toPrimary) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  inner(toPrimary) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(toPrimary)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(toPrimary) "ptnKind: 0 useRtnV: 
 --  false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(toPrimary)":rec:inner(toPrimary) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(toPrimary)":rec:inner(toPrimary) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(toPrimary)":rec:inner(toPrimary) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS fromPrimary 50 1 Unit 40
 jmpFalse  L3
 pushThis 
 -- vassign:B: base off: 2 size: 2 mode: 0 
 vassign  2 2 0
 jmp L4
 L3:
 invokeVal  base 40 1
 rpop 
 L4:
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in base: var PrimaryUnit " DI:isConst: false 
 --  isBasicValue: false primNo: 0 
 -- DI:isConst: base 
 -- inArg: in base: var PrimaryUnit 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(fromPrimary) "
 -- INV:gen: "inner(fromPrimary) " 
 -- needorigin: "inner(fromPrimary) " 
 -- needOrigin:E: "inner(fromPrimary) "  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(fromPrimary) " rec: "inner(fromPrimary) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  E.ATd.desc: 
 --  %basic 101
 --  in inner: ref Object
 --  E.ATd.IT: 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- doNeedOrigin:Ex: "inner(fromPrimary) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inner(fromPrimary) " 
 -- doNeedOrigin:E: "inner(fromPrimary) " 
 -- computeAdrX:superAdj: 0 "inner(fromPrimary) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(fromPrimary) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(fromPrimary) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(fromPrimary)":rec:- 
 --  rec:  "inner(fromPrimary) "E:  "inner(fromPrimary) "
 -- INV:gen:E.loadArgs "inner(fromPrimary) "
 -- INV:gen:after:E.loadArgs "inner(fromPrimary) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  inner(fromPrimary) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(fromPrimary)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(fromPrimary) "ptnKind: 0 useRtnV: 
 --  false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(fromPrimary)":rec:inner(fromPrimary) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(fromPrimary)":rec:inner(fromPrimary) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(fromPrimary)":rec:inner(fromPrimary) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS print 51 1 Unit 40
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: ""Unit:".print "
 -- INV:gen: ""Unit:".print " 
 -- needorigin: ""Unit:".print " 
 -- needOrigin:E: "print "  E.ATd: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeatEx: ""Unit:" " rec: ""Unit:" " E.ATd: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeatE.ATd.desc: 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])E.ATd.IT: 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- after:needOrigin: ""Unit:" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  ""Unit:" "E:  ""Unit:" "
 -- INV:gen:E.loadArgs ""Unit:" "
 -- INV:gen:after:E.loadArgs ""Unit:" "
 --  OIadr: 
 pushText "Unit:"
 -- IV:gen:checkTail: ""Unit:".print "E: ""Unit:" "tail: "print "
 --   not isLast: false 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: ""Unit:" " 
 --  adr:none 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- OG:before:super.gen: "inner(print) "
 -- INV:gen: "inner(print) " 
 -- needorigin: "inner(print) " 
 -- needOrigin:E: "inner(print) "  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(print) " rec: "inner(print) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  E.ATd.desc: 
 --  %basic 101
 --  in inner: ref Object
 --  E.ATd.IT: 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- doNeedOrigin:Ex: "inner(print) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inner(print) " 
 -- doNeedOrigin:E: "inner(print) " 
 -- computeAdrX:superAdj: 0 "inner(print) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(print) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(print) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(print)":rec:- 
 --  rec:  "inner(print) "E:  "inner(print) "
 -- INV:gen:E.loadArgs "inner(print) "
 -- INV:gen:after:E.loadArgs "inner(print) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  inner(print) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(print)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(print) "ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(print)":rec:inner(print) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(print)":rec:inner(print) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(print)":rec:inner(print) 
 -- OG:before:super.gen: "put(':') "
 -- INV:gen: "put(':') " 
 -- needorigin: "put(':') " 
 -- needOrigin:E: "put(':') "  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put(':') " rec: "put(':') " E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  E.ATd.desc: 
 --  %globals
 --  %basic 2
 --  in ch: val char
 --  E.ATd.IT: 
 --  %globals
 --  %basic 2
 --  in ch: val char
 -- \
 --   
 -- Ex:loadOrgin:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put(':') " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put(':') "E:  "put(':') "
 -- INV:gen:E.loadArgs "put(':') "
 -- NonVirt: "put(':') " "ObjectInvocation_KeyWord " ActArg: "':' "
 --  isValue: true formalArg: "in ch: val char " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(':') " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "':' "
 -- INV:gen: "':' " 
 -- needorigin: "':' " 
 -- needOrigin:E: "':' "  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16Ex: "':' " rec: "':' " E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16E.ATd.desc: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %publicE.ATd.IT: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 -- after:needOrigin: "':' " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "':' "E:  "':' "
 -- INV:gen:E.loadArgs "':' "
 -- INV:gen:after:E.loadArgs "':' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "':' "
 pushc 58
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "':' ":isBasicVal: true 
 -- case:B: ':' ObjectGenerator 3 3 3 false true 
 -- end:loadArgs:NonVirt: "put(':') "
 -- INV:gen:after:E.loadArgs "put(':') "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  put(':') "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put(':') "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- OG:before:super.gen: "putFloat(magnitude) "
 -- INV:gen: "putFloat(magnitude) " 
 -- needorigin: "putFloat(magnitude) " 
 -- needOrigin:E: "putFloat(magnitude) "  E.ATd: 
 --  putFloat: 
 --     %basic 142
 --     in X: var Float
 --     out V: var integer
 --  Ex: "putFloat(magnitude) " rec: "putFloat(magnitude) " E.ATd: 
 --  putFloat: 
 --     %basic 142
 --     in X: var Float
 --     out V: var integer
 --  E.ATd.desc: 
 --  %basic 142
 --  in X: var Float
 --  out V: var integer
 --  E.ATd.IT: 
 --  %basic 142
 --  in X: var Float
 --  out V: var integer
 -- \
 --   
 -- doNeedOrigin:Ex: "putFloat(magnitude) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "putFloat(magnitude) " 
 -- doNeedOrigin:E: "putFloat(magnitude) " 
 -- computeAdrX:superAdj: 0 "putFloat(magnitude) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "
 --  putFloat(magnitude) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "putFloat(magnitude) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putFloat(magnitude)":rec:- 
 --  rec:  "putFloat(magnitude) "E:  "putFloat(magnitude) "
 -- INV:gen:E.loadArgs "putFloat(magnitude) "
 -- NonVirt: "putFloat(magnitude) " "ObjectInvocation_KeyWord " 
 --  ActArg: "magnitude "isValue: false formalArg: "in X: var Float " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "putFloat(magnitude) "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "magnitude "
 -- INV:gen: "magnitude " 
 -- needorigin: "magnitude " 
 -- needOrigin:E: "magnitude "  E.ATd: "magnitude: var Float " Ex: "
 --  magnitude " rec: "magnitude " E.ATd: "magnitude: var Float " E.ATd.desc: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "magnitude " 
 -- doNeedOrigin:E: "magnitude " 
 -- computeAdrX:superAdj: 0 "magnitude " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "magnitude " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "print "on: 1 isValueObj: false 
 --  origin: Unit origin:isValueObj: true 
 rpushg print$51 1
 -- computeAdrX:isLast:E:  "magnitude "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 --  rec:  "magnitude "E:  "magnitude "
 -- INV:gen:E.loadArgs "magnitude "
 -- INV:gen:after:E.loadArgs "magnitude "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude "
 --  :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- DI:invoke: "magnitude: var Float " 
 -- load: 
 --  :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude isNotRemote: true 
 -- load:isValue:E: "magnitude "originIsValue: true 
 --  E.ATd:isValueObj: true 
 -- E.ATd: "magnitude: var Float " 
 --  E.ATd.origin: 
 --  %unit "U", 1
 --  %public
 --  magnitude: var Float
 --  thisUnit:< Unit
 --  (E.ATd.origin.ogOfScope): 
 --  Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 fvpushg 1 Unit$40
 -- OI:invoke:V: adr: 
 --  :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- OI:invoke:X: adr: 
 --  :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- INV:gen:end:off: 1 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- actualArg:isPtn: false formalArg:isPtn: "in X: var Float "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "magnitude ":isBasicVal: true 
 -- case:B: magnitude ObjectGenerator 9 0 9 false false 
 -- end:loadArgs:NonVirt: "putFloat(magnitude) "
 -- INV:gen:after:E.loadArgs "putFloat(magnitude) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  putFloat(magnitude) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putFloat(magnitude)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern putFloat 
 -- ptn:invoke: "putFloat "E: "putFloat(magnitude) "ptnKind: 0 
 --  useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "
 --  putFloat(magnitude) " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putFloat(magnitude)":rec:putFloat(magnitude) 
 %printf_prim 142
 vpop
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putFloat(magnitude)":rec:putFloat(magnitude) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putFloat(magnitude)":rec:putFloat(magnitude) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putFloat(magnitude)":rec:putFloat(magnitude) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS print 52 1 String 10
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 pushThis 
 -- before objTmpStack:add:  55   "for:to:repeat$55 "
 invoke for:to:repeat$55 55 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS for:to:repeat 28 0 BETA 2
 pushThis 
 storeg integer$5 2
 pushThis 
 storeg integer$5 1
 allocEventQ
 mvStack 
 -- DI:gen: "inx: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: inx 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "inx := first " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "inx := first " right.label: "ObjectGenerator ""first " 
 -- OG:before:super.gen: "first "
 -- INV:gen: "first " 
 -- needorigin: "first " 
 -- needOrigin:E: "first "  E.ATd: "first: var integer " Ex: "
 --  first " rec: "first " E.ATd: "first: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "first " 
 -- doNeedOrigin:E: "first " 
 -- computeAdrX:superAdj: 0 "first " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "first " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "first "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:- 
 --  rec:  "first "E:  "first "
 -- INV:gen:E.loadArgs "first "
 -- INV:gen:after:E.loadArgs "first "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "first "
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:- 
 -- OI:invoke:before:ATdx.invoke: var first 
 -- DI:invoke: "first: var integer " 
 -- load: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:first isNotRemote: true 
 pushg 1 for:to:repeat$28
 -- OI:invoke:V: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:first 
 -- OI:invoke:X: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:first 
 -- INV:gen:end:off: 1 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:first 
 -- assign:adr.store:A: 
 storeg for:to:repeat$28 3
 -- assign:adr.store:B: 
 pushThis 
 -- before objTmpStack:add:  57   "_doIt "
 invoke _doIt 57 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:1 objSize:3 isIndexed:0

 CLASS repeat#29 29 0 for:to:repeat$28 28 isVstub
 invoke Object 21 0 0
 pushThis 
 rstoreg   2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:1 objSize:3 isIndexed:0

 CLASS _doIt 57 1 for:to:repeat 28
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  :else 
 --     inx := inx "
 -- INV:gen: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 -- needorigin: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 -- needOrigin:E: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt) E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)rec: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)E.ATd: 
 -- \
 --   if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  E.ATd.desc: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  E.ATd.IT: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  :else 
 --     inx := inx "E:  "
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  :else 
 --     inx := inx "
 -- INV:gen:E.loadArgs "
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  :else 
 --     inx := inx "
 -- INV:gen:after:E.loadArgs "
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  :else 
 --     inx := inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThenElse "
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  :else 
 --     inx := inx "
 -- OG:before:super.gen: "(inx <= last) "
 -- INV:gen: "(inx <= last) " 
 -- needorigin: "(inx <= last) " 
 -- needOrigin:E: "(inx <= last) "  E.ATd: 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  Ex: "(inx <= last) " rec: "(inx <= last) " E.ATd: 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  E.ATd.desc: 
 --  %basic 52
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  E.ATd.IT: 
 --  %basic 52
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 -- \
 --   
 -- doNeedOrigin:Ex: "(inx <= last) "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(inx <= last) " 
 -- doNeedOrigin:E: "(inx <= last) " 
 -- computeAdrX:superAdj: 0 "(inx <= last) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(inx <= last) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "inx <= last "superAdj: 0 
 -- computeAdrX:isLast:E:  "inx <= last "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "inx <= last "E:  "inx <= last "
 -- INV:gen:E.loadArgs "inx <= last "
 -- BinaryExp:loadArgs: "inx <= last " superAdj: 0 
 -- INV:gen: "inx " 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "_doIt "on: 1 isValueObj: false 
 --  origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$57 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 3 for:to:repeat$28
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- NonVirt: "<= last " "ObjectInvocation_Binary " ActArg: "last "
 --  isValue: false formalArg: "in Veq: var this(Value) " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "<= last " isCompositeValueObj: 
 --  true 
 -- OG:before:super.gen: "last "
 -- INV:gen: "last " 
 -- needorigin: "last " 
 -- needOrigin:E: "last "  E.ATd: "last: var integer " Ex: "last " 
 --  rec: "last " E.ATd: "last: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "last " 
 -- doNeedOrigin:E: "last " 
 -- computeAdrX:superAdj: 0 "last " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "last " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "_doIt "on: 1 isValueObj: false 
 --  origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$57 1
 -- computeAdrX:isLast:E:  "last "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:- 
 --  rec:  "last "E:  "last "
 -- INV:gen:E.loadArgs "last "
 -- INV:gen:after:E.loadArgs "last "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "last "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:- 
 -- OI:invoke:before:ATdx.invoke: var last 
 -- DI:invoke: "last: var integer " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:last isNotRemote: true 
 pushg 2 for:to:repeat$28
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:last 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:last 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:last 
 -- vEq: 
 -- end:loadArgs:NonVirt: "<= last "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:after:E.loadArgs "inx <= last "
 --  OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- IV:E.invoke:useRtnVal: true E: BinOp "inx <= last "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- BinaryExp:invoke: "inx "rec: "inx <= last "
 -- M: "<= last "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:before:ATdx.invoke: pattern <=   
 -- ptn:invoke: "<=   "E: "<= last "ptnKind: 1 useRtnV: true 
 -- E: "<= last " rec: "inx ""Invocation "OGx: "integer " 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- rec.ATd: "inx: var integer " 
 -- bobs: 1 OGx: "integer " 
 -- 
 le
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<= last":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<= last":rec:inx 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  59   "$59 "
 invoke $59 59 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L5
 L4:
 pushThis 
 -- before objTmpStack:add:  62   "$62 "
 invoke $62 62 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L5:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $59 59 1 _doIt 57
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "repeat "
 -- INV:gen: "repeat " 
 -- needorigin: "repeat " 
 -- needOrigin:E: "repeat "  E.ATd: "repeat:< object " Ex: "repeat " 
 --  rec: "repeat " E.ATd: "repeat:< object " E.ATd.desc: 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : E.ATd.IT: " " 
 -- doNeedOrigin:Ex: "repeat "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "repeat " 
 -- doNeedOrigin:E: "repeat " 
 -- computeAdrX:superAdj: 0 "repeat " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "repeat " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$59 "on: 2 isValueObj: false 
 --  origin: _doIt origin:isValueObj: false 
 rpushg $59$59 1
 -- items:goOrigin:encOG: "_doIt "on: 1 isValueObj: false 
 --  origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$57 1
 -- computeAdrX:isLast:E:  "repeat "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:- 
 --  rec:  "repeat "E:  "repeat "
 -- INV:gen:E.loadArgs "repeat "
 -- INV:gen:after:E.loadArgs "repeat "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "repeat "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern repeat 
 -- ptn:invoke: "repeat "E: "repeat "ptnKind: 1 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 1 staticOff: 0 rec: "repeat " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:repeat 
 invokev 2 0 repeat$29$29 0
 -- GeneralPTN:invoke:after:pushOut: 
 rpop 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:repeat 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:repeat 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:repeat 
 -- AssignmentStatement:gen: "inx := inx + 1 " 
 pushThis 
 -- items:goOrigin:encOG: "$59 "on: 2 isValueObj: false 
 --  origin: _doIt origin:isValueObj: false 
 rpushg $59$59 1
 -- items:goOrigin:encOG: "_doIt "on: 1 isValueObj: false 
 --  origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$57 1
 -- AssignmentStatement:gen: 
 --  "inx := inx + 1 " right.label: "ObjectGenerator ""inx + 1 " 
 -- OG:before:super.gen: "inx + 1 "
 -- INV:gen: "inx + 1 " 
 -- needorigin: "inx + 1 " 
 -- needOrigin:E: "inx + 1 "  E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  Ex: "inx + 1 " rec: "inx + 1 " E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  E.ATd.desc: 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 --  E.ATd.IT: 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 -- \
 --   
 -- doNeedOrigin:Ex: "inx + 1 "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inx + 1 " 
 -- doNeedOrigin:E: "inx + 1 " 
 -- computeAdrX:superAdj: 0 "inx + 1 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx + 1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "inx + 1 "superAdj: 0 
 -- computeAdrX:isLast:E:  "inx + 1 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "inx + 1 "E:  "inx + 1 "
 -- INV:gen:E.loadArgs "inx + 1 "
 -- BinaryExp:loadArgs: "inx + 1 " superAdj: 0 
 -- INV:gen: "inx " 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$59 "on: 2 isValueObj: false 
 --  origin: _doIt origin:isValueObj: false 
 rpushg $59$59 1
 -- items:goOrigin:encOG: "_doIt "on: 1 isValueObj: false 
 --  origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$57 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 3 for:to:repeat$28
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- NonVirt: "+ 1 " "ObjectInvocation_Binary " ActArg: "1 "isValue: 
 --  true formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ 1 " isCompositeValueObj: false 
 -- OG:before:super.gen: "1 "
 -- INV:gen: "1 " 
 -- needorigin: "1 " 
 -- needOrigin:E: "1 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "1 " rec: "1 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "1 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "1 "E:  "1 "
 -- INV:gen:E.loadArgs "1 "
 -- INV:gen:after:E.loadArgs "1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1 "
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- end:loadArgs:NonVirt: "+ 1 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:after:E.loadArgs "inx + 1 "
 --  OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- IV:E.invoke:useRtnVal: true E: BinOp "inx + 1 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- BinaryExp:invoke: "inx "rec: "inx + 1 "
 -- M: "+ 1 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- ptn:invoke: "+   "E: "+ 1 "ptnKind: 0 useRtnV: true 
 plus
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:inx 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg for:to:repeat$28 3
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "restart(_doIt) "
 -- INV:gen: "restart(_doIt) " 
 -- needorigin: "restart(_doIt) " 
 -- needOrigin:E: "restart(_doIt) "  E.ATd: 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  Ex: "restart(_doIt) " rec: "restart(_doIt) " E.ATd: 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  E.ATd.desc: "%basic 102 " E.ATd.IT: "%basic 102 " 
 -- doNeedOrigin:Ex: "restart(_doIt) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "restart(_doIt) " 
 -- doNeedOrigin:E: "restart(_doIt) " 
 -- computeAdrX:superAdj: 0 "restart(_doIt) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "restart(_doIt) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "restart(_doIt) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:- 
 --  rec:  "restart(_doIt) "E:  "restart(_doIt) "
 -- INV:gen:E.loadArgs "restart(_doIt) "
 -- INV:gen:after:E.loadArgs "restart(_doIt) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  restart(_doIt) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern restart(V: var integer) 
 -- ptn:invoke: "restart(V: var integer) "E: "restart(_doIt) "
 --  ptnKind: 0 useRtnV: false 
 break  1 1 57 0
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:restart(_doIt) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:restart(_doIt) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:restart(_doIt) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $62 62 1 _doIt 57
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "inx := inx " 
 pushThis 
 -- items:goOrigin:encOG: "$62 "on: 2 isValueObj: false 
 --  origin: _doIt origin:isValueObj: false 
 rpushg $62$62 1
 -- items:goOrigin:encOG: "_doIt "on: 1 isValueObj: false 
 --  origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$57 1
 -- AssignmentStatement:gen: 
 --  "inx := inx " right.label: "ObjectGenerator ""inx " 
 -- OG:before:super.gen: "inx "
 -- INV:gen: "inx " 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$62 "on: 2 isValueObj: false 
 --  origin: _doIt origin:isValueObj: false 
 rpushg $62$62 1
 -- items:goOrigin:encOG: "_doIt "on: 1 isValueObj: false 
 --  origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$57 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 3 for:to:repeat$28
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- assign:adr.store:A: 
 storeg for:to:repeat$28 3
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS if:then 20 0 BETA 2
 pushThis 
 storeg Boolean$108 1
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:1 objSize:1 isIndexed:0

 CLASS thenPart#22 22 0 if:then$20 20 isVstub
 invoke Object 21 0 0
 pushThis 
 rstoreg   2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:1 objSize:3 isIndexed:0

 CLASS repeat$53 53 1 for:to:repeat$55 55
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "put(get[inx]) "
 -- INV:gen: "put(get[inx]) " 
 -- needorigin: "put(get[inx]) " 
 -- needOrigin:E: "put(get[inx]) "  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put(get[inx]) " rec: "put(get[inx]) " E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  E.ATd.desc: 
 --  %globals
 --  %basic 2
 --  in ch: val char
 --  E.ATd.IT: 
 --  %globals
 --  %basic 2
 --  in ch: val char
 -- \
 --   
 -- Ex:loadOrgin:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put(get[inx]) " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put(get[inx]) "E:  "put(get[inx]) "
 -- INV:gen:E.loadArgs "put(get[inx]) "
 -- NonVirt: "put(get[inx]) " "ObjectInvocation_KeyWord " ActArg: "
 --  get[inx] "isValue: false formalArg: "in ch: val char " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(get[inx]) "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "get[inx] "
 -- INV:gen: "get[inx] " 
 -- needorigin: "get[inx] " 
 -- needOrigin:E: "get[inx] "  E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  Ex: "get[inx] " rec: "get[inx] " E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  E.ATd.desc: 
 --  %basic 117
 --  out ch: var char
 --  E.ATd.IT: 
 --  %basic 117
 --  out ch: var char
 --  
 -- doNeedOrigin:Ex: "get[inx] "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "get[inx] " 
 -- doNeedOrigin:E: "get[inx] " 
 -- computeAdrX:superAdj: 0 "get[inx] " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "get[inx] " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$53 "on: 3 isValueObj: false 
 --  origin: for:to:repeat$55 origin:isValueObj: false 
 rpushg repeat$53$53 1
 -- items:goOrigin:encOG: "for:to:repeat$55 "on: 2 isValueObj: 
 --  false 
 --  origin: print origin:isValueObj: false 
 rpushg for:to:repeat$55$55 4
 -- items:goOrigin:encOG: "print "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg print$52 1
 -- computeAdrX:isLast:E:  "get[inx] "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 --  rec:  "get[inx] "E:  "get[inx] "
 -- INV:gen:E.loadArgs "get[inx] "
 -- NonVirt: "get[inx] " "ObjectInvocation_KeyWord " ActArg: "inx "
 --  isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx] " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "inx "
 -- INV:gen: "inx " 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$53 "on: 1 isValueObj: false 
 --  origin: for:to:repeat$55 origin:isValueObj: false 
 rpushg repeat$53$53 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 3 for:to:repeat$55$55
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "get[inx] "
 -- INV:gen:after:E.loadArgs "get[inx] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx] "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- ptn:invoke: "get[inx: var integer] "E: "get[inx] "ptnKind: 0 
 --  useRtnV: true 
 xpushg  inx 1 0 1
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "get[inx] ":isBasicVal: true 
 -- case:B: get[inx] ObjectGenerator 3 117 117 false false 
 -- end:loadArgs:NonVirt: "put(get[inx]) "
 -- INV:gen:after:E.loadArgs "put(get[inx]) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  put(get[inx]) "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put(get[inx]) "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS put 54 0 BETA 2
 pushThis 
 storeg char$7 1
 allocEventQ
 mvStack 
 -- DI:gen: "in ch: val char " DI:isConst: true isBasicValue: true 
 --  primNo: 3 
 -- DI:gen:primitiveType: ch 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS for:to:repeat$55 55 4 print 52
 -- vdtTableCopy: I:1:28 V:2:29
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- NonVirt: 
 --  for(1):to(length):repeat
 --     put(get[inx])
 --  "ObjectInvocation_KeyWord " ActArg: "1 "isValue: true formalArg: "
 --  first: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  for(1):to(length):repeat
 --     put(get[inx])
 --   " isCompositeValueObj: false 
 -- OG:before:super.gen: "1 "
 -- INV:gen: "1 " 
 -- needorigin: "1 " 
 -- needOrigin:E: "1 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "1 " rec: "1 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "1 " 
 -- IV:after:computeAdr:superAdj: 4 
 --  rec:  "1 "E:  "1 "
 -- INV:gen:E.loadArgs "1 "
 -- INV:gen:after:E.loadArgs "1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1 "
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "first: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- end:loadArgs:NonVirt: "for(1):to(length):repeat
 --     put(get[inx])
 --   "
 -- NonVirt: 
 --  for(1):to(length):repeat
 --     put(get[inx])
 --  "ObjectInvocation_KeyWord " ActArg: "length "isValue: false 
 --  formalArg: "last: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  for(1):to(length):repeat
 --     put(get[inx])
 --   " isCompositeValueObj: false 
 -- OG:before:super.gen: "length "
 -- INV:gen: "length " 
 -- needorigin: "length " 
 -- needOrigin:E: "length "  E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  Ex: "length " rec: "length " E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  E.ATd.desc: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  E.ATd.IT: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- doNeedOrigin:Ex: "length "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "length " 
 -- doNeedOrigin:E: "length " 
 -- computeAdrX:superAdj: 4 "length " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "length " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 rpushg print$52 4
 -- items:goOrigin:encOG: "print "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg print$52 1
 -- computeAdrX:isLast:E:  "length "
 -- IV:after:computeAdr:superAdj: 4 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 --  rec:  "length "E:  "length "
 -- INV:gen:E.loadArgs "length "
 -- INV:gen:after:E.loadArgs "length "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- ptn:invoke: "length "E: "length "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "length " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- actualArg:isPtn: true formalArg:isPtn: "last: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "length ":isBasicVal: true 
 -- case:B: length ObjectGenerator 1 0 0 false false 
 -- end:loadArgs:NonVirt: "for(1):to(length):repeat
 --     put(get[inx])
 --   "
 pushThis 
 storeg integer$5 2
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- DI:gen: "inx: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: inx 
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0

 CLASS putFloat 56 1 BETA 2
 pushThis 
 fstoreg 2 X
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in X: var Float " DI:isConst: false isBasicValue: true 
 --  primNo: 9 
 -- DI:gen:primitiveType: X 
 -- DI:gen: "out V: var integer " DI:isConst: false isBasicValue: 
 --  true primNo: 1 
 -- DI:gen:primitiveType: V 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS symbol 63 1 Dimension 39
 allocEventQ
 mvStack 
 -- DI:gen: "out T: var StringLib.String " DI:isConst: false 
 --  isBasicValue: false primNo: 5 
 -- DI:StringVar "out T: var StringLib.String "
 pushText ""
 pushThis 
 rstoreg  T 2
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(Symbol) "
 -- INV:gen: "inner(Symbol) " 
 -- needorigin: "inner(Symbol) " 
 -- needOrigin:E: "inner(Symbol) "  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(Symbol) " rec: "inner(Symbol) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  E.ATd.desc: 
 --  %basic 101
 --  in inner: ref Object
 --  E.ATd.IT: 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- doNeedOrigin:Ex: "inner(Symbol) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inner(Symbol) " 
 -- doNeedOrigin:E: "inner(Symbol) " 
 -- computeAdrX:superAdj: 0 "inner(Symbol) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(Symbol) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(Symbol) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Symbol)":rec:- 
 --  rec:  "inner(Symbol) "E:  "inner(Symbol) "
 -- INV:gen:E.loadArgs "inner(Symbol) "
 -- INV:gen:after:E.loadArgs "inner(Symbol) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  inner(Symbol) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Symbol)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(Symbol) "ptnKind: 0 useRtnV: 
 --  false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Symbol)":rec:inner(Symbol) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Symbol)":rec:inner(Symbol) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Symbol)":rec:inner(Symbol) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS gMult 64 1 Dimension 39
 jmpFalse  L3
 pushThis 
 -- vassign:B: R off: 4 size: 2 mode: 0 
 vassign  4 2 0
 jmp L4
 L3:
 invokeVal  R 40 3
 rpop 
 L4:
 jmpFalse  L5
 pushThis 
 -- vassign:B: L off: 2 size: 2 mode: 0 
 vassign  2 2 0
 jmp L6
 L5:
 invokeVal  L 40 1
 rpop 
 L6:
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in L: var MultArgL " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 -- DI:isConst: L 
 -- inArg: in L: var MultArgL 
 -- DI:gen: "in R: var MultArgR " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 -- DI:isConst: R 
 -- inArg: in R: var MultArgR 
 -- DI:gen: "out U: var MultRes " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 -- DI:isConst: U 
 -- DI:off: 6 this: "out U: var MultRes " 
 --  
 -- OG:before:super.gen: "MultRes "
 -- INV:gen: "MultRes " 
 -- needorigin: "MultRes " 
 -- needOrigin:E: "MultRes "  E.ATd: "MultRes:< Unit " Ex: "
 --  MultRes " rec: "MultRes " E.ATd: "MultRes:< Unit " E.ATd.desc: 
 --  %unit "U", 1
 --  %public
 --  magnitude: var Float
 --  thisUnit:< UnitE.ATd.IT: " " 
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 -- after:needOrigin: "MultRes " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "MultRes "E:  "MultRes "
 -- INV:gen:E.loadArgs "MultRes "
 -- INV:gen:after:E.loadArgs "MultRes "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "MultRes "
 -- OI:invoke:before:ATdx.invoke: pattern MultRes 
 -- ptn:invoke: "MultRes "E: "MultRes "ptnKind: 1 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 1 staticOff: 6 rec: "MultRes " 
 --  adr:none 
 invokeVal  MultRes 40 5
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "
 --  U.magnitude := L.magnitude * R.magnitude " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "U.magnitude := L.magnitude * R.magnitude " right.label: "
 --  ObjectGenerator ""L.magnitude * R.magnitude " 
 -- OG:before:super.gen: "L.magnitude * R.magnitude "
 -- INV:gen: "L.magnitude * R.magnitude " 
 -- needorigin: "L.magnitude * R.magnitude " 
 -- needOrigin:E: "L.magnitude * R.magnitude "  E.ATd: 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  Ex: "L.magnitude * R.magnitude " rec: "
 --  L.magnitude * R.magnitude " E.ATd: 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  E.ATd.desc: 
 --  %basic 112
 --  in V: var float
 --  out R: var float
 --  E.ATd.IT: 
 --  %basic 112
 --  in V: var float
 -- \
 --   out R: var float
 --  
 -- doNeedOrigin:Ex: "L.magnitude * R.magnitude "originIsValueObj: 
 --  true origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "L.magnitude * R.magnitude " 
 -- doNeedOrigin:E: "L.magnitude * R.magnitude " 
 -- computeAdrX:superAdj: 0 "L.magnitude * R.magnitude " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "
 --  L.magnitude * R.magnitude " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "L.magnitude * R.magnitude "
 --  superAdj: 0 
 -- computeAdrX:isLast:E:  "L.magnitude * R.magnitude "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "L.magnitude * R.magnitude "E:  "L.magnitude * R.magnitude "
 -- INV:gen:E.loadArgs "L.magnitude * R.magnitude "
 -- BinaryExp:loadArgs: "L.magnitude * R.magnitude " superAdj: 0 
 -- INV:gen: "L.magnitude " 
 -- needorigin: "L.magnitude " 
 -- needOrigin:E: "magnitude "  E.ATd: "magnitude: var Float " Ex: 
 --  none rec: "L " E.ATd: "magnitude: var Float " E.ATd.desc: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "magnitude " 
 -- doNeedOrigin:E: "magnitude " 
 -- computeAdrX:superAdj: 0 "L.magnitude " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "L " rec: "L " E: "magnitude " 
 --  A.E: "L "
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdrX:isLast:E:  "magnitude "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 --  rec:  "L "E:  "magnitude "
 -- INV:gen:E.loadArgs "magnitude "
 -- INV:gen:after:E.loadArgs "magnitude "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude "
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- DI:invoke: "magnitude: var Float " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:L isNotRemote: false 
 fpushg 2 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:L 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:L 
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:L 
 -- NonVirt: "* R.magnitude " "ObjectInvocation_Binary " ActArg: "
 --  R.magnitude "isValue: false formalArg: "in V: var float " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- OG:before:super.gen: "R.magnitude "
 -- INV:gen: "R.magnitude " 
 -- needorigin: "R.magnitude " 
 -- needOrigin:E: "magnitude "  E.ATd: "magnitude: var Float " Ex: 
 --  none rec: "R " E.ATd: "magnitude: var Float " E.ATd.desc: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "magnitude " 
 -- doNeedOrigin:E: "magnitude " 
 -- computeAdrX:superAdj: 0 "R.magnitude " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "R " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "R " rec: "R " E: "magnitude " 
 --  A.E: "R "
 --  
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- computeAdrX:isLast:E:  "magnitude "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 --  rec:  "R "E:  "magnitude "
 -- INV:gen:E.loadArgs "magnitude "
 -- INV:gen:after:E.loadArgs "magnitude "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude "
 --  :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- DI:invoke: "magnitude: var Float " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:R isNotRemote: false 
 fpushg 4 
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:R 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:R 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:R 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var float "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "R.magnitude ":isBasicVal: true 
 -- case:B: R.magnitude ObjectGenerator 9 0 9 false false 
 -- end:loadArgs:NonVirt: "* R.magnitude "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:L 
 -- INV:gen:after:E.loadArgs "L.magnitude * R.magnitude "
 --  OIadr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:L 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L.magnitude * R.magnitude "
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:L 
 -- BinaryExp:invoke: "L.magnitude "rec: "L.magnitude * R.magnitude "
 -- M: "* R.magnitude "
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:L 
 -- OI:invoke:before:ATdx.invoke: pattern *   
 -- ptn:invoke: "*   "E: "* R.magnitude "ptnKind: 0 useRtnV: true 
 fmult
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* R.magnitude":rec:L.magnitude 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* R.magnitude":rec:L.magnitude 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 fstoreg 6 address:storeg
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:7 isIndexed:0

 CLASS AngularAcceleration 66 1 Dimensions 38
 -- vdtTableCopy: I:1:39 V:2:44 V:3:63 V:4:45 V:5:46 V:6:47 V:7:64 I:8:0
 tstOriginIsNone 
 rstore  1 origin
 -- super Dimension
 -- computeAdrX:superAdj: 1 "Dimension " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Dimension " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 rpushg Dimensions$38 1
 -- computeAdrX:isLast:E:  "Dimension "
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 rtnAlloc 1
 toSuper 39
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0

 CLASS PrimaryUnit#67 67 1 AngularAcceleration$66 66 isVstub
 invoke RadiansPerSecondSquared 68 0 1
 pushThis 
 rstoreg   2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS RadiansPerSecondSquared 68 0 AngularAcceleration 66 isValueObj
 -- vdtTableCopy: I:1:40 V:2:0 V:3:0 V:4:0 V:5:0 V:6:0 V:7:49 V:8:50 V:9:51
 -- super Unit
 -- DI:gen: "magnitude: var Float " DI:isConst: false isBasicValue: 
 --  true primNo: 9 
 -- DI:gen:primitiveType: magnitude 
 rtnAlloc 1
 toSuper 40
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS print 69 1 RadiansPerSecondSquared 68
 -- vdtTableCopy: I:1:51 I:2:0
 tstOriginIsNone 
 rstore  1 origin
 -- super print
 pushThis 
 rpushg iOrigin 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 rtnAlloc 1
 toSuper 51
DO:
 mvStack 
 L1:
 -- OG:before:super.gen: ""RadiansPerSecondSquared".print "
 -- INV:gen: ""RadiansPerSecondSquared".print " 
 -- needorigin: ""RadiansPerSecondSquared".print " 
 -- needOrigin:E: "print "  E.ATd: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeatEx: ""RadiansPerSecondSquared" " rec: "
 --  "RadiansPerSecondSquared" " E.ATd: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeatE.ATd.desc: 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])E.ATd.IT: 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- after:needOrigin: ""RadiansPerSecondSquared" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  ""RadiansPerSecondSquared" "E:  ""RadiansPerSecondSquared" "
 -- INV:gen:E.loadArgs ""RadiansPerSecondSquared" "
 -- INV:gen:after:E.loadArgs ""RadiansPerSecondSquared" "
 --  OIadr: 
 pushText "RadiansPerSecondSquared"
 -- IV:gen:checkTail: ""RadiansPerSecondSquared".print "E: "
 --  "RadiansPerSecondSquared" "tail: "print " not isLast: false 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "
 --  "RadiansPerSecondSquared" " 
 --  adr:none 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0

 CLASS Area 70 1 Dimensions 38
 -- vdtTableCopy: I:1:39 V:2:44 V:3:63 V:4:45 V:5:46 V:6:47 V:7:64 I:8:0
 tstOriginIsNone 
 rstore  1 origin
 -- super Dimension
 -- computeAdrX:superAdj: 1 "Dimension " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Dimension " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 rpushg Dimensions$38 1
 -- computeAdrX:isLast:E:  "Dimension "
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 rtnAlloc 1
 toSuper 39
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0

 CLASS PrimaryUnit#71 71 1 Area$70 70 isVstub
 invoke SquareMeter 72 0 1
 pushThis 
 rstoreg   2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS SquareMeter 72 0 Area 70 isValueObj
 -- vdtTableCopy: I:1:40 V:2:0 V:3:0 V:4:0 V:5:0 V:6:0 V:7:49 V:8:50 V:9:51
 -- super Unit
 -- DI:gen: "magnitude: var Float " DI:isConst: false isBasicValue: 
 --  true primNo: 9 
 -- DI:gen:primitiveType: magnitude 
 rtnAlloc 1
 toSuper 40
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS print 74 1 SquareMeter 72
 -- vdtTableCopy: I:1:51 I:2:0
 tstOriginIsNone 
 rstore  1 origin
 -- super print
 pushThis 
 rpushg iOrigin 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 rtnAlloc 1
 toSuper 51
DO:
 mvStack 
 L1:
 -- OG:before:super.gen: ""SquareMeter".print "
 -- INV:gen: ""SquareMeter".print " 
 -- needorigin: ""SquareMeter".print " 
 -- needOrigin:E: "print "  E.ATd: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeatEx: ""SquareMeter" " rec: ""SquareMeter" " E.ATd: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeatE.ATd.desc: 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])E.ATd.IT: 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- after:needOrigin: ""SquareMeter" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  ""SquareMeter" "E:  ""SquareMeter" "
 -- INV:gen:E.loadArgs ""SquareMeter" "
 -- INV:gen:after:E.loadArgs ""SquareMeter" "
 --  OIadr: 
 pushText "SquareMeter"
 -- IV:gen:checkTail: ""SquareMeter".print "E: ""SquareMeter" "tail: "
 --  print " not isLast: false 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "
 --  "SquareMeter" " 
 --  adr:none 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0

 CLASS symbol 75 1 Area 70
 -- vdtTableCopy: I:1:63 I:2:0
 -- super symbol
 allocEventQ
 -- DI:gen: "out T: var StringLib.String " DI:isConst: false 
 --  isBasicValue: false primNo: 5 
 -- DI:StringVar "out T: var StringLib.String "
 pushText ""
 pushThis 
 rstoreg  T 2
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 rtnAlloc 1
 toSuper 63
DO:
 mvStack 
 L1:
 -- AssignmentStatement:gen: "T := "A" " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "T := "A" " right.label: "ObjectGenerator """A" " 
 -- OG:before:super.gen: ""A" "
 -- INV:gen: ""A" " 
 -- needorigin: ""A" " 
 -- needOrigin:E: ""A" "  E.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5Ex: ""A" " rec: ""A" " E.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5E.ATd.desc: 
 --  %id "String pattern"
 --  %OSDvisibility disguised
 --  %basic 5
 --  %publicE.ATd.IT: 
 --  %id "String pattern"
 --  %OSDvisibility disguised
 --  %basic 5
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- after:needOrigin: ""A" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  ""A" "E:  ""A" "
 -- INV:gen:E.loadArgs ""A" "
 -- INV:gen:after:E.loadArgs ""A" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: String: ""A" "
 pushText "A"
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 rswap 0
 rstoreg  EisNone 2
   ;; vTop(0,0)=[] rTop(-2,1)=[]
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS Energy 76 1 Dimensions 38
 -- vdtTableCopy: I:1:39 V:2:44 V:3:63 V:4:45 V:5:46 V:6:47 V:7:64 I:8:0
 tstOriginIsNone 
 rstore  1 origin
 -- super Dimension
 -- computeAdrX:superAdj: 1 "Dimension " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Dimension " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 rpushg Dimensions$38 1
 -- computeAdrX:isLast:E:  "Dimension "
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 rtnAlloc 1
 toSuper 39
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0

 CLASS PrimaryUnit#77 77 1 Energy$76 76 isVstub
 invoke Joule 81 0 1
 pushThis 
 rstoreg   2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS multArgL#78 78 1 Energy$76 76 isVstub
 invoke Newton 86 0 1
 pushThis 
 rstoreg   2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS multArgR#79 79 1 Energy$76 76 isVstub
 invoke Meter 91 0 1
 pushThis 
 rstoreg   2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS multRes#80 80 1 Energy$76 76 isVstub
 invoke Joule 81 0 1
 pushThis 
 rstoreg   2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS Joule 81 0 Energy 76 isValueObj
 -- vdtTableCopy: I:1:40 V:2:0 V:3:0 V:4:0 V:5:0 V:6:0 V:7:49 V:8:50 V:9:51
 -- super Unit
 -- DI:gen: "magnitude: var Float " DI:isConst: false isBasicValue: 
 --  true primNo: 9 
 -- DI:gen:primitiveType: magnitude 
 rtnAlloc 1
 toSuper 40
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS print 83 1 Joule 81
 -- vdtTableCopy: I:1:51 I:2:0
 tstOriginIsNone 
 rstore  1 origin
 -- super print
 pushThis 
 rpushg iOrigin 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 rtnAlloc 1
 toSuper 51
DO:
 mvStack 
 L1:
 -- OG:before:super.gen: ""Joule".print "
 -- INV:gen: ""Joule".print " 
 -- needorigin: ""Joule".print " 
 -- needOrigin:E: "print "  E.ATd: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeatEx: ""Joule" " rec: ""Joule" " E.ATd: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeatE.ATd.desc: 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])E.ATd.IT: 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- after:needOrigin: ""Joule" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  ""Joule" "E:  ""Joule" "
 -- INV:gen:E.loadArgs ""Joule" "
 -- INV:gen:after:E.loadArgs ""Joule" "
 --  OIadr: 
 pushText "Joule"
 -- IV:gen:checkTail: ""Joule".print "E: ""Joule" "tail: "print "
 --   not isLast: false 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: ""Joule" " 
 --  adr:none 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0

 CLASS Force 84 1 Dimensions 38
 -- vdtTableCopy: I:1:39 V:2:44 V:3:63 V:4:45 V:5:46 V:6:47 V:7:64 I:8:0
 tstOriginIsNone 
 rstore  1 origin
 -- super Dimension
 -- computeAdrX:superAdj: 1 "Dimension " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Dimension " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 rpushg Dimensions$38 1
 -- computeAdrX:isLast:E:  "Dimension "
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 rtnAlloc 1
 toSuper 39
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0

 CLASS PrimaryUnit#85 85 1 Force$84 84 isVstub
 invoke Newton 86 0 1
 pushThis 
 rstoreg   2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS Newton 86 0 Force 84 isValueObj
 -- vdtTableCopy: I:1:40 V:2:0 V:3:0 V:4:0 V:5:0 V:6:0 V:7:49 V:8:50 V:9:51
 -- super Unit
 -- DI:gen: "magnitude: var Float " DI:isConst: false isBasicValue: 
 --  true primNo: 9 
 -- DI:gen:primitiveType: magnitude 
 rtnAlloc 1
 toSuper 40
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS print 88 1 Newton 86
 -- vdtTableCopy: I:1:51 I:2:0
 tstOriginIsNone 
 rstore  1 origin
 -- super print
 pushThis 
 rpushg iOrigin 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 rtnAlloc 1
 toSuper 51
DO:
 mvStack 
 L1:
 -- OG:before:super.gen: ""Newton".print "
 -- INV:gen: ""Newton".print " 
 -- needorigin: ""Newton".print " 
 -- needOrigin:E: "print "  E.ATd: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeatEx: ""Newton" " rec: ""Newton" " E.ATd: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeatE.ATd.desc: 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])E.ATd.IT: 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- after:needOrigin: ""Newton" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  ""Newton" "E:  ""Newton" "
 -- INV:gen:E.loadArgs ""Newton" "
 -- INV:gen:after:E.loadArgs ""Newton" "
 --  OIadr: 
 pushText "Newton"
 -- IV:gen:checkTail: ""Newton".print "E: ""Newton" "tail: "print "
 --   not isLast: false 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: ""Newton" " 
 --  adr:none 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0

 CLASS Length 89 1 Dimensions 38
 -- vdtTableCopy: I:1:39 V:2:44 V:3:63 V:4:45 V:5:46 V:6:47 V:7:64 I:8:0
 tstOriginIsNone 
 rstore  1 origin
 -- super Dimension
 -- computeAdrX:superAdj: 1 "Dimension " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Dimension " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 rpushg Dimensions$38 1
 -- computeAdrX:isLast:E:  "Dimension "
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 rtnAlloc 1
 toSuper 39
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0

 CLASS PrimaryUnit#90 90 1 Length$89 89 isVstub
 invoke Meter 91 0 1
 pushThis 
 rstoreg   2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS Meter 91 0 Length 89 isValueObj
 -- vdtTableCopy: I:1:40 V:2:0 V:3:0 V:4:0 V:5:0 V:6:0 V:7:49 V:8:50 V:9:51
 -- super Unit
 -- DI:gen: "magnitude: var Float " DI:isConst: false isBasicValue: 
 --  true primNo: 9 
 -- DI:gen:primitiveType: magnitude 
 rtnAlloc 1
 toSuper 40
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS toPrimary 95 1 Meter 91
 -- vdtTableCopy: I:1:49 I:2:0
 tstOriginIsNone 
 rstore  1 origin
 -- super toPrimary
 pushThis 
 rpushg iOrigin 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- DI:gen: "out base: var PrimaryUnit " DI:isConst: false 
 --  isBasicValue: false primNo: 0 
 -- DI:isConst: base 
 -- DI:off: 2 this: "out base: var PrimaryUnit " 
 --  
 -- OG:before:super.gen: "PrimaryUnit "
 -- INV:gen: "PrimaryUnit " 
 -- needorigin: "PrimaryUnit " 
 -- needOrigin:E: "PrimaryUnit "  E.ATd: "PrimaryUnit:< Unit " Ex: "
 --  PrimaryUnit " rec: "PrimaryUnit " E.ATd: "PrimaryUnit:< Unit " E.ATd.desc: 
 --  %unit "U", 1
 --  %public
 --  magnitude: var Float
 --  thisUnit:< UnitE.ATd.IT: " " 
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 -- after:needOrigin: "PrimaryUnit " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "PrimaryUnit "E:  "PrimaryUnit "
 -- INV:gen:E.loadArgs "PrimaryUnit "
 -- INV:gen:after:E.loadArgs "PrimaryUnit "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "
 --  PrimaryUnit "
 -- OI:invoke:before:ATdx.invoke: pattern PrimaryUnit 
 -- ptn:invoke: "PrimaryUnit "E: "PrimaryUnit "ptnKind: 1 useRtnV: 
 --  false 
 -- GeneralPTN:invoke:ptnKind: 1 staticOff: 2 rec: "PrimaryUnit " 
 --  adr:none 
 invokeVal  PrimaryUnit 40 1
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 rtnAlloc 1
 toSuper 49
DO:
 mvStack 
 L1:
 -- AssignmentStatement:gen: "base.magnitude := magnitude " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "base.magnitude := magnitude " right.label: "ObjectGenerator ""
 --  magnitude " 
 -- OG:before:super.gen: "magnitude "
 -- INV:gen: "magnitude " 
 -- needorigin: "magnitude " 
 -- needOrigin:E: "magnitude "  E.ATd: "magnitude: var Float " Ex: "
 --  magnitude " rec: "magnitude " E.ATd: "magnitude: var Float " E.ATd.desc: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "magnitude " 
 -- doNeedOrigin:E: "magnitude " 
 -- computeAdrX:superAdj: 0 "magnitude " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "magnitude " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "toPrimary "on: 1 isValueObj: false 
 --  origin: Meter origin:isValueObj: true 
 rpushg toPrimary$95 1
 -- computeAdrX:isLast:E:  "magnitude "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 --  rec:  "magnitude "E:  "magnitude "
 -- INV:gen:E.loadArgs "magnitude "
 -- INV:gen:after:E.loadArgs "magnitude "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude "
 --  :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- DI:invoke: "magnitude: var Float " 
 -- load: 
 --  :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude isNotRemote: true 
 -- load:isValue:E: "magnitude "originIsValue: true 
 --  E.ATd:isValueObj: true 
 -- E.ATd: "magnitude: var Float " 
 --  E.ATd.origin: 
 --  %unit "U", 1
 --  %public
 --  magnitude: var Float
 --  thisUnit:< Unit
 --  (E.ATd.origin.ogOfScope): 
 --  Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 fvpushg 1 Meter$91
 -- OI:invoke:V: adr: 
 --  :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- OI:invoke:X: adr: 
 --  :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- INV:gen:end:off: 1 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- assign:adr.store:A: 
 fstoreg 2 address:storeg
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:3 isIndexed:0

 CLASS fromPrimary 96 1 Meter 91
 -- vdtTableCopy: I:1:50 I:2:0
 tstOriginIsNone 
 rstore  1 origin
 -- super fromPrimary
 pushThis 
 rpushg iOrigin 1
 jmpFalse  L3
 pushThis 
 -- vassign:B: base off: 2 size: 2 mode: 0 
 vassign  2 2 0
 jmp L4
 L3:
 invokeVal  base 40 1
 rpop 
 L4:
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- DI:gen: "in base: var PrimaryUnit " DI:isConst: false 
 --  isBasicValue: false primNo: 0 
 -- DI:isConst: base 
 -- inArg: in base: var PrimaryUnit 
 rtnAlloc 1
 toSuper 50
DO:
 mvStack 
 L1:
 -- AssignmentStatement:gen: "magnitude := base.magnitude " 
 pushThis 
 -- items:goOrigin:encOG: "fromPrimary "on: 1 isValueObj: false 
 --  origin: Meter origin:isValueObj: true 
 rpushg fromPrimary$96 1
 -- AssignmentStatement:gen: 
 --  "magnitude := base.magnitude " right.label: "ObjectGenerator ""
 --  base.magnitude " 
 -- OG:before:super.gen: "base.magnitude "
 -- INV:gen: "base.magnitude " 
 -- needorigin: "base.magnitude " 
 -- needOrigin:E: "magnitude "  E.ATd: "magnitude: var Float " Ex: 
 --  none rec: "base " E.ATd: "magnitude: var Float " E.ATd.desc: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "magnitude " 
 -- doNeedOrigin:E: "magnitude " 
 -- computeAdrX:superAdj: 0 "base.magnitude " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "base " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "base " rec: "base " E: "magnitude " 
 --  A.E: "base "
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- computeAdrX:isLast:E:  "magnitude "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 --  rec:  "base "E:  "magnitude "
 -- INV:gen:E.loadArgs "magnitude "
 -- INV:gen:after:E.loadArgs "magnitude "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude "
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- DI:invoke: "magnitude: var Float " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base isNotRemote: false 
 fpushg 2 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- assign:adr.store:A: 
 fvstoreg  1 
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:3 isIndexed:0

 CLASS print 97 1 Meter 91
 -- vdtTableCopy: I:1:51 I:2:0
 tstOriginIsNone 
 rstore  1 origin
 -- super print
 pushThis 
 rpushg iOrigin 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 rtnAlloc 1
 toSuper 51
DO:
 mvStack 
 L1:
 -- OG:before:super.gen: ""Meter".print "
 -- INV:gen: ""Meter".print " 
 -- needorigin: ""Meter".print " 
 -- needOrigin:E: "print "  E.ATd: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeatEx: ""Meter" " rec: ""Meter" " E.ATd: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeatE.ATd.desc: 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])E.ATd.IT: 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- after:needOrigin: ""Meter" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  ""Meter" "E:  ""Meter" "
 -- INV:gen:E.loadArgs ""Meter" "
 -- INV:gen:after:E.loadArgs ""Meter" "
 --  OIadr: 
 pushText "Meter"
 -- IV:gen:checkTail: ""Meter".print "E: ""Meter" "tail: "print "
 --   not isLast: false 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: ""Meter" " 
 --  adr:none 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0

 CLASS symbol 98 1 Length 89
 -- vdtTableCopy: I:1:63 I:2:0
 -- super symbol
 allocEventQ
 -- DI:gen: "out T: var StringLib.String " DI:isConst: false 
 --  isBasicValue: false primNo: 5 
 -- DI:StringVar "out T: var StringLib.String "
 pushText ""
 pushThis 
 rstoreg  T 2
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 rtnAlloc 1
 toSuper 63
DO:
 mvStack 
 L1:
 -- AssignmentStatement:gen: "T := "L" " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "T := "L" " right.label: "ObjectGenerator """L" " 
 -- OG:before:super.gen: ""L" "
 -- INV:gen: ""L" " 
 -- needorigin: ""L" " 
 -- needOrigin:E: ""L" "  E.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5Ex: ""L" " rec: ""L" " E.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5E.ATd.desc: 
 --  %id "String pattern"
 --  %OSDvisibility disguised
 --  %basic 5
 --  %publicE.ATd.IT: 
 --  %id "String pattern"
 --  %OSDvisibility disguised
 --  %basic 5
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- after:needOrigin: ""L" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  ""L" "E:  ""L" "
 -- INV:gen:E.loadArgs ""L" "
 -- INV:gen:after:E.loadArgs ""L" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: String: ""L" "
 pushText "L"
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 rswap 0
 rstoreg  EisNone 2
   ;; vTop(0,0)=[] rTop(-2,1)=[]
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS Mass 99 1 Dimensions 38
 -- vdtTableCopy: I:1:39 V:2:44 V:3:63 V:4:45 V:5:46 V:6:47 V:7:64 I:8:0
 tstOriginIsNone 
 rstore  1 origin
 -- super Dimension
 -- computeAdrX:superAdj: 1 "Dimension " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Dimension " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 rpushg Dimensions$38 1
 -- computeAdrX:isLast:E:  "Dimension "
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 rtnAlloc 1
 toSuper 39
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0

 CLASS Time 100 1 Dimensions 38
 -- vdtTableCopy: I:1:39 V:2:44 V:3:63 V:4:45 V:5:46 V:6:47 V:7:64 I:8:0
 tstOriginIsNone 
 rstore  1 origin
 -- super Dimension
 -- computeAdrX:superAdj: 1 "Dimension " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Dimension " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 rpushg Dimensions$38 1
 -- computeAdrX:isLast:E:  "Dimension "
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 rtnAlloc 1
 toSuper 39
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0

 CLASS PrimaryUnit#101 101 1 Time$100 100 isVstub
 invoke Second 102 0 0
 pushThis 
 rstoreg   2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS Second 102 0 Time 100 isValueObj
 -- vdtTableCopy: I:1:40 V:2:0 V:3:0 V:4:0 V:5:0 V:6:0 V:7:49 V:8:50 V:9:51
 -- super Unit
 -- DI:gen: "magnitude: var Float " DI:isConst: false isBasicValue: 
 --  true primNo: 9 
 -- DI:gen:primitiveType: magnitude 
 rtnAlloc 1
 toSuper 40
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS toPrimary 104 1 Second 102
 -- vdtTableCopy: I:1:49 I:2:0
 tstOriginIsNone 
 rstore  1 origin
 -- super toPrimary
 pushThis 
 rpushg iOrigin 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- DI:gen: "out base: var PrimaryUnit " DI:isConst: false 
 --  isBasicValue: false primNo: 0 
 -- DI:isConst: base 
 -- DI:off: 2 this: "out base: var PrimaryUnit " 
 --  
 -- OG:before:super.gen: "PrimaryUnit "
 -- INV:gen: "PrimaryUnit " 
 -- needorigin: "PrimaryUnit " 
 -- needOrigin:E: "PrimaryUnit "  E.ATd: "PrimaryUnit:< Unit " Ex: "
 --  PrimaryUnit " rec: "PrimaryUnit " E.ATd: "PrimaryUnit:< Unit " E.ATd.desc: 
 --  %unit "U", 1
 --  %public
 --  magnitude: var Float
 --  thisUnit:< UnitE.ATd.IT: " " 
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 -- after:needOrigin: "PrimaryUnit " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "PrimaryUnit "E:  "PrimaryUnit "
 -- INV:gen:E.loadArgs "PrimaryUnit "
 -- INV:gen:after:E.loadArgs "PrimaryUnit "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "
 --  PrimaryUnit "
 -- OI:invoke:before:ATdx.invoke: pattern PrimaryUnit 
 -- ptn:invoke: "PrimaryUnit "E: "PrimaryUnit "ptnKind: 1 useRtnV: 
 --  false 
 -- GeneralPTN:invoke:ptnKind: 1 staticOff: 2 rec: "PrimaryUnit " 
 --  adr:none 
 invokeVal  PrimaryUnit 40 1
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 rtnAlloc 1
 toSuper 49
DO:
 mvStack 
 L1:
 -- AssignmentStatement:gen: "base.magnitude := magnitude " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "base.magnitude := magnitude " right.label: "ObjectGenerator ""
 --  magnitude " 
 -- OG:before:super.gen: "magnitude "
 -- INV:gen: "magnitude " 
 -- needorigin: "magnitude " 
 -- needOrigin:E: "magnitude "  E.ATd: "magnitude: var Float " Ex: "
 --  magnitude " rec: "magnitude " E.ATd: "magnitude: var Float " E.ATd.desc: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "magnitude " 
 -- doNeedOrigin:E: "magnitude " 
 -- computeAdrX:superAdj: 0 "magnitude " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "magnitude " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "toPrimary "on: 1 isValueObj: false 
 --  origin: Second origin:isValueObj: true 
 rpushg toPrimary$104 1
 -- computeAdrX:isLast:E:  "magnitude "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 --  rec:  "magnitude "E:  "magnitude "
 -- INV:gen:E.loadArgs "magnitude "
 -- INV:gen:after:E.loadArgs "magnitude "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude "
 --  :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- DI:invoke: "magnitude: var Float " 
 -- load: 
 --  :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude isNotRemote: true 
 -- load:isValue:E: "magnitude "originIsValue: true 
 --  E.ATd:isValueObj: true 
 -- E.ATd: "magnitude: var Float " 
 --  E.ATd.origin: 
 --  %unit "U", 1
 --  %public
 --  magnitude: var Float
 --  thisUnit:< Unit
 --  (E.ATd.origin.ogOfScope): 
 --  Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 fvpushg 1 Second$102
 -- OI:invoke:V: adr: 
 --  :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- OI:invoke:X: adr: 
 --  :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- INV:gen:end:off: 1 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- assign:adr.store:A: 
 fstoreg 2 address:storeg
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:3 isIndexed:0

 CLASS fromPrimary 105 1 Second 102
 -- vdtTableCopy: I:1:50 I:2:0
 tstOriginIsNone 
 rstore  1 origin
 -- super fromPrimary
 pushThis 
 rpushg iOrigin 1
 jmpFalse  L3
 pushThis 
 -- vassign:B: base off: 2 size: 2 mode: 0 
 vassign  2 2 0
 jmp L4
 L3:
 invokeVal  base 40 1
 rpop 
 L4:
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- DI:gen: "in base: var PrimaryUnit " DI:isConst: false 
 --  isBasicValue: false primNo: 0 
 -- DI:isConst: base 
 -- inArg: in base: var PrimaryUnit 
 rtnAlloc 1
 toSuper 50
DO:
 mvStack 
 L1:
 -- AssignmentStatement:gen: "magnitude := base.magnitude " 
 pushThis 
 -- items:goOrigin:encOG: "fromPrimary "on: 1 isValueObj: false 
 --  origin: Second origin:isValueObj: true 
 rpushg fromPrimary$105 1
 -- AssignmentStatement:gen: 
 --  "magnitude := base.magnitude " right.label: "ObjectGenerator ""
 --  base.magnitude " 
 -- OG:before:super.gen: "base.magnitude "
 -- INV:gen: "base.magnitude " 
 -- needorigin: "base.magnitude " 
 -- needOrigin:E: "magnitude "  E.ATd: "magnitude: var Float " Ex: 
 --  none rec: "base " E.ATd: "magnitude: var Float " E.ATd.desc: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "magnitude " 
 -- doNeedOrigin:E: "magnitude " 
 -- computeAdrX:superAdj: 0 "base.magnitude " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "base " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "base " rec: "base " E: "magnitude " 
 --  A.E: "base "
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- computeAdrX:isLast:E:  "magnitude "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 --  rec:  "base "E:  "magnitude "
 -- INV:gen:E.loadArgs "magnitude "
 -- INV:gen:after:E.loadArgs "magnitude "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude "
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- DI:invoke: "magnitude: var Float " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base isNotRemote: false 
 fpushg 2 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- assign:adr.store:A: 
 fvstoreg  1 
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:3 isIndexed:0

 CLASS print 106 1 Second 102
 -- vdtTableCopy: I:1:51 I:2:0
 tstOriginIsNone 
 rstore  1 origin
 -- super print
 pushThis 
 rpushg iOrigin 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 rtnAlloc 1
 toSuper 51
DO:
 mvStack 
 L1:
 -- OG:before:super.gen: ""Second".print "
 -- INV:gen: ""Second".print " 
 -- needorigin: ""Second".print " 
 -- needOrigin:E: "print "  E.ATd: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeatEx: ""Second" " rec: ""Second" " E.ATd: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeatE.ATd.desc: 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])E.ATd.IT: 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- after:needOrigin: ""Second" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  ""Second" "E:  ""Second" "
 -- INV:gen:E.loadArgs ""Second" "
 -- INV:gen:after:E.loadArgs ""Second" "
 --  OIadr: 
 pushText "Second"
 -- IV:gen:checkTail: ""Second".print "E: ""Second" "tail: "print "
 --   not isLast: false 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: ""Second" " 
 --  adr:none 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0

 CLASS StringLib 107 1 LIB 33
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 saveStringOrigin
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $18 18 1 loop 14
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "leave(loop) "
 -- INV:gen: "leave(loop) " 
 -- needorigin: "leave(loop) " 
 -- needOrigin:E: "leave(loop) "  E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  Ex: "leave(loop) " rec: "leave(loop) " E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  E.ATd.desc: "%basic 103 " E.ATd.IT: "%basic 103 " 
 -- doNeedOrigin:Ex: "leave(loop) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "leave(loop) " 
 -- doNeedOrigin:E: "leave(loop) " 
 -- computeAdrX:superAdj: 0 "leave(loop) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "leave(loop) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "leave(loop) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:- 
 --  rec:  "leave(loop) "E:  "leave(loop) "
 -- INV:gen:E.loadArgs "leave(loop) "
 -- INV:gen:after:E.loadArgs "leave(loop) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  leave(loop) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- ptn:invoke: "leave(V: var integer) "E: "leave(loop) "ptnKind: 0 
 --  useRtnV: false 
 break  1 2 14 0
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS Boolean 108 0 BETA 2 isValueObj
 mvStack 
 -- DI:gen: "_thisBasicValue: var Universal " DI:isConst: false 
 --  isBasicValue: true primNo: 1 
 -- DI:gen:primitiveType: _thisBasicValue 
 rtnAlloc 1
DO:
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS True 23 0 BETA 2
 allocEventQ
 mvStack 
 -- DI:gen: "out B: var boolean " DI:isConst: false isBasicValue: 
 --  true primNo: 4 
 -- DI:gen:primitiveType: B 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "B := 1 " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "B := 1 " right.label: "ObjectGenerator ""1 " 
 -- OG:before:super.gen: "1 "
 -- INV:gen: "1 " 
 -- needorigin: "1 " 
 -- needOrigin:E: "1 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "1 " rec: "1 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "1 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "1 "E:  "1 "
 -- INV:gen:E.loadArgs "1 "
 -- INV:gen:after:E.loadArgs "1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1 "
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg True$23 1
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS repeat$24 24 1 for:to:repeat$30 30
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "c1 := get[inx] " 
 pushThis 
 -- items:goOrigin:encOG: "repeat$24 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30 "on: 1 isValueObj: 
 --  false 
 --  origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- AssignmentStatement:gen: 
 --  "c1 := get[inx] " right.label: "ObjectGenerator ""get[inx] " 
 -- OG:before:super.gen: "get[inx] "
 -- INV:gen: "get[inx] " 
 -- needorigin: "get[inx] " 
 -- needOrigin:E: "get[inx] "  E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  Ex: "get[inx] " rec: "get[inx] " E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  E.ATd.desc: 
 --  %basic 117
 --  out ch: var char
 --  E.ATd.IT: 
 --  %basic 117
 --  out ch: var char
 --  
 -- doNeedOrigin:Ex: "get[inx] "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "get[inx] " 
 -- doNeedOrigin:E: "get[inx] " 
 -- computeAdrX:superAdj: 0 "get[inx] " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "get[inx] " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$24 "on: 4 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30 "on: 3 isValueObj: 
 --  false 
 --  origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- items:goOrigin:encOG: "loop "on: 2 isValueObj: false 
 --  origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- items:goOrigin:encOG: "= "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg =$13 1
 -- computeAdrX:isLast:E:  "get[inx] "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 --  rec:  "get[inx] "E:  "get[inx] "
 -- INV:gen:E.loadArgs "get[inx] "
 -- NonVirt: "get[inx] " "ObjectInvocation_KeyWord " ActArg: "inx "
 --  isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx] " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "inx "
 -- INV:gen: "inx " 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$24 "on: 1 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 3 for:to:repeat$30$30
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "get[inx] "
 -- INV:gen:after:E.loadArgs "get[inx] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx] "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- ptn:invoke: "get[inx: var integer] "E: "get[inx] "ptnKind: 0 
 --  useRtnV: true 
 xpushg  inx 1 0 1
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- assign:adr.store:A: 
 storeg loop$14 2
 -- assign:adr.store:B: 
 -- AssignmentStatement:gen: "c2 := Veq.get[inx] " 
 pushThis 
 -- items:goOrigin:encOG: "repeat$24 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30 "on: 1 isValueObj: 
 --  false 
 --  origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- AssignmentStatement:gen: 
 --  "c2 := Veq.get[inx] " right.label: "ObjectGenerator ""
 --  Veq.get[inx] " 
 -- OG:before:super.gen: "Veq.get[inx] "
 -- INV:gen: "Veq.get[inx] " 
 -- needorigin: "Veq.get[inx] " 
 -- needOrigin:E: "get[inx] "  E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  Ex: "get[inx] " rec: "Veq " E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  E.ATd.desc: 
 --  %basic 117
 --  out ch: var char
 --  E.ATd.IT: 
 --  %basic 117
 --  out ch: var char
 --  
 -- doNeedOrigin:Ex: "get[inx] "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "get[inx] " 
 -- doNeedOrigin:E: "get[inx] " 
 -- computeAdrX:superAdj: 0 "Veq.get[inx] " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Veq " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$24 "on: 3 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30 "on: 2 isValueObj: 
 --  false 
 --  origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- computeAdrX:En: 2 pRec: "Veq " rec: "Veq " E: "get[inx] " 
 --  A.E: none 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "Veq " rec: "Veq " E: "get[inx] " 
 --  rec.ATd: "in Veq: var this(Value) " rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --     inner(= )
 --  
 --  recA: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 --  pRecA: none 
 -- pRec: "Veq " rec: "Veq " E: "get[inx] " 
 --  false true 
 -- computeAdrX:before:rec:: "Veq " 
 -- OI:invoke:before:ATdx.invoke: var Veq 
 -- DI:invoke: "in Veq: var this(Value) " 
 -- isValueObj:isAdr: true objSize: 2  rec "Veq ",E: "get[inx] ""
 --  ObjectInvocation_KeyWord "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- Address:loadAdr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 rpushg repeat$24$24 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- computeAdrX:after:rec.invoke: "Veq " 
 -- computeAdrX:isLast:E:  "get[inx] "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 --  rec:  "Veq "E:  "get[inx] "
 -- INV:gen:E.loadArgs "get[inx] "
 -- NonVirt: "get[inx] " "ObjectInvocation_KeyWord " ActArg: "inx "
 --  isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx] " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "inx "
 -- INV:gen: "inx " 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$24 "on: 1 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 3 for:to:repeat$30$30
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "get[inx] "
 -- INV:gen:after:E.loadArgs "get[inx] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx] "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- ptn:invoke: "get[inx: var integer] "E: "get[inx] "ptnKind: 0 
 --  useRtnV: true 
 xpushg  inx 1 0 1
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- assign:adr.store:A: 
 storeg loop$14 3
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop) "
 -- INV:gen: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  
 -- needorigin: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  
 -- needOrigin:E: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  rec: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  E.ATd: 
 -- \
 --   if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  E.ATd.desc: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  E.ATd.IT: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop) "E:  "
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop) "
 -- INV:gen:E.loadArgs "
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop) "
 -- INV:gen:after:E.loadArgs "
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop) "
 -- OG:before:super.gen: "(c1 <> c2) "
 -- INV:gen: "(c1 <> c2) " 
 -- needorigin: "(c1 <> c2) " 
 -- needOrigin:E: "(c1 <> c2) "  E.ATd: 
 --  <>  : 
 --     %basic 55
 --     in V: var char
 --     out B: var boolean
 --  Ex: "(c1 <> c2) " rec: "(c1 <> c2) " E.ATd: 
 --  <>  : 
 --     %basic 55
 --     in V: var char
 --     out B: var boolean
 --  E.ATd.desc: 
 --  %basic 55
 --  in V: var char
 --  out B: var boolean
 --  E.ATd.IT: 
 --  %basic 55
 --  in V: var char
 --  out B: var boolean
 -- \
 --   
 -- doNeedOrigin:Ex: "(c1 <> c2) "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(c1 <> c2) " 
 -- doNeedOrigin:E: "(c1 <> c2) " 
 -- computeAdrX:superAdj: 0 "(c1 <> c2) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(c1 <> c2) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "c1 <> c2 "superAdj: 0 
 -- computeAdrX:isLast:E:  "c1 <> c2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "c1 <> c2 "E:  "c1 <> c2 "
 -- INV:gen:E.loadArgs "c1 <> c2 "
 -- BinaryExp:loadArgs: "c1 <> c2 " superAdj: 0 
 -- INV:gen: "c1 " 
 -- needorigin: "c1 " 
 -- needOrigin:E: "c1 "  E.ATd: "c1: var char " Ex: "c1 " rec: "c1 " 
 --  E.ATd: "c1: var char " E.ATd.desc: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "c1 " 
 -- doNeedOrigin:E: "c1 " 
 -- computeAdrX:superAdj: 0 "c1 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "c1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$24 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30 "on: 1 isValueObj: 
 --  false 
 --  origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- computeAdrX:isLast:E:  "c1 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 --  rec:  "c1 "E:  "c1 "
 -- INV:gen:E.loadArgs "c1 "
 -- INV:gen:after:E.loadArgs "c1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c1 "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var c1 
 -- DI:invoke: "c1: var char " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 isNotRemote: true 
 pushg 2 loop$14
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- NonVirt: "<> c2 " "ObjectInvocation_Binary " ActArg: "c2 "
 --  isValue: false formalArg: "in V: var char " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "<> c2 " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "c2 "
 -- INV:gen: "c2 " 
 -- needorigin: "c2 " 
 -- needOrigin:E: "c2 "  E.ATd: "c2: var char " Ex: "c2 " rec: "c2 " 
 --  E.ATd: "c2: var char " E.ATd.desc: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "c2 " 
 -- doNeedOrigin:E: "c2 " 
 -- computeAdrX:superAdj: 0 "c2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "c2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$24 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30 "on: 1 isValueObj: 
 --  false 
 --  origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- computeAdrX:isLast:E:  "c2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 --  rec:  "c2 "E:  "c2 "
 -- INV:gen:E.loadArgs "c2 "
 -- INV:gen:after:E.loadArgs "c2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c2 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var c2 
 -- DI:invoke: "c2: var char " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 isNotRemote: true 
 pushg 3 loop$14
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var char "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "c2 ":isBasicVal: true 
 -- case:B: c2 ObjectGenerator 3 0 3 false false 
 -- end:loadArgs:NonVirt: "<> c2 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:after:E.loadArgs "c1 <> c2 "
 --  OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "c1 <> c2 "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- BinaryExp:invoke: "c1 "rec: "c1 <> c2 "
 -- M: "<> c2 "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:before:ATdx.invoke: pattern <>   
 -- ptn:invoke: "<>   "E: "<> c2 "ptnKind: 0 useRtnV: true 
 ne
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<> c2":rec:c1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<> c2":rec:c1 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  26   "$26 "
 invoke $26 26 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $26 26 1 repeat$24 24
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "Beq := false " 
 pushThis 
 -- items:goOrigin:encOG: "$26 "on: 4 isValueObj: false 
 --  origin: repeat$24 origin:isValueObj: false 
 rpushg $26$26 1
 -- items:goOrigin:encOG: "repeat$24 "on: 3 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30 "on: 2 isValueObj: 
 --  false 
 --  origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- AssignmentStatement:gen: 
 --  "Beq := false " right.label: "ObjectGenerator ""false " 
 -- OG:before:super.gen: "false "
 -- INV:gen: "false " 
 -- needorigin: "false " 
 -- needOrigin:E: "false "  E.ATd: 
 --  False: 
 --     %globals
 --     out B: var boolean
 --     B := 0
 --  Ex: "false " rec: "false " E.ATd: 
 --  False: 
 --     %globals
 --     out B: var boolean
 --     B := 0
 --  E.ATd.desc: 
 --  %globals
 --  out B: var boolean
 --  B := 0
 --  E.ATd.IT: 
 --  %globals
 --  out B: var boolean
 --  B := 0
 -- \
 --   
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %globals
 --     out B: var boolean
 --     B := 0
 --  
 -- after:needOrigin: "false " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "false "E:  "false "
 -- INV:gen:E.loadArgs "false "
 -- INV:gen:after:E.loadArgs "false "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "false "
 -- OI:invoke:before:ATdx.invoke: pattern False 
 -- ptn:invoke: "False "E: "false "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "false " 
 --  adr:none 
 invoke False 27 0 0
 -- global:pushOut: B off: 1 
 pushg 1 
 -- callInvoke:after:pushOut: 1 
 -- GeneralPTN:invoke:after:callInvoke: 1 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg =$13 3
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "leave(loop) "
 -- INV:gen: "leave(loop) " 
 -- needorigin: "leave(loop) " 
 -- needOrigin:E: "leave(loop) "  E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  Ex: "leave(loop) " rec: "leave(loop) " E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  E.ATd.desc: "%basic 103 " E.ATd.IT: "%basic 103 " 
 -- doNeedOrigin:Ex: "leave(loop) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "leave(loop) " 
 -- doNeedOrigin:E: "leave(loop) " 
 -- computeAdrX:superAdj: 0 "leave(loop) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "leave(loop) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "leave(loop) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:- 
 --  rec:  "leave(loop) "E:  "leave(loop) "
 -- INV:gen:E.loadArgs "leave(loop) "
 -- INV:gen:after:E.loadArgs "leave(loop) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  leave(loop) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- ptn:invoke: "leave(V: var integer) "E: "leave(loop) "ptnKind: 0 
 --  useRtnV: false 
 break  3 2 14 0
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS False 27 0 BETA 2
 allocEventQ
 mvStack 
 -- DI:gen: "out B: var boolean " DI:isConst: false isBasicValue: 
 --  true primNo: 4 
 -- DI:gen:primitiveType: B 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "B := 0 " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "B := 0 " right.label: "ObjectGenerator ""0 " 
 -- OG:before:super.gen: "0 "
 -- INV:gen: "0 " 
 -- needorigin: "0 " 
 -- needOrigin:E: "0 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "0 " rec: "0 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "0 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "0 "E:  "0 "
 -- INV:gen:E.loadArgs "0 "
 -- INV:gen:after:E.loadArgs "0 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0 "
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg False$27 1
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS for:to:repeat$30 30 4 loop 14
 -- vdtTableCopy: I:1:28 V:2:29
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- NonVirt: 
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then "ObjectInvocation_KeyWord " ActArg: "1 "isValue: true formalArg: "
 --  first: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --        Beq := false
 --        leave(loop)
 --   " isCompositeValueObj: false 
 -- OG:before:super.gen: "1 "
 -- INV:gen: "1 " 
 -- needorigin: "1 " 
 -- needOrigin:E: "1 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "1 " rec: "1 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "1 " 
 -- IV:after:computeAdr:superAdj: 4 
 --  rec:  "1 "E:  "1 "
 -- INV:gen:E.loadArgs "1 "
 -- INV:gen:after:E.loadArgs "1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1 "
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "first: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- end:loadArgs:NonVirt: "
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --        Beq := false
 --        leave(loop)
 --   "
 -- NonVirt: 
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then "ObjectInvocation_KeyWord " ActArg: "length "isValue: false 
 --  formalArg: "last: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --        Beq := false
 --        leave(loop)
 --   " isCompositeValueObj: false 
 -- OG:before:super.gen: "length "
 -- INV:gen: "length " 
 -- needorigin: "length " 
 -- needOrigin:E: "length "  E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  Ex: "length " rec: "length " E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  E.ATd.desc: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  E.ATd.IT: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- doNeedOrigin:Ex: "length "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "length " 
 -- doNeedOrigin:E: "length " 
 -- computeAdrX:superAdj: 4 "length " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "length " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 rpushg loop$14 4
 -- items:goOrigin:encOG: "loop "on: 2 isValueObj: false 
 --  origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- items:goOrigin:encOG: "= "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg =$13 1
 -- computeAdrX:isLast:E:  "length "
 -- IV:after:computeAdr:superAdj: 4 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 --  rec:  "length "E:  "length "
 -- INV:gen:E.loadArgs "length "
 -- INV:gen:after:E.loadArgs "length "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- ptn:invoke: "length "E: "length "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "length " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- actualArg:isPtn: true formalArg:isPtn: "last: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "length ":isBasicVal: true 
 -- case:B: length ObjectGenerator 1 0 0 false false 
 -- end:loadArgs:NonVirt: "
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --        Beq := false
 --        leave(loop)
 --   "
 pushThis 
 storeg integer$5 2
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- DI:gen: "inx: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: inx 
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0

 CLASS <= 58 1 Value 4
 jmpFalse  L3
 pushThis 
 -- vassign:B: Veq off: 4 size: 2 mode: 0 
 vassign  4 2 0
 jmp L4
 L3:
 invokeVal  Veq 31 3
 rpop 
 L4:
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in Veq: var this(Value) " DI:isConst: false 
 --  isBasicValue: false primNo: 18 
 -- DI:isConst: Veq 
 -- inArg: in Veq: var this(Value) 
 -- DI:gen: "out Beq: var boolean " DI:isConst: false isBasicValue: 
 --  true primNo: 4 
 -- DI:gen:primitiveType: Beq 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0

 CLASS <= 109 1 String 10
 -- vdtTableCopy: I:1:58
 rShiftUp  1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- super <=
 pushThis 
 rpushg iOrigin 1
 rShiftDown  1
 pushThis 
 rstoreg  Veq 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in Veq: var this(Value) " DI:isConst: false 
 --  isBasicValue: false primNo: 18 
 -- DI:isConst: Veq 
 -- inArg: in Veq: var this(Value) 
 -- DI:gen: "out Beq: var boolean " DI:isConst: false isBasicValue: 
 --  true primNo: 4 
 -- DI:gen:primitiveType: Beq 
 -- DI:gen: 
 --  loop: obj 
 --     -- "Hello"  <= "World" since H <= W
 --     -- "Qweabc" <= "Qwevwxy" since a <= e
 --     -- "Qweayc" <= "Qwexby"DI:isConst: true isBasicValue: false primNo: 0 
 -- DI:isConst: loop 
 -- DI:off: 4 this: 
 --  loop: obj 
 --     -- "Hello"  <= "World" since H <= W
 --     -- "Qweabc" <= "Qwevwxy" since a <= e
 --     -- "Qweayc" <= "Qwexby"
 --  
 pushThis 
 -- before objTmpStack:add:  110   "loop "
 invoke loop 110 4 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS loop 110 1 <= 109
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "L: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: L 
 -- DI:gen: "L1: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: L1 
 -- DI:gen: "L2: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: L2 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: 
 --  L1 := length
 --  -- min length of this and V
 --  
 pushThis 
 -- AssignmentStatement:gen: 
 --  
 --  L1 := length
 --  -- min length of this and V
 --  right.label: "ObjectGenerator "
 --  length
 --  -- min length of this and V
 --  
 -- OG:before:super.gen: "length
 --  -- min length of this and V "
 -- INV:gen: 
 --  length
 --  -- min length of this and V
 --  
 -- needorigin: 
 --  length
 --  -- min length of this and V
 --  
 -- needOrigin:E: 
 --  length
 --  -- min length of this and V
 --   E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  Ex: 
 --  length
 --  -- min length of this and V
 --  rec: 
 --  length
 --  -- min length of this and V
 --  E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  E.ATd.desc: 
 -- \
 --   out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  E.ATd.IT: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- doNeedOrigin:Ex: "length
 --  -- min length of this and V "
 --  originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: 
 --  length
 --  -- min length of this and V
 --  
 -- doNeedOrigin:E: 
 --  length
 --  -- min length of this and V
 --  
 -- computeAdrX:superAdj: 0 
 --  length
 --  -- min length of this and V
 --  
 -- computeAdrX:En: 1 pRec: none rec: none E: 
 --  length
 --  -- min length of this and V
 --  
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 2 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$110 1
 -- items:goOrigin:encOG: "<= "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg <=$109 1
 -- computeAdrX:isLast:E:  "length
 --  -- min length of this and V "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length
 --  -- min length of this and V":rec:- 
 --  rec:  "length
 --  -- min length of this and V "E:  "
 --  length
 --  -- min length of this and V "
 -- INV:gen:E.loadArgs "length
 --  -- min length of this and V "
 -- INV:gen:after:E.loadArgs "length
 --  -- min length of this and V "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "
 --  length
 --  -- min length of this and V "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length
 --  -- min length of this and V":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- ptn:invoke: "length "E: "length
 --  -- min length of this and V "
 --  ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: 
 --  length
 --  -- min length of this and V
 --  
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length
 --  -- min length of this and V":rec:length
 --  -- min length of this and V 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length
 --  -- min length of this and V":rec:length
 --  -- min length of this and V 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length
 --  -- min length of this and V":rec:length
 --  -- min length of this and V 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length
 --  -- min length of this and V":rec:length
 --  -- min length of this and V 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length
 --  -- min length of this and V":rec:length
 --  -- min length of this and V 
 -- assign:adr.store:A: 
 storeg loop$110 3
 -- assign:adr.store:B: 
 -- AssignmentStatement:gen: "L2 := Veq.length " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "L2 := Veq.length " right.label: "ObjectGenerator ""Veq.length " 
 -- OG:before:super.gen: "Veq.length "
 -- INV:gen: "Veq.length " 
 -- needorigin: "Veq.length " 
 -- needOrigin:E: "length "  E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  Ex: "length " rec: "Veq " E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  E.ATd.desc: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  E.ATd.IT: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- doNeedOrigin:Ex: "length "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "length " 
 -- doNeedOrigin:E: "length " 
 -- computeAdrX:superAdj: 0 "Veq.length " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Veq " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$110 1
 -- computeAdrX:En: 2 pRec: "Veq " rec: "Veq " E: "length " 
 --  A.E: none 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "Veq " rec: "Veq " E: "length " 
 --  rec.ATd: "in Veq: var this(Value) " rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 --  recA: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 --  pRecA: none 
 -- pRec: "Veq " rec: "Veq " E: "length " 
 --  false true 
 -- computeAdrX:before:rec:: "Veq " 
 -- OI:invoke:before:ATdx.invoke: var Veq 
 -- DI:invoke: "in Veq: var this(Value) " 
 -- isValueObj:isAdr: true objSize: 2  rec "Veq ",E: "length ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- Address:loadAdr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 rpushg loop$110 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- computeAdrX:after:rec.invoke: "Veq " 
 -- computeAdrX:isLast:E:  "length "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 --  rec:  "Veq "E:  "length "
 -- INV:gen:E.loadArgs "length "
 -- INV:gen:after:E.loadArgs "length "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- ptn:invoke: "length "E: "length "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "Veq " 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- assign:adr.store:A: 
 storeg loop$110 4
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2 "
 -- INV:gen: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  
 -- needorigin: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  
 -- needOrigin:E: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  rec: 
 --  if (L1 < L2) :then 
 --     L := L1
 -- \
 --   :else 
 --     L := L2
 --  E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  E.ATd.desc: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  E.ATd.IT: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2 "E:  "
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2 "
 -- INV:gen:E.loadArgs "
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2 "
 -- INV:gen:after:E.loadArgs "
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThenElse "
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2 "
 -- OG:before:super.gen: "(L1 < L2) "
 -- INV:gen: "(L1 < L2) " 
 -- needorigin: "(L1 < L2) " 
 -- needOrigin:E: "(L1 < L2) "  E.ATd: 
 --  <  : 
 --     %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  Ex: "(L1 < L2) " rec: "(L1 < L2) " E.ATd: 
 --  <  : 
 --     %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  E.ATd.desc: 
 --  %basic 51
 --  in V: var integer
 --  out B: var boolean
 --  E.ATd.IT: 
 --  %basic 51
 --  in V: var integer
 --  out B: var boolean
 -- \
 --   
 -- doNeedOrigin:Ex: "(L1 < L2) "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(L1 < L2) " 
 -- doNeedOrigin:E: "(L1 < L2) " 
 -- computeAdrX:superAdj: 0 "(L1 < L2) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(L1 < L2) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "L1 < L2 "superAdj: 0 
 -- computeAdrX:isLast:E:  "L1 < L2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "L1 < L2 "E:  "L1 < L2 "
 -- INV:gen:E.loadArgs "L1 < L2 "
 -- BinaryExp:loadArgs: "L1 < L2 " superAdj: 0 
 -- INV:gen: "L1 " 
 -- needorigin: "L1 " 
 -- needOrigin:E: "L1 "  E.ATd: "L1: var integer " Ex: "L1 " rec: "
 --  L1 " E.ATd: "L1: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L1 " 
 -- doNeedOrigin:E: "L1 " 
 -- computeAdrX:superAdj: 0 "L1 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "L1 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 --  rec:  "L1 "E:  "L1 "
 -- INV:gen:E.loadArgs "L1 "
 -- INV:gen:after:E.loadArgs "L1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L1 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- DI:invoke: "L1: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 isNotRemote: true 
 pushg 3 loop$110
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- NonVirt: "< L2 " "ObjectInvocation_Binary " ActArg: "L2 "
 --  isValue: false formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "< L2 " isCompositeValueObj: false 
 -- OG:before:super.gen: "L2 "
 -- INV:gen: "L2 " 
 -- needorigin: "L2 " 
 -- needOrigin:E: "L2 "  E.ATd: "L2: var integer " Ex: "L2 " rec: "
 --  L2 " E.ATd: "L2: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L2 " 
 -- doNeedOrigin:E: "L2 " 
 -- computeAdrX:superAdj: 0 "L2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "L2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 --  rec:  "L2 "E:  "L2 "
 -- INV:gen:E.loadArgs "L2 "
 -- INV:gen:after:E.loadArgs "L2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L2 "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- DI:invoke: "L2: var integer " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 isNotRemote: true 
 pushg 4 loop$110
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "L2 ":isBasicVal: true 
 -- case:B: L2 ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "< L2 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:after:E.loadArgs "L1 < L2 "
 --  OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L1 < L2 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- BinaryExp:invoke: "L1 "rec: "L1 < L2 "
 -- M: "< L2 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:before:ATdx.invoke: pattern <   
 -- ptn:invoke: "<   "E: "< L2 "ptnKind: 0 useRtnV: true 
 lt
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< L2":rec:L1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< L2":rec:L1 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  112   "$112 "
 invoke $112 112 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L5
 L4:
 pushThis 
 -- before objTmpStack:add:  113   "$113 "
 invoke $113 113 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L5:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- OG:before:super.gen: "matchEq "
 -- INV:gen: "matchEq " 
 -- needorigin: "matchEq " 
 -- needOrigin:E: "matchEq "  E.ATd: 
 --  matchEq: 
 --     inx: var integer
 --     c1: var char
 --     c2: var charEx: "matchEq " rec: "matchEq " E.ATd: 
 --  matchEq: 
 --     inx: var integer
 --     c1: var char
 --     c2: var charE.ATd.desc: 
 --  inx: var integer
 --  c1: var char
 --  c2: var char
 --  isEmpty: do E.ATd.IT: 
 --  inx: var integer
 --  c1: var char
 --  c2: var char
 --  isEmpty: do 
 -- doNeedOrigin:Ex: "matchEq "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "matchEq " 
 -- doNeedOrigin:E: "matchEq " 
 -- computeAdrX:superAdj: 0 "matchEq " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "matchEq " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "matchEq "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:- 
 --  rec:  "matchEq "E:  "matchEq "
 -- INV:gen:E.loadArgs "matchEq "
 -- INV:gen:after:E.loadArgs "matchEq "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "matchEq "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern matchEq 
 -- ptn:invoke: "matchEq "E: "matchEq "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "matchEq " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:matchEq 
 invoke matchEq 114 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:matchEq 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:matchEq 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:matchEq 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS $112 112 1 loop 110
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "L := L1 " 
 pushThis 
 -- items:goOrigin:encOG: "$112 "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $112$112 1
 -- AssignmentStatement:gen: 
 --  "L := L1 " right.label: "ObjectGenerator ""L1 " 
 -- OG:before:super.gen: "L1 "
 -- INV:gen: "L1 " 
 -- needorigin: "L1 " 
 -- needOrigin:E: "L1 "  E.ATd: "L1: var integer " Ex: "L1 " rec: "
 --  L1 " E.ATd: "L1: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L1 " 
 -- doNeedOrigin:E: "L1 " 
 -- computeAdrX:superAdj: 0 "L1 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$112 "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $112$112 1
 -- computeAdrX:isLast:E:  "L1 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 --  rec:  "L1 "E:  "L1 "
 -- INV:gen:E.loadArgs "L1 "
 -- INV:gen:after:E.loadArgs "L1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L1 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- DI:invoke: "L1: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 isNotRemote: true 
 pushg 3 loop$110
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- assign:adr.store:A: 
 storeg loop$110 2
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $113 113 1 loop 110
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "L := L2 " 
 pushThis 
 -- items:goOrigin:encOG: "$113 "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $113$113 1
 -- AssignmentStatement:gen: 
 --  "L := L2 " right.label: "ObjectGenerator ""L2 " 
 -- OG:before:super.gen: "L2 "
 -- INV:gen: "L2 " 
 -- needorigin: "L2 " 
 -- needOrigin:E: "L2 "  E.ATd: "L2: var integer " Ex: "L2 " rec: "
 --  L2 " E.ATd: "L2: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L2 " 
 -- doNeedOrigin:E: "L2 " 
 -- computeAdrX:superAdj: 0 "L2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$113 "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $113$113 1
 -- computeAdrX:isLast:E:  "L2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 --  rec:  "L2 "E:  "L2 "
 -- INV:gen:E.loadArgs "L2 "
 -- INV:gen:after:E.loadArgs "L2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L2 "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- DI:invoke: "L2: var integer " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 isNotRemote: true 
 pushg 4 loop$110
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- assign:adr.store:A: 
 storeg loop$110 2
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS matchEq 114 1 loop 110
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "inx: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: inx 
 -- DI:gen: "c1: var char " DI:isConst: false isBasicValue: true 
 --  primNo: 3 
 -- DI:gen:primitiveType: c1 
 -- DI:gen: "c2: var char " DI:isConst: false isBasicValue: true 
 --  primNo: 3 
 -- DI:gen:primitiveType: c2 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 pushThis 
 -- before objTmpStack:add:  115   "isEmpty "
 invoke isEmpty 115 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  118   "loop "
 invoke loop 118 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  121   "doit "
 invoke doit 121 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS isEmpty 115 1 matchEq 114
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq) "
 -- INV:gen: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  
 -- needorigin: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  
 -- needOrigin:E: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  rec: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  E.ATd: 
 -- \
 --   if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  E.ATd.desc: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  E.ATd.IT: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq) "
 --  E:  "if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq) "
 -- INV:gen:E.loadArgs "
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq) "
 -- INV:gen:after:E.loadArgs "
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq) "
 -- OG:before:super.gen: "(L1 = 0) "
 -- INV:gen: "(L1 = 0) " 
 -- needorigin: "(L1 = 0) " 
 -- needOrigin:E: "(L1 = 0) "  E.ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var booleanEx: "(L1 = 0) " rec: "(L1 = 0) " E.ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var booleanE.ATd.desc: 
 --  %basic 50
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  inner(= )
 --  E.ATd.IT: 
 --  %basic 50
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  inner(= )
 -- \
 --   
 -- doNeedOrigin:Ex: "(L1 = 0) "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(L1 = 0) " 
 -- doNeedOrigin:E: "(L1 = 0) " 
 -- computeAdrX:superAdj: 0 "(L1 = 0) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(L1 = 0) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "L1 = 0 "superAdj: 0 
 -- computeAdrX:isLast:E:  "L1 = 0 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "L1 = 0 "E:  "L1 = 0 "
 -- INV:gen:E.loadArgs "L1 = 0 "
 -- BinaryExp:loadArgs: "L1 = 0 " superAdj: 0 
 -- INV:gen: "L1 " 
 -- needorigin: "L1 " 
 -- needOrigin:E: "L1 "  E.ATd: "L1: var integer " Ex: "L1 " rec: "
 --  L1 " E.ATd: "L1: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L1 " 
 -- doNeedOrigin:E: "L1 " 
 -- computeAdrX:superAdj: 0 "L1 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "isEmpty "on: 2 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$115 1
 -- items:goOrigin:encOG: "matchEq "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$114 1
 -- computeAdrX:isLast:E:  "L1 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 --  rec:  "L1 "E:  "L1 "
 -- INV:gen:E.loadArgs "L1 "
 -- INV:gen:after:E.loadArgs "L1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L1 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- DI:invoke: "L1: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 isNotRemote: true 
 pushg 3 loop$110
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- NonVirt: "= 0 " "ObjectInvocation_Binary " ActArg: "0 "isValue: 
 --  true formalArg: "in Veq: var this(Value) " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "= 0 " isCompositeValueObj: true 
 -- OG:before:super.gen: "0 "
 -- INV:gen: "0 " 
 -- needorigin: "0 " 
 -- needOrigin:E: "0 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "0 " rec: "0 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "0 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "0 "E:  "0 "
 -- INV:gen:E.loadArgs "0 "
 -- INV:gen:after:E.loadArgs "0 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0 "
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- vEq: 
 -- end:loadArgs:NonVirt: "= 0 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:after:E.loadArgs "L1 = 0 "
 --  OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L1 = 0 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- BinaryExp:invoke: "L1 "rec: "L1 = 0 "
 -- M: "= 0 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:before:ATdx.invoke: pattern =   
 -- ptn:invoke: "=   "E: "= 0 "ptnKind: 1 useRtnV: true 
 -- E: "= 0 " rec: "L1 ""Invocation "OGx: "integer " 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- rec.ATd: "L1: var integer " 
 -- bobs: 1 OGx: "integer " 
 -- 
 eq
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= 0":rec:L1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= 0":rec:L1 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  116   "$116 "
 invoke $116 116 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- OG:before:super.gen: "
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq) "
 -- INV:gen: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  
 -- needorigin: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  
 -- needOrigin:E: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  rec: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  E.ATd: 
 -- \
 --   if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  E.ATd.desc: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  E.ATd.IT: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq) "E:  "
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq) "
 -- INV:gen:E.loadArgs "
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq) "
 -- INV:gen:after:E.loadArgs "
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq) "
 -- OG:before:super.gen: "(L2 = 0) "
 -- INV:gen: "(L2 = 0) " 
 -- needorigin: "(L2 = 0) " 
 -- needOrigin:E: "(L2 = 0) "  E.ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var booleanEx: "(L2 = 0) " rec: "(L2 = 0) " E.ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var booleanE.ATd.desc: 
 --  %basic 50
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  inner(= )
 --  E.ATd.IT: 
 --  %basic 50
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  inner(= )
 -- \
 --   
 -- doNeedOrigin:Ex: "(L2 = 0) "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(L2 = 0) " 
 -- doNeedOrigin:E: "(L2 = 0) " 
 -- computeAdrX:superAdj: 0 "(L2 = 0) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(L2 = 0) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "L2 = 0 "superAdj: 0 
 -- computeAdrX:isLast:E:  "L2 = 0 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "L2 = 0 "E:  "L2 = 0 "
 -- INV:gen:E.loadArgs "L2 = 0 "
 -- BinaryExp:loadArgs: "L2 = 0 " superAdj: 0 
 -- INV:gen: "L2 " 
 -- needorigin: "L2 " 
 -- needOrigin:E: "L2 "  E.ATd: "L2: var integer " Ex: "L2 " rec: "
 --  L2 " E.ATd: "L2: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L2 " 
 -- doNeedOrigin:E: "L2 " 
 -- computeAdrX:superAdj: 0 "L2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "isEmpty "on: 2 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$115 1
 -- items:goOrigin:encOG: "matchEq "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$114 1
 -- computeAdrX:isLast:E:  "L2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 --  rec:  "L2 "E:  "L2 "
 -- INV:gen:E.loadArgs "L2 "
 -- INV:gen:after:E.loadArgs "L2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L2 "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- DI:invoke: "L2: var integer " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 isNotRemote: true 
 pushg 4 loop$110
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- INV:gen:end:off: 4 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- NonVirt: "= 0 " "ObjectInvocation_Binary " ActArg: "0 "isValue: 
 --  true formalArg: "in Veq: var this(Value) " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "= 0 " isCompositeValueObj: true 
 -- OG:before:super.gen: "0 "
 -- INV:gen: "0 " 
 -- needorigin: "0 " 
 -- needOrigin:E: "0 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "0 " rec: "0 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "0 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "0 "E:  "0 "
 -- INV:gen:E.loadArgs "0 "
 -- INV:gen:after:E.loadArgs "0 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0 "
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- vEq: 
 -- end:loadArgs:NonVirt: "= 0 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- INV:gen:after:E.loadArgs "L2 = 0 "
 --  OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L2 = 0 "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- BinaryExp:invoke: "L2 "rec: "L2 = 0 "
 -- M: "= 0 "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:before:ATdx.invoke: pattern =   
 -- ptn:invoke: "=   "E: "= 0 "ptnKind: 1 useRtnV: true 
 -- E: "= 0 " rec: "L2 ""Invocation "OGx: "integer " 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- rec.ATd: "L2: var integer " 
 -- bobs: 1 OGx: "integer " 
 -- 
 eq
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= 0":rec:L2 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= 0":rec:L2 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L7
 L6:
 pushThis 
 -- before objTmpStack:add:  117   "$117 "
 invoke $117 117 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L7:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $116 116 1 isEmpty 115
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "Beq := L1 <= L2 " 
 pushThis 
 -- items:goOrigin:encOG: "$116 "on: 4 isValueObj: false 
 --  origin: isEmpty origin:isValueObj: false 
 rpushg $116$116 1
 -- items:goOrigin:encOG: "isEmpty "on: 3 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$115 1
 -- items:goOrigin:encOG: "matchEq "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$114 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$110 1
 -- AssignmentStatement:gen: 
 --  "Beq := L1 <= L2 " right.label: "ObjectGenerator ""L1 <= L2 " 
 -- OG:before:super.gen: "L1 <= L2 "
 -- INV:gen: "L1 <= L2 " 
 -- needorigin: "L1 <= L2 " 
 -- needOrigin:E: "L1 <= L2 "  E.ATd: 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  Ex: "L1 <= L2 " rec: "L1 <= L2 " E.ATd: 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  E.ATd.desc: 
 --  %basic 52
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  E.ATd.IT: 
 --  %basic 52
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 -- \
 --   
 -- doNeedOrigin:Ex: "L1 <= L2 "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "L1 <= L2 " 
 -- doNeedOrigin:E: "L1 <= L2 " 
 -- computeAdrX:superAdj: 0 "L1 <= L2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L1 <= L2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "L1 <= L2 "superAdj: 0 
 -- computeAdrX:isLast:E:  "L1 <= L2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "L1 <= L2 "E:  "L1 <= L2 "
 -- INV:gen:E.loadArgs "L1 <= L2 "
 -- BinaryExp:loadArgs: "L1 <= L2 " superAdj: 0 
 -- INV:gen: "L1 " 
 -- needorigin: "L1 " 
 -- needOrigin:E: "L1 "  E.ATd: "L1: var integer " Ex: "L1 " rec: "
 --  L1 " E.ATd: "L1: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L1 " 
 -- doNeedOrigin:E: "L1 " 
 -- computeAdrX:superAdj: 0 "L1 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$116 "on: 3 isValueObj: false 
 --  origin: isEmpty origin:isValueObj: false 
 rpushg $116$116 1
 -- items:goOrigin:encOG: "isEmpty "on: 2 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$115 1
 -- items:goOrigin:encOG: "matchEq "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$114 1
 -- computeAdrX:isLast:E:  "L1 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 --  rec:  "L1 "E:  "L1 "
 -- INV:gen:E.loadArgs "L1 "
 -- INV:gen:after:E.loadArgs "L1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L1 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- DI:invoke: "L1: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 isNotRemote: true 
 pushg 3 loop$110
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- NonVirt: "<= L2 " "ObjectInvocation_Binary " ActArg: "L2 "
 --  isValue: false formalArg: "in Veq: var this(Value) " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "<= L2 " isCompositeValueObj: true 
 -- OG:before:super.gen: "L2 "
 -- INV:gen: "L2 " 
 -- needorigin: "L2 " 
 -- needOrigin:E: "L2 "  E.ATd: "L2: var integer " Ex: "L2 " rec: "
 --  L2 " E.ATd: "L2: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L2 " 
 -- doNeedOrigin:E: "L2 " 
 -- computeAdrX:superAdj: 0 "L2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$116 "on: 3 isValueObj: false 
 --  origin: isEmpty origin:isValueObj: false 
 rpushg $116$116 1
 -- items:goOrigin:encOG: "isEmpty "on: 2 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$115 1
 -- items:goOrigin:encOG: "matchEq "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$114 1
 -- computeAdrX:isLast:E:  "L2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 --  rec:  "L2 "E:  "L2 "
 -- INV:gen:E.loadArgs "L2 "
 -- INV:gen:after:E.loadArgs "L2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L2 "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- DI:invoke: "L2: var integer " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 isNotRemote: true 
 pushg 4 loop$110
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- vEq: 
 -- end:loadArgs:NonVirt: "<= L2 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:after:E.loadArgs "L1 <= L2 "
 --  OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L1 <= L2 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- BinaryExp:invoke: "L1 "rec: "L1 <= L2 "
 -- M: "<= L2 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:before:ATdx.invoke: pattern <=   
 -- ptn:invoke: "<=   "E: "<= L2 "ptnKind: 1 useRtnV: true 
 -- E: "<= L2 " rec: "L1 ""Invocation "OGx: "integer " 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- rec.ATd: "L1: var integer " 
 -- bobs: 1 OGx: "integer " 
 -- 
 le
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<= L2":rec:L1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<= L2":rec:L1 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg <=$109 3
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "leave(matchEq) "
 -- INV:gen: "leave(matchEq) " 
 -- needorigin: "leave(matchEq) " 
 -- needOrigin:E: "leave(matchEq) "  E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  Ex: "leave(matchEq) " rec: "leave(matchEq) " E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  E.ATd.desc: "%basic 103 " E.ATd.IT: "%basic 103 " 
 -- doNeedOrigin:Ex: "leave(matchEq) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "leave(matchEq) " 
 -- doNeedOrigin:E: "leave(matchEq) " 
 -- computeAdrX:superAdj: 0 "leave(matchEq) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "leave(matchEq) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "leave(matchEq) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 --  rec:  "leave(matchEq) "E:  "leave(matchEq) "
 -- INV:gen:E.loadArgs "leave(matchEq) "
 -- INV:gen:after:E.loadArgs "leave(matchEq) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  leave(matchEq) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- ptn:invoke: "leave(V: var integer) "E: "leave(matchEq) "ptnKind: 0 
 --  useRtnV: false 
 break  2 2 114 0
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $117 117 1 isEmpty 115
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "Beq := false " 
 pushThis 
 -- items:goOrigin:encOG: "$117 "on: 4 isValueObj: false 
 --  origin: isEmpty origin:isValueObj: false 
 rpushg $117$117 1
 -- items:goOrigin:encOG: "isEmpty "on: 3 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$115 1
 -- items:goOrigin:encOG: "matchEq "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$114 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$110 1
 -- AssignmentStatement:gen: 
 --  "Beq := false " right.label: "ObjectGenerator ""false " 
 -- OG:before:super.gen: "false "
 -- INV:gen: "false " 
 -- needorigin: "false " 
 -- needOrigin:E: "false "  E.ATd: 
 --  False: 
 --     %globals
 --     out B: var boolean
 --     B := 0
 --  Ex: "false " rec: "false " E.ATd: 
 --  False: 
 --     %globals
 --     out B: var boolean
 --     B := 0
 --  E.ATd.desc: 
 --  %globals
 --  out B: var boolean
 --  B := 0
 --  E.ATd.IT: 
 --  %globals
 --  out B: var boolean
 --  B := 0
 -- \
 --   
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %globals
 --     out B: var boolean
 --     B := 0
 --  
 -- after:needOrigin: "false " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "false "E:  "false "
 -- INV:gen:E.loadArgs "false "
 -- INV:gen:after:E.loadArgs "false "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "false "
 -- OI:invoke:before:ATdx.invoke: pattern False 
 -- ptn:invoke: "False "E: "false "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "false " 
 --  adr:none 
 invoke False 27 0 0
 -- global:pushOut: B off: 1 
 pushg 1 
 -- callInvoke:after:pushOut: 1 
 -- GeneralPTN:invoke:after:callInvoke: 1 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg <=$109 3
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "leave(matchEq) "
 -- INV:gen: "leave(matchEq) " 
 -- needorigin: "leave(matchEq) " 
 -- needOrigin:E: "leave(matchEq) "  E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  Ex: "leave(matchEq) " rec: "leave(matchEq) " E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  E.ATd.desc: "%basic 103 " E.ATd.IT: "%basic 103 " 
 -- doNeedOrigin:Ex: "leave(matchEq) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "leave(matchEq) " 
 -- doNeedOrigin:E: "leave(matchEq) " 
 -- computeAdrX:superAdj: 0 "leave(matchEq) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "leave(matchEq) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "leave(matchEq) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 --  rec:  "leave(matchEq) "E:  "leave(matchEq) "
 -- INV:gen:E.loadArgs "leave(matchEq) "
 -- INV:gen:after:E.loadArgs "leave(matchEq) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  leave(matchEq) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- ptn:invoke: "leave(V: var integer) "E: "leave(matchEq) "ptnKind: 0 
 --  useRtnV: false 
 break  2 2 114 0
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS loop 118 1 matchEq 114
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "inx := inx + 1 " 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$118 1
 -- AssignmentStatement:gen: 
 --  "inx := inx + 1 " right.label: "ObjectGenerator ""inx + 1 " 
 -- OG:before:super.gen: "inx + 1 "
 -- INV:gen: "inx + 1 " 
 -- needorigin: "inx + 1 " 
 -- needOrigin:E: "inx + 1 "  E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  Ex: "inx + 1 " rec: "inx + 1 " E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  E.ATd.desc: 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 --  E.ATd.IT: 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 -- \
 --   
 -- doNeedOrigin:Ex: "inx + 1 "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inx + 1 " 
 -- doNeedOrigin:E: "inx + 1 " 
 -- computeAdrX:superAdj: 0 "inx + 1 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx + 1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "inx + 1 "superAdj: 0 
 -- computeAdrX:isLast:E:  "inx + 1 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "inx + 1 "E:  "inx + 1 "
 -- INV:gen:E.loadArgs "inx + 1 "
 -- BinaryExp:loadArgs: "inx + 1 " superAdj: 0 
 -- INV:gen: "inx " 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$118 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 2 matchEq$114
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- NonVirt: "+ 1 " "ObjectInvocation_Binary " ActArg: "1 "isValue: 
 --  true formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ 1 " isCompositeValueObj: false 
 -- OG:before:super.gen: "1 "
 -- INV:gen: "1 " 
 -- needorigin: "1 " 
 -- needOrigin:E: "1 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "1 " rec: "1 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "1 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "1 "E:  "1 "
 -- INV:gen:E.loadArgs "1 "
 -- INV:gen:after:E.loadArgs "1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1 "
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- end:loadArgs:NonVirt: "+ 1 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:after:E.loadArgs "inx + 1 "
 --  OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- IV:E.invoke:useRtnVal: true E: BinOp "inx + 1 "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- BinaryExp:invoke: "inx "rec: "inx + 1 "
 -- M: "+ 1 "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- ptn:invoke: "+   "E: "+ 1 "ptnKind: 0 useRtnV: true 
 plus
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:inx 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg matchEq$114 2
 -- assign:adr.store:B: 
 -- AssignmentStatement:gen: "c1 := get[inx] " 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$118 1
 -- AssignmentStatement:gen: 
 --  "c1 := get[inx] " right.label: "ObjectGenerator ""get[inx] " 
 -- OG:before:super.gen: "get[inx] "
 -- INV:gen: "get[inx] " 
 -- needorigin: "get[inx] " 
 -- needOrigin:E: "get[inx] "  E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  Ex: "get[inx] " rec: "get[inx] " E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  E.ATd.desc: 
 --  %basic 117
 --  out ch: var char
 --  E.ATd.IT: 
 --  %basic 117
 --  out ch: var char
 --  
 -- doNeedOrigin:Ex: "get[inx] "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "get[inx] " 
 -- doNeedOrigin:E: "get[inx] " 
 -- computeAdrX:superAdj: 0 "get[inx] " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "get[inx] " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 4 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$118 1
 -- items:goOrigin:encOG: "matchEq "on: 3 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$114 1
 -- items:goOrigin:encOG: "loop "on: 2 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$110 1
 -- items:goOrigin:encOG: "<= "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg <=$109 1
 -- computeAdrX:isLast:E:  "get[inx] "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 --  rec:  "get[inx] "E:  "get[inx] "
 -- INV:gen:E.loadArgs "get[inx] "
 -- NonVirt: "get[inx] " "ObjectInvocation_KeyWord " ActArg: "inx "
 --  isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx] " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "inx "
 -- INV:gen: "inx " 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$118 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 2 matchEq$114
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "get[inx] "
 -- INV:gen:after:E.loadArgs "get[inx] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx] "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- ptn:invoke: "get[inx: var integer] "E: "get[inx] "ptnKind: 0 
 --  useRtnV: true 
 xpushg  inx 1 0 1
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- assign:adr.store:A: 
 storeg matchEq$114 3
 -- assign:adr.store:B: 
 -- AssignmentStatement:gen: "c2 := Veq.get[inx] " 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$118 1
 -- AssignmentStatement:gen: 
 --  "c2 := Veq.get[inx] " right.label: "ObjectGenerator ""
 --  Veq.get[inx] " 
 -- OG:before:super.gen: "Veq.get[inx] "
 -- INV:gen: "Veq.get[inx] " 
 -- needorigin: "Veq.get[inx] " 
 -- needOrigin:E: "get[inx] "  E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  Ex: "get[inx] " rec: "Veq " E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  E.ATd.desc: 
 --  %basic 117
 --  out ch: var char
 --  E.ATd.IT: 
 --  %basic 117
 --  out ch: var char
 --  
 -- doNeedOrigin:Ex: "get[inx] "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "get[inx] " 
 -- doNeedOrigin:E: "get[inx] " 
 -- computeAdrX:superAdj: 0 "Veq.get[inx] " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Veq " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 3 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$118 1
 -- items:goOrigin:encOG: "matchEq "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$114 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$110 1
 -- computeAdrX:En: 2 pRec: "Veq " rec: "Veq " E: "get[inx] " 
 --  A.E: none 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "Veq " rec: "Veq " E: "get[inx] " 
 --  rec.ATd: "in Veq: var this(Value) " rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 --  recA: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 --  pRecA: none 
 -- pRec: "Veq " rec: "Veq " E: "get[inx] " 
 --  false true 
 -- computeAdrX:before:rec:: "Veq " 
 -- OI:invoke:before:ATdx.invoke: var Veq 
 -- DI:invoke: "in Veq: var this(Value) " 
 -- isValueObj:isAdr: true objSize: 2  rec "Veq ",E: "get[inx] ""
 --  ObjectInvocation_KeyWord "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- Address:loadAdr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 rpushg loop$118 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- computeAdrX:after:rec.invoke: "Veq " 
 -- computeAdrX:isLast:E:  "get[inx] "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 --  rec:  "Veq "E:  "get[inx] "
 -- INV:gen:E.loadArgs "get[inx] "
 -- NonVirt: "get[inx] " "ObjectInvocation_KeyWord " ActArg: "inx "
 --  isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx] " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "inx "
 -- INV:gen: "inx " 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$118 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 2 matchEq$114
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "get[inx] "
 -- INV:gen:after:E.loadArgs "get[inx] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx] "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- ptn:invoke: "get[inx: var integer] "E: "get[inx] "ptnKind: 0 
 --  useRtnV: true 
 xpushg  inx 1 0 1
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- assign:adr.store:A: 
 storeg matchEq$114 4
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop) "
 -- INV:gen: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  
 -- needorigin: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  
 -- needOrigin:E: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  rec: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  E.ATd: 
 -- \
 --   if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  E.ATd.desc: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  E.ATd.IT: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop) "E:  "
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop) "
 -- INV:gen:E.loadArgs "
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop) "
 -- INV:gen:after:E.loadArgs "
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop) "
 -- OG:before:super.gen: "(c1 = c2) "
 -- INV:gen: "(c1 = c2) " 
 -- needorigin: "(c1 = c2) " 
 -- needOrigin:E: "(c1 = c2) "  E.ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var booleanEx: "(c1 = c2) " rec: "(c1 = c2) " E.ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var booleanE.ATd.desc: 
 --  %basic 50
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  inner(= )
 --  E.ATd.IT: 
 --  %basic 50
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  inner(= )
 -- \
 --   
 -- doNeedOrigin:Ex: "(c1 = c2) "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(c1 = c2) " 
 -- doNeedOrigin:E: "(c1 = c2) " 
 -- computeAdrX:superAdj: 0 "(c1 = c2) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(c1 = c2) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "c1 = c2 "superAdj: 0 
 -- computeAdrX:isLast:E:  "c1 = c2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "c1 = c2 "E:  "c1 = c2 "
 -- INV:gen:E.loadArgs "c1 = c2 "
 -- BinaryExp:loadArgs: "c1 = c2 " superAdj: 0 
 -- INV:gen: "c1 " 
 -- needorigin: "c1 " 
 -- needOrigin:E: "c1 "  E.ATd: "c1: var char " Ex: "c1 " rec: "c1 " 
 --  E.ATd: "c1: var char " E.ATd.desc: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "c1 " 
 -- doNeedOrigin:E: "c1 " 
 -- computeAdrX:superAdj: 0 "c1 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "c1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$118 1
 -- computeAdrX:isLast:E:  "c1 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 --  rec:  "c1 "E:  "c1 "
 -- INV:gen:E.loadArgs "c1 "
 -- INV:gen:after:E.loadArgs "c1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c1 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var c1 
 -- DI:invoke: "c1: var char " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 isNotRemote: true 
 pushg 3 matchEq$114
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- NonVirt: "= c2 " "ObjectInvocation_Binary " ActArg: "c2 "
 --  isValue: false formalArg: "in Veq: var this(Value) " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "= c2 " isCompositeValueObj: true 
 -- OG:before:super.gen: "c2 "
 -- INV:gen: "c2 " 
 -- needorigin: "c2 " 
 -- needOrigin:E: "c2 "  E.ATd: "c2: var char " Ex: "c2 " rec: "c2 " 
 --  E.ATd: "c2: var char " E.ATd.desc: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "c2 " 
 -- doNeedOrigin:E: "c2 " 
 -- computeAdrX:superAdj: 0 "c2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "c2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$118 1
 -- computeAdrX:isLast:E:  "c2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 --  rec:  "c2 "E:  "c2 "
 -- INV:gen:E.loadArgs "c2 "
 -- INV:gen:after:E.loadArgs "c2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c2 "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var c2 
 -- DI:invoke: "c2: var char " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 isNotRemote: true 
 pushg 4 matchEq$114
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- vEq: 
 -- end:loadArgs:NonVirt: "= c2 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:after:E.loadArgs "c1 = c2 "
 --  OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "c1 = c2 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- BinaryExp:invoke: "c1 "rec: "c1 = c2 "
 -- M: "= c2 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:before:ATdx.invoke: pattern =   
 -- ptn:invoke: "=   "E: "= c2 "ptnKind: 1 useRtnV: true 
 -- E: "= c2 " rec: "c1 ""Invocation "OGx: "char " 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- rec.ATd: "c1: var char " 
 -- bobs: 3 OGx: "char " 
 -- 
 eq
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= c2":rec:c1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= c2":rec:c1 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  119   "$119 "
 invoke $119 119 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $119 119 1 loop 118
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "if (inx < L) :then 
 --     restart(loop) "
 -- INV:gen: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  
 -- needorigin: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  
 -- needOrigin:E: 
 --  if (inx < L) :then 
 --     restart(loop)
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  rec: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 -- \
 --      %globals inSub
 --  E.ATd.desc: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  E.ATd.IT: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "if (inx < L) :then 
 --     restart(loop) "E:  "
 --  if (inx < L) :then 
 --     restart(loop) "
 -- INV:gen:E.loadArgs "if (inx < L) :then 
 --     restart(loop) "
 -- INV:gen:after:E.loadArgs "if (inx < L) :then 
 --     restart(loop) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "
 --  if (inx < L) :then 
 --     restart(loop) "
 -- OG:before:super.gen: "(inx < L) "
 -- INV:gen: "(inx < L) " 
 -- needorigin: "(inx < L) " 
 -- needOrigin:E: "(inx < L) "  E.ATd: 
 --  <  : 
 --     %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  Ex: "(inx < L) " rec: "(inx < L) " E.ATd: 
 --  <  : 
 --     %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  E.ATd.desc: 
 --  %basic 51
 --  in V: var integer
 --  out B: var boolean
 --  E.ATd.IT: 
 --  %basic 51
 --  in V: var integer
 --  out B: var boolean
 -- \
 --   
 -- doNeedOrigin:Ex: "(inx < L) "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(inx < L) " 
 -- doNeedOrigin:E: "(inx < L) " 
 -- computeAdrX:superAdj: 0 "(inx < L) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(inx < L) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "inx < L "superAdj: 0 
 -- computeAdrX:isLast:E:  "inx < L "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "inx < L "E:  "inx < L "
 -- INV:gen:E.loadArgs "inx < L "
 -- BinaryExp:loadArgs: "inx < L " superAdj: 0 
 -- INV:gen: "inx " 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$119 "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $119$119 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$118 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 2 matchEq$114
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- NonVirt: "< L " "ObjectInvocation_Binary " ActArg: "L "isValue: 
 --  false formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "< L " isCompositeValueObj: false 
 -- OG:before:super.gen: "L "
 -- INV:gen: "L " 
 -- needorigin: "L " 
 -- needOrigin:E: "L "  E.ATd: "L: var integer " Ex: "L " rec: "L " 
 --  E.ATd: "L: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L " 
 -- doNeedOrigin:E: "L " 
 -- computeAdrX:superAdj: 0 "L " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$119 "on: 3 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $119$119 1
 -- items:goOrigin:encOG: "loop "on: 2 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$118 1
 -- items:goOrigin:encOG: "matchEq "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$114 1
 -- computeAdrX:isLast:E:  "L "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 --  rec:  "L "E:  "L "
 -- INV:gen:E.loadArgs "L "
 -- INV:gen:after:E.loadArgs "L "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- DI:invoke: "L: var integer " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L isNotRemote: true 
 pushg 2 loop$110
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "L ":isBasicVal: true 
 -- case:B: L ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "< L "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:after:E.loadArgs "inx < L "
 --  OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- IV:E.invoke:useRtnVal: true E: BinOp "inx < L "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- BinaryExp:invoke: "inx "rec: "inx < L "
 -- M: "< L "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:before:ATdx.invoke: pattern <   
 -- ptn:invoke: "<   "E: "< L "ptnKind: 0 useRtnV: true 
 lt
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< L":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< L":rec:inx 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  120   "$120 "
 invoke $120 120 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $120 120 1 $119 119
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "restart(loop) "
 -- INV:gen: "restart(loop) " 
 -- needorigin: "restart(loop) " 
 -- needOrigin:E: "restart(loop) "  E.ATd: 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  Ex: "restart(loop) " rec: "restart(loop) " E.ATd: 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  E.ATd.desc: "%basic 102 " E.ATd.IT: "%basic 102 " 
 -- doNeedOrigin:Ex: "restart(loop) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "restart(loop) " 
 -- doNeedOrigin:E: "restart(loop) " 
 -- computeAdrX:superAdj: 0 "restart(loop) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "restart(loop) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "restart(loop) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:- 
 --  rec:  "restart(loop) "E:  "restart(loop) "
 -- INV:gen:E.loadArgs "restart(loop) "
 -- INV:gen:after:E.loadArgs "restart(loop) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  restart(loop) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern restart(V: var integer) 
 -- ptn:invoke: "restart(V: var integer) "E: "restart(loop) "
 --  ptnKind: 0 useRtnV: false 
 break  2 1 118 0
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS doit 121 1 matchEq 114
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 --     Beq := c1 < c2
 --     leave(matchEq) "
 -- INV:gen: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 -- needorigin: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 -- needOrigin:E: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else  E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else rec: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else E.ATd: 
 -- \
 --   if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  E.ATd.desc: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  E.ATd.IT: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 --     Beq := c1 < c2
 --     leave(matchEq) "E:  "
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 --     Beq := c1 < c2
 --     leave(matchEq) "
 -- INV:gen:E.loadArgs "
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 --     Beq := c1 < c2
 --     leave(matchEq) "
 -- INV:gen:after:E.loadArgs "
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 --     Beq := c1 < c2
 --     leave(matchEq) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThenElse "
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 --     Beq := c1 < c2
 --     leave(matchEq) "
 -- OG:before:super.gen: "(c1 = c2) "
 -- INV:gen: "(c1 = c2) " 
 -- needorigin: "(c1 = c2) " 
 -- needOrigin:E: "(c1 = c2) "  E.ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var booleanEx: "(c1 = c2) " rec: "(c1 = c2) " E.ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var booleanE.ATd.desc: 
 --  %basic 50
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  inner(= )
 --  E.ATd.IT: 
 --  %basic 50
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  inner(= )
 -- \
 --   
 -- doNeedOrigin:Ex: "(c1 = c2) "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(c1 = c2) " 
 -- doNeedOrigin:E: "(c1 = c2) " 
 -- computeAdrX:superAdj: 0 "(c1 = c2) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(c1 = c2) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "c1 = c2 "superAdj: 0 
 -- computeAdrX:isLast:E:  "c1 = c2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "c1 = c2 "E:  "c1 = c2 "
 -- INV:gen:E.loadArgs "c1 = c2 "
 -- BinaryExp:loadArgs: "c1 = c2 " superAdj: 0 
 -- INV:gen: "c1 " 
 -- needorigin: "c1 " 
 -- needOrigin:E: "c1 "  E.ATd: "c1: var char " Ex: "c1 " rec: "c1 " 
 --  E.ATd: "c1: var char " E.ATd.desc: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "c1 " 
 -- doNeedOrigin:E: "c1 " 
 -- computeAdrX:superAdj: 0 "c1 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "c1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "doit "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$121 1
 -- computeAdrX:isLast:E:  "c1 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 --  rec:  "c1 "E:  "c1 "
 -- INV:gen:E.loadArgs "c1 "
 -- INV:gen:after:E.loadArgs "c1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c1 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var c1 
 -- DI:invoke: "c1: var char " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 isNotRemote: true 
 pushg 3 matchEq$114
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- NonVirt: "= c2 " "ObjectInvocation_Binary " ActArg: "c2 "
 --  isValue: false formalArg: "in Veq: var this(Value) " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "= c2 " isCompositeValueObj: true 
 -- OG:before:super.gen: "c2 "
 -- INV:gen: "c2 " 
 -- needorigin: "c2 " 
 -- needOrigin:E: "c2 "  E.ATd: "c2: var char " Ex: "c2 " rec: "c2 " 
 --  E.ATd: "c2: var char " E.ATd.desc: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "c2 " 
 -- doNeedOrigin:E: "c2 " 
 -- computeAdrX:superAdj: 0 "c2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "c2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "doit "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$121 1
 -- computeAdrX:isLast:E:  "c2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 --  rec:  "c2 "E:  "c2 "
 -- INV:gen:E.loadArgs "c2 "
 -- INV:gen:after:E.loadArgs "c2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c2 "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var c2 
 -- DI:invoke: "c2: var char " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 isNotRemote: true 
 pushg 4 matchEq$114
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- vEq: 
 -- end:loadArgs:NonVirt: "= c2 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:after:E.loadArgs "c1 = c2 "
 --  OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "c1 = c2 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- BinaryExp:invoke: "c1 "rec: "c1 = c2 "
 -- M: "= c2 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:before:ATdx.invoke: pattern =   
 -- ptn:invoke: "=   "E: "= c2 "ptnKind: 1 useRtnV: true 
 -- E: "= c2 " rec: "c1 ""Invocation "OGx: "char " 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- rec.ATd: "c1: var char " 
 -- bobs: 3 OGx: "char " 
 -- 
 eq
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= c2":rec:c1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= c2":rec:c1 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  122   "$122 "
 invoke $122 122 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L5
 L4:
 pushThis 
 -- before objTmpStack:add:  123   "$123 "
 invoke $123 123 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L5:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $122 122 1 doit 121
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "Beq := L1 <= L2 " 
 pushThis 
 -- items:goOrigin:encOG: "$122 "on: 4 isValueObj: false 
 --  origin: doit origin:isValueObj: false 
 rpushg $122$122 1
 -- items:goOrigin:encOG: "doit "on: 3 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$121 1
 -- items:goOrigin:encOG: "matchEq "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$114 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$110 1
 -- AssignmentStatement:gen: 
 --  "Beq := L1 <= L2 " right.label: "ObjectGenerator ""L1 <= L2 " 
 -- OG:before:super.gen: "L1 <= L2 "
 -- INV:gen: "L1 <= L2 " 
 -- needorigin: "L1 <= L2 " 
 -- needOrigin:E: "L1 <= L2 "  E.ATd: 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  Ex: "L1 <= L2 " rec: "L1 <= L2 " E.ATd: 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  E.ATd.desc: 
 --  %basic 52
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  E.ATd.IT: 
 --  %basic 52
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 -- \
 --   
 -- doNeedOrigin:Ex: "L1 <= L2 "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "L1 <= L2 " 
 -- doNeedOrigin:E: "L1 <= L2 " 
 -- computeAdrX:superAdj: 0 "L1 <= L2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L1 <= L2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "L1 <= L2 "superAdj: 0 
 -- computeAdrX:isLast:E:  "L1 <= L2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "L1 <= L2 "E:  "L1 <= L2 "
 -- INV:gen:E.loadArgs "L1 <= L2 "
 -- BinaryExp:loadArgs: "L1 <= L2 " superAdj: 0 
 -- INV:gen: "L1 " 
 -- needorigin: "L1 " 
 -- needOrigin:E: "L1 "  E.ATd: "L1: var integer " Ex: "L1 " rec: "
 --  L1 " E.ATd: "L1: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L1 " 
 -- doNeedOrigin:E: "L1 " 
 -- computeAdrX:superAdj: 0 "L1 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$122 "on: 3 isValueObj: false 
 --  origin: doit origin:isValueObj: false 
 rpushg $122$122 1
 -- items:goOrigin:encOG: "doit "on: 2 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$121 1
 -- items:goOrigin:encOG: "matchEq "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$114 1
 -- computeAdrX:isLast:E:  "L1 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 --  rec:  "L1 "E:  "L1 "
 -- INV:gen:E.loadArgs "L1 "
 -- INV:gen:after:E.loadArgs "L1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L1 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- DI:invoke: "L1: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 isNotRemote: true 
 pushg 3 loop$110
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- NonVirt: "<= L2 " "ObjectInvocation_Binary " ActArg: "L2 "
 --  isValue: false formalArg: "in Veq: var this(Value) " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "<= L2 " isCompositeValueObj: true 
 -- OG:before:super.gen: "L2 "
 -- INV:gen: "L2 " 
 -- needorigin: "L2 " 
 -- needOrigin:E: "L2 "  E.ATd: "L2: var integer " Ex: "L2 " rec: "
 --  L2 " E.ATd: "L2: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L2 " 
 -- doNeedOrigin:E: "L2 " 
 -- computeAdrX:superAdj: 0 "L2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$122 "on: 3 isValueObj: false 
 --  origin: doit origin:isValueObj: false 
 rpushg $122$122 1
 -- items:goOrigin:encOG: "doit "on: 2 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$121 1
 -- items:goOrigin:encOG: "matchEq "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$114 1
 -- computeAdrX:isLast:E:  "L2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 --  rec:  "L2 "E:  "L2 "
 -- INV:gen:E.loadArgs "L2 "
 -- INV:gen:after:E.loadArgs "L2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L2 "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- DI:invoke: "L2: var integer " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 isNotRemote: true 
 pushg 4 loop$110
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- vEq: 
 -- end:loadArgs:NonVirt: "<= L2 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:after:E.loadArgs "L1 <= L2 "
 --  OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L1 <= L2 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- BinaryExp:invoke: "L1 "rec: "L1 <= L2 "
 -- M: "<= L2 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:before:ATdx.invoke: pattern <=   
 -- ptn:invoke: "<=   "E: "<= L2 "ptnKind: 1 useRtnV: true 
 -- E: "<= L2 " rec: "L1 ""Invocation "OGx: "integer " 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- rec.ATd: "L1: var integer " 
 -- bobs: 1 OGx: "integer " 
 -- 
 le
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<= L2":rec:L1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<= L2":rec:L1 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg <=$109 3
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "leave(matchEq) "
 -- INV:gen: "leave(matchEq) " 
 -- needorigin: "leave(matchEq) " 
 -- needOrigin:E: "leave(matchEq) "  E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  Ex: "leave(matchEq) " rec: "leave(matchEq) " E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  E.ATd.desc: "%basic 103 " E.ATd.IT: "%basic 103 " 
 -- doNeedOrigin:Ex: "leave(matchEq) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "leave(matchEq) " 
 -- doNeedOrigin:E: "leave(matchEq) " 
 -- computeAdrX:superAdj: 0 "leave(matchEq) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "leave(matchEq) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "leave(matchEq) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 --  rec:  "leave(matchEq) "E:  "leave(matchEq) "
 -- INV:gen:E.loadArgs "leave(matchEq) "
 -- INV:gen:after:E.loadArgs "leave(matchEq) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  leave(matchEq) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- ptn:invoke: "leave(V: var integer) "E: "leave(matchEq) "ptnKind: 0 
 --  useRtnV: false 
 break  2 2 114 0
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $123 123 1 doit 121
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "Beq := c1 < c2 " 
 pushThis 
 -- items:goOrigin:encOG: "$123 "on: 4 isValueObj: false 
 --  origin: doit origin:isValueObj: false 
 rpushg $123$123 1
 -- items:goOrigin:encOG: "doit "on: 3 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$121 1
 -- items:goOrigin:encOG: "matchEq "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$114 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$110 1
 -- AssignmentStatement:gen: 
 --  "Beq := c1 < c2 " right.label: "ObjectGenerator ""c1 < c2 " 
 -- OG:before:super.gen: "c1 < c2 "
 -- INV:gen: "c1 < c2 " 
 -- needorigin: "c1 < c2 " 
 -- needOrigin:E: "c1 < c2 "  E.ATd: 
 --  <  : 
 --     %basic 51
 --     in V: var char
 --     out B: var boolean
 --  Ex: "c1 < c2 " rec: "c1 < c2 " E.ATd: 
 --  <  : 
 --     %basic 51
 --     in V: var char
 --     out B: var boolean
 --  E.ATd.desc: 
 --  %basic 51
 --  in V: var char
 --  out B: var boolean
 --  E.ATd.IT: 
 --  %basic 51
 --  in V: var char
 --  out B: var boolean
 -- \
 --   
 -- doNeedOrigin:Ex: "c1 < c2 "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "c1 < c2 " 
 -- doNeedOrigin:E: "c1 < c2 " 
 -- computeAdrX:superAdj: 0 "c1 < c2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "c1 < c2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "c1 < c2 "superAdj: 0 
 -- computeAdrX:isLast:E:  "c1 < c2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "c1 < c2 "E:  "c1 < c2 "
 -- INV:gen:E.loadArgs "c1 < c2 "
 -- BinaryExp:loadArgs: "c1 < c2 " superAdj: 0 
 -- INV:gen: "c1 " 
 -- needorigin: "c1 " 
 -- needOrigin:E: "c1 "  E.ATd: "c1: var char " Ex: "c1 " rec: "c1 " 
 --  E.ATd: "c1: var char " E.ATd.desc: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "c1 " 
 -- doNeedOrigin:E: "c1 " 
 -- computeAdrX:superAdj: 0 "c1 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "c1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$123 "on: 2 isValueObj: false 
 --  origin: doit origin:isValueObj: false 
 rpushg $123$123 1
 -- items:goOrigin:encOG: "doit "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$121 1
 -- computeAdrX:isLast:E:  "c1 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 --  rec:  "c1 "E:  "c1 "
 -- INV:gen:E.loadArgs "c1 "
 -- INV:gen:after:E.loadArgs "c1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c1 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var c1 
 -- DI:invoke: "c1: var char " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 isNotRemote: true 
 pushg 3 matchEq$114
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- NonVirt: "< c2 " "ObjectInvocation_Binary " ActArg: "c2 "
 --  isValue: false formalArg: "in V: var char " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "< c2 " isCompositeValueObj: false 
 -- OG:before:super.gen: "c2 "
 -- INV:gen: "c2 " 
 -- needorigin: "c2 " 
 -- needOrigin:E: "c2 "  E.ATd: "c2: var char " Ex: "c2 " rec: "c2 " 
 --  E.ATd: "c2: var char " E.ATd.desc: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "c2 " 
 -- doNeedOrigin:E: "c2 " 
 -- computeAdrX:superAdj: 0 "c2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "c2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$123 "on: 2 isValueObj: false 
 --  origin: doit origin:isValueObj: false 
 rpushg $123$123 1
 -- items:goOrigin:encOG: "doit "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$121 1
 -- computeAdrX:isLast:E:  "c2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 --  rec:  "c2 "E:  "c2 "
 -- INV:gen:E.loadArgs "c2 "
 -- INV:gen:after:E.loadArgs "c2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c2 "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var c2 
 -- DI:invoke: "c2: var char " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 isNotRemote: true 
 pushg 4 matchEq$114
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var char "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "c2 ":isBasicVal: true 
 -- case:B: c2 ObjectGenerator 3 0 3 false false 
 -- end:loadArgs:NonVirt: "< c2 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:after:E.loadArgs "c1 < c2 "
 --  OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "c1 < c2 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- BinaryExp:invoke: "c1 "rec: "c1 < c2 "
 -- M: "< c2 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:before:ATdx.invoke: pattern <   
 -- ptn:invoke: "<   "E: "< c2 "ptnKind: 0 useRtnV: true 
 lt
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< c2":rec:c1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< c2":rec:c1 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg <=$109 3
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "leave(matchEq) "
 -- INV:gen: "leave(matchEq) " 
 -- needorigin: "leave(matchEq) " 
 -- needOrigin:E: "leave(matchEq) "  E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  Ex: "leave(matchEq) " rec: "leave(matchEq) " E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  E.ATd.desc: "%basic 103 " E.ATd.IT: "%basic 103 " 
 -- doNeedOrigin:Ex: "leave(matchEq) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "leave(matchEq) " 
 -- doNeedOrigin:E: "leave(matchEq) " 
 -- computeAdrX:superAdj: 0 "leave(matchEq) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "leave(matchEq) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "leave(matchEq) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 --  rec:  "leave(matchEq) "E:  "leave(matchEq) "
 -- INV:gen:E.loadArgs "leave(matchEq) "
 -- INV:gen:after:E.loadArgs "leave(matchEq) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  leave(matchEq) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- ptn:invoke: "leave(V: var integer) "E: "leave(matchEq) "ptnKind: 0 
 --  useRtnV: false 
 break  2 2 114 0
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS puttext 125 1 ConsoleIF 8
 pushThis 
 rstoreg  T 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(puttext) "
 -- INV:gen: "inner(puttext) " 
 -- needorigin: "inner(puttext) " 
 -- needOrigin:E: "inner(puttext) "  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(puttext) " rec: "inner(puttext) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  E.ATd.desc: 
 --  %basic 101
 --  in inner: ref Object
 --  E.ATd.IT: 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- doNeedOrigin:Ex: "inner(puttext) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inner(puttext) " 
 -- doNeedOrigin:E: "inner(puttext) " 
 -- computeAdrX:superAdj: 0 "inner(puttext) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(puttext) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(puttext) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:- 
 --  rec:  "inner(puttext) "E:  "inner(puttext) "
 -- INV:gen:E.loadArgs "inner(puttext) "
 -- INV:gen:after:E.loadArgs "inner(puttext) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  inner(puttext) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(puttext) "ptnKind: 0 useRtnV: 
 --  false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:inner(puttext) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:inner(puttext) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:inner(puttext) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS putint 126 1 ConsoleIF 8
 pushThis 
 storeg integer$5 2
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(putint) "
 -- INV:gen: "inner(putint) " 
 -- needorigin: "inner(putint) " 
 -- needOrigin:E: "inner(putint) "  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(putint) " rec: "inner(putint) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  E.ATd.desc: 
 --  %basic 101
 --  in inner: ref Object
 --  E.ATd.IT: 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- doNeedOrigin:Ex: "inner(putint) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inner(putint) " 
 -- doNeedOrigin:E: "inner(putint) " 
 -- computeAdrX:superAdj: 0 "inner(putint) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(putint) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(putint) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:- 
 --  rec:  "inner(putint) "E:  "inner(putint) "
 -- INV:gen:E.loadArgs "inner(putint) "
 -- INV:gen:after:E.loadArgs "inner(putint) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  inner(putint) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(putint) "ptnKind: 0 useRtnV: 
 --  false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:inner(putint) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:inner(putint) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:inner(putint) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS workspace 127 1 BETAworld 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 pushThis 
 -- before objTmpStack:add:  128   "UnitIssues "
 invoke UnitIssues 128 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS UnitIssues 128 1 workspace 127
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "L1: var Length.meter " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 -- DI:isConst: L1 
 -- DI:off: 2 this: "L1: var Length.meter " 
 --  
 -- OG:before:super.gen: "Length.meter "
 -- INV:gen: "Length.meter " 
 -- needorigin: "Length.meter " 
 -- needOrigin:E: "meter "  E.ATd: 
 --  Meter: Unit
 --     %unit "m", 1
 --     %Public
 --     thisUnit:: MeterEx: "meter " rec: "Length " E.ATd: 
 --  Meter: Unit
 --     %unit "m", 1
 --     %Public
 --     thisUnit:: MeterE.ATd.desc: 
 --  %unit "m", 1
 --  %Public
 --  thisUnit:: Meter
 --  argUnit:: MeterE.ATd.IT: 
 --  %unit "m", 1
 --  %Public
 --  thisUnit:: Meter
 --  argUnit:: Meter
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Unit
 --     %unit "m", 1
 --     %Public
 --     thisUnit:: Meter
 -- after:needOrigin: "meter " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "Length "E:  "meter "
 -- INV:gen:E.loadArgs "meter "
 -- INV:gen:after:E.loadArgs "meter "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "meter "
 -- OI:invoke:before:ATdx.invoke: pattern Meter 
 -- ptn:invoke: "Meter "E: "meter "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 2 rec: "Length " 
 --  adr:none 
 invokeVal  Meter 91 1
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- DI:gen: "L2: var Length.Meter " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 -- DI:isConst: L2 
 -- DI:off: 4 this: "L2: var Length.Meter " 
 --  
 -- OG:before:super.gen: "Length.Meter "
 -- INV:gen: "Length.Meter " 
 -- needorigin: "Length.Meter " 
 -- needOrigin:E: "Meter "  E.ATd: 
 --  Meter: Unit
 --     %unit "m", 1
 --     %Public
 --     thisUnit:: MeterEx: "Meter " rec: "Length " E.ATd: 
 --  Meter: Unit
 --     %unit "m", 1
 --     %Public
 --     thisUnit:: MeterE.ATd.desc: 
 --  %unit "m", 1
 --  %Public
 --  thisUnit:: Meter
 --  argUnit:: MeterE.ATd.IT: 
 --  %unit "m", 1
 --  %Public
 --  thisUnit:: Meter
 --  argUnit:: Meter
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Unit
 --     %unit "m", 1
 --     %Public
 --     thisUnit:: Meter
 -- after:needOrigin: "Meter " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "Length "E:  "Meter "
 -- INV:gen:E.loadArgs "Meter "
 -- INV:gen:after:E.loadArgs "Meter "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "Meter "
 -- OI:invoke:before:ATdx.invoke: pattern Meter 
 -- ptn:invoke: "Meter "E: "Meter "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 4 rec: "Length " 
 --  adr:none 
 invokeVal  Meter 91 3
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- DI:gen: "A1: var Area.SquareMeter " DI:isConst: false 
 --  isBasicValue: false primNo: 0 
 -- DI:isConst: A1 
 -- DI:off: 6 this: "A1: var Area.SquareMeter " 
 --  
 -- OG:before:super.gen: "Area.SquareMeter "
 -- INV:gen: "Area.SquareMeter " 
 -- needorigin: "Area.SquareMeter " 
 -- needOrigin:E: "SquareMeter "  E.ATd: 
 --  SquareMeter: Unit
 --     %unit "m2", 1
 --     %Public
 --     thisUnit:: SquareMeterEx: "SquareMeter " rec: "Area " E.ATd: 
 --  SquareMeter: Unit
 --     %unit "m2", 1
 --     %Public
 --     thisUnit:: SquareMeterE.ATd.desc: 
 --  %unit "m2", 1
 --  %Public
 --  thisUnit:: SquareMeter
 --  print:: E.ATd.IT: 
 --  %unit "m2", 1
 --  %Public
 --  thisUnit:: SquareMeter
 --  print:: 
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Unit
 --     %unit "m2", 1
 --     %Public
 --     thisUnit:: SquareMeter
 -- after:needOrigin: "SquareMeter " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "Area "E:  "SquareMeter "
 -- INV:gen:E.loadArgs "SquareMeter "
 -- INV:gen:after:E.loadArgs "SquareMeter "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "
 --  SquareMeter "
 -- OI:invoke:before:ATdx.invoke: pattern SquareMeter 
 -- ptn:invoke: "SquareMeter "E: "SquareMeter "ptnKind: 0 useRtnV: 
 --  false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 6 rec: "Area " 
 --  adr:none 
 invokeVal  SquareMeter 72 5
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- DI:gen: "A2: var Area.SquareMeter " DI:isConst: false 
 --  isBasicValue: false primNo: 0 
 -- DI:isConst: A2 
 -- DI:off: 8 this: "A2: var Area.SquareMeter " 
 --  
 -- OG:before:super.gen: "Area.SquareMeter "
 -- INV:gen: "Area.SquareMeter " 
 -- needorigin: "Area.SquareMeter " 
 -- needOrigin:E: "SquareMeter "  E.ATd: 
 --  SquareMeter: Unit
 --     %unit "m2", 1
 --     %Public
 --     thisUnit:: SquareMeterEx: "SquareMeter " rec: "Area " E.ATd: 
 --  SquareMeter: Unit
 --     %unit "m2", 1
 --     %Public
 --     thisUnit:: SquareMeterE.ATd.desc: 
 --  %unit "m2", 1
 --  %Public
 --  thisUnit:: SquareMeter
 --  print:: E.ATd.IT: 
 --  %unit "m2", 1
 --  %Public
 --  thisUnit:: SquareMeter
 --  print:: 
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Unit
 --     %unit "m2", 1
 --     %Public
 --     thisUnit:: SquareMeter
 -- after:needOrigin: "SquareMeter " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "Area "E:  "SquareMeter "
 -- INV:gen:E.loadArgs "SquareMeter "
 -- INV:gen:after:E.loadArgs "SquareMeter "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "
 --  SquareMeter "
 -- OI:invoke:before:ATdx.invoke: pattern SquareMeter 
 -- ptn:invoke: "SquareMeter "E: "SquareMeter "ptnKind: 0 useRtnV: 
 --  false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 8 rec: "Area " 
 --  adr:none 
 invokeVal  SquareMeter 72 7
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- DI:gen: "A3: var Area.SquareMeter " DI:isConst: false 
 --  isBasicValue: false primNo: 0 
 -- DI:isConst: A3 
 -- DI:off: 10 this: "A3: var Area.SquareMeter " 
 --  
 -- OG:before:super.gen: "Area.SquareMeter "
 -- INV:gen: "Area.SquareMeter " 
 -- needorigin: "Area.SquareMeter " 
 -- needOrigin:E: "SquareMeter "  E.ATd: 
 --  SquareMeter: Unit
 --     %unit "m2", 1
 --     %Public
 --     thisUnit:: SquareMeterEx: "SquareMeter " rec: "Area " E.ATd: 
 --  SquareMeter: Unit
 --     %unit "m2", 1
 --     %Public
 --     thisUnit:: SquareMeterE.ATd.desc: 
 --  %unit "m2", 1
 --  %Public
 --  thisUnit:: SquareMeter
 --  print:: E.ATd.IT: 
 --  %unit "m2", 1
 --  %Public
 --  thisUnit:: SquareMeter
 --  print:: 
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Unit
 --     %unit "m2", 1
 --     %Public
 --     thisUnit:: SquareMeter
 -- after:needOrigin: "SquareMeter " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "Area "E:  "SquareMeter "
 -- INV:gen:E.loadArgs "SquareMeter "
 -- INV:gen:after:E.loadArgs "SquareMeter "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "
 --  SquareMeter "
 -- OI:invoke:before:ATdx.invoke: pattern SquareMeter 
 -- ptn:invoke: "SquareMeter "E: "SquareMeter "ptnKind: 0 useRtnV: 
 --  false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 10 rec: "Area " 
 --  adr:none 
 invokeVal  SquareMeter 72 9
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- DI:gen: "V: var Float " DI:isConst: false isBasicValue: true 
 --  primNo: 9 
 -- DI:gen:primitiveType: V 
 -- DI:gen: "N: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: N 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "A1 := 24"m2" " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "A1 := 24"m2" " right.label: "ObjectGenerator ""24"m2" " 
 -- OG:before:super.gen: "24"m2" "
 -- INV:gen: "24"m2" " 
 -- needorigin: "24"m2" " 
 -- needOrigin:E: "24"m2" "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "24"m2" " rec: "24"m2" " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "24"m2" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "24"m2" "E:  "24"m2" "
 -- INV:gen:E.loadArgs "24"m2" "
 -- INV:gen:after:E.loadArgs "24"m2" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "24"m2" "
 pushc 24
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 i2f
 -- assign:adr.store:A: 
 fstoreg 6 address:storeg
 -- assign:adr.store:B: 
 -- AssignmentStatement:gen: "A2 := 12"m2" " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "A2 := 12"m2" " right.label: "ObjectGenerator ""12"m2" " 
 -- OG:before:super.gen: "12"m2" "
 -- INV:gen: "12"m2" " 
 -- needorigin: "12"m2" " 
 -- needOrigin:E: "12"m2" "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "12"m2" " rec: "12"m2" " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "12"m2" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "12"m2" "E:  "12"m2" "
 -- INV:gen:E.loadArgs "12"m2" "
 -- INV:gen:after:E.loadArgs "12"m2" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "12"m2" "
 pushc 12
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 i2f
 -- assign:adr.store:A: 
 fstoreg 8 address:storeg
 -- assign:adr.store:B: 
 -- AssignmentStatement:gen: "A3 := A1 / A2 -- not OK " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "A3 := A1 / A2 -- not OK " right.label: "ObjectGenerator ""
 --  A1 / A2 -- not OK " 
 -- OG:before:super.gen: "A1 / A2 -- not OK "
 -- INV:gen: "A1 / A2 -- not OK " 
 -- needorigin: "A1 / A2 -- not OK " 
 -- needOrigin:E: "A1 / A2 -- not OK "  E.ATd: 
 --  /  : 
 --     %basic 121
 --     in V: var float
 --     out R: var float
 --  Ex: "A1 / A2 -- not OK " rec: "A1 / A2 -- not OK " E.ATd: 
 --  /  : 
 --     %basic 121
 --     in V: var float
 --     out R: var float
 --  E.ATd.desc: 
 --  %basic 121
 --  in V: var float
 --  out R: var float
 --  E.ATd.IT: 
 --  %basic 121
 --  in V: var float
 --  out R: var float
 -- \
 --   
 -- doNeedOrigin:Ex: "A1 / A2 -- not OK "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "A1 / A2 -- not OK " 
 -- doNeedOrigin:E: "A1 / A2 -- not OK " 
 -- computeAdrX:superAdj: 0 "A1 / A2 -- not OK " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "A1 / A2 -- not OK " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "A1 / A2 -- not OK "superAdj: 0 
 -- computeAdrX:isLast:E:  "A1 / A2 -- not OK "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "A1 / A2 -- not OK "E:  "A1 / A2 -- not OK "
 -- INV:gen:E.loadArgs "A1 / A2 -- not OK "
 -- BinaryExp:loadArgs: "A1 / A2 -- not OK " superAdj: 0 
 -- INV:gen: "A1 " 
 -- needorigin: "A1 " 
 -- needOrigin:E: "A1 "  E.ATd: "A1: var Area.SquareMeter " Ex: "
 --  A1 " rec: "A1 " E.ATd: "A1: var Area.SquareMeter " E.ATd.desc: 
 --  %unit "m2", 1
 --  %Public
 --  thisUnit:: SquareMeter
 --  print:: E.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "A1 " 
 -- doNeedOrigin:E: "A1 " 
 -- computeAdrX:superAdj: 0 "A1 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "A1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "A1 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A1":rec:- 
 --  rec:  "A1 "E:  "A1 "
 -- INV:gen:E.loadArgs "A1 "
 -- INV:gen:after:E.loadArgs "A1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "A1 "
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var A1 
 -- DI:invoke: "A1: var Area.SquareMeter " 
 -- isValueObj:isAdr: false objSize: 2  rec "A1 ",E: "A1 ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A1":rec:A1 
 -- Address:loadAdr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A1":rec:A1 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:isUnitVal 
 fpushg 6 
 -- OI:invoke:V: adr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A1":rec:A1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A1":rec:A1 
 -- INV:gen:end:off: 6 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A1":rec:A1 
 -- NonVirt: "/ A2 -- not OK " "ObjectInvocation_Binary " ActArg: "
 --  A2 -- not OK "isValue: true formalArg: "in V: var float " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "/ A2 -- not OK "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "A2 -- not OK "
 -- INV:gen: "A2 -- not OK " 
 -- needorigin: "A2 -- not OK " 
 -- needOrigin:E: "A2 -- not OK "  E.ATd: "
 --  A2: var Area.SquareMeter " Ex: "A2 -- not OK " rec: "A2 -- not OK " E.ATd: "
 --  A2: var Area.SquareMeter " E.ATd.desc: 
 --  %unit "m2", 1
 --  %Public
 --  thisUnit:: SquareMeter
 --  print:: E.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "A2 -- not OK " 
 -- doNeedOrigin:E: "A2 -- not OK " 
 -- computeAdrX:superAdj: 0 "A2 -- not OK " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "A2 -- not OK " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "A2 -- not OK "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A2 -- not OK":rec:- 
 --  rec:  "A2 -- not OK "E:  "A2 -- not OK "
 -- INV:gen:E.loadArgs "A2 -- not OK "
 -- INV:gen:after:E.loadArgs "A2 -- not OK "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "
 --  A2 -- not OK "
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A2 -- not OK":rec:- 
 -- OI:invoke:before:ATdx.invoke: var A2 
 -- DI:invoke: "A2: var Area.SquareMeter " 
 -- isValueObj:isAdr: false objSize: 2  rec "A2 -- not OK ",E: "
 --  A2 -- not OK ""ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A2 -- not OK":rec:A2 -- not OK 
 -- Address:loadAdr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A2 -- not OK":rec:A2 -- not OK 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:isUnitVal 
 fpushg 8 
 -- OI:invoke:V: adr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A2 -- not OK":rec:A2 -- not OK 
 -- OI:invoke:X: adr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A2 -- not OK":rec:A2 -- not OK 
 -- INV:gen:end:off: 8 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A2 -- not OK":rec:A2 -- not OK 
 -- before:pushSize:  actualArg.super.ATd.OG.isUnitValueObj: true 
 --  :actualArg.isCompositeValueObj: false 
 -- actualArg:UnitOne?: A2 -- not OK 
 -- end:loadArgs:NonVirt: "/ A2 -- not OK "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A1":rec:A1 
 -- INV:gen:after:E.loadArgs "A1 / A2 -- not OK "
 --  OIadr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A1":rec:A1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "A1 / A2 -- not OK "
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A1":rec:A1 
 -- BinaryExp:invoke: "A1 "rec: "A1 / A2 -- not OK "
 -- M: "/ A2 -- not OK "
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A1":rec:A1 
 -- OI:invoke:before:ATdx.invoke: pattern /   
 -- ptn:invoke: "/   "E: "/ A2 -- not OK "ptnKind: 0 useRtnV: true 
 fdiv
 -- OI:invoke:V: adr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"/ A2 -- not OK":rec:A1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"/ A2 -- not OK":rec:A1 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 fstoreg 10 address:storeg
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "A3.print "
 -- INV:gen: "A3.print " 
 -- needorigin: "A3.print " 
 -- needOrigin:E: "print "  E.ATd: 
 --  print:: 
 --     "SquareMeter".print
 --  Ex: "print " rec: "A3 " E.ATd: 
 --  print:: 
 --     "SquareMeter".print
 --  E.ATd.desc: ""SquareMeter".print " E.ATd.IT: "
 --  "SquareMeter".print " 
 -- doNeedOrigin:Ex: "print "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- origin:isValueObj: "SquareMeter "
 -- after:needOrigin: "print " 
 -- doNeedOrigin:E: "print " 
 -- computeAdrX:superAdj: 0 "A3.print " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "A3 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "A3 " rec: "A3 " E: "print " 
 --  A.E: "A3 "
 --  
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A3":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "A3 " rec: "A3 " E: "print " 
 --  rec.ATd: "A3: var Area.SquareMeter " rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  %visible Dimensions
 --     %requires Dimensions.Area, Dimensions.Length, Dimensions.Mass, Dimensions.Energy, Dimensions.AngularAcceleration
 --     energyCombinations: 
 --        M: var Mass.KiloGram
 --  recA: 
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A3":rec:- 
 --  pRecA: none 
 -- pRec: "A3 " rec: "A3 " E: "print " 
 --  false true 
 -- computeAdrX:before:rec:: "A3 " 
 -- OI:invoke:before:ATdx.invoke: var A3 
 -- DI:invoke: "A3: var Area.SquareMeter " 
 -- isValueObj:isAdr: true objSize: 2  rec "A3 ",E: "print ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A3 
 -- Address:loadAdr: 
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A3 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain "print " cmpAndSwap: false rec: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A3 
 -- OI:invoke:X: adr: 
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A3 
 -- computeAdrX:after:rec.invoke: "A3 " 
 -- computeAdrX:isLast:E:  "print "
 -- originIsValueObj: 
 --  %visible Dimensions
 --  %requires Dimensions.Area, Dimensions.Length, Dimensions.Mass, Dimensions.Energy, Dimensions.AngularAcceleration
 --  energyCombinations: 
 --     M: var Mass.KiloGram
 -- rec = E: false 0 
 -- call:mkValueProxy false true 
 -- mkValueProxy:INV: "A3.print " E: "print " rec: "A3 " E.ATd: 
 --  print:: 
 --     "SquareMeter".print
 --  
 -- CreateProxyW:E: "print "E.ATd.origin.encOG:OGid "SquareMeter "
 --  origin:descNo: 72 "Area ""A3.print " 
 --  rec.ATd: "A3: var Area.SquareMeter "rec.ATd.newOff: 10 0 
 rdouble 0
 -- son: "A3 " 
 -- son: "print " 
 -- recOfE: "A3 "recOfE.ATd: "A3: var Area.SquareMeter " 
 -- first: "Area "ObjectInvocation_Unary first.origin.encOG: "
 --  UnitIssues "
 -- items:goOrigin:encOG: "UnitIssues "on: 2 isValueObj: false 
 --  origin: workspace origin:isValueObj: false 
 rpushg UnitIssues$128 1
 -- items:goOrigin:encOG: "workspace "on: 1 isValueObj: false 
 --  origin: BETAworld origin:isValueObj: false 
 rpushg workspace$127 1
 rpushg LIB 3
 rpushg Dimensions 4
 -- after:Ey.loadOrigin: 
 -- Adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- Address:loadAdr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rpushg EisNone 3
 -- after:A.loadAdr 
 mkValueProxy 72 9
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A3 
 --  rec:  "A3 "E:  "print "
 -- INV:gen:E.loadArgs "print "
 -- INV:gen:after:E.loadArgs "print "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print "
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A3 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 rec: "A3 " 
 --  
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A3 
 invoke print 74 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- OI:invoke:V: adr: 
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A3 
 -- OI:invoke:X: adr: 
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A3 
 -- INV:gen:end:off: 10 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A3 
 -- OG:before:super.gen: "newline "
 -- INV:gen: "newline " 
 -- needorigin: "newline " 
 -- needOrigin:E: "newline "  E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  Ex: "newline " rec: "newline " E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  E.ATd.desc: 
 --  %globals
 --  put(10)
 --  E.ATd.IT: 
 --  %globals
 --  put(10)
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %globals
 --     put(10)
 --  
 -- after:needOrigin: "newline " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "newline "E:  "newline "
 -- INV:gen:E.loadArgs "newline "
 -- INV:gen:after:E.loadArgs "newline "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "newline "
 -- OI:invoke:before:ATdx.invoke: pattern newline 
 -- ptn:invoke: "newline "E: "newline "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "newline " 
 --  adr:none 
 invoke newline 130 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- AssignmentStatement:gen: "V := A1 / A2 -- ok " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "V := A1 / A2 -- ok " right.label: "ObjectGenerator ""
 --  A1 / A2 -- ok " 
 -- OG:before:super.gen: "A1 / A2 -- ok "
 -- INV:gen: "A1 / A2 -- ok " 
 -- needorigin: "A1 / A2 -- ok " 
 -- needOrigin:E: "A1 / A2 -- ok "  E.ATd: 
 --  /  : 
 --     %basic 121
 --     in V: var float
 --     out R: var float
 --  Ex: "A1 / A2 -- ok " rec: "A1 / A2 -- ok " E.ATd: 
 --  /  : 
 --     %basic 121
 --     in V: var float
 --     out R: var float
 --  E.ATd.desc: 
 --  %basic 121
 --  in V: var float
 --  out R: var float
 --  E.ATd.IT: 
 --  %basic 121
 --  in V: var float
 --  out R: var float
 -- \
 --   
 -- doNeedOrigin:Ex: "A1 / A2 -- ok "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "A1 / A2 -- ok " 
 -- doNeedOrigin:E: "A1 / A2 -- ok " 
 -- computeAdrX:superAdj: 0 "A1 / A2 -- ok " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "A1 / A2 -- ok " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "A1 / A2 -- ok "superAdj: 0 
 -- computeAdrX:isLast:E:  "A1 / A2 -- ok "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "A1 / A2 -- ok "E:  "A1 / A2 -- ok "
 -- INV:gen:E.loadArgs "A1 / A2 -- ok "
 -- BinaryExp:loadArgs: "A1 / A2 -- ok " superAdj: 0 
 -- INV:gen: "A1 " 
 -- needorigin: "A1 " 
 -- needOrigin:E: "A1 "  E.ATd: "A1: var Area.SquareMeter " Ex: "
 --  A1 " rec: "A1 " E.ATd: "A1: var Area.SquareMeter " E.ATd.desc: 
 --  %unit "m2", 1
 --  %Public
 --  thisUnit:: SquareMeter
 --  print:: E.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "A1 " 
 -- doNeedOrigin:E: "A1 " 
 -- computeAdrX:superAdj: 0 "A1 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "A1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "A1 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A1":rec:- 
 --  rec:  "A1 "E:  "A1 "
 -- INV:gen:E.loadArgs "A1 "
 -- INV:gen:after:E.loadArgs "A1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "A1 "
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var A1 
 -- DI:invoke: "A1: var Area.SquareMeter " 
 -- isValueObj:isAdr: false objSize: 2  rec "A1 ",E: "A1 ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A1":rec:A1 
 -- Address:loadAdr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A1":rec:A1 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:isUnitVal 
 fpushg 6 
 -- OI:invoke:V: adr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A1":rec:A1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A1":rec:A1 
 -- INV:gen:end:off: 6 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A1":rec:A1 
 -- NonVirt: "/ A2 -- ok " "ObjectInvocation_Binary " ActArg: "
 --  A2 -- ok "isValue: true formalArg: "in V: var float " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "/ A2 -- ok " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "A2 -- ok "
 -- INV:gen: "A2 -- ok " 
 -- needorigin: "A2 -- ok " 
 -- needOrigin:E: "A2 -- ok "  E.ATd: "A2: var Area.SquareMeter " 
 --  Ex: "A2 -- ok " rec: "A2 -- ok " E.ATd: "A2: var Area.SquareMeter " 
 --  E.ATd.desc: 
 --  %unit "m2", 1
 --  %Public
 --  thisUnit:: SquareMeter
 --  print:: E.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "A2 -- ok " 
 -- doNeedOrigin:E: "A2 -- ok " 
 -- computeAdrX:superAdj: 0 "A2 -- ok " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "A2 -- ok " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "A2 -- ok "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A2 -- ok":rec:- 
 --  rec:  "A2 -- ok "E:  "A2 -- ok "
 -- INV:gen:E.loadArgs "A2 -- ok "
 -- INV:gen:after:E.loadArgs "A2 -- ok "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "A2 -- ok "
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A2 -- ok":rec:- 
 -- OI:invoke:before:ATdx.invoke: var A2 
 -- DI:invoke: "A2: var Area.SquareMeter " 
 -- isValueObj:isAdr: false objSize: 2  rec "A2 -- ok ",E: "A2 -- ok ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A2 -- ok":rec:A2 -- ok 
 -- Address:loadAdr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A2 -- ok":rec:A2 -- ok 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:isUnitVal 
 fpushg 8 
 -- OI:invoke:V: adr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A2 -- ok":rec:A2 -- ok 
 -- OI:invoke:X: adr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A2 -- ok":rec:A2 -- ok 
 -- INV:gen:end:off: 8 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A2 -- ok":rec:A2 -- ok 
 -- before:pushSize:  actualArg.super.ATd.OG.isUnitValueObj: true 
 --  :actualArg.isCompositeValueObj: false 
 -- actualArg:UnitOne?: A2 -- ok 
 -- end:loadArgs:NonVirt: "/ A2 -- ok "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A1":rec:A1 
 -- INV:gen:after:E.loadArgs "A1 / A2 -- ok "
 --  OIadr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A1":rec:A1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "A1 / A2 -- ok "
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A1":rec:A1 
 -- BinaryExp:invoke: "A1 "rec: "A1 / A2 -- ok "
 -- M: "/ A2 -- ok "
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A1":rec:A1 
 -- OI:invoke:before:ATdx.invoke: pattern /   
 -- ptn:invoke: "/   "E: "/ A2 -- ok "ptnKind: 0 useRtnV: true 
 fdiv
 -- OI:invoke:V: adr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"/ A2 -- ok":rec:A1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"/ A2 -- ok":rec:A1 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 fstoreg 12 address:storeg
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "putfloat(V) "
 -- INV:gen: "putfloat(V) " 
 -- needorigin: "putfloat(V) " 
 -- needOrigin:E: "putfloat(V) "  E.ATd: 
 --  putFloat: 
 --     %basic 142
 --     in X: var Float
 --     out V: var integer
 --  Ex: "putfloat(V) " rec: "putfloat(V) " E.ATd: 
 --  putFloat: 
 --     %basic 142
 --     in X: var Float
 --     out V: var integer
 --  E.ATd.desc: 
 --  %basic 142
 --  in X: var Float
 --  out V: var integer
 --  E.ATd.IT: 
 --  %basic 142
 --  in X: var Float
 --  out V: var integer
 -- \
 --   
 -- doNeedOrigin:Ex: "putfloat(V) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "putfloat(V) " 
 -- doNeedOrigin:E: "putfloat(V) " 
 -- computeAdrX:superAdj: 0 "putfloat(V) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "putfloat(V) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "putfloat(V) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putfloat(V)":rec:- 
 --  rec:  "putfloat(V) "E:  "putfloat(V) "
 -- INV:gen:E.loadArgs "putfloat(V) "
 -- NonVirt: "putfloat(V) " "ObjectInvocation_KeyWord " ActArg: "V "
 --  isValue: false formalArg: "in X: var Float " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "putfloat(V) "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "V "
 -- INV:gen: "V " 
 -- needorigin: "V " 
 -- needOrigin:E: "V "  E.ATd: "V: var Float " Ex: "V " rec: "V " 
 --  E.ATd: "V: var Float " E.ATd.desc: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "V " 
 -- doNeedOrigin:E: "V " 
 -- computeAdrX:superAdj: 0 "V " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "V " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "V "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:12 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 --  rec:  "V "E:  "V "
 -- INV:gen:E.loadArgs "V "
 -- INV:gen:after:E.loadArgs "V "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "V "
 --  :Adr:off:12 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- OI:invoke:before:ATdx.invoke: var V 
 -- DI:invoke: "V: var Float " 
 -- load: 
 --  :Adr:off:12 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V isNotRemote: true 
 fpushg 12 
 -- OI:invoke:V: adr: 
 --  :Adr:off:12 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:X: adr: 
 --  :Adr:off:12 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- INV:gen:end:off: 12 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:12 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- actualArg:isPtn: false formalArg:isPtn: "in X: var Float "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "V ":isBasicVal: true 
 -- case:B: V ObjectGenerator 9 0 9 false false 
 -- end:loadArgs:NonVirt: "putfloat(V) "
 -- INV:gen:after:E.loadArgs "putfloat(V) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  putfloat(V) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putfloat(V)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern putFloat 
 -- ptn:invoke: "putFloat "E: "putfloat(V) "ptnKind: 0 useRtnV: 
 --  false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "putfloat(V) " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putfloat(V)":rec:putfloat(V) 
 %printf_prim 142
 vpop
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putfloat(V)":rec:putfloat(V) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putfloat(V)":rec:putfloat(V) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putfloat(V)":rec:putfloat(V) 
 -- OG:before:super.gen: "newline "
 -- INV:gen: "newline " 
 -- needorigin: "newline " 
 -- needOrigin:E: "newline "  E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  Ex: "newline " rec: "newline " E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  E.ATd.desc: 
 --  %globals
 --  put(10)
 --  E.ATd.IT: 
 --  %globals
 --  put(10)
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %globals
 --     put(10)
 --  
 -- after:needOrigin: "newline " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "newline "E:  "newline "
 -- INV:gen:E.loadArgs "newline "
 -- INV:gen:after:E.loadArgs "newline "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "newline "
 -- OI:invoke:before:ATdx.invoke: pattern newline 
 -- ptn:invoke: "newline "E: "newline "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "newline " 
 --  adr:none 
 invoke newline 130 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- AssignmentStatement:gen: "A1 := A2 * 4 " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "A1 := A2 * 4 " right.label: "ObjectGenerator ""A2 * 4 " 
 -- OG:before:super.gen: "A2 * 4 "
 -- INV:gen: "A2 * 4 " 
 -- needorigin: "A2 * 4 " 
 -- needOrigin:E: "A2 * 4 "  E.ATd: 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  Ex: "A2 * 4 " rec: "A2 * 4 " E.ATd: 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  E.ATd.desc: 
 --  %basic 112
 --  in V: var float
 --  out R: var float
 --  E.ATd.IT: 
 --  %basic 112
 --  in V: var float
 --  out R: var float
 -- \
 --   
 -- doNeedOrigin:Ex: "A2 * 4 "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "A2 * 4 " 
 -- doNeedOrigin:E: "A2 * 4 " 
 -- computeAdrX:superAdj: 0 "A2 * 4 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "A2 * 4 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "A2 * 4 "superAdj: 0 
 -- computeAdrX:isLast:E:  "A2 * 4 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "A2 * 4 "E:  "A2 * 4 "
 -- INV:gen:E.loadArgs "A2 * 4 "
 -- BinaryExp:loadArgs: "A2 * 4 " superAdj: 0 
 -- INV:gen: "A2 " 
 -- needorigin: "A2 " 
 -- needOrigin:E: "A2 "  E.ATd: "A2: var Area.SquareMeter " Ex: "
 --  A2 " rec: "A2 " E.ATd: "A2: var Area.SquareMeter " E.ATd.desc: 
 --  %unit "m2", 1
 --  %Public
 --  thisUnit:: SquareMeter
 --  print:: E.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "A2 " 
 -- doNeedOrigin:E: "A2 " 
 -- computeAdrX:superAdj: 0 "A2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "A2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "A2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A2":rec:- 
 --  rec:  "A2 "E:  "A2 "
 -- INV:gen:E.loadArgs "A2 "
 -- INV:gen:after:E.loadArgs "A2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "A2 "
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var A2 
 -- DI:invoke: "A2: var Area.SquareMeter " 
 -- isValueObj:isAdr: false objSize: 2  rec "A2 ",E: "A2 ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A2":rec:A2 
 -- Address:loadAdr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A2":rec:A2 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:isUnitVal 
 fpushg 8 
 -- OI:invoke:V: adr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A2":rec:A2 
 -- OI:invoke:X: adr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A2":rec:A2 
 -- INV:gen:end:off: 8 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A2":rec:A2 
 -- NonVirt: "* 4 " "ObjectInvocation_Binary " ActArg: "4 "isValue: 
 --  true formalArg: "in V: var float " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- OG:before:super.gen: "4 "
 -- INV:gen: "4 " 
 -- needorigin: "4 " 
 -- needOrigin:E: "4 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "4 " rec: "4 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "4 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "4 "E:  "4 "
 -- INV:gen:E.loadArgs "4 "
 -- INV:gen:after:E.loadArgs "4 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "4 "
 pushc 4
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var float "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "4 ":isBasicVal: true 
 -- case:B: 4 ObjectGenerator 9 1 1 false true 
 i2f
 -- end:loadArgs:NonVirt: "* 4 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A2":rec:A2 
 -- INV:gen:after:E.loadArgs "A2 * 4 "
 --  OIadr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A2":rec:A2 
 -- IV:E.invoke:useRtnVal: true E: BinOp "A2 * 4 "
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A2":rec:A2 
 -- BinaryExp:invoke: "A2 "rec: "A2 * 4 "
 -- M: "* 4 "
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A2":rec:A2 
 -- OI:invoke:before:ATdx.invoke: pattern *   
 -- ptn:invoke: "*   "E: "* 4 "ptnKind: 0 useRtnV: true 
 fmult
 -- OI:invoke:V: adr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* 4":rec:A2 
 -- OI:invoke:X: adr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* 4":rec:A2 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 fstoreg 6 address:storeg
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "A1.print "
 -- INV:gen: "A1.print " 
 -- needorigin: "A1.print " 
 -- needOrigin:E: "print "  E.ATd: 
 --  print:: 
 --     "SquareMeter".print
 --  Ex: "print " rec: "A1 " E.ATd: 
 --  print:: 
 --     "SquareMeter".print
 --  E.ATd.desc: ""SquareMeter".print " E.ATd.IT: "
 --  "SquareMeter".print " 
 -- doNeedOrigin:Ex: "print "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- origin:isValueObj: "SquareMeter "
 -- after:needOrigin: "print " 
 -- doNeedOrigin:E: "print " 
 -- computeAdrX:superAdj: 0 "A1.print " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "A1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "A1 " rec: "A1 " E: "print " 
 --  A.E: "A1 "
 --  
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A1":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "A1 " rec: "A1 " E: "print " 
 --  rec.ATd: "A1: var Area.SquareMeter " rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  %visible Dimensions
 --     %requires Dimensions.Area, Dimensions.Length, Dimensions.Mass, Dimensions.Energy, Dimensions.AngularAcceleration
 --     energyCombinations: 
 --        M: var Mass.KiloGram
 --  recA: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A1":rec:- 
 --  pRecA: none 
 -- pRec: "A1 " rec: "A1 " E: "print " 
 --  false true 
 -- computeAdrX:before:rec:: "A1 " 
 -- OI:invoke:before:ATdx.invoke: var A1 
 -- DI:invoke: "A1: var Area.SquareMeter " 
 -- isValueObj:isAdr: true objSize: 2  rec "A1 ",E: "print ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 -- Address:loadAdr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain "print " cmpAndSwap: false rec: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 -- computeAdrX:after:rec.invoke: "A1 " 
 -- computeAdrX:isLast:E:  "print "
 -- originIsValueObj: 
 --  %visible Dimensions
 --  %requires Dimensions.Area, Dimensions.Length, Dimensions.Mass, Dimensions.Energy, Dimensions.AngularAcceleration
 --  energyCombinations: 
 --     M: var Mass.KiloGram
 -- rec = E: false 0 
 -- call:mkValueProxy false true 
 -- mkValueProxy:INV: "A1.print " E: "print " rec: "A1 " E.ATd: 
 --  print:: 
 --     "SquareMeter".print
 --  
 -- CreateProxyW:E: "print "E.ATd.origin.encOG:OGid "SquareMeter "
 --  origin:descNo: 72 "Area ""A1.print " 
 --  rec.ATd: "A1: var Area.SquareMeter "rec.ATd.newOff: 6 0 
 rdouble 0
 -- son: "A1 " 
 -- son: "print " 
 -- recOfE: "A1 "recOfE.ATd: "A1: var Area.SquareMeter " 
 -- first: "Area "ObjectInvocation_Unary first.origin.encOG: "
 --  UnitIssues "
 -- items:goOrigin:encOG: "UnitIssues "on: 2 isValueObj: false 
 --  origin: workspace origin:isValueObj: false 
 rpushg UnitIssues$128 1
 -- items:goOrigin:encOG: "workspace "on: 1 isValueObj: false 
 --  origin: BETAworld origin:isValueObj: false 
 rpushg workspace$127 1
 rpushg LIB 3
 rpushg Dimensions 4
 -- after:Ey.loadOrigin: 
 -- Adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- Address:loadAdr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rpushg EisNone 3
 -- after:A.loadAdr 
 mkValueProxy 72 5
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 --  rec:  "A1 "E:  "print "
 -- INV:gen:E.loadArgs "print "
 -- INV:gen:after:E.loadArgs "print "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print "
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 rec: "A1 " 
 --  
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 invoke print 74 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- OI:invoke:V: adr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 -- INV:gen:end:off: 6 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 -- OG:before:super.gen: "
 --  newline
 --  --  3 * A2 : (* A2).unit = A2.unit = m "
 -- INV:gen: 
 --  newline
 --  --  3 * A2 : (* A2).unit = A2.unit = m
 --  
 -- needorigin: 
 --  newline
 --  --  3 * A2 : (* A2).unit = A2.unit = m
 --  
 -- needOrigin:E: "newline "  E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  Ex: "newline " rec: "newline " E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  E.ATd.desc: 
 --  %globals
 --  put(10)
 --  E.ATd.IT: 
 --  %globals
 --  put(10)
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %globals
 --     put(10)
 --  
 -- after:needOrigin: "newline " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "newline "E:  "newline "
 -- INV:gen:E.loadArgs "newline "
 -- INV:gen:after:E.loadArgs "newline "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "newline "
 -- OI:invoke:before:ATdx.invoke: pattern newline 
 -- ptn:invoke: "newline "E: "newline "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "newline " 
 --  adr:none 
 invoke newline 130 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- AssignmentStatement:gen: "A1 := 3 * A2 " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "A1 := 3 * A2 " right.label: "ObjectGenerator ""3 * A2 " 
 -- OG:before:super.gen: "3 * A2 "
 -- INV:gen: "3 * A2 " 
 -- needorigin: "3 * A2 " 
 -- needOrigin:E: "3 * A2 "  E.ATd: 
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  Ex: "3 * A2 " rec: "3 * A2 " E.ATd: 
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  E.ATd.desc: 
 --  %basic 66
 --  in V: var integer
 --  out R: var integer
 --  E.ATd.IT: 
 --  %basic 66
 --  in V: var integer
 --  out R: var integer
 -- \
 --   
 -- doNeedOrigin:Ex: "3 * A2 "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "3 * A2 " 
 -- doNeedOrigin:E: "3 * A2 " 
 -- computeAdrX:superAdj: 0 "3 * A2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "3 * A2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "3 * A2 "superAdj: 0 
 -- computeAdrX:isLast:E:  "3 * A2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "3 * A2 "E:  "3 * A2 "
 -- INV:gen:E.loadArgs "3 * A2 "
 -- BinaryExp:loadArgs: "3 * A2 " superAdj: 0 
 -- INV:gen: "3 " 
 -- needorigin: "3 " 
 -- needOrigin:E: "3 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "3 " rec: "3 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "3 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "3 "E:  "3 "
 -- INV:gen:E.loadArgs "3 "
 -- INV:gen:after:E.loadArgs "3 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "3 "
 pushc 3
 -- INV:gen:end:off: 
 i2f
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 -- NonVirt: "* A2 " "ObjectInvocation_Binary " ActArg: "A2 "
 --  isValue: true formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "* A2 " isCompositeValueObj: false 
 -- OG:before:super.gen: "A2 "
 -- INV:gen: "A2 " 
 -- needorigin: "A2 " 
 -- needOrigin:E: "A2 "  E.ATd: "A2: var Area.SquareMeter " Ex: "
 --  A2 " rec: "A2 " E.ATd: "A2: var Area.SquareMeter " E.ATd.desc: 
 --  %unit "m2", 1
 --  %Public
 --  thisUnit:: SquareMeter
 --  print:: E.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "A2 " 
 -- doNeedOrigin:E: "A2 " 
 -- computeAdrX:superAdj: 0 "A2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "A2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "A2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A2":rec:- 
 --  rec:  "A2 "E:  "A2 "
 -- INV:gen:E.loadArgs "A2 "
 -- INV:gen:after:E.loadArgs "A2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "A2 "
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var A2 
 -- DI:invoke: "A2: var Area.SquareMeter " 
 -- isValueObj:isAdr: false objSize: 2  rec "A2 ",E: "A2 ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A2":rec:A2 
 -- Address:loadAdr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A2":rec:A2 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:isUnitVal 
 fpushg 8 
 -- OI:invoke:V: adr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A2":rec:A2 
 -- OI:invoke:X: adr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A2":rec:A2 
 -- INV:gen:end:off: 8 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A2":rec:A2 
 -- before:pushSize:  actualArg.super.ATd.OG.isUnitValueObj: true 
 --  :actualArg.isCompositeValueObj: false 
 -- actualArg:UnitOne?: A2 
 -- end:loadArgs:NonVirt: "* A2 "
 -- BinaryExp:loadArgs:end: 
 -- INV:gen:after:E.loadArgs "3 * A2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: BinOp "3 * A2 "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:invoke: "3 "rec: "3 * A2 "
 -- M: "* A2 "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern *   
 -- ptn:invoke: "*   "E: "* A2 "ptnKind: 0 useRtnV: true 
 fmult
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"* A2":rec:3 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"* A2":rec:3 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 fstoreg 6 address:storeg
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "A1.print "
 -- INV:gen: "A1.print " 
 -- needorigin: "A1.print " 
 -- needOrigin:E: "print "  E.ATd: 
 --  print:: 
 --     "SquareMeter".print
 --  Ex: "print " rec: "A1 " E.ATd: 
 --  print:: 
 --     "SquareMeter".print
 --  E.ATd.desc: ""SquareMeter".print " E.ATd.IT: "
 --  "SquareMeter".print " 
 -- doNeedOrigin:Ex: "print "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- origin:isValueObj: "SquareMeter "
 -- after:needOrigin: "print " 
 -- doNeedOrigin:E: "print " 
 -- computeAdrX:superAdj: 0 "A1.print " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "A1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "A1 " rec: "A1 " E: "print " 
 --  A.E: "A1 "
 --  
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A1":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "A1 " rec: "A1 " E: "print " 
 --  rec.ATd: "A1: var Area.SquareMeter " rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  %visible Dimensions
 --     %requires Dimensions.Area, Dimensions.Length, Dimensions.Mass, Dimensions.Energy, Dimensions.AngularAcceleration
 --     energyCombinations: 
 --        M: var Mass.KiloGram
 --  recA: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A1":rec:- 
 --  pRecA: none 
 -- pRec: "A1 " rec: "A1 " E: "print " 
 --  false true 
 -- computeAdrX:before:rec:: "A1 " 
 -- OI:invoke:before:ATdx.invoke: var A1 
 -- DI:invoke: "A1: var Area.SquareMeter " 
 -- isValueObj:isAdr: true objSize: 2  rec "A1 ",E: "print ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 -- Address:loadAdr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain "print " cmpAndSwap: false rec: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 -- computeAdrX:after:rec.invoke: "A1 " 
 -- computeAdrX:isLast:E:  "print "
 -- originIsValueObj: 
 --  %visible Dimensions
 --  %requires Dimensions.Area, Dimensions.Length, Dimensions.Mass, Dimensions.Energy, Dimensions.AngularAcceleration
 --  energyCombinations: 
 --     M: var Mass.KiloGram
 -- rec = E: false 0 
 -- call:mkValueProxy false true 
 -- mkValueProxy:INV: "A1.print " E: "print " rec: "A1 " E.ATd: 
 --  print:: 
 --     "SquareMeter".print
 --  
 -- CreateProxyW:E: "print "E.ATd.origin.encOG:OGid "SquareMeter "
 --  origin:descNo: 72 "Area ""A1.print " 
 --  rec.ATd: "A1: var Area.SquareMeter "rec.ATd.newOff: 6 0 
 rdouble 0
 -- son: "A1 " 
 -- son: "print " 
 -- recOfE: "A1 "recOfE.ATd: "A1: var Area.SquareMeter " 
 -- first: "Area "ObjectInvocation_Unary first.origin.encOG: "
 --  UnitIssues "
 -- items:goOrigin:encOG: "UnitIssues "on: 2 isValueObj: false 
 --  origin: workspace origin:isValueObj: false 
 rpushg UnitIssues$128 1
 -- items:goOrigin:encOG: "workspace "on: 1 isValueObj: false 
 --  origin: BETAworld origin:isValueObj: false 
 rpushg workspace$127 1
 rpushg LIB 3
 rpushg Dimensions 4
 -- after:Ey.loadOrigin: 
 -- Adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- Address:loadAdr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rpushg EisNone 3
 -- after:A.loadAdr 
 mkValueProxy 72 5
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 --  rec:  "A1 "E:  "print "
 -- INV:gen:E.loadArgs "print "
 -- INV:gen:after:E.loadArgs "print "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print "
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 rec: "A1 " 
 --  
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 invoke print 74 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- OI:invoke:V: adr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 -- INV:gen:end:off: 6 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 -- OG:before:super.gen: "
 --  newline
 --  --  3 m * 5 m : (* 5 m).unit = (5 m).unit = m "
 -- INV:gen: 
 --  newline
 --  --  3 m * 5 m : (* 5 m).unit = (5 m).unit = m
 --  
 -- needorigin: 
 --  newline
 --  --  3 m * 5 m : (* 5 m).unit = (5 m).unit = m
 --  
 -- needOrigin:E: "newline "  E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  Ex: "newline " rec: "newline " E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  E.ATd.desc: 
 --  %globals
 --  put(10)
 --  E.ATd.IT: 
 --  %globals
 --  put(10)
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %globals
 --     put(10)
 --  
 -- after:needOrigin: "newline " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "newline "E:  "newline "
 -- INV:gen:E.loadArgs "newline "
 -- INV:gen:after:E.loadArgs "newline "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "newline "
 -- OI:invoke:before:ATdx.invoke: pattern newline 
 -- ptn:invoke: "newline "E: "newline "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "newline " 
 --  adr:none 
 invoke newline 130 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- AssignmentStatement:gen: "A3 := 3.0"m" * 5.0"m" " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "A3 := 3.0"m" * 5.0"m" " right.label: "ObjectGenerator ""
 --  3.0"m" * 5.0"m" " 
 -- OG:before:super.gen: "3.0"m" * 5.0"m" "
 -- INV:gen: "3.0"m" * 5.0"m" " 
 -- needorigin: "3.0"m" * 5.0"m" " 
 -- needOrigin:E: "3.0"m" * 5.0"m" "  E.ATd: 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  Ex: "3.0"m" * 5.0"m" " rec: "3.0"m" * 5.0"m" " E.ATd: 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  E.ATd.desc: 
 --  %basic 112
 --  in V: var float
 --  out R: var float
 --  E.ATd.IT: 
 --  %basic 112
 --  in V: var float
 --  out R: var float
 -- \
 --   
 -- doNeedOrigin:Ex: "3.0"m" * 5.0"m" "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "3.0"m" * 5.0"m" " 
 -- doNeedOrigin:E: "3.0"m" * 5.0"m" " 
 -- computeAdrX:superAdj: 0 "3.0"m" * 5.0"m" " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "3.0"m" * 5.0"m" " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "3.0"m" * 5.0"m" "superAdj: 0 
 -- computeAdrX:isLast:E:  "3.0"m" * 5.0"m" "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "3.0"m" * 5.0"m" "E:  "3.0"m" * 5.0"m" "
 -- INV:gen:E.loadArgs "3.0"m" * 5.0"m" "
 -- BinaryExp:loadArgs: "3.0"m" * 5.0"m" " superAdj: 0 
 -- INV:gen: "3.0"m" " 
 -- needorigin: "3.0"m" " 
 -- needOrigin:E: "3.0"m" "  E.ATd: 
 --  float: Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var FloatEx: "3.0"m" " rec: "3.0"m" " E.ATd: 
 --  float: Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var FloatE.ATd.desc: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %publicE.ATd.IT: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var Float
 -- after:needOrigin: "3.0"m" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "3.0"m" "E:  "3.0"m" "
 -- INV:gen:E.loadArgs "3.0"m" "
 -- INV:gen:after:E.loadArgs "3.0"m" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: FloatLiteral "3.0"m" "
 pushFloatConst 3.000000
 -- INV:gen:end:off: 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 -- NonVirt: "* 5.0"m" " "ObjectInvocation_Binary " ActArg: "5.0"m" "
 --  isValue: true formalArg: "in V: var float " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- OG:before:super.gen: "5.0"m" "
 -- INV:gen: "5.0"m" " 
 -- needorigin: "5.0"m" " 
 -- needOrigin:E: "5.0"m" "  E.ATd: 
 --  float: Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var FloatEx: "5.0"m" " rec: "5.0"m" " E.ATd: 
 --  float: Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var FloatE.ATd.desc: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %publicE.ATd.IT: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var Float
 -- after:needOrigin: "5.0"m" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "5.0"m" "E:  "5.0"m" "
 -- INV:gen:E.loadArgs "5.0"m" "
 -- INV:gen:after:E.loadArgs "5.0"m" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: FloatLiteral "5.0"m" "
 pushFloatConst 5.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var float "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "5.0"m" ":isBasicVal: true 
 -- case:B: 5.0"m" ObjectGenerator 9 9 9 false true 
 -- end:loadArgs:NonVirt: "* 5.0"m" "
 -- BinaryExp:loadArgs:end: 
 -- INV:gen:after:E.loadArgs "3.0"m" * 5.0"m" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: BinOp "3.0"m" * 5.0"m" "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:invoke: "3.0"m" "rec: "3.0"m" * 5.0"m" "
 -- M: "* 5.0"m" "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern *   
 -- ptn:invoke: "*   "E: "* 5.0"m" "ptnKind: 0 useRtnV: true 
 fmult
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"* 5.0"m"":rec:3.0"m" 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"* 5.0"m"":rec:3.0"m" 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 fstoreg 10 address:storeg
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "A3.print "
 -- INV:gen: "A3.print " 
 -- needorigin: "A3.print " 
 -- needOrigin:E: "print "  E.ATd: 
 --  print:: 
 --     "SquareMeter".print
 --  Ex: "print " rec: "A3 " E.ATd: 
 --  print:: 
 --     "SquareMeter".print
 --  E.ATd.desc: ""SquareMeter".print " E.ATd.IT: "
 --  "SquareMeter".print " 
 -- doNeedOrigin:Ex: "print "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- origin:isValueObj: "SquareMeter "
 -- after:needOrigin: "print " 
 -- doNeedOrigin:E: "print " 
 -- computeAdrX:superAdj: 0 "A3.print " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "A3 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "A3 " rec: "A3 " E: "print " 
 --  A.E: "A3 "
 --  
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A3":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "A3 " rec: "A3 " E: "print " 
 --  rec.ATd: "A3: var Area.SquareMeter " rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  %visible Dimensions
 --     %requires Dimensions.Area, Dimensions.Length, Dimensions.Mass, Dimensions.Energy, Dimensions.AngularAcceleration
 --     energyCombinations: 
 --        M: var Mass.KiloGram
 --  recA: 
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A3":rec:- 
 --  pRecA: none 
 -- pRec: "A3 " rec: "A3 " E: "print " 
 --  false true 
 -- computeAdrX:before:rec:: "A3 " 
 -- OI:invoke:before:ATdx.invoke: var A3 
 -- DI:invoke: "A3: var Area.SquareMeter " 
 -- isValueObj:isAdr: true objSize: 2  rec "A3 ",E: "print ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A3 
 -- Address:loadAdr: 
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A3 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain "print " cmpAndSwap: false rec: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A3 
 -- OI:invoke:X: adr: 
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A3 
 -- computeAdrX:after:rec.invoke: "A3 " 
 -- computeAdrX:isLast:E:  "print "
 -- originIsValueObj: 
 --  %visible Dimensions
 --  %requires Dimensions.Area, Dimensions.Length, Dimensions.Mass, Dimensions.Energy, Dimensions.AngularAcceleration
 --  energyCombinations: 
 --     M: var Mass.KiloGram
 -- rec = E: false 0 
 -- call:mkValueProxy false true 
 -- mkValueProxy:INV: "A3.print " E: "print " rec: "A3 " E.ATd: 
 --  print:: 
 --     "SquareMeter".print
 --  
 -- CreateProxyW:E: "print "E.ATd.origin.encOG:OGid "SquareMeter "
 --  origin:descNo: 72 "Area ""A3.print " 
 --  rec.ATd: "A3: var Area.SquareMeter "rec.ATd.newOff: 10 0 
 rdouble 0
 -- son: "A3 " 
 -- son: "print " 
 -- recOfE: "A3 "recOfE.ATd: "A3: var Area.SquareMeter " 
 -- first: "Area "ObjectInvocation_Unary first.origin.encOG: "
 --  UnitIssues "
 -- items:goOrigin:encOG: "UnitIssues "on: 2 isValueObj: false 
 --  origin: workspace origin:isValueObj: false 
 rpushg UnitIssues$128 1
 -- items:goOrigin:encOG: "workspace "on: 1 isValueObj: false 
 --  origin: BETAworld origin:isValueObj: false 
 rpushg workspace$127 1
 rpushg LIB 3
 rpushg Dimensions 4
 -- after:Ey.loadOrigin: 
 -- Adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- Address:loadAdr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rpushg EisNone 3
 -- after:A.loadAdr 
 mkValueProxy 72 9
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A3 
 --  rec:  "A3 "E:  "print "
 -- INV:gen:E.loadArgs "print "
 -- INV:gen:after:E.loadArgs "print "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print "
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A3 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 rec: "A3 " 
 --  
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A3 
 invoke print 74 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- OI:invoke:V: adr: 
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A3 
 -- OI:invoke:X: adr: 
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A3 
 -- INV:gen:end:off: 10 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A3 
 -- OG:before:super.gen: "newline "
 -- INV:gen: "newline " 
 -- needorigin: "newline " 
 -- needOrigin:E: "newline "  E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  Ex: "newline " rec: "newline " E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  E.ATd.desc: 
 --  %globals
 --  put(10)
 --  E.ATd.IT: 
 --  %globals
 --  put(10)
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %globals
 --     put(10)
 --  
 -- after:needOrigin: "newline " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "newline "E:  "newline "
 -- INV:gen:E.loadArgs "newline "
 -- INV:gen:after:E.loadArgs "newline "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "newline "
 -- OI:invoke:before:ATdx.invoke: pattern newline 
 -- ptn:invoke: "newline "E: "newline "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "newline " 
 --  adr:none 
 invoke newline 130 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- AssignmentStatement:gen: "L1 := 5"m" " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "L1 := 5"m" " right.label: "ObjectGenerator ""5"m" " 
 -- OG:before:super.gen: "5"m" "
 -- INV:gen: "5"m" " 
 -- needorigin: "5"m" " 
 -- needOrigin:E: "5"m" "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "5"m" " rec: "5"m" " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "5"m" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "5"m" "E:  "5"m" "
 -- INV:gen:E.loadArgs "5"m" "
 -- INV:gen:after:E.loadArgs "5"m" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "5"m" "
 pushc 5
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 i2f
 -- assign:adr.store:A: 
 fstoreg 2 address:storeg
 -- assign:adr.store:B: 
 -- AssignmentStatement:gen: "L2 := 3"m" " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "L2 := 3"m" " right.label: "ObjectGenerator ""3"m" " 
 -- OG:before:super.gen: "3"m" "
 -- INV:gen: "3"m" " 
 -- needorigin: "3"m" " 
 -- needOrigin:E: "3"m" "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "3"m" " rec: "3"m" " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "3"m" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "3"m" "E:  "3"m" "
 -- INV:gen:E.loadArgs "3"m" "
 -- INV:gen:after:E.loadArgs "3"m" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "3"m" "
 pushc 3
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 i2f
 -- assign:adr.store:A: 
 fstoreg 4 address:storeg
 -- assign:adr.store:B: 
 -- AssignmentStatement:gen: "A3 := L1 * L2 " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "A3 := L1 * L2 " right.label: "ObjectGenerator ""L1 * L2 " 
 -- OG:before:super.gen: "L1 * L2 "
 -- INV:gen: "L1 * L2 " 
 -- needorigin: "L1 * L2 " 
 -- needOrigin:E: "L1 * L2 "  E.ATd: 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  Ex: "L1 * L2 " rec: "L1 * L2 " E.ATd: 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  E.ATd.desc: 
 --  %basic 112
 --  in V: var float
 --  out R: var float
 --  E.ATd.IT: 
 --  %basic 112
 --  in V: var float
 --  out R: var float
 -- \
 --   
 -- doNeedOrigin:Ex: "L1 * L2 "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "L1 * L2 " 
 -- doNeedOrigin:E: "L1 * L2 " 
 -- computeAdrX:superAdj: 0 "L1 * L2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L1 * L2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "L1 * L2 "superAdj: 0 
 -- computeAdrX:isLast:E:  "L1 * L2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "L1 * L2 "E:  "L1 * L2 "
 -- INV:gen:E.loadArgs "L1 * L2 "
 -- BinaryExp:loadArgs: "L1 * L2 " superAdj: 0 
 -- INV:gen: "L1 " 
 -- needorigin: "L1 " 
 -- needOrigin:E: "L1 "  E.ATd: "L1: var Length.meter " Ex: "L1 " 
 --  rec: "L1 " E.ATd: "L1: var Length.meter " E.ATd.desc: 
 --  %unit "m", 1
 --  %Public
 --  thisUnit:: Meter
 --  argUnit:: MeterE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L1 " 
 -- doNeedOrigin:E: "L1 " 
 -- computeAdrX:superAdj: 0 "L1 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "L1 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 --  rec:  "L1 "E:  "L1 "
 -- INV:gen:E.loadArgs "L1 "
 -- INV:gen:after:E.loadArgs "L1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L1 "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- DI:invoke: "L1: var Length.meter " 
 -- isValueObj:isAdr: false objSize: 2  rec "L1 ",E: "L1 ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- Address:loadAdr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:isUnitVal 
 fpushg 2 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- NonVirt: "* L2 " "ObjectInvocation_Binary " ActArg: "L2 "
 --  isValue: true formalArg: "in V: var float " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- OG:before:super.gen: "L2 "
 -- INV:gen: "L2 " 
 -- needorigin: "L2 " 
 -- needOrigin:E: "L2 "  E.ATd: "L2: var Length.Meter " Ex: "L2 " 
 --  rec: "L2 " E.ATd: "L2: var Length.Meter " E.ATd.desc: 
 --  %unit "m", 1
 --  %Public
 --  thisUnit:: Meter
 --  argUnit:: MeterE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L2 " 
 -- doNeedOrigin:E: "L2 " 
 -- computeAdrX:superAdj: 0 "L2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "L2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 --  rec:  "L2 "E:  "L2 "
 -- INV:gen:E.loadArgs "L2 "
 -- INV:gen:after:E.loadArgs "L2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L2 "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- DI:invoke: "L2: var Length.Meter " 
 -- isValueObj:isAdr: false objSize: 2  rec "L2 ",E: "L2 ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- Address:loadAdr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:isUnitVal 
 fpushg 4 
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- before:pushSize:  actualArg.super.ATd.OG.isUnitValueObj: true 
 --  :actualArg.isCompositeValueObj: false 
 -- actualArg:UnitOne?: L2 
 -- end:loadArgs:NonVirt: "* L2 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:after:E.loadArgs "L1 * L2 "
 --  OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L1 * L2 "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- BinaryExp:invoke: "L1 "rec: "L1 * L2 "
 -- M: "* L2 "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:before:ATdx.invoke: pattern *   
 -- ptn:invoke: "*   "E: "* L2 "ptnKind: 0 useRtnV: true 
 fmult
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* L2":rec:L1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* L2":rec:L1 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 fstoreg 10 address:storeg
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "A3.print "
 -- INV:gen: "A3.print " 
 -- needorigin: "A3.print " 
 -- needOrigin:E: "print "  E.ATd: 
 --  print:: 
 --     "SquareMeter".print
 --  Ex: "print " rec: "A3 " E.ATd: 
 --  print:: 
 --     "SquareMeter".print
 --  E.ATd.desc: ""SquareMeter".print " E.ATd.IT: "
 --  "SquareMeter".print " 
 -- doNeedOrigin:Ex: "print "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- origin:isValueObj: "SquareMeter "
 -- after:needOrigin: "print " 
 -- doNeedOrigin:E: "print " 
 -- computeAdrX:superAdj: 0 "A3.print " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "A3 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "A3 " rec: "A3 " E: "print " 
 --  A.E: "A3 "
 --  
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A3":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "A3 " rec: "A3 " E: "print " 
 --  rec.ATd: "A3: var Area.SquareMeter " rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  %visible Dimensions
 --     %requires Dimensions.Area, Dimensions.Length, Dimensions.Mass, Dimensions.Energy, Dimensions.AngularAcceleration
 --     energyCombinations: 
 --        M: var Mass.KiloGram
 --  recA: 
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A3":rec:- 
 --  pRecA: none 
 -- pRec: "A3 " rec: "A3 " E: "print " 
 --  false true 
 -- computeAdrX:before:rec:: "A3 " 
 -- OI:invoke:before:ATdx.invoke: var A3 
 -- DI:invoke: "A3: var Area.SquareMeter " 
 -- isValueObj:isAdr: true objSize: 2  rec "A3 ",E: "print ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A3 
 -- Address:loadAdr: 
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A3 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain "print " cmpAndSwap: false rec: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A3 
 -- OI:invoke:X: adr: 
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A3 
 -- computeAdrX:after:rec.invoke: "A3 " 
 -- computeAdrX:isLast:E:  "print "
 -- originIsValueObj: 
 --  %visible Dimensions
 --  %requires Dimensions.Area, Dimensions.Length, Dimensions.Mass, Dimensions.Energy, Dimensions.AngularAcceleration
 --  energyCombinations: 
 --     M: var Mass.KiloGram
 -- rec = E: false 0 
 -- call:mkValueProxy false true 
 -- mkValueProxy:INV: "A3.print " E: "print " rec: "A3 " E.ATd: 
 --  print:: 
 --     "SquareMeter".print
 --  
 -- CreateProxyW:E: "print "E.ATd.origin.encOG:OGid "SquareMeter "
 --  origin:descNo: 72 "Area ""A3.print " 
 --  rec.ATd: "A3: var Area.SquareMeter "rec.ATd.newOff: 10 0 
 rdouble 0
 -- son: "A3 " 
 -- son: "print " 
 -- recOfE: "A3 "recOfE.ATd: "A3: var Area.SquareMeter " 
 -- first: "Area "ObjectInvocation_Unary first.origin.encOG: "
 --  UnitIssues "
 -- items:goOrigin:encOG: "UnitIssues "on: 2 isValueObj: false 
 --  origin: workspace origin:isValueObj: false 
 rpushg UnitIssues$128 1
 -- items:goOrigin:encOG: "workspace "on: 1 isValueObj: false 
 --  origin: BETAworld origin:isValueObj: false 
 rpushg workspace$127 1
 rpushg LIB 3
 rpushg Dimensions 4
 -- after:Ey.loadOrigin: 
 -- Adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- Address:loadAdr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rpushg EisNone 3
 -- after:A.loadAdr 
 mkValueProxy 72 9
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A3 
 --  rec:  "A3 "E:  "print "
 -- INV:gen:E.loadArgs "print "
 -- INV:gen:after:E.loadArgs "print "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print "
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A3 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 rec: "A3 " 
 --  
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A3 
 invoke print 74 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- OI:invoke:V: adr: 
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A3 
 -- OI:invoke:X: adr: 
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A3 
 -- INV:gen:end:off: 10 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A3 
 -- OG:before:super.gen: "newline "
 -- INV:gen: "newline " 
 -- needorigin: "newline " 
 -- needOrigin:E: "newline "  E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  Ex: "newline " rec: "newline " E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  E.ATd.desc: 
 --  %globals
 --  put(10)
 --  E.ATd.IT: 
 --  %globals
 --  put(10)
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %globals
 --     put(10)
 --  
 -- after:needOrigin: "newline " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "newline "E:  "newline "
 -- INV:gen:E.loadArgs "newline "
 -- INV:gen:after:E.loadArgs "newline "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "newline "
 -- OI:invoke:before:ATdx.invoke: pattern newline 
 -- ptn:invoke: "newline "E: "newline "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "newline " 
 --  adr:none 
 invoke newline 130 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- AssignmentStatement:gen: "V := 3.14 " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "V := 3.14 " right.label: "ObjectGenerator ""3.14 " 
 -- OG:before:super.gen: "3.14 "
 -- INV:gen: "3.14 " 
 -- needorigin: "3.14 " 
 -- needOrigin:E: "3.14 "  E.ATd: 
 --  float: Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var FloatEx: "3.14 " rec: "3.14 " E.ATd: 
 --  float: Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var FloatE.ATd.desc: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %publicE.ATd.IT: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var Float
 -- after:needOrigin: "3.14 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "3.14 "E:  "3.14 "
 -- INV:gen:E.loadArgs "3.14 "
 -- INV:gen:after:E.loadArgs "3.14 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: FloatLiteral "3.14 "
 pushFloatConst 3.140000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 fstoreg 12 address:storeg
 -- assign:adr.store:B: 
 -- AssignmentStatement:gen: "L1 := V " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "L1 := V " right.label: "ObjectGenerator ""V " 
 -- OG:before:super.gen: "V "
 -- INV:gen: "V " 
 -- needorigin: "V " 
 -- needOrigin:E: "V "  E.ATd: "V: var Float " Ex: "V " rec: "V " 
 --  E.ATd: "V: var Float " E.ATd.desc: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "V " 
 -- doNeedOrigin:E: "V " 
 -- computeAdrX:superAdj: 0 "V " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "V " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "V "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:12 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 --  rec:  "V "E:  "V "
 -- INV:gen:E.loadArgs "V "
 -- INV:gen:after:E.loadArgs "V "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "V "
 --  :Adr:off:12 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- OI:invoke:before:ATdx.invoke: var V 
 -- DI:invoke: "V: var Float " 
 -- load: 
 --  :Adr:off:12 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V isNotRemote: true 
 fpushg 12 
 -- OI:invoke:V: adr: 
 --  :Adr:off:12 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:X: adr: 
 --  :Adr:off:12 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- INV:gen:end:off: 12 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:12 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- assign:adr.store:A: 
 fstoreg 2 address:storeg
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "L1.print "
 -- INV:gen: "L1.print " 
 -- needorigin: "L1.print " 
 -- needOrigin:E: "print "  E.ATd: 
 --  print:: 
 --     "Meter".print
 --  Ex: "print " rec: "L1 " E.ATd: 
 --  print:: 
 --     "Meter".print
 --  E.ATd.desc: ""Meter".print " E.ATd.IT: ""Meter".print " 
 -- doNeedOrigin:Ex: "print "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- origin:isValueObj: "Meter "
 -- after:needOrigin: "print " 
 -- doNeedOrigin:E: "print " 
 -- computeAdrX:superAdj: 0 "L1.print " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "L1 " rec: "L1 " E: "print " 
 --  A.E: "L1 "
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "L1 " rec: "L1 " E: "print " 
 --  rec.ATd: "L1: var Length.meter " rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  %visible Dimensions
 --     %requires Dimensions.Area, Dimensions.Length, Dimensions.Mass, Dimensions.Energy, Dimensions.AngularAcceleration
 --     energyCombinations: 
 --        M: var Mass.KiloGram
 --  recA: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 --  pRecA: none 
 -- pRec: "L1 " rec: "L1 " E: "print " 
 --  false true 
 -- computeAdrX:before:rec:: "L1 " 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- DI:invoke: "L1: var Length.meter " 
 -- isValueObj:isAdr: true objSize: 2  rec "L1 ",E: "print ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- Address:loadAdr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain "print " cmpAndSwap: false rec: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- computeAdrX:after:rec.invoke: "L1 " 
 -- computeAdrX:isLast:E:  "print "
 -- originIsValueObj: 
 --  %visible Dimensions
 --  %requires Dimensions.Area, Dimensions.Length, Dimensions.Mass, Dimensions.Energy, Dimensions.AngularAcceleration
 --  energyCombinations: 
 --     M: var Mass.KiloGram
 -- rec = E: false 0 
 -- call:mkValueProxy false true 
 -- mkValueProxy:INV: "L1.print " E: "print " rec: "L1 " E.ATd: 
 --  print:: 
 --     "Meter".print
 --  
 -- CreateProxyW:E: "print "E.ATd.origin.encOG:OGid "Meter "
 --  origin:descNo: 91 "Length ""L1.print " 
 --  rec.ATd: "L1: var Length.meter "rec.ATd.newOff: 2 0 
 rdouble 0
 -- son: "L1 " 
 -- son: "print " 
 -- recOfE: "L1 "recOfE.ATd: "L1: var Length.meter " 
 -- first: "Length "ObjectInvocation_Unary first.origin.encOG: "
 --  UnitIssues "
 -- items:goOrigin:encOG: "UnitIssues "on: 2 isValueObj: false 
 --  origin: workspace origin:isValueObj: false 
 rpushg UnitIssues$128 1
 -- items:goOrigin:encOG: "workspace "on: 1 isValueObj: false 
 --  origin: BETAworld origin:isValueObj: false 
 rpushg workspace$127 1
 rpushg LIB 3
 rpushg Dimensions 4
 -- after:Ey.loadOrigin: 
 -- Adr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- Address:loadAdr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rpushg EisNone 6
 -- after:A.loadAdr 
 mkValueProxy 91 1
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 --  rec:  "L1 "E:  "print "
 -- INV:gen:E.loadArgs "print "
 -- INV:gen:after:E.loadArgs "print "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 rec: "L1 " 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 invoke print 97 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- OG:before:super.gen: "newline "
 -- INV:gen: "newline " 
 -- needorigin: "newline " 
 -- needOrigin:E: "newline "  E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  Ex: "newline " rec: "newline " E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  E.ATd.desc: 
 --  %globals
 --  put(10)
 --  E.ATd.IT: 
 --  %globals
 --  put(10)
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %globals
 --     put(10)
 --  
 -- after:needOrigin: "newline " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "newline "E:  "newline "
 -- INV:gen:E.loadArgs "newline "
 -- INV:gen:after:E.loadArgs "newline "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "newline "
 -- OI:invoke:before:ATdx.invoke: pattern newline 
 -- ptn:invoke: "newline "E: "newline "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "newline " 
 --  adr:none 
 invoke newline 130 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- AssignmentStatement:gen: "N := 1001 " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "N := 1001 " right.label: "ObjectGenerator ""1001 " 
 -- OG:before:super.gen: "1001 "
 -- INV:gen: "1001 " 
 -- needorigin: "1001 " 
 -- needOrigin:E: "1001 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "1001 " rec: "1001 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "1001 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "1001 "E:  "1001 "
 -- INV:gen:E.loadArgs "1001 "
 -- INV:gen:after:E.loadArgs "1001 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1001 "
 pushc 1001
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg UnitIssues$128 14
 -- assign:adr.store:B: 
 -- AssignmentStatement:gen: "L1 := N " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "L1 := N " right.label: "ObjectGenerator ""N " 
 -- OG:before:super.gen: "N "
 -- INV:gen: "N " 
 -- needorigin: "N " 
 -- needOrigin:E: "N "  E.ATd: "N: var integer " Ex: "N " rec: "N " 
 --  E.ATd: "N: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "N " 
 -- doNeedOrigin:E: "N " 
 -- computeAdrX:superAdj: 0 "N " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "N " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "N "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:14 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"N":rec:- 
 --  rec:  "N "E:  "N "
 -- INV:gen:E.loadArgs "N "
 -- INV:gen:after:E.loadArgs "N "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "N "
 --  :Adr:off:14 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"N":rec:- 
 -- OI:invoke:before:ATdx.invoke: var N 
 -- DI:invoke: "N: var integer " 
 -- load: 
 --  :Adr:off:14 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"N":rec:N isNotRemote: true 
 pushg 14 UnitIssues$128
 -- OI:invoke:V: adr: 
 --  :Adr:off:14 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"N":rec:N 
 -- OI:invoke:X: adr: 
 --  :Adr:off:14 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"N":rec:N 
 -- INV:gen:end:off: 14 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:14 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"N":rec:N 
 i2f
 -- assign:adr.store:A: 
 fstoreg 2 address:storeg
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "L1.print "
 -- INV:gen: "L1.print " 
 -- needorigin: "L1.print " 
 -- needOrigin:E: "print "  E.ATd: 
 --  print:: 
 --     "Meter".print
 --  Ex: "print " rec: "L1 " E.ATd: 
 --  print:: 
 --     "Meter".print
 --  E.ATd.desc: ""Meter".print " E.ATd.IT: ""Meter".print " 
 -- doNeedOrigin:Ex: "print "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- origin:isValueObj: "Meter "
 -- after:needOrigin: "print " 
 -- doNeedOrigin:E: "print " 
 -- computeAdrX:superAdj: 0 "L1.print " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "L1 " rec: "L1 " E: "print " 
 --  A.E: "L1 "
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "L1 " rec: "L1 " E: "print " 
 --  rec.ATd: "L1: var Length.meter " rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  %visible Dimensions
 --     %requires Dimensions.Area, Dimensions.Length, Dimensions.Mass, Dimensions.Energy, Dimensions.AngularAcceleration
 --     energyCombinations: 
 --        M: var Mass.KiloGram
 --  recA: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 --  pRecA: none 
 -- pRec: "L1 " rec: "L1 " E: "print " 
 --  false true 
 -- computeAdrX:before:rec:: "L1 " 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- DI:invoke: "L1: var Length.meter " 
 -- isValueObj:isAdr: true objSize: 2  rec "L1 ",E: "print ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- Address:loadAdr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain "print " cmpAndSwap: false rec: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- computeAdrX:after:rec.invoke: "L1 " 
 -- computeAdrX:isLast:E:  "print "
 -- originIsValueObj: 
 --  %visible Dimensions
 --  %requires Dimensions.Area, Dimensions.Length, Dimensions.Mass, Dimensions.Energy, Dimensions.AngularAcceleration
 --  energyCombinations: 
 --     M: var Mass.KiloGram
 -- rec = E: false 0 
 -- call:mkValueProxy false true 
 -- mkValueProxy:INV: "L1.print " E: "print " rec: "L1 " E.ATd: 
 --  print:: 
 --     "Meter".print
 --  
 -- CreateProxyW:E: "print "E.ATd.origin.encOG:OGid "Meter "
 --  origin:descNo: 91 "Length ""L1.print " 
 --  rec.ATd: "L1: var Length.meter "rec.ATd.newOff: 2 0 
 rdouble 0
 -- son: "L1 " 
 -- son: "print " 
 -- recOfE: "L1 "recOfE.ATd: "L1: var Length.meter " 
 -- first: "Length "ObjectInvocation_Unary first.origin.encOG: "
 --  UnitIssues "
 -- items:goOrigin:encOG: "UnitIssues "on: 2 isValueObj: false 
 --  origin: workspace origin:isValueObj: false 
 rpushg UnitIssues$128 1
 -- items:goOrigin:encOG: "workspace "on: 1 isValueObj: false 
 --  origin: BETAworld origin:isValueObj: false 
 rpushg workspace$127 1
 rpushg LIB 3
 rpushg Dimensions 4
 -- after:Ey.loadOrigin: 
 -- Adr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- Address:loadAdr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rpushg EisNone 6
 -- after:A.loadAdr 
 mkValueProxy 91 1
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 --  rec:  "L1 "E:  "print "
 -- INV:gen:E.loadArgs "print "
 -- INV:gen:after:E.loadArgs "print "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 rec: "L1 " 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 invoke print 97 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- OG:before:super.gen: "newline "
 -- INV:gen: "newline " 
 -- needorigin: "newline " 
 -- needOrigin:E: "newline "  E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  Ex: "newline " rec: "newline " E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  E.ATd.desc: 
 --  %globals
 --  put(10)
 --  E.ATd.IT: 
 --  %globals
 --  put(10)
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %globals
 --     put(10)
 --  
 -- after:needOrigin: "newline " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "newline "E:  "newline "
 -- INV:gen:E.loadArgs "newline "
 -- INV:gen:after:E.loadArgs "newline "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "newline "
 -- OI:invoke:before:ATdx.invoke: pattern newline 
 -- ptn:invoke: "newline "E: "newline "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "newline " 
 --  adr:none 
 invoke newline 130 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- AssignmentStatement:gen: "L1 := (N + 8) " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "L1 := (N + 8) " right.label: "ObjectGenerator ""(N + 8) " 
 -- OG:before:super.gen: "(N + 8) "
 -- INV:gen: "(N + 8) " 
 -- needorigin: "(N + 8) " 
 -- needOrigin:E: "(N + 8) "  E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  Ex: "(N + 8) " rec: "(N + 8) " E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  E.ATd.desc: 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 --  E.ATd.IT: 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 -- \
 --   
 -- doNeedOrigin:Ex: "(N + 8) "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(N + 8) " 
 -- doNeedOrigin:E: "(N + 8) " 
 -- computeAdrX:superAdj: 0 "(N + 8) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(N + 8) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "N + 8 "superAdj: 0 
 -- computeAdrX:isLast:E:  "N + 8 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "N + 8 "E:  "N + 8 "
 -- INV:gen:E.loadArgs "N + 8 "
 -- BinaryExp:loadArgs: "N + 8 " superAdj: 0 
 -- INV:gen: "N " 
 -- needorigin: "N " 
 -- needOrigin:E: "N "  E.ATd: "N: var integer " Ex: "N " rec: "N " 
 --  E.ATd: "N: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "N " 
 -- doNeedOrigin:E: "N " 
 -- computeAdrX:superAdj: 0 "N " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "N " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "N "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:14 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"N":rec:- 
 --  rec:  "N "E:  "N "
 -- INV:gen:E.loadArgs "N "
 -- INV:gen:after:E.loadArgs "N "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "N "
 --  :Adr:off:14 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"N":rec:- 
 -- OI:invoke:before:ATdx.invoke: var N 
 -- DI:invoke: "N: var integer " 
 -- load: 
 --  :Adr:off:14 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"N":rec:N isNotRemote: true 
 pushg 14 UnitIssues$128
 -- OI:invoke:V: adr: 
 --  :Adr:off:14 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"N":rec:N 
 -- OI:invoke:X: adr: 
 --  :Adr:off:14 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"N":rec:N 
 -- INV:gen:end:off: 14 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:14 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"N":rec:N 
 -- NonVirt: "+ 8 " "ObjectInvocation_Binary " ActArg: "8 "isValue: 
 --  true formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ 8 " isCompositeValueObj: false 
 -- OG:before:super.gen: "8 "
 -- INV:gen: "8 " 
 -- needorigin: "8 " 
 -- needOrigin:E: "8 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "8 " rec: "8 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "8 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "8 "E:  "8 "
 -- INV:gen:E.loadArgs "8 "
 -- INV:gen:after:E.loadArgs "8 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "8 "
 pushc 8
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "8 ":isBasicVal: true 
 -- case:B: 8 ObjectGenerator 1 1 1 false true 
 -- end:loadArgs:NonVirt: "+ 8 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:14 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"N":rec:N 
 -- INV:gen:after:E.loadArgs "N + 8 "
 --  OIadr: 
 --  :Adr:off:14 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"N":rec:N 
 -- IV:E.invoke:useRtnVal: true E: BinOp "N + 8 "
 --  :Adr:off:14 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"N":rec:N 
 -- BinaryExp:invoke: "N "rec: "N + 8 "
 -- M: "+ 8 "
 --  :Adr:off:14 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"N":rec:N 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- ptn:invoke: "+   "E: "+ 8 "ptnKind: 0 useRtnV: true 
 plus
 -- OI:invoke:V: adr: 
 --  :Adr:off:14 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 8":rec:N 
 -- OI:invoke:X: adr: 
 --  :Adr:off:14 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 8":rec:N 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 i2f
 -- assign:adr.store:A: 
 fstoreg 2 address:storeg
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "L1.print "
 -- INV:gen: "L1.print " 
 -- needorigin: "L1.print " 
 -- needOrigin:E: "print "  E.ATd: 
 --  print:: 
 --     "Meter".print
 --  Ex: "print " rec: "L1 " E.ATd: 
 --  print:: 
 --     "Meter".print
 --  E.ATd.desc: ""Meter".print " E.ATd.IT: ""Meter".print " 
 -- doNeedOrigin:Ex: "print "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- origin:isValueObj: "Meter "
 -- after:needOrigin: "print " 
 -- doNeedOrigin:E: "print " 
 -- computeAdrX:superAdj: 0 "L1.print " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "L1 " rec: "L1 " E: "print " 
 --  A.E: "L1 "
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "L1 " rec: "L1 " E: "print " 
 --  rec.ATd: "L1: var Length.meter " rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  %visible Dimensions
 --     %requires Dimensions.Area, Dimensions.Length, Dimensions.Mass, Dimensions.Energy, Dimensions.AngularAcceleration
 --     energyCombinations: 
 --        M: var Mass.KiloGram
 --  recA: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 --  pRecA: none 
 -- pRec: "L1 " rec: "L1 " E: "print " 
 --  false true 
 -- computeAdrX:before:rec:: "L1 " 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- DI:invoke: "L1: var Length.meter " 
 -- isValueObj:isAdr: true objSize: 2  rec "L1 ",E: "print ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- Address:loadAdr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain "print " cmpAndSwap: false rec: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- computeAdrX:after:rec.invoke: "L1 " 
 -- computeAdrX:isLast:E:  "print "
 -- originIsValueObj: 
 --  %visible Dimensions
 --  %requires Dimensions.Area, Dimensions.Length, Dimensions.Mass, Dimensions.Energy, Dimensions.AngularAcceleration
 --  energyCombinations: 
 --     M: var Mass.KiloGram
 -- rec = E: false 0 
 -- call:mkValueProxy false true 
 -- mkValueProxy:INV: "L1.print " E: "print " rec: "L1 " E.ATd: 
 --  print:: 
 --     "Meter".print
 --  
 -- CreateProxyW:E: "print "E.ATd.origin.encOG:OGid "Meter "
 --  origin:descNo: 91 "Length ""L1.print " 
 --  rec.ATd: "L1: var Length.meter "rec.ATd.newOff: 2 0 
 rdouble 0
 -- son: "L1 " 
 -- son: "print " 
 -- recOfE: "L1 "recOfE.ATd: "L1: var Length.meter " 
 -- first: "Length "ObjectInvocation_Unary first.origin.encOG: "
 --  UnitIssues "
 -- items:goOrigin:encOG: "UnitIssues "on: 2 isValueObj: false 
 --  origin: workspace origin:isValueObj: false 
 rpushg UnitIssues$128 1
 -- items:goOrigin:encOG: "workspace "on: 1 isValueObj: false 
 --  origin: BETAworld origin:isValueObj: false 
 rpushg workspace$127 1
 rpushg LIB 3
 rpushg Dimensions 4
 -- after:Ey.loadOrigin: 
 -- Adr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- Address:loadAdr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rpushg EisNone 6
 -- after:A.loadAdr 
 mkValueProxy 91 1
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 --  rec:  "L1 "E:  "print "
 -- INV:gen:E.loadArgs "print "
 -- INV:gen:after:E.loadArgs "print "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 rec: "L1 " 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 invoke print 97 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- OG:before:super.gen: "newline "
 -- INV:gen: "newline " 
 -- needorigin: "newline " 
 -- needOrigin:E: "newline "  E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  Ex: "newline " rec: "newline " E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  E.ATd.desc: 
 --  %globals
 --  put(10)
 --  E.ATd.IT: 
 --  %globals
 --  put(10)
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %globals
 --     put(10)
 --  
 -- after:needOrigin: "newline " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "newline "E:  "newline "
 -- INV:gen:E.loadArgs "newline "
 -- INV:gen:after:E.loadArgs "newline "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "newline "
 -- OI:invoke:before:ATdx.invoke: pattern newline 
 -- ptn:invoke: "newline "E: "newline "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "newline " 
 --  adr:none 
 invoke newline 130 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- AssignmentStatement:gen: "A1 := foo(3.19"m") " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "A1 := foo(3.19"m") " right.label: "ObjectGenerator ""
 --  foo(3.19"m") " 
 -- OG:before:super.gen: "foo(3.19"m") "
 -- INV:gen: "foo(3.19"m") " 
 -- needorigin: "foo(3.19"m") " 
 -- needOrigin:E: "foo(3.19"m") "  E.ATd: 
 --  foo: 
 --     in L: var Length.Meter
 --     out A: var Area.SquareMeter
 --     A := Area.mult(L,L)
 --  Ex: "foo(3.19"m") " rec: "foo(3.19"m") " E.ATd: 
 --  foo: 
 --     in L: var Length.Meter
 --     out A: var Area.SquareMeter
 --     A := Area.mult(L,L)
 --  E.ATd.desc: 
 --  in L: var Length.Meter
 --  out A: var Area.SquareMeter
 --  A := Area.mult(L,L)
 --  E.ATd.IT: 
 --  in L: var Length.Meter
 --  out A: var Area.SquareMeter
 --  A := Area.mult(L,L)
 -- \
 --   
 -- doNeedOrigin:Ex: "foo(3.19"m") "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "foo(3.19"m") " 
 -- doNeedOrigin:E: "foo(3.19"m") " 
 -- computeAdrX:superAdj: 0 "foo(3.19"m") " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "foo(3.19"m") " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "foo(3.19"m") "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"foo(3.19"m")":rec:- 
 --  rec:  "foo(3.19"m") "E:  "foo(3.19"m") "
 -- INV:gen:E.loadArgs "foo(3.19"m") "
 -- NonVirt: "foo(3.19"m") " "ObjectInvocation_KeyWord " ActArg: "
 --  3.19"m" "isValue: true formalArg: "in L: var Length.Meter " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "foo(3.19"m") "
 --   isCompositeValueObj: true 
 -- OG:before:super.gen: "3.19"m" "
 -- INV:gen: "3.19"m" " 
 -- needorigin: "3.19"m" " 
 -- needOrigin:E: "3.19"m" "  E.ATd: 
 --  float: Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var FloatEx: "3.19"m" " rec: "3.19"m" " E.ATd: 
 --  float: Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var FloatE.ATd.desc: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %publicE.ATd.IT: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var Float
 -- after:needOrigin: "3.19"m" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "3.19"m" "E:  "3.19"m" "
 -- INV:gen:E.loadArgs "3.19"m" "
 -- INV:gen:after:E.loadArgs "3.19"m" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: FloatLiteral "3.19"m" "
 pushFloatConst 3.190000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in L: var Length.Meter "
 --  :isBasicVal: false :valueObj: true 
 --  :actArg: "3.19"m" ":isBasicVal: true 
 -- case:A: "3.19"m" "form:isNonBasicValueObj: true 
 --  act:isBasicValue: true 
 pushc 1
 -- end:loadArgs:NonVirt: "foo(3.19"m") "
 -- INV:gen:after:E.loadArgs "foo(3.19"m") "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "
 --  foo(3.19"m") "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"foo(3.19"m")":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern foo 
 -- ptn:invoke: "foo "E: "foo(3.19"m") "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "foo(3.19"m") " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"foo(3.19"m")":rec:foo(3.19"m") 
 invoke foo 132 0 0
 -- global:pushOut: A off: 4 
 -- callInvoke:after:pushOut: 4 
 -- GeneralPTN:invoke:after:callInvoke: 4 
 -- GeneralPTN:invoke:end: 4 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"foo(3.19"m")":rec:foo(3.19"m") 
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"foo(3.19"m")":rec:foo(3.19"m") 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"foo(3.19"m")":rec:foo(3.19"m") 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"foo(3.19"m")":rec:foo(3.19"m") 
 -- right.super.ATd:not:none 
 -- right.super.ATd.OG.super.ATD:none "ObjectGenerator "foo(3.19"m") 
 -- pushValue: A: off: 4 size: 5 descNo: -1 foo(3.19"m") 
 pushvalue  off:4 size:2 descNo: -1
 -- assign:adr.store:A: 
 -- vassign:A: "A1 "off: 6 size: 2 mode: 0 
 vassign  6 2 0
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "A1.print "
 -- INV:gen: "A1.print " 
 -- needorigin: "A1.print " 
 -- needOrigin:E: "print "  E.ATd: 
 --  print:: 
 --     "SquareMeter".print
 --  Ex: "print " rec: "A1 " E.ATd: 
 --  print:: 
 --     "SquareMeter".print
 --  E.ATd.desc: ""SquareMeter".print " E.ATd.IT: "
 --  "SquareMeter".print " 
 -- doNeedOrigin:Ex: "print "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- origin:isValueObj: "SquareMeter "
 -- after:needOrigin: "print " 
 -- doNeedOrigin:E: "print " 
 -- computeAdrX:superAdj: 0 "A1.print " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "A1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "A1 " rec: "A1 " E: "print " 
 --  A.E: "A1 "
 --  
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A1":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "A1 " rec: "A1 " E: "print " 
 --  rec.ATd: "A1: var Area.SquareMeter " rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  %visible Dimensions
 --     %requires Dimensions.Area, Dimensions.Length, Dimensions.Mass, Dimensions.Energy, Dimensions.AngularAcceleration
 --     energyCombinations: 
 --        M: var Mass.KiloGram
 --  recA: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A1":rec:- 
 --  pRecA: none 
 -- pRec: "A1 " rec: "A1 " E: "print " 
 --  false true 
 -- computeAdrX:before:rec:: "A1 " 
 -- OI:invoke:before:ATdx.invoke: var A1 
 -- DI:invoke: "A1: var Area.SquareMeter " 
 -- isValueObj:isAdr: true objSize: 2  rec "A1 ",E: "print ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 -- Address:loadAdr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain "print " cmpAndSwap: false rec: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 -- computeAdrX:after:rec.invoke: "A1 " 
 -- computeAdrX:isLast:E:  "print "
 -- originIsValueObj: 
 --  %visible Dimensions
 --  %requires Dimensions.Area, Dimensions.Length, Dimensions.Mass, Dimensions.Energy, Dimensions.AngularAcceleration
 --  energyCombinations: 
 --     M: var Mass.KiloGram
 -- rec = E: false 0 
 -- call:mkValueProxy false true 
 -- mkValueProxy:INV: "A1.print " E: "print " rec: "A1 " E.ATd: 
 --  print:: 
 --     "SquareMeter".print
 --  
 -- CreateProxyW:E: "print "E.ATd.origin.encOG:OGid "SquareMeter "
 --  origin:descNo: 72 "Area ""A1.print " 
 --  rec.ATd: "A1: var Area.SquareMeter "rec.ATd.newOff: 6 0 
 rdouble 0
 -- son: "A1 " 
 -- son: "print " 
 -- recOfE: "A1 "recOfE.ATd: "A1: var Area.SquareMeter " 
 -- first: "Area "ObjectInvocation_Unary first.origin.encOG: "
 --  UnitIssues "
 -- items:goOrigin:encOG: "UnitIssues "on: 2 isValueObj: false 
 --  origin: workspace origin:isValueObj: false 
 rpushg UnitIssues$128 1
 -- items:goOrigin:encOG: "workspace "on: 1 isValueObj: false 
 --  origin: BETAworld origin:isValueObj: false 
 rpushg workspace$127 1
 rpushg LIB 3
 rpushg Dimensions 4
 -- after:Ey.loadOrigin: 
 -- Adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- Address:loadAdr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rpushg EisNone 3
 -- after:A.loadAdr 
 mkValueProxy 72 5
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 --  rec:  "A1 "E:  "print "
 -- INV:gen:E.loadArgs "print "
 -- INV:gen:after:E.loadArgs "print "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print "
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 rec: "A1 " 
 --  
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 invoke print 74 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- OI:invoke:V: adr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 -- INV:gen:end:off: 6 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 -- OG:before:super.gen: "newline "
 -- INV:gen: "newline " 
 -- needorigin: "newline " 
 -- needOrigin:E: "newline "  E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  Ex: "newline " rec: "newline " E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  E.ATd.desc: 
 --  %globals
 --  put(10)
 --  E.ATd.IT: 
 --  %globals
 --  put(10)
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %globals
 --     put(10)
 --  
 -- after:needOrigin: "newline " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "newline "E:  "newline "
 -- INV:gen:E.loadArgs "newline "
 -- INV:gen:after:E.loadArgs "newline "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "newline "
 -- OI:invoke:before:ATdx.invoke: pattern newline 
 -- ptn:invoke: "newline "E: "newline "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "newline " 
 --  adr:none 
 invoke newline 130 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- AssignmentStatement:gen: "A1 := foo(6"m") " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "A1 := foo(6"m") " right.label: "ObjectGenerator ""foo(6"m") " 
 -- OG:before:super.gen: "foo(6"m") "
 -- INV:gen: "foo(6"m") " 
 -- needorigin: "foo(6"m") " 
 -- needOrigin:E: "foo(6"m") "  E.ATd: 
 --  foo: 
 --     in L: var Length.Meter
 --     out A: var Area.SquareMeter
 --     A := Area.mult(L,L)
 --  Ex: "foo(6"m") " rec: "foo(6"m") " E.ATd: 
 --  foo: 
 --     in L: var Length.Meter
 --     out A: var Area.SquareMeter
 --     A := Area.mult(L,L)
 --  E.ATd.desc: 
 --  in L: var Length.Meter
 --  out A: var Area.SquareMeter
 --  A := Area.mult(L,L)
 --  E.ATd.IT: 
 --  in L: var Length.Meter
 --  out A: var Area.SquareMeter
 --  A := Area.mult(L,L)
 -- \
 --   
 -- doNeedOrigin:Ex: "foo(6"m") "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "foo(6"m") " 
 -- doNeedOrigin:E: "foo(6"m") " 
 -- computeAdrX:superAdj: 0 "foo(6"m") " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "foo(6"m") " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "foo(6"m") "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"foo(6"m")":rec:- 
 --  rec:  "foo(6"m") "E:  "foo(6"m") "
 -- INV:gen:E.loadArgs "foo(6"m") "
 -- NonVirt: "foo(6"m") " "ObjectInvocation_KeyWord " ActArg: "6"m" "
 --  isValue: true formalArg: "in L: var Length.Meter " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "foo(6"m") " isCompositeValueObj: 
 --  true 
 -- OG:before:super.gen: "6"m" "
 -- INV:gen: "6"m" " 
 -- needorigin: "6"m" " 
 -- needOrigin:E: "6"m" "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "6"m" " rec: "6"m" " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "6"m" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "6"m" "E:  "6"m" "
 -- INV:gen:E.loadArgs "6"m" "
 -- INV:gen:after:E.loadArgs "6"m" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "6"m" "
 pushc 6
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in L: var Length.Meter "
 --  :isBasicVal: false :valueObj: true 
 --  :actArg: "6"m" ":isBasicVal: true 
 -- case:A: "6"m" "form:isNonBasicValueObj: true act:isBasicValue: 
 --  true 
 i2f
 pushc 1
 -- end:loadArgs:NonVirt: "foo(6"m") "
 -- INV:gen:after:E.loadArgs "foo(6"m") "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "
 --  foo(6"m") "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"foo(6"m")":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern foo 
 -- ptn:invoke: "foo "E: "foo(6"m") "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "foo(6"m") " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"foo(6"m")":rec:foo(6"m") 
 invoke foo 132 0 0
 -- global:pushOut: A off: 4 
 -- callInvoke:after:pushOut: 4 
 -- GeneralPTN:invoke:after:callInvoke: 4 
 -- GeneralPTN:invoke:end: 4 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"foo(6"m")":rec:foo(6"m") 
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"foo(6"m")":rec:foo(6"m") 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"foo(6"m")":rec:foo(6"m") 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"foo(6"m")":rec:foo(6"m") 
 -- right.super.ATd:not:none 
 -- right.super.ATd.OG.super.ATD:none "ObjectGenerator "foo(6"m") 
 -- pushValue: A: off: 4 size: 5 descNo: -1 foo(6"m") 
 pushvalue  off:4 size:2 descNo: -1
 -- assign:adr.store:A: 
 -- vassign:A: "A1 "off: 6 size: 2 mode: 0 
 vassign  6 2 0
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "A1.print "
 -- INV:gen: "A1.print " 
 -- needorigin: "A1.print " 
 -- needOrigin:E: "print "  E.ATd: 
 --  print:: 
 --     "SquareMeter".print
 --  Ex: "print " rec: "A1 " E.ATd: 
 --  print:: 
 --     "SquareMeter".print
 --  E.ATd.desc: ""SquareMeter".print " E.ATd.IT: "
 --  "SquareMeter".print " 
 -- doNeedOrigin:Ex: "print "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- origin:isValueObj: "SquareMeter "
 -- after:needOrigin: "print " 
 -- doNeedOrigin:E: "print " 
 -- computeAdrX:superAdj: 0 "A1.print " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "A1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "A1 " rec: "A1 " E: "print " 
 --  A.E: "A1 "
 --  
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A1":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "A1 " rec: "A1 " E: "print " 
 --  rec.ATd: "A1: var Area.SquareMeter " rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  %visible Dimensions
 --     %requires Dimensions.Area, Dimensions.Length, Dimensions.Mass, Dimensions.Energy, Dimensions.AngularAcceleration
 --     energyCombinations: 
 --        M: var Mass.KiloGram
 --  recA: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A1":rec:- 
 --  pRecA: none 
 -- pRec: "A1 " rec: "A1 " E: "print " 
 --  false true 
 -- computeAdrX:before:rec:: "A1 " 
 -- OI:invoke:before:ATdx.invoke: var A1 
 -- DI:invoke: "A1: var Area.SquareMeter " 
 -- isValueObj:isAdr: true objSize: 2  rec "A1 ",E: "print ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 -- Address:loadAdr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain "print " cmpAndSwap: false rec: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 -- computeAdrX:after:rec.invoke: "A1 " 
 -- computeAdrX:isLast:E:  "print "
 -- originIsValueObj: 
 --  %visible Dimensions
 --  %requires Dimensions.Area, Dimensions.Length, Dimensions.Mass, Dimensions.Energy, Dimensions.AngularAcceleration
 --  energyCombinations: 
 --     M: var Mass.KiloGram
 -- rec = E: false 0 
 -- call:mkValueProxy false true 
 -- mkValueProxy:INV: "A1.print " E: "print " rec: "A1 " E.ATd: 
 --  print:: 
 --     "SquareMeter".print
 --  
 -- CreateProxyW:E: "print "E.ATd.origin.encOG:OGid "SquareMeter "
 --  origin:descNo: 72 "Area ""A1.print " 
 --  rec.ATd: "A1: var Area.SquareMeter "rec.ATd.newOff: 6 0 
 rdouble 0
 -- son: "A1 " 
 -- son: "print " 
 -- recOfE: "A1 "recOfE.ATd: "A1: var Area.SquareMeter " 
 -- first: "Area "ObjectInvocation_Unary first.origin.encOG: "
 --  UnitIssues "
 -- items:goOrigin:encOG: "UnitIssues "on: 2 isValueObj: false 
 --  origin: workspace origin:isValueObj: false 
 rpushg UnitIssues$128 1
 -- items:goOrigin:encOG: "workspace "on: 1 isValueObj: false 
 --  origin: BETAworld origin:isValueObj: false 
 rpushg workspace$127 1
 rpushg LIB 3
 rpushg Dimensions 4
 -- after:Ey.loadOrigin: 
 -- Adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- Address:loadAdr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rpushg EisNone 3
 -- after:A.loadAdr 
 mkValueProxy 72 5
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 --  rec:  "A1 "E:  "print "
 -- INV:gen:E.loadArgs "print "
 -- INV:gen:after:E.loadArgs "print "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print "
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 rec: "A1 " 
 --  
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 invoke print 74 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- OI:invoke:V: adr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 -- INV:gen:end:off: 6 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A1 
 -- OG:before:super.gen: "newline "
 -- INV:gen: "newline " 
 -- needorigin: "newline " 
 -- needOrigin:E: "newline "  E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  Ex: "newline " rec: "newline " E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  E.ATd.desc: 
 --  %globals
 --  put(10)
 --  E.ATd.IT: 
 --  %globals
 --  put(10)
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %globals
 --     put(10)
 --  
 -- after:needOrigin: "newline " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "newline "E:  "newline "
 -- INV:gen:E.loadArgs "newline "
 -- INV:gen:after:E.loadArgs "newline "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "newline "
 -- OI:invoke:before:ATdx.invoke: pattern newline 
 -- ptn:invoke: "newline "E: "newline "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "newline " 
 --  adr:none 
 invoke newline 130 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- AssignmentStatement:gen: "L2 := 5"m" " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "L2 := 5"m" " right.label: "ObjectGenerator ""5"m" " 
 -- OG:before:super.gen: "5"m" "
 -- INV:gen: "5"m" " 
 -- needorigin: "5"m" " 
 -- needOrigin:E: "5"m" "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "5"m" " rec: "5"m" " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "5"m" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "5"m" "E:  "5"m" "
 -- INV:gen:E.loadArgs "5"m" "
 -- INV:gen:after:E.loadArgs "5"m" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "5"m" "
 pushc 5
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 i2f
 -- assign:adr.store:A: 
 fstoreg 4 address:storeg
 -- assign:adr.store:B: 
 -- AssignmentStatement:gen: "L1 := mapi(L2) " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "L1 := mapi(L2) " right.label: "ObjectGenerator ""mapi(L2) " 
 -- OG:before:super.gen: "mapi(L2) "
 -- INV:gen: "mapi(L2) " 
 -- needorigin: "mapi(L2) " 
 -- needOrigin:E: "mapi(L2) "  E.ATd: 
 --  mapi(V: var integer) -> res: var integer: 
 --     res := V + V
 --  Ex: "mapi(L2) " rec: "mapi(L2) " E.ATd: 
 --  mapi(V: var integer) -> res: var integer: 
 --     res := V + V
 --  E.ATd.desc: "res := V + V " E.ATd.IT: "res := V + V " 
 -- doNeedOrigin:Ex: "mapi(L2) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "mapi(L2) " 
 -- doNeedOrigin:E: "mapi(L2) " 
 -- computeAdrX:superAdj: 0 "mapi(L2) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "mapi(L2) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "mapi(L2) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mapi(L2)":rec:- 
 --  rec:  "mapi(L2) "E:  "mapi(L2) "
 -- INV:gen:E.loadArgs "mapi(L2) "
 -- NonVirt: "mapi(L2) " "ObjectInvocation_KeyWord " ActArg: "L2 "
 --  isValue: true formalArg: "V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "mapi(L2) " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "L2 "
 -- INV:gen: "L2 " 
 -- needorigin: "L2 " 
 -- needOrigin:E: "L2 "  E.ATd: "L2: var Length.Meter " Ex: "L2 " 
 --  rec: "L2 " E.ATd: "L2: var Length.Meter " E.ATd.desc: 
 --  %unit "m", 1
 --  %Public
 --  thisUnit:: Meter
 --  argUnit:: MeterE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L2 " 
 -- doNeedOrigin:E: "L2 " 
 -- computeAdrX:superAdj: 0 "L2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "L2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 --  rec:  "L2 "E:  "L2 "
 -- INV:gen:E.loadArgs "L2 "
 -- INV:gen:after:E.loadArgs "L2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L2 "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- DI:invoke: "L2: var Length.Meter " 
 -- isValueObj:isAdr: false objSize: 2  rec "L2 ",E: "L2 ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- Address:loadAdr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:isUnitVal 
 fpushg 4 
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- before:pushSize:  actualArg.super.ATd.OG.isUnitValueObj: true 
 --  :actualArg.isCompositeValueObj: false 
 -- actualArg:UnitOne?: L2 
 -- end:loadArgs:NonVirt: "mapi(L2) "
 -- INV:gen:after:E.loadArgs "mapi(L2) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "mapi(L2) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mapi(L2)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern 
 --  mapi(V: var integer) -> res: var integer 
 -- ptn:invoke: "mapi(V: var integer) -> res: var integer "E: "
 --  mapi(L2) "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "mapi(L2) " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mapi(L2)":rec:mapi(L2) 
 f2i
 invoke mapi 134 0 0
 -- global:pushOut: res off: 3 
 pushg 3 
 -- callInvoke:after:pushOut: 3 
 -- GeneralPTN:invoke:after:callInvoke: 3 
 i2f
 -- GeneralPTN:invoke:end: 3 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mapi(L2)":rec:mapi(L2) 
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mapi(L2)":rec:mapi(L2) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mapi(L2)":rec:mapi(L2) 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mapi(L2)":rec:mapi(L2) 
 -- assign:adr.store:A: 
 fstoreg 2 address:storeg
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "L1.print "
 -- INV:gen: "L1.print " 
 -- needorigin: "L1.print " 
 -- needOrigin:E: "print "  E.ATd: 
 --  print:: 
 --     "Meter".print
 --  Ex: "print " rec: "L1 " E.ATd: 
 --  print:: 
 --     "Meter".print
 --  E.ATd.desc: ""Meter".print " E.ATd.IT: ""Meter".print " 
 -- doNeedOrigin:Ex: "print "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- origin:isValueObj: "Meter "
 -- after:needOrigin: "print " 
 -- doNeedOrigin:E: "print " 
 -- computeAdrX:superAdj: 0 "L1.print " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "L1 " rec: "L1 " E: "print " 
 --  A.E: "L1 "
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "L1 " rec: "L1 " E: "print " 
 --  rec.ATd: "L1: var Length.meter " rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  %visible Dimensions
 --     %requires Dimensions.Area, Dimensions.Length, Dimensions.Mass, Dimensions.Energy, Dimensions.AngularAcceleration
 --     energyCombinations: 
 --        M: var Mass.KiloGram
 --  recA: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 --  pRecA: none 
 -- pRec: "L1 " rec: "L1 " E: "print " 
 --  false true 
 -- computeAdrX:before:rec:: "L1 " 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- DI:invoke: "L1: var Length.meter " 
 -- isValueObj:isAdr: true objSize: 2  rec "L1 ",E: "print ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- Address:loadAdr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain "print " cmpAndSwap: false rec: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- computeAdrX:after:rec.invoke: "L1 " 
 -- computeAdrX:isLast:E:  "print "
 -- originIsValueObj: 
 --  %visible Dimensions
 --  %requires Dimensions.Area, Dimensions.Length, Dimensions.Mass, Dimensions.Energy, Dimensions.AngularAcceleration
 --  energyCombinations: 
 --     M: var Mass.KiloGram
 -- rec = E: false 0 
 -- call:mkValueProxy false true 
 -- mkValueProxy:INV: "L1.print " E: "print " rec: "L1 " E.ATd: 
 --  print:: 
 --     "Meter".print
 --  
 -- CreateProxyW:E: "print "E.ATd.origin.encOG:OGid "Meter "
 --  origin:descNo: 91 "Length ""L1.print " 
 --  rec.ATd: "L1: var Length.meter "rec.ATd.newOff: 2 0 
 rdouble 0
 -- son: "L1 " 
 -- son: "print " 
 -- recOfE: "L1 "recOfE.ATd: "L1: var Length.meter " 
 -- first: "Length "ObjectInvocation_Unary first.origin.encOG: "
 --  UnitIssues "
 -- items:goOrigin:encOG: "UnitIssues "on: 2 isValueObj: false 
 --  origin: workspace origin:isValueObj: false 
 rpushg UnitIssues$128 1
 -- items:goOrigin:encOG: "workspace "on: 1 isValueObj: false 
 --  origin: BETAworld origin:isValueObj: false 
 rpushg workspace$127 1
 rpushg LIB 3
 rpushg Dimensions 4
 -- after:Ey.loadOrigin: 
 -- Adr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- Address:loadAdr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rpushg EisNone 6
 -- after:A.loadAdr 
 mkValueProxy 91 1
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 --  rec:  "L1 "E:  "print "
 -- INV:gen:E.loadArgs "print "
 -- INV:gen:after:E.loadArgs "print "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 rec: "L1 " 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 invoke print 97 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- OG:before:super.gen: "newline "
 -- INV:gen: "newline " 
 -- needorigin: "newline " 
 -- needOrigin:E: "newline "  E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  Ex: "newline " rec: "newline " E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  E.ATd.desc: 
 --  %globals
 --  put(10)
 --  E.ATd.IT: 
 --  %globals
 --  put(10)
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %globals
 --     put(10)
 --  
 -- after:needOrigin: "newline " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "newline "E:  "newline "
 -- INV:gen:E.loadArgs "newline "
 -- INV:gen:after:E.loadArgs "newline "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "newline "
 -- OI:invoke:before:ATdx.invoke: pattern newline 
 -- ptn:invoke: "newline "E: "newline "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "newline " 
 --  adr:none 
 invoke newline 130 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- AssignmentStatement:gen: "L2 := 6"m" " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "L2 := 6"m" " right.label: "ObjectGenerator ""6"m" " 
 -- OG:before:super.gen: "6"m" "
 -- INV:gen: "6"m" " 
 -- needorigin: "6"m" " 
 -- needOrigin:E: "6"m" "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "6"m" " rec: "6"m" " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "6"m" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "6"m" "E:  "6"m" "
 -- INV:gen:E.loadArgs "6"m" "
 -- INV:gen:after:E.loadArgs "6"m" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "6"m" "
 pushc 6
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 i2f
 -- assign:adr.store:A: 
 fstoreg 4 address:storeg
 -- assign:adr.store:B: 
 -- AssignmentStatement:gen: "L1 := mapf(L2) " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "L1 := mapf(L2) " right.label: "ObjectGenerator ""mapf(L2) " 
 -- OG:before:super.gen: "mapf(L2) "
 -- INV:gen: "mapf(L2) " 
 -- needorigin: "mapf(L2) " 
 -- needOrigin:E: "mapf(L2) "  E.ATd: 
 --  mapf(V: var float) -> res: var float: 
 --     res := V + V
 --  Ex: "mapf(L2) " rec: "mapf(L2) " E.ATd: 
 --  mapf(V: var float) -> res: var float: 
 --     res := V + V
 --  E.ATd.desc: "res := V + V " E.ATd.IT: "res := V + V " 
 -- doNeedOrigin:Ex: "mapf(L2) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "mapf(L2) " 
 -- doNeedOrigin:E: "mapf(L2) " 
 -- computeAdrX:superAdj: 0 "mapf(L2) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "mapf(L2) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "mapf(L2) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mapf(L2)":rec:- 
 --  rec:  "mapf(L2) "E:  "mapf(L2) "
 -- INV:gen:E.loadArgs "mapf(L2) "
 -- NonVirt: "mapf(L2) " "ObjectInvocation_KeyWord " ActArg: "L2 "
 --  isValue: true formalArg: "V: var float " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "mapf(L2) " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "L2 "
 -- INV:gen: "L2 " 
 -- needorigin: "L2 " 
 -- needOrigin:E: "L2 "  E.ATd: "L2: var Length.Meter " Ex: "L2 " 
 --  rec: "L2 " E.ATd: "L2: var Length.Meter " E.ATd.desc: 
 --  %unit "m", 1
 --  %Public
 --  thisUnit:: Meter
 --  argUnit:: MeterE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L2 " 
 -- doNeedOrigin:E: "L2 " 
 -- computeAdrX:superAdj: 0 "L2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "L2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 --  rec:  "L2 "E:  "L2 "
 -- INV:gen:E.loadArgs "L2 "
 -- INV:gen:after:E.loadArgs "L2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L2 "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- DI:invoke: "L2: var Length.Meter " 
 -- isValueObj:isAdr: false objSize: 2  rec "L2 ",E: "L2 ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- Address:loadAdr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:isUnitVal 
 fpushg 4 
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- before:pushSize:  actualArg.super.ATd.OG.isUnitValueObj: true 
 --  :actualArg.isCompositeValueObj: false 
 -- actualArg:UnitOne?: L2 
 -- end:loadArgs:NonVirt: "mapf(L2) "
 -- INV:gen:after:E.loadArgs "mapf(L2) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "mapf(L2) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mapf(L2)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern 
 --  mapf(V: var float) -> res: var float 
 -- ptn:invoke: "mapf(V: var float) -> res: var float "E: "mapf(L2) "
 --  ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "mapf(L2) " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mapf(L2)":rec:mapf(L2) 
 invoke mapf 135 0 0
 -- global:pushOut: res off: 4 
 fpushg 4 
 -- callInvoke:after:pushOut: 4 
 -- GeneralPTN:invoke:after:callInvoke: 4 
 -- GeneralPTN:invoke:end: 4 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mapf(L2)":rec:mapf(L2) 
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mapf(L2)":rec:mapf(L2) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mapf(L2)":rec:mapf(L2) 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mapf(L2)":rec:mapf(L2) 
 -- assign:adr.store:A: 
 fstoreg 2 address:storeg
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "L1.print "
 -- INV:gen: "L1.print " 
 -- needorigin: "L1.print " 
 -- needOrigin:E: "print "  E.ATd: 
 --  print:: 
 --     "Meter".print
 --  Ex: "print " rec: "L1 " E.ATd: 
 --  print:: 
 --     "Meter".print
 --  E.ATd.desc: ""Meter".print " E.ATd.IT: ""Meter".print " 
 -- doNeedOrigin:Ex: "print "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- origin:isValueObj: "Meter "
 -- after:needOrigin: "print " 
 -- doNeedOrigin:E: "print " 
 -- computeAdrX:superAdj: 0 "L1.print " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "L1 " rec: "L1 " E: "print " 
 --  A.E: "L1 "
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "L1 " rec: "L1 " E: "print " 
 --  rec.ATd: "L1: var Length.meter " rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  %visible Dimensions
 --     %requires Dimensions.Area, Dimensions.Length, Dimensions.Mass, Dimensions.Energy, Dimensions.AngularAcceleration
 --     energyCombinations: 
 --        M: var Mass.KiloGram
 --  recA: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 --  pRecA: none 
 -- pRec: "L1 " rec: "L1 " E: "print " 
 --  false true 
 -- computeAdrX:before:rec:: "L1 " 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- DI:invoke: "L1: var Length.meter " 
 -- isValueObj:isAdr: true objSize: 2  rec "L1 ",E: "print ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- Address:loadAdr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain "print " cmpAndSwap: false rec: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- computeAdrX:after:rec.invoke: "L1 " 
 -- computeAdrX:isLast:E:  "print "
 -- originIsValueObj: 
 --  %visible Dimensions
 --  %requires Dimensions.Area, Dimensions.Length, Dimensions.Mass, Dimensions.Energy, Dimensions.AngularAcceleration
 --  energyCombinations: 
 --     M: var Mass.KiloGram
 -- rec = E: false 0 
 -- call:mkValueProxy false true 
 -- mkValueProxy:INV: "L1.print " E: "print " rec: "L1 " E.ATd: 
 --  print:: 
 --     "Meter".print
 --  
 -- CreateProxyW:E: "print "E.ATd.origin.encOG:OGid "Meter "
 --  origin:descNo: 91 "Length ""L1.print " 
 --  rec.ATd: "L1: var Length.meter "rec.ATd.newOff: 2 0 
 rdouble 0
 -- son: "L1 " 
 -- son: "print " 
 -- recOfE: "L1 "recOfE.ATd: "L1: var Length.meter " 
 -- first: "Length "ObjectInvocation_Unary first.origin.encOG: "
 --  UnitIssues "
 -- items:goOrigin:encOG: "UnitIssues "on: 2 isValueObj: false 
 --  origin: workspace origin:isValueObj: false 
 rpushg UnitIssues$128 1
 -- items:goOrigin:encOG: "workspace "on: 1 isValueObj: false 
 --  origin: BETAworld origin:isValueObj: false 
 rpushg workspace$127 1
 rpushg LIB 3
 rpushg Dimensions 4
 -- after:Ey.loadOrigin: 
 -- Adr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- Address:loadAdr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rpushg EisNone 6
 -- after:A.loadAdr 
 mkValueProxy 91 1
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 --  rec:  "L1 "E:  "print "
 -- INV:gen:E.loadArgs "print "
 -- INV:gen:after:E.loadArgs "print "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 rec: "L1 " 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 invoke print 97 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- OG:before:super.gen: "newline "
 -- INV:gen: "newline " 
 -- needorigin: "newline " 
 -- needOrigin:E: "newline "  E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  Ex: "newline " rec: "newline " E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  E.ATd.desc: 
 --  %globals
 --  put(10)
 --  E.ATd.IT: 
 --  %globals
 --  put(10)
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %globals
 --     put(10)
 --  
 -- after:needOrigin: "newline " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "newline "E:  "newline "
 -- INV:gen:E.loadArgs "newline "
 -- INV:gen:after:E.loadArgs "newline "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "newline "
 -- OI:invoke:before:ATdx.invoke: pattern newline 
 -- ptn:invoke: "newline "E: "newline "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "newline " 
 --  adr:none 
 invoke newline 130 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- OG:before:super.gen: "energyCombinations "
 -- INV:gen: "energyCombinations " 
 -- needorigin: "energyCombinations " 
 -- needOrigin:E: "energyCombinations "  E.ATd: 
 --  energyCombinations: 
 --     M: var Mass.KiloGram
 --     A: var Area.SquareMeter
 --     R: var AngularAcceleration.RadiansPerSecondSquaredEx: "energyCombinations " rec: "energyCombinations " E.ATd: 
 --  energyCombinations: 
 --     M: var Mass.KiloGram
 --     A: var Area.SquareMeter
 --     R: var AngularAcceleration.RadiansPerSecondSquaredE.ATd.desc: 
 --  M: var Mass.KiloGram
 --  A: var Area.SquareMeter
 --  R: var AngularAcceleration.RadiansPerSecondSquared
 --  X: var Energy.JouleE.ATd.IT: 
 --  M: var Mass.KiloGram
 --  A: var Area.SquareMeter
 --  R: var AngularAcceleration.RadiansPerSecondSquared
 --  X: var Energy.Joule
 -- doNeedOrigin:Ex: "energyCombinations "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "energyCombinations " 
 -- doNeedOrigin:E: "energyCombinations " 
 -- computeAdrX:superAdj: 0 "energyCombinations " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "energyCombinations " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "energyCombinations "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"energyCombinations":rec:- 
 --  rec:  "energyCombinations "E:  "energyCombinations "
 -- INV:gen:E.loadArgs "energyCombinations "
 -- INV:gen:after:E.loadArgs "energyCombinations "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "
 --  energyCombinations "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"energyCombinations":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern energyCombinations 
 -- ptn:invoke: "energyCombinations "E: "energyCombinations "
 --  ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "
 --  energyCombinations " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"energyCombinations":rec:energyCombinations 
 invoke energyCombinations 137 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"energyCombinations":rec:energyCombinations 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"energyCombinations":rec:energyCombinations 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"energyCombinations":rec:energyCombinations 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:14 isIndexed:0

 CLASS newline 130 0 BETA 2
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "put(10) "
 -- INV:gen: "put(10) " 
 -- needorigin: "put(10) " 
 -- needOrigin:E: "put(10) "  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put(10) " rec: "put(10) " E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  E.ATd.desc: 
 --  %globals
 --  %basic 2
 --  in ch: val char
 --  E.ATd.IT: 
 --  %globals
 --  %basic 2
 --  in ch: val char
 -- \
 --   
 -- Ex:loadOrgin:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put(10) " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put(10) "E:  "put(10) "
 -- INV:gen:E.loadArgs "put(10) "
 -- NonVirt: "put(10) " "ObjectInvocation_KeyWord " ActArg: "10 "
 --  isValue: true formalArg: "in ch: val char " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(10) " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "10 "
 -- INV:gen: "10 " 
 -- needorigin: "10 " 
 -- needOrigin:E: "10 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "10 " rec: "10 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "10 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "10 "E:  "10 "
 -- INV:gen:E.loadArgs "10 "
 -- INV:gen:after:E.loadArgs "10 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "10 "
 pushc 10
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "10 ":isBasicVal: true 
 -- case:B: 10 ObjectGenerator 3 1 1 false true 
 -- end:loadArgs:NonVirt: "put(10) "
 -- INV:gen:after:E.loadArgs "put(10) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(10) "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put(10) "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:0 isIndexed:0

 CLASS foo 132 1 UnitIssues 128
 jmpFalse  L3
 pushThis 
 -- vassign:B: L off: 2 size: 2 mode: 0 
 vassign  2 2 0
 jmp L4
 L3:
 invokeVal  L 91 1
 rpop 
 L4:
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in L: var Length.Meter " DI:isConst: false 
 --  isBasicValue: false primNo: 0 
 -- DI:isConst: L 
 -- inArg: in L: var Length.Meter 
 -- DI:gen: "out A: var Area.SquareMeter " DI:isConst: false 
 --  isBasicValue: false primNo: 0 
 -- DI:isConst: A 
 -- DI:off: 4 this: "out A: var Area.SquareMeter " 
 --  
 -- OG:before:super.gen: "Area.SquareMeter "
 -- INV:gen: "Area.SquareMeter " 
 -- needorigin: "Area.SquareMeter " 
 -- needOrigin:E: "SquareMeter "  E.ATd: 
 --  SquareMeter: Unit
 --     %unit "m2", 1
 --     %Public
 --     thisUnit:: SquareMeterEx: "SquareMeter " rec: "Area " E.ATd: 
 --  SquareMeter: Unit
 --     %unit "m2", 1
 --     %Public
 --     thisUnit:: SquareMeterE.ATd.desc: 
 --  %unit "m2", 1
 --  %Public
 --  thisUnit:: SquareMeter
 --  print:: E.ATd.IT: 
 --  %unit "m2", 1
 --  %Public
 --  thisUnit:: SquareMeter
 --  print:: 
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Unit
 --     %unit "m2", 1
 --     %Public
 --     thisUnit:: SquareMeter
 -- after:needOrigin: "SquareMeter " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "Area "E:  "SquareMeter "
 -- INV:gen:E.loadArgs "SquareMeter "
 -- INV:gen:after:E.loadArgs "SquareMeter "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "
 --  SquareMeter "
 -- OI:invoke:before:ATdx.invoke: pattern SquareMeter 
 -- ptn:invoke: "SquareMeter "E: "SquareMeter "ptnKind: 0 useRtnV: 
 --  false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 4 rec: "Area " 
 --  adr:none 
 invokeVal  SquareMeter 72 3
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "A := Area.mult(L,L) " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "A := Area.mult(L,L) " right.label: "ObjectGenerator ""
 --  Area.mult(L,L) " 
 -- OG:before:super.gen: "Area.mult(L,L) "
 -- INV:gen: "Area.mult(L,L) " 
 -- needorigin: "Area.mult(L,L) " 
 -- needOrigin:E: "mult(L,L) "  E.ATd: 
 --  mult: 
 --     in A: var Length.Meter
 --     in B: var Length.Meter
 --     out R: var squareMeterEx: "mult(L,L) " rec: "Area " E.ATd: 
 --  mult: 
 --     in A: var Length.Meter
 --     in B: var Length.Meter
 --     out R: var squareMeterE.ATd.desc: 
 --  in A: var Length.Meter
 --  in B: var Length.Meter
 --  out R: var squareMeter
 --  R.magnitude := A.magnitude * B.magnitude
 --  E.ATd.IT: 
 --  in A: var Length.Meter
 --  in B: var Length.Meter
 --  out R: var squareMeter
 --  R.magnitude := A.magnitude * B.magnitude
 -- \
 --   
 -- doNeedOrigin:Ex: "mult(L,L) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "mult(L,L) " 
 -- doNeedOrigin:E: "mult(L,L) " 
 -- computeAdrX:superAdj: 0 "Area.mult(L,L) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Area " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "foo "on: 1 isValueObj: false 
 --  origin: UnitIssues origin:isValueObj: false 
 rpushg foo$132 1
 -- items:goOrigin:encOG: "UnitIssues "on: 2 isValueObj: false 
 --  origin: workspace origin:isValueObj: false 
 rpushg UnitIssues$128 1
 -- items:goOrigin:encOG: "workspace "on: 1 isValueObj: false 
 --  origin: BETAworld origin:isValueObj: false 
 rpushg workspace$127 1
 rpushg LIB 3
 rpushg Dimensions 4
 -- computeAdrX:En: 2 pRec: "Area " rec: "Area " E: "mult(L,L) " 
 --  A.E: none 
 --  
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "Area " rec: "Area " E: "
 --  mult(L,L) " 
 --  rec.ATd: 
 --  --Area
 --  rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  %domain_boundary
 --     %public
 --     Dimension: 
 --        %dimension "-top-"
 --  recA: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(L,L)":rec:- 
 --  pRecA: none 
 -- pRec: "Area " rec: "Area " E: "mult(L,L) " 
 --  false false 
 -- computeAdrX:before:rec:: "Area " 
 -- OI:invoke:before:ATdx.invoke: ModuleItem Area 
 rpushg Area 3
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(L,L)":rec:Area 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(L,L)":rec:Area 
 -- computeAdrX:after:rec.invoke: "Area " 
 -- computeAdrX:isLast:E:  "mult(L,L) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(L,L)":rec:Area 
 --  rec:  "Area "E:  "mult(L,L) "
 -- INV:gen:E.loadArgs "mult(L,L) "
 -- NonVirt: "mult(L,L) " "ObjectInvocation_Function " ActArg: "L "
 --  isValue: true formalArg: "in A: var Length.Meter " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "mult(L,L) " isCompositeValueObj: 
 --  true 
 -- OG:before:super.gen: "L "
 -- INV:gen: "L " 
 -- needorigin: "L " 
 -- needOrigin:E: "L "  E.ATd: "in L: var Length.Meter " Ex: "L " 
 --  rec: "L " E.ATd: "in L: var Length.Meter " E.ATd.desc: 
 --  %unit "m", 1
 --  %Public
 --  thisUnit:: Meter
 --  argUnit:: MeterE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L " 
 -- doNeedOrigin:E: "L " 
 -- computeAdrX:superAdj: 0 "L " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "L "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 --  rec:  "L "E:  "L "
 -- INV:gen:E.loadArgs "L "
 -- INV:gen:after:E.loadArgs "L "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- DI:invoke: "in L: var Length.Meter " 
 -- isValueObj:isAdr: false objSize: 2  rec "L ",E: "L ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: true 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- Address:loadAdr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain "L " cmpAndSwap: false rec: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- before:pushSize:  actualArg.super.ATd.OG.isUnitValueObj: true 
 --  :actualArg.isCompositeValueObj: true 
 -- composite:valueObj:or:not:unitValue  OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 pushvalue  off:2 size:2 descNo: 91
 pushc 1
 -- end:loadArgs:NonVirt: "mult(L,L) "
 -- NonVirt: "mult(L,L) " "ObjectInvocation_Function " ActArg: "L "
 --  isValue: true formalArg: "in B: var Length.Meter " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "mult(L,L) " isCompositeValueObj: 
 --  true 
 -- OG:before:super.gen: "L "
 -- INV:gen: "L " 
 -- needorigin: "L " 
 -- needOrigin:E: "L "  E.ATd: "in L: var Length.Meter " Ex: "L " 
 --  rec: "L " E.ATd: "in L: var Length.Meter " E.ATd.desc: 
 --  %unit "m", 1
 --  %Public
 --  thisUnit:: Meter
 --  argUnit:: MeterE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L " 
 -- doNeedOrigin:E: "L " 
 -- computeAdrX:superAdj: 0 "L " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "L "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 --  rec:  "L "E:  "L "
 -- INV:gen:E.loadArgs "L "
 -- INV:gen:after:E.loadArgs "L "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- DI:invoke: "in L: var Length.Meter " 
 -- isValueObj:isAdr: false objSize: 2  rec "L ",E: "L ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: true 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- Address:loadAdr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain "L " cmpAndSwap: false rec: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- before:pushSize:  actualArg.super.ATd.OG.isUnitValueObj: true 
 --  :actualArg.isCompositeValueObj: true 
 -- composite:valueObj:or:not:unitValue  OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 pushvalue  off:2 size:2 descNo: 91
 pushc 1
 -- end:loadArgs:NonVirt: "mult(L,L) "
 -- INV:gen:after:E.loadArgs "mult(L,L) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Function "
 --  mult(L,L) "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(L,L)":rec:Area 
 -- OI:invoke:before:ATdx.invoke: pattern mult 
 -- ptn:invoke: "mult "E: "mult(L,L) "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "Area " 
 --  
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(L,L)":rec:Area 
 invoke mult 133 0 0
 -- global:pushOut: R off: 6 
 -- callInvoke:after:pushOut: 6 
 -- GeneralPTN:invoke:after:callInvoke: 6 
 -- GeneralPTN:invoke:end: 6 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(L,L)":rec:Area 
 -- OI:invoke:V: adr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(L,L)":rec:Area 
 -- OI:invoke:X: adr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(L,L)":rec:Area 
 -- INV:gen:end:off: 6 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(L,L)":rec:Area 
 -- right.super.ATd:not:none 
 -- right.super.ATd.OG.super.ATD:none "ObjectGenerator "
 --  Area.mult(L,L) 
 -- pushValue: A: off: 6 size: 7 descNo: -1 Area.mult(L,L) 
 pushvalue  off:6 size:2 descNo: -1
 -- assign:adr.store:A: 
 -- vassign:A: "A "off: 4 size: 2 mode: 0 
 vassign  4 2 0
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0

 CLASS mult 133 1 Area 70
 jmpFalse  L3
 pushThis 
 -- vassign:B: B off: 4 size: 2 mode: 0 
 vassign  4 2 0
 jmp L4
 L3:
 invokeVal  B 91 3
 rpop 
 L4:
 jmpFalse  L5
 pushThis 
 -- vassign:B: A off: 2 size: 2 mode: 0 
 vassign  2 2 0
 jmp L6
 L5:
 invokeVal  A 91 1
 rpop 
 L6:
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in A: var Length.Meter " DI:isConst: false 
 --  isBasicValue: false primNo: 0 
 -- DI:isConst: A 
 -- inArg: in A: var Length.Meter 
 -- DI:gen: "in B: var Length.Meter " DI:isConst: false 
 --  isBasicValue: false primNo: 0 
 -- DI:isConst: B 
 -- inArg: in B: var Length.Meter 
 -- DI:gen: "out R: var squareMeter " DI:isConst: false 
 --  isBasicValue: false primNo: 0 
 -- DI:isConst: R 
 -- DI:off: 6 this: "out R: var squareMeter " 
 --  
 -- OG:before:super.gen: "squareMeter "
 -- INV:gen: "squareMeter " 
 -- needorigin: "squareMeter " 
 -- needOrigin:E: "squareMeter "  E.ATd: 
 --  SquareMeter: Unit
 --     %unit "m2", 1
 --     %Public
 --     thisUnit:: SquareMeterEx: "squareMeter " rec: "squareMeter " E.ATd: 
 --  SquareMeter: Unit
 --     %unit "m2", 1
 --     %Public
 --     thisUnit:: SquareMeterE.ATd.desc: 
 --  %unit "m2", 1
 --  %Public
 --  thisUnit:: SquareMeter
 --  print:: E.ATd.IT: 
 --  %unit "m2", 1
 --  %Public
 --  thisUnit:: SquareMeter
 --  print:: 
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Unit
 --     %unit "m2", 1
 --     %Public
 --     thisUnit:: SquareMeter
 -- after:needOrigin: "squareMeter " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "squareMeter "E:  "squareMeter "
 -- INV:gen:E.loadArgs "squareMeter "
 -- INV:gen:after:E.loadArgs "squareMeter "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "
 --  squareMeter "
 -- OI:invoke:before:ATdx.invoke: pattern SquareMeter 
 -- ptn:invoke: "SquareMeter "E: "squareMeter "ptnKind: 0 useRtnV: 
 --  false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 6 rec: "squareMeter " 
 --  adr:none 
 invokeVal  SquareMeter 72 5
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "
 --  R.magnitude := A.magnitude * B.magnitude " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "R.magnitude := A.magnitude * B.magnitude " right.label: "
 --  ObjectGenerator ""A.magnitude * B.magnitude " 
 -- OG:before:super.gen: "A.magnitude * B.magnitude "
 -- INV:gen: "A.magnitude * B.magnitude " 
 -- needorigin: "A.magnitude * B.magnitude " 
 -- needOrigin:E: "A.magnitude * B.magnitude "  E.ATd: 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  Ex: "A.magnitude * B.magnitude " rec: "
 --  A.magnitude * B.magnitude " E.ATd: 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  E.ATd.desc: 
 --  %basic 112
 --  in V: var float
 --  out R: var float
 --  E.ATd.IT: 
 --  %basic 112
 --  in V: var float
 -- \
 --   out R: var float
 --  
 -- doNeedOrigin:Ex: "A.magnitude * B.magnitude "originIsValueObj: 
 --  true origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "A.magnitude * B.magnitude " 
 -- doNeedOrigin:E: "A.magnitude * B.magnitude " 
 -- computeAdrX:superAdj: 0 "A.magnitude * B.magnitude " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "
 --  A.magnitude * B.magnitude " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "A.magnitude * B.magnitude "
 --  superAdj: 0 
 -- computeAdrX:isLast:E:  "A.magnitude * B.magnitude "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "A.magnitude * B.magnitude "E:  "A.magnitude * B.magnitude "
 -- INV:gen:E.loadArgs "A.magnitude * B.magnitude "
 -- BinaryExp:loadArgs: "A.magnitude * B.magnitude " superAdj: 0 
 -- INV:gen: "A.magnitude " 
 -- needorigin: "A.magnitude " 
 -- needOrigin:E: "magnitude "  E.ATd: "magnitude: var Float " Ex: 
 --  none rec: "A " E.ATd: "magnitude: var Float " E.ATd.desc: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "magnitude " 
 -- doNeedOrigin:E: "magnitude " 
 -- computeAdrX:superAdj: 0 "A.magnitude " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "A " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "A " rec: "A " E: "magnitude " 
 --  A.E: "A "
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- computeAdrX:isLast:E:  "magnitude "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 --  rec:  "A "E:  "magnitude "
 -- INV:gen:E.loadArgs "magnitude "
 -- INV:gen:after:E.loadArgs "magnitude "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude "
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- DI:invoke: "magnitude: var Float " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:A isNotRemote: false 
 fpushg 2 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:A 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:A 
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:A 
 -- NonVirt: "* B.magnitude " "ObjectInvocation_Binary " ActArg: "
 --  B.magnitude "isValue: false formalArg: "in V: var float " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- OG:before:super.gen: "B.magnitude "
 -- INV:gen: "B.magnitude " 
 -- needorigin: "B.magnitude " 
 -- needOrigin:E: "magnitude "  E.ATd: "magnitude: var Float " Ex: 
 --  none rec: "B " E.ATd: "magnitude: var Float " E.ATd.desc: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "magnitude " 
 -- doNeedOrigin:E: "magnitude " 
 -- computeAdrX:superAdj: 0 "B.magnitude " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "B " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "B " rec: "B " E: "magnitude " 
 --  A.E: "B "
 --  
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- computeAdrX:isLast:E:  "magnitude "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 --  rec:  "B "E:  "magnitude "
 -- INV:gen:E.loadArgs "magnitude "
 -- INV:gen:after:E.loadArgs "magnitude "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude "
 --  :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- DI:invoke: "magnitude: var Float " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:B isNotRemote: false 
 fpushg 4 
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:B 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:B 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:B 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var float "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "B.magnitude ":isBasicVal: true 
 -- case:B: B.magnitude ObjectGenerator 9 0 9 false false 
 -- end:loadArgs:NonVirt: "* B.magnitude "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:A 
 -- INV:gen:after:E.loadArgs "A.magnitude * B.magnitude "
 --  OIadr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:A 
 -- IV:E.invoke:useRtnVal: true E: BinOp "A.magnitude * B.magnitude "
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:A 
 -- BinaryExp:invoke: "A.magnitude "rec: "A.magnitude * B.magnitude "
 -- M: "* B.magnitude "
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:A 
 -- OI:invoke:before:ATdx.invoke: pattern *   
 -- ptn:invoke: "*   "E: "* B.magnitude "ptnKind: 0 useRtnV: true 
 fmult
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* B.magnitude":rec:A.magnitude 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* B.magnitude":rec:A.magnitude 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 fstoreg 6 address:storeg
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:7 isIndexed:0

 CLASS mapi 134 1 UnitIssues 128
 pushThis 
 storeg integer$5 2
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "res := V + V " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "res := V + V " right.label: "ObjectGenerator ""V + V " 
 -- OG:before:super.gen: "V + V "
 -- INV:gen: "V + V " 
 -- needorigin: "V + V " 
 -- needOrigin:E: "V + V "  E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  Ex: "V + V " rec: "V + V " E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  E.ATd.desc: 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 --  E.ATd.IT: 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 -- \
 --   
 -- doNeedOrigin:Ex: "V + V "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "V + V " 
 -- doNeedOrigin:E: "V + V " 
 -- computeAdrX:superAdj: 0 "V + V " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "V + V " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "V + V "superAdj: 0 
 -- computeAdrX:isLast:E:  "V + V "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "V + V "E:  "V + V "
 -- INV:gen:E.loadArgs "V + V "
 -- BinaryExp:loadArgs: "V + V " superAdj: 0 
 -- INV:gen: "V " 
 -- needorigin: "V " 
 -- needOrigin:E: "V "  E.ATd: "V: var integer " Ex: "V " rec: "V " 
 --  E.ATd: "V: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "V " 
 -- doNeedOrigin:E: "V " 
 -- computeAdrX:superAdj: 0 "V " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "V " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "V "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 --  rec:  "V "E:  "V "
 -- INV:gen:E.loadArgs "V "
 -- INV:gen:after:E.loadArgs "V "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "V "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- OI:invoke:before:ATdx.invoke: var V 
 -- DI:invoke: "V: var integer " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V isNotRemote: true 
 pushg 2 mapi$134
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- NonVirt: "+ V " "ObjectInvocation_Binary " ActArg: "V "isValue: 
 --  false formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ V " isCompositeValueObj: false 
 -- OG:before:super.gen: "V "
 -- INV:gen: "V " 
 -- needorigin: "V " 
 -- needOrigin:E: "V "  E.ATd: "V: var integer " Ex: "V " rec: "V " 
 --  E.ATd: "V: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "V " 
 -- doNeedOrigin:E: "V " 
 -- computeAdrX:superAdj: 0 "V " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "V " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "V "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 --  rec:  "V "E:  "V "
 -- INV:gen:E.loadArgs "V "
 -- INV:gen:after:E.loadArgs "V "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "V "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- OI:invoke:before:ATdx.invoke: var V 
 -- DI:invoke: "V: var integer " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V isNotRemote: true 
 pushg 2 mapi$134
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "V ":isBasicVal: true 
 -- case:B: V ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "+ V "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- INV:gen:after:E.loadArgs "V + V "
 --  OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- IV:E.invoke:useRtnVal: true E: BinOp "V + V "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- BinaryExp:invoke: "V "rec: "V + V "
 -- M: "+ V "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- ptn:invoke: "+   "E: "+ V "ptnKind: 0 useRtnV: true 
 plus
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ V":rec:V 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ V":rec:V 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg mapi$134 3
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS mapf 135 1 UnitIssues 128
 pushThis 
 fstoreg 2 V
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "res := V + V " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "res := V + V " right.label: "ObjectGenerator ""V + V " 
 -- OG:before:super.gen: "V + V "
 -- INV:gen: "V + V " 
 -- needorigin: "V + V " 
 -- needOrigin:E: "V + V "  E.ATd: 
 --  +  : 
 --     %basic 109
 --     in V: var float
 --     out R: var float
 --  Ex: "V + V " rec: "V + V " E.ATd: 
 --  +  : 
 --     %basic 109
 --     in V: var float
 --     out R: var float
 --  E.ATd.desc: 
 --  %basic 109
 --  in V: var float
 --  out R: var float
 --  E.ATd.IT: 
 --  %basic 109
 --  in V: var float
 --  out R: var float
 -- \
 --   
 -- doNeedOrigin:Ex: "V + V "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "V + V " 
 -- doNeedOrigin:E: "V + V " 
 -- computeAdrX:superAdj: 0 "V + V " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "V + V " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "V + V "superAdj: 0 
 -- computeAdrX:isLast:E:  "V + V "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "V + V "E:  "V + V "
 -- INV:gen:E.loadArgs "V + V "
 -- BinaryExp:loadArgs: "V + V " superAdj: 0 
 -- INV:gen: "V " 
 -- needorigin: "V " 
 -- needOrigin:E: "V "  E.ATd: "V: var float " Ex: "V " rec: "V " 
 --  E.ATd: "V: var float " E.ATd.desc: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "V " 
 -- doNeedOrigin:E: "V " 
 -- computeAdrX:superAdj: 0 "V " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "V " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "V "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 --  rec:  "V "E:  "V "
 -- INV:gen:E.loadArgs "V "
 -- INV:gen:after:E.loadArgs "V "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "V "
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- OI:invoke:before:ATdx.invoke: var V 
 -- DI:invoke: "V: var float " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V isNotRemote: true 
 fpushg 2 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- NonVirt: "+ V " "ObjectInvocation_Binary " ActArg: "V "isValue: 
 --  false formalArg: "in V: var float " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ V " isCompositeValueObj: false 
 -- OG:before:super.gen: "V "
 -- INV:gen: "V " 
 -- needorigin: "V " 
 -- needOrigin:E: "V "  E.ATd: "V: var float " Ex: "V " rec: "V " 
 --  E.ATd: "V: var float " E.ATd.desc: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "V " 
 -- doNeedOrigin:E: "V " 
 -- computeAdrX:superAdj: 0 "V " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "V " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "V "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 --  rec:  "V "E:  "V "
 -- INV:gen:E.loadArgs "V "
 -- INV:gen:after:E.loadArgs "V "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "V "
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- OI:invoke:before:ATdx.invoke: var V 
 -- DI:invoke: "V: var float " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V isNotRemote: true 
 fpushg 2 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var float "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "V ":isBasicVal: true 
 -- case:B: V ObjectGenerator 9 0 9 false false 
 -- end:loadArgs:NonVirt: "+ V "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- INV:gen:after:E.loadArgs "V + V "
 --  OIadr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- IV:E.invoke:useRtnVal: true E: BinOp "V + V "
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- BinaryExp:invoke: "V "rec: "V + V "
 -- M: "+ V "
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- ptn:invoke: "+   "E: "+ V "ptnKind: 0 useRtnV: true 
 fplus
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ V":rec:V 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ V":rec:V 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 fstoreg 4 address:storeg
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0

 CLASS energyCombinations 137 1 UnitIssues 128
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "M: var Mass.KiloGram " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 -- DI:isConst: M 
 -- DI:off: 2 this: "M: var Mass.KiloGram " 
 --  
 -- OG:before:super.gen: "Mass.KiloGram "
 -- INV:gen: "Mass.KiloGram " 
 -- needorigin: "Mass.KiloGram " 
 -- needOrigin:E: "KiloGram "  E.ATd: 
 --  KiloGram: Unit
 --     %unit "kg", 1
 --     %public
 --     thisUnit:: KiloGramEx: "KiloGram " rec: "Mass " E.ATd: 
 --  KiloGram: Unit
 --     %unit "kg", 1
 --     %public
 --     thisUnit:: KiloGramE.ATd.desc: 
 --  %unit "kg", 1
 --  %public
 --  thisUnit:: KiloGram
 --  print:: E.ATd.IT: 
 --  %unit "kg", 1
 --  %public
 --  thisUnit:: KiloGram
 --  print:: 
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Unit
 --     %unit "kg", 1
 --     %public
 --     thisUnit:: KiloGram
 -- after:needOrigin: "KiloGram " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "Mass "E:  "KiloGram "
 -- INV:gen:E.loadArgs "KiloGram "
 -- INV:gen:after:E.loadArgs "KiloGram "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "KiloGram "
 -- OI:invoke:before:ATdx.invoke: pattern KiloGram 
 -- ptn:invoke: "KiloGram "E: "KiloGram "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 2 rec: "Mass " 
 --  adr:none 
 invokeVal  KiloGram 138 1
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- DI:gen: "A: var Area.SquareMeter " DI:isConst: false 
 --  isBasicValue: false primNo: 0 
 -- DI:isConst: A 
 -- DI:off: 4 this: "A: var Area.SquareMeter " 
 --  
 -- OG:before:super.gen: "Area.SquareMeter "
 -- INV:gen: "Area.SquareMeter " 
 -- needorigin: "Area.SquareMeter " 
 -- needOrigin:E: "SquareMeter "  E.ATd: 
 --  SquareMeter: Unit
 --     %unit "m2", 1
 --     %Public
 --     thisUnit:: SquareMeterEx: "SquareMeter " rec: "Area " E.ATd: 
 --  SquareMeter: Unit
 --     %unit "m2", 1
 --     %Public
 --     thisUnit:: SquareMeterE.ATd.desc: 
 --  %unit "m2", 1
 --  %Public
 --  thisUnit:: SquareMeter
 --  print:: E.ATd.IT: 
 --  %unit "m2", 1
 --  %Public
 --  thisUnit:: SquareMeter
 --  print:: 
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Unit
 --     %unit "m2", 1
 --     %Public
 --     thisUnit:: SquareMeter
 -- after:needOrigin: "SquareMeter " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "Area "E:  "SquareMeter "
 -- INV:gen:E.loadArgs "SquareMeter "
 -- INV:gen:after:E.loadArgs "SquareMeter "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "
 --  SquareMeter "
 -- OI:invoke:before:ATdx.invoke: pattern SquareMeter 
 -- ptn:invoke: "SquareMeter "E: "SquareMeter "ptnKind: 0 useRtnV: 
 --  false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 4 rec: "Area " 
 --  adr:none 
 invokeVal  SquareMeter 72 3
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- DI:gen: "R: var AngularAcceleration.RadiansPerSecondSquared " 
 --  DI:isConst: false isBasicValue: false primNo: 0 
 -- DI:isConst: R 
 -- DI:off: 6 this: "
 --  R: var AngularAcceleration.RadiansPerSecondSquared " 
 --  
 -- OG:before:super.gen: "AngularAcceleration.RadiansPerSecondSquared "
 -- INV:gen: "AngularAcceleration.RadiansPerSecondSquared " 
 -- needorigin: "AngularAcceleration.RadiansPerSecondSquared " 
 -- needOrigin:E: "RadiansPerSecondSquared "  E.ATd: 
 --  RadiansPerSecondSquared: Unit
 --     %unit "RSS", "s^-2", 1
 --     print:: 
 --        "RadiansPerSecondSquared".print
 --  Ex: "RadiansPerSecondSquared " rec: "AngularAcceleration " 
 --  E.ATd: 
 --  RadiansPerSecondSquared: Unit
 --     %unit "RSS", "s^-2", 1
 --     print:: 
 --        "RadiansPerSecondSquared".print
 --  E.ATd.desc: 
 --  %unit "RSS", "s^-2", 1
 --  print:: 
 --     "RadiansPerSecondSquared".print
 --  E.ATd.IT: 
 --  %unit "RSS", "s^-2", 1
 --  print:: 
 -- \
 --      "RadiansPerSecondSquared".print
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Unit
 --     %unit "RSS", "s^-2", 1
 --     print:: 
 --        "RadiansPerSecondSquared".print
 --  
 -- after:needOrigin: "RadiansPerSecondSquared " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "AngularAcceleration "E:  "RadiansPerSecondSquared "
 -- INV:gen:E.loadArgs "RadiansPerSecondSquared "
 -- INV:gen:after:E.loadArgs "RadiansPerSecondSquared "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "
 --  RadiansPerSecondSquared "
 -- OI:invoke:before:ATdx.invoke: pattern RadiansPerSecondSquared 
 -- ptn:invoke: "RadiansPerSecondSquared "E: "RadiansPerSecondSquared "
 --  ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 6 rec: "
 --  AngularAcceleration " 
 --  adr:none 
 invokeVal  RadiansPerSecondSquared 68 5
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- DI:gen: "X: var Energy.Joule " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 -- DI:isConst: X 
 -- DI:off: 8 this: "X: var Energy.Joule " 
 --  
 -- OG:before:super.gen: "Energy.Joule "
 -- INV:gen: "Energy.Joule " 
 -- needorigin: "Energy.Joule " 
 -- needOrigin:E: "Joule "  E.ATd: 
 --  Joule: Unit
 --     %unit "J", 1
 --     thisUnit:: Joule
 --     print:: Ex: "Joule " rec: "Energy " E.ATd: 
 --  Joule: Unit
 --     %unit "J", 1
 --     thisUnit:: Joule
 --     print:: E.ATd.desc: 
 --  %unit "J", 1
 --  thisUnit:: Joule
 --  print:: 
 --     "Joule".print
 --  E.ATd.IT: 
 --  %unit "J", 1
 --  thisUnit:: Joule
 --  print:: 
 --     "Joule".print
 -- \
 --   
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Unit
 --     %unit "J", 1
 --     thisUnit:: Joule
 --     print:: 
 -- after:needOrigin: "Joule " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "Energy "E:  "Joule "
 -- INV:gen:E.loadArgs "Joule "
 -- INV:gen:after:E.loadArgs "Joule "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "Joule "
 -- OI:invoke:before:ATdx.invoke: pattern Joule 
 -- ptn:invoke: "Joule "E: "Joule "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 8 rec: "Energy " 
 --  adr:none 
 invokeVal  Joule 81 7
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: ""EnergyCombinations:\n".print "
 -- INV:gen: ""EnergyCombinations:\n".print " 
 -- needorigin: ""EnergyCombinations:\n".print " 
 -- needOrigin:E: "print "  E.ATd: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeatEx: ""EnergyCombinations:\n" " rec: ""EnergyCombinations:\n" " 
 --  E.ATd: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeatE.ATd.desc: 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])E.ATd.IT: 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- after:needOrigin: ""EnergyCombinations:\n" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  ""EnergyCombinations:\n" "E:  ""EnergyCombinations:\n" "
 -- INV:gen:E.loadArgs ""EnergyCombinations:\n" "
 -- INV:gen:after:E.loadArgs ""EnergyCombinations:\n" "
 --  OIadr: 
 pushText "EnergyCombinations:\n"
 -- IV:gen:checkTail: ""EnergyCombinations:\n".print "E: "
 --  "EnergyCombinations:\n" "tail: "print " not isLast: false 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "
 --  "EnergyCombinations:\n" " 
 --  adr:none 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- AssignmentStatement:gen: "M := 12"kg" " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "M := 12"kg" " right.label: "ObjectGenerator ""12"kg" " 
 -- OG:before:super.gen: "12"kg" "
 -- INV:gen: "12"kg" " 
 -- needorigin: "12"kg" " 
 -- needOrigin:E: "12"kg" "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "12"kg" " rec: "12"kg" " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "12"kg" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "12"kg" "E:  "12"kg" "
 -- INV:gen:E.loadArgs "12"kg" "
 -- INV:gen:after:E.loadArgs "12"kg" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "12"kg" "
 pushc 12
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 i2f
 -- assign:adr.store:A: 
 fstoreg 2 address:storeg
 -- assign:adr.store:B: 
 -- AssignmentStatement:gen: "A := 4"m2" " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "A := 4"m2" " right.label: "ObjectGenerator ""4"m2" " 
 -- OG:before:super.gen: "4"m2" "
 -- INV:gen: "4"m2" " 
 -- needorigin: "4"m2" " 
 -- needOrigin:E: "4"m2" "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "4"m2" " rec: "4"m2" " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "4"m2" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "4"m2" "E:  "4"m2" "
 -- INV:gen:E.loadArgs "4"m2" "
 -- INV:gen:after:E.loadArgs "4"m2" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "4"m2" "
 pushc 4
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 i2f
 -- assign:adr.store:A: 
 fstoreg 4 address:storeg
 -- assign:adr.store:B: 
 -- AssignmentStatement:gen: "R := 6"RSS" " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "R := 6"RSS" " right.label: "ObjectGenerator ""6"RSS" " 
 -- OG:before:super.gen: "6"RSS" "
 -- INV:gen: "6"RSS" " 
 -- needorigin: "6"RSS" " 
 -- needOrigin:E: "6"RSS" "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "6"RSS" " rec: "6"RSS" " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "6"RSS" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "6"RSS" "E:  "6"RSS" "
 -- INV:gen:E.loadArgs "6"RSS" "
 -- INV:gen:after:E.loadArgs "6"RSS" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "6"RSS" "
 pushc 6
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 i2f
 -- assign:adr.store:A: 
 fstoreg 6 address:storeg
 -- assign:adr.store:B: 
 -- AssignmentStatement:gen: "X := M * A * R " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "X := M * A * R " right.label: "ObjectGenerator ""M * A * R " 
 -- OG:before:super.gen: "M * A * R "
 -- INV:gen: "M * A * R " 
 -- needorigin: "M * A * R " 
 -- needOrigin:E: "M * A * R "  E.ATd: 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  Ex: "M * A * R " rec: "M * A * R " E.ATd: 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  E.ATd.desc: 
 --  %basic 112
 --  in V: var float
 --  out R: var float
 --  E.ATd.IT: 
 --  %basic 112
 --  in V: var float
 --  out R: var float
 -- \
 --   
 -- doNeedOrigin:Ex: "M * A * R "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "M * A * R " 
 -- doNeedOrigin:E: "M * A * R " 
 -- computeAdrX:superAdj: 0 "M * A * R " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "M * A * R " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "M * A * R "superAdj: 0 
 -- computeAdrX:isLast:E:  "M * A * R "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "M * A * R "E:  "M * A * R "
 -- INV:gen:E.loadArgs "M * A * R "
 -- BinaryExp:loadArgs: "M * A * R " superAdj: 0 
 -- BinaryExp:gen: "M * A "
 -- INV:gen: "M " 
 -- needorigin: "M " 
 -- needOrigin:E: "M "  E.ATd: "M: var Mass.KiloGram " Ex: "M " rec: "
 --  M " E.ATd: "M: var Mass.KiloGram " E.ATd.desc: 
 --  %unit "kg", 1
 --  %public
 --  thisUnit:: KiloGram
 --  print:: E.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "M " 
 -- doNeedOrigin:E: "M " 
 -- computeAdrX:superAdj: 0 "M " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "M " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "M "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:- 
 --  rec:  "M "E:  "M "
 -- INV:gen:E.loadArgs "M "
 -- INV:gen:after:E.loadArgs "M "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "M "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:- 
 -- OI:invoke:before:ATdx.invoke: var M 
 -- DI:invoke: "M: var Mass.KiloGram " 
 -- isValueObj:isAdr: false objSize: 2  rec "M ",E: "M ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- Address:loadAdr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:isUnitVal 
 fpushg 2 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- INV:gen:end:off: 2 
 -- BinaryExp:gen:before:loadargs "M * A "
 -- A: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- NonVirt: "* A " "ObjectInvocation_Binary " ActArg: "A "isValue: 
 --  true formalArg: "in V: var float " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- OG:before:super.gen: "A "
 -- INV:gen: "A " 
 -- needorigin: "A " 
 -- needOrigin:E: "A "  E.ATd: "A: var Area.SquareMeter " Ex: "A " 
 --  rec: "A " E.ATd: "A: var Area.SquareMeter " E.ATd.desc: 
 --  %unit "m2", 1
 --  %Public
 --  thisUnit:: SquareMeter
 --  print:: E.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "A " 
 -- doNeedOrigin:E: "A " 
 -- computeAdrX:superAdj: 0 "A " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "A " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "A "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 --  rec:  "A "E:  "A "
 -- INV:gen:E.loadArgs "A "
 -- INV:gen:after:E.loadArgs "A "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "A "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- OI:invoke:before:ATdx.invoke: var A 
 -- DI:invoke: "A: var Area.SquareMeter " 
 -- isValueObj:isAdr: false objSize: 2  rec "A ",E: "A ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:A 
 -- Address:loadAdr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:A 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:isUnitVal 
 fpushg 4 
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:A 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:A 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:A 
 -- before:pushSize:  actualArg.super.ATd.OG.isUnitValueObj: true 
 --  :actualArg.isCompositeValueObj: false 
 -- actualArg:UnitOne?: A 
 -- end:loadArgs:NonVirt: "* A "
 -- OI:invoke:before:ATdx.invoke: pattern *   
 -- ptn:invoke: "*   "E: "* A "ptnKind: 0 useRtnV: true 
 fmult
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* A":rec:* A 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* A":rec:* A 
 -- BinaryExp:gen:before:end "M * A "
 -- Madr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* A":rec:* A 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 -- NonVirt: "* R " "ObjectInvocation_Binary " ActArg: "R "isValue: 
 --  true formalArg: "in V: var float " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- OG:before:super.gen: "R "
 -- INV:gen: "R " 
 -- needorigin: "R " 
 -- needOrigin:E: "R "  E.ATd: "
 --  R: var AngularAcceleration.RadiansPerSecondSquared " Ex: "R " rec: "R " E.ATd: "
 --  R: var AngularAcceleration.RadiansPerSecondSquared " E.ATd.desc: 
 --  %unit "RSS", "s^-2", 1
 --  print:: 
 --     "RadiansPerSecondSquared".print
 --  E.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "R " 
 -- doNeedOrigin:E: "R " 
 -- computeAdrX:superAdj: 0 "R " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "R " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "R "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 --  rec:  "R "E:  "R "
 -- INV:gen:E.loadArgs "R "
 -- INV:gen:after:E.loadArgs "R "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "R "
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- OI:invoke:before:ATdx.invoke: var R 
 -- DI:invoke: "R: var AngularAcceleration.RadiansPerSecondSquared " 
 -- isValueObj:isAdr: false objSize: 2  rec "R ",E: "R ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:R 
 -- Address:loadAdr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:R 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:isUnitVal 
 fpushg 6 
 -- OI:invoke:V: adr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:R 
 -- OI:invoke:X: adr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:R 
 -- INV:gen:end:off: 6 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:R 
 -- before:pushSize:  actualArg.super.ATd.OG.isUnitValueObj: true 
 --  :actualArg.isCompositeValueObj: false 
 -- actualArg:UnitOne?: R 
 -- end:loadArgs:NonVirt: "* R "
 -- BinaryExp:loadArgs:end: 
 -- INV:gen:after:E.loadArgs "M * A * R "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: BinOp "M * A * R "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:invoke: "M * A "rec: "M * A * R "
 -- M: "* R "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern *   
 -- ptn:invoke: "*   "E: "* R "ptnKind: 0 useRtnV: true 
 fmult
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"* R":rec:M * A 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"* R":rec:M * A 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 fstoreg 8 address:storeg
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "X.print "
 -- INV:gen: "X.print " 
 -- needorigin: "X.print " 
 -- needOrigin:E: "print "  E.ATd: 
 --  print:: 
 --     "Joule".print
 --  Ex: "print " rec: "X " E.ATd: 
 --  print:: 
 --     "Joule".print
 --  E.ATd.desc: ""Joule".print " E.ATd.IT: ""Joule".print " 
 -- doNeedOrigin:Ex: "print "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- origin:isValueObj: "Joule "
 -- after:needOrigin: "print " 
 -- doNeedOrigin:E: "print " 
 -- computeAdrX:superAdj: 0 "X.print " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "X " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "X " rec: "X " E: "print " 
 --  A.E: "X "
 --  
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "X " rec: "X " E: "print " 
 --  rec.ATd: "X: var Energy.Joule " rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  M: var Mass.KiloGram
 --     A: var Area.SquareMeter
 --     R: var AngularAcceleration.RadiansPerSecondSquared
 --     X: var Energy.Joule
 --  recA: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X":rec:- 
 --  pRecA: none 
 -- pRec: "X " rec: "X " E: "print " 
 --  false true 
 -- computeAdrX:before:rec:: "X " 
 -- OI:invoke:before:ATdx.invoke: var X 
 -- DI:invoke: "X: var Energy.Joule " 
 -- isValueObj:isAdr: true objSize: 2  rec "X ",E: "print ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 -- Address:loadAdr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain "print " cmpAndSwap: false rec: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 -- OI:invoke:X: adr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 -- computeAdrX:after:rec.invoke: "X " 
 -- computeAdrX:isLast:E:  "print "
 -- originIsValueObj: 
 --  M: var Mass.KiloGram
 --  A: var Area.SquareMeter
 --  R: var AngularAcceleration.RadiansPerSecondSquared
 --  X: var Energy.Joule
 -- rec = E: false 0 
 -- call:mkValueProxy false true 
 -- mkValueProxy:INV: "X.print " E: "print " rec: "X " E.ATd: 
 --  print:: 
 --     "Joule".print
 --  
 -- CreateProxyW:E: "print "E.ATd.origin.encOG:OGid "Joule "
 --  origin:descNo: 81 "Energy ""X.print " 
 --  rec.ATd: "X: var Energy.Joule "rec.ATd.newOff: 8 0 
 rdouble 0
 -- son: "X " 
 -- son: "print " 
 -- recOfE: "X "recOfE.ATd: "X: var Energy.Joule " 
 -- first: "Energy "ObjectInvocation_Unary first.origin.encOG: "
 --  energyCombinations "
 -- items:goOrigin:encOG: "energyCombinations "on: 1 isValueObj: 
 --  false 
 --  origin: UnitIssues origin:isValueObj: false 
 rpushg energyCombinations$137 1
 -- items:goOrigin:encOG: "UnitIssues "on: 2 isValueObj: false 
 --  origin: workspace origin:isValueObj: false 
 rpushg UnitIssues$128 1
 -- items:goOrigin:encOG: "workspace "on: 1 isValueObj: false 
 --  origin: BETAworld origin:isValueObj: false 
 rpushg workspace$127 1
 rpushg LIB 3
 rpushg Dimensions 4
 -- after:Ey.loadOrigin: 
 -- Adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- Address:loadAdr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rpushg EisNone 4
 -- after:A.loadAdr 
 mkValueProxy 81 7
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 --  rec:  "X "E:  "print "
 -- INV:gen:E.loadArgs "print "
 -- INV:gen:after:E.loadArgs "print "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print "
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 rec: "X " 
 --  
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 invoke print 83 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- OI:invoke:V: adr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 -- OI:invoke:X: adr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 -- INV:gen:end:off: 8 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 -- OG:before:super.gen: "newline "
 -- INV:gen: "newline " 
 -- needorigin: "newline " 
 -- needOrigin:E: "newline "  E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  Ex: "newline " rec: "newline " E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  E.ATd.desc: 
 --  %globals
 --  put(10)
 --  E.ATd.IT: 
 --  %globals
 --  put(10)
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %globals
 --     put(10)
 --  
 -- after:needOrigin: "newline " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "newline "E:  "newline "
 -- INV:gen:E.loadArgs "newline "
 -- INV:gen:after:E.loadArgs "newline "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "newline "
 -- OI:invoke:before:ATdx.invoke: pattern newline 
 -- ptn:invoke: "newline "E: "newline "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "newline " 
 --  adr:none 
 invoke newline 130 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- AssignmentStatement:gen: "X := M * A * 6"s^-2" " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "X := M * A * 6"s^-2" " right.label: "ObjectGenerator ""
 --  M * A * 6"s^-2" " 
 -- OG:before:super.gen: "M * A * 6"s^-2" "
 -- INV:gen: "M * A * 6"s^-2" " 
 -- needorigin: "M * A * 6"s^-2" " 
 -- needOrigin:E: "M * A * 6"s^-2" "  E.ATd: 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  Ex: "M * A * 6"s^-2" " rec: "M * A * 6"s^-2" " E.ATd: 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  E.ATd.desc: 
 --  %basic 112
 --  in V: var float
 --  out R: var float
 --  E.ATd.IT: 
 --  %basic 112
 --  in V: var float
 --  out R: var float
 -- \
 --   
 -- doNeedOrigin:Ex: "M * A * 6"s^-2" "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "M * A * 6"s^-2" " 
 -- doNeedOrigin:E: "M * A * 6"s^-2" " 
 -- computeAdrX:superAdj: 0 "M * A * 6"s^-2" " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "M * A * 6"s^-2" " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "M * A * 6"s^-2" "superAdj: 0 
 -- computeAdrX:isLast:E:  "M * A * 6"s^-2" "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "M * A * 6"s^-2" "E:  "M * A * 6"s^-2" "
 -- INV:gen:E.loadArgs "M * A * 6"s^-2" "
 -- BinaryExp:loadArgs: "M * A * 6"s^-2" " superAdj: 0 
 -- BinaryExp:gen: "M * A "
 -- INV:gen: "M " 
 -- needorigin: "M " 
 -- needOrigin:E: "M "  E.ATd: "M: var Mass.KiloGram " Ex: "M " rec: "
 --  M " E.ATd: "M: var Mass.KiloGram " E.ATd.desc: 
 --  %unit "kg", 1
 --  %public
 --  thisUnit:: KiloGram
 --  print:: E.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "M " 
 -- doNeedOrigin:E: "M " 
 -- computeAdrX:superAdj: 0 "M " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "M " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "M "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:- 
 --  rec:  "M "E:  "M "
 -- INV:gen:E.loadArgs "M "
 -- INV:gen:after:E.loadArgs "M "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "M "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:- 
 -- OI:invoke:before:ATdx.invoke: var M 
 -- DI:invoke: "M: var Mass.KiloGram " 
 -- isValueObj:isAdr: false objSize: 2  rec "M ",E: "M ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- Address:loadAdr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:isUnitVal 
 fpushg 2 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- INV:gen:end:off: 2 
 -- BinaryExp:gen:before:loadargs "M * A "
 -- A: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"M":rec:M 
 -- NonVirt: "* A " "ObjectInvocation_Binary " ActArg: "A "isValue: 
 --  true formalArg: "in V: var float " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- OG:before:super.gen: "A "
 -- INV:gen: "A " 
 -- needorigin: "A " 
 -- needOrigin:E: "A "  E.ATd: "A: var Area.SquareMeter " Ex: "A " 
 --  rec: "A " E.ATd: "A: var Area.SquareMeter " E.ATd.desc: 
 --  %unit "m2", 1
 --  %Public
 --  thisUnit:: SquareMeter
 --  print:: E.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "A " 
 -- doNeedOrigin:E: "A " 
 -- computeAdrX:superAdj: 0 "A " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "A " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "A "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 --  rec:  "A "E:  "A "
 -- INV:gen:E.loadArgs "A "
 -- INV:gen:after:E.loadArgs "A "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "A "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- OI:invoke:before:ATdx.invoke: var A 
 -- DI:invoke: "A: var Area.SquareMeter " 
 -- isValueObj:isAdr: false objSize: 2  rec "A ",E: "A ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:A 
 -- Address:loadAdr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:A 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:isUnitVal 
 fpushg 4 
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:A 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:A 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:A 
 -- before:pushSize:  actualArg.super.ATd.OG.isUnitValueObj: true 
 --  :actualArg.isCompositeValueObj: false 
 -- actualArg:UnitOne?: A 
 -- end:loadArgs:NonVirt: "* A "
 -- OI:invoke:before:ATdx.invoke: pattern *   
 -- ptn:invoke: "*   "E: "* A "ptnKind: 0 useRtnV: true 
 fmult
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* A":rec:* A 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* A":rec:* A 
 -- BinaryExp:gen:before:end "M * A "
 -- Madr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* A":rec:* A 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 -- NonVirt: "* 6"s^-2" " "ObjectInvocation_Binary " ActArg: "6"s^-2" "
 --  isValue: true formalArg: "in V: var float " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- OG:before:super.gen: "6"s^-2" "
 -- INV:gen: "6"s^-2" " 
 -- needorigin: "6"s^-2" " 
 -- needOrigin:E: "6"s^-2" "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "6"s^-2" " rec: "6"s^-2" " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "6"s^-2" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "6"s^-2" "E:  "6"s^-2" "
 -- INV:gen:E.loadArgs "6"s^-2" "
 -- INV:gen:after:E.loadArgs "6"s^-2" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "6"s^-2" "
 pushc 6
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var float "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "6"s^-2" ":isBasicVal: true 
 -- case:B: 6"s^-2" ObjectGenerator 9 1 1 false true 
 i2f
 -- end:loadArgs:NonVirt: "* 6"s^-2" "
 -- BinaryExp:loadArgs:end: 
 -- INV:gen:after:E.loadArgs "M * A * 6"s^-2" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: BinOp "M * A * 6"s^-2" "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:invoke: "M * A "rec: "M * A * 6"s^-2" "
 -- M: "* 6"s^-2" "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern *   
 -- ptn:invoke: "*   "E: "* 6"s^-2" "ptnKind: 0 useRtnV: true 
 fmult
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"* 6"s^-2"":rec:M * A 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"* 6"s^-2"":rec:M * A 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 fstoreg 8 address:storeg
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "X.print "
 -- INV:gen: "X.print " 
 -- needorigin: "X.print " 
 -- needOrigin:E: "print "  E.ATd: 
 --  print:: 
 --     "Joule".print
 --  Ex: "print " rec: "X " E.ATd: 
 --  print:: 
 --     "Joule".print
 --  E.ATd.desc: ""Joule".print " E.ATd.IT: ""Joule".print " 
 -- doNeedOrigin:Ex: "print "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- origin:isValueObj: "Joule "
 -- after:needOrigin: "print " 
 -- doNeedOrigin:E: "print " 
 -- computeAdrX:superAdj: 0 "X.print " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "X " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "X " rec: "X " E: "print " 
 --  A.E: "X "
 --  
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "X " rec: "X " E: "print " 
 --  rec.ATd: "X: var Energy.Joule " rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  M: var Mass.KiloGram
 --     A: var Area.SquareMeter
 --     R: var AngularAcceleration.RadiansPerSecondSquared
 --     X: var Energy.Joule
 --  recA: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X":rec:- 
 --  pRecA: none 
 -- pRec: "X " rec: "X " E: "print " 
 --  false true 
 -- computeAdrX:before:rec:: "X " 
 -- OI:invoke:before:ATdx.invoke: var X 
 -- DI:invoke: "X: var Energy.Joule " 
 -- isValueObj:isAdr: true objSize: 2  rec "X ",E: "print ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 -- Address:loadAdr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain "print " cmpAndSwap: false rec: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 -- OI:invoke:X: adr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 -- computeAdrX:after:rec.invoke: "X " 
 -- computeAdrX:isLast:E:  "print "
 -- originIsValueObj: 
 --  M: var Mass.KiloGram
 --  A: var Area.SquareMeter
 --  R: var AngularAcceleration.RadiansPerSecondSquared
 --  X: var Energy.Joule
 -- rec = E: false 0 
 -- call:mkValueProxy false true 
 -- mkValueProxy:INV: "X.print " E: "print " rec: "X " E.ATd: 
 --  print:: 
 --     "Joule".print
 --  
 -- CreateProxyW:E: "print "E.ATd.origin.encOG:OGid "Joule "
 --  origin:descNo: 81 "Energy ""X.print " 
 --  rec.ATd: "X: var Energy.Joule "rec.ATd.newOff: 8 0 
 rdouble 0
 -- son: "X " 
 -- son: "print " 
 -- recOfE: "X "recOfE.ATd: "X: var Energy.Joule " 
 -- first: "Energy "ObjectInvocation_Unary first.origin.encOG: "
 --  energyCombinations "
 -- items:goOrigin:encOG: "energyCombinations "on: 1 isValueObj: 
 --  false 
 --  origin: UnitIssues origin:isValueObj: false 
 rpushg energyCombinations$137 1
 -- items:goOrigin:encOG: "UnitIssues "on: 2 isValueObj: false 
 --  origin: workspace origin:isValueObj: false 
 rpushg UnitIssues$128 1
 -- items:goOrigin:encOG: "workspace "on: 1 isValueObj: false 
 --  origin: BETAworld origin:isValueObj: false 
 rpushg workspace$127 1
 rpushg LIB 3
 rpushg Dimensions 4
 -- after:Ey.loadOrigin: 
 -- Adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- Address:loadAdr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rpushg EisNone 4
 -- after:A.loadAdr 
 mkValueProxy 81 7
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 --  rec:  "X "E:  "print "
 -- INV:gen:E.loadArgs "print "
 -- INV:gen:after:E.loadArgs "print "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print "
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 rec: "X " 
 --  
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 invoke print 83 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- OI:invoke:V: adr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 -- OI:invoke:X: adr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 -- INV:gen:end:off: 8 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 -- OG:before:super.gen: "newline "
 -- INV:gen: "newline " 
 -- needorigin: "newline " 
 -- needOrigin:E: "newline "  E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  Ex: "newline " rec: "newline " E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  E.ATd.desc: 
 --  %globals
 --  put(10)
 --  E.ATd.IT: 
 --  %globals
 --  put(10)
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %globals
 --     put(10)
 --  
 -- after:needOrigin: "newline " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "newline "E:  "newline "
 -- INV:gen:E.loadArgs "newline "
 -- INV:gen:after:E.loadArgs "newline "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "newline "
 -- OI:invoke:before:ATdx.invoke: pattern newline 
 -- ptn:invoke: "newline "E: "newline "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "newline " 
 --  adr:none 
 invoke newline 130 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- AssignmentStatement:gen: "X := 12.0"kg" * 4.0"m2" * 6.0"s^-2" " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "X := 12.0"kg" * 4.0"m2" * 6.0"s^-2" " right.label: "
 --  ObjectGenerator ""12.0"kg" * 4.0"m2" * 6.0"s^-2" " 
 -- OG:before:super.gen: "12.0"kg" * 4.0"m2" * 6.0"s^-2" "
 -- INV:gen: "12.0"kg" * 4.0"m2" * 6.0"s^-2" " 
 -- needorigin: "12.0"kg" * 4.0"m2" * 6.0"s^-2" " 
 -- needOrigin:E: "12.0"kg" * 4.0"m2" * 6.0"s^-2" "  E.ATd: 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  Ex: "12.0"kg" * 4.0"m2" * 6.0"s^-2" " rec: "
 --  12.0"kg" * 4.0"m2" * 6.0"s^-2" " E.ATd: 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  E.ATd.desc: 
 --  %basic 112
 --  in V: var float
 --  out R: var float
 --  E.ATd.IT: 
 --  %basic 112
 --  in V: var float
 -- \
 --   out R: var float
 --  
 -- doNeedOrigin:Ex: "12.0"kg" * 4.0"m2" * 6.0"s^-2" "
 --  originIsValueObj: true origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "12.0"kg" * 4.0"m2" * 6.0"s^-2" " 
 -- doNeedOrigin:E: "12.0"kg" * 4.0"m2" * 6.0"s^-2" " 
 -- computeAdrX:superAdj: 0 "12.0"kg" * 4.0"m2" * 6.0"s^-2" " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "
 --  12.0"kg" * 4.0"m2" * 6.0"s^-2" " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "12.0"kg" * 4.0"m2" * 6.0"s^-2" "
 --  superAdj: 0 
 -- computeAdrX:isLast:E:  "12.0"kg" * 4.0"m2" * 6.0"s^-2" "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "12.0"kg" * 4.0"m2" * 6.0"s^-2" "E:  "
 --  12.0"kg" * 4.0"m2" * 6.0"s^-2" "
 -- INV:gen:E.loadArgs "12.0"kg" * 4.0"m2" * 6.0"s^-2" "
 -- BinaryExp:loadArgs: "12.0"kg" * 4.0"m2" * 6.0"s^-2" " superAdj: 0 
 -- BinaryExp:gen: "12.0"kg" * 4.0"m2" "
 -- INV:gen: "12.0"kg" " 
 -- needorigin: "12.0"kg" " 
 -- needOrigin:E: "12.0"kg" "  E.ATd: 
 --  float: Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var FloatEx: "12.0"kg" " rec: "12.0"kg" " E.ATd: 
 --  float: Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var FloatE.ATd.desc: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %publicE.ATd.IT: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var Float
 -- after:needOrigin: "12.0"kg" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "12.0"kg" "E:  "12.0"kg" "
 -- INV:gen:E.loadArgs "12.0"kg" "
 -- INV:gen:after:E.loadArgs "12.0"kg" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: FloatLiteral "12.0"kg" "
 pushFloatConst 12.000000
 -- INV:gen:end:off: 
 -- BinaryExp:gen:before:loadargs "12.0"kg" * 4.0"m2" "
 -- A: 
 -- NonVirt: "* 4.0"m2" " "ObjectInvocation_Binary " ActArg: "4.0"m2" "
 --  isValue: true formalArg: "in V: var float " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- OG:before:super.gen: "4.0"m2" "
 -- INV:gen: "4.0"m2" " 
 -- needorigin: "4.0"m2" " 
 -- needOrigin:E: "4.0"m2" "  E.ATd: 
 --  float: Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var FloatEx: "4.0"m2" " rec: "4.0"m2" " E.ATd: 
 --  float: Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var FloatE.ATd.desc: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %publicE.ATd.IT: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var Float
 -- after:needOrigin: "4.0"m2" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "4.0"m2" "E:  "4.0"m2" "
 -- INV:gen:E.loadArgs "4.0"m2" "
 -- INV:gen:after:E.loadArgs "4.0"m2" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: FloatLiteral "4.0"m2" "
 pushFloatConst 4.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var float "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "4.0"m2" ":isBasicVal: true 
 -- case:B: 4.0"m2" ObjectGenerator 9 9 9 false true 
 -- end:loadArgs:NonVirt: "* 4.0"m2" "
 -- OI:invoke:before:ATdx.invoke: pattern *   
 -- ptn:invoke: "*   "E: "* 4.0"m2" "ptnKind: 0 useRtnV: true 
 fmult
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- BinaryExp:gen:before:end "12.0"kg" * 4.0"m2" "
 -- Madr: 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 -- NonVirt: "* 6.0"s^-2" " "ObjectInvocation_Binary " ActArg: "
 --  6.0"s^-2" "isValue: true formalArg: "in V: var float " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- OG:before:super.gen: "6.0"s^-2" "
 -- INV:gen: "6.0"s^-2" " 
 -- needorigin: "6.0"s^-2" " 
 -- needOrigin:E: "6.0"s^-2" "  E.ATd: 
 --  float: Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var FloatEx: "6.0"s^-2" " rec: "6.0"s^-2" " E.ATd: 
 --  float: Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var FloatE.ATd.desc: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %publicE.ATd.IT: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var Float
 -- after:needOrigin: "6.0"s^-2" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "6.0"s^-2" "E:  "6.0"s^-2" "
 -- INV:gen:E.loadArgs "6.0"s^-2" "
 -- INV:gen:after:E.loadArgs "6.0"s^-2" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: FloatLiteral "6.0"s^-2" "
 pushFloatConst 6.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var float "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "6.0"s^-2" ":isBasicVal: true 
 -- case:B: 6.0"s^-2" ObjectGenerator 9 9 9 false true 
 -- end:loadArgs:NonVirt: "* 6.0"s^-2" "
 -- BinaryExp:loadArgs:end: 
 -- INV:gen:after:E.loadArgs "12.0"kg" * 4.0"m2" * 6.0"s^-2" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: BinOp "
 --  12.0"kg" * 4.0"m2" * 6.0"s^-2" "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:invoke: "12.0"kg" * 4.0"m2" "rec: "
 --  12.0"kg" * 4.0"m2" * 6.0"s^-2" "
 -- M: "* 6.0"s^-2" "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern *   
 -- ptn:invoke: "*   "E: "* 6.0"s^-2" "ptnKind: 0 useRtnV: true 
 fmult
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"* 6.0"s^-2"":rec:12.0"kg" * 4.0"m2" 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"* 6.0"s^-2"":rec:12.0"kg" * 4.0"m2" 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 fstoreg 8 address:storeg
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "X.print "
 -- INV:gen: "X.print " 
 -- needorigin: "X.print " 
 -- needOrigin:E: "print "  E.ATd: 
 --  print:: 
 --     "Joule".print
 --  Ex: "print " rec: "X " E.ATd: 
 --  print:: 
 --     "Joule".print
 --  E.ATd.desc: ""Joule".print " E.ATd.IT: ""Joule".print " 
 -- doNeedOrigin:Ex: "print "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- origin:isValueObj: "Joule "
 -- after:needOrigin: "print " 
 -- doNeedOrigin:E: "print " 
 -- computeAdrX:superAdj: 0 "X.print " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "X " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "X " rec: "X " E: "print " 
 --  A.E: "X "
 --  
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "X " rec: "X " E: "print " 
 --  rec.ATd: "X: var Energy.Joule " rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  M: var Mass.KiloGram
 --     A: var Area.SquareMeter
 --     R: var AngularAcceleration.RadiansPerSecondSquared
 --     X: var Energy.Joule
 --  recA: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X":rec:- 
 --  pRecA: none 
 -- pRec: "X " rec: "X " E: "print " 
 --  false true 
 -- computeAdrX:before:rec:: "X " 
 -- OI:invoke:before:ATdx.invoke: var X 
 -- DI:invoke: "X: var Energy.Joule " 
 -- isValueObj:isAdr: true objSize: 2  rec "X ",E: "print ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 -- Address:loadAdr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain "print " cmpAndSwap: false rec: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 -- OI:invoke:X: adr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 -- computeAdrX:after:rec.invoke: "X " 
 -- computeAdrX:isLast:E:  "print "
 -- originIsValueObj: 
 --  M: var Mass.KiloGram
 --  A: var Area.SquareMeter
 --  R: var AngularAcceleration.RadiansPerSecondSquared
 --  X: var Energy.Joule
 -- rec = E: false 0 
 -- call:mkValueProxy false true 
 -- mkValueProxy:INV: "X.print " E: "print " rec: "X " E.ATd: 
 --  print:: 
 --     "Joule".print
 --  
 -- CreateProxyW:E: "print "E.ATd.origin.encOG:OGid "Joule "
 --  origin:descNo: 81 "Energy ""X.print " 
 --  rec.ATd: "X: var Energy.Joule "rec.ATd.newOff: 8 0 
 rdouble 0
 -- son: "X " 
 -- son: "print " 
 -- recOfE: "X "recOfE.ATd: "X: var Energy.Joule " 
 -- first: "Energy "ObjectInvocation_Unary first.origin.encOG: "
 --  energyCombinations "
 -- items:goOrigin:encOG: "energyCombinations "on: 1 isValueObj: 
 --  false 
 --  origin: UnitIssues origin:isValueObj: false 
 rpushg energyCombinations$137 1
 -- items:goOrigin:encOG: "UnitIssues "on: 2 isValueObj: false 
 --  origin: workspace origin:isValueObj: false 
 rpushg UnitIssues$128 1
 -- items:goOrigin:encOG: "workspace "on: 1 isValueObj: false 
 --  origin: BETAworld origin:isValueObj: false 
 rpushg workspace$127 1
 rpushg LIB 3
 rpushg Dimensions 4
 -- after:Ey.loadOrigin: 
 -- Adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- Address:loadAdr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rpushg EisNone 4
 -- after:A.loadAdr 
 mkValueProxy 81 7
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 --  rec:  "X "E:  "print "
 -- INV:gen:E.loadArgs "print "
 -- INV:gen:after:E.loadArgs "print "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print "
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 rec: "X " 
 --  
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 invoke print 83 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- OI:invoke:V: adr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 -- OI:invoke:X: adr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 -- INV:gen:end:off: 8 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 -- OG:before:super.gen: "newline "
 -- INV:gen: "newline " 
 -- needorigin: "newline " 
 -- needOrigin:E: "newline "  E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  Ex: "newline " rec: "newline " E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  E.ATd.desc: 
 --  %globals
 --  put(10)
 --  E.ATd.IT: 
 --  %globals
 --  put(10)
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %globals
 --     put(10)
 --  
 -- after:needOrigin: "newline " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "newline "E:  "newline "
 -- INV:gen:E.loadArgs "newline "
 -- INV:gen:after:E.loadArgs "newline "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "newline "
 -- OI:invoke:before:ATdx.invoke: pattern newline 
 -- ptn:invoke: "newline "E: "newline "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "newline " 
 --  adr:none 
 invoke newline 130 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- AssignmentStatement:gen: "X := 12"kg" * 4"m2" * 6"s^-2" " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "X := 12"kg" * 4"m2" * 6"s^-2" " right.label: "ObjectGenerator ""
 --  12"kg" * 4"m2" * 6"s^-2" " 
 -- OG:before:super.gen: "12"kg" * 4"m2" * 6"s^-2" "
 -- INV:gen: "12"kg" * 4"m2" * 6"s^-2" " 
 -- needorigin: "12"kg" * 4"m2" * 6"s^-2" " 
 -- needOrigin:E: "12"kg" * 4"m2" * 6"s^-2" "  E.ATd: 
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  Ex: "12"kg" * 4"m2" * 6"s^-2" " rec: "12"kg" * 4"m2" * 6"s^-2" " 
 --  E.ATd: 
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  E.ATd.desc: 
 --  %basic 66
 --  in V: var integer
 --  out R: var integer
 --  E.ATd.IT: 
 --  %basic 66
 --  in V: var integer
 -- \
 --   out R: var integer
 --  
 -- doNeedOrigin:Ex: "12"kg" * 4"m2" * 6"s^-2" "originIsValueObj: 
 --  true origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "12"kg" * 4"m2" * 6"s^-2" " 
 -- doNeedOrigin:E: "12"kg" * 4"m2" * 6"s^-2" " 
 -- computeAdrX:superAdj: 0 "12"kg" * 4"m2" * 6"s^-2" " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "
 --  12"kg" * 4"m2" * 6"s^-2" " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "12"kg" * 4"m2" * 6"s^-2" "superAdj: 0 
 -- computeAdrX:isLast:E:  "12"kg" * 4"m2" * 6"s^-2" "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "12"kg" * 4"m2" * 6"s^-2" "E:  "12"kg" * 4"m2" * 6"s^-2" "
 -- INV:gen:E.loadArgs "12"kg" * 4"m2" * 6"s^-2" "
 -- BinaryExp:loadArgs: "12"kg" * 4"m2" * 6"s^-2" " superAdj: 0 
 -- BinaryExp:gen: "12"kg" * 4"m2" "
 -- INV:gen: "12"kg" " 
 -- needorigin: "12"kg" " 
 -- needOrigin:E: "12"kg" "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "12"kg" " rec: "12"kg" " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "12"kg" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "12"kg" "E:  "12"kg" "
 -- INV:gen:E.loadArgs "12"kg" "
 -- INV:gen:after:E.loadArgs "12"kg" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "12"kg" "
 pushc 12
 -- INV:gen:end:off: 
 -- BinaryExp:gen:before:loadargs "12"kg" * 4"m2" "
 -- A: 
 -- NonVirt: "* 4"m2" " "ObjectInvocation_Binary " ActArg: "4"m2" "
 --  isValue: true formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "* 4"m2" " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "4"m2" "
 -- INV:gen: "4"m2" " 
 -- needorigin: "4"m2" " 
 -- needOrigin:E: "4"m2" "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "4"m2" " rec: "4"m2" " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "4"m2" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "4"m2" "E:  "4"m2" "
 -- INV:gen:E.loadArgs "4"m2" "
 -- INV:gen:after:E.loadArgs "4"m2" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "4"m2" "
 pushc 4
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "4"m2" ":isBasicVal: true 
 -- case:B: 4"m2" ObjectGenerator 1 1 1 false true 
 -- end:loadArgs:NonVirt: "* 4"m2" "
 -- OI:invoke:before:ATdx.invoke: pattern *   
 -- ptn:invoke: "*   "E: "* 4"m2" "ptnKind: 0 useRtnV: true 
 mult
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- BinaryExp:gen:before:end "12"kg" * 4"m2" "
 -- Madr: 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 -- NonVirt: "* 6"s^-2" " "ObjectInvocation_Binary " ActArg: "6"s^-2" "
 --  isValue: true formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "* 6"s^-2" " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "6"s^-2" "
 -- INV:gen: "6"s^-2" " 
 -- needorigin: "6"s^-2" " 
 -- needOrigin:E: "6"s^-2" "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "6"s^-2" " rec: "6"s^-2" " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "6"s^-2" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "6"s^-2" "E:  "6"s^-2" "
 -- INV:gen:E.loadArgs "6"s^-2" "
 -- INV:gen:after:E.loadArgs "6"s^-2" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "6"s^-2" "
 pushc 6
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "6"s^-2" ":isBasicVal: true 
 -- case:B: 6"s^-2" ObjectGenerator 1 1 1 false true 
 -- end:loadArgs:NonVirt: "* 6"s^-2" "
 -- BinaryExp:loadArgs:end: 
 -- INV:gen:after:E.loadArgs "12"kg" * 4"m2" * 6"s^-2" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: BinOp "12"kg" * 4"m2" * 6"s^-2" "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:invoke: "12"kg" * 4"m2" "rec: "12"kg" * 4"m2" * 6"s^-2" "
 -- M: "* 6"s^-2" "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern *   
 -- ptn:invoke: "*   "E: "* 6"s^-2" "ptnKind: 0 useRtnV: true 
 mult
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"* 6"s^-2"":rec:12"kg" * 4"m2" 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"* 6"s^-2"":rec:12"kg" * 4"m2" 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 i2f
 -- assign:adr.store:A: 
 fstoreg 8 address:storeg
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "X.print "
 -- INV:gen: "X.print " 
 -- needorigin: "X.print " 
 -- needOrigin:E: "print "  E.ATd: 
 --  print:: 
 --     "Joule".print
 --  Ex: "print " rec: "X " E.ATd: 
 --  print:: 
 --     "Joule".print
 --  E.ATd.desc: ""Joule".print " E.ATd.IT: ""Joule".print " 
 -- doNeedOrigin:Ex: "print "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- origin:isValueObj: "Joule "
 -- after:needOrigin: "print " 
 -- doNeedOrigin:E: "print " 
 -- computeAdrX:superAdj: 0 "X.print " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "X " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "X " rec: "X " E: "print " 
 --  A.E: "X "
 --  
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "X " rec: "X " E: "print " 
 --  rec.ATd: "X: var Energy.Joule " rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  M: var Mass.KiloGram
 --     A: var Area.SquareMeter
 --     R: var AngularAcceleration.RadiansPerSecondSquared
 --     X: var Energy.Joule
 --  recA: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X":rec:- 
 --  pRecA: none 
 -- pRec: "X " rec: "X " E: "print " 
 --  false true 
 -- computeAdrX:before:rec:: "X " 
 -- OI:invoke:before:ATdx.invoke: var X 
 -- DI:invoke: "X: var Energy.Joule " 
 -- isValueObj:isAdr: true objSize: 2  rec "X ",E: "print ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 -- Address:loadAdr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain "print " cmpAndSwap: false rec: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 -- OI:invoke:X: adr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 -- computeAdrX:after:rec.invoke: "X " 
 -- computeAdrX:isLast:E:  "print "
 -- originIsValueObj: 
 --  M: var Mass.KiloGram
 --  A: var Area.SquareMeter
 --  R: var AngularAcceleration.RadiansPerSecondSquared
 --  X: var Energy.Joule
 -- rec = E: false 0 
 -- call:mkValueProxy false true 
 -- mkValueProxy:INV: "X.print " E: "print " rec: "X " E.ATd: 
 --  print:: 
 --     "Joule".print
 --  
 -- CreateProxyW:E: "print "E.ATd.origin.encOG:OGid "Joule "
 --  origin:descNo: 81 "Energy ""X.print " 
 --  rec.ATd: "X: var Energy.Joule "rec.ATd.newOff: 8 0 
 rdouble 0
 -- son: "X " 
 -- son: "print " 
 -- recOfE: "X "recOfE.ATd: "X: var Energy.Joule " 
 -- first: "Energy "ObjectInvocation_Unary first.origin.encOG: "
 --  energyCombinations "
 -- items:goOrigin:encOG: "energyCombinations "on: 1 isValueObj: 
 --  false 
 --  origin: UnitIssues origin:isValueObj: false 
 rpushg energyCombinations$137 1
 -- items:goOrigin:encOG: "UnitIssues "on: 2 isValueObj: false 
 --  origin: workspace origin:isValueObj: false 
 rpushg UnitIssues$128 1
 -- items:goOrigin:encOG: "workspace "on: 1 isValueObj: false 
 --  origin: BETAworld origin:isValueObj: false 
 rpushg workspace$127 1
 rpushg LIB 3
 rpushg Dimensions 4
 -- after:Ey.loadOrigin: 
 -- Adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- Address:loadAdr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rpushg EisNone 4
 -- after:A.loadAdr 
 mkValueProxy 81 7
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 --  rec:  "X "E:  "print "
 -- INV:gen:E.loadArgs "print "
 -- INV:gen:after:E.loadArgs "print "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print "
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 rec: "X " 
 --  
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 invoke print 83 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- OI:invoke:V: adr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 -- OI:invoke:X: adr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 -- INV:gen:end:off: 8 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:X 
 -- OG:before:super.gen: "newline "
 -- INV:gen: "newline " 
 -- needorigin: "newline " 
 -- needOrigin:E: "newline "  E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  Ex: "newline " rec: "newline " E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  E.ATd.desc: 
 --  %globals
 --  put(10)
 --  E.ATd.IT: 
 --  %globals
 --  put(10)
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %globals
 --     put(10)
 --  
 -- after:needOrigin: "newline " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "newline "E:  "newline "
 -- INV:gen:E.loadArgs "newline "
 -- INV:gen:after:E.loadArgs "newline "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "newline "
 -- OI:invoke:before:ATdx.invoke: pattern newline 
 -- ptn:invoke: "newline "E: "newline "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "newline " 
 --  adr:none 
 invoke newline 130 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:9 isIndexed:0

 CLASS KiloGram 138 0 Mass 99 isValueObj
 -- vdtTableCopy: I:1:40 V:2:0 V:3:0 V:4:0 V:5:0 V:6:0 V:7:49 V:8:50 V:9:51
 -- super Unit
 -- DI:gen: "magnitude: var Float " DI:isConst: false isBasicValue: 
 --  true primNo: 9 
 -- DI:gen:primitiveType: magnitude 
 rtnAlloc 1
 toSuper 40
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS print 140 1 KiloGram 138
 -- vdtTableCopy: I:1:51 I:2:0
 tstOriginIsNone 
 rstore  1 origin
 -- super print
 pushThis 
 rpushg iOrigin 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 rtnAlloc 1
 toSuper 51
DO:
 mvStack 
 L1:
 -- OG:before:super.gen: ""kg".print "
 -- INV:gen: ""kg".print " 
 -- needorigin: ""kg".print " 
 -- needOrigin:E: "print "  E.ATd: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeatEx: ""kg" " rec: ""kg" " E.ATd: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeatE.ATd.desc: 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])E.ATd.IT: 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- after:needOrigin: ""kg" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  ""kg" "E:  ""kg" "
 -- INV:gen:E.loadArgs ""kg" "
 -- INV:gen:after:E.loadArgs ""kg" "
 --  OIadr: 
 pushText "kg"
 -- IV:gen:checkTail: ""kg".print "E: ""kg" "tail: "print "
 --   not isLast: false 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: ""kg" " 
 --  adr:none 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0

 CLASS + 141 1 String 10
 pushThis 
 rstoreg  S 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in S: var String " DI:isConst: false isBasicValue: 
 --  false primNo: 5 
 -- DI:gen: "out V: var String " DI:isConst: false isBasicValue: 
 --  false primNo: 5 
 -- DI:StringVar "out V: var String "
 pushText ""
 pushThis 
 rstoreg  V 3
   ;; vTop(0,0)=[] rTop(-3,0)=[]
 -- DI:gen: "L: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: L 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "L := Length " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "L := Length " right.label: "ObjectGenerator ""Length " 
 -- OG:before:super.gen: "Length "
 -- INV:gen: "Length " 
 -- needorigin: "Length " 
 -- needOrigin:E: "Length "  E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  Ex: "Length " rec: "Length " E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  E.ATd.desc: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  E.ATd.IT: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- doNeedOrigin:Ex: "Length "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "Length " 
 -- doNeedOrigin:E: "Length " 
 -- computeAdrX:superAdj: 0 "Length " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Length " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "+ "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg +$141 1
 -- computeAdrX:isLast:E:  "Length "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:- 
 --  rec:  "Length "E:  "Length "
 -- INV:gen:E.loadArgs "Length "
 -- INV:gen:after:E.loadArgs "Length "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "Length "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- ptn:invoke: "length "E: "Length "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "Length " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 -- assign:adr.store:A: 
 storeg +$141 4
 -- assign:adr.store:B: 
 pushThis 
 -- before objTmpStack:add:  142   "doplus "
 invoke doplus 142 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS doplus 142 1 + 141
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "e: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: e 
 -- DI:gen: "i: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: i 
 -- DI:gen: "T: obj Indexed(L + S.length,Integer) " DI:isConst: true 
 --  isBasicValue: false primNo: 114 
 -- DI:isConst: T 
 -- DI:off: 4 this: "T: obj Indexed(L + S.length,Integer) " 
 --  
 -- OG:before:super.gen: "Indexed(L + S.length,Integer) "
 -- INV:gen: "Indexed(L + S.length,Integer) " 
 -- needorigin: "Indexed(L + S.length,Integer) " 
 -- needOrigin:E: "Indexed(L + S.length,Integer) "  E.ATd: 
 --  Indexed: 
 --     %globals
 --     %basic 114
 --     %publicEx: "Indexed(L + S.length,Integer) " rec: "
 --  Indexed(L + S.length,Integer) " E.ATd: 
 --  Indexed: 
 --     %globals
 --     %basic 114
 --     %publicE.ATd.desc: 
 --  %globals
 --  %basic 114
 --  %public
 --  in range: var IntegerE.ATd.IT: 
 --  %globals
 --  %basic 114
 --  %public
 --  in range: var Integer
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %globals
 --     %basic 114
 --     %public
 --     in range: var Integer
 -- after:needOrigin: "Indexed(L + S.length,Integer) " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "Indexed(L + S.length,Integer) "E:  "
 --  Indexed(L + S.length,Integer) "
 -- INV:gen:E.loadArgs "Indexed(L + S.length,Integer) "
 -- NonVirt: "Indexed(L + S.length,Integer) " "
 --  ObjectInvocation_Function " ActArg: "L + S.length "isValue: false formalArg: "
 --  in range: var Integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "Indexed(L + S.length,Integer) "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "L + S.length "
 -- INV:gen: "L + S.length " 
 -- needorigin: "L + S.length " 
 -- needOrigin:E: "L + S.length "  E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  Ex: "L + S.length " rec: "L + S.length " E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  E.ATd.desc: 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 --  E.ATd.IT: 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 -- \
 --   
 -- doNeedOrigin:Ex: "L + S.length "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "L + S.length " 
 -- doNeedOrigin:E: "L + S.length " 
 -- computeAdrX:superAdj: 0 "L + S.length " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L + S.length " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "L + S.length "superAdj: 0 
 -- computeAdrX:isLast:E:  "L + S.length "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "L + S.length "E:  "L + S.length "
 -- INV:gen:E.loadArgs "L + S.length "
 -- BinaryExp:loadArgs: "L + S.length " superAdj: 0 
 -- INV:gen: "L " 
 -- needorigin: "L " 
 -- needOrigin:E: "L "  E.ATd: "L: var integer " Ex: "L " rec: "L " 
 --  E.ATd: "L: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L " 
 -- doNeedOrigin:E: "L " 
 -- computeAdrX:superAdj: 0 "L " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "doplus "on: 1 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$142 1
 -- computeAdrX:isLast:E:  "L "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 --  rec:  "L "E:  "L "
 -- INV:gen:E.loadArgs "L "
 -- INV:gen:after:E.loadArgs "L "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- DI:invoke: "L: var integer " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L isNotRemote: true 
 pushg 4 +$141
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:end:off: 4 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- NonVirt: "+ S.length " "ObjectInvocation_Binary " ActArg: "
 --  S.length "isValue: false formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ S.length " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "S.length "
 -- INV:gen: "S.length " 
 -- needorigin: "S.length " 
 -- needOrigin:E: "length "  E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  Ex: "length " rec: "S " E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  E.ATd.desc: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  E.ATd.IT: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- doNeedOrigin:Ex: "length "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "length " 
 -- doNeedOrigin:E: "length " 
 -- computeAdrX:superAdj: 0 "S.length " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "S " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "doplus "on: 1 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$142 1
 -- computeAdrX:En: 2 pRec: "S " rec: "S " E: "length " 
 --  A.E: none 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "S " rec: "S " E: "length " 
 --  rec.ATd: "in S: var String " rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  in S: var String
 --     out V: var String
 --     L: var integer
 --     L := Length
 --  recA: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 --  pRecA: none 
 -- pRec: "S " rec: "S " E: "length " 
 --  false false 
 -- computeAdrX:before:rec:: "S " 
 -- OI:invoke:before:ATdx.invoke: var S 
 -- DI:invoke: "in S: var String " 
 -- >Object:unique: false 
 -- Address:loadAdr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 rpushg doplus$142 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- computeAdrX:after:rec.invoke: "S " 
 -- computeAdrX:isLast:E:  "length "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 --  rec:  "S "E:  "length "
 -- INV:gen:E.loadArgs "length "
 -- INV:gen:after:E.loadArgs "length "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- ptn:invoke: "length "E: "length "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "S " 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "S.length ":isBasicVal: true 
 -- case:B: S.length ObjectGenerator 1 0 0 false false 
 -- end:loadArgs:NonVirt: "+ S.length "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:after:E.loadArgs "L + S.length "
 --  OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L + S.length "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- BinaryExp:invoke: "L "rec: "L + S.length "
 -- M: "+ S.length "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- ptn:invoke: "+   "E: "+ S.length "ptnKind: 0 useRtnV: true 
 plus
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ S.length":rec:L 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ S.length":rec:L 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in range: var Integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "L + S.length ":isBasicVal: true 
 -- case:B: L + S.length ObjectGenerator 1 61 61 false false 
 -- end:loadArgs:NonVirt: "Indexed(L + S.length,Integer) "
 -- INV:gen:after:E.loadArgs "Indexed(L + S.length,Integer) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Function "
 --  Indexed(L + S.length,Integer) "
 -- OI:invoke:before:ATdx.invoke: pattern Indexed 
 -- ptn:invoke: "Indexed "E: "Indexed(L + S.length,Integer) "
 --  ptnKind: 0 useRtnV: false 
 pushThis 
 pushc 1
 allocIndexed doplus$142 143 1 0
 pushThis 
 rstoreg  doplus$142 4
   ;; vTop(2,2)=[0/0,0/0] rTop(-4,0)=[]
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 pushThis 
 -- before objTmpStack:add:  147   "for:to:repeat$147 "
 invoke for:to:repeat$147 147 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  149   "for:to:repeat$149 "
 invoke for:to:repeat$149 149 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- AssignmentStatement:gen: 
 --  V := T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 pushThis 
 -- items:goOrigin:encOG: "doplus "on: 1 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$142 1
 -- AssignmentStatement:gen: 
 --  
 --  V := T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  right.label: "ObjectGenerator "
 --  T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- OG:before:super.gen: "
 --  T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "
 -- INV:gen: 
 --  T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- needorigin: 
 --  T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- needOrigin:E: 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --   E.ATd: 
 --  asString: 
 --     %basic 118
 --     out S: var LIB.StringLib.String
 --  Ex: 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  rec: "T " E.ATd: 
 --  asString: 
 --     %basic 118
 --     out S: var LIB.StringLib.String
 --  E.ATd.desc: 
 --  %basic 118
 -- \
 --   out S: var LIB.StringLib.String
 --  E.ATd.IT: 
 --  %basic 118
 --  out S: var LIB.StringLib.String
 --  
 -- doNeedOrigin:Ex: "
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- doNeedOrigin:E: 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- computeAdrX:superAdj: 0 
 --  T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- computeAdrX:En: 1 pRec: none rec: none E: "T " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "T " rec: "T " E: 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 --  A.E: none 
 --  
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "T " rec: "T " E: 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 --  rec.ATd: "T: obj Indexed(L + S.length,Integer) " 
 --  rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  e: var integer
 --     i: var integer
 --     T: obj Indexed(L + S.length,Integer)
 --     for(1):to(L):repeat
 --  recA: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:- 
 --  pRecA: none 
 -- pRec: "T " rec: "T " E: 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 --  false false 
 -- computeAdrX:before:rec:: "T " 
 -- OI:invoke:before:ATdx.invoke: obj T 
 -- DI:invoke: "T: obj Indexed(L + S.length,Integer) " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:T isNotRemote: false 
 rpushg doplus$142 4
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:T 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:T 
 -- computeAdrX:after:rec.invoke: "T " 
 -- computeAdrX:isLast:E:  "
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:T 
 --  rec:  "T "E:  "
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "
 -- INV:gen:E.loadArgs "
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "
 -- INV:gen:after:E.loadArgs "
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:T 
 -- OI:invoke:before:ATdx.invoke: pattern asString 
 -- ptn:invoke: "asString "E: "
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "ptnKind: 0 useRtnV: true 
 %asString 118
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:T 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:T 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:T 
 -- assign:adr.store:A: 
 rswap 0
 rstoreg  EisNone 3
   ;; vTop(2,2)=[0/0,0/0] rTop(-8,0)=[]
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS Indexed 143 0 BETA 2
 pushThis 
 storeg integer$5 1
 allocEventQ
 mvStack 
 -- DI:gen: "in range: var Integer " DI:isConst: false isBasicValue: 
 --  true primNo: 1 
 -- DI:gen:primitiveType: range 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:1

 CLASS repeat$145 145 1 for:to:repeat$147 147
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "e := get[inx] " 
 pushThis 
 -- items:goOrigin:encOG: "repeat$145 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$147 origin:isValueObj: false 
 rpushg repeat$145$145 1
 -- items:goOrigin:encOG: "for:to:repeat$147 "on: 1 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$147$147 4
 -- AssignmentStatement:gen: 
 --  "e := get[inx] " right.label: "ObjectGenerator ""get[inx] " 
 -- OG:before:super.gen: "get[inx] "
 -- INV:gen: "get[inx] " 
 -- needorigin: "get[inx] " 
 -- needOrigin:E: "get[inx] "  E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  Ex: "get[inx] " rec: "get[inx] " E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  E.ATd.desc: 
 --  %basic 117
 --  out ch: var char
 --  E.ATd.IT: 
 --  %basic 117
 --  out ch: var char
 --  
 -- doNeedOrigin:Ex: "get[inx] "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "get[inx] " 
 -- doNeedOrigin:E: "get[inx] " 
 -- computeAdrX:superAdj: 0 "get[inx] " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "get[inx] " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$145 "on: 4 isValueObj: false 
 --  origin: for:to:repeat$147 origin:isValueObj: false 
 rpushg repeat$145$145 1
 -- items:goOrigin:encOG: "for:to:repeat$147 "on: 3 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$147$147 4
 -- items:goOrigin:encOG: "doplus "on: 2 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$142 1
 -- items:goOrigin:encOG: "+ "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg +$141 1
 -- computeAdrX:isLast:E:  "get[inx] "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 --  rec:  "get[inx] "E:  "get[inx] "
 -- INV:gen:E.loadArgs "get[inx] "
 -- NonVirt: "get[inx] " "ObjectInvocation_KeyWord " ActArg: "inx "
 --  isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx] " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "inx "
 -- INV:gen: "inx " 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$145 "on: 1 isValueObj: false 
 --  origin: for:to:repeat$147 origin:isValueObj: false 
 rpushg repeat$145$145 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 3 for:to:repeat$147$147
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "get[inx] "
 -- INV:gen:after:E.loadArgs "get[inx] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx] "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- ptn:invoke: "get[inx: var integer] "E: "get[inx] "ptnKind: 0 
 --  useRtnV: true 
 xpushg  inx 1 0 1
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- assign:adr.store:A: 
 storeg doplus$142 2
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "T.put(e):at[inx] "
 -- INV:gen: "T.put(e):at[inx] " 
 -- needorigin: "T.put(e):at[inx] " 
 -- needOrigin:E: "put(e):at[inx] "  E.ATd: 
 --  put(V: var integer):at[inx: var integer]: 
 --     %basic 115
 --  Ex: "put(e):at[inx] " rec: "T " E.ATd: 
 --  put(V: var integer):at[inx: var integer]: 
 --     %basic 115
 --  E.ATd.desc: "%basic 115 " E.ATd.IT: "%basic 115 " 
 -- doNeedOrigin:Ex: "put(e):at[inx] "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "put(e):at[inx] " 
 -- doNeedOrigin:E: "put(e):at[inx] " 
 -- computeAdrX:superAdj: 0 "T.put(e):at[inx] " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "T " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$145 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$147 origin:isValueObj: false 
 rpushg repeat$145$145 1
 -- items:goOrigin:encOG: "for:to:repeat$147 "on: 1 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$147$147 4
 -- computeAdrX:En: 2 pRec: "T " rec: "T " E: "put(e):at[inx] " 
 --  A.E: none 
 --  
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "T " rec: "T " E: "
 --  put(e):at[inx] " 
 --  rec.ATd: "T: obj Indexed(L + S.length,Integer) " 
 --  rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  e: var integer
 --     i: var integer
 --     T: obj Indexed(L + S.length,Integer)
 --     for(1):to(L):repeat
 --  recA: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:- 
 --  pRecA: none 
 -- pRec: "T " rec: "T " E: "put(e):at[inx] " 
 --  false false 
 -- computeAdrX:before:rec:: "T " 
 -- OI:invoke:before:ATdx.invoke: obj T 
 -- DI:invoke: "T: obj Indexed(L + S.length,Integer) " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T isNotRemote: false 
 rpushg repeat$145$145 4
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- computeAdrX:after:rec.invoke: "T " 
 -- computeAdrX:isLast:E:  "put(e):at[inx] "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 --  rec:  "T "E:  "put(e):at[inx] "
 -- INV:gen:E.loadArgs "put(e):at[inx] "
 -- NonVirt: "put(e):at[inx] " "ObjectInvocation_KeyWord " ActArg: "e "
 --  isValue: false formalArg: "V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(e):at[inx] "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "e "
 -- INV:gen: "e " 
 -- needorigin: "e " 
 -- needOrigin:E: "e "  E.ATd: "e: var integer " Ex: "e " rec: "e " 
 --  E.ATd: "e: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "e " 
 -- doNeedOrigin:E: "e " 
 -- computeAdrX:superAdj: 0 "e " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "e " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$145 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$147 origin:isValueObj: false 
 rpushg repeat$145$145 1
 -- items:goOrigin:encOG: "for:to:repeat$147 "on: 1 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$147$147 4
 -- computeAdrX:isLast:E:  "e "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 --  rec:  "e "E:  "e "
 -- INV:gen:E.loadArgs "e "
 -- INV:gen:after:E.loadArgs "e "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "e "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- OI:invoke:before:ATdx.invoke: var e 
 -- DI:invoke: "e: var integer " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e isNotRemote: true 
 pushg 2 doplus$142
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- actualArg:isPtn: false formalArg:isPtn: "V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "e ":isBasicVal: true 
 -- case:B: e ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "put(e):at[inx] "
 -- NonVirt: "put(e):at[inx] " "ObjectInvocation_KeyWord " ActArg: "
 --  inx "isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(e):at[inx] "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "inx "
 -- INV:gen: "inx " 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$145 "on: 1 isValueObj: false 
 --  origin: for:to:repeat$147 origin:isValueObj: false 
 rpushg repeat$145$145 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 3 for:to:repeat$147$147
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "put(e):at[inx] "
 -- INV:gen:after:E.loadArgs "put(e):at[inx] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  put(e):at[inx] "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- OI:invoke:before:ATdx.invoke: pattern 
 --  put(V: var integer):at[inx: var integer] 
 -- ptn:invoke: "put(V: var integer):at[inx: var integer] "E: "
 --  put(e):at[inx] "ptnKind: 0 useRtnV: false 
 xstoreg  inx 1 0 1
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS for:to:repeat$147 147 4 doplus 142
 -- vdtTableCopy: I:1:28 V:2:29
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- NonVirt: 
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --  "ObjectInvocation_KeyWord " ActArg: "1 "isValue: true formalArg: "
 --  first: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --   " isCompositeValueObj: false 
 -- OG:before:super.gen: "1 "
 -- INV:gen: "1 " 
 -- needorigin: "1 " 
 -- needOrigin:E: "1 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "1 " rec: "1 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "1 " 
 -- IV:after:computeAdr:superAdj: 4 
 --  rec:  "1 "E:  "1 "
 -- INV:gen:E.loadArgs "1 "
 -- INV:gen:after:E.loadArgs "1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1 "
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "first: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- end:loadArgs:NonVirt: "
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --   "
 -- NonVirt: 
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --  "ObjectInvocation_KeyWord " ActArg: "L "isValue: false 
 --  formalArg: "last: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --   " isCompositeValueObj: false 
 -- OG:before:super.gen: "L "
 -- INV:gen: "L " 
 -- needorigin: "L " 
 -- needOrigin:E: "L "  E.ATd: "L: var integer " Ex: "L " rec: "L " 
 --  E.ATd: "L: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L " 
 -- doNeedOrigin:E: "L " 
 -- computeAdrX:superAdj: 4 "L " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 rpushg doplus$142 4
 -- items:goOrigin:encOG: "doplus "on: 1 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$142 1
 -- computeAdrX:isLast:E:  "L "
 -- IV:after:computeAdr:superAdj: 4 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 --  rec:  "L "E:  "L "
 -- INV:gen:E.loadArgs "L "
 -- INV:gen:after:E.loadArgs "L "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- DI:invoke: "L: var integer " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L isNotRemote: true 
 pushg 4 +$141
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- actualArg:isPtn: false formalArg:isPtn: "last: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "L ":isBasicVal: true 
 -- case:B: L ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --   "
 pushThis 
 storeg integer$5 2
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- DI:gen: "inx: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: inx 
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0

 CLASS repeat$148 148 1 for:to:repeat$149 149
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "e := S.get[inx] " 
 pushThis 
 -- items:goOrigin:encOG: "repeat$148 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$149 origin:isValueObj: false 
 rpushg repeat$148$148 1
 -- items:goOrigin:encOG: "for:to:repeat$149 "on: 1 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$149$149 4
 -- AssignmentStatement:gen: 
 --  "e := S.get[inx] " right.label: "ObjectGenerator ""S.get[inx] " 
 -- OG:before:super.gen: "S.get[inx] "
 -- INV:gen: "S.get[inx] " 
 -- needorigin: "S.get[inx] " 
 -- needOrigin:E: "get[inx] "  E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  Ex: "get[inx] " rec: "S " E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  E.ATd.desc: 
 --  %basic 117
 --  out ch: var char
 --  E.ATd.IT: 
 --  %basic 117
 --  out ch: var char
 --  
 -- doNeedOrigin:Ex: "get[inx] "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "get[inx] " 
 -- doNeedOrigin:E: "get[inx] " 
 -- computeAdrX:superAdj: 0 "S.get[inx] " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "S " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$148 "on: 3 isValueObj: false 
 --  origin: for:to:repeat$149 origin:isValueObj: false 
 rpushg repeat$148$148 1
 -- items:goOrigin:encOG: "for:to:repeat$149 "on: 2 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$149$149 4
 -- items:goOrigin:encOG: "doplus "on: 1 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$142 1
 -- computeAdrX:En: 2 pRec: "S " rec: "S " E: "get[inx] " 
 --  A.E: none 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "S " rec: "S " E: "get[inx] " 
 --  rec.ATd: "in S: var String " rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  in S: var String
 --     out V: var String
 --     L: var integer
 --     L := Length
 --  recA: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 --  pRecA: none 
 -- pRec: "S " rec: "S " E: "get[inx] " 
 --  false false 
 -- computeAdrX:before:rec:: "S " 
 -- OI:invoke:before:ATdx.invoke: var S 
 -- DI:invoke: "in S: var String " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S isNotRemote: false 
 rpushg repeat$148$148 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- computeAdrX:after:rec.invoke: "S " 
 -- computeAdrX:isLast:E:  "get[inx] "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 --  rec:  "S "E:  "get[inx] "
 -- INV:gen:E.loadArgs "get[inx] "
 -- NonVirt: "get[inx] " "ObjectInvocation_KeyWord " ActArg: "inx "
 --  isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx] " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "inx "
 -- INV:gen: "inx " 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$148 "on: 1 isValueObj: false 
 --  origin: for:to:repeat$149 origin:isValueObj: false 
 rpushg repeat$148$148 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 3 for:to:repeat$149$149
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "get[inx] "
 -- INV:gen:after:E.loadArgs "get[inx] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx] "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- ptn:invoke: "get[inx: var integer] "E: "get[inx] "ptnKind: 0 
 --  useRtnV: true 
 xpushg  inx 1 0 1
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- assign:adr.store:A: 
 storeg doplus$142 2
 -- assign:adr.store:B: 
 -- AssignmentStatement:gen: "i := L + inx " 
 pushThis 
 -- items:goOrigin:encOG: "repeat$148 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$149 origin:isValueObj: false 
 rpushg repeat$148$148 1
 -- items:goOrigin:encOG: "for:to:repeat$149 "on: 1 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$149$149 4
 -- AssignmentStatement:gen: 
 --  "i := L + inx " right.label: "ObjectGenerator ""L + inx " 
 -- OG:before:super.gen: "L + inx "
 -- INV:gen: "L + inx " 
 -- needorigin: "L + inx " 
 -- needOrigin:E: "L + inx "  E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  Ex: "L + inx " rec: "L + inx " E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  E.ATd.desc: 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 --  E.ATd.IT: 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 -- \
 --   
 -- doNeedOrigin:Ex: "L + inx "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "L + inx " 
 -- doNeedOrigin:E: "L + inx " 
 -- computeAdrX:superAdj: 0 "L + inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L + inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "L + inx "superAdj: 0 
 -- computeAdrX:isLast:E:  "L + inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "L + inx "E:  "L + inx "
 -- INV:gen:E.loadArgs "L + inx "
 -- BinaryExp:loadArgs: "L + inx " superAdj: 0 
 -- INV:gen: "L " 
 -- needorigin: "L " 
 -- needOrigin:E: "L "  E.ATd: "L: var integer " Ex: "L " rec: "L " 
 --  E.ATd: "L: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L " 
 -- doNeedOrigin:E: "L " 
 -- computeAdrX:superAdj: 0 "L " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$148 "on: 3 isValueObj: false 
 --  origin: for:to:repeat$149 origin:isValueObj: false 
 rpushg repeat$148$148 1
 -- items:goOrigin:encOG: "for:to:repeat$149 "on: 2 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$149$149 4
 -- items:goOrigin:encOG: "doplus "on: 1 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$142 1
 -- computeAdrX:isLast:E:  "L "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 --  rec:  "L "E:  "L "
 -- INV:gen:E.loadArgs "L "
 -- INV:gen:after:E.loadArgs "L "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- DI:invoke: "L: var integer " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L isNotRemote: true 
 pushg 4 +$141
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:end:off: 4 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- NonVirt: "+ inx " "ObjectInvocation_Binary " ActArg: "inx "
 --  isValue: false formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ inx " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "inx "
 -- INV:gen: "inx " 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$148 "on: 1 isValueObj: false 
 --  origin: for:to:repeat$149 origin:isValueObj: false 
 rpushg repeat$148$148 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 3 for:to:repeat$149$149
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "+ inx "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:after:E.loadArgs "L + inx "
 --  OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L + inx "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- BinaryExp:invoke: "L "rec: "L + inx "
 -- M: "+ inx "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- ptn:invoke: "+   "E: "+ inx "ptnKind: 0 useRtnV: true 
 plus
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ inx":rec:L 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ inx":rec:L 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 storeg doplus$142 3
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "T.put(e):at[i] "
 -- INV:gen: "T.put(e):at[i] " 
 -- needorigin: "T.put(e):at[i] " 
 -- needOrigin:E: "put(e):at[i] "  E.ATd: 
 --  put(V: var integer):at[inx: var integer]: 
 --     %basic 115
 --  Ex: "put(e):at[i] " rec: "T " E.ATd: 
 --  put(V: var integer):at[inx: var integer]: 
 --     %basic 115
 --  E.ATd.desc: "%basic 115 " E.ATd.IT: "%basic 115 " 
 -- doNeedOrigin:Ex: "put(e):at[i] "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "put(e):at[i] " 
 -- doNeedOrigin:E: "put(e):at[i] " 
 -- computeAdrX:superAdj: 0 "T.put(e):at[i] " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "T " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$148 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$149 origin:isValueObj: false 
 rpushg repeat$148$148 1
 -- items:goOrigin:encOG: "for:to:repeat$149 "on: 1 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$149$149 4
 -- computeAdrX:En: 2 pRec: "T " rec: "T " E: "put(e):at[i] " 
 --  A.E: none 
 --  
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "T " rec: "T " E: "put(e):at[i] " 
 --  rec.ATd: "T: obj Indexed(L + S.length,Integer) " 
 --  rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  e: var integer
 --     i: var integer
 --     T: obj Indexed(L + S.length,Integer)
 --     for(1):to(L):repeat
 --  recA: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:- 
 --  pRecA: none 
 -- pRec: "T " rec: "T " E: "put(e):at[i] " 
 --  false false 
 -- computeAdrX:before:rec:: "T " 
 -- OI:invoke:before:ATdx.invoke: obj T 
 -- DI:invoke: "T: obj Indexed(L + S.length,Integer) " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T isNotRemote: false 
 rpushg repeat$148$148 4
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- computeAdrX:after:rec.invoke: "T " 
 -- computeAdrX:isLast:E:  "put(e):at[i] "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 --  rec:  "T "E:  "put(e):at[i] "
 -- INV:gen:E.loadArgs "put(e):at[i] "
 -- NonVirt: "put(e):at[i] " "ObjectInvocation_KeyWord " ActArg: "e "
 --  isValue: false formalArg: "V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(e):at[i] "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "e "
 -- INV:gen: "e " 
 -- needorigin: "e " 
 -- needOrigin:E: "e "  E.ATd: "e: var integer " Ex: "e " rec: "e " 
 --  E.ATd: "e: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "e " 
 -- doNeedOrigin:E: "e " 
 -- computeAdrX:superAdj: 0 "e " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "e " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$148 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$149 origin:isValueObj: false 
 rpushg repeat$148$148 1
 -- items:goOrigin:encOG: "for:to:repeat$149 "on: 1 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$149$149 4
 -- computeAdrX:isLast:E:  "e "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 --  rec:  "e "E:  "e "
 -- INV:gen:E.loadArgs "e "
 -- INV:gen:after:E.loadArgs "e "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "e "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- OI:invoke:before:ATdx.invoke: var e 
 -- DI:invoke: "e: var integer " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e isNotRemote: true 
 pushg 2 doplus$142
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- actualArg:isPtn: false formalArg:isPtn: "V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "e ":isBasicVal: true 
 -- case:B: e ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "put(e):at[i] "
 -- NonVirt: "put(e):at[i] " "ObjectInvocation_KeyWord " ActArg: "i "
 --  isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(e):at[i] "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "i "
 -- INV:gen: "i " 
 -- needorigin: "i " 
 -- needOrigin:E: "i "  E.ATd: "i: var integer " Ex: "i " rec: "i " 
 --  E.ATd: "i: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "i " 
 -- doNeedOrigin:E: "i " 
 -- computeAdrX:superAdj: 0 "i " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "i " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$148 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$149 origin:isValueObj: false 
 rpushg repeat$148$148 1
 -- items:goOrigin:encOG: "for:to:repeat$149 "on: 1 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$149$149 4
 -- computeAdrX:isLast:E:  "i "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 --  rec:  "i "E:  "i "
 -- INV:gen:E.loadArgs "i "
 -- INV:gen:after:E.loadArgs "i "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "i "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- OI:invoke:before:ATdx.invoke: var i 
 -- DI:invoke: "i: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i isNotRemote: true 
 pushg 3 doplus$142
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "i ":isBasicVal: true 
 -- case:B: i ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "put(e):at[i] "
 -- INV:gen:after:E.loadArgs "put(e):at[i] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  put(e):at[i] "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- OI:invoke:before:ATdx.invoke: pattern 
 --  put(V: var integer):at[inx: var integer] 
 -- ptn:invoke: "put(V: var integer):at[inx: var integer] "E: "
 --  put(e):at[i] "ptnKind: 0 useRtnV: false 
 xstoreg  inx 1 0 1
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS for:to:repeat$149 149 4 doplus 142
 -- vdtTableCopy: I:1:28 V:2:29
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- NonVirt: 
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]"ObjectInvocation_KeyWord " ActArg: "1 "isValue: true formalArg: "
 --  first: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 --   " isCompositeValueObj: false 
 -- OG:before:super.gen: "1 "
 -- INV:gen: "1 " 
 -- needorigin: "1 " 
 -- needOrigin:E: "1 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "1 " rec: "1 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "1 " 
 -- IV:after:computeAdr:superAdj: 4 
 --  rec:  "1 "E:  "1 "
 -- INV:gen:E.loadArgs "1 "
 -- INV:gen:after:E.loadArgs "1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1 "
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "first: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- end:loadArgs:NonVirt: "
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 --   "
 -- NonVirt: 
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]"ObjectInvocation_KeyWord " ActArg: "S.length "isValue: false 
 --  formalArg: "last: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 --   " isCompositeValueObj: false 
 -- OG:before:super.gen: "S.length "
 -- INV:gen: "S.length " 
 -- needorigin: "S.length " 
 -- needOrigin:E: "length "  E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  Ex: "length " rec: "S " E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  E.ATd.desc: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  E.ATd.IT: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- doNeedOrigin:Ex: "length "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "length " 
 -- doNeedOrigin:E: "length " 
 -- computeAdrX:superAdj: 4 "S.length " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "S " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 rpushg doplus$142 4
 -- items:goOrigin:encOG: "doplus "on: 1 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$142 1
 -- computeAdrX:En: 2 pRec: "S " rec: "S " E: "length " 
 --  A.E: none 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "S " rec: "S " E: "length " 
 --  rec.ATd: "in S: var String " rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  in S: var String
 --     out V: var String
 --     L: var integer
 --     L := Length
 --  recA: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 --  pRecA: none 
 -- pRec: "S " rec: "S " E: "length " 
 --  false false 
 -- computeAdrX:before:rec:: "S " 
 -- OI:invoke:before:ATdx.invoke: var S 
 -- DI:invoke: "in S: var String " 
 -- >Object:unique: false 
 -- Address:loadAdr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 rpushg doplus$142 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- computeAdrX:after:rec.invoke: "S " 
 -- computeAdrX:isLast:E:  "length "
 -- IV:after:computeAdr:superAdj: 4 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 --  rec:  "S "E:  "length "
 -- INV:gen:E.loadArgs "length "
 -- INV:gen:after:E.loadArgs "length "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- ptn:invoke: "length "E: "length "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "S " 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- actualArg:isPtn: true formalArg:isPtn: "last: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "S.length ":isBasicVal: true 
 -- case:B: S.length ObjectGenerator 1 0 0 false false 
 -- end:loadArgs:NonVirt: "
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 --   "
 pushThis 
 storeg integer$5 2
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- DI:gen: "inx: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: inx 
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0

 CLASS asString 150 1 Indexed 143
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "out S: var LIB.StringLib.String " DI:isConst: false 
 --  isBasicValue: false primNo: 5 
 -- DI:StringVar "out S: var LIB.StringLib.String "
 pushText ""
 pushThis 
 rstoreg  S 2
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS valProx 151 1 Object 0
 END OSDV:0 objSize:4 isIndexed:0

 CLASS VM 152 0 Object 0
 L1:
 pushThis 
 invoke BETAworld 1 0 1
 stop
 L2:
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS EventProcessor 153 0 Object 0
 stop
 END OSDV:0 objSize:1 isIndexed:0

 CLASS ThreadStub 154 0 Object 0
DO:
 call(D)ThreadStub
 stop
 END OSDV:0 objSize:1 isIndexed:0

Class BETAworld descInx:1 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	pushthis 
7:	saveBETAworld
8:	mvStack
allocE: 
9:	pushthis 
10:	invoke 2 2 1
16:	rpop 
17:	pushthis 
18:	invoke 33 3 1
24:	rpop 
25:	pushthis 
26:	invoke 127 4 1
32:	rpop 
33:	rtnAlloc 1
doE: 
35:	doEventQ 
36:	mvStack
37:	setThisStack
38:	pushthis 
39:	rtn D


Class BETA descInx:2 objSize:3 originOff: 1 visibility: 2
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 3 2 1
14:	rpop 
15:	rtnAlloc 1
doE: 
17:	doEventQ 
18:	mvStack
19:	setThisStack
20:	pushthis 
21:	rtn D


Class ascii descInx:3 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushc 10
9:	pushthis 
10:	storeg 2
12:	pushc 13
14:	pushthis 
15:	storeg 3
17:	pushc 0
19:	pushthis 
20:	storeg 4
22:	rtnAlloc 1
doE: 
24:	doEventQ 
25:	mvStack
26:	pushthis 
27:	pushc 10
29:	storeg 5
31:	setThisStack
32:	pushthis 
33:	rtn D


Class Value descInx:4 objSize:0 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	mvStack
allocE: 
2:	rtnAlloc 1
doE: 
4:	mvStack
5:	setThisStack
6:	pushthis 
7:	rtn D


Class integer descInx:5 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	mvStack
allocE: 
2:	rtnAlloc 1
doE: 
4:	mvStack
5:	setThisStack
6:	pushthis 
7:	rtn D


Class universal descInx:6 objSize:0 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	mvStack
allocE: 
2:	rtnAlloc 1
doE: 
4:	mvStack
5:	setThisStack
6:	pushthis 
7:	rtn D


Class char descInx:7 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	mvStack
allocE: 
2:	rtnAlloc 1
doE: 
4:	mvStack
5:	setThisStack
6:	pushthis 
7:	rtn D


Class ConsoleIF descInx:8 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class put descInx:9 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class String descInx:10 objSize:0 originOff: 0 visibility: 2
storeOrgAndArgsE:
1:	allocEventQ 1
3:	mvStack
allocE: 
4:	rtnAlloc 1
doE: 
6:	doEventQ 
7:	mvStack
8:	setThisStack
9:	pushthis 
10:	rtn D


Class = descInx:11 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	jmpFalse 13
4:	pushthis 
5:	vassign 4 2 0
10:	jmp 20
13:	invokeVal 31 3 0
19:	rpop 
20:	tstOriginNone 
21:	rstore 1
23:	allocEventQ 0
25:	mvStack
allocE: 
26:	rtnAlloc 1
doE: 
28:	doEventQ 
29:	mvStack
30:	pushthis 
31:	innerP 2
33:	rpopThisObj
34:	setThisStack
35:	pushthis 
36:	rtn D


Class = descInx:13 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	rshiftup 1
3:	tstOriginNone 
4:	rstore 1
6:	allocEventQ 0
8:	pushthis 
9:	rpushg 1
11:	rshiftdown 1
13:	pushthis 
14:	rstoreg 2
16:	tstOriginNone 
17:	rstore 1
19:	allocEventQ 0
21:	mvStack
allocE: 
doE: 
22:	doEventQ 
23:	mvStack
24:	pushthis 
25:	invoke 14 0 0
31:	rpop 
32:	setThisStack
33:	pushthis 
34:	rtn D


Class loop descInx:14 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	rpushg 1
17:	invoke 15 0 0
23:	pushg 2
25:	storeg 4
27:	pushthis 
28:	pushg 4
30:	pushthis 
31:	rpushg 1
33:	rpushg 2
35:	invoke 15 0 0
41:	pushg 2
43:	ne 
44:	jmpFalse 55
47:	pushthis 
48:	invoke 18 0 0
54:	rpop 
55:	pushthis 
56:	rpushg 1
58:	invoke 23 0 0
64:	pushg 1
66:	storeg 3
68:	pushthis 
69:	invoke 30 0 0
75:	rpop 
76:	setThisStack
77:	pushthis 
78:	rtn D


Class length descInx:15 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	pushc 0
17:	xpushg 1 0 1
21:	storeg 2
23:	setThisStack
24:	pushthis 
25:	rtn D


Class $18 descInx:18 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	break 1 2 14 0
18:	setThisStack
19:	pushthis 
20:	rtn D


Class if:then descInx:20 objSize:1 originOff: 0 visibility: 1
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class BETAworld descInx:21 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	innerP 2
14:	rpopThisObj
15:	setThisStack
16:	pushthis 
17:	rtn D


Class thenPart#22 descInx:22 objSize:3 originOff: 0 visibility: 1
storeOrgAndArgsE:
1:	invoke 21 0 0
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class True descInx:23 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
3:	mvStack
allocE: 
4:	rtnAlloc 1
doE: 
6:	doEventQ 
7:	mvStack
8:	pushthis 
9:	pushc 1
11:	storeg 1
13:	setThisStack
14:	pushthis 
15:	rtn D


Class repeat$24 descInx:24 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	pushthis 
17:	rpushg 1
19:	rpushg 4
21:	rpushg 1
23:	rpushg 1
25:	pushthis 
26:	rpushg 1
28:	pushg 3
30:	xpushg 1 0 1
34:	storeg 2
36:	pushthis 
37:	rpushg 1
39:	rpushg 4
41:	pushthis 
42:	rpushg 1
44:	rpushg 4
46:	rpushg 1
48:	rpushg 2
50:	pushthis 
51:	rpushg 1
53:	pushg 3
55:	xpushg 1 0 1
59:	storeg 3
61:	pushthis 
62:	rpushg 1
64:	rpushg 4
66:	pushg 2
68:	pushthis 
69:	rpushg 1
71:	rpushg 4
73:	pushg 3
75:	ne 
76:	jmpFalse 87
79:	pushthis 
80:	invoke 26 0 0
86:	rpop 
87:	setThisStack
88:	pushthis 
89:	rtn D


Class $26 descInx:26 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 4
18:	rpushg 1
20:	invoke 27 0 0
26:	pushg 1
28:	storeg 3
30:	break 3 2 14 0
37:	setThisStack
38:	pushthis 
39:	rtn D


Class False descInx:27 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
3:	mvStack
allocE: 
4:	rtnAlloc 1
doE: 
6:	doEventQ 
7:	mvStack
8:	pushthis 
9:	pushc 0
11:	storeg 1
13:	setThisStack
14:	pushthis 
15:	rtn D


Class for:to:repeat descInx:28 objSize:3 originOff: 0 visibility: 1
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 2
4:	pushthis 
5:	storeg 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	pushthis 
16:	pushg 1
18:	storeg 3
20:	pushthis 
21:	invoke 57 0 0
27:	rpop 
28:	setThisStack
29:	pushthis 
30:	rtn D


Class repeat#29 descInx:29 objSize:3 originOff: 0 visibility: 1
storeOrgAndArgsE:
1:	invoke 21 0 0
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class for:to:repeat$30 descInx:30 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	rpushg 1
13:	invoke 15 0 0
19:	pushg 2
21:	pushthis 
22:	storeg 2
24:	pushthis 
25:	storeg 1
27:	allocEventQ 0
allocE: 
29:	rtnAlloc 1
31:	toSuper 28
doE: 
34:	mvStack
35:	rtnInner


Class this descInx:31 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	setThisStack
15:	pushthis 
16:	rtn D


Class X_asString descInx:32 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushText 1
9:	pushthis 
10:	rstoreg 2
12:	rtnAlloc 1
doE: 
14:	doEventQ 
15:	mvStack
16:	pushthis 
17:	innerP 2
19:	rpopThisObj
20:	setThisStack
21:	pushthis 
22:	rtn D


Class LIB descInx:33 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 34 3 1
14:	rpop 
15:	pushthis 
16:	invoke 38 4 1
22:	rpop 
23:	pushthis 
24:	invoke 107 5 1
30:	rpop 
31:	rtnAlloc 1
doE: 
33:	doEventQ 
34:	mvStack
35:	setThisStack
36:	pushthis 
37:	rtn D


Class BasicIO descInx:34 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 35 2 1
14:	rpop 
15:	pushthis 
16:	invoke 36 3 1
22:	rpop 
23:	rtnAlloc 1
doE: 
25:	doEventQ 
26:	mvStack
27:	setThisStack
28:	pushthis 
29:	rtn D


Class keyboard descInx:35 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class screen descInx:36 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	rpushg 1
10:	invoke 37 2 1
16:	rpop 
17:	rtnAlloc 1
doE: 
19:	doEventQ 
20:	mvStack
21:	setThisStack
22:	pushthis 
23:	rtn D


Class Lock descInx:37 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class Dimensions descInx:38 objSize:8 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 66 2 1
14:	rpop 
15:	pushthis 
16:	invoke 70 3 1
22:	rpop 
23:	pushthis 
24:	invoke 76 4 1
30:	rpop 
31:	pushthis 
32:	invoke 84 5 1
38:	rpop 
39:	pushthis 
40:	invoke 89 6 1
46:	rpop 
47:	pushthis 
48:	invoke 99 7 1
54:	rpop 
55:	pushthis 
56:	invoke 100 8 1
62:	rpop 
63:	rtnAlloc 1
doE: 
65:	doEventQ 
66:	mvStack
67:	setThisStack
68:	pushthis 
69:	rtn D


Class Dimension descInx:39 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	innerP 8
14:	rpopThisObj
15:	setThisStack
16:	pushthis 
17:	rtn D


Class Unit descInx:40 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	mvStack
allocE: 
2:	rtnAlloc 1
doE: 
4:	mvStack
5:	setThisStack
6:	pushthis 
7:	rtn D


Class PrimaryUnit#44 descInx:44 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	invoke 40 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class MultArgL#45 descInx:45 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	invoke 40 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class MultArgR#46 descInx:46 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	invoke 40 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class MultRes#47 descInx:47 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	invoke 40 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class float descInx:48 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	mvStack
allocE: 
2:	rtnAlloc 1
doE: 
4:	mvStack
5:	setThisStack
6:	pushthis 
7:	rtn D


Class toPrimary descInx:49 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	invokeVal 40 1 0
13:	rpop 
14:	rtnAlloc 1
doE: 
16:	doEventQ 
17:	mvStack
18:	pushthis 
19:	innerP 2
21:	rpopThisObj
22:	setThisStack
23:	pushthis 
24:	rtn D


Class fromPrimary descInx:50 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	jmpFalse 13
4:	pushthis 
5:	vassign 2 2 0
10:	jmp 20
13:	invokeVal 40 1 0
19:	rpop 
20:	tstOriginNone 
21:	rstore 1
23:	allocEventQ 0
25:	mvStack
allocE: 
26:	rtnAlloc 1
doE: 
28:	doEventQ 
29:	mvStack
30:	pushthis 
31:	innerP 2
33:	rpopThisObj
34:	setThisStack
35:	pushthis 
36:	rtn D


Class print descInx:51 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushText 1
13:	invoke 52 0 0
19:	rpop 
20:	pushthis 
21:	innerP 2
23:	rpopThisObj
24:	pushc 58
26:	%prim put 2
28:	pushthis 
29:	rpushg 1
31:	fvpushg 1
33:	%prim printf 142
35:	vpop 
36:	setThisStack
37:	pushthis 
38:	rtn D


Class print descInx:52 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	invoke 55 0 0
18:	rpop 
19:	setThisStack
20:	pushthis 
21:	rtn D


Class repeat$53 descInx:53 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	rpushg 1
18:	pushthis 
19:	rpushg 1
21:	pushg 3
23:	xpushg 1 0 1
27:	%prim put 2
29:	setThisStack
30:	pushthis 
31:	rtn D


Class put descInx:54 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class for:to:repeat$55 descInx:55 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	invoke 15 0 0
17:	pushg 2
19:	pushthis 
20:	storeg 2
22:	pushthis 
23:	storeg 1
25:	allocEventQ 0
allocE: 
27:	rtnAlloc 1
29:	toSuper 28
doE: 
32:	mvStack
33:	rtnInner


Class putFloat descInx:56 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	fstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	setThisStack
15:	pushthis 
16:	rtn D


Class _doIt descInx:57 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushg 3
16:	pushthis 
17:	rpushg 1
19:	pushg 2
21:	le
22:	jmpFalse 36
25:	pushthis 
26:	invoke 59 0 0
32:	rpop 
33:	jmp 44
36:	pushthis 
37:	invoke 62 0 0
43:	rpop 
44:	setThisStack
45:	pushthis 
46:	rtn D


Class <= descInx:58 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	jmpFalse 13
4:	pushthis 
5:	vassign 4 2 0
10:	jmp 20
13:	invokeVal 31 3 0
19:	rpop 
20:	tstOriginNone 
21:	rstore 1
23:	allocEventQ 0
25:	mvStack
allocE: 
26:	rtnAlloc 1
doE: 
28:	doEventQ 
29:	mvStack
30:	setThisStack
31:	pushthis 
32:	rtn D


Class $59 descInx:59 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	invokev 2 0 0
20:	rpop 
21:	pushthis 
22:	rpushg 1
24:	rpushg 1
26:	pushthis 
27:	rpushg 1
29:	rpushg 1
31:	pushg 3
33:	pushc 1
35:	+
36:	storeg 3
38:	break 1 1 57 0
45:	setThisStack
46:	pushthis 
47:	rtn D


Class $62 descInx:62 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushthis 
17:	rpushg 1
19:	rpushg 1
21:	pushg 3
23:	storeg 3
25:	setThisStack
26:	pushthis 
27:	rtn D


Class symbol descInx:63 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
3:	mvStack
allocE: 
4:	pushText 1
6:	pushthis 
7:	rstoreg 2
9:	rtnAlloc 1
doE: 
11:	doEventQ 
12:	mvStack
13:	pushthis 
14:	innerP 2
16:	rpopThisObj
17:	setThisStack
18:	pushthis 
19:	rtn D


Class gMult descInx:64 objSize:7 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	jmpFalse 13
4:	pushthis 
5:	vassign 4 2 0
10:	jmp 20
13:	invokeVal 40 3 0
19:	rpop 
20:	jmpFalse 32
23:	pushthis 
24:	vassign 2 2 0
29:	jmp 39
32:	invokeVal 40 1 0
38:	rpop 
39:	tstOriginNone 
40:	rstore 1
42:	allocEventQ 0
44:	mvStack
allocE: 
45:	invokeVal 40 5 0
51:	rpop 
52:	rtnAlloc 1
doE: 
54:	doEventQ 
55:	mvStack
56:	pushthis 
57:	pushthis 
58:	fpushg 2
60:	pushthis 
61:	fpushg 4
63:	fmult 
64:	fstoreg 6
66:	setThisStack
67:	pushthis 
68:	rtn D


Class AngularAcceleration descInx:66 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 39
doE: 
17:	mvStack
18:	rtnInner


Class PrimaryUnit#67 descInx:67 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	invoke 68 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class RadiansPerSecondSquared descInx:68 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
1:	rtnAlloc 1
3:	toSuper 40
doE: 
6:	mvStack
7:	rtnInner


Class print descInx:69 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 51
doE: 
17:	mvStack
18:	pushText 14
20:	invoke 52 0 0
26:	rpop 
27:	rtnInner


Class Area descInx:70 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 39
doE: 
17:	mvStack
18:	rtnInner


Class PrimaryUnit#71 descInx:71 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	invoke 72 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class SquareMeter descInx:72 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
1:	rtnAlloc 1
3:	toSuper 40
doE: 
6:	mvStack
7:	rtnInner


Class print descInx:74 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 51
doE: 
17:	mvStack
18:	pushText 14
20:	invoke 52 0 0
26:	rpop 
27:	rtnInner


Class symbol descInx:75 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
allocE: 
3:	pushText 5
5:	pushthis 
6:	rstoreg 2
8:	rtnAlloc 1
10:	toSuper 63
doE: 
13:	mvStack
14:	pushthis 
15:	pushText 6
17:	rswap 0
19:	rstoreg 2
21:	rtnInner


Class Energy descInx:76 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 39
doE: 
17:	mvStack
18:	rtnInner


Class PrimaryUnit#77 descInx:77 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	invoke 81 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class multArgL#78 descInx:78 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	invoke 86 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class multArgR#79 descInx:79 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	invoke 91 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class multRes#80 descInx:80 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	invoke 81 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class Joule descInx:81 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
1:	rtnAlloc 1
3:	toSuper 40
doE: 
6:	mvStack
7:	rtnInner


Class print descInx:83 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 51
doE: 
17:	mvStack
18:	pushText 14
20:	invoke 52 0 0
26:	rpop 
27:	rtnInner


Class Force descInx:84 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 39
doE: 
17:	mvStack
18:	rtnInner


Class PrimaryUnit#85 descInx:85 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	invoke 86 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class Newton descInx:86 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
1:	rtnAlloc 1
3:	toSuper 40
doE: 
6:	mvStack
7:	rtnInner


Class print descInx:88 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 51
doE: 
17:	mvStack
18:	pushText 14
20:	invoke 52 0 0
26:	rpop 
27:	rtnInner


Class Length descInx:89 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 39
doE: 
17:	mvStack
18:	rtnInner


Class PrimaryUnit#90 descInx:90 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	invoke 91 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class Meter descInx:91 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
1:	rtnAlloc 1
3:	toSuper 40
doE: 
6:	mvStack
7:	rtnInner


Class toPrimary descInx:95 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	invokeVal 40 1 0
18:	rpop 
19:	rtnAlloc 1
21:	toSuper 49
doE: 
24:	mvStack
25:	pushthis 
26:	pushthis 
27:	rpushg 1
29:	fvpushg 1
31:	fstoreg 2
33:	rtnInner


Class fromPrimary descInx:96 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	jmpFalse 19
10:	pushthis 
11:	vassign 2 2 0
16:	jmp 26
19:	invokeVal 40 1 0
25:	rpop 
26:	tstOriginNone 
27:	rstore 1
29:	allocEventQ 0
allocE: 
31:	rtnAlloc 1
33:	toSuper 50
doE: 
36:	mvStack
37:	pushthis 
38:	rpushg 1
40:	pushthis 
41:	fpushg 2
43:	fvstoreg 1
45:	rtnInner


Class print descInx:97 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 51
doE: 
17:	mvStack
18:	pushText 14
20:	invoke 52 0 0
26:	rpop 
27:	rtnInner


Class symbol descInx:98 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
allocE: 
3:	pushText 5
5:	pushthis 
6:	rstoreg 2
8:	rtnAlloc 1
10:	toSuper 63
doE: 
13:	mvStack
14:	pushthis 
15:	pushText 6
17:	rswap 0
19:	rstoreg 2
21:	rtnInner


Class Mass descInx:99 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 39
doE: 
17:	mvStack
18:	rtnInner


Class Time descInx:100 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 39
doE: 
17:	mvStack
18:	rtnInner


Class PrimaryUnit#101 descInx:101 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	invoke 102 0 0
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class Second descInx:102 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
1:	rtnAlloc 1
3:	toSuper 40
doE: 
6:	mvStack
7:	rtnInner


Class toPrimary descInx:104 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	invokeVal 40 1 0
18:	rpop 
19:	rtnAlloc 1
21:	toSuper 49
doE: 
24:	mvStack
25:	pushthis 
26:	pushthis 
27:	rpushg 1
29:	fvpushg 1
31:	fstoreg 2
33:	rtnInner


Class fromPrimary descInx:105 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	jmpFalse 19
10:	pushthis 
11:	vassign 2 2 0
16:	jmp 26
19:	invokeVal 40 1 0
25:	rpop 
26:	tstOriginNone 
27:	rstore 1
29:	allocEventQ 0
allocE: 
31:	rtnAlloc 1
33:	toSuper 50
doE: 
36:	mvStack
37:	pushthis 
38:	rpushg 1
40:	pushthis 
41:	fpushg 2
43:	fvstoreg 1
45:	rtnInner


Class print descInx:106 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 51
doE: 
17:	mvStack
18:	pushText 14
20:	invoke 52 0 0
26:	rpop 
27:	rtnInner


Class StringLib descInx:107 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	saveStringOrigin
7:	mvStack
allocE: 
8:	rtnAlloc 1
doE: 
10:	doEventQ 
11:	mvStack
12:	setThisStack
13:	pushthis 
14:	rtn D


Class Boolean descInx:108 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	mvStack
allocE: 
2:	rtnAlloc 1
doE: 
4:	mvStack
5:	setThisStack
6:	pushthis 
7:	rtn D


Class <= descInx:109 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	rshiftup 1
3:	tstOriginNone 
4:	rstore 1
6:	allocEventQ 0
8:	pushthis 
9:	rpushg 1
11:	rshiftdown 1
13:	pushthis 
14:	rstoreg 2
16:	tstOriginNone 
17:	rstore 1
19:	allocEventQ 0
21:	mvStack
allocE: 
22:	pushthis 
23:	invoke 110 4 1
29:	rpop 
doE: 
30:	doEventQ 
31:	mvStack
32:	setThisStack
33:	pushthis 
34:	rtn D


Class loop descInx:110 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	rpushg 1
17:	invoke 15 0 0
23:	pushg 2
25:	storeg 3
27:	pushthis 
28:	pushthis 
29:	rpushg 1
31:	rpushg 2
33:	invoke 15 0 0
39:	pushg 2
41:	storeg 4
43:	pushthis 
44:	pushg 3
46:	pushthis 
47:	pushg 4
49:	lt
50:	jmpFalse 64
53:	pushthis 
54:	invoke 112 0 0
60:	rpop 
61:	jmp 72
64:	pushthis 
65:	invoke 113 0 0
71:	rpop 
72:	pushthis 
73:	invoke 114 0 0
79:	rpop 
80:	setThisStack
81:	pushthis 
82:	rtn D


Class $112 descInx:112 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushthis 
15:	rpushg 1
17:	pushg 3
19:	storeg 2
21:	setThisStack
22:	pushthis 
23:	rtn D


Class $113 descInx:113 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushthis 
15:	rpushg 1
17:	pushg 4
19:	storeg 2
21:	setThisStack
22:	pushthis 
23:	rtn D


Class matchEq descInx:114 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	invoke 115 0 0
18:	rpop 
19:	pushthis 
20:	invoke 118 0 0
26:	rpop 
27:	pushthis 
28:	invoke 121 0 0
34:	rpop 
35:	setThisStack
36:	pushthis 
37:	rtn D


Class isEmpty descInx:115 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushg 3
18:	pushc 0
20:	eq 
21:	jmpFalse 32
24:	pushthis 
25:	invoke 116 0 0
31:	rpop 
32:	pushthis 
33:	rpushg 1
35:	rpushg 1
37:	pushg 4
39:	pushc 0
41:	eq 
42:	jmpFalse 53
45:	pushthis 
46:	invoke 117 0 0
52:	rpop 
53:	setThisStack
54:	pushthis 
55:	rtn D


Class $116 descInx:116 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 1
20:	pushthis 
21:	rpushg 1
23:	rpushg 1
25:	rpushg 1
27:	pushg 3
29:	pushthis 
30:	rpushg 1
32:	rpushg 1
34:	rpushg 1
36:	pushg 4
38:	le
39:	storeg 3
41:	break 2 2 114 0
48:	setThisStack
49:	pushthis 
50:	rtn D


Class $117 descInx:117 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 1
20:	invoke 27 0 0
26:	pushg 1
28:	storeg 3
30:	break 2 2 114 0
37:	setThisStack
38:	pushthis 
39:	rtn D


Class loop descInx:118 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushthis 
15:	rpushg 1
17:	pushg 2
19:	pushc 1
21:	+
22:	storeg 2
24:	pushthis 
25:	rpushg 1
27:	pushthis 
28:	rpushg 1
30:	rpushg 1
32:	rpushg 1
34:	rpushg 1
36:	pushthis 
37:	rpushg 1
39:	pushg 2
41:	xpushg 1 0 1
45:	storeg 3
47:	pushthis 
48:	rpushg 1
50:	pushthis 
51:	rpushg 1
53:	rpushg 1
55:	rpushg 1
57:	rpushg 2
59:	pushthis 
60:	rpushg 1
62:	pushg 2
64:	xpushg 1 0 1
68:	storeg 4
70:	pushthis 
71:	rpushg 1
73:	pushg 3
75:	pushthis 
76:	rpushg 1
78:	pushg 4
80:	eq 
81:	jmpFalse 92
84:	pushthis 
85:	invoke 119 0 0
91:	rpop 
92:	setThisStack
93:	pushthis 
94:	rtn D


Class $119 descInx:119 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushg 2
18:	pushthis 
19:	rpushg 1
21:	rpushg 1
23:	rpushg 1
25:	pushg 2
27:	lt
28:	jmpFalse 39
31:	pushthis 
32:	invoke 120 0 0
38:	rpop 
39:	setThisStack
40:	pushthis 
41:	rtn D


Class $120 descInx:120 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	break 2 1 118 0
18:	setThisStack
19:	pushthis 
20:	rtn D


Class doit descInx:121 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushg 3
16:	pushthis 
17:	rpushg 1
19:	pushg 4
21:	eq 
22:	jmpFalse 36
25:	pushthis 
26:	invoke 122 0 0
32:	rpop 
33:	jmp 44
36:	pushthis 
37:	invoke 123 0 0
43:	rpop 
44:	setThisStack
45:	pushthis 
46:	rtn D


Class $122 descInx:122 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 1
20:	pushthis 
21:	rpushg 1
23:	rpushg 1
25:	rpushg 1
27:	pushg 3
29:	pushthis 
30:	rpushg 1
32:	rpushg 1
34:	rpushg 1
36:	pushg 4
38:	le
39:	storeg 3
41:	break 2 2 114 0
48:	setThisStack
49:	pushthis 
50:	rtn D


Class $123 descInx:123 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 1
20:	pushthis 
21:	rpushg 1
23:	rpushg 1
25:	pushg 3
27:	pushthis 
28:	rpushg 1
30:	rpushg 1
32:	pushg 4
34:	lt
35:	storeg 3
37:	break 2 2 114 0
44:	setThisStack
45:	pushthis 
46:	rtn D


Class puttext descInx:125 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	innerP 2
17:	rpopThisObj
18:	setThisStack
19:	pushthis 
20:	rtn D


Class putint descInx:126 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	innerP 2
17:	rpopThisObj
18:	setThisStack
19:	pushthis 
20:	rtn D


Class workspace descInx:127 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 128 2 1
14:	rpop 
15:	rtnAlloc 1
doE: 
17:	doEventQ 
18:	mvStack
19:	setThisStack
20:	pushthis 
21:	rtn D


Class UnitIssues descInx:128 objSize:14 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	invokeVal 91 1 0
13:	rpop 
14:	invokeVal 91 3 0
20:	rpop 
21:	invokeVal 72 5 0
27:	rpop 
28:	invokeVal 72 7 0
34:	rpop 
35:	invokeVal 72 9 0
41:	rpop 
42:	rtnAlloc 1
doE: 
44:	doEventQ 
45:	mvStack
46:	pushthis 
47:	pushc 24
49:	i2f
50:	fstoreg 6
52:	pushthis 
53:	pushc 12
55:	i2f
56:	fstoreg 8
58:	pushthis 
59:	pushthis 
60:	fpushg 6
62:	pushthis 
63:	fpushg 8
65:	fdiv 
66:	fstoreg 10
68:	pushthis 
69:	rdouble 
70:	rpushg 1
72:	rpushg 1
74:	rpushg 3
76:	rpushg 4
78:	rpushg 3
80:	mkValueProxy 72 9 0 0
87:	invoke 74 0 0
93:	rpop 
94:	invoke 130 0 0
100:	rpop 
101:	pushthis 
102:	pushthis 
103:	fpushg 6
105:	pushthis 
106:	fpushg 8
108:	fdiv 
109:	fstoreg 12
111:	pushthis 
112:	fpushg 12
114:	%prim printf 142
116:	vpop 
117:	invoke 130 0 0
123:	rpop 
124:	pushthis 
125:	pushthis 
126:	fpushg 8
128:	pushc 4
130:	i2f
131:	fmult 
132:	fstoreg 6
134:	pushthis 
135:	rdouble 
136:	rpushg 1
138:	rpushg 1
140:	rpushg 3
142:	rpushg 4
144:	rpushg 3
146:	mkValueProxy 72 5 0 0
153:	invoke 74 0 0
159:	rpop 
160:	invoke 130 0 0
166:	rpop 

167:	pushthis 
168:	pushc 3
170:	i2f
171:	pushthis 
172:	fpushg 8
174:	fmult 
175:	fstoreg 6

177:	pushthis 
178:	rdouble 
179:	rpushg 1
181:	rpushg 1
183:	rpushg 3
185:	rpushg 4
187:	rpushg 3
189:	mkValueProxy 72 5 0 0
196:	invoke 74 0 0
202:	rpop 
203:	invoke 130 0 0
209:	rpop 
210:	pushthis 
211:	pushFloatConst 3.000000
220:	pushFloatConst 5.000000
229:	fmult 
230:	fstoreg 10
232:	pushthis 
233:	rdouble 
234:	rpushg 1
236:	rpushg 1
238:	rpushg 3
240:	rpushg 4
242:	rpushg 3
244:	mkValueProxy 72 9 0 0
251:	invoke 74 0 0
257:	rpop 
258:	invoke 130 0 0
264:	rpop 
265:	pushthis 
266:	pushc 5
268:	i2f
269:	fstoreg 2
271:	pushthis 
272:	pushc 3
274:	i2f
275:	fstoreg 4
277:	pushthis 
278:	pushthis 
279:	fpushg 2
281:	pushthis 
282:	fpushg 4
284:	fmult 
285:	fstoreg 10
287:	pushthis 
288:	rdouble 
289:	rpushg 1
291:	rpushg 1
293:	rpushg 3
295:	rpushg 4
297:	rpushg 3
299:	mkValueProxy 72 9 0 0
306:	invoke 74 0 0
312:	rpop 
313:	invoke 130 0 0
319:	rpop 
320:	pushthis 
321:	pushFloatConst 3.140000
330:	fstoreg 12
332:	pushthis 
333:	pushthis 
334:	fpushg 12
336:	fstoreg 2
338:	pushthis 
339:	rdouble 
340:	rpushg 1
342:	rpushg 1
344:	rpushg 3
346:	rpushg 4
348:	rpushg 6
350:	mkValueProxy 91 1 0 0
357:	invoke 97 0 0
363:	rpop 
364:	invoke 130 0 0
370:	rpop 
371:	pushthis 
372:	pushc2 1001
375:	storeg 14
377:	pushthis 
378:	pushthis 
379:	pushg 14
381:	i2f
382:	fstoreg 2
384:	pushthis 
385:	rdouble 
386:	rpushg 1
388:	rpushg 1
390:	rpushg 3
392:	rpushg 4
394:	rpushg 6
396:	mkValueProxy 91 1 0 0
403:	invoke 97 0 0
409:	rpop 
410:	invoke 130 0 0
416:	rpop 
417:	pushthis 
418:	pushthis 
419:	pushg 14
421:	pushc 8
423:	+
424:	i2f
425:	fstoreg 2
427:	pushthis 
428:	rdouble 
429:	rpushg 1
431:	rpushg 1
433:	rpushg 3
435:	rpushg 4
437:	rpushg 6
439:	mkValueProxy 91 1 0 0
446:	invoke 97 0 0
452:	rpop 
453:	invoke 130 0 0
459:	rpop 
460:	pushthis 
461:	pushthis 
462:	pushFloatConst 3.190000
471:	pushc 1
473:	invoke 132 0 0
479:	pushValue 4 2
483:	vassign 6 2 0
488:	pushthis 
489:	rdouble 
490:	rpushg 1
492:	rpushg 1
494:	rpushg 3
496:	rpushg 4
498:	rpushg 3
500:	mkValueProxy 72 5 0 0
507:	invoke 74 0 0
513:	rpop 
514:	invoke 130 0 0
520:	rpop 
521:	pushthis 
522:	pushthis 
523:	pushc 6
525:	i2f
526:	pushc 1
528:	invoke 132 0 0
534:	pushValue 4 2
538:	vassign 6 2 0
543:	pushthis 
544:	rdouble 
545:	rpushg 1
547:	rpushg 1
549:	rpushg 3
551:	rpushg 4
553:	rpushg 3
555:	mkValueProxy 72 5 0 0
562:	invoke 74 0 0
568:	rpop 
569:	invoke 130 0 0
575:	rpop 
576:	pushthis 
577:	pushc 5
579:	i2f
580:	fstoreg 4
582:	pushthis 
583:	pushthis 
584:	pushthis 
585:	fpushg 4
587:	f2i
588:	invoke 134 0 0
594:	pushg 3
596:	i2f
597:	fstoreg 2
599:	pushthis 
600:	rdouble 
601:	rpushg 1
603:	rpushg 1
605:	rpushg 3
607:	rpushg 4
609:	rpushg 6
611:	mkValueProxy 91 1 0 0
618:	invoke 97 0 0
624:	rpop 
625:	invoke 130 0 0
631:	rpop 
632:	pushthis 
633:	pushc 6
635:	i2f
636:	fstoreg 4
638:	pushthis 
639:	pushthis 
640:	pushthis 
641:	fpushg 4
643:	invoke 135 0 0
649:	fpushg 4
651:	fstoreg 2
653:	pushthis 
654:	rdouble 
655:	rpushg 1
657:	rpushg 1
659:	rpushg 3
661:	rpushg 4
663:	rpushg 6
665:	mkValueProxy 91 1 0 0
672:	invoke 97 0 0
678:	rpop 
679:	invoke 130 0 0
685:	rpop 
686:	pushthis 
687:	invoke 137 0 0
693:	rpop 
694:	setThisStack
695:	pushthis 
696:	rtn D


Class newline descInx:130 objSize:0 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
3:	mvStack
allocE: 
4:	rtnAlloc 1
doE: 
6:	doEventQ 
7:	mvStack
8:	pushc 10
10:	%prim put 2
12:	setThisStack
13:	pushthis 
14:	rtn D


Class foo descInx:132 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	jmpFalse 13
4:	pushthis 
5:	vassign 2 2 0
10:	jmp 20
13:	invokeVal 91 1 0
19:	rpop 
20:	tstOriginNone 
21:	rstore 1
23:	allocEventQ 0
25:	mvStack
allocE: 
26:	invokeVal 72 3 0
32:	rpop 
33:	rtnAlloc 1
doE: 
35:	doEventQ 
36:	mvStack
37:	pushthis 
38:	pushthis 
39:	rpushg 1
41:	rpushg 1
43:	rpushg 1
45:	rpushg 3
47:	rpushg 4
49:	rpushg 3
51:	pushthis 
52:	pushValue 2 2
56:	pushc 1
58:	pushthis 
59:	pushValue 2 2
63:	pushc 1
65:	invoke 133 0 0
71:	pushValue 6 2
75:	vassign 4 2 0
80:	setThisStack
81:	pushthis 
82:	rtn D


Class mult descInx:133 objSize:7 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	jmpFalse 13
4:	pushthis 
5:	vassign 4 2 0
10:	jmp 20
13:	invokeVal 91 3 0
19:	rpop 
20:	jmpFalse 32
23:	pushthis 
24:	vassign 2 2 0
29:	jmp 39
32:	invokeVal 91 1 0
38:	rpop 
39:	tstOriginNone 
40:	rstore 1
42:	allocEventQ 0
44:	mvStack
allocE: 
45:	invokeVal 72 5 0
51:	rpop 
52:	rtnAlloc 1
doE: 
54:	doEventQ 
55:	mvStack
56:	pushthis 
57:	pushthis 
58:	fpushg 2
60:	pushthis 
61:	fpushg 4
63:	fmult 
64:	fstoreg 6
66:	setThisStack
67:	pushthis 
68:	rtn D


Class mapi descInx:134 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	pushthis 
16:	pushg 2
18:	pushthis 
19:	pushg 2
21:	+
22:	storeg 3
24:	setThisStack
25:	pushthis 
26:	rtn D


Class mapf descInx:135 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	fstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	pushthis 
16:	fpushg 2
18:	pushthis 
19:	fpushg 2
21:	fplus 
22:	fstoreg 4
24:	setThisStack
25:	pushthis 
26:	rtn D


Class energyCombinations descInx:137 objSize:9 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	invokeVal 138 1 0
13:	rpop 
14:	invokeVal 72 3 0
20:	rpop 
21:	invokeVal 68 5 0
27:	rpop 
28:	invokeVal 81 7 0
34:	rpop 
35:	rtnAlloc 1
doE: 
37:	doEventQ 
38:	mvStack
39:	pushText 1
41:	invoke 52 0 0
47:	rpop 
48:	pushthis 
49:	pushc 12
51:	i2f
52:	fstoreg 2
54:	pushthis 
55:	pushc 4
57:	i2f
58:	fstoreg 4
60:	pushthis 
61:	pushc 6
63:	i2f
64:	fstoreg 6
66:	pushthis 
67:	pushthis 
68:	fpushg 2
70:	pushthis 
71:	fpushg 4
73:	fmult 
74:	pushthis 
75:	fpushg 6
77:	fmult 
78:	fstoreg 8
80:	pushthis 
81:	rdouble 
82:	rpushg 1
84:	rpushg 1
86:	rpushg 1
88:	rpushg 3
90:	rpushg 4
92:	rpushg 4
94:	mkValueProxy 81 7 0 0
101:	invoke 83 0 0
107:	rpop 
108:	invoke 130 0 0
114:	rpop 
115:	pushthis 
116:	pushthis 
117:	fpushg 2
119:	pushthis 
120:	fpushg 4
122:	fmult 
123:	pushc 6
125:	i2f
126:	fmult 
127:	fstoreg 8
129:	pushthis 
130:	rdouble 
131:	rpushg 1
133:	rpushg 1
135:	rpushg 1
137:	rpushg 3
139:	rpushg 4
141:	rpushg 4
143:	mkValueProxy 81 7 0 0
150:	invoke 83 0 0
156:	rpop 
157:	invoke 130 0 0
163:	rpop 
164:	pushthis 
165:	pushFloatConst 12.000000
174:	pushFloatConst 4.000000
183:	fmult 
184:	pushFloatConst 6.000000
193:	fmult 
194:	fstoreg 8
196:	pushthis 
197:	rdouble 
198:	rpushg 1
200:	rpushg 1
202:	rpushg 1
204:	rpushg 3
206:	rpushg 4
208:	rpushg 4
210:	mkValueProxy 81 7 0 0
217:	invoke 83 0 0
223:	rpop 
224:	invoke 130 0 0
230:	rpop 
231:	pushthis 
232:	pushc 12
234:	pushc 4
236:	*
237:	pushc 6
239:	*
240:	i2f
241:	fstoreg 8
243:	pushthis 
244:	rdouble 
245:	rpushg 1
247:	rpushg 1
249:	rpushg 1
251:	rpushg 3
253:	rpushg 4
255:	rpushg 4
257:	mkValueProxy 81 7 0 0
264:	invoke 83 0 0
270:	rpop 
271:	invoke 130 0 0
277:	rpop 
278:	setThisStack
279:	pushthis 
280:	rtn D


Class KiloGram descInx:138 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
1:	rtnAlloc 1
3:	toSuper 40
doE: 
6:	mvStack
7:	rtnInner


Class print descInx:140 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 51
doE: 
17:	mvStack
18:	pushText 14
20:	invoke 52 0 0
26:	rpop 
27:	rtnInner


Class + descInx:141 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	pushText 1
12:	pushthis 
13:	rstoreg 3
15:	rtnAlloc 1
doE: 
17:	doEventQ 
18:	mvStack
19:	pushthis 
20:	pushthis 
21:	rpushg 1
23:	invoke 15 0 0
29:	pushg 2
31:	storeg 4
33:	pushthis 
34:	invoke 142 0 0
40:	rpop 
41:	setThisStack
42:	pushthis 
43:	rtn D


Class doplus descInx:142 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushthis 
8:	rpushg 1
10:	pushg 4
12:	pushthis 
13:	rpushg 1
15:	rpushg 2
17:	invoke 15 0 0
23:	pushg 2
25:	+
26:	pushthis 
27:	pushc 1
29:	allocIndexed 143 1 0 
34:	pushthis 
35:	rstoreg 4
37:	rtnAlloc 1
doE: 
39:	doEventQ 
40:	mvStack
41:	pushthis 
42:	invoke 147 0 0
48:	rpop 
49:	pushthis 
50:	invoke 149 0 0
56:	rpop 
57:	pushthis 
58:	rpushg 1
60:	pushthis 
61:	rpushg 4
63:	%prim asString 118
65:	rswap 0
67:	rstoreg 3
69:	setThisStack
70:	pushthis 
71:	rtn D


Class Indexed descInx:143 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class repeat$145 descInx:145 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	pushthis 
17:	rpushg 1
19:	rpushg 4
21:	rpushg 1
23:	rpushg 1
25:	pushthis 
26:	rpushg 1
28:	pushg 3
30:	xpushg 1 0 1
34:	storeg 2
36:	pushthis 
37:	rpushg 1
39:	rpushg 4
41:	rpushg 4
43:	pushthis 
44:	rpushg 1
46:	rpushg 4
48:	pushg 2
50:	pushthis 
51:	rpushg 1
53:	pushg 3
55:	xstoreg 1 0 1 
59:	setThisStack
60:	pushthis 
61:	rtn D


Class for:to:repeat$147 descInx:147 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	pushg 4
13:	pushthis 
14:	storeg 2
16:	pushthis 
17:	storeg 1
19:	allocEventQ 0
allocE: 
21:	rtnAlloc 1
23:	toSuper 28
doE: 
26:	mvStack
27:	rtnInner


Class repeat$148 descInx:148 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	pushthis 
17:	rpushg 1
19:	rpushg 4
21:	rpushg 1
23:	rpushg 2
25:	pushthis 
26:	rpushg 1
28:	pushg 3
30:	xpushg 1 0 1
34:	storeg 2
36:	pushthis 
37:	rpushg 1
39:	rpushg 4
41:	pushthis 
42:	rpushg 1
44:	rpushg 4
46:	rpushg 1
48:	pushg 4
50:	pushthis 
51:	rpushg 1
53:	pushg 3
55:	+
56:	storeg 3
58:	pushthis 
59:	rpushg 1
61:	rpushg 4
63:	rpushg 4
65:	pushthis 
66:	rpushg 1
68:	rpushg 4
70:	pushg 2
72:	pushthis 
73:	rpushg 1
75:	rpushg 4
77:	pushg 3
79:	xstoreg 1 0 1 
83:	setThisStack
84:	pushthis 
85:	rtn D


Class for:to:repeat$149 descInx:149 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	rpushg 2
13:	invoke 15 0 0
19:	pushg 2
21:	pushthis 
22:	storeg 2
24:	pushthis 
25:	storeg 1
27:	allocEventQ 0
allocE: 
29:	rtnAlloc 1
31:	toSuper 28
doE: 
34:	mvStack
35:	rtnInner


Class asString descInx:150 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushText 1
9:	pushthis 
10:	rstoreg 2
12:	rtnAlloc 1
doE: 
14:	doEventQ 
15:	mvStack
16:	setThisStack
17:	pushthis 
18:	rtn D


Class valProx descInx:151 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	0


Class VM descInx:152 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	invoke 1 0 1
8:	stop 
9:	rtn D


Class EventProcessor descInx:153 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	stop 


Class ThreadStub descInx:154 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
doE: 
1:	call D
3:	stop 

