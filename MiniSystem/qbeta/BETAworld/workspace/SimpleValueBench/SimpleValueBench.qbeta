SimpleValueBench: obj
   %visible StringLib
   vPoint: Value
      in x: var float
      in y: var float
      in z: var float
      get_x:
         out V: var integer
         V := x
      fooA:
         ...
      fooB:<
         ...
      fooC:
         fooB
      fooD:
         in dx: var float
         in dy: var float
         x := x + dx
         y := y + dy
   mPoint:
      in x: var float
      in y: var float
      in z: var float
      get_x:
         out V: var integer
         V := x
      equals:
         in p: ref mPoint
         out B: var Boolean
         B := (x = p.x) && (y = p.y) && (z = p.z)
      fooA:
         ...
      fooB:<
         ...
      fooC:
         fooB
      fooD:
         in dx: var float
         in dy: var float
         x := x + dx
         y := y + dy
   vp1: var vPoint(1,2,3)
   vp2: var vPoint(1,2,3)  
   vp3: var vPoint(1,4,5)  
   mp1: obj mPoint(10,11,12)
   mp2: obj mPoint(10,11,12)
   mp3: obj mPoint(10,1,15)
   mp4: ref #mPoint
   mp4 := mPoint(10,3,17)
      
   tester:
      in n: var integer
      if (emitLatex.not) :then 
         put(' ')
         putint(n)
      inner(tester)
   directValueX: tester
      benchA: do
         i: var integer
         i := i + 1
         F: var float
         F := vp1.x
         if (i <= executionsPerBenchmark) :then
            restart(benchA)
   directMaterialX: tester
      benchA: do
         i: var integer
         i := i + 1
         F: var float
         F := mp1.x
         if (i <= executionsPerBenchmark) :then
            restart(benchA)
   getValueX: tester
      benchA: do
         i: var integer
         i := i + 1
         F: var float
         F := vp1.get_x
         if (i <= executionsPerBenchmark) :then
            restart(benchA)
   getMaterialX: tester
      benchA: do
         i: var integer
         i := i + 1
         F: var float
         F := mp1.get_x
         if (i <= executionsPerBenchmark) :then
            restart(benchA)
   ValueEQ: tester
      bench1: do
         i: var integer
         i := i + 1
         B: var boolean
         B := vp1 = vp2
         if (i <= executionsPerBenchmark) :then
            restart(bench1)
   MaterialEquals: tester
      bench2: do
         i: var integer
         i := i + 1
         B: var boolean
         B := mp1.equals(mp2)
         if (i <= executionsPerBenchmark) :then
            restart(bench2)
   MaterialEQxyz: tester
      bench3: do
         i: var integer
         i := i + 1
         B: var boolean
         B := (mp1.x = mp2.x) && (mp1.y = mp2.y) && (mp1.z = mp2.z)
         if (i <= executionsPerBenchmark) :then
            restart(bench3)
   ValueMethod: tester
      vp1.fooA
      bench4: do
         i: var integer
         i := i + 1
         vp1.fooA
         if (i <= executionsPerBenchmark) :then
            restart(bench4)
   MaterialMethod: tester
      mp1.fooA
      bench5: do
         i: var integer
         i := i + 1
         mp1.fooA
         if (i <= executionsPerBenchmark) :then
            restart(bench5)
   ValueVirtualMethod: tester
      vp1.fooB
      bench7: do
         i: var integer
         i := i + 1
         vp1.fooB
         if (i <= executionsPerBenchmark) :then
            restart(bench7)
   MaterialVirtualMethod: tester
      mp1.fooB
      bench8: do
         i: var integer
         i := i + 1
         mp1.fooB
         if (i <= executionsPerBenchmark) :then
            restart(bench8)
   MaterialVirtualMethodRef: tester
      mp4.fooB
      bench9: do
         i: var integer
         i := i + 1
         mp4.fooB
         if (i <= executionsPerBenchmark) :then
            restart(bench9)
   ValueMethodCallingVirtual: tester
      vp1.fooc
      bench10: do
         i: var integer
         i := i + 1
         vp1.fooC
         if (i <= executionsPerBenchmark) :then
            restart(bench10)
   MaterialMethodCallingVirtual: tester
      mp1.fooC
      bench11: do
         i: var integer
         i := i + 1
         mp1.fooC
         if (i <= executionsPerBenchmark) :then
            restart(bench11)
   ValueTranslate: tester
      vp1.fooD(0.001,0.001)
      bench13: do
         i: var integer
         h: var integer
         i := i + 1
         h := markHeap(h)
         vp1.fooD(0.001,0.001)
         if (i <= executionsPerBenchmark) :then
            restart(bench13)
   MaterialTranslate: tester
      mp1.fooD(0.001,0.001)
      bench14: do
         i: var integer
         h: var integer
         i := i + 1
         h := markHeap(h)
         mp1.fooD(0.001,0.001)
         if (i <= executionsPerBenchmark) :then
            restart(bench14)
   printCPUtime:
       "CPU time: ".print
       putint(cpuTime - startTime)
       " microseconds\n".print
       startTime := cpuTime

   "**** Simple value benchmark: runsPerTest: {I2S(runsPerTest)}, executionsPerBenchmark: {I2S(executionsPerBenchmark)}\n".print
   emitPreAmble:
      if (emitLatex) :then
         "\\begin\{center\}\\small\n\\begin\{tabular\}\{ |p\{3cm\}|c|c|c|c|c| \}\n".print
         "\\hline\n   & \\textbf\{mechanism\} & \\textbf\{object kind\}  & \\textbf\{min\} & \\textbf\{max\} & \\textbf\{mean\} \\\\\n".print
   emitSep:
      if (emitLatex) :then
         "\\hline\n".print
      :else
         newline
      noOfRows := 0
   emitClosing:
      if (emitLatex) :then
         "\\hline\n\\end\{tabular\}\n\\end\{center\}\n".print
   emitHeader:
      in id: var String
      in isValue: var Boolean
      noOfRows := noOfRows + 1
      if (emitLatex) :then
         if (noOfRows = 1) :then
            "\\hline\n".print
            "\\multirow\{2\}\{3cm\}\{".print
            what.print
            "\}".print
         :else
            "\\cline\{2-6\}\n".print
         put('&')
         id.print
         put(' ')
         put('&')
         if (isValue) :then
            "value    & ".print
         :else
            "material & ".print
      :else
         if (noOfRows = 1) :then
            "**** ".print
            what.print
            ":\n".print
         ("***  " + id + ": ").print 
         if (isValue) :then
            "VALUE, ".print
         :else
            "MATERIAL, ".print
   emitMinMaxMean: 
      in id: var String
      in isValue: var Boolean
      in bench: ref #array
      min: var integer
      max: var integer
      mean: var integer
      if (emitLatex.not) :then
         "\n**   ".print
      for (1) :to (bench.length) :repeat
           V: var integer
           V := bench.get[inx]
           if (emitLatex.not) :then
              putint(V)
              put(' ')
           if (min = 0) || ( V < min) :then
              min := V
           if (max < V) :then
              max := V
           mean := mean + V 
      mean := mean // bench.length
      if (emitLatex) :then
         " {I2S(min)} & {I2S(max)} & {I2S(mean)} \\\\\n".print
      :else
         "\n*    CPU-time, min: {I2S(min)}, max: {I2S(max)}, mean: {I2S(mean)}".print
   what: var String
   noOfRows: var integer
   startTime: var integer
   endTime: var integer
   runsPerTest: val 2 -- 10
   executionsPerBenchmark: val 5 -- 500000
   emitLatex: val true
   heapTop: var Integer
   bench: obj Array(runsPerTest,#integer)
   bTop: var integer

   startTime := cpuTime
   emitPreAmble
   runTest:
      in id: var String
      in isValue: var Boolean
      h: var integer
      emitHeader(id,isValue)
      bTop := 0
      for (1):to(runsPerTest):repeat 
          h := markHeap(h)
          startTime := cpuTime
          bTop := bTop + 1
          inner(runTest)
          bench.put(cpuTime - startTime):at[bTop]
      emitMinMaxMean(id,isValue,bench)
      if (emitLatex.not) :then
         newline
   what := "Variable access"
   runTest("vp.x",true)
      directValueX(bTop)
   heapTop := markHeap(heapTop)
   runTest("mp.x",false)
      directMaterialX(bTop)
   emitSep
   what := "Getter method"
   runTest("vp.getx",true)
      getValueX(bTop)
   heapTop := markHeap(heapTop)
   runTest("mp.getx",false)
      getMaterialX(bTop)
   emitSep
   what := "Equality"
   runTest("vp1 = vp2",true)
      ValueEQ(bTop)
   heapTop := markHeap(heapTop)
   runTest("mp1.equals(mp2)",false)
      MaterialEquals(bTop)
   heapTop := markHeap(heapTop)
   runTest("mp1.x=mp2.x,...",false)
      MaterialEQxyz(bTop)
   emitSep
   what := "Remote method invocation"
   heapTop := markHeap(heapTop)
   runTest("vp.fooA",true)
      ValueMethod(bTop)
   heapTop := markHeap(heapTop)
   runTest("mp.fooA",false)
      MaterialMethod(bTop)
   emitSep
   what := "Remote virtual method invocation"
   heapTop := markHeap(heapTop)
   runTest("vp.fooB",true)
      ValueVirtualMethod(bTop)
   heapTop := markHeap(heapTop)
   runTest("vp.fooB",false)
      MaterialVirtualMethod(bTop)
   heapTop := markHeap(heapTop)
   runTest("mp.fooB",false)
      MaterialVirtualMethodRef(bTop)
   heapTop := markHeap(heapTop)
   emitSep
   what := "Remote invocation of method calling local virtual"
   runTest("vp.fooC",true)
      ValueMethodCallingVirtual(bTop)
   heapTop := markHeap(heapTop)
   runTest("mp.fooC",false)
      MaterialMethodCallingVirtual(bTop)
   emitSep
   what := "Remote method changing the object"
   heapTop := markHeap(heapTop)
   runTest("vp.fooD(e1,e2)",true)
      ValueTranslate(bTop)
   heapTop := markHeap(heapTop)
   runTest("mp.fooD(e1,e2)",false)
      MaterialTranslate(bTop)
   emitClosing