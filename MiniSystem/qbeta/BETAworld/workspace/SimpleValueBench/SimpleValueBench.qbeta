SimpleValueBench: obj
   vPoint: Value
      in x: var float
      in y: var float
      in z: var float
      vFoo:
         vBar
      vBar:<
         ...
      translate:
         in dx: var float
         in dy: var float
         x := x + dx
         y := y + dy
   mPoint:
      in x: var float
      in y: var float
      in z: var float
      equals:
         in p: ref mPoint
         out B: var Boolean
         B := (x = p.x) && (y = p.y) && (z = p.z)
      mFoo:
         mBar
      mBar:<
         ...
      translate:
         in dx: var float
         in dy: var float
         x := x + dx
         y := y + dy
   vp1: var vPoint(1,2,3)
   vp2: var vPoint(1,2,3)  
   vp3: var vPoint(1,4,5)  
   mp1: obj mPoint(10,11,12)
   mp2: obj mPoint(10,11,12)
   mp3: obj mPoint(10,1,15)
   max: val 500000
   testValueEQ:
      "**** testValueEQ:".print
      if (vp1 = vp2) :then
         "vp1=vp2:OK,".print
      :else
         "vp1<>vp:wrong,".print  
      if (vp1 = vp3) :then
         "vp1=vp2:wrong\n".print
      :else
         "vp1<>vp2:OK\n".print
      for (1):to(max) :repeat
         B: var boolean
         B := vp1 = vp2
         B := vp1 = vp3
   testMaterialEquals:
      "**** testMaterialEquals:".print
      if (mp1.equals(mp2)) :then
         "mp1=mp2:OK,".print
      :else
         "mp1<>mp:wrong,".print  
      if (mp1.equals(mp3)) :then
         "mp1=mp3:wrong\n".print
      :else
         "mp1<>m3:OK\n".print 
      for (1):to(max) :repeat 
         B: var boolean
         B := mp1.equals(mp2)
         B := mp1.equals(mp3)
   testMaterialEQxyz:
      "**** testMaterialEQxyz:".print
      if ((mp1.x = mp2.x) && (mp1.y = mp2.y) && (mp1.z = mp2.z)) :then
         "mp1.x=mp2.x...:OK,".print
      :else
         "mp1.x<>mp2.x...:wrong,".print  
      if ((mp1.x = mp3.x) && (mp1.y = mp3.y) && (mp1.z = mp3.z)) :then
         "mp1.x=mp3.x...:wrong\n".print
      :else
         "mp1.x<>mp3.x...:OK\n".print  
      for (1):to(max) :repeat 
         B: var boolean
         B := (mp1.x = mp2.x) && (mp1.y = mp2.y) && (mp1.z = mp2.z)
         B := (mp1.x = mp3.x) && (mp1.y = mp3.y) && (mp1.z = mp3.z)
   testValueVirtual:
      "**** testValueVirtual:\n".print
      vp1.vFoo
      for (1) :to(max) :repeat
          vp1.vFoo
   testMaterialVirtual:
      "**** testMaterialVirt:\n".print
      mp1.mFoo
      for (1) :to(max) :repeat
          mp1.mFoo
   testValueTranslate:
      "**** testValueTranslate:\n".print
      vp1.translate(0.001,0.001)
      for (1) :to(max) :repeat
           vp1.translate(0.001,0.001)
          
   testMaterialTranslate:
      "**** testMaterialTranslate:\n".print
      mp1.translate(0.001,0.001)
      for (1) :to(max) :repeat
          mp1.translate(0.001,0.001)
   printCPUtime:
       "CPU time: ".print
       putint(cpuTime - startTime)
       " microseconsd\n".print
       startTime := cpuTime
   startTime: var integer
   endTime: var integer
   select: val 5
   heapTop: var Integer
   startTime := cpuTime
   heapTop := markHeap(0)
   "**** heapTop: ".print
   putint(heapTop)
   newline
   testValueEQ
   heapTop := markHeap(heapTop)
   printCPUtime
   testMaterialEquals
   heapTop := markHeap(heapTop)
   printCPUtime
   testMaterialEQxyz
   heapTop := markHeap(heapTop)
   printCPUtime
   newline
   testValueVirtual
   heapTop := markHeap(heapTop)
   printCPUtime
   testMaterialVirtual
   heapTop := markHeap(heapTop)
   printCPUtime
   newline
   testValueTranslate
   heapTop := markHeap(heapTop)
   printCPUtime
   testMaterialTranslate
   heapTop := markHeap(heapTop)
   printCPUtime