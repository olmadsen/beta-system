SimpleValueBench: obj
   %visible StringLib
   vPoint: Value
      in x: var float
      in y: var float
      in z: var float
      get_x:
         out V: var integer
         V := x
      vMsg:
         ...
      vFoo:
         vBar
      vBar:<
         ...
      translate:
         in dx: var float
         in dy: var float
         x := x + dx
         y := y + dy
   mPoint:
      in x: var float
      in y: var float
      in z: var float
      get_x:
         out V: var integer
         V := x
      equals:
         in p: ref mPoint
         out B: var Boolean
         B := (x = p.x) && (y = p.y) && (z = p.z)
      mMsg:
         ...
      mFoo:
         mBar
      mBar:<
         ...
      translate:
         in dx: var float
         in dy: var float
         x := x + dx
         y := y + dy
   vp1: var vPoint(1,2,3)
   vp2: var vPoint(1,2,3)  
   vp3: var vPoint(1,4,5)  
   mp1: obj mPoint(10,11,12)
   mp2: obj mPoint(10,11,12)
   mp3: obj mPoint(10,1,15)
   mp4: ref #mPoint
   mp4 := mPoint(10,3,17)
      
   tester:
      in n: var integer
      if (emitLatex.not) :then 
         if (n = 1) :then
            put(' ')
         :else
            put(',')
         putint(n)
      inner(tester)
   directValueX: tester
      benchA: do
         i: var integer
         i := i + 1
         F: var float
         F := vp1.x
         if (i <= executionsPerBenchmark) :then
            restart(benchA)
   directMaterialX: tester
      benchA: do
         i: var integer
         i := i + 1
         F: var float
         F := mp1.x
         if (i <= executionsPerBenchmark) :then
            restart(benchA)
   getValueX: tester
      benchA: do
         i: var integer
         i := i + 1
         F: var float
         F := vp1.get_x
         if (i <= executionsPerBenchmark) :then
            restart(benchA)
   getMaterialX: tester
      benchA: do
         i: var integer
         i := i + 1
         F: var float
         F := mp1.get_x
         if (i <= executionsPerBenchmark) :then
            restart(benchA)
   ValueEQ: tester
      bench1: do
         i: var integer
         i := i + 1
         B: var boolean
         B := vp1 = vp2
         --B := vp1 = vp3
         if (i <= executionsPerBenchmark) :then
            restart(bench1)
   MaterialEquals: tester
      bench2: do
         i: var integer
         i := i + 1
         B: var boolean
         B := mp1.equals(mp2)
         --B := mp1.equals(mp3)
         if (i <= executionsPerBenchmark) :then
            restart(bench2)
   MaterialEQxyz: tester
      bench3: do
         i: var integer
         i := i + 1
         B: var boolean
         B := (mp1.x = mp2.x) && (mp1.y = mp2.y) && (mp1.z = mp2.z)
         --B := (mp1.x = mp3.x) && (mp1.y = mp3.y) && (mp1.z = mp3.z)
         if (i <= executionsPerBenchmark) :then
            restart(bench3)
   ValueMethod: tester
      vp1.vMsg
      bench4: do
         i: var integer
         i := i + 1
         vp1.vMsg
         if (i <= executionsPerBenchmark) :then
            restart(bench4)
   MaterialMethod: tester
      mp1.mMsg
      bench5: do
         i: var integer
         i := i + 1
         mp1.mMsg
         if (i <= executionsPerBenchmark) :then
            restart(bench5)
   ValueVirtualMethod: tester
      vp1.vBar
      bench7: do
         i: var integer
         i := i + 1
         vp1.vBar
         if (i <= executionsPerBenchmark) :then
            restart(bench7)
   MaterialVirtualMethod: tester
      mp1.mBar
      bench8: do
         i: var integer
         i := i + 1
         mp1.mBar
         if (i <= executionsPerBenchmark) :then
            restart(bench8)
   MaterialVirtualMethodRef: tester
      mp4.mBar
      bench9: do
         i: var integer
         i := i + 1
         mp4.mBar
         if (i <= executionsPerBenchmark) :then
            restart(bench9)
   ValueVirtual: tester
      vp1.vFoo
      bench10: do
         i: var integer
         i := i + 1
         vp1.vFoo
         if (i <= executionsPerBenchmark) :then
            restart(bench10)
   MaterialVirtual: tester
      mp1.mFoo
      bench11: do
         i: var integer
         i := i + 1
         mp1.mFoo
         if (i <= executionsPerBenchmark) :then
            restart(bench11)
   ValueTranslate: tester
      vp1.translate(0.001,0.001)
      bench13: do
         i: var integer
         h: var integer
         i := i + 1
         h := markHeap(h)
         vp1.translate(0.001,0.001)
         if (i <= executionsPerBenchmark) :then
            restart(bench13)
   MaterialTranslate: tester
      mp1.translate(0.001,0.001)
      bench14: do
         i: var integer
         h: var integer
         i := i + 1
         h := markHeap(h)
         mp1.translate(0.001,0.001)
         if (i <= executionsPerBenchmark) :then
            restart(bench14)
   printCPUtime:
       "CPU time: ".print
       putint(cpuTime - startTime)
       " microseconds\n".print
       startTime := cpuTime

   "**** Simple value benchmark: runsPerTest: {I2S(runsPerTest)}, executionsPerBenchmark: {I2S(executionsPerBenchmark)}\n".print
   emitPreAmble:
      if (emitLatex) :then
         "\\begin\{center\}\\small\n\\begin\{tabular\}\{ |p\{3cm\}||c|c|c|c|c| \}\n".print
         "\\hline\n \\textbf\{subject\} & \\textbf\{object kind\}  & \\textbf\{mechanism\} & \\textbf\{min\} & \\textbf\{max\} & \\textbf\{mean\} \\\\\n\\hline\n".print
         "\\hline\n \\textbf\{what\} & \\textbf\{on what\}     & \\textbf\{how\} & \\textbf\{min\} & \\textbf\{max\} & \\textbf\{mean\} \\\\\n\\hline\n".print
   emitSep:
      if (emitLatex) :then
         "\\hline\n".print
      :else
         newline
      noOfRows := 0
   emitClosing:
      if (emitLatex) :then
         "\\hline\n\\end\{tabular\}\n\\end\{center\}\n".print
   emitHeader:
      in id: var String
      in isValue: var Boolean
      noOfRows := noOfRows + 1
      if (emitLatex) :then
         if (noOfRows = 1) :then
            "\\hline\n".print
            "\\multirow\{2\}\{3cm\}\{".print
            what.print
            "\}".print
         :else
            "\\cline\{2-6\}\n".print

         put('&')
         if (isValue) :then
            "value    & ".print
         :else
            "material & ".print
         id.print
         put(' ')
         put('&')
      :else
         "**** ".print
         if (isValue) :then
            "value    , ".print
         :else
            "material , ".print
         (id + ":").print 
   emitMinMaxMean: 
      in id: var String
      in isValue: var Boolean
      in bench: ref #array
      min: var integer
      max: var integer
      mean: var integer
      if (emitLatex.not) :then
         "\n**   ".print
      for (1) :to (bench.length) :repeat
           V: var integer
           V := bench.get[inx]
           if (emitLatex.not) :then
              putint(V)
              put(' ')
           if (min = 0) || ( V < min) :then
              min := V
           if (max < V) :then
              max := V
           mean := mean + V 
      mean := mean // bench.length
      if (emitLatex) :then
         " {I2S(min)} & {I2S(max)} & {I2S(mean)} \\\\\n".print
      :else
         "\n**   CPU-time, min: {I2S(min)}, max: {I2S(max)}, mean: {I2S(mean)}".print
   what: var String
   noOfRows: var integer
   startTime: var integer
   endTime: var integer
   runsPerTest: val 10
   executionsPerBenchmark: val 1000 -- 500000
   emitLatex: val True
   select: val 5
   heapTop: var Integer
   bench: obj Array(runsPerTest,#integer)
   bTop: var integer

   startTime := cpuTime
   emitPreAmble
   runTest:
      in id: var String
      in isValue: var Boolean
      h: var integer
      emitHeader(id,isValue)
      bTop := 0
      for (1):to(runsPerTest):repeat 
          h := markHeap(h)
          startTime := cpuTime
          bTop := bTop + 1
          inner(runTest)
          bench.put(cpuTime - startTime):at[bTop]
      emitMinMaxMean(id,isValue,bench)
      if (emitLatex.not) :then
         newline
   what := "Variable access"
   runTest("p.x",true)
      directValueX(bTop)
   heapTop := markHeap(heapTop)
   runTest("p.x",false)
      directMaterialX(bTop)
   emitSep
   what := "Getter access"
   runTest("p.getx",true)
      getValueX(bTop)
   heapTop := markHeap(heapTop)
   runTest("p.getx",false)
      getMaterialX(bTop)
   emitSep
   what := "Equality"
   runTest("p1 = p2",true)
      ValueEQ(bTop)
   heapTop := markHeap(heapTop)
   runTest("p1.equals(p2)",false)
      MaterialEquals(bTop)
   heapTop := markHeap(heapTop)
   runTest("p1.x=p2.x,...",false)
      MaterialEQxyz(bTop)
   emitSep
   what := "Remote method invocation"
   heapTop := markHeap(heapTop)
   runTest("p.foo",true)
      ValueMethod(bTop)
   heapTop := markHeap(heapTop)
   runTest("p.foo",false)
      MaterialMethod(bTop)
   emitSep
   what := "Remote virtual method invocation"
   heapTop := markHeap(heapTop)
   runTest("p.virtFoo",true)
      ValueVirtualMethod(bTop)
   heapTop := markHeap(heapTop)
   runTest("p.virtFoo",false)
      MaterialVirtualMethod(bTop)
   heapTop := markHeap(heapTop)
   runTest("P.virtFoo",false)
      MaterialVirtualMethodRef(bTop)
   heapTop := markHeap(heapTop)
   emitSep
   what := "Remote invocation of method calling local virtual"
   runTest("vp.foo",true)
      ValueVirtual(bTop)
   heapTop := markHeap(heapTop)
   runTest("p.foo",false)
      MaterialVirtual(bTop)
   emitSep
   what := "Remote method changing the object"
   heapTop := markHeap(heapTop)
   runTest("p.translate(e1,e2)",true)
      ValueTranslate(bTop)
   heapTop := markHeap(heapTop)
   runTest("p.translate(e1,e2)",false)
      MaterialTranslate(bTop)
   emitClosing