BinaryTreeMerge: obj
   maxInt: val 9999
   BinTree:
      Node: -- The nodes of the binary tree}
         in elem: var Integer;
         left: ref Node
         right: ref Node
         insert:
            in V: var integer
            @if V <= elem :then
                @if left = none :then
                    left := node(V)
                :else
                    left.insert(V)
            :else
               @if right = none :then
                   right := node(V)
               :else
                   right.insert(V)
      root: ref Node;
      next:
        out V: var Integer
        Traverse.call
        V := Traverse.next
      insert:
         in V: var integer
         @if root = none :then
             root := node(V)
         :else
             root.insert(V)
      Traverse: obj
         next: var integer      
         Scan:
            in current: ref Node
            @if (Current <> NONE) :then
                 scan(current.left)
                 next := current.elem
                 Traverse.SUSPEND;
                 scan(current.right)
         Traverse.suspend
         Scan(root)
         next:= MaxInt
         cycle
            Traverse.suspend
         -- {Exit maxInt hereafter}
   b1: obj BinTree
   b2: obj Bintree
   e1: var integer
   e2: var Integer
   b1.insert(15)
   b1.insert(6)
   b1.insert(27)
   b1.insert(21)
   b2.insert(14)
   b2.insert(8)
   b2.insert(28)
   b2.insert(20)   
   --b1.Traverse.call
   e1 := b1.next
   --putint(e1)
   --put(',')
   --b2.Traverse.call
   --put('E')
   e2 := b2.next
   --putint(e2)
   Merge:
      Cycle
         @if (e1 = MaxInt) && (e2 = MaxInt) :then
             @leave Merge
         @if (e1 <  e2) :then
             putint(e1)
             --b1.Traverse.call
             e1 := b1.next
         :else
             putint(e2)
             --b2.Traverse.call
             e2 := b2.next
         put(' ')
   Merge
   