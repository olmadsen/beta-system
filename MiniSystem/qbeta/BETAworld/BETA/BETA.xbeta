BETA: obj
    [OSDvisibility[disguised]]
    universal: Value
       [basic[1,32],globals[]]
       + V: var integer -> R: var integer:
           [basic[61]]
       - V: var integer -> R: var integer:
           [basic[62]]
    integer: value
       [basic[1,32],globals[]]
       _v: var Universal
       + V: var integer -> R: var integer:
           [basic[61]]
       - V: var integer -> R: var integer:
           [basic[62]]
       * V: var integer -> R: var integer:
           [basic[66]]
       / V: var integer -> R: var integer:
           [basic[67]]
       // V: var integer -> B: var integer:
           [basic[68]]
       /% V: var integer -> R: var integer:
           [basic[69]]
       = V: var integer -> B: var boolean:
           [basic[50]]
       < V: var integer -> B: var boolean:
           [basic[51]]
       <= V: var integer -> B: var boolean:
           [basic[52]]
       > V: var integer -> B: var boolean:
           [basic[53]]
       >= V: var integer -> B: var boolean:
           [basic[54]]
       <> V: var integer -> B: var boolean:
           [basic[55]]
       cmpAndSwap(V: var integer) -> res: var integer:
           [basic[14]]

    Boolean: value
       [basic[4,8],globals[inSub]]
       _v: var Universal
       && B: var boolean -> B: var boolean:
           [basic[70]]
       || B: var boolean -> R: var boolean:
           [basic[63]]
       = B: var boolean -> R: var boolean:
           [basic[50]]
       not -> R: var boolean:
           [basic[65]]
    False -> B: var boolean:
       [globals[]]
       B := 0
    True -> B: var boolean:
       [globals[]]
       B := 1
    char: value
       [basic[3,16],globals[]]
       _v: var Universal
       + V: var char -> R: var char:
           [basic[61]]
       - V: var char -> R: var char:
           [basic[62]]   
       = V: var char -> B: var boolean:
           [basic[50]]
       < V: var char -> B: var boolean:
           [basic[51]]
       <= V: var char -> B: var boolean:
           [basic[52]]
       > V: var char -> B: var boolean:
           [basic[53]]
       >= V: var char -> B: var boolean:
           [basic[54]]
       <> V: var char -> B: var boolean:
           [basic[55]]
    put(ch: val char):
       [basic[2],globals[]]
    _iget-> ch: var char:
       [external[4]]
    _kbhit-> B: var boolean:
       [external[5]]
    Object:
       [basic[64]]
       := V: ref Value:
           [basic[8]]
       :- R: ref Object:
           [basic[6]]
       = objx: ref Object -> V: var boolean:
           [basic[56]]
       <> objx: ref Object -> V: var boolean:
           [basic[57]]
       suspend: 
           [basic[111]]
       attach(V: var integer):
           [basic[10]]
       resume:
           [basic[113]]
       onResume:
           [basic[119]]
       onSuspend:
           [basic[120]]
       dumpObj -> R: ref Indexed:
           [basic[140]]
       %inner Object
    Value:
       [basic[21],globals[]]
       := V: var Value:
           [basic[8]]
    none:
       [basic[19]]
       none_x: var integer
    immutable:
       [basic[20]]
       %inner immutable
    inner:
       [basic[101]]
    %inner P: ref Object:
       [basic[101]]
    %this P: ref Object:
       [basic[18]]
    disable:
      [basic[11]]
    enable:
       [basic[12]]
    fork(S: ref Object): 
       [basic[13]]
    sleep(V: var integer): 
       [basic[15]]
    core:
       dummy: var integer
    thisCore -> C: ref core:
       [basic[17]]
       C := core
    thisCoreId -> V: var integer:
       [basic[22]]
    inSub:
       [basic[7]]
    Indexed(range: var Integer, elm:< Object):
       [basic[114],globals[]]   
       %put V: ref elm %at% inx: var integer:
          [basic[115]]
       %get inx: var integer -> V: var integer:
          [basic[116]]
       length -> res: var integer:
          res := %get 0 -- actually an index error
       asString -> S: ref Object:
           [basic[118]]
           -- converts this (indexed) to a String
           -- we should move String to here and qualify S as String

    %if _cond: var boolean %then% _thenPart:< Object:
       [basic[100],globals[inSub]]
    %restart Objx: var integer:
       [basic[102]]
    %leave Objx: var integer:
       [basic[103]]
    %if cond: var boolean %then% thenPart:< Object %else% elsePart:< Object:
       [globals[inSub]] --,OSDvisibility[disguised]]
       ugly_y: var integer
       _L: =
          x_uglye: var integer
          %if cond %then%
              thenPart
              %leave _L
          elsePart
    cycle:
       [globals[inSub]]
       %inner cycle
       %restart cycle
    %for first: var integer %to% last: var integer %do% body:< Object:
         [globals[inSub]]
         inx: var integer
         do:
           loop: =
             %if inx <= last %then%
                 body
                 inx := inx + 1
                 %restart loop
         inx := first
         do
         %inner 
    switch(V: var integer):
       case(x: var integer):
          %if V = x %then%
              %inner case
              %leave switch
       %inner switch
    %xswitch V: var integer:
       %scase x: var integer:
          %if V = x %then%
              %inner %scase
              %leave %xswitch
       %inner %xswitch
    ascii: =
       nl: val 10
       cr: val 13
       newline: var char
       newline:= cr -- Windows/Linux???
    newline:
       [globals[]]
       put(10)
    putint(V: var integer):
       [globals[]]
       D: = Indexed(20,integer)
       L: var integer
       isNeg: var Boolean
       isNeg := V < 0
       %if isNeg %then% V := 0 - V
       doit:
          loop: =
              L := L + 1
              D.%put V /% 10 %at% L
              V := V // 10
              %if V > 0 %then% 
                  %restart loop
          %if isNeg %then% put('-')
          %for 1 %to% L %do%
               i: var integer
               i := L + 1 - inx
               put('0' + D.%get i)
       doit

    I2S(V: var integer) -> S: ref Object:
          [globals[]]
          D: = Indexed(20,char)
          D2: = Indexed(20,char)
          L: var integer
          isNeg: var Boolean
          isNeg := V < 0
          %if isNeg %then%
             V := 0 - V
             D.%put '-' %at% 1
             L := 1
          doit:
             loop: =
                 L := L + 1
                 D.%put('0' + V /% 10) %at% L
                 V   := V // 10
                 %if V > 0 %then% 
                     %restart loop
             %for 1 %to% L %do%
                  i: var integer
                  D2.%put (D.%get(L + 1 - inx)) %at% inx
          doIt
          T: ref LIB.string.String	  
          T := D2.asString
          --putint(T.length)
          --newline
          S := T
       

