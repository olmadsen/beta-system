BETA: obj
    [OSDvisibility[disguised]]
    universal: Value
       [basic[1,32],globals[]]
       + V: var integer -> R: var integer:
           [basic[61]]
       - V: var integer -> R: var integer:
           [basic[62]]
    integer: value
       [basic[1,32],globals[]]
       _thisBasicValue: var Universal
       + V: var integer -> R: var integer:
           [basic[61]]
       - V: var integer -> R: var integer:
           [basic[62]]
       * V: var integer -> R: var integer:
           [basic[66]]
       / V: var integer -> R: var integer:
           [basic[67]]
       // V: var integer -> B: var integer:
           [basic[68]]
       /% V: var integer -> R: var integer:
           [basic[69]]
       = V: var integer -> B: var boolean:
           [basic[50]]
       < V: var integer -> B: var boolean:
           [basic[51]]
       <= V: var integer -> B: var boolean:
           [basic[52]]
       > V: var integer -> B: var boolean:
           [basic[53]]
       >= V: var integer -> B: var boolean:
           [basic[54]]
       <> V: var integer -> B: var boolean:
           [basic[55]]
       cmpAndSwap:
           [basic[14]]
           in V: var integer
           out  res: var integer

    Boolean: value
       [basic[4,8],globals[inSub]]
       _thisBasicValue: var Universal
       && B: var boolean -> B: var boolean:
           [basic[70]]
       || B: var boolean -> R: var boolean:
           [basic[63]]
       = B: var boolean -> R: var boolean:
           [basic[50]]
       not -> R: var boolean:
           [basic[65]]
    False:
       [globals[]]
       out B: var boolean
       B := 0
    True:
       [globals[]]
       out B: var boolean
       B := 1
    char: value
       [basic[3,16],globals[]]
       _thisBasicValue: var Universal
       + V: var char -> R: var char:
           [basic[61]]
       - V: var char -> R: var char:
           [basic[62]]   
       = V: var char -> B: var boolean:
           [basic[50]]
       < V: var char -> B: var boolean:
           [basic[51]]
       <= V: var char -> B: var boolean:
           [basic[52]]
       > V: var char -> B: var boolean:
           [basic[53]]
       >= V: var char -> B: var boolean:
           [basic[54]]
       <> V: var char -> B: var boolean:
           [basic[55]]
    put:
       [basic[2],globals[]]
       in ch: val char
    _iget:
       [external[4]]
       out ch: var char
    _kbhit:
       [external[5]]
       out B: var boolean
       
    Object:
       [basic[64]]
       := V: ref Value:
           [basic[8]]
       :- R: ref Object:
           [basic[6]]
       = : 
           [basic[56]]
           in objx: ref Object
           out V: var boolean
       <> :
           [basic[57]]
           in objx: ref Object
           out V: var boolean
       suspend: 
           [basic[111]]
       attach:
           [basic[10]]
           in V: var integer
       resume:
           [basic[113]]
       onResume:
           [basic[119]]
       onSuspend:
           [basic[120]]
       dumpObj:
           [basic[140]]
           out R: ref Indexed
       @inner Object
    Value:
       [basic[21],globals[]]
       := V: var Value:
           [basic[8]]
    none:
       [basic[19]]
       none_x: var integer
    immutable:
       [basic[20]]
       @inner immutable
    inner:
       [basic[101]]
    %inner P: ref Object:
       [basic[101]]
    @inner: 
       [basic[101]]
       in inner: ref Object

    %this P: ref Object:
       [basic[18]]

    @this:
       [basic[18]]
       in this: ref Object

    disable:
      [basic[11]]
    enable:
       [basic[12]]
    fork:   
       [basic[13]]
       in S: ref Object
    sleep:
       [basic[15]]
       in V: var integer
    core:
       dummy: var integer
    thisCore:
       [basic[17]]
       out C: ref core
       C := core
    thisCoreId:
       [basic[22]]
       outV: var integer
    inSub:
       [basic[7]]
    Indexed:
       [basic[114],globals[]]   
       in range: var Integer
       in  elm:< Object
       length:
          out res: var integer
          res := @get 0 -- actually an index error
       @put:
          [basic[115]]
          in put: ref elm 
          in at: var integer	  
       @get:
          [basic[116]]
          in get: var integer
          out V: var integer

       asString -> S: ref Object:
           [basic[118]]
           -- converts this (indexed) to a String
           -- we should move String to here and qualify S as String

    %if _cond: var boolean %then% _thenPart:< Object:
       [basic[100],globals[inSub]]
    @if:
       [basic[100],globals[inSub]]
       in if: var boolean
       in then:< Object

              
    %restart Objx: var integer:
       [basic[102]]
    %leave Objx: var integer:
       [basic[103]]
    @restart:
       [basic[102]]
       in restart: var integer
    @leave: 
       [basic[103]]
       in leave: var integer
       
    %if cond: var boolean %then% thenPart:< Object %else% elsePart:< Object:
       [globals[inSub]] --,OSDvisibility[disguised]]
       ugly_y: var integer
       _L: =
          x_uglye: var integer
          %if cond %then%
              thenPart
              %leave _L
          elsePart
    @if:   § Declaration of if then else control pattern
       [globals[inSub]] --,OSDvisibility[disguised]]
       in if: ?Boolean
       in then:< Object
       in else:< Object
       _L: obj
          %if if
          %then%
             then
             %leave _L
          else
    cycle:
       [globals[inSub]]
       @inner cycle
       @restart cycle
    %for first: var integer %to% last: var integer %do% body:< Object:
         [globals[inSub]]
         inx: var integer
         do:
           loop: obj
             %if inx <= last %then%
                 body
                 inx := inx + 1
                 %restart loop
         inx := first
         do
         %inner 

    @for:
       [globals[inSub]]
       in for: var integer 
       in to: var integer 
       in do:< Object
       inx: var integer
       doIt:
          loop: obj
            @if inx <= to :then
                do
                inx := inx + 1
                @restart loop
       inx := for
       doIt
       @inner
	 
    switch:
       in V: var integer
       case:
          in x: var integer
          @if V = x :then
              @inner case
              @leave switch
       @inner switch

    @xswitch:
       in xswitch: var integer
       @scase: 
          in scase: var integer
          @if scase = xswitch :then
              @inner @scase
              @leave @xswitch
       @inner @xswitch
       
    ascii: =
       nl: val 10
       cr: val 13
       newline: var char
       newline:= cr -- Windows/Linux???
    newline:
       [globals[]]
       put(10)
    putint:
       [globals[]]
       in V: var integer
       D: = Indexed(20,integer)
       L: var integer
       isNeg: var Boolean 
       isNeg := V < 0
       @if isNeg :then V := 0 - V
       doit:
          loop: =
              L := L + 1
              D.@put V /% 10 :at L
              V := V // 10
              @if V > 0 :then 
                  @restart loop
          @if isNeg :then put('-')
          @for 1 :to L :do
               i: var integer
               i := L + 1 - inx
               put('0' + D.@get i)
       doit

    I2S:
          [globals[]]
          in V: var integer
          out S: ref Object

          D: = Indexed(20,char)
          D2: = Indexed(20,char)
          L: var integer
          isNeg: var Boolean
          isNeg := V < 0
          @if isNeg :then
             V := 0 - V
             D.@put '-' :at 1
             L := 1
          doit:
             loop: =
                 L := L + 1
                 D.@put('0' + V /% 10) :at L
                 V   := V // 10
                 @if V > 0 :then
                     @restart loop
             @for 1 :to L :do
                  i: var integer
                  D2.@put (D.@get(L + 1 - inx)) :at inx
          doIt
          T: ref LIB.string.String	  
          T := D2.asString
          --putint(T.length)
          --newline
          S := T
       

