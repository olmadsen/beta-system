
 CLASS BETAworld 21 1 BETA 2
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(Object) "
 -- handleInv: "inner(Object) " staticOff: 0 doLoad: true 
 --  useRtnVal: false 
 -- isPtnWithOrigin: "inner(Object) " 
 --  "inner(Object) " true 
 -- needOriginII: "inner(Object) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- needOrigin: true "inner(Object) " 
 -- exps.range: 1 exps[i]: "inner(Object) " needOrigin: true 
 -- isConst: "inner(Object) " ObjectInvocation_KeyWord 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- updateOffset: "inner(Object) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- loadPathII:E: "inner(Object) " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "inner(Object) " 
 -- loadPathII:before:newInvoke: "inner(Object) " true 
 -- checkForProxy:E: "inner(Object) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "inner(Object) " 
 -- ptn:newInvoke: "inner " staticOff: 0 
 -- oPTN:newInvoke: "inner " 101 
 pushThis 
 innerP  2
 rpopThisObj 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS BETAworld 1 1 Object 21
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 pushThis 
 saveBETAworld
 mvStack 
 pushThis 
 -- before objTmpStack:add:  2   "BETA "
 invoke BETA 2 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  33   "LIB "
 invoke LIB 33 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  67   "OOPM "
 invoke OOPM 67 4 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS BETA 2 1 BETAworld 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: 
 --  ascii: obj 
 --     asciiFoo: 
 --        msg1:  -- obj
 --           _put('F')DI:isConst: true isBasicValue: false primNo: 0 
 -- DI:isConst: ascii 
 -- DI:off: 2 this: 
 --  ascii: obj 
 --     asciiFoo: 
 --        msg1:  -- obj
 --           _put('F')
 --  
 pushThis 
 -- before objTmpStack:add:  3   "ascii "
 invoke ascii 3 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- DI:gen: "console: ref ConsoleIF " DI:isConst: false 
 --  isBasicValue: false primNo: 0 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:2 objSize:3 isIndexed:0

 CLASS ascii 3 1 BETA 2
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "nl: val 10 " DI:isConst: true isBasicValue: true 
 --  primNo: 1 
 -- DI:valueObj: nl 
 -- OG:before:super.gen: "10 "
 -- handleInv: "10 " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "10 " 
 --  "10 " false 
 -- needOriginII: "10 " 
 -- E: ConstLiteral D: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- needOrigin: true "10 " 
 -- exps.range: 1 exps[i]: "10 " needOrigin: true 
 -- isConst: "10 " ConstLiteral 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- isConstLiteral: "10 " 
 pushc 10
 -- const:cst: "10 " 10 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- DI:store:basicValue: off: 1 NewOff: 2 
 pushThis 
 storeg nl 2
 -- DI:gen: "cr: val 13 " DI:isConst: true isBasicValue: true 
 --  primNo: 1 
 -- DI:valueObj: cr 
 -- OG:before:super.gen: "13 "
 -- handleInv: "13 " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "13 " 
 --  "13 " false 
 -- needOriginII: "13 " 
 -- E: ConstLiteral D: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- needOrigin: true "13 " 
 -- exps.range: 1 exps[i]: "13 " needOrigin: true 
 -- isConst: "13 " ConstLiteral 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- isConstLiteral: "13 " 
 pushc 13
 -- const:cst: "13 " 13 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- DI:store:basicValue: off: 2 NewOff: 3 
 pushThis 
 storeg cr 3
 -- DI:gen: "null: val 0 " DI:isConst: true isBasicValue: true 
 --  primNo: 1 
 -- DI:valueObj: null 
 -- OG:before:super.gen: "0 "
 -- handleInv: "0 " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "0 " 
 --  "0 " false 
 -- needOriginII: "0 " 
 -- E: ConstLiteral D: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- needOrigin: true "0 " 
 -- exps.range: 1 exps[i]: "0 " needOrigin: true 
 -- isConst: "0 " ConstLiteral 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- isConstLiteral: "0 " 
 pushc 0
 -- const:cst: "0 " 0 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- DI:store:basicValue: off: 3 NewOff: 4 
 pushThis 
 storeg null 4
 -- DI:gen: "newline: var char " DI:isConst: false isBasicValue: 
 --  true primNo: 3 
 -- DI:gen:primitiveType: newline 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- handleAssign: 
 --  newline := nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  
 -- handleInv: "newline " staticOff: 0 doLoad: false useRtnVal: 
 --  false 
 -- isPtnWithOrigin: "newline " 
 --  "newline " false 
 -- needOriginII: "newline " 
 -- E: ObjectInvocation_Unary D: "newline: var char " 
 -- needOrigin: true "newline " 
 -- exps.range: 1 exps[i]: "newline " needOrigin: true 
 -- isConst: "newline " ObjectInvocation_Unary "newline: var char " 
 -- isConst:DI: "newline: var char " 
 -- updateOffset: "newline " E.ATd: "newline: var char " 
 -- loadPathII:E: "newline " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "newline " 
 pushThis 
 -- loadPathII:before:newInvoke: "newline " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: 
 --  newline := nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  leftE: "newline " 
 -- OG:before:super.gen: "
 --  nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1 "
 -- handleInv: 
 --  nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: 
 --  nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  
 --  
 --  nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  false 
 -- needOriginII: 
 --  nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  
 -- E: ObjectInvocation_Unary D: "nl: val 10 " 
 -- needOrigin: true 
 --  nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  
 -- exps.range: 1 exps[i]: 
 --  nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  needOrigin: true 
 -- isConst: 
 --  nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  ObjectInvocation_Unary "nl: val 10 " 
 -- isConst:DI: "nl: val 10 " 
 -- isConst:DI:isConst "nl: val 10 " 
 pushc 10
 -- const:cst: 
 --  nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  10 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: 
 --  newline := nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- checkI2F2I: 
 --  newline := nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  left.isFloat: false right.isFloat: false false left.isFloat:X: 
 --  false 
 -- ???:left.isFloat: false 
 -- Assign:end: 
 --  newline := nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  isNotRemote: false qual: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  D: none 
 -- DI:newStore: "newline " off: 5 valueOff: 0 dstE: "newline " 
 --  isNotRemote: false originIsValueObj: false isUnitValueObj: false 
 --  rightQual:primNo: 1 rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 storeg char$7 5
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0

 CLASS Value 4 0 BETA 2 isValueObj
 mvStack 
 rtnAlloc 1
DO:
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:0 isIndexed:0

 CLASS integer 5 0 BETA 2 isValueObj
 mvStack 
 -- DI:gen: "_thisBasicValue: var Universal " DI:isConst: false 
 --  isBasicValue: true primNo: 1 
 -- DI:gen:primitiveType: _thisBasicValue 
 rtnAlloc 1
DO:
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS universal 6 0 BETA 2 isValueObj
 mvStack 
 rtnAlloc 1
DO:
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:0 isIndexed:0

 CLASS char 7 0 BETA 2 isValueObj
 mvStack 
 -- DI:gen: "_thisBasicValue: var Universal " DI:isConst: false 
 --  isBasicValue: true primNo: 1 
 -- DI:gen:primitiveType: _thisBasicValue 
 rtnAlloc 1
DO:
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS ConsoleIF 8 1 BETA 2
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS put 9 1 ConsoleIF 8
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS String 10 0 StringLib 41
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:2 objSize:0 isIndexed:1

 CLASS = 11 1 Value 4
 jmpFalse  L3
 pushThis 
 -- vassign:B: Veq off: 4 size: 2 mode: 0 
 vassign  4 2 0
 jmp L4
 L3:
 invokeVal  Veq 31 3
 rpop 
 L4:
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in Veq: var this(Value) " DI:isConst: false 
 --  isBasicValue: false primNo: 18 
 -- DI:isConst: Veq 
 -- inArg: in Veq: var this(Value) 
 -- DI:gen: "out Beq: var boolean " DI:isConst: false isBasicValue: 
 --  true primNo: 4 
 -- DI:gen:primitiveType: Beq 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(= ) "
 -- handleInv: "inner(= ) " staticOff: 0 doLoad: true useRtnVal: 
 --  false 
 -- isPtnWithOrigin: "inner(= ) " 
 --  "inner(= ) " true 
 -- needOriginII: "inner(= ) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- needOrigin: true "inner(= ) " 
 -- exps.range: 1 exps[i]: "inner(= ) " needOrigin: true 
 -- isConst: "inner(= ) " ObjectInvocation_KeyWord 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- updateOffset: "inner(= ) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- loadPathII:E: "inner(= ) " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "inner(= ) " 
 -- loadPathII:before:newInvoke: "inner(= ) " true 
 -- checkForProxy:E: "inner(= ) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "inner(= ) " 
 -- ptn:newInvoke: "inner " staticOff: 0 
 -- oPTN:newInvoke: "inner " 101 
 pushThis 
 innerP  2
 rpopThisObj 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0

 CLASS = 13 1 String 10
 -- vdtTableCopy: I:1:11 I:2:0
 rShiftUp  1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- super =
 pushThis 
 rpushg iOrigin 1
 rShiftDown  1
 pushThis 
 rstoreg  Veq 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in Veq: var this(Value) " DI:isConst: false 
 --  isBasicValue: false primNo: 18 
 -- DI:isConst: Veq 
 -- inArg: in Veq: var this(Value) 
 -- DI:gen: "out Beq: var boolean " DI:isConst: false isBasicValue: 
 --  true primNo: 4 
 -- DI:gen:primitiveType: Beq 
DO:
 doEventQ
 mvStack 
 L1:
 pushThis 
 -- before objTmpStack:add:  14   "loop "
 invoke loop 14 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS loop 14 1 = 13
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "c1: var char " DI:isConst: false isBasicValue: true 
 --  primNo: 3 
 -- DI:gen:primitiveType: c1 
 -- DI:gen: "c2: var char " DI:isConst: false isBasicValue: true 
 --  primNo: 3 
 -- DI:gen:primitiveType: c2 
 -- DI:gen: "L: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: L 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- handleAssign: "L := length " 
 -- handleInv: "L " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "L " 
 --  "L " false 
 -- needOriginII: "L " 
 -- E: ObjectInvocation_Unary D: "L: var integer " 
 -- needOrigin: true "L " 
 -- exps.range: 1 exps[i]: "L " needOrigin: true 
 -- isConst: "L " ObjectInvocation_Unary "L: var integer " 
 -- isConst:DI: "L: var integer " 
 -- updateOffset: "L " E.ATd: "L: var integer " 
 -- loadPathII:E: "L " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "L " 
 pushThis 
 -- loadPathII:before:newInvoke: "L " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "L := length " leftE: "L " 
 -- OG:before:super.gen: "length "
 -- handleInv: "length " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "length " 
 --  "length " true 
 -- needOriginII: "length " 
 -- E: ObjectInvocation_Unary D: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- needOrigin: true "length " 
 -- exps.range: 1 exps[i]: "length " needOrigin: true 
 -- isConst: "length " ObjectInvocation_Unary 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- updateOffset: "length " E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- loadPathII:E: "length " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "length " 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 2 isValueObj: false 
 --  origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- items:goOrigin:encOG: "= "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg =$13 1
 -- loadPathII:before:newInvoke: "length " true 
 -- checkForProxy:E: "length " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "length " 
 -- ptn:newInvoke: "length " staticOff: 0 
 -- gPTN:newInvoke: "length " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: none 
 -- invoke:nonVirtual: "length " isAdr: false 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "L := length " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- right:isPTN:not:valueObj: "out V: var integer " 
 -- checkI2F2I: "L := length " left.isFloat: false right.isFloat: 
 --  false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- Assign:end: "L := length " isNotRemote: false qual: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  D: none 
 -- DI:newStore: "L " off: 4 valueOff: 0 dstE: "L " isNotRemote: 
 --  false originIsValueObj: false isUnitValueObj: false rightQual:primNo: 1 
 --  rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 storeg integer$5 4
 -- OG:before:super.gen: "if (L <> Veq.length) :then 
 --     leave(loop) "
 -- handleInv: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  staticOff: 0 doLoad: true useRtnVal: false 
 -- isPtnWithOrigin: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  
 --  
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  false 
 -- needOriginII: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  
 -- E: IfThen D: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- needOrigin: false 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  
 -- exps.range: 1 exps[i]: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  needOrigin: false 
 -- isConst: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  IfThen 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- noOrigin: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  
 -- loadPathII:E: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  1 1 exps.range: 1 staticOff: 0 
 -- loadPathII:before:newInvoke: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  true 
 -- checkForProxy:E: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  isBasicValue: false origin.isValueObj: false staticOff: 0 rec: 
 --  none 
 -- loadPathII:next: 1 1 
 -- IfThen:newInvoke: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  
 -- OG:before:super.gen: "(L <> Veq.length) "
 -- handleInv: "(L <> Veq.length) " staticOff: 0 doLoad: true 
 --  useRtnVal: true 
 -- isPtnWithOrigin: "(L <> Veq.length) " 
 --  "L " false "<> Veq.length " true 
 -- needOriginII: "(L <> Veq.length) " 
 -- E: ObjectInvocation_Unary D: "L: var integer " 
 -- E: ObjectInvocation_Binary D: 
 --  <>  : 
 --     %basic 55
 --     in V: var integer
 --     out B: var boolean
 --  
 -- needOrigin: true "<> Veq.length " 
 -- exps.range: 2 exps[i]: "L " exps[i]: "<> Veq.length " 
 --  needOrigin: true 
 -- isConst: "L " ObjectInvocation_Unary "L: var integer " 
 -- isConst:DI: "L: var integer " 
 -- updateOffset: "L " E.ATd: "L: var integer " 
 -- isConst: "<> Veq.length " ObjectInvocation_Binary 
 --  <>  : 
 --     %basic 55
 --     in V: var integer
 --     out B: var boolean
 --  
 -- updateOffset: "<> Veq.length " E.ATd: 
 --  <>  : 
 --     %basic 55
 --     in V: var integer
 --     out B: var boolean
 --  
 -- loadPathII:E: "L " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "L " 
 pushThis 
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "L " 
 -- DI:loadAccessor: "L " 
 -- DI:loadAccesor:loadPrimitive: "L " 
 pushg 4 newInvoke
 -- loadPathII:E: "<> Veq.length " 1 2 exps.range: 2 staticOff: 0 
 -- E: "<> Veq.length " E:isPrimitiveIntWithFloatArg: false rec: "
 --  L " isFloat: false 
 -- NonVirt: "<> Veq.length " "ObjectInvocation_Binary " ActArg: "
 --  Veq.length "isValue: false formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "<> Veq.length "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "Veq.length "
 -- handleInv: "Veq.length " staticOff: 0 doLoad: true useRtnVal: 
 --  true 
 -- isPtnWithOrigin: "Veq.length " 
 --  "Veq " false "length " true 
 -- needOriginII: "Veq.length " 
 -- E: ObjectInvocation_Unary D: "in Veq: var this(Value) " 
 -- E: ObjectInvocation_Unary D: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- needOrigin: true "length " 
 -- exps.range: 2 exps[i]: "Veq " exps[i]: "length " needOrigin: 
 --  true 
 -- isConst: "Veq " ObjectInvocation_Unary "
 --  in Veq: var this(Value) " 
 -- isConst:DI: "in Veq: var this(Value) " 
 -- valueOff: 0 E.newOff: 2 "Veq " 
 -- isValueObj:E: "Veq " valueOff: 2 
 -- isConst: "length " ObjectInvocation_Unary 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- updateOffset: "length " E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- loadPathII:E: "Veq " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "Veq " 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "Veq " 
 -- DI:loadAccessor: "Veq " 
 -- DI:loadAccessor:accessValObj: "Veq " 
 rpushg newInvoke 2
 -- loadPathII:E: "length " 1 2 exps.range: 2 staticOff: 0 
 -- E: "length " E:isPrimitiveIntWithFloatArg: false rec: "Veq " 
 --  isFloat: false 
 -- loadPathII:before:newInvoke: "length " true 
 -- checkForProxy:E: "length " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: "Veq " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "length " 
 -- ptn:newInvoke: "length " staticOff: 0 
 -- gPTN:newInvoke: "length " ptnKind: 0 staticOff: 0 valueOff: 2 
 --  rec: "Veq " 
 -- invoke:nonVirtual: "length " isAdr: false 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- handleINV:end: isNotRemote: true valueOff: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "Veq.length ":isBasicVal: true 
 -- case:B: Veq.length ObjectGenerator 1 0 0 false false 
 -- isIntForFloatArg: "Veq.length " D: "in V: var integer " true 
 --  false srcOG.isFloat: false src.isUnitValueObj: false this: "
 --  Veq.length " false 
 --  B: false 
 --  
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- end:loadArgs:NonVirt: "<> Veq.length "
 -- loadPathII:before:newInvoke: "<> Veq.length " true 
 -- checkForProxy:E: "<> Veq.length " isBasicValue: false 
 --  origin.isValueObj: true staticOff: 0 rec: "L " 
 -- checkForProxy:rec=None:localInvocation? "(L <> Veq.length) " E: "
 --  <> Veq.length " rec: "L " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "<> Veq.length " 
 -- ptn:newInvoke: "<>   " staticOff: 0 
 -- gPTN:newInvoke: "<>   " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: "L " 
 -- checkInt2IntWithUnitArg:E: "<> Veq.length " false false 
 ne
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  18   "$18 "
 invoke $18 18 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign: "beq := true " 
 -- handleInv: "beq " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "beq " 
 --  "beq " false 
 -- needOriginII: "beq " 
 -- E: ObjectInvocation_Unary D: "out Beq: var boolean " 
 -- needOrigin: true "beq " 
 -- exps.range: 1 exps[i]: "beq " needOrigin: true 
 -- isConst: "beq " ObjectInvocation_Unary "out Beq: var boolean " 
 -- isConst:DI: "out Beq: var boolean " 
 -- updateOffset: "beq " E.ATd: "out Beq: var boolean " 
 -- loadPathII:E: "beq " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "beq " 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- loadPathII:before:newInvoke: "beq " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "beq := true " leftE: "beq " 
 -- OG:before:super.gen: "true "
 -- handleInv: "true " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "true " 
 --  "true " false 
 -- needOriginII: "true " 
 -- E: ObjectInvocation_Unary D: 
 --  True: 
 --     %globals
 --     out B: var boolean
 --     B := 1
 --  
 -- needOrigin: false "true " 
 -- exps.range: 1 exps[i]: "true " needOrigin: false 
 -- isConst: "true " ObjectInvocation_Unary 
 --  True: 
 --     %globals
 --     out B: var boolean
 --     B := 1
 --  
 -- noOrigin: "true " 
 -- loadPathII:E: "true " 1 1 exps.range: 1 staticOff: 0 
 -- loadPathII:before:newInvoke: "true " true 
 -- checkForProxy:E: "true " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "true " 
 -- ptn:newInvoke: "True " staticOff: 0 
 -- gPTN:newInvoke: "True " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: none 
 -- invoke:nonVirtual: "True " isAdr: false 
 invoke True 23 0 0
 -- global:pushOut: B off: 1 
 pushg 1 
 -- callInvoke:after:pushOut: 1 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "beq := true " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- right:isPTN:not:valueObj: "out B: var boolean " 
 -- checkI2F2I: "beq := true " left.isFloat: false right.isFloat: 
 --  false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- Assign:end: "beq := true " isNotRemote: false qual: 
 --  value
 --     %id "Boolean"
 --     %globals inSub
 --     %basic 4, 8
 --  D: none 
 -- DI:newStore: "Beq " off: 3 valueOff: 0 dstE: "beq " 
 --  isNotRemote: false originIsValueObj: false isUnitValueObj: false 
 --  rightQual:primNo: 4 rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 storeg Boolean$42 3
 pushThis 
 -- before objTmpStack:add:  30   "for:to:repeat$30 "
 invoke for:to:repeat$30 30 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS length 15 1 String 10
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "out V: var integer " DI:isConst: false isBasicValue: 
 --  true primNo: 1 
 -- DI:gen:primitiveType: V 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- handleAssign: "
 --  V := get[0] -- actually an index error, accessing length " 
 -- handleInv: "V " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "V " 
 --  "V " false 
 -- needOriginII: "V " 
 -- E: ObjectInvocation_Unary D: "out V: var integer " 
 -- needOrigin: true "V " 
 -- exps.range: 1 exps[i]: "V " needOrigin: true 
 -- isConst: "V " ObjectInvocation_Unary "out V: var integer " 
 -- isConst:DI: "out V: var integer " 
 -- updateOffset: "V " E.ATd: "out V: var integer " 
 -- loadPathII:E: "V " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "V " 
 pushThis 
 -- loadPathII:before:newInvoke: "V " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "
 --  V := get[0] -- actually an index error, accessing length " leftE: "V " 
 -- OG:before:super.gen: "
 --  get[0] -- actually an index error, accessing length "
 -- handleInv: "
 --  get[0] -- actually an index error, accessing length " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "
 --  get[0] -- actually an index error, accessing length " 
 --  "get[0] -- actually an index error, accessing length " true 
 -- needOriginII: "
 --  get[0] -- actually an index error, accessing length " 
 -- E: ObjectInvocation_KeyWord D: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- needOrigin: true "
 --  get[0] -- actually an index error, accessing length " 
 -- exps.range: 1 exps[i]: "
 --  get[0] -- actually an index error, accessing length " needOrigin: true 
 -- isConst: "get[0] -- actually an index error, accessing length " 
 --  ObjectInvocation_KeyWord 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- updateOffset: "
 --  get[0] -- actually an index error, accessing length " E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- loadPathII:E: "
 --  get[0] -- actually an index error, accessing length " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "
 --  get[0] -- actually an index error, accessing length " 
 pushThis 
 -- items:goOrigin:encOG: "length "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg length$15 1
 -- NonVirt: "get[0] -- actually an index error, accessing length " "
 --  ObjectInvocation_KeyWord " ActArg: "0 "isValue: true formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  get[0] -- actually an index error, accessing length " isCompositeValueObj: false 
 -- OG:before:super.gen: "0 "
 -- handleInv: "0 " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "0 " 
 --  "0 " false 
 -- needOriginII: "0 " 
 -- E: ConstLiteral D: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- needOrigin: true "0 " 
 -- exps.range: 1 exps[i]: "0 " needOrigin: true 
 -- isConst: "0 " ConstLiteral 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- isConstLiteral: "0 " 
 pushc 0
 -- const:cst: "0 " 0 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: true formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "0 ":isBasicVal: true 
 -- case:B: 0 ObjectGenerator 1 1 1 false true 
 -- isIntForFloatArg: "0 " D: "inx: var integer " true false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "0 " false 
 --  B: false 
 --  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- end:loadArgs:NonVirt: "
 --  get[0] -- actually an index error, accessing length "
 -- loadPathII:before:newInvoke: "
 --  get[0] -- actually an index error, accessing length " true 
 -- checkForProxy:E: "
 --  get[0] -- actually an index error, accessing length " isBasicValue: false origin.isValueObj: false staticOff: 0 rec: 
 --  none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "
 --  get[0] -- actually an index error, accessing length " 
 -- ptn:newInvoke: "get[inx: var integer] " staticOff: 0 
 -- indexPTN:newInvoke: "get[inx: var integer] " isAdr: false 
 xpushg  inx 1 0 1
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "
 --  V := get[0] -- actually an index error, accessing length " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- right:isPTN:not:valueObj: "out ch: var char " 
 -- checkI2F2I: "
 --  V := get[0] -- actually an index error, accessing length " left.isFloat: false right.isFloat: false false left.isFloat:X: 
 --  false 
 -- ???:left.isFloat: false 
 -- Assign:end: "
 --  V := get[0] -- actually an index error, accessing length " isNotRemote: false qual: 
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  D: none 
 -- DI:newStore: "V " off: 2 valueOff: 0 dstE: "V " isNotRemote: 
 --  false originIsValueObj: false isUnitValueObj: false rightQual:primNo: 3 
 --  rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 storeg integer$5 2
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS this 31 1 BETA 2
 pushThis 
 rstoreg  this 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in this: ref Object " DI:isConst: false isBasicValue: 
 --  false primNo: 64 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS X_asString 32 1 Object 21
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "out S: var LIB.StringLib.String " DI:isConst: false 
 --  isBasicValue: false primNo: 5 
 -- DI:StringVar "out S: var LIB.StringLib.String "
 pushText ""
 pushThis 
 rstoreg  S 2
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(X_asString) "
 -- handleInv: "inner(X_asString) " staticOff: 0 doLoad: true 
 --  useRtnVal: false 
 -- isPtnWithOrigin: "inner(X_asString) " 
 --  "inner(X_asString) " true 
 -- needOriginII: "inner(X_asString) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- needOrigin: true "inner(X_asString) " 
 -- exps.range: 1 exps[i]: "inner(X_asString) " needOrigin: true 
 -- isConst: "inner(X_asString) " ObjectInvocation_KeyWord 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- updateOffset: "inner(X_asString) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- loadPathII:E: "inner(X_asString) " 1 1 exps.range: 1 
 --  staticOff: 0 
 -- loadOriginII: "inner(X_asString) " 
 -- loadPathII:before:newInvoke: "inner(X_asString) " true 
 -- checkForProxy:E: "inner(X_asString) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "inner(X_asString) " 
 -- ptn:newInvoke: "inner " staticOff: 0 
 -- oPTN:newInvoke: "inner " 101 
 pushThis 
 innerP  2
 rpopThisObj 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS LIB 33 1 BETAworld 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 pushThis 
 -- before objTmpStack:add:  34   "BasicIO "
 invoke BasicIO 34 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  38   "Collections "
 invoke Collections 38 4 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  41   "StringLib "
 invoke StringLib 41 5 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- DI:gen: "x_dummy_LIB: var integer " DI:isConst: false 
 --  isBasicValue: true primNo: 1 
 -- DI:gen:primitiveType: x_dummy_LIB 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0

 CLASS BasicIO 34 1 LIB 33
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: 
 --  keyboard: obj 
 --     %Public
 --     readLine: 
 --        out M: var LIB.StringLib.StringDI:isConst: true isBasicValue: false primNo: 0 
 -- DI:isConst: keyboard 
 -- DI:off: 2 this: 
 --  keyboard: obj 
 --     %Public
 --     readLine: 
 --        out M: var LIB.StringLib.String
 --  
 pushThis 
 -- before objTmpStack:add:  35   "keyboard "
 invoke keyboard 35 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- DI:gen: 
 --  screen: obj 
 --     L: obj Lock
 --     %Public
 --     init: DI:isConst: true isBasicValue: false primNo: 0 
 -- DI:isConst: screen 
 -- DI:off: 3 this: 
 --  screen: obj 
 --     L: obj Lock
 --     %Public
 --     init: 
 --  
 pushThis 
 -- before objTmpStack:add:  36   "screen "
 invoke screen 36 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS keyboard 35 1 BasicIO 34
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS screen 36 1 BasicIO 34
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "L: obj Lock " DI:isConst: true isBasicValue: false 
 --  primNo: 0 
 -- DI:isConst: L 
 -- DI:off: 2 this: "L: obj Lock " 
 --  
 -- OG:before:super.gen: "Lock "
 -- handleInv: "Lock " staticOff: 2 doLoad: true useRtnVal: false 
 -- isPtnWithOrigin: "Lock " 
 --  "Lock " true 
 -- needOriginII: "Lock " 
 -- E: ObjectInvocation_Unary D: 
 --  Lock: 
 --     dummy: var integer
 --     %Public
 --     M: var integer
 -- needOrigin: true "Lock " 
 -- exps.range: 1 exps[i]: "Lock " needOrigin: true 
 -- isConst: "Lock " ObjectInvocation_Unary 
 --  Lock: 
 --     dummy: var integer
 --     %Public
 --     M: var integer
 -- updateOffset: "Lock " E.ATd: 
 --  Lock: 
 --     dummy: var integer
 --     %Public
 --     M: var integer
 -- loadPathII:E: "Lock " 1 1 exps.range: 1 staticOff: 2 
 -- loadOriginII: "Lock " 
 pushThis 
 -- items:goOrigin:encOG: "screen "on: 1 isValueObj: false 
 --  origin: BasicIO origin:isValueObj: false 
 rpushg screen$36 1
 -- loadPathII:before:newInvoke: "Lock " true 
 -- checkForProxy:E: "Lock " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 2 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "Lock " 
 -- ptn:newInvoke: "Lock " staticOff: 2 
 -- gPTN:newInvoke: "Lock " ptnKind: 0 staticOff: 2 valueOff: 0 
 --  rec: none 
 -- invoke:nonVirtual: "Lock " isAdr: false 
 invoke Lock 37 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS Lock 37 1 BasicIO 34
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "dummy: var integer " DI:isConst: false isBasicValue: 
 --  true primNo: 1 
 -- DI:gen:primitiveType: dummy 
 -- DI:gen: "M: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: M 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS Collections 38 1 LIB 33
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- before objTmpStack:add:  39   "OrderedList "
 invoke OrderedList 39 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  40   "SetLib "
 invoke SetLib 40 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS OrderedList 39 0 Collections 38
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:0 isIndexed:0

 CLASS SetLib 40 1 Collections 38
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS StringLib 41 1 LIB 33
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 saveStringOrigin
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $18 18 1 loop 14
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "leave(loop) "
 -- handleInv: "leave(loop) " staticOff: 0 doLoad: true useRtnVal: 
 --  false 
 -- isPtnWithOrigin: "leave(loop) " 
 --  "leave(loop) " true 
 -- needOriginII: "leave(loop) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- needOrigin: true "leave(loop) " 
 -- exps.range: 1 exps[i]: "leave(loop) " needOrigin: true 
 -- isConst: "leave(loop) " ObjectInvocation_KeyWord 
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- updateOffset: "leave(loop) " E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- loadPathII:E: "leave(loop) " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "leave(loop) " 
 -- loadPathII:before:newInvoke: "leave(loop) " true 
 -- checkForProxy:E: "leave(loop) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "leave(loop) " 
 -- ptn:newInvoke: "leave(V: var integer) " staticOff: 0 
 -- bPTN:newInvoke: "leave(V: var integer) " 
 break  1 2 14 0
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS if:then 20 0 BETA 2
 pushThis 
 storeg Boolean$42 1
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:1 objSize:1 isIndexed:0

 CLASS thenPart#22 22 0 if:then$20 20 isVstub
 invoke Object 21 0 1
 pushThis 
 rstoreg   2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:1 objSize:3 isIndexed:0

 CLASS Boolean 42 0 BETA 2 isValueObj
 mvStack 
 -- DI:gen: "_thisBasicValue: var Universal " DI:isConst: false 
 --  isBasicValue: true primNo: 1 
 -- DI:gen:primitiveType: _thisBasicValue 
 rtnAlloc 1
DO:
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS True 23 0 BETA 2
 allocEventQ
 mvStack 
 -- DI:gen: "out B: var boolean " DI:isConst: false isBasicValue: 
 --  true primNo: 4 
 -- DI:gen:primitiveType: B 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- handleAssign: "B := 1 " 
 -- handleInv: "B " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "B " 
 --  "B " false 
 -- needOriginII: "B " 
 -- E: ObjectInvocation_Unary D: "out B: var boolean " 
 -- needOrigin: true "B " 
 -- exps.range: 1 exps[i]: "B " needOrigin: true 
 -- isConst: "B " ObjectInvocation_Unary "out B: var boolean " 
 -- isConst:DI: "out B: var boolean " 
 -- updateOffset: "B " E.ATd: "out B: var boolean " 
 -- loadPathII:E: "B " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "B " 
 pushThis 
 -- loadPathII:before:newInvoke: "B " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "B := 1 " leftE: "B " 
 -- OG:before:super.gen: "1 "
 -- handleInv: "1 " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "1 " 
 --  "1 " false 
 -- needOriginII: "1 " 
 -- E: ConstLiteral D: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- needOrigin: true "1 " 
 -- exps.range: 1 exps[i]: "1 " needOrigin: true 
 -- isConst: "1 " ConstLiteral 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- isConstLiteral: "1 " 
 pushc 1
 -- const:cst: "1 " 1 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "B := 1 " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- checkI2F2I: "B := 1 " left.isFloat: false right.isFloat: false 
 --  false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- Assign:end: "B := 1 " isNotRemote: false qual: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  D: none 
 -- DI:newStore: "B " off: 1 valueOff: 0 dstE: "B " isNotRemote: 
 --  false originIsValueObj: false isUnitValueObj: false rightQual:primNo: 1 
 --  rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 storeg Boolean$42 1
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS for:to:repeat 28 0 BETA 2
 pushThis 
 storeg integer$5 2
 pushThis 
 storeg integer$5 1
 allocEventQ
 mvStack 
 -- DI:gen: "inx: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: inx 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- handleAssign: "inx := first " 
 -- handleInv: "inx " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "inx " 
 --  "inx " false 
 -- needOriginII: "inx " 
 -- E: ObjectInvocation_Unary D: "inx: var integer " 
 -- needOrigin: true "inx " 
 -- exps.range: 1 exps[i]: "inx " needOrigin: true 
 -- isConst: "inx " ObjectInvocation_Unary "inx: var integer " 
 -- isConst:DI: "inx: var integer " 
 -- updateOffset: "inx " E.ATd: "inx: var integer " 
 -- loadPathII:E: "inx " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "inx " 
 pushThis 
 -- loadPathII:before:newInvoke: "inx " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "inx := first " leftE: "inx " 
 -- OG:before:super.gen: "first "
 -- handleInv: "first " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "first " 
 --  "first " false 
 -- needOriginII: "first " 
 -- E: ObjectInvocation_Unary D: "first: var integer " 
 -- needOrigin: true "first " 
 -- exps.range: 1 exps[i]: "first " needOrigin: true 
 -- isConst: "first " ObjectInvocation_Unary "first: var integer " 
 -- isConst:DI: "first: var integer " 
 -- updateOffset: "first " E.ATd: "first: var integer " 
 -- loadPathII:E: "first " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "first " 
 pushThis 
 -- loadPathII:before:newInvoke: "first " true 
 -- checkForProxy:E: "first " isBasicValue: true origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "first " 
 -- DI:newInvoke: "first: var integer " off: 1 valueOff: 0 E: "
 --  first " next: none isAdr: false 
 -- DI:newInvoke:loadPrimitive: "first " isAdr: false valueOff: 0 
 pushg 1 newInvoke
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "inx := first " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- checkI2F2I: "inx := first " left.isFloat: false right.isFloat: 
 --  false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- Assign:end: "inx := first " isNotRemote: false qual: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  D: none 
 -- DI:newStore: "inx " off: 3 valueOff: 0 dstE: "inx " 
 --  isNotRemote: false originIsValueObj: false isUnitValueObj: false 
 --  rightQual:primNo: 1 rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 storeg integer$5 3
 pushThis 
 -- before objTmpStack:add:  43   "_doIt "
 invoke _doIt 43 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:1 objSize:3 isIndexed:0

 CLASS repeat#29 29 0 for:to:repeat$28 28 isVstub
 invoke Object 21 0 1
 pushThis 
 rstoreg   2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:1 objSize:3 isIndexed:0

 CLASS _doIt 43 1 for:to:repeat 28
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  :else 
 --     inx := inx "
 -- handleInv: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)staticOff: 0 doLoad: true useRtnVal: false 
 -- isPtnWithOrigin: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)false 
 -- needOriginII: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 -- E: IfThenElse D: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- needOrigin: false 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 -- exps.range: 1 exps[i]: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)needOrigin: false 
 -- isConst: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)IfThenElse 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- noOrigin: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 -- loadPathII:E: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)1 1 exps.range: 1 staticOff: 0 
 -- loadPathII:before:newInvoke: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)true 
 -- checkForProxy:E: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)isBasicValue: false origin.isValueObj: false staticOff: 0 rec: 
 --  none 
 -- loadPathII:next: 1 1 
 -- IfThenElse:newInvoke: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 -- OG:before:super.gen: "(inx <= last) "
 -- handleInv: "(inx <= last) " staticOff: 0 doLoad: true 
 --  useRtnVal: true 
 -- isPtnWithOrigin: "(inx <= last) " 
 --  "inx " false "<= last " true 
 -- needOriginII: "(inx <= last) " 
 -- E: ObjectInvocation_Unary D: "inx: var integer " 
 -- E: ObjectInvocation_Binary D: 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- needOrigin: true "<= last " 
 -- exps.range: 2 exps[i]: "inx " exps[i]: "<= last " needOrigin: 
 --  true 
 -- isConst: "inx " ObjectInvocation_Unary "inx: var integer " 
 -- isConst:DI: "inx: var integer " 
 -- updateOffset: "inx " E.ATd: "inx: var integer " 
 -- isConst: "<= last " ObjectInvocation_Binary 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- updateOffset: "<= last " E.ATd: 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- loadPathII:E: "inx " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "inx " 
 pushThis 
 -- items:goOrigin:encOG: "_doIt "on: 1 isValueObj: false 
 --  origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$43 1
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "inx " 
 -- DI:loadAccessor: "inx " 
 -- DI:loadAccesor:loadPrimitive: "inx " 
 pushg 3 newInvoke
 -- loadPathII:E: "<= last " 1 2 exps.range: 2 staticOff: 0 
 -- E: "<= last " E:isPrimitiveIntWithFloatArg: false rec: "inx " 
 --  isFloat: false 
 -- NonVirt: "<= last " "ObjectInvocation_Binary " ActArg: "last "
 --  isValue: false formalArg: "in Veq: var this(Value) " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "<= last " isCompositeValueObj: 
 --  true 
 -- OG:before:super.gen: "last "
 -- handleInv: "last " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "last " 
 --  "last " false 
 -- needOriginII: "last " 
 -- E: ObjectInvocation_Unary D: "last: var integer " 
 -- needOrigin: true "last " 
 -- exps.range: 1 exps[i]: "last " needOrigin: true 
 -- isConst: "last " ObjectInvocation_Unary "last: var integer " 
 -- isConst:DI: "last: var integer " 
 -- updateOffset: "last " E.ATd: "last: var integer " 
 -- loadPathII:E: "last " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "last " 
 pushThis 
 -- items:goOrigin:encOG: "_doIt "on: 1 isValueObj: false 
 --  origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$43 1
 -- loadPathII:before:newInvoke: "last " true 
 -- checkForProxy:E: "last " isBasicValue: true origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "last " 
 -- DI:newInvoke: "last: var integer " off: 2 valueOff: 0 E: "
 --  last " next: none isAdr: false 
 -- DI:newInvoke:loadPrimitive: "last " isAdr: false valueOff: 0 
 pushg 2 newInvoke
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- vEq: 
 -- end:loadArgs:NonVirt: "<= last "
 -- loadPathII:before:newInvoke: "<= last " true 
 -- checkForProxy:E: "<= last " isBasicValue: false 
 --  origin.isValueObj: true staticOff: 0 rec: "inx " 
 -- checkForProxy:rec=None:localInvocation? "(inx <= last) " E: "
 --  <= last " rec: "inx " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "<= last " 
 -- ptn:newInvoke: "<=   " staticOff: 0 
 -- gPTN:newInvoke: "<=   " ptnKind: 1 staticOff: 0 valueOff: 0 
 --  rec: "inx " 
 -- rec: "inx " E: "<= last " OGx.label: "ObjectGenerator "OGx: "
 --  integer " 
 --  rec.ATd: "inx: var integer " 
 -- bobs: 1 OGx: "integer " 
 le
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  45   "$45 "
 invoke $45 45 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L5
 L4:
 pushThis 
 -- before objTmpStack:add:  48   "$48 "
 invoke $48 48 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L5:
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $45 45 1 _doIt 43
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "repeat "
 -- handleInv: "repeat " staticOff: 0 doLoad: true useRtnVal: false 
 -- isPtnWithOrigin: "repeat " 
 --  "repeat " true 
 -- needOriginII: "repeat " 
 -- E: ObjectInvocation_Unary D: "repeat:< object " 
 -- needOrigin: true "repeat " 
 -- exps.range: 1 exps[i]: "repeat " needOrigin: true 
 -- isConst: "repeat " ObjectInvocation_Unary "repeat:< object " 
 -- updateOffset: "repeat " E.ATd: "repeat:< object " 
 -- loadPathII:E: "repeat " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "repeat " 
 pushThis 
 -- items:goOrigin:encOG: "$45 "on: 2 isValueObj: false 
 --  origin: _doIt origin:isValueObj: false 
 rpushg $45$45 1
 -- items:goOrigin:encOG: "_doIt "on: 1 isValueObj: false 
 --  origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$43 1
 -- loadPathII:before:newInvoke: "repeat " true 
 -- checkForProxy:E: "repeat " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "repeat " 
 -- ptn:newInvoke: "repeat " staticOff: 0 
 -- gPTN:newInvoke: "repeat " ptnKind: 1 staticOff: 0 valueOff: 0 
 --  rec: none 
 -- invoke:Virtual: "repeat " E: "repeat " E.ATd.isValueObj: false 
 --  this:isVal: false rec: none isStatic: false 
 invokev 2 0 repeat$29$29 0
 -- GeneralPTN:invoke:after:pushOut: 
 rpop 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign: "inx := inx + 1 " 
 -- handleInv: "inx " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "inx " 
 --  "inx " false 
 -- needOriginII: "inx " 
 -- E: ObjectInvocation_Unary D: "inx: var integer " 
 -- needOrigin: true "inx " 
 -- exps.range: 1 exps[i]: "inx " needOrigin: true 
 -- isConst: "inx " ObjectInvocation_Unary "inx: var integer " 
 -- isConst:DI: "inx: var integer " 
 -- updateOffset: "inx " E.ATd: "inx: var integer " 
 -- loadPathII:E: "inx " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "inx " 
 pushThis 
 -- items:goOrigin:encOG: "$45 "on: 2 isValueObj: false 
 --  origin: _doIt origin:isValueObj: false 
 rpushg $45$45 1
 -- items:goOrigin:encOG: "_doIt "on: 1 isValueObj: false 
 --  origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$43 1
 -- loadPathII:before:newInvoke: "inx " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "inx := inx + 1 " leftE: "inx " 
 -- OG:before:super.gen: "inx + 1 "
 -- handleInv: "inx + 1 " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "inx + 1 " 
 --  "inx " false "+ 1 " true 
 -- needOriginII: "inx + 1 " 
 -- E: ObjectInvocation_Unary D: "inx: var integer " 
 -- E: ObjectInvocation_Binary D: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- needOrigin: true "+ 1 " 
 -- exps.range: 2 exps[i]: "inx " exps[i]: "+ 1 " needOrigin: true 
 -- isConst: "inx " ObjectInvocation_Unary "inx: var integer " 
 -- isConst:DI: "inx: var integer " 
 -- updateOffset: "inx " E.ATd: "inx: var integer " 
 -- isConst: "+ 1 " ObjectInvocation_Binary 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- updateOffset: "+ 1 " E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- loadPathII:E: "inx " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "inx " 
 pushThis 
 -- items:goOrigin:encOG: "$45 "on: 2 isValueObj: false 
 --  origin: _doIt origin:isValueObj: false 
 rpushg $45$45 1
 -- items:goOrigin:encOG: "_doIt "on: 1 isValueObj: false 
 --  origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$43 1
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "inx " 
 -- DI:loadAccessor: "inx " 
 -- DI:loadAccesor:loadPrimitive: "inx " 
 pushg 3 newInvoke
 -- loadPathII:E: "+ 1 " 1 2 exps.range: 2 staticOff: 0 
 -- E: "+ 1 " E:isPrimitiveIntWithFloatArg: false rec: "inx " 
 --  isFloat: false 
 -- NonVirt: "+ 1 " "ObjectInvocation_Binary " ActArg: "1 "isValue: 
 --  true formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ 1 " isCompositeValueObj: false 
 -- OG:before:super.gen: "1 "
 -- handleInv: "1 " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "1 " 
 --  "1 " false 
 -- needOriginII: "1 " 
 -- E: ConstLiteral D: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- needOrigin: true "1 " 
 -- exps.range: 1 exps[i]: "1 " needOrigin: true 
 -- isConst: "1 " ConstLiteral 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- isConstLiteral: "1 " 
 pushc 1
 -- const:cst: "1 " 1 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- isIntForFloatArg: "1 " D: "in V: var integer " true false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "1 " false 
 --  B: false 
 --  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- end:loadArgs:NonVirt: "+ 1 "
 -- loadPathII:before:newInvoke: "+ 1 " true 
 -- checkForProxy:E: "+ 1 " isBasicValue: true origin.isValueObj: 
 --  true staticOff: 0 rec: "inx " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "+ 1 " 
 -- ptn:newInvoke: "+   " staticOff: 0 
 -- gPTN:newInvoke: "+   " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: "inx " 
 -- checkInt2IntWithUnitArg:E: "+ 1 " false false 
 plus
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "inx := inx + 1 " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- right:isPTN:not:valueObj: "out R: var integer " 
 -- "+ 1 " 
 -- "+ 1 " 
 -- checkI2F2I: "inx := inx + 1 " left.isFloat: false right.isFloat: 
 --  false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- "+ 1 " 
 -- "+ 1 " 
 -- Assign:end: "inx := inx + 1 " isNotRemote: false qual: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  D: none 
 -- DI:newStore: "inx " off: 3 valueOff: 0 dstE: "inx " 
 --  isNotRemote: false originIsValueObj: false isUnitValueObj: false 
 --  rightQual:primNo: 1 rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 storeg integer$5 3
 -- OG:before:super.gen: "restart(_doIt) "
 -- handleInv: "restart(_doIt) " staticOff: 0 doLoad: true 
 --  useRtnVal: false 
 -- isPtnWithOrigin: "restart(_doIt) " 
 --  "restart(_doIt) " true 
 -- needOriginII: "restart(_doIt) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  
 -- needOrigin: true "restart(_doIt) " 
 -- exps.range: 1 exps[i]: "restart(_doIt) " needOrigin: true 
 -- isConst: "restart(_doIt) " ObjectInvocation_KeyWord 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  
 -- updateOffset: "restart(_doIt) " E.ATd: 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  
 -- loadPathII:E: "restart(_doIt) " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "restart(_doIt) " 
 -- loadPathII:before:newInvoke: "restart(_doIt) " true 
 -- checkForProxy:E: "restart(_doIt) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "restart(_doIt) " 
 -- ptn:newInvoke: "restart(V: var integer) " staticOff: 0 
 -- bPTN:newInvoke: "restart(V: var integer) " 
 break  1 1 43 0
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $48 48 1 _doIt 43
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- handleAssign: "inx := inx " 
 -- handleInv: "inx " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "inx " 
 --  "inx " false 
 -- needOriginII: "inx " 
 -- E: ObjectInvocation_Unary D: "inx: var integer " 
 -- needOrigin: true "inx " 
 -- exps.range: 1 exps[i]: "inx " needOrigin: true 
 -- isConst: "inx " ObjectInvocation_Unary "inx: var integer " 
 -- isConst:DI: "inx: var integer " 
 -- updateOffset: "inx " E.ATd: "inx: var integer " 
 -- loadPathII:E: "inx " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "inx " 
 pushThis 
 -- items:goOrigin:encOG: "$48 "on: 2 isValueObj: false 
 --  origin: _doIt origin:isValueObj: false 
 rpushg $48$48 1
 -- items:goOrigin:encOG: "_doIt "on: 1 isValueObj: false 
 --  origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$43 1
 -- loadPathII:before:newInvoke: "inx " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "inx := inx " leftE: "inx " 
 -- OG:before:super.gen: "inx "
 -- handleInv: "inx " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "inx " 
 --  "inx " false 
 -- needOriginII: "inx " 
 -- E: ObjectInvocation_Unary D: "inx: var integer " 
 -- needOrigin: true "inx " 
 -- exps.range: 1 exps[i]: "inx " needOrigin: true 
 -- isConst: "inx " ObjectInvocation_Unary "inx: var integer " 
 -- isConst:DI: "inx: var integer " 
 -- updateOffset: "inx " E.ATd: "inx: var integer " 
 -- loadPathII:E: "inx " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "inx " 
 pushThis 
 -- items:goOrigin:encOG: "$48 "on: 2 isValueObj: false 
 --  origin: _doIt origin:isValueObj: false 
 rpushg $48$48 1
 -- items:goOrigin:encOG: "_doIt "on: 1 isValueObj: false 
 --  origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$43 1
 -- loadPathII:before:newInvoke: "inx " true 
 -- checkForProxy:E: "inx " isBasicValue: true origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "inx " 
 -- DI:newInvoke: "inx: var integer " off: 1 valueOff: 0 E: "inx " 
 --  next: none isAdr: false 
 -- DI:newInvoke:loadPrimitive: "inx " isAdr: false valueOff: 0 
 pushg 3 newInvoke
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "inx := inx " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- checkI2F2I: "inx := inx " left.isFloat: false right.isFloat: 
 --  false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- Assign:end: "inx := inx " isNotRemote: false qual: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  D: none 
 -- DI:newStore: "inx " off: 3 valueOff: 0 dstE: "inx " 
 --  isNotRemote: false originIsValueObj: false isUnitValueObj: false 
 --  rightQual:primNo: 1 rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 storeg integer$5 3
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS repeat$24 24 1 for:to:repeat$30 30
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- handleAssign: "c1 := get[inx] " 
 -- handleInv: "c1 " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "c1 " 
 --  "c1 " false 
 -- needOriginII: "c1 " 
 -- E: ObjectInvocation_Unary D: "c1: var char " 
 -- needOrigin: true "c1 " 
 -- exps.range: 1 exps[i]: "c1 " needOrigin: true 
 -- isConst: "c1 " ObjectInvocation_Unary "c1: var char " 
 -- isConst:DI: "c1: var char " 
 -- updateOffset: "c1 " E.ATd: "c1: var char " 
 -- loadPathII:E: "c1 " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "c1 " 
 pushThis 
 -- items:goOrigin:encOG: "repeat$24 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30 "on: 1 isValueObj: 
 --  false 
 --  origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- loadPathII:before:newInvoke: "c1 " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "c1 := get[inx] " leftE: "c1 " 
 -- OG:before:super.gen: "get[inx] "
 -- handleInv: "get[inx] " staticOff: 0 doLoad: true useRtnVal: 
 --  true 
 -- isPtnWithOrigin: "get[inx] " 
 --  "get[inx] " true 
 -- needOriginII: "get[inx] " 
 -- E: ObjectInvocation_KeyWord D: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- needOrigin: true "get[inx] " 
 -- exps.range: 1 exps[i]: "get[inx] " needOrigin: true 
 -- isConst: "get[inx] " ObjectInvocation_KeyWord 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- updateOffset: "get[inx] " E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- loadPathII:E: "get[inx] " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "get[inx] " 
 pushThis 
 -- items:goOrigin:encOG: "repeat$24 "on: 4 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30 "on: 3 isValueObj: 
 --  false 
 --  origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- items:goOrigin:encOG: "loop "on: 2 isValueObj: false 
 --  origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- items:goOrigin:encOG: "= "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg =$13 1
 -- NonVirt: "get[inx] " "ObjectInvocation_KeyWord " ActArg: "inx "
 --  isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx] " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "inx "
 -- handleInv: "inx " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "inx " 
 --  "inx " false 
 -- needOriginII: "inx " 
 -- E: ObjectInvocation_Unary D: "inx: var integer " 
 -- needOrigin: true "inx " 
 -- exps.range: 1 exps[i]: "inx " needOrigin: true 
 -- isConst: "inx " ObjectInvocation_Unary "inx: var integer " 
 -- isConst:DI: "inx: var integer " 
 -- updateOffset: "inx " E.ATd: "inx: var integer " 
 -- loadPathII:E: "inx " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "inx " 
 pushThis 
 -- items:goOrigin:encOG: "repeat$24 "on: 1 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- loadPathII:before:newInvoke: "inx " true 
 -- checkForProxy:E: "inx " isBasicValue: true origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "inx " 
 -- DI:newInvoke: "inx: var integer " off: 1 valueOff: 0 E: "inx " 
 --  next: none isAdr: false 
 -- DI:newInvoke:loadPrimitive: "inx " isAdr: false valueOff: 0 
 pushg 3 newInvoke
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- isIntForFloatArg: "inx " D: "inx: var integer " true false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "inx " 
 --  B: false 
 --  "inx: var integer " 
 -- end:loadArgs:NonVirt: "get[inx] "
 -- loadPathII:before:newInvoke: "get[inx] " true 
 -- checkForProxy:E: "get[inx] " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "get[inx] " 
 -- ptn:newInvoke: "get[inx: var integer] " staticOff: 0 
 -- indexPTN:newInvoke: "get[inx: var integer] " isAdr: false 
 xpushg  inx 1 0 1
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "c1 := get[inx] " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- right:isPTN:not:valueObj: "out ch: var char " 
 -- checkI2F2I: "c1 := get[inx] " left.isFloat: false right.isFloat: 
 --  false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- Assign:end: "c1 := get[inx] " isNotRemote: false qual: 
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  D: none 
 -- DI:newStore: "c1 " off: 2 valueOff: 0 dstE: "c1 " isNotRemote: 
 --  false originIsValueObj: false isUnitValueObj: false rightQual:primNo: 3 
 --  rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 storeg char$7 2
 -- handleAssign: "c2 := Veq.get[inx] " 
 -- handleInv: "c2 " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "c2 " 
 --  "c2 " false 
 -- needOriginII: "c2 " 
 -- E: ObjectInvocation_Unary D: "c2: var char " 
 -- needOrigin: true "c2 " 
 -- exps.range: 1 exps[i]: "c2 " needOrigin: true 
 -- isConst: "c2 " ObjectInvocation_Unary "c2: var char " 
 -- isConst:DI: "c2: var char " 
 -- updateOffset: "c2 " E.ATd: "c2: var char " 
 -- loadPathII:E: "c2 " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "c2 " 
 pushThis 
 -- items:goOrigin:encOG: "repeat$24 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30 "on: 1 isValueObj: 
 --  false 
 --  origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- loadPathII:before:newInvoke: "c2 " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "c2 := Veq.get[inx] " leftE: "c2 " 
 -- OG:before:super.gen: "Veq.get[inx] "
 -- handleInv: "Veq.get[inx] " staticOff: 0 doLoad: true useRtnVal: 
 --  true 
 -- isPtnWithOrigin: "Veq.get[inx] " 
 --  "Veq " false "get[inx] " true 
 -- needOriginII: "Veq.get[inx] " 
 -- E: ObjectInvocation_Unary D: "in Veq: var this(Value) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- needOrigin: true "get[inx] " 
 -- exps.range: 2 exps[i]: "Veq " exps[i]: "get[inx] " needOrigin: 
 --  true 
 -- isConst: "Veq " ObjectInvocation_Unary "
 --  in Veq: var this(Value) " 
 -- isConst:DI: "in Veq: var this(Value) " 
 -- valueOff: 0 E.newOff: 2 "Veq " 
 -- isValueObj:E: "Veq " valueOff: 2 
 -- isConst: "get[inx] " ObjectInvocation_KeyWord 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- updateOffset: "get[inx] " E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- loadPathII:E: "Veq " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "Veq " 
 pushThis 
 -- items:goOrigin:encOG: "repeat$24 "on: 3 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30 "on: 2 isValueObj: 
 --  false 
 --  origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "Veq " 
 -- DI:loadAccessor: "Veq " 
 -- DI:loadAccessor:accessValObj: "Veq " 
 rpushg newInvoke 2
 -- loadPathII:E: "get[inx] " 1 2 exps.range: 2 staticOff: 0 
 -- E: "get[inx] " E:isPrimitiveIntWithFloatArg: false rec: "Veq " 
 --  isFloat: false 
 -- NonVirt: "get[inx] " "ObjectInvocation_KeyWord " ActArg: "inx "
 --  isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx] " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "inx "
 -- handleInv: "inx " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "inx " 
 --  "inx " false 
 -- needOriginII: "inx " 
 -- E: ObjectInvocation_Unary D: "inx: var integer " 
 -- needOrigin: true "inx " 
 -- exps.range: 1 exps[i]: "inx " needOrigin: true 
 -- isConst: "inx " ObjectInvocation_Unary "inx: var integer " 
 -- isConst:DI: "inx: var integer " 
 -- updateOffset: "inx " E.ATd: "inx: var integer " 
 -- loadPathII:E: "inx " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "inx " 
 pushThis 
 -- items:goOrigin:encOG: "repeat$24 "on: 1 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- loadPathII:before:newInvoke: "inx " true 
 -- checkForProxy:E: "inx " isBasicValue: true origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "inx " 
 -- DI:newInvoke: "inx: var integer " off: 1 valueOff: 0 E: "inx " 
 --  next: none isAdr: false 
 -- DI:newInvoke:loadPrimitive: "inx " isAdr: false valueOff: 0 
 pushg 3 newInvoke
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- isIntForFloatArg: "inx " D: "inx: var integer " true false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "inx " 
 --  B: false 
 --  "inx: var integer " 
 -- end:loadArgs:NonVirt: "get[inx] "
 -- loadPathII:before:newInvoke: "get[inx] " true 
 -- checkForProxy:E: "get[inx] " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: "Veq " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "get[inx] " 
 -- ptn:newInvoke: "get[inx: var integer] " staticOff: 0 
 -- indexPTN:newInvoke: "get[inx: var integer] " isAdr: false 
 xpushg  inx 1 0 1
 -- handleINV:end: isNotRemote: true valueOff: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "c2 := Veq.get[inx] " OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- right:isPTN:not:valueObj: "out ch: var char " 
 -- "get[inx] " 
 -- "get[inx] " 
 -- checkI2F2I: "c2 := Veq.get[inx] " left.isFloat: false 
 --  right.isFloat: false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- "get[inx] " 
 -- "get[inx] " 
 -- Assign:end: "c2 := Veq.get[inx] " isNotRemote: false qual: 
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  D: none 
 -- DI:newStore: "c2 " off: 3 valueOff: 0 dstE: "c2 " isNotRemote: 
 --  false originIsValueObj: false isUnitValueObj: false rightQual:primNo: 3 
 --  rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 storeg char$7 3
 -- OG:before:super.gen: "
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop) "
 -- handleInv: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  staticOff: 0 doLoad: true useRtnVal: false 
 -- isPtnWithOrigin: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  
 --  
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  false 
 -- needOriginII: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  
 -- E: IfThen D: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- needOrigin: false 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  
 -- exps.range: 1 exps[i]: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  needOrigin: false 
 -- isConst: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  IfThen 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- noOrigin: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  
 -- loadPathII:E: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  1 1 exps.range: 1 staticOff: 0 
 -- loadPathII:before:newInvoke: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  true 
 -- checkForProxy:E: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  isBasicValue: false origin.isValueObj: false staticOff: 0 rec: 
 --  none 
 -- loadPathII:next: 1 1 
 -- IfThen:newInvoke: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  
 -- OG:before:super.gen: "(c1 <> c2) "
 -- handleInv: "(c1 <> c2) " staticOff: 0 doLoad: true useRtnVal: 
 --  true 
 -- isPtnWithOrigin: "(c1 <> c2) " 
 --  "c1 " false "<> c2 " true 
 -- needOriginII: "(c1 <> c2) " 
 -- E: ObjectInvocation_Unary D: "c1: var char " 
 -- E: ObjectInvocation_Binary D: 
 --  <>  : 
 --     %basic 55
 --     in V: var char
 --     out B: var boolean
 --  
 -- needOrigin: true "<> c2 " 
 -- exps.range: 2 exps[i]: "c1 " exps[i]: "<> c2 " needOrigin: true 
 -- isConst: "c1 " ObjectInvocation_Unary "c1: var char " 
 -- isConst:DI: "c1: var char " 
 -- updateOffset: "c1 " E.ATd: "c1: var char " 
 -- isConst: "<> c2 " ObjectInvocation_Binary 
 --  <>  : 
 --     %basic 55
 --     in V: var char
 --     out B: var boolean
 --  
 -- updateOffset: "<> c2 " E.ATd: 
 --  <>  : 
 --     %basic 55
 --     in V: var char
 --     out B: var boolean
 --  
 -- loadPathII:E: "c1 " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "c1 " 
 pushThis 
 -- items:goOrigin:encOG: "repeat$24 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30 "on: 1 isValueObj: 
 --  false 
 --  origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "c1 " 
 -- DI:loadAccessor: "c1 " 
 -- DI:loadAccesor:loadPrimitive: "c1 " 
 pushg 2 newInvoke
 -- loadPathII:E: "<> c2 " 1 2 exps.range: 2 staticOff: 0 
 -- E: "<> c2 " E:isPrimitiveIntWithFloatArg: false rec: "c1 " 
 --  isFloat: false 
 -- NonVirt: "<> c2 " "ObjectInvocation_Binary " ActArg: "c2 "
 --  isValue: false formalArg: "in V: var char " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "<> c2 " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "c2 "
 -- handleInv: "c2 " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "c2 " 
 --  "c2 " false 
 -- needOriginII: "c2 " 
 -- E: ObjectInvocation_Unary D: "c2: var char " 
 -- needOrigin: true "c2 " 
 -- exps.range: 1 exps[i]: "c2 " needOrigin: true 
 -- isConst: "c2 " ObjectInvocation_Unary "c2: var char " 
 -- isConst:DI: "c2: var char " 
 -- updateOffset: "c2 " E.ATd: "c2: var char " 
 -- loadPathII:E: "c2 " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "c2 " 
 pushThis 
 -- items:goOrigin:encOG: "repeat$24 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30 "on: 1 isValueObj: 
 --  false 
 --  origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- loadPathII:before:newInvoke: "c2 " true 
 -- checkForProxy:E: "c2 " isBasicValue: true origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "c2 " 
 -- DI:newInvoke: "c2: var char " off: 2 valueOff: 0 E: "c2 " 
 --  next: none isAdr: false 
 -- DI:newInvoke:loadPrimitive: "c2 " isAdr: false valueOff: 0 
 pushg 3 newInvoke
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var char "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "c2 ":isBasicVal: true 
 -- case:B: c2 ObjectGenerator 3 0 3 false false 
 -- isIntForFloatArg: "c2 " D: "in V: var char " false false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "c2 " 
 --  B: false 
 --  "c2: var char " 
 -- end:loadArgs:NonVirt: "<> c2 "
 -- loadPathII:before:newInvoke: "<> c2 " true 
 -- checkForProxy:E: "<> c2 " isBasicValue: false origin.isValueObj: 
 --  true staticOff: 0 rec: "c1 " 
 -- checkForProxy:rec=None:localInvocation? "(c1 <> c2) " E: "
 --  <> c2 " rec: "c1 " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "<> c2 " 
 -- ptn:newInvoke: "<>   " staticOff: 0 
 -- gPTN:newInvoke: "<>   " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: "c1 " 
 -- checkInt2IntWithUnitArg:E: "<> c2 " false false 
 ne
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  26   "$26 "
 invoke $26 26 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $26 26 1 repeat$24 24
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- handleAssign: "Beq := false " 
 -- handleInv: "Beq " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "Beq " 
 --  "Beq " false 
 -- needOriginII: "Beq " 
 -- E: ObjectInvocation_Unary D: "out Beq: var boolean " 
 -- needOrigin: true "Beq " 
 -- exps.range: 1 exps[i]: "Beq " needOrigin: true 
 -- isConst: "Beq " ObjectInvocation_Unary "out Beq: var boolean " 
 -- isConst:DI: "out Beq: var boolean " 
 -- updateOffset: "Beq " E.ATd: "out Beq: var boolean " 
 -- loadPathII:E: "Beq " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "Beq " 
 pushThis 
 -- items:goOrigin:encOG: "$26 "on: 4 isValueObj: false 
 --  origin: repeat$24 origin:isValueObj: false 
 rpushg $26$26 1
 -- items:goOrigin:encOG: "repeat$24 "on: 3 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30 "on: 2 isValueObj: 
 --  false 
 --  origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- loadPathII:before:newInvoke: "Beq " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "Beq := false " leftE: "Beq " 
 -- OG:before:super.gen: "false "
 -- handleInv: "false " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "false " 
 --  "false " false 
 -- needOriginII: "false " 
 -- E: ObjectInvocation_Unary D: 
 --  False: 
 --     %globals
 --     out B: var boolean
 --     B := 0
 --  
 -- needOrigin: false "false " 
 -- exps.range: 1 exps[i]: "false " needOrigin: false 
 -- isConst: "false " ObjectInvocation_Unary 
 --  False: 
 --     %globals
 --     out B: var boolean
 --     B := 0
 --  
 -- noOrigin: "false " 
 -- loadPathII:E: "false " 1 1 exps.range: 1 staticOff: 0 
 -- loadPathII:before:newInvoke: "false " true 
 -- checkForProxy:E: "false " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "false " 
 -- ptn:newInvoke: "False " staticOff: 0 
 -- gPTN:newInvoke: "False " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: none 
 -- invoke:nonVirtual: "False " isAdr: false 
 invoke False 27 0 0
 -- global:pushOut: B off: 1 
 pushg 1 
 -- callInvoke:after:pushOut: 1 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "Beq := false " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- right:isPTN:not:valueObj: "out B: var boolean " 
 -- checkI2F2I: "Beq := false " left.isFloat: false right.isFloat: 
 --  false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- Assign:end: "Beq := false " isNotRemote: false qual: 
 --  value
 --     %id "Boolean"
 --     %globals inSub
 --     %basic 4, 8
 --  D: none 
 -- DI:newStore: "Beq " off: 3 valueOff: 0 dstE: "Beq " 
 --  isNotRemote: false originIsValueObj: false isUnitValueObj: false 
 --  rightQual:primNo: 4 rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 storeg Boolean$42 3
 -- OG:before:super.gen: "leave(loop) "
 -- handleInv: "leave(loop) " staticOff: 0 doLoad: true useRtnVal: 
 --  false 
 -- isPtnWithOrigin: "leave(loop) " 
 --  "leave(loop) " true 
 -- needOriginII: "leave(loop) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- needOrigin: true "leave(loop) " 
 -- exps.range: 1 exps[i]: "leave(loop) " needOrigin: true 
 -- isConst: "leave(loop) " ObjectInvocation_KeyWord 
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- updateOffset: "leave(loop) " E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- loadPathII:E: "leave(loop) " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "leave(loop) " 
 -- loadPathII:before:newInvoke: "leave(loop) " true 
 -- checkForProxy:E: "leave(loop) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "leave(loop) " 
 -- ptn:newInvoke: "leave(V: var integer) " staticOff: 0 
 -- bPTN:newInvoke: "leave(V: var integer) " 
 break  3 2 14 0
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS False 27 0 BETA 2
 allocEventQ
 mvStack 
 -- DI:gen: "out B: var boolean " DI:isConst: false isBasicValue: 
 --  true primNo: 4 
 -- DI:gen:primitiveType: B 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- handleAssign: "B := 0 " 
 -- handleInv: "B " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "B " 
 --  "B " false 
 -- needOriginII: "B " 
 -- E: ObjectInvocation_Unary D: "out B: var boolean " 
 -- needOrigin: true "B " 
 -- exps.range: 1 exps[i]: "B " needOrigin: true 
 -- isConst: "B " ObjectInvocation_Unary "out B: var boolean " 
 -- isConst:DI: "out B: var boolean " 
 -- updateOffset: "B " E.ATd: "out B: var boolean " 
 -- loadPathII:E: "B " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "B " 
 pushThis 
 -- loadPathII:before:newInvoke: "B " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "B := 0 " leftE: "B " 
 -- OG:before:super.gen: "0 "
 -- handleInv: "0 " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "0 " 
 --  "0 " false 
 -- needOriginII: "0 " 
 -- E: ConstLiteral D: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- needOrigin: true "0 " 
 -- exps.range: 1 exps[i]: "0 " needOrigin: true 
 -- isConst: "0 " ConstLiteral 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- isConstLiteral: "0 " 
 pushc 0
 -- const:cst: "0 " 0 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "B := 0 " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- checkI2F2I: "B := 0 " left.isFloat: false right.isFloat: false 
 --  false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- Assign:end: "B := 0 " isNotRemote: false qual: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  D: none 
 -- DI:newStore: "B " off: 1 valueOff: 0 dstE: "B " isNotRemote: 
 --  false originIsValueObj: false isUnitValueObj: false rightQual:primNo: 1 
 --  rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 storeg Boolean$42 1
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS for:to:repeat$30 30 4 loop 14
 -- vdtTableCopy: I:1:28 V:2:29
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- NonVirt: 
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then "ObjectInvocation_KeyWord " ActArg: "1 "isValue: true formalArg: "
 --  first: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --        Beq := false
 --        leave(loop)
 --   " isCompositeValueObj: false 
 -- OG:before:super.gen: "1 "
 -- handleInv: "1 " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "1 " 
 --  "1 " false 
 -- needOriginII: "1 " 
 -- E: ConstLiteral D: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- needOrigin: true "1 " 
 -- exps.range: 1 exps[i]: "1 " needOrigin: true 
 -- isConst: "1 " ConstLiteral 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- isConstLiteral: "1 " 
 pushc 1
 -- const:cst: "1 " 1 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: true formalArg:isPtn: "first: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- isIntForFloatArg: "1 " D: "first: var integer " true false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "1 " false 
 --  B: false 
 --  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- end:loadArgs:NonVirt: "
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --        Beq := false
 --        leave(loop)
 --   "
 -- NonVirt: 
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then "ObjectInvocation_KeyWord " ActArg: "length "isValue: false 
 --  formalArg: "last: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --        Beq := false
 --        leave(loop)
 --   " isCompositeValueObj: false 
 -- OG:before:super.gen: "length "
 -- handleInv: "length " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "length " 
 --  "length " true 
 -- needOriginII: "length " 
 -- E: ObjectInvocation_Unary D: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- needOrigin: true "length " 
 -- exps.range: 1 exps[i]: "length " needOrigin: true 
 -- isConst: "length " ObjectInvocation_Unary 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- updateOffset: "length " E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- loadPathII:E: "length " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "length " 
 pushThis 
 rpushg loop$14 4
 -- items:goOrigin:encOG: "loop "on: 2 isValueObj: false 
 --  origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- items:goOrigin:encOG: "= "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg =$13 1
 -- loadPathII:before:newInvoke: "length " true 
 -- checkForProxy:E: "length " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "length " 
 -- ptn:newInvoke: "length " staticOff: 0 
 -- gPTN:newInvoke: "length " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: none 
 -- invoke:nonVirtual: "length " isAdr: false 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: true formalArg:isPtn: "last: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "length ":isBasicVal: true 
 -- case:B: length ObjectGenerator 1 0 0 false false 
 -- isIntForFloatArg: "length " D: "last: var integer " true false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "length " false 
 --  B: false 
 --  
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- end:loadArgs:NonVirt: "
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --        Beq := false
 --        leave(loop)
 --   "
 pushThis 
 storeg integer$5 2
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- DI:gen: "inx: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: inx 
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0

 CLASS <= 44 1 Value 4
 jmpFalse  L3
 pushThis 
 -- vassign:B: Veq off: 4 size: 2 mode: 0 
 vassign  4 2 0
 jmp L4
 L3:
 invokeVal  Veq 31 3
 rpop 
 L4:
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in Veq: var this(Value) " DI:isConst: false 
 --  isBasicValue: false primNo: 18 
 -- DI:isConst: Veq 
 -- inArg: in Veq: var this(Value) 
 -- DI:gen: "out Beq: var boolean " DI:isConst: false isBasicValue: 
 --  true primNo: 4 
 -- DI:gen:primitiveType: Beq 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0

 CLASS <= 49 1 String 10
 -- vdtTableCopy: I:1:44
 rShiftUp  1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- super <=
 pushThis 
 rpushg iOrigin 1
 rShiftDown  1
 pushThis 
 rstoreg  Veq 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in Veq: var this(Value) " DI:isConst: false 
 --  isBasicValue: false primNo: 18 
 -- DI:isConst: Veq 
 -- inArg: in Veq: var this(Value) 
 -- DI:gen: "out Beq: var boolean " DI:isConst: false isBasicValue: 
 --  true primNo: 4 
 -- DI:gen:primitiveType: Beq 
 -- DI:gen: 
 --  loop: obj 
 --     -- "Hello"  <= "World" since H <= W
 --     -- "Qweabc" <= "Qwevwxy" since a <= e
 --     -- "Qweayc" <= "Qwexby"DI:isConst: true isBasicValue: false primNo: 0 
 -- DI:isConst: loop 
 -- DI:off: 4 this: 
 --  loop: obj 
 --     -- "Hello"  <= "World" since H <= W
 --     -- "Qweabc" <= "Qwevwxy" since a <= e
 --     -- "Qweayc" <= "Qwexby"
 --  
 pushThis 
 -- before objTmpStack:add:  50   "loop "
 invoke loop 50 4 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS loop 50 1 <= 49
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "L: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: L 
 -- DI:gen: "L1: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: L1 
 -- DI:gen: "L2: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: L2 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- handleAssign: 
 --  L1 := length
 --  -- min length of this and V
 --  
 -- handleInv: "L1 " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "L1 " 
 --  "L1 " false 
 -- needOriginII: "L1 " 
 -- E: ObjectInvocation_Unary D: "L1: var integer " 
 -- needOrigin: true "L1 " 
 -- exps.range: 1 exps[i]: "L1 " needOrigin: true 
 -- isConst: "L1 " ObjectInvocation_Unary "L1: var integer " 
 -- isConst:DI: "L1: var integer " 
 -- updateOffset: "L1 " E.ATd: "L1: var integer " 
 -- loadPathII:E: "L1 " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "L1 " 
 pushThis 
 -- loadPathII:before:newInvoke: "L1 " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: 
 --  L1 := length
 --  -- min length of this and V
 --  leftE: "L1 " 
 -- OG:before:super.gen: "length
 --  -- min length of this and V "
 -- handleInv: 
 --  length
 --  -- min length of this and V
 --  staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: 
 --  length
 --  -- min length of this and V
 --  
 --  
 --  length
 --  -- min length of this and V
 --  true 
 -- needOriginII: 
 --  length
 --  -- min length of this and V
 --  
 -- E: ObjectInvocation_Unary D: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- needOrigin: true 
 --  length
 --  -- min length of this and V
 --  
 -- exps.range: 1 exps[i]: 
 --  length
 --  -- min length of this and V
 --  needOrigin: true 
 -- isConst: 
 --  length
 --  -- min length of this and V
 --  ObjectInvocation_Unary 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- updateOffset: 
 --  length
 --  -- min length of this and V
 --  E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- loadPathII:E: 
 --  length
 --  -- min length of this and V
 --  1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: 
 --  length
 --  -- min length of this and V
 --  
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 2 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$50 1
 -- items:goOrigin:encOG: "<= "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg <=$49 1
 -- loadPathII:before:newInvoke: 
 --  length
 --  -- min length of this and V
 --  true 
 -- checkForProxy:E: 
 --  length
 --  -- min length of this and V
 --  isBasicValue: false origin.isValueObj: false staticOff: 0 rec: 
 --  none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: 
 --  length
 --  -- min length of this and V
 --  
 -- ptn:newInvoke: "length " staticOff: 0 
 -- gPTN:newInvoke: "length " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: none 
 -- invoke:nonVirtual: "length " isAdr: false 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: 
 --  L1 := length
 --  -- min length of this and V
 --  OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- right:isPTN:not:valueObj: "out V: var integer " 
 -- checkI2F2I: 
 --  L1 := length
 --  -- min length of this and V
 --  left.isFloat: false right.isFloat: false false left.isFloat:X: 
 --  false 
 -- ???:left.isFloat: false 
 -- Assign:end: 
 --  L1 := length
 --  -- min length of this and V
 --  isNotRemote: false qual: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  D: none 
 -- DI:newStore: "L1 " off: 3 valueOff: 0 dstE: "L1 " isNotRemote: 
 --  false originIsValueObj: false isUnitValueObj: false rightQual:primNo: 1 
 --  rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 storeg integer$5 3
 -- handleAssign: "L2 := Veq.length " 
 -- handleInv: "L2 " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "L2 " 
 --  "L2 " false 
 -- needOriginII: "L2 " 
 -- E: ObjectInvocation_Unary D: "L2: var integer " 
 -- needOrigin: true "L2 " 
 -- exps.range: 1 exps[i]: "L2 " needOrigin: true 
 -- isConst: "L2 " ObjectInvocation_Unary "L2: var integer " 
 -- isConst:DI: "L2: var integer " 
 -- updateOffset: "L2 " E.ATd: "L2: var integer " 
 -- loadPathII:E: "L2 " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "L2 " 
 pushThis 
 -- loadPathII:before:newInvoke: "L2 " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "L2 := Veq.length " leftE: "L2 " 
 -- OG:before:super.gen: "Veq.length "
 -- handleInv: "Veq.length " staticOff: 0 doLoad: true useRtnVal: 
 --  true 
 -- isPtnWithOrigin: "Veq.length " 
 --  "Veq " false "length " true 
 -- needOriginII: "Veq.length " 
 -- E: ObjectInvocation_Unary D: "in Veq: var this(Value) " 
 -- E: ObjectInvocation_Unary D: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- needOrigin: true "length " 
 -- exps.range: 2 exps[i]: "Veq " exps[i]: "length " needOrigin: 
 --  true 
 -- isConst: "Veq " ObjectInvocation_Unary "
 --  in Veq: var this(Value) " 
 -- isConst:DI: "in Veq: var this(Value) " 
 -- valueOff: 0 E.newOff: 2 "Veq " 
 -- isValueObj:E: "Veq " valueOff: 2 
 -- isConst: "length " ObjectInvocation_Unary 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- updateOffset: "length " E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- loadPathII:E: "Veq " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "Veq " 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$50 1
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "Veq " 
 -- DI:loadAccessor: "Veq " 
 -- DI:loadAccessor:accessValObj: "Veq " 
 rpushg newInvoke 2
 -- loadPathII:E: "length " 1 2 exps.range: 2 staticOff: 0 
 -- E: "length " E:isPrimitiveIntWithFloatArg: false rec: "Veq " 
 --  isFloat: false 
 -- loadPathII:before:newInvoke: "length " true 
 -- checkForProxy:E: "length " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: "Veq " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "length " 
 -- ptn:newInvoke: "length " staticOff: 0 
 -- gPTN:newInvoke: "length " ptnKind: 0 staticOff: 0 valueOff: 2 
 --  rec: "Veq " 
 -- invoke:nonVirtual: "length " isAdr: false 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- handleINV:end: isNotRemote: true valueOff: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "L2 := Veq.length " OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- right:isPTN:not:valueObj: "out V: var integer " 
 -- "length " 
 -- "length " 
 -- checkI2F2I: "L2 := Veq.length " left.isFloat: false 
 --  right.isFloat: false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- "length " 
 -- "length " 
 -- Assign:end: "L2 := Veq.length " isNotRemote: false qual: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  D: none 
 -- DI:newStore: "L2 " off: 4 valueOff: 0 dstE: "L2 " isNotRemote: 
 --  false originIsValueObj: false isUnitValueObj: false rightQual:primNo: 1 
 --  rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 storeg integer$5 4
 -- OG:before:super.gen: "
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2 "
 -- handleInv: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  staticOff: 0 doLoad: true useRtnVal: false 
 -- isPtnWithOrigin: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  
 --  
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  false 
 -- needOriginII: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  
 -- E: IfThenElse D: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- needOrigin: false 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  
 -- exps.range: 1 exps[i]: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  needOrigin: false 
 -- isConst: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  IfThenElse 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- noOrigin: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  
 -- loadPathII:E: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  1 1 exps.range: 1 staticOff: 0 
 -- loadPathII:before:newInvoke: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  true 
 -- checkForProxy:E: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  isBasicValue: false origin.isValueObj: false staticOff: 0 rec: 
 --  none 
 -- loadPathII:next: 1 1 
 -- IfThenElse:newInvoke: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  
 -- OG:before:super.gen: "(L1 < L2) "
 -- handleInv: "(L1 < L2) " staticOff: 0 doLoad: true useRtnVal: 
 --  true 
 -- isPtnWithOrigin: "(L1 < L2) " 
 --  "L1 " false "< L2 " true 
 -- needOriginII: "(L1 < L2) " 
 -- E: ObjectInvocation_Unary D: "L1: var integer " 
 -- E: ObjectInvocation_Binary D: 
 --  <  : 
 --     %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  
 -- needOrigin: true "< L2 " 
 -- exps.range: 2 exps[i]: "L1 " exps[i]: "< L2 " needOrigin: true 
 -- isConst: "L1 " ObjectInvocation_Unary "L1: var integer " 
 -- isConst:DI: "L1: var integer " 
 -- updateOffset: "L1 " E.ATd: "L1: var integer " 
 -- isConst: "< L2 " ObjectInvocation_Binary 
 --  <  : 
 --     %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  
 -- updateOffset: "< L2 " E.ATd: 
 --  <  : 
 --     %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  
 -- loadPathII:E: "L1 " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "L1 " 
 pushThis 
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "L1 " 
 -- DI:loadAccessor: "L1 " 
 -- DI:loadAccesor:loadPrimitive: "L1 " 
 pushg 3 newInvoke
 -- loadPathII:E: "< L2 " 1 2 exps.range: 2 staticOff: 0 
 -- E: "< L2 " E:isPrimitiveIntWithFloatArg: false rec: "L1 " 
 --  isFloat: false 
 -- NonVirt: "< L2 " "ObjectInvocation_Binary " ActArg: "L2 "
 --  isValue: false formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "< L2 " isCompositeValueObj: false 
 -- OG:before:super.gen: "L2 "
 -- handleInv: "L2 " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "L2 " 
 --  "L2 " false 
 -- needOriginII: "L2 " 
 -- E: ObjectInvocation_Unary D: "L2: var integer " 
 -- needOrigin: true "L2 " 
 -- exps.range: 1 exps[i]: "L2 " needOrigin: true 
 -- isConst: "L2 " ObjectInvocation_Unary "L2: var integer " 
 -- isConst:DI: "L2: var integer " 
 -- updateOffset: "L2 " E.ATd: "L2: var integer " 
 -- loadPathII:E: "L2 " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "L2 " 
 pushThis 
 -- loadPathII:before:newInvoke: "L2 " true 
 -- checkForProxy:E: "L2 " isBasicValue: true origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "L2 " 
 -- DI:newInvoke: "L2: var integer " off: 3 valueOff: 0 E: "L2 " 
 --  next: none isAdr: false 
 -- DI:newInvoke:loadPrimitive: "L2 " isAdr: false valueOff: 0 
 pushg 4 newInvoke
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "L2 ":isBasicVal: true 
 -- case:B: L2 ObjectGenerator 1 0 1 false false 
 -- isIntForFloatArg: "L2 " D: "in V: var integer " true false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "L2 " 
 --  B: false 
 --  "L2: var integer " 
 -- end:loadArgs:NonVirt: "< L2 "
 -- loadPathII:before:newInvoke: "< L2 " true 
 -- checkForProxy:E: "< L2 " isBasicValue: false origin.isValueObj: 
 --  true staticOff: 0 rec: "L1 " 
 -- checkForProxy:rec=None:localInvocation? "(L1 < L2) " E: "< L2 " 
 --  rec: "L1 " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "< L2 " 
 -- ptn:newInvoke: "<   " staticOff: 0 
 -- gPTN:newInvoke: "<   " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: "L1 " 
 -- checkInt2IntWithUnitArg:E: "< L2 " false false 
 lt
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  52   "$52 "
 invoke $52 52 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L5
 L4:
 pushThis 
 -- before objTmpStack:add:  53   "$53 "
 invoke $53 53 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L5:
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OG:before:super.gen: "matchEq "
 -- handleInv: "matchEq " staticOff: 0 doLoad: true useRtnVal: 
 --  false 
 -- isPtnWithOrigin: "matchEq " 
 --  "matchEq " true 
 -- needOriginII: "matchEq " 
 -- E: ObjectInvocation_Unary D: 
 --  matchEq: 
 --     inx: var integer
 --     c1: var char
 --     c2: var char
 -- needOrigin: true "matchEq " 
 -- exps.range: 1 exps[i]: "matchEq " needOrigin: true 
 -- isConst: "matchEq " ObjectInvocation_Unary 
 --  matchEq: 
 --     inx: var integer
 --     c1: var char
 --     c2: var char
 -- updateOffset: "matchEq " E.ATd: 
 --  matchEq: 
 --     inx: var integer
 --     c1: var char
 --     c2: var char
 -- loadPathII:E: "matchEq " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "matchEq " 
 pushThis 
 -- loadPathII:before:newInvoke: "matchEq " true 
 -- checkForProxy:E: "matchEq " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "matchEq " 
 -- ptn:newInvoke: "matchEq " staticOff: 0 
 -- gPTN:newInvoke: "matchEq " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: none 
 -- invoke:nonVirtual: "matchEq " isAdr: false 
 invoke matchEq 54 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS $52 52 1 loop 50
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- handleAssign: "L := L1 " 
 -- handleInv: "L " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "L " 
 --  "L " false 
 -- needOriginII: "L " 
 -- E: ObjectInvocation_Unary D: "L: var integer " 
 -- needOrigin: true "L " 
 -- exps.range: 1 exps[i]: "L " needOrigin: true 
 -- isConst: "L " ObjectInvocation_Unary "L: var integer " 
 -- isConst:DI: "L: var integer " 
 -- updateOffset: "L " E.ATd: "L: var integer " 
 -- loadPathII:E: "L " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "L " 
 pushThis 
 -- items:goOrigin:encOG: "$52 "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $52$52 1
 -- loadPathII:before:newInvoke: "L " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "L := L1 " leftE: "L " 
 -- OG:before:super.gen: "L1 "
 -- handleInv: "L1 " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "L1 " 
 --  "L1 " false 
 -- needOriginII: "L1 " 
 -- E: ObjectInvocation_Unary D: "L1: var integer " 
 -- needOrigin: true "L1 " 
 -- exps.range: 1 exps[i]: "L1 " needOrigin: true 
 -- isConst: "L1 " ObjectInvocation_Unary "L1: var integer " 
 -- isConst:DI: "L1: var integer " 
 -- updateOffset: "L1 " E.ATd: "L1: var integer " 
 -- loadPathII:E: "L1 " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "L1 " 
 pushThis 
 -- items:goOrigin:encOG: "$52 "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $52$52 1
 -- loadPathII:before:newInvoke: "L1 " true 
 -- checkForProxy:E: "L1 " isBasicValue: true origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "L1 " 
 -- DI:newInvoke: "L1: var integer " off: 2 valueOff: 0 E: "L1 " 
 --  next: none isAdr: false 
 -- DI:newInvoke:loadPrimitive: "L1 " isAdr: false valueOff: 0 
 pushg 3 newInvoke
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "L := L1 " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- checkI2F2I: "L := L1 " left.isFloat: false right.isFloat: false 
 --  false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- Assign:end: "L := L1 " isNotRemote: false qual: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  D: none 
 -- DI:newStore: "L " off: 2 valueOff: 0 dstE: "L " isNotRemote: 
 --  false originIsValueObj: false isUnitValueObj: false rightQual:primNo: 1 
 --  rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 storeg integer$5 2
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $53 53 1 loop 50
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- handleAssign: "L := L2 " 
 -- handleInv: "L " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "L " 
 --  "L " false 
 -- needOriginII: "L " 
 -- E: ObjectInvocation_Unary D: "L: var integer " 
 -- needOrigin: true "L " 
 -- exps.range: 1 exps[i]: "L " needOrigin: true 
 -- isConst: "L " ObjectInvocation_Unary "L: var integer " 
 -- isConst:DI: "L: var integer " 
 -- updateOffset: "L " E.ATd: "L: var integer " 
 -- loadPathII:E: "L " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "L " 
 pushThis 
 -- items:goOrigin:encOG: "$53 "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $53$53 1
 -- loadPathII:before:newInvoke: "L " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "L := L2 " leftE: "L " 
 -- OG:before:super.gen: "L2 "
 -- handleInv: "L2 " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "L2 " 
 --  "L2 " false 
 -- needOriginII: "L2 " 
 -- E: ObjectInvocation_Unary D: "L2: var integer " 
 -- needOrigin: true "L2 " 
 -- exps.range: 1 exps[i]: "L2 " needOrigin: true 
 -- isConst: "L2 " ObjectInvocation_Unary "L2: var integer " 
 -- isConst:DI: "L2: var integer " 
 -- updateOffset: "L2 " E.ATd: "L2: var integer " 
 -- loadPathII:E: "L2 " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "L2 " 
 pushThis 
 -- items:goOrigin:encOG: "$53 "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $53$53 1
 -- loadPathII:before:newInvoke: "L2 " true 
 -- checkForProxy:E: "L2 " isBasicValue: true origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "L2 " 
 -- DI:newInvoke: "L2: var integer " off: 3 valueOff: 0 E: "L2 " 
 --  next: none isAdr: false 
 -- DI:newInvoke:loadPrimitive: "L2 " isAdr: false valueOff: 0 
 pushg 4 newInvoke
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "L := L2 " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- checkI2F2I: "L := L2 " left.isFloat: false right.isFloat: false 
 --  false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- Assign:end: "L := L2 " isNotRemote: false qual: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  D: none 
 -- DI:newStore: "L " off: 2 valueOff: 0 dstE: "L " isNotRemote: 
 --  false originIsValueObj: false isUnitValueObj: false rightQual:primNo: 1 
 --  rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 storeg integer$5 2
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS matchEq 54 1 loop 50
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "inx: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: inx 
 -- DI:gen: "c1: var char " DI:isConst: false isBasicValue: true 
 --  primNo: 3 
 -- DI:gen:primitiveType: c1 
 -- DI:gen: "c2: var char " DI:isConst: false isBasicValue: true 
 --  primNo: 3 
 -- DI:gen:primitiveType: c2 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 pushThis 
 -- before objTmpStack:add:  55   "isEmpty "
 invoke isEmpty 55 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  58   "loop "
 invoke loop 58 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  61   "doit "
 invoke doit 61 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS isEmpty 55 1 matchEq 54
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq) "
 -- handleInv: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  staticOff: 0 doLoad: true useRtnVal: false 
 -- isPtnWithOrigin: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  
 --  
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  false 
 -- needOriginII: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  
 -- E: IfThen D: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- needOrigin: false 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  
 -- exps.range: 1 exps[i]: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  needOrigin: false 
 -- isConst: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  IfThen 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- noOrigin: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  
 -- loadPathII:E: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  1 1 exps.range: 1 staticOff: 0 
 -- loadPathII:before:newInvoke: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  true 
 -- checkForProxy:E: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  isBasicValue: false origin.isValueObj: false staticOff: 0 rec: 
 --  none 
 -- loadPathII:next: 1 1 
 -- IfThen:newInvoke: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  
 -- OG:before:super.gen: "(L1 = 0) "
 -- handleInv: "(L1 = 0) " staticOff: 0 doLoad: true useRtnVal: 
 --  true 
 -- isPtnWithOrigin: "(L1 = 0) " 
 --  "L1 " false "= 0 " true 
 -- needOriginII: "(L1 = 0) " 
 -- E: ObjectInvocation_Unary D: "L1: var integer " 
 -- E: ObjectInvocation_Binary D: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- needOrigin: true "= 0 " 
 -- exps.range: 2 exps[i]: "L1 " exps[i]: "= 0 " needOrigin: true 
 -- isConst: "L1 " ObjectInvocation_Unary "L1: var integer " 
 -- isConst:DI: "L1: var integer " 
 -- updateOffset: "L1 " E.ATd: "L1: var integer " 
 -- isConst: "= 0 " ObjectInvocation_Binary 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- updateOffset: "= 0 " E.ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- loadPathII:E: "L1 " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "L1 " 
 pushThis 
 -- items:goOrigin:encOG: "isEmpty "on: 2 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$55 1
 -- items:goOrigin:encOG: "matchEq "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$54 1
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "L1 " 
 -- DI:loadAccessor: "L1 " 
 -- DI:loadAccesor:loadPrimitive: "L1 " 
 pushg 3 newInvoke
 -- loadPathII:E: "= 0 " 1 2 exps.range: 2 staticOff: 0 
 -- E: "= 0 " E:isPrimitiveIntWithFloatArg: false rec: "L1 " 
 --  isFloat: false 
 -- NonVirt: "= 0 " "ObjectInvocation_Binary " ActArg: "0 "isValue: 
 --  true formalArg: "in Veq: var this(Value) " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "= 0 " isCompositeValueObj: true 
 -- OG:before:super.gen: "0 "
 -- handleInv: "0 " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "0 " 
 --  "0 " false 
 -- needOriginII: "0 " 
 -- E: ConstLiteral D: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- needOrigin: true "0 " 
 -- exps.range: 1 exps[i]: "0 " needOrigin: true 
 -- isConst: "0 " ConstLiteral 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- isConstLiteral: "0 " 
 pushc 0
 -- const:cst: "0 " 0 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- vEq: 
 -- end:loadArgs:NonVirt: "= 0 "
 -- loadPathII:before:newInvoke: "= 0 " true 
 -- checkForProxy:E: "= 0 " isBasicValue: true origin.isValueObj: 
 --  true staticOff: 0 rec: "L1 " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "= 0 " 
 -- ptn:newInvoke: "=   " staticOff: 0 
 -- gPTN:newInvoke: "=   " ptnKind: 1 staticOff: 0 valueOff: 0 
 --  rec: "L1 " 
 -- rec: "L1 " E: "= 0 " OGx.label: "ObjectGenerator "OGx: "
 --  integer " 
 --  rec.ATd: "L1: var integer " 
 -- bobs: 1 OGx: "integer " 
 eq
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  56   "$56 "
 invoke $56 56 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OG:before:super.gen: "
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq) "
 -- handleInv: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  staticOff: 0 doLoad: true useRtnVal: false 
 -- isPtnWithOrigin: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  
 --  
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  false 
 -- needOriginII: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  
 -- E: IfThen D: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- needOrigin: false 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  
 -- exps.range: 1 exps[i]: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  needOrigin: false 
 -- isConst: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  IfThen 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- noOrigin: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  
 -- loadPathII:E: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  1 1 exps.range: 1 staticOff: 0 
 -- loadPathII:before:newInvoke: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  true 
 -- checkForProxy:E: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  isBasicValue: false origin.isValueObj: false staticOff: 0 rec: 
 --  none 
 -- loadPathII:next: 1 1 
 -- IfThen:newInvoke: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  
 -- OG:before:super.gen: "(L2 = 0) "
 -- handleInv: "(L2 = 0) " staticOff: 0 doLoad: true useRtnVal: 
 --  true 
 -- isPtnWithOrigin: "(L2 = 0) " 
 --  "L2 " false "= 0 " true 
 -- needOriginII: "(L2 = 0) " 
 -- E: ObjectInvocation_Unary D: "L2: var integer " 
 -- E: ObjectInvocation_Binary D: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- needOrigin: true "= 0 " 
 -- exps.range: 2 exps[i]: "L2 " exps[i]: "= 0 " needOrigin: true 
 -- isConst: "L2 " ObjectInvocation_Unary "L2: var integer " 
 -- isConst:DI: "L2: var integer " 
 -- updateOffset: "L2 " E.ATd: "L2: var integer " 
 -- isConst: "= 0 " ObjectInvocation_Binary 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- updateOffset: "= 0 " E.ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- loadPathII:E: "L2 " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "L2 " 
 pushThis 
 -- items:goOrigin:encOG: "isEmpty "on: 2 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$55 1
 -- items:goOrigin:encOG: "matchEq "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$54 1
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "L2 " 
 -- DI:loadAccessor: "L2 " 
 -- DI:loadAccesor:loadPrimitive: "L2 " 
 pushg 4 newInvoke
 -- loadPathII:E: "= 0 " 1 2 exps.range: 2 staticOff: 0 
 -- E: "= 0 " E:isPrimitiveIntWithFloatArg: false rec: "L2 " 
 --  isFloat: false 
 -- NonVirt: "= 0 " "ObjectInvocation_Binary " ActArg: "0 "isValue: 
 --  true formalArg: "in Veq: var this(Value) " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "= 0 " isCompositeValueObj: true 
 -- OG:before:super.gen: "0 "
 -- handleInv: "0 " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "0 " 
 --  "0 " false 
 -- needOriginII: "0 " 
 -- E: ConstLiteral D: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- needOrigin: true "0 " 
 -- exps.range: 1 exps[i]: "0 " needOrigin: true 
 -- isConst: "0 " ConstLiteral 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- isConstLiteral: "0 " 
 pushc 0
 -- const:cst: "0 " 0 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- vEq: 
 -- end:loadArgs:NonVirt: "= 0 "
 -- loadPathII:before:newInvoke: "= 0 " true 
 -- checkForProxy:E: "= 0 " isBasicValue: true origin.isValueObj: 
 --  true staticOff: 0 rec: "L2 " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "= 0 " 
 -- ptn:newInvoke: "=   " staticOff: 0 
 -- gPTN:newInvoke: "=   " ptnKind: 1 staticOff: 0 valueOff: 0 
 --  rec: "L2 " 
 -- rec: "L2 " E: "= 0 " OGx.label: "ObjectGenerator "OGx: "
 --  integer " 
 --  rec.ATd: "L2: var integer " 
 -- bobs: 1 OGx: "integer " 
 eq
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmpFalse  L7
 L6:
 pushThis 
 -- before objTmpStack:add:  57   "$57 "
 invoke $57 57 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L7:
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $56 56 1 isEmpty 55
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- handleAssign: "Beq := L1 <= L2 " 
 -- handleInv: "Beq " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "Beq " 
 --  "Beq " false 
 -- needOriginII: "Beq " 
 -- E: ObjectInvocation_Unary D: "out Beq: var boolean " 
 -- needOrigin: true "Beq " 
 -- exps.range: 1 exps[i]: "Beq " needOrigin: true 
 -- isConst: "Beq " ObjectInvocation_Unary "out Beq: var boolean " 
 -- isConst:DI: "out Beq: var boolean " 
 -- updateOffset: "Beq " E.ATd: "out Beq: var boolean " 
 -- loadPathII:E: "Beq " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "Beq " 
 pushThis 
 -- items:goOrigin:encOG: "$56 "on: 4 isValueObj: false 
 --  origin: isEmpty origin:isValueObj: false 
 rpushg $56$56 1
 -- items:goOrigin:encOG: "isEmpty "on: 3 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$55 1
 -- items:goOrigin:encOG: "matchEq "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$54 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$50 1
 -- loadPathII:before:newInvoke: "Beq " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "Beq := L1 <= L2 " leftE: "Beq " 
 -- OG:before:super.gen: "L1 <= L2 "
 -- handleInv: "L1 <= L2 " staticOff: 0 doLoad: true useRtnVal: 
 --  true 
 -- isPtnWithOrigin: "L1 <= L2 " 
 --  "L1 " false "<= L2 " true 
 -- needOriginII: "L1 <= L2 " 
 -- E: ObjectInvocation_Unary D: "L1: var integer " 
 -- E: ObjectInvocation_Binary D: 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- needOrigin: true "<= L2 " 
 -- exps.range: 2 exps[i]: "L1 " exps[i]: "<= L2 " needOrigin: true 
 -- isConst: "L1 " ObjectInvocation_Unary "L1: var integer " 
 -- isConst:DI: "L1: var integer " 
 -- updateOffset: "L1 " E.ATd: "L1: var integer " 
 -- isConst: "<= L2 " ObjectInvocation_Binary 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- updateOffset: "<= L2 " E.ATd: 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- loadPathII:E: "L1 " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "L1 " 
 pushThis 
 -- items:goOrigin:encOG: "$56 "on: 3 isValueObj: false 
 --  origin: isEmpty origin:isValueObj: false 
 rpushg $56$56 1
 -- items:goOrigin:encOG: "isEmpty "on: 2 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$55 1
 -- items:goOrigin:encOG: "matchEq "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$54 1
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "L1 " 
 -- DI:loadAccessor: "L1 " 
 -- DI:loadAccesor:loadPrimitive: "L1 " 
 pushg 3 newInvoke
 -- loadPathII:E: "<= L2 " 1 2 exps.range: 2 staticOff: 0 
 -- E: "<= L2 " E:isPrimitiveIntWithFloatArg: false rec: "L1 " 
 --  isFloat: false 
 -- NonVirt: "<= L2 " "ObjectInvocation_Binary " ActArg: "L2 "
 --  isValue: false formalArg: "in Veq: var this(Value) " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "<= L2 " isCompositeValueObj: true 
 -- OG:before:super.gen: "L2 "
 -- handleInv: "L2 " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "L2 " 
 --  "L2 " false 
 -- needOriginII: "L2 " 
 -- E: ObjectInvocation_Unary D: "L2: var integer " 
 -- needOrigin: true "L2 " 
 -- exps.range: 1 exps[i]: "L2 " needOrigin: true 
 -- isConst: "L2 " ObjectInvocation_Unary "L2: var integer " 
 -- isConst:DI: "L2: var integer " 
 -- updateOffset: "L2 " E.ATd: "L2: var integer " 
 -- loadPathII:E: "L2 " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "L2 " 
 pushThis 
 -- items:goOrigin:encOG: "$56 "on: 3 isValueObj: false 
 --  origin: isEmpty origin:isValueObj: false 
 rpushg $56$56 1
 -- items:goOrigin:encOG: "isEmpty "on: 2 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$55 1
 -- items:goOrigin:encOG: "matchEq "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$54 1
 -- loadPathII:before:newInvoke: "L2 " true 
 -- checkForProxy:E: "L2 " isBasicValue: true origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "L2 " 
 -- DI:newInvoke: "L2: var integer " off: 3 valueOff: 0 E: "L2 " 
 --  next: none isAdr: false 
 -- DI:newInvoke:loadPrimitive: "L2 " isAdr: false valueOff: 0 
 pushg 4 newInvoke
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- vEq: 
 -- end:loadArgs:NonVirt: "<= L2 "
 -- loadPathII:before:newInvoke: "<= L2 " true 
 -- checkForProxy:E: "<= L2 " isBasicValue: false origin.isValueObj: 
 --  true staticOff: 0 rec: "L1 " 
 -- checkForProxy:rec=None:localInvocation? "L1 <= L2 " E: "<= L2 " 
 --  rec: "L1 " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "<= L2 " 
 -- ptn:newInvoke: "<=   " staticOff: 0 
 -- gPTN:newInvoke: "<=   " ptnKind: 1 staticOff: 0 valueOff: 0 
 --  rec: "L1 " 
 -- rec: "L1 " E: "<= L2 " OGx.label: "ObjectGenerator "OGx: "
 --  integer " 
 --  rec.ATd: "L1: var integer " 
 -- bobs: 1 OGx: "integer " 
 le
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "Beq := L1 <= L2 " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- right:isPTN:not:valueObj: "out Beq: var boolean " 
 -- "<= L2 " 
 -- "<= L2 " 
 -- checkI2F2I: "Beq := L1 <= L2 " left.isFloat: false 
 --  right.isFloat: false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- "<= L2 " 
 -- "<= L2 " 
 -- Assign:end: "Beq := L1 <= L2 " isNotRemote: false qual: 
 --  value
 --     %id "Boolean"
 --     %globals inSub
 --     %basic 4, 8
 --  D: none 
 -- DI:newStore: "Beq " off: 3 valueOff: 0 dstE: "Beq " 
 --  isNotRemote: false originIsValueObj: false isUnitValueObj: false 
 --  rightQual:primNo: 4 rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 storeg Boolean$42 3
 -- OG:before:super.gen: "leave(matchEq) "
 -- handleInv: "leave(matchEq) " staticOff: 0 doLoad: true 
 --  useRtnVal: false 
 -- isPtnWithOrigin: "leave(matchEq) " 
 --  "leave(matchEq) " true 
 -- needOriginII: "leave(matchEq) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- needOrigin: true "leave(matchEq) " 
 -- exps.range: 1 exps[i]: "leave(matchEq) " needOrigin: true 
 -- isConst: "leave(matchEq) " ObjectInvocation_KeyWord 
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- updateOffset: "leave(matchEq) " E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- loadPathII:E: "leave(matchEq) " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "leave(matchEq) " 
 -- loadPathII:before:newInvoke: "leave(matchEq) " true 
 -- checkForProxy:E: "leave(matchEq) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "leave(matchEq) " 
 -- ptn:newInvoke: "leave(V: var integer) " staticOff: 0 
 -- bPTN:newInvoke: "leave(V: var integer) " 
 break  2 2 54 0
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $57 57 1 isEmpty 55
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- handleAssign: "Beq := false " 
 -- handleInv: "Beq " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "Beq " 
 --  "Beq " false 
 -- needOriginII: "Beq " 
 -- E: ObjectInvocation_Unary D: "out Beq: var boolean " 
 -- needOrigin: true "Beq " 
 -- exps.range: 1 exps[i]: "Beq " needOrigin: true 
 -- isConst: "Beq " ObjectInvocation_Unary "out Beq: var boolean " 
 -- isConst:DI: "out Beq: var boolean " 
 -- updateOffset: "Beq " E.ATd: "out Beq: var boolean " 
 -- loadPathII:E: "Beq " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "Beq " 
 pushThis 
 -- items:goOrigin:encOG: "$57 "on: 4 isValueObj: false 
 --  origin: isEmpty origin:isValueObj: false 
 rpushg $57$57 1
 -- items:goOrigin:encOG: "isEmpty "on: 3 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$55 1
 -- items:goOrigin:encOG: "matchEq "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$54 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$50 1
 -- loadPathII:before:newInvoke: "Beq " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "Beq := false " leftE: "Beq " 
 -- OG:before:super.gen: "false "
 -- handleInv: "false " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "false " 
 --  "false " false 
 -- needOriginII: "false " 
 -- E: ObjectInvocation_Unary D: 
 --  False: 
 --     %globals
 --     out B: var boolean
 --     B := 0
 --  
 -- needOrigin: false "false " 
 -- exps.range: 1 exps[i]: "false " needOrigin: false 
 -- isConst: "false " ObjectInvocation_Unary 
 --  False: 
 --     %globals
 --     out B: var boolean
 --     B := 0
 --  
 -- noOrigin: "false " 
 -- loadPathII:E: "false " 1 1 exps.range: 1 staticOff: 0 
 -- loadPathII:before:newInvoke: "false " true 
 -- checkForProxy:E: "false " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "false " 
 -- ptn:newInvoke: "False " staticOff: 0 
 -- gPTN:newInvoke: "False " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: none 
 -- invoke:nonVirtual: "False " isAdr: false 
 invoke False 27 0 0
 -- global:pushOut: B off: 1 
 pushg 1 
 -- callInvoke:after:pushOut: 1 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "Beq := false " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- right:isPTN:not:valueObj: "out B: var boolean " 
 -- checkI2F2I: "Beq := false " left.isFloat: false right.isFloat: 
 --  false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- Assign:end: "Beq := false " isNotRemote: false qual: 
 --  value
 --     %id "Boolean"
 --     %globals inSub
 --     %basic 4, 8
 --  D: none 
 -- DI:newStore: "Beq " off: 3 valueOff: 0 dstE: "Beq " 
 --  isNotRemote: false originIsValueObj: false isUnitValueObj: false 
 --  rightQual:primNo: 4 rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 storeg Boolean$42 3
 -- OG:before:super.gen: "leave(matchEq) "
 -- handleInv: "leave(matchEq) " staticOff: 0 doLoad: true 
 --  useRtnVal: false 
 -- isPtnWithOrigin: "leave(matchEq) " 
 --  "leave(matchEq) " true 
 -- needOriginII: "leave(matchEq) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- needOrigin: true "leave(matchEq) " 
 -- exps.range: 1 exps[i]: "leave(matchEq) " needOrigin: true 
 -- isConst: "leave(matchEq) " ObjectInvocation_KeyWord 
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- updateOffset: "leave(matchEq) " E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- loadPathII:E: "leave(matchEq) " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "leave(matchEq) " 
 -- loadPathII:before:newInvoke: "leave(matchEq) " true 
 -- checkForProxy:E: "leave(matchEq) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "leave(matchEq) " 
 -- ptn:newInvoke: "leave(V: var integer) " staticOff: 0 
 -- bPTN:newInvoke: "leave(V: var integer) " 
 break  2 2 54 0
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS loop 58 1 matchEq 54
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- handleAssign: "inx := inx + 1 " 
 -- handleInv: "inx " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "inx " 
 --  "inx " false 
 -- needOriginII: "inx " 
 -- E: ObjectInvocation_Unary D: "inx: var integer " 
 -- needOrigin: true "inx " 
 -- exps.range: 1 exps[i]: "inx " needOrigin: true 
 -- isConst: "inx " ObjectInvocation_Unary "inx: var integer " 
 -- isConst:DI: "inx: var integer " 
 -- updateOffset: "inx " E.ATd: "inx: var integer " 
 -- loadPathII:E: "inx " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "inx " 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$58 1
 -- loadPathII:before:newInvoke: "inx " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "inx := inx + 1 " leftE: "inx " 
 -- OG:before:super.gen: "inx + 1 "
 -- handleInv: "inx + 1 " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "inx + 1 " 
 --  "inx " false "+ 1 " true 
 -- needOriginII: "inx + 1 " 
 -- E: ObjectInvocation_Unary D: "inx: var integer " 
 -- E: ObjectInvocation_Binary D: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- needOrigin: true "+ 1 " 
 -- exps.range: 2 exps[i]: "inx " exps[i]: "+ 1 " needOrigin: true 
 -- isConst: "inx " ObjectInvocation_Unary "inx: var integer " 
 -- isConst:DI: "inx: var integer " 
 -- updateOffset: "inx " E.ATd: "inx: var integer " 
 -- isConst: "+ 1 " ObjectInvocation_Binary 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- updateOffset: "+ 1 " E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- loadPathII:E: "inx " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "inx " 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$58 1
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "inx " 
 -- DI:loadAccessor: "inx " 
 -- DI:loadAccesor:loadPrimitive: "inx " 
 pushg 2 newInvoke
 -- loadPathII:E: "+ 1 " 1 2 exps.range: 2 staticOff: 0 
 -- E: "+ 1 " E:isPrimitiveIntWithFloatArg: false rec: "inx " 
 --  isFloat: false 
 -- NonVirt: "+ 1 " "ObjectInvocation_Binary " ActArg: "1 "isValue: 
 --  true formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ 1 " isCompositeValueObj: false 
 -- OG:before:super.gen: "1 "
 -- handleInv: "1 " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "1 " 
 --  "1 " false 
 -- needOriginII: "1 " 
 -- E: ConstLiteral D: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- needOrigin: true "1 " 
 -- exps.range: 1 exps[i]: "1 " needOrigin: true 
 -- isConst: "1 " ConstLiteral 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- isConstLiteral: "1 " 
 pushc 1
 -- const:cst: "1 " 1 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- isIntForFloatArg: "1 " D: "in V: var integer " true false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "1 " false 
 --  B: false 
 --  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- end:loadArgs:NonVirt: "+ 1 "
 -- loadPathII:before:newInvoke: "+ 1 " true 
 -- checkForProxy:E: "+ 1 " isBasicValue: true origin.isValueObj: 
 --  true staticOff: 0 rec: "inx " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "+ 1 " 
 -- ptn:newInvoke: "+   " staticOff: 0 
 -- gPTN:newInvoke: "+   " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: "inx " 
 -- checkInt2IntWithUnitArg:E: "+ 1 " false false 
 plus
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "inx := inx + 1 " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- right:isPTN:not:valueObj: "out R: var integer " 
 -- "+ 1 " 
 -- "+ 1 " 
 -- checkI2F2I: "inx := inx + 1 " left.isFloat: false right.isFloat: 
 --  false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- "+ 1 " 
 -- "+ 1 " 
 -- Assign:end: "inx := inx + 1 " isNotRemote: false qual: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  D: none 
 -- DI:newStore: "inx " off: 2 valueOff: 0 dstE: "inx " 
 --  isNotRemote: false originIsValueObj: false isUnitValueObj: false 
 --  rightQual:primNo: 1 rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 storeg integer$5 2
 -- handleAssign: "c1 := get[inx] " 
 -- handleInv: "c1 " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "c1 " 
 --  "c1 " false 
 -- needOriginII: "c1 " 
 -- E: ObjectInvocation_Unary D: "c1: var char " 
 -- needOrigin: true "c1 " 
 -- exps.range: 1 exps[i]: "c1 " needOrigin: true 
 -- isConst: "c1 " ObjectInvocation_Unary "c1: var char " 
 -- isConst:DI: "c1: var char " 
 -- updateOffset: "c1 " E.ATd: "c1: var char " 
 -- loadPathII:E: "c1 " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "c1 " 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$58 1
 -- loadPathII:before:newInvoke: "c1 " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "c1 := get[inx] " leftE: "c1 " 
 -- OG:before:super.gen: "get[inx] "
 -- handleInv: "get[inx] " staticOff: 0 doLoad: true useRtnVal: 
 --  true 
 -- isPtnWithOrigin: "get[inx] " 
 --  "get[inx] " true 
 -- needOriginII: "get[inx] " 
 -- E: ObjectInvocation_KeyWord D: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- needOrigin: true "get[inx] " 
 -- exps.range: 1 exps[i]: "get[inx] " needOrigin: true 
 -- isConst: "get[inx] " ObjectInvocation_KeyWord 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- updateOffset: "get[inx] " E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- loadPathII:E: "get[inx] " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "get[inx] " 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 4 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$58 1
 -- items:goOrigin:encOG: "matchEq "on: 3 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$54 1
 -- items:goOrigin:encOG: "loop "on: 2 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$50 1
 -- items:goOrigin:encOG: "<= "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg <=$49 1
 -- NonVirt: "get[inx] " "ObjectInvocation_KeyWord " ActArg: "inx "
 --  isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx] " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "inx "
 -- handleInv: "inx " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "inx " 
 --  "inx " false 
 -- needOriginII: "inx " 
 -- E: ObjectInvocation_Unary D: "inx: var integer " 
 -- needOrigin: true "inx " 
 -- exps.range: 1 exps[i]: "inx " needOrigin: true 
 -- isConst: "inx " ObjectInvocation_Unary "inx: var integer " 
 -- isConst:DI: "inx: var integer " 
 -- updateOffset: "inx " E.ATd: "inx: var integer " 
 -- loadPathII:E: "inx " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "inx " 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$58 1
 -- loadPathII:before:newInvoke: "inx " true 
 -- checkForProxy:E: "inx " isBasicValue: true origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "inx " 
 -- DI:newInvoke: "inx: var integer " off: 1 valueOff: 0 E: "inx " 
 --  next: none isAdr: false 
 -- DI:newInvoke:loadPrimitive: "inx " isAdr: false valueOff: 0 
 pushg 2 newInvoke
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- isIntForFloatArg: "inx " D: "inx: var integer " true false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "inx " 
 --  B: false 
 --  "inx: var integer " 
 -- end:loadArgs:NonVirt: "get[inx] "
 -- loadPathII:before:newInvoke: "get[inx] " true 
 -- checkForProxy:E: "get[inx] " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "get[inx] " 
 -- ptn:newInvoke: "get[inx: var integer] " staticOff: 0 
 -- indexPTN:newInvoke: "get[inx: var integer] " isAdr: false 
 xpushg  inx 1 0 1
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "c1 := get[inx] " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- right:isPTN:not:valueObj: "out ch: var char " 
 -- checkI2F2I: "c1 := get[inx] " left.isFloat: false right.isFloat: 
 --  false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- Assign:end: "c1 := get[inx] " isNotRemote: false qual: 
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  D: none 
 -- DI:newStore: "c1 " off: 3 valueOff: 0 dstE: "c1 " isNotRemote: 
 --  false originIsValueObj: false isUnitValueObj: false rightQual:primNo: 3 
 --  rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 storeg char$7 3
 -- handleAssign: "c2 := Veq.get[inx] " 
 -- handleInv: "c2 " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "c2 " 
 --  "c2 " false 
 -- needOriginII: "c2 " 
 -- E: ObjectInvocation_Unary D: "c2: var char " 
 -- needOrigin: true "c2 " 
 -- exps.range: 1 exps[i]: "c2 " needOrigin: true 
 -- isConst: "c2 " ObjectInvocation_Unary "c2: var char " 
 -- isConst:DI: "c2: var char " 
 -- updateOffset: "c2 " E.ATd: "c2: var char " 
 -- loadPathII:E: "c2 " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "c2 " 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$58 1
 -- loadPathII:before:newInvoke: "c2 " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "c2 := Veq.get[inx] " leftE: "c2 " 
 -- OG:before:super.gen: "Veq.get[inx] "
 -- handleInv: "Veq.get[inx] " staticOff: 0 doLoad: true useRtnVal: 
 --  true 
 -- isPtnWithOrigin: "Veq.get[inx] " 
 --  "Veq " false "get[inx] " true 
 -- needOriginII: "Veq.get[inx] " 
 -- E: ObjectInvocation_Unary D: "in Veq: var this(Value) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- needOrigin: true "get[inx] " 
 -- exps.range: 2 exps[i]: "Veq " exps[i]: "get[inx] " needOrigin: 
 --  true 
 -- isConst: "Veq " ObjectInvocation_Unary "
 --  in Veq: var this(Value) " 
 -- isConst:DI: "in Veq: var this(Value) " 
 -- valueOff: 0 E.newOff: 2 "Veq " 
 -- isValueObj:E: "Veq " valueOff: 2 
 -- isConst: "get[inx] " ObjectInvocation_KeyWord 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- updateOffset: "get[inx] " E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- loadPathII:E: "Veq " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "Veq " 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 3 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$58 1
 -- items:goOrigin:encOG: "matchEq "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$54 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$50 1
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "Veq " 
 -- DI:loadAccessor: "Veq " 
 -- DI:loadAccessor:accessValObj: "Veq " 
 rpushg newInvoke 2
 -- loadPathII:E: "get[inx] " 1 2 exps.range: 2 staticOff: 0 
 -- E: "get[inx] " E:isPrimitiveIntWithFloatArg: false rec: "Veq " 
 --  isFloat: false 
 -- NonVirt: "get[inx] " "ObjectInvocation_KeyWord " ActArg: "inx "
 --  isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx] " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "inx "
 -- handleInv: "inx " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "inx " 
 --  "inx " false 
 -- needOriginII: "inx " 
 -- E: ObjectInvocation_Unary D: "inx: var integer " 
 -- needOrigin: true "inx " 
 -- exps.range: 1 exps[i]: "inx " needOrigin: true 
 -- isConst: "inx " ObjectInvocation_Unary "inx: var integer " 
 -- isConst:DI: "inx: var integer " 
 -- updateOffset: "inx " E.ATd: "inx: var integer " 
 -- loadPathII:E: "inx " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "inx " 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$58 1
 -- loadPathII:before:newInvoke: "inx " true 
 -- checkForProxy:E: "inx " isBasicValue: true origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "inx " 
 -- DI:newInvoke: "inx: var integer " off: 1 valueOff: 0 E: "inx " 
 --  next: none isAdr: false 
 -- DI:newInvoke:loadPrimitive: "inx " isAdr: false valueOff: 0 
 pushg 2 newInvoke
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- isIntForFloatArg: "inx " D: "inx: var integer " true false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "inx " 
 --  B: false 
 --  "inx: var integer " 
 -- end:loadArgs:NonVirt: "get[inx] "
 -- loadPathII:before:newInvoke: "get[inx] " true 
 -- checkForProxy:E: "get[inx] " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: "Veq " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "get[inx] " 
 -- ptn:newInvoke: "get[inx: var integer] " staticOff: 0 
 -- indexPTN:newInvoke: "get[inx: var integer] " isAdr: false 
 xpushg  inx 1 0 1
 -- handleINV:end: isNotRemote: true valueOff: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "c2 := Veq.get[inx] " OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- right:isPTN:not:valueObj: "out ch: var char " 
 -- "get[inx] " 
 -- "get[inx] " 
 -- checkI2F2I: "c2 := Veq.get[inx] " left.isFloat: false 
 --  right.isFloat: false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- "get[inx] " 
 -- "get[inx] " 
 -- Assign:end: "c2 := Veq.get[inx] " isNotRemote: false qual: 
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  D: none 
 -- DI:newStore: "c2 " off: 4 valueOff: 0 dstE: "c2 " isNotRemote: 
 --  false originIsValueObj: false isUnitValueObj: false rightQual:primNo: 3 
 --  rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 storeg char$7 4
 -- OG:before:super.gen: "
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop) "
 -- handleInv: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  staticOff: 0 doLoad: true useRtnVal: false 
 -- isPtnWithOrigin: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  
 --  
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  false 
 -- needOriginII: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  
 -- E: IfThen D: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- needOrigin: false 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  
 -- exps.range: 1 exps[i]: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  needOrigin: false 
 -- isConst: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  IfThen 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- noOrigin: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  
 -- loadPathII:E: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  1 1 exps.range: 1 staticOff: 0 
 -- loadPathII:before:newInvoke: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  true 
 -- checkForProxy:E: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  isBasicValue: false origin.isValueObj: false staticOff: 0 rec: 
 --  none 
 -- loadPathII:next: 1 1 
 -- IfThen:newInvoke: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  
 -- OG:before:super.gen: "(c1 = c2) "
 -- handleInv: "(c1 = c2) " staticOff: 0 doLoad: true useRtnVal: 
 --  true 
 -- isPtnWithOrigin: "(c1 = c2) " 
 --  "c1 " false "= c2 " true 
 -- needOriginII: "(c1 = c2) " 
 -- E: ObjectInvocation_Unary D: "c1: var char " 
 -- E: ObjectInvocation_Binary D: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- needOrigin: true "= c2 " 
 -- exps.range: 2 exps[i]: "c1 " exps[i]: "= c2 " needOrigin: true 
 -- isConst: "c1 " ObjectInvocation_Unary "c1: var char " 
 -- isConst:DI: "c1: var char " 
 -- updateOffset: "c1 " E.ATd: "c1: var char " 
 -- isConst: "= c2 " ObjectInvocation_Binary 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- updateOffset: "= c2 " E.ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- loadPathII:E: "c1 " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "c1 " 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$58 1
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "c1 " 
 -- DI:loadAccessor: "c1 " 
 -- DI:loadAccesor:loadPrimitive: "c1 " 
 pushg 3 newInvoke
 -- loadPathII:E: "= c2 " 1 2 exps.range: 2 staticOff: 0 
 -- E: "= c2 " E:isPrimitiveIntWithFloatArg: false rec: "c1 " 
 --  isFloat: false 
 -- NonVirt: "= c2 " "ObjectInvocation_Binary " ActArg: "c2 "
 --  isValue: false formalArg: "in Veq: var this(Value) " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "= c2 " isCompositeValueObj: true 
 -- OG:before:super.gen: "c2 "
 -- handleInv: "c2 " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "c2 " 
 --  "c2 " false 
 -- needOriginII: "c2 " 
 -- E: ObjectInvocation_Unary D: "c2: var char " 
 -- needOrigin: true "c2 " 
 -- exps.range: 1 exps[i]: "c2 " needOrigin: true 
 -- isConst: "c2 " ObjectInvocation_Unary "c2: var char " 
 -- isConst:DI: "c2: var char " 
 -- updateOffset: "c2 " E.ATd: "c2: var char " 
 -- loadPathII:E: "c2 " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "c2 " 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$58 1
 -- loadPathII:before:newInvoke: "c2 " true 
 -- checkForProxy:E: "c2 " isBasicValue: true origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "c2 " 
 -- DI:newInvoke: "c2: var char " off: 3 valueOff: 0 E: "c2 " 
 --  next: none isAdr: false 
 -- DI:newInvoke:loadPrimitive: "c2 " isAdr: false valueOff: 0 
 pushg 4 newInvoke
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- vEq: 
 -- end:loadArgs:NonVirt: "= c2 "
 -- loadPathII:before:newInvoke: "= c2 " true 
 -- checkForProxy:E: "= c2 " isBasicValue: true origin.isValueObj: 
 --  true staticOff: 0 rec: "c1 " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "= c2 " 
 -- ptn:newInvoke: "=   " staticOff: 0 
 -- gPTN:newInvoke: "=   " ptnKind: 1 staticOff: 0 valueOff: 0 
 --  rec: "c1 " 
 -- rec: "c1 " E: "= c2 " OGx.label: "ObjectGenerator "OGx: "char " 
 --  rec.ATd: "c1: var char " 
 -- bobs: 3 OGx: "char " 
 eq
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  59   "$59 "
 invoke $59 59 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $59 59 1 loop 58
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "if (inx < L) :then 
 --     restart(loop) "
 -- handleInv: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  staticOff: 0 doLoad: true useRtnVal: false 
 -- isPtnWithOrigin: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  
 --  
 --  if (inx < L) :then 
 --     restart(loop)
 --  false 
 -- needOriginII: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  
 -- E: IfThen D: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- needOrigin: false 
 --  if (inx < L) :then 
 --     restart(loop)
 --  
 -- exps.range: 1 exps[i]: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  needOrigin: false 
 -- isConst: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  IfThen 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- noOrigin: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  
 -- loadPathII:E: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  1 1 exps.range: 1 staticOff: 0 
 -- loadPathII:before:newInvoke: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  true 
 -- checkForProxy:E: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  isBasicValue: false origin.isValueObj: false staticOff: 0 rec: 
 --  none 
 -- loadPathII:next: 1 1 
 -- IfThen:newInvoke: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  
 -- OG:before:super.gen: "(inx < L) "
 -- handleInv: "(inx < L) " staticOff: 0 doLoad: true useRtnVal: 
 --  true 
 -- isPtnWithOrigin: "(inx < L) " 
 --  "inx " false "< L " true 
 -- needOriginII: "(inx < L) " 
 -- E: ObjectInvocation_Unary D: "inx: var integer " 
 -- E: ObjectInvocation_Binary D: 
 --  <  : 
 --     %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  
 -- needOrigin: true "< L " 
 -- exps.range: 2 exps[i]: "inx " exps[i]: "< L " needOrigin: true 
 -- isConst: "inx " ObjectInvocation_Unary "inx: var integer " 
 -- isConst:DI: "inx: var integer " 
 -- updateOffset: "inx " E.ATd: "inx: var integer " 
 -- isConst: "< L " ObjectInvocation_Binary 
 --  <  : 
 --     %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  
 -- updateOffset: "< L " E.ATd: 
 --  <  : 
 --     %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  
 -- loadPathII:E: "inx " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "inx " 
 pushThis 
 -- items:goOrigin:encOG: "$59 "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $59$59 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$58 1
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "inx " 
 -- DI:loadAccessor: "inx " 
 -- DI:loadAccesor:loadPrimitive: "inx " 
 pushg 2 newInvoke
 -- loadPathII:E: "< L " 1 2 exps.range: 2 staticOff: 0 
 -- E: "< L " E:isPrimitiveIntWithFloatArg: false rec: "inx " 
 --  isFloat: false 
 -- NonVirt: "< L " "ObjectInvocation_Binary " ActArg: "L "isValue: 
 --  false formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "< L " isCompositeValueObj: false 
 -- OG:before:super.gen: "L "
 -- handleInv: "L " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "L " 
 --  "L " false 
 -- needOriginII: "L " 
 -- E: ObjectInvocation_Unary D: "L: var integer " 
 -- needOrigin: true "L " 
 -- exps.range: 1 exps[i]: "L " needOrigin: true 
 -- isConst: "L " ObjectInvocation_Unary "L: var integer " 
 -- isConst:DI: "L: var integer " 
 -- updateOffset: "L " E.ATd: "L: var integer " 
 -- loadPathII:E: "L " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "L " 
 pushThis 
 -- items:goOrigin:encOG: "$59 "on: 3 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $59$59 1
 -- items:goOrigin:encOG: "loop "on: 2 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$58 1
 -- items:goOrigin:encOG: "matchEq "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$54 1
 -- loadPathII:before:newInvoke: "L " true 
 -- checkForProxy:E: "L " isBasicValue: true origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "L " 
 -- DI:newInvoke: "L: var integer " off: 1 valueOff: 0 E: "L " 
 --  next: none isAdr: false 
 -- DI:newInvoke:loadPrimitive: "L " isAdr: false valueOff: 0 
 pushg 2 newInvoke
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "L ":isBasicVal: true 
 -- case:B: L ObjectGenerator 1 0 1 false false 
 -- isIntForFloatArg: "L " D: "in V: var integer " true false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "L " 
 --  B: false 
 --  "L: var integer " 
 -- end:loadArgs:NonVirt: "< L "
 -- loadPathII:before:newInvoke: "< L " true 
 -- checkForProxy:E: "< L " isBasicValue: false origin.isValueObj: 
 --  true staticOff: 0 rec: "inx " 
 -- checkForProxy:rec=None:localInvocation? "(inx < L) " E: "< L " 
 --  rec: "inx " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "< L " 
 -- ptn:newInvoke: "<   " staticOff: 0 
 -- gPTN:newInvoke: "<   " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: "inx " 
 -- checkInt2IntWithUnitArg:E: "< L " false false 
 lt
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  60   "$60 "
 invoke $60 60 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $60 60 1 $59 59
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "restart(loop) "
 -- handleInv: "restart(loop) " staticOff: 0 doLoad: true 
 --  useRtnVal: false 
 -- isPtnWithOrigin: "restart(loop) " 
 --  "restart(loop) " true 
 -- needOriginII: "restart(loop) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  
 -- needOrigin: true "restart(loop) " 
 -- exps.range: 1 exps[i]: "restart(loop) " needOrigin: true 
 -- isConst: "restart(loop) " ObjectInvocation_KeyWord 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  
 -- updateOffset: "restart(loop) " E.ATd: 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  
 -- loadPathII:E: "restart(loop) " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "restart(loop) " 
 -- loadPathII:before:newInvoke: "restart(loop) " true 
 -- checkForProxy:E: "restart(loop) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "restart(loop) " 
 -- ptn:newInvoke: "restart(V: var integer) " staticOff: 0 
 -- bPTN:newInvoke: "restart(V: var integer) " 
 break  2 1 58 0
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS doit 61 1 matchEq 54
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 --     Beq := c1 < c2
 --     leave(matchEq) "
 -- handleInv: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else staticOff: 0 doLoad: true useRtnVal: false 
 -- isPtnWithOrigin: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 --  
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else false 
 -- needOriginII: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 -- E: IfThenElse D: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- needOrigin: false 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 -- exps.range: 1 exps[i]: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else needOrigin: false 
 -- isConst: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else IfThenElse 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- noOrigin: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 -- loadPathII:E: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 1 1 exps.range: 1 staticOff: 0 
 -- loadPathII:before:newInvoke: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else true 
 -- checkForProxy:E: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else isBasicValue: false origin.isValueObj: false staticOff: 0 rec: 
 --  none 
 -- loadPathII:next: 1 1 
 -- IfThenElse:newInvoke: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 -- OG:before:super.gen: "(c1 = c2) "
 -- handleInv: "(c1 = c2) " staticOff: 0 doLoad: true useRtnVal: 
 --  true 
 -- isPtnWithOrigin: "(c1 = c2) " 
 --  "c1 " false "= c2 " true 
 -- needOriginII: "(c1 = c2) " 
 -- E: ObjectInvocation_Unary D: "c1: var char " 
 -- E: ObjectInvocation_Binary D: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- needOrigin: true "= c2 " 
 -- exps.range: 2 exps[i]: "c1 " exps[i]: "= c2 " needOrigin: true 
 -- isConst: "c1 " ObjectInvocation_Unary "c1: var char " 
 -- isConst:DI: "c1: var char " 
 -- updateOffset: "c1 " E.ATd: "c1: var char " 
 -- isConst: "= c2 " ObjectInvocation_Binary 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- updateOffset: "= c2 " E.ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- loadPathII:E: "c1 " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "c1 " 
 pushThis 
 -- items:goOrigin:encOG: "doit "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$61 1
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "c1 " 
 -- DI:loadAccessor: "c1 " 
 -- DI:loadAccesor:loadPrimitive: "c1 " 
 pushg 3 newInvoke
 -- loadPathII:E: "= c2 " 1 2 exps.range: 2 staticOff: 0 
 -- E: "= c2 " E:isPrimitiveIntWithFloatArg: false rec: "c1 " 
 --  isFloat: false 
 -- NonVirt: "= c2 " "ObjectInvocation_Binary " ActArg: "c2 "
 --  isValue: false formalArg: "in Veq: var this(Value) " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "= c2 " isCompositeValueObj: true 
 -- OG:before:super.gen: "c2 "
 -- handleInv: "c2 " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "c2 " 
 --  "c2 " false 
 -- needOriginII: "c2 " 
 -- E: ObjectInvocation_Unary D: "c2: var char " 
 -- needOrigin: true "c2 " 
 -- exps.range: 1 exps[i]: "c2 " needOrigin: true 
 -- isConst: "c2 " ObjectInvocation_Unary "c2: var char " 
 -- isConst:DI: "c2: var char " 
 -- updateOffset: "c2 " E.ATd: "c2: var char " 
 -- loadPathII:E: "c2 " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "c2 " 
 pushThis 
 -- items:goOrigin:encOG: "doit "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$61 1
 -- loadPathII:before:newInvoke: "c2 " true 
 -- checkForProxy:E: "c2 " isBasicValue: true origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "c2 " 
 -- DI:newInvoke: "c2: var char " off: 3 valueOff: 0 E: "c2 " 
 --  next: none isAdr: false 
 -- DI:newInvoke:loadPrimitive: "c2 " isAdr: false valueOff: 0 
 pushg 4 newInvoke
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- vEq: 
 -- end:loadArgs:NonVirt: "= c2 "
 -- loadPathII:before:newInvoke: "= c2 " true 
 -- checkForProxy:E: "= c2 " isBasicValue: true origin.isValueObj: 
 --  true staticOff: 0 rec: "c1 " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "= c2 " 
 -- ptn:newInvoke: "=   " staticOff: 0 
 -- gPTN:newInvoke: "=   " ptnKind: 1 staticOff: 0 valueOff: 0 
 --  rec: "c1 " 
 -- rec: "c1 " E: "= c2 " OGx.label: "ObjectGenerator "OGx: "char " 
 --  rec.ATd: "c1: var char " 
 -- bobs: 3 OGx: "char " 
 eq
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  62   "$62 "
 invoke $62 62 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L5
 L4:
 pushThis 
 -- before objTmpStack:add:  63   "$63 "
 invoke $63 63 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L5:
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $62 62 1 doit 61
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- handleAssign: "Beq := L1 <= L2 " 
 -- handleInv: "Beq " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "Beq " 
 --  "Beq " false 
 -- needOriginII: "Beq " 
 -- E: ObjectInvocation_Unary D: "out Beq: var boolean " 
 -- needOrigin: true "Beq " 
 -- exps.range: 1 exps[i]: "Beq " needOrigin: true 
 -- isConst: "Beq " ObjectInvocation_Unary "out Beq: var boolean " 
 -- isConst:DI: "out Beq: var boolean " 
 -- updateOffset: "Beq " E.ATd: "out Beq: var boolean " 
 -- loadPathII:E: "Beq " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "Beq " 
 pushThis 
 -- items:goOrigin:encOG: "$62 "on: 4 isValueObj: false 
 --  origin: doit origin:isValueObj: false 
 rpushg $62$62 1
 -- items:goOrigin:encOG: "doit "on: 3 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$61 1
 -- items:goOrigin:encOG: "matchEq "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$54 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$50 1
 -- loadPathII:before:newInvoke: "Beq " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "Beq := L1 <= L2 " leftE: "Beq " 
 -- OG:before:super.gen: "L1 <= L2 "
 -- handleInv: "L1 <= L2 " staticOff: 0 doLoad: true useRtnVal: 
 --  true 
 -- isPtnWithOrigin: "L1 <= L2 " 
 --  "L1 " false "<= L2 " true 
 -- needOriginII: "L1 <= L2 " 
 -- E: ObjectInvocation_Unary D: "L1: var integer " 
 -- E: ObjectInvocation_Binary D: 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- needOrigin: true "<= L2 " 
 -- exps.range: 2 exps[i]: "L1 " exps[i]: "<= L2 " needOrigin: true 
 -- isConst: "L1 " ObjectInvocation_Unary "L1: var integer " 
 -- isConst:DI: "L1: var integer " 
 -- updateOffset: "L1 " E.ATd: "L1: var integer " 
 -- isConst: "<= L2 " ObjectInvocation_Binary 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- updateOffset: "<= L2 " E.ATd: 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- loadPathII:E: "L1 " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "L1 " 
 pushThis 
 -- items:goOrigin:encOG: "$62 "on: 3 isValueObj: false 
 --  origin: doit origin:isValueObj: false 
 rpushg $62$62 1
 -- items:goOrigin:encOG: "doit "on: 2 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$61 1
 -- items:goOrigin:encOG: "matchEq "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$54 1
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "L1 " 
 -- DI:loadAccessor: "L1 " 
 -- DI:loadAccesor:loadPrimitive: "L1 " 
 pushg 3 newInvoke
 -- loadPathII:E: "<= L2 " 1 2 exps.range: 2 staticOff: 0 
 -- E: "<= L2 " E:isPrimitiveIntWithFloatArg: false rec: "L1 " 
 --  isFloat: false 
 -- NonVirt: "<= L2 " "ObjectInvocation_Binary " ActArg: "L2 "
 --  isValue: false formalArg: "in Veq: var this(Value) " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "<= L2 " isCompositeValueObj: true 
 -- OG:before:super.gen: "L2 "
 -- handleInv: "L2 " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "L2 " 
 --  "L2 " false 
 -- needOriginII: "L2 " 
 -- E: ObjectInvocation_Unary D: "L2: var integer " 
 -- needOrigin: true "L2 " 
 -- exps.range: 1 exps[i]: "L2 " needOrigin: true 
 -- isConst: "L2 " ObjectInvocation_Unary "L2: var integer " 
 -- isConst:DI: "L2: var integer " 
 -- updateOffset: "L2 " E.ATd: "L2: var integer " 
 -- loadPathII:E: "L2 " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "L2 " 
 pushThis 
 -- items:goOrigin:encOG: "$62 "on: 3 isValueObj: false 
 --  origin: doit origin:isValueObj: false 
 rpushg $62$62 1
 -- items:goOrigin:encOG: "doit "on: 2 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$61 1
 -- items:goOrigin:encOG: "matchEq "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$54 1
 -- loadPathII:before:newInvoke: "L2 " true 
 -- checkForProxy:E: "L2 " isBasicValue: true origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "L2 " 
 -- DI:newInvoke: "L2: var integer " off: 3 valueOff: 0 E: "L2 " 
 --  next: none isAdr: false 
 -- DI:newInvoke:loadPrimitive: "L2 " isAdr: false valueOff: 0 
 pushg 4 newInvoke
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- vEq: 
 -- end:loadArgs:NonVirt: "<= L2 "
 -- loadPathII:before:newInvoke: "<= L2 " true 
 -- checkForProxy:E: "<= L2 " isBasicValue: false origin.isValueObj: 
 --  true staticOff: 0 rec: "L1 " 
 -- checkForProxy:rec=None:localInvocation? "L1 <= L2 " E: "<= L2 " 
 --  rec: "L1 " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "<= L2 " 
 -- ptn:newInvoke: "<=   " staticOff: 0 
 -- gPTN:newInvoke: "<=   " ptnKind: 1 staticOff: 0 valueOff: 0 
 --  rec: "L1 " 
 -- rec: "L1 " E: "<= L2 " OGx.label: "ObjectGenerator "OGx: "
 --  integer " 
 --  rec.ATd: "L1: var integer " 
 -- bobs: 1 OGx: "integer " 
 le
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "Beq := L1 <= L2 " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- right:isPTN:not:valueObj: "out Beq: var boolean " 
 -- "<= L2 " 
 -- "<= L2 " 
 -- checkI2F2I: "Beq := L1 <= L2 " left.isFloat: false 
 --  right.isFloat: false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- "<= L2 " 
 -- "<= L2 " 
 -- Assign:end: "Beq := L1 <= L2 " isNotRemote: false qual: 
 --  value
 --     %id "Boolean"
 --     %globals inSub
 --     %basic 4, 8
 --  D: none 
 -- DI:newStore: "Beq " off: 3 valueOff: 0 dstE: "Beq " 
 --  isNotRemote: false originIsValueObj: false isUnitValueObj: false 
 --  rightQual:primNo: 4 rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 storeg Boolean$42 3
 -- OG:before:super.gen: "leave(matchEq) "
 -- handleInv: "leave(matchEq) " staticOff: 0 doLoad: true 
 --  useRtnVal: false 
 -- isPtnWithOrigin: "leave(matchEq) " 
 --  "leave(matchEq) " true 
 -- needOriginII: "leave(matchEq) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- needOrigin: true "leave(matchEq) " 
 -- exps.range: 1 exps[i]: "leave(matchEq) " needOrigin: true 
 -- isConst: "leave(matchEq) " ObjectInvocation_KeyWord 
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- updateOffset: "leave(matchEq) " E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- loadPathII:E: "leave(matchEq) " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "leave(matchEq) " 
 -- loadPathII:before:newInvoke: "leave(matchEq) " true 
 -- checkForProxy:E: "leave(matchEq) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "leave(matchEq) " 
 -- ptn:newInvoke: "leave(V: var integer) " staticOff: 0 
 -- bPTN:newInvoke: "leave(V: var integer) " 
 break  2 2 54 0
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $63 63 1 doit 61
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- handleAssign: "Beq := c1 < c2 " 
 -- handleInv: "Beq " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "Beq " 
 --  "Beq " false 
 -- needOriginII: "Beq " 
 -- E: ObjectInvocation_Unary D: "out Beq: var boolean " 
 -- needOrigin: true "Beq " 
 -- exps.range: 1 exps[i]: "Beq " needOrigin: true 
 -- isConst: "Beq " ObjectInvocation_Unary "out Beq: var boolean " 
 -- isConst:DI: "out Beq: var boolean " 
 -- updateOffset: "Beq " E.ATd: "out Beq: var boolean " 
 -- loadPathII:E: "Beq " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "Beq " 
 pushThis 
 -- items:goOrigin:encOG: "$63 "on: 4 isValueObj: false 
 --  origin: doit origin:isValueObj: false 
 rpushg $63$63 1
 -- items:goOrigin:encOG: "doit "on: 3 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$61 1
 -- items:goOrigin:encOG: "matchEq "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$54 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$50 1
 -- loadPathII:before:newInvoke: "Beq " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "Beq := c1 < c2 " leftE: "Beq " 
 -- OG:before:super.gen: "c1 < c2 "
 -- handleInv: "c1 < c2 " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "c1 < c2 " 
 --  "c1 " false "< c2 " true 
 -- needOriginII: "c1 < c2 " 
 -- E: ObjectInvocation_Unary D: "c1: var char " 
 -- E: ObjectInvocation_Binary D: 
 --  <  : 
 --     %basic 51
 --     in V: var char
 --     out B: var boolean
 --  
 -- needOrigin: true "< c2 " 
 -- exps.range: 2 exps[i]: "c1 " exps[i]: "< c2 " needOrigin: true 
 -- isConst: "c1 " ObjectInvocation_Unary "c1: var char " 
 -- isConst:DI: "c1: var char " 
 -- updateOffset: "c1 " E.ATd: "c1: var char " 
 -- isConst: "< c2 " ObjectInvocation_Binary 
 --  <  : 
 --     %basic 51
 --     in V: var char
 --     out B: var boolean
 --  
 -- updateOffset: "< c2 " E.ATd: 
 --  <  : 
 --     %basic 51
 --     in V: var char
 --     out B: var boolean
 --  
 -- loadPathII:E: "c1 " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "c1 " 
 pushThis 
 -- items:goOrigin:encOG: "$63 "on: 2 isValueObj: false 
 --  origin: doit origin:isValueObj: false 
 rpushg $63$63 1
 -- items:goOrigin:encOG: "doit "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$61 1
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "c1 " 
 -- DI:loadAccessor: "c1 " 
 -- DI:loadAccesor:loadPrimitive: "c1 " 
 pushg 3 newInvoke
 -- loadPathII:E: "< c2 " 1 2 exps.range: 2 staticOff: 0 
 -- E: "< c2 " E:isPrimitiveIntWithFloatArg: false rec: "c1 " 
 --  isFloat: false 
 -- NonVirt: "< c2 " "ObjectInvocation_Binary " ActArg: "c2 "
 --  isValue: false formalArg: "in V: var char " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "< c2 " isCompositeValueObj: false 
 -- OG:before:super.gen: "c2 "
 -- handleInv: "c2 " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "c2 " 
 --  "c2 " false 
 -- needOriginII: "c2 " 
 -- E: ObjectInvocation_Unary D: "c2: var char " 
 -- needOrigin: true "c2 " 
 -- exps.range: 1 exps[i]: "c2 " needOrigin: true 
 -- isConst: "c2 " ObjectInvocation_Unary "c2: var char " 
 -- isConst:DI: "c2: var char " 
 -- updateOffset: "c2 " E.ATd: "c2: var char " 
 -- loadPathII:E: "c2 " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "c2 " 
 pushThis 
 -- items:goOrigin:encOG: "$63 "on: 2 isValueObj: false 
 --  origin: doit origin:isValueObj: false 
 rpushg $63$63 1
 -- items:goOrigin:encOG: "doit "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$61 1
 -- loadPathII:before:newInvoke: "c2 " true 
 -- checkForProxy:E: "c2 " isBasicValue: true origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "c2 " 
 -- DI:newInvoke: "c2: var char " off: 3 valueOff: 0 E: "c2 " 
 --  next: none isAdr: false 
 -- DI:newInvoke:loadPrimitive: "c2 " isAdr: false valueOff: 0 
 pushg 4 newInvoke
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var char "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "c2 ":isBasicVal: true 
 -- case:B: c2 ObjectGenerator 3 0 3 false false 
 -- isIntForFloatArg: "c2 " D: "in V: var char " false false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "c2 " 
 --  B: false 
 --  "c2: var char " 
 -- end:loadArgs:NonVirt: "< c2 "
 -- loadPathII:before:newInvoke: "< c2 " true 
 -- checkForProxy:E: "< c2 " isBasicValue: false origin.isValueObj: 
 --  true staticOff: 0 rec: "c1 " 
 -- checkForProxy:rec=None:localInvocation? "c1 < c2 " E: "< c2 " 
 --  rec: "c1 " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "< c2 " 
 -- ptn:newInvoke: "<   " staticOff: 0 
 -- gPTN:newInvoke: "<   " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: "c1 " 
 -- checkInt2IntWithUnitArg:E: "< c2 " false false 
 lt
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "Beq := c1 < c2 " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- right:isPTN:not:valueObj: "out B: var boolean " 
 -- "< c2 " 
 -- "< c2 " 
 -- checkI2F2I: "Beq := c1 < c2 " left.isFloat: false right.isFloat: 
 --  false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- "< c2 " 
 -- "< c2 " 
 -- Assign:end: "Beq := c1 < c2 " isNotRemote: false qual: 
 --  value
 --     %id "Boolean"
 --     %globals inSub
 --     %basic 4, 8
 --  D: none 
 -- DI:newStore: "Beq " off: 3 valueOff: 0 dstE: "Beq " 
 --  isNotRemote: false originIsValueObj: false isUnitValueObj: false 
 --  rightQual:primNo: 4 rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 storeg Boolean$42 3
 -- OG:before:super.gen: "leave(matchEq) "
 -- handleInv: "leave(matchEq) " staticOff: 0 doLoad: true 
 --  useRtnVal: false 
 -- isPtnWithOrigin: "leave(matchEq) " 
 --  "leave(matchEq) " true 
 -- needOriginII: "leave(matchEq) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- needOrigin: true "leave(matchEq) " 
 -- exps.range: 1 exps[i]: "leave(matchEq) " needOrigin: true 
 -- isConst: "leave(matchEq) " ObjectInvocation_KeyWord 
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- updateOffset: "leave(matchEq) " E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- loadPathII:E: "leave(matchEq) " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "leave(matchEq) " 
 -- loadPathII:before:newInvoke: "leave(matchEq) " true 
 -- checkForProxy:E: "leave(matchEq) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "leave(matchEq) " 
 -- ptn:newInvoke: "leave(V: var integer) " staticOff: 0 
 -- bPTN:newInvoke: "leave(V: var integer) " 
 break  2 2 54 0
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS puttext 65 1 ConsoleIF 8
 pushThis 
 rstoreg  T 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(puttext) "
 -- handleInv: "inner(puttext) " staticOff: 0 doLoad: true 
 --  useRtnVal: false 
 -- isPtnWithOrigin: "inner(puttext) " 
 --  "inner(puttext) " true 
 -- needOriginII: "inner(puttext) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- needOrigin: true "inner(puttext) " 
 -- exps.range: 1 exps[i]: "inner(puttext) " needOrigin: true 
 -- isConst: "inner(puttext) " ObjectInvocation_KeyWord 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- updateOffset: "inner(puttext) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- loadPathII:E: "inner(puttext) " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "inner(puttext) " 
 -- loadPathII:before:newInvoke: "inner(puttext) " true 
 -- checkForProxy:E: "inner(puttext) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "inner(puttext) " 
 -- ptn:newInvoke: "inner " staticOff: 0 
 -- oPTN:newInvoke: "inner " 101 
 pushThis 
 innerP  2
 rpopThisObj 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS putint 66 1 ConsoleIF 8
 pushThis 
 storeg integer$5 2
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(putint) "
 -- handleInv: "inner(putint) " staticOff: 0 doLoad: true 
 --  useRtnVal: false 
 -- isPtnWithOrigin: "inner(putint) " 
 --  "inner(putint) " true 
 -- needOriginII: "inner(putint) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- needOrigin: true "inner(putint) " 
 -- exps.range: 1 exps[i]: "inner(putint) " needOrigin: true 
 -- isConst: "inner(putint) " ObjectInvocation_KeyWord 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- updateOffset: "inner(putint) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- loadPathII:E: "inner(putint) " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "inner(putint) " 
 -- loadPathII:before:newInvoke: "inner(putint) " true 
 -- checkForProxy:E: "inner(putint) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "inner(putint) " 
 -- ptn:newInvoke: "inner " staticOff: 0 
 -- oPTN:newInvoke: "inner " 101 
 pushThis 
 innerP  2
 rpopThisObj 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS OOPM 67 1 BETAworld 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "dummy: var integer " DI:isConst: false isBasicValue: 
 --  true primNo: 1 
 -- DI:gen:primitiveType: dummy 
 -- DI:gen: 
 --  console: obj 
 --     readString: 
 --        ch: var Char
 --        i: var integerDI:isConst: true isBasicValue: false primNo: 0 
 -- DI:isConst: console 
 -- DI:off: 3 this: 
 --  console: obj 
 --     readString: 
 --        ch: var Char
 --        i: var integer
 --  
 pushThis 
 -- before objTmpStack:add:  68   "console "
 invoke console 68 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  69   "GrammarLib "
 invoke GrammarLib 69 4 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS console 68 1 OOPM 67
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS GrammarLib 69 1 OOPM 67
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 pushThis 
 -- before objTmpStack:add:  70   "demo "
 invoke demo 70 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS demo 70 1 GrammarLib 69
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 pushThis 
 -- before objTmpStack:add:  145   "gTst "
 invoke gTst 145 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS Grammar 71 1 GrammarLib 69
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "nonTerminals: obj Set(#Nonterminal) " DI:isConst: true 
 --  isBasicValue: false primNo: 0 
 -- DI:isConst: nonTerminals 
 -- DI:off: 2 this: "nonTerminals: obj Set(#Nonterminal) " 
 --  
 -- before objTmpStack:add:  85   "nonTerminals "
 invoke nonTerminals 85 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- DI:gen: "terminals: obj Set(#Terminal) " DI:isConst: true 
 --  isBasicValue: false primNo: 0 
 -- DI:isConst: terminals 
 -- DI:off: 3 this: "terminals: obj Set(#Terminal) " 
 --  
 -- before objTmpStack:add:  88   "terminals "
 invoke terminals 88 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- DI:gen: "rules: obj OrderedList(#Rule) " DI:isConst: true 
 --  isBasicValue: false primNo: 0 
 -- DI:isConst: rules 
 -- DI:off: 4 this: "rules: obj OrderedList(#Rule) " 
 --  
 -- before objTmpStack:add:  95   "rules "
 invoke rules 95 4 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- DI:gen: "start: ref Nonterminal " DI:isConst: false 
 --  isBasicValue: false primNo: 0 
 -- DI:gen: "noOfRules: var integer " DI:isConst: false 
 --  isBasicValue: true primNo: 1 
 -- DI:gen:primitiveType: noOfRules 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(Grammar) "
 -- handleInv: "inner(Grammar) " staticOff: 0 doLoad: true 
 --  useRtnVal: false 
 -- isPtnWithOrigin: "inner(Grammar) " 
 --  "inner(Grammar) " true 
 -- needOriginII: "inner(Grammar) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- needOrigin: true "inner(Grammar) " 
 -- exps.range: 1 exps[i]: "inner(Grammar) " needOrigin: true 
 -- isConst: "inner(Grammar) " ObjectInvocation_KeyWord 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- updateOffset: "inner(Grammar) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- loadPathII:E: "inner(Grammar) " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "inner(Grammar) " 
 -- loadPathII:before:newInvoke: "inner(Grammar) " true 
 -- checkForProxy:E: "inner(Grammar) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "inner(Grammar) " 
 -- ptn:newInvoke: "inner " staticOff: 0 
 -- oPTN:newInvoke: "inner " 101 
 pushThis 
 innerP  3
 rpopThisObj 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:6 isIndexed:0

 CLASS Collection 80 0 Collections 38
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(Collection) "
 -- handleInv: "inner(Collection) " staticOff: 0 doLoad: true 
 --  useRtnVal: false 
 -- isPtnWithOrigin: "inner(Collection) " 
 --  "inner(Collection) " true 
 -- needOriginII: "inner(Collection) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- needOrigin: true "inner(Collection) " 
 -- exps.range: 1 exps[i]: "inner(Collection) " needOrigin: true 
 -- isConst: "inner(Collection) " ObjectInvocation_KeyWord 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- updateOffset: "inner(Collection) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- loadPathII:E: "inner(Collection) " 1 1 exps.range: 1 
 --  staticOff: 0 
 -- loadOriginII: "inner(Collection) " 
 -- loadPathII:before:newInvoke: "inner(Collection) " true 
 -- checkForProxy:E: "inner(Collection) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "inner(Collection) " 
 -- ptn:newInvoke: "inner " staticOff: 0 
 -- oPTN:newInvoke: "inner " 101 
 pushThis 
 innerP  9
 rpopThisObj 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:0 isIndexed:0

 CLASS insert 74 1 Collection 80
 pushThis 
 rstoreg  e 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in e: ref elm " DI:isConst: false isBasicValue: false 
 --  primNo: 0 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(insert) "
 -- handleInv: "inner(insert) " staticOff: 0 doLoad: true 
 --  useRtnVal: false 
 -- isPtnWithOrigin: "inner(insert) " 
 --  "inner(insert) " true 
 -- needOriginII: "inner(insert) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- needOrigin: true "inner(insert) " 
 -- exps.range: 1 exps[i]: "inner(insert) " needOrigin: true 
 -- isConst: "inner(insert) " ObjectInvocation_KeyWord 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- updateOffset: "inner(insert) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- loadPathII:E: "inner(insert) " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "inner(insert) " 
 -- loadPathII:before:newInvoke: "inner(insert) " true 
 -- checkForProxy:E: "inner(insert) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "inner(insert) " 
 -- ptn:newInvoke: "inner " staticOff: 0 
 -- oPTN:newInvoke: "inner " 101 
 pushThis 
 innerP  2
 rpopThisObj 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS has 96 1 Collection 80
 pushThis 
 rstoreg  E 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in E: ref elm " DI:isConst: false isBasicValue: false 
 --  primNo: 0 
 -- DI:gen: "out B: var boolean " DI:isConst: false isBasicValue: 
 --  true primNo: 4 
 -- DI:gen:primitiveType: B 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(has) "
 -- handleInv: "inner(has) " staticOff: 0 doLoad: true useRtnVal: 
 --  false 
 -- isPtnWithOrigin: "inner(has) " 
 --  "inner(has) " true 
 -- needOriginII: "inner(has) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- needOrigin: true "inner(has) " 
 -- exps.range: 1 exps[i]: "inner(has) " needOrigin: true 
 -- isConst: "inner(has) " ObjectInvocation_KeyWord 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- updateOffset: "inner(has) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- loadPathII:E: "inner(has) " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "inner(has) " 
 -- loadPathII:before:newInvoke: "inner(has) " true 
 -- checkForProxy:E: "inner(has) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "inner(has) " 
 -- ptn:newInvoke: "inner " staticOff: 0 
 -- oPTN:newInvoke: "inner " 101 
 pushThis 
 innerP  2
 rpopThisObj 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS remove 97 1 Collection 80
 pushThis 
 rstoreg  E 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in E: ref elm " DI:isConst: false isBasicValue: false 
 --  primNo: 0 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(remove) "
 -- handleInv: "inner(remove) " staticOff: 0 doLoad: true 
 --  useRtnVal: false 
 -- isPtnWithOrigin: "inner(remove) " 
 --  "inner(remove) " true 
 -- needOriginII: "inner(remove) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- needOrigin: true "inner(remove) " 
 -- exps.range: 1 exps[i]: "inner(remove) " needOrigin: true 
 -- isConst: "inner(remove) " ObjectInvocation_KeyWord 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- updateOffset: "inner(remove) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- loadPathII:E: "inner(remove) " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "inner(remove) " 
 -- loadPathII:before:newInvoke: "inner(remove) " true 
 -- checkForProxy:E: "inner(remove) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "inner(remove) " 
 -- ptn:newInvoke: "inner " staticOff: 0 
 -- oPTN:newInvoke: "inner " 101 
 pushThis 
 innerP  2
 rpopThisObj 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS isEmpty 98 1 Collection 80
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(isEmpty) "
 -- handleInv: "inner(isEmpty) " staticOff: 0 doLoad: true 
 --  useRtnVal: false 
 -- isPtnWithOrigin: "inner(isEmpty) " 
 --  "inner(isEmpty) " true 
 -- needOriginII: "inner(isEmpty) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- needOrigin: true "inner(isEmpty) " 
 -- exps.range: 1 exps[i]: "inner(isEmpty) " needOrigin: true 
 -- isConst: "inner(isEmpty) " ObjectInvocation_KeyWord 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- updateOffset: "inner(isEmpty) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- loadPathII:E: "inner(isEmpty) " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "inner(isEmpty) " 
 -- loadPathII:before:newInvoke: "inner(isEmpty) " true 
 -- checkForProxy:E: "inner(isEmpty) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "inner(isEmpty) " 
 -- ptn:newInvoke: "inner " staticOff: 0 
 -- oPTN:newInvoke: "inner " 101 
 pushThis 
 innerP  2
 rpopThisObj 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS size 99 1 Collection 80
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(size) "
 -- handleInv: "inner(size) " staticOff: 0 doLoad: true useRtnVal: 
 --  false 
 -- isPtnWithOrigin: "inner(size) " 
 --  "inner(size) " true 
 -- needOriginII: "inner(size) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- needOrigin: true "inner(size) " 
 -- exps.range: 1 exps[i]: "inner(size) " needOrigin: true 
 -- isConst: "inner(size) " ObjectInvocation_KeyWord 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- updateOffset: "inner(size) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- loadPathII:E: "inner(size) " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "inner(size) " 
 -- loadPathII:before:newInvoke: "inner(size) " true 
 -- checkForProxy:E: "inner(size) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "inner(size) " 
 -- ptn:newInvoke: "inner " staticOff: 0 
 -- oPTN:newInvoke: "inner " 101 
 pushThis 
 innerP  2
 rpopThisObj 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS clear 100 1 Collection 80
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(clear) "
 -- handleInv: "inner(clear) " staticOff: 0 doLoad: true useRtnVal: 
 --  false 
 -- isPtnWithOrigin: "inner(clear) " 
 --  "inner(clear) " true 
 -- needOriginII: "inner(clear) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- needOrigin: true "inner(clear) " 
 -- exps.range: 1 exps[i]: "inner(clear) " needOrigin: true 
 -- isConst: "inner(clear) " ObjectInvocation_KeyWord 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- updateOffset: "inner(clear) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- loadPathII:E: "inner(clear) " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "inner(clear) " 
 -- loadPathII:before:newInvoke: "inner(clear) " true 
 -- checkForProxy:E: "inner(clear) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "inner(clear) " 
 -- ptn:newInvoke: "inner " staticOff: 0 
 -- oPTN:newInvoke: "inner " 101 
 pushThis 
 innerP  2
 rpopThisObj 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS Set 83 0 SetLib 40
 -- vdtTableCopy: I:1:80 V:2:0 V:3:74 V:4:96 V:5:97 V:6:98 V:7:99 V:8:100 I:9:0
 -- super Collection
 allocEventQ
 -- DI:gen: "head: ref link " DI:isConst: false isBasicValue: false 
 --  primNo: 0 
 rtnAlloc 1
 toSuper 80
DO:
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(Set) "
 -- handleInv: "inner(Set) " staticOff: 0 doLoad: true useRtnVal: 
 --  false 
 -- isPtnWithOrigin: "inner(Set) " 
 --  "inner(Set) " true 
 -- needOriginII: "inner(Set) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- needOrigin: true "inner(Set) " 
 -- exps.range: 1 exps[i]: "inner(Set) " needOrigin: true 
 -- isConst: "inner(Set) " ObjectInvocation_KeyWord 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- updateOffset: "inner(Set) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- loadPathII:E: "inner(Set) " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "inner(Set) " 
 -- loadPathII:before:newInvoke: "inner(Set) " true 
 -- checkForProxy:E: "inner(Set) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "inner(Set) " 
 -- ptn:newInvoke: "inner " staticOff: 0 
 -- oPTN:newInvoke: "inner " 101 
 pushThis 
 innerP  10
 rpopThisObj 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0

 CLASS has 101 1 Set 83
 -- vdtTableCopy: I:1:96 I:2:0
 rShiftUp  1
 tstOriginIsNone 
 rstore  1 origin
 -- super has
 pushThis 
 rpushg iOrigin 1
 rShiftDown  1
 pushThis 
 rstoreg  E 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- DI:gen: "in E: ref elm " DI:isConst: false isBasicValue: false 
 --  primNo: 0 
 -- DI:gen: "out B: var boolean " DI:isConst: false isBasicValue: 
 --  true primNo: 4 
 -- DI:gen:primitiveType: B 
 rtnAlloc 1
 toSuper 96
DO:
 mvStack 
 L1:
 -- handleAssign: "B := false " 
 -- handleInv: "B " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "B " 
 --  "B " false 
 -- needOriginII: "B " 
 -- E: ObjectInvocation_Unary D: "out B: var boolean " 
 -- needOrigin: true "B " 
 -- exps.range: 1 exps[i]: "B " needOrigin: true 
 -- isConst: "B " ObjectInvocation_Unary "out B: var boolean " 
 -- isConst:DI: "out B: var boolean " 
 -- updateOffset: "B " E.ATd: "out B: var boolean " 
 -- loadPathII:E: "B " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "B " 
 pushThis 
 -- loadPathII:before:newInvoke: "B " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "B := false " leftE: "B " 
 -- OG:before:super.gen: "false "
 -- handleInv: "false " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "false " 
 --  "false " false 
 -- needOriginII: "false " 
 -- E: ObjectInvocation_Unary D: 
 --  False: 
 --     %globals
 --     out B: var boolean
 --     B := 0
 --  
 -- needOrigin: false "false " 
 -- exps.range: 1 exps[i]: "false " needOrigin: false 
 -- isConst: "false " ObjectInvocation_Unary 
 --  False: 
 --     %globals
 --     out B: var boolean
 --     B := 0
 --  
 -- noOrigin: "false " 
 -- loadPathII:E: "false " 1 1 exps.range: 1 staticOff: 0 
 -- loadPathII:before:newInvoke: "false " true 
 -- checkForProxy:E: "false " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "false " 
 -- ptn:newInvoke: "False " staticOff: 0 
 -- gPTN:newInvoke: "False " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: none 
 -- invoke:nonVirtual: "False " isAdr: false 
 invoke False 27 0 0
 -- global:pushOut: B off: 1 
 pushg 1 
 -- callInvoke:after:pushOut: 1 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "B := false " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- right:isPTN:not:valueObj: "out B: var boolean " 
 -- checkI2F2I: "B := false " left.isFloat: false right.isFloat: 
 --  false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- Assign:end: "B := false " isNotRemote: false qual: 
 --  value
 --     %id "Boolean"
 --     %globals inSub
 --     %basic 4, 8
 --  D: none 
 -- DI:newStore: "B " off: 3 valueOff: 0 dstE: "B " isNotRemote: 
 --  false originIsValueObj: false isUnitValueObj: false rightQual:primNo: 4 
 --  rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 storeg Boolean$42 3
 pushThis 
 -- before objTmpStack:add:  103   "scan$103 "
 invoke scan$103 103 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 rtnInner  M
 END OSDV:0 objSize:3 isIndexed:0

 CLASS scan 102 1 Set 83
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "current: ref elm " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 -- DI:gen: "nxt: ref link " DI:isConst: false isBasicValue: false 
 --  primNo: 0 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- handleAssign: "nxt := head " 
 -- handleInv: "nxt " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "nxt " 
 --  "nxt " false 
 -- needOriginII: "nxt " 
 -- E: ObjectInvocation_Unary D: "nxt: ref link " 
 -- needOrigin: true "nxt " 
 -- exps.range: 1 exps[i]: "nxt " needOrigin: true 
 -- isConst: "nxt " ObjectInvocation_Unary "nxt: ref link " 
 -- isConst:DI: "nxt: ref link " 
 -- updateOffset: "nxt " E.ATd: "nxt: ref link " 
 -- loadPathII:E: "nxt " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "nxt " 
 pushThis 
 -- loadPathII:before:newInvoke: "nxt " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "nxt := head " leftE: "nxt " 
 -- OG:before:super.gen: "head "
 -- handleInv: "head " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "head " 
 --  "head " false 
 -- needOriginII: "head " 
 -- E: ObjectInvocation_Unary D: "head: ref link " 
 -- needOrigin: true "head " 
 -- exps.range: 1 exps[i]: "head " needOrigin: true 
 -- isConst: "head " ObjectInvocation_Unary "head: ref link " 
 -- isConst:DI: "head: ref link " 
 -- updateOffset: "head " E.ATd: "head: ref link " 
 -- loadPathII:E: "head " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "head " 
 pushThis 
 -- items:goOrigin:encOG: "scan "on: 1 isValueObj: false 
 --  origin: Set origin:isValueObj: false 
 rpushg scan$102 1
 -- loadPathII:before:newInvoke: "head " true 
 -- checkForProxy:E: "head " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "head " 
 -- DI:newInvoke: "head: ref link " off: 1 valueOff: 0 E: "head " 
 --  next: none isAdr: false 
 -- DI:newInvoke:loadObj: "head: ref link " 
 rpushg newInvoke 1
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "nxt := head " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- checkI2F2I: "nxt := head " left.isFloat: false right.isFloat: 
 --  false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- Assign:end: "nxt := head " isNotRemote: false qual: 
 --  in e: ref elm
 --     in next: ref link
 --  
 --  D: none 
 -- DI:newStore: "nxt " off: 3 valueOff: 0 dstE: "nxt " 
 --  isNotRemote: false originIsValueObj: false isUnitValueObj: false 
 --  rightQual:primNo: 0 rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 -- DI:newStore:ref/String: "nxt: ref link " 
 rswap 0
 rstoreg  link$78 3
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 pushThis 
 -- before objTmpStack:add:  107   "Loop "
 invoke Loop 107 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:1 objSize:3 isIndexed:0

 CLASS link 78 1 Set 83
 pushThis 
 rstoreg  next 3
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 pushThis 
 rstoreg  e 2
   ;; vTop(0,0)=[] rTop(-4,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in e: ref elm " DI:isConst: false isBasicValue: false 
 --  primNo: 0 
 -- DI:gen: "in next: ref link " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS Loop 107 1 scan 102
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "
 --  if (nxt =/= none) :then 
 --     current := nxt.e
 --     inner(scan)
 --     nxt := nxt.next
 --     restart(Loop)
 --  :else 
 --     nxt := nxt "
 -- handleInv: 
 --  if (nxt =/= none) :then 
 --     current := nxt.e
 --     inner(scan)
 --     nxt := nxt.nextstaticOff: 0 doLoad: true useRtnVal: false 
 -- isPtnWithOrigin: 
 --  if (nxt =/= none) :then 
 --     current := nxt.e
 --     inner(scan)
 --     nxt := nxt.next
 --  
 --  if (nxt =/= none) :then 
 --     current := nxt.e
 --     inner(scan)
 --     nxt := nxt.nextfalse 
 -- needOriginII: 
 --  if (nxt =/= none) :then 
 --     current := nxt.e
 --     inner(scan)
 --     nxt := nxt.next
 -- E: IfThenElse D: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- needOrigin: false 
 --  if (nxt =/= none) :then 
 --     current := nxt.e
 --     inner(scan)
 --     nxt := nxt.next
 -- exps.range: 1 exps[i]: 
 --  if (nxt =/= none) :then 
 --     current := nxt.e
 --     inner(scan)
 --     nxt := nxt.nextneedOrigin: false 
 -- isConst: 
 --  if (nxt =/= none) :then 
 --     current := nxt.e
 --     inner(scan)
 --     nxt := nxt.nextIfThenElse 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- noOrigin: 
 --  if (nxt =/= none) :then 
 --     current := nxt.e
 --     inner(scan)
 --     nxt := nxt.next
 -- loadPathII:E: 
 --  if (nxt =/= none) :then 
 --     current := nxt.e
 --     inner(scan)
 --     nxt := nxt.next1 1 exps.range: 1 staticOff: 0 
 -- loadPathII:before:newInvoke: 
 --  if (nxt =/= none) :then 
 --     current := nxt.e
 --     inner(scan)
 --     nxt := nxt.nexttrue 
 -- checkForProxy:E: 
 --  if (nxt =/= none) :then 
 --     current := nxt.e
 --     inner(scan)
 --     nxt := nxt.nextisBasicValue: false origin.isValueObj: false staticOff: 0 rec: 
 --  none 
 -- loadPathII:next: 1 1 
 -- IfThenElse:newInvoke: 
 --  if (nxt =/= none) :then 
 --     current := nxt.e
 --     inner(scan)
 --     nxt := nxt.next
 -- OG:before:super.gen: "(nxt =/= none) "
 -- handleInv: "(nxt =/= none) " staticOff: 0 doLoad: true 
 --  useRtnVal: true 
 -- isPtnWithOrigin: "(nxt =/= none) " 
 --  "nxt " false "=/= none " true 
 -- needOriginII: "(nxt =/= none) " 
 -- E: ObjectInvocation_Unary D: "nxt: ref link " 
 -- E: ObjectInvocation_Binary D: 
 --  =/=  : 
 --     %basic 57
 --     in objx: ref Object
 --     out V: var boolean
 --  
 -- needOrigin: true "=/= none " 
 -- exps.range: 2 exps[i]: "nxt " exps[i]: "=/= none " needOrigin: 
 --  true 
 -- isConst: "nxt " ObjectInvocation_Unary "nxt: ref link " 
 -- isConst:DI: "nxt: ref link " 
 -- updateOffset: "nxt " E.ATd: "nxt: ref link " 
 -- isConst: "=/= none " ObjectInvocation_Binary 
 --  =/=  : 
 --     %basic 57
 --     in objx: ref Object
 --     out V: var boolean
 --  
 -- updateOffset: "=/= none " E.ATd: 
 --  =/=  : 
 --     %basic 57
 --     in objx: ref Object
 --     out V: var boolean
 --  
 -- loadPathII:E: "nxt " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "nxt " 
 pushThis 
 -- items:goOrigin:encOG: "Loop "on: 1 isValueObj: false 
 --  origin: scan origin:isValueObj: false 
 rpushg Loop$107 1
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "nxt " 
 -- DI:loadAccessor: "nxt " 
 -- DI:loadAccessor:Obj: "nxt: ref link " 
 rpushg newInvoke 3
 -- loadPathII:E: "=/= none " 1 2 exps.range: 2 staticOff: 0 
 -- E: "=/= none " E:isPrimitiveIntWithFloatArg: false rec: "nxt " 
 --  isFloat: false 
 -- NonVirt: "=/= none " "ObjectInvocation_Binary " ActArg: "none "
 --  isValue: false formalArg: "in objx: ref Object " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "=/= none " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "none "
 -- handleInv: "none " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "none " 
 --  "none " true 
 -- needOriginII: "none " 
 -- E: ObjectInvocation_Unary D: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  
 -- needOrigin: true "none " 
 -- exps.range: 1 exps[i]: "none " needOrigin: true 
 -- isConst: "none " ObjectInvocation_Unary 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  
 -- updateOffset: "none " E.ATd: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  
 -- loadPathII:E: "none " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "none " 
 -- loadPathII:before:newInvoke: "none " true 
 -- checkForProxy:E: "none " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "none " 
 -- ptn:newInvoke: "none " staticOff: 0 
 -- oPTN:newInvoke: "none " 19 
 pushNone 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: true formalArg:isPtn: "in objx: ref Object "
 --  :isBasicVal: false :valueObj: false 
 --  :actArg: "none ":isBasicVal: false 
 -- case:B: none ObjectGenerator 64 19 19 false false 
 -- isIntForFloatArg: "none " D: "in objx: ref Object " false false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "none " false 
 --  B: false 
 --  
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  
 -- end:loadArgs:NonVirt: "=/= none "
 -- loadPathII:before:newInvoke: "=/= none " true 
 -- checkForProxy:E: "=/= none " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: "nxt " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "=/= none " 
 -- ptn:newInvoke: "=/=   " staticOff: 0 
 -- gPTN:newInvoke: "=/=   " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: "nxt " 
 -- checkInt2IntWithUnitArg:E: "=/= none " false false 
 rne
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  110   "$110 "
 invoke $110 110 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L5
 L4:
 pushThis 
 -- before objTmpStack:add:  111   "$111 "
 invoke $111 111 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L5:
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $110 110 1 Loop 107
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- handleAssign: "current := nxt.e " 
 -- handleInv: "current " staticOff: 0 doLoad: false useRtnVal: 
 --  false 
 -- isPtnWithOrigin: "current " 
 --  "current " false 
 -- needOriginII: "current " 
 -- E: ObjectInvocation_Unary D: "current: ref elm " 
 -- needOrigin: true "current " 
 -- exps.range: 1 exps[i]: "current " needOrigin: true 
 -- isConst: "current " ObjectInvocation_Unary "current: ref elm " 
 -- isConst:DI: "current: ref elm " 
 -- updateOffset: "current " E.ATd: "current: ref elm " 
 -- loadPathII:E: "current " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "current " 
 pushThis 
 -- items:goOrigin:encOG: "$110 "on: 2 isValueObj: false 
 --  origin: Loop origin:isValueObj: false 
 rpushg $110$110 1
 -- items:goOrigin:encOG: "Loop "on: 1 isValueObj: false 
 --  origin: scan origin:isValueObj: false 
 rpushg Loop$107 1
 -- loadPathII:before:newInvoke: "current " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "current := nxt.e " leftE: "current " 
 -- OG:before:super.gen: "nxt.e "
 -- handleInv: "nxt.e " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "nxt.e " 
 --  "nxt " false "e " false 
 -- needOriginII: "nxt.e " 
 -- E: ObjectInvocation_Unary D: "nxt: ref link " 
 -- E: ObjectInvocation_Unary D: "in e: ref elm " 
 -- needOrigin: true "e " 
 -- exps.range: 2 exps[i]: "nxt " exps[i]: "e " needOrigin: true 
 -- isConst: "nxt " ObjectInvocation_Unary "nxt: ref link " 
 -- isConst:DI: "nxt: ref link " 
 -- updateOffset: "nxt " E.ATd: "nxt: ref link " 
 -- isConst: "e " ObjectInvocation_Unary "in e: ref elm " 
 -- isConst:DI: "in e: ref elm " 
 -- updateOffset: "e " E.ATd: "in e: ref elm " 
 -- loadPathII:E: "nxt " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "nxt " 
 pushThis 
 -- items:goOrigin:encOG: "$110 "on: 2 isValueObj: false 
 --  origin: Loop origin:isValueObj: false 
 rpushg $110$110 1
 -- items:goOrigin:encOG: "Loop "on: 1 isValueObj: false 
 --  origin: scan origin:isValueObj: false 
 rpushg Loop$107 1
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "nxt " 
 -- DI:loadAccessor: "nxt " 
 -- DI:loadAccessor:Obj: "nxt: ref link " 
 rpushg newInvoke 3
 -- loadPathII:E: "e " 1 2 exps.range: 2 staticOff: 0 
 -- E: "e " E:isPrimitiveIntWithFloatArg: false rec: "nxt " isFloat: 
 --  false 
 -- loadPathII:before:newInvoke: "e " true 
 -- checkForProxy:E: "e " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: "nxt " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "e " 
 -- DI:newInvoke: "in e: ref elm " off: 2 valueOff: 0 E: "e " 
 --  next: none isAdr: false 
 -- DI:newInvoke:loadObj: "in e: ref elm " 
 rpushg newInvoke 2
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "current := nxt.e " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- "e " 
 -- "e " 
 -- checkI2F2I: "current := nxt.e " left.isFloat: false 
 --  right.isFloat: false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- "e " 
 -- "e " 
 -- Assign:end: "current := nxt.e " isNotRemote: false qual: 
 --  %ID Object
 --     %basic 64
 --     %public
 --     ==  : 
 --  D: none 
 -- DI:newStore: "current " off: 2 valueOff: 0 dstE: "current " 
 --  isNotRemote: false originIsValueObj: false isUnitValueObj: false 
 --  rightQual:primNo: 64 rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 -- DI:newStore:ref/String: "current: ref elm " 
 rswap 0
 rstoreg  Object$0 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- OG:before:super.gen: "inner(scan) "
 -- handleInv: "inner(scan) " staticOff: 0 doLoad: true useRtnVal: 
 --  false 
 -- isPtnWithOrigin: "inner(scan) " 
 --  "inner(scan) " true 
 -- needOriginII: "inner(scan) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- needOrigin: true "inner(scan) " 
 -- exps.range: 1 exps[i]: "inner(scan) " needOrigin: true 
 -- isConst: "inner(scan) " ObjectInvocation_KeyWord 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- updateOffset: "inner(scan) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- loadPathII:E: "inner(scan) " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "inner(scan) " 
 -- loadPathII:before:newInvoke: "inner(scan) " true 
 -- checkForProxy:E: "inner(scan) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "inner(scan) " 
 -- ptn:newInvoke: "inner " staticOff: 0 
 -- oPTN:newInvoke: "inner " 101 
 pushThis 
 -- items:goOrigin:encOG: "$110 "on: 2 isValueObj: false 
 --  origin: Loop origin:isValueObj: false 
 rpushg $110$110 1
 -- items:goOrigin:encOG: "Loop "on: 1 isValueObj: false 
 --  origin: scan origin:isValueObj: false 
 rpushg Loop$107 1
 innerP  2
 rpopThisObj 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign: "nxt := nxt.next " 
 -- handleInv: "nxt " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "nxt " 
 --  "nxt " false 
 -- needOriginII: "nxt " 
 -- E: ObjectInvocation_Unary D: "nxt: ref link " 
 -- needOrigin: true "nxt " 
 -- exps.range: 1 exps[i]: "nxt " needOrigin: true 
 -- isConst: "nxt " ObjectInvocation_Unary "nxt: ref link " 
 -- isConst:DI: "nxt: ref link " 
 -- updateOffset: "nxt " E.ATd: "nxt: ref link " 
 -- loadPathII:E: "nxt " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "nxt " 
 pushThis 
 -- items:goOrigin:encOG: "$110 "on: 2 isValueObj: false 
 --  origin: Loop origin:isValueObj: false 
 rpushg $110$110 1
 -- items:goOrigin:encOG: "Loop "on: 1 isValueObj: false 
 --  origin: scan origin:isValueObj: false 
 rpushg Loop$107 1
 -- loadPathII:before:newInvoke: "nxt " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "nxt := nxt.next " leftE: "nxt " 
 -- OG:before:super.gen: "nxt.next "
 -- handleInv: "nxt.next " staticOff: 0 doLoad: true useRtnVal: 
 --  true 
 -- isPtnWithOrigin: "nxt.next " 
 --  "nxt " false "next " false 
 -- needOriginII: "nxt.next " 
 -- E: ObjectInvocation_Unary D: "nxt: ref link " 
 -- E: ObjectInvocation_Unary D: "in next: ref link " 
 -- needOrigin: true "next " 
 -- exps.range: 2 exps[i]: "nxt " exps[i]: "next " needOrigin: true 
 -- isConst: "nxt " ObjectInvocation_Unary "nxt: ref link " 
 -- isConst:DI: "nxt: ref link " 
 -- updateOffset: "nxt " E.ATd: "nxt: ref link " 
 -- isConst: "next " ObjectInvocation_Unary "in next: ref link " 
 -- isConst:DI: "in next: ref link " 
 -- updateOffset: "next " E.ATd: "in next: ref link " 
 -- loadPathII:E: "nxt " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "nxt " 
 pushThis 
 -- items:goOrigin:encOG: "$110 "on: 2 isValueObj: false 
 --  origin: Loop origin:isValueObj: false 
 rpushg $110$110 1
 -- items:goOrigin:encOG: "Loop "on: 1 isValueObj: false 
 --  origin: scan origin:isValueObj: false 
 rpushg Loop$107 1
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "nxt " 
 -- DI:loadAccessor: "nxt " 
 -- DI:loadAccessor:Obj: "nxt: ref link " 
 rpushg newInvoke 3
 -- loadPathII:E: "next " 1 2 exps.range: 2 staticOff: 0 
 -- E: "next " E:isPrimitiveIntWithFloatArg: false rec: "nxt " 
 --  isFloat: false 
 -- loadPathII:before:newInvoke: "next " true 
 -- checkForProxy:E: "next " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: "nxt " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "next " 
 -- DI:newInvoke: "in next: ref link " off: 3 valueOff: 0 E: "
 --  next " next: none isAdr: false 
 -- DI:newInvoke:loadObj: "in next: ref link " 
 rpushg newInvoke 3
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "nxt := nxt.next " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- "next " 
 -- "next " 
 -- checkI2F2I: "nxt := nxt.next " left.isFloat: false 
 --  right.isFloat: false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- "next " 
 -- "next " 
 -- Assign:end: "nxt := nxt.next " isNotRemote: false qual: 
 --  in e: ref elm
 --     in next: ref link
 --  
 --  D: none 
 -- DI:newStore: "nxt " off: 3 valueOff: 0 dstE: "nxt " 
 --  isNotRemote: false originIsValueObj: false isUnitValueObj: false 
 --  rightQual:primNo: 0 rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 -- DI:newStore:ref/String: "nxt: ref link " 
 rswap 0
 rstoreg  link$78 3
   ;; vTop(0,0)=[] rTop(-4,0)=[]
 -- OG:before:super.gen: "restart(Loop) "
 -- handleInv: "restart(Loop) " staticOff: 0 doLoad: true 
 --  useRtnVal: false 
 -- isPtnWithOrigin: "restart(Loop) " 
 --  "restart(Loop) " true 
 -- needOriginII: "restart(Loop) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  
 -- needOrigin: true "restart(Loop) " 
 -- exps.range: 1 exps[i]: "restart(Loop) " needOrigin: true 
 -- isConst: "restart(Loop) " ObjectInvocation_KeyWord 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  
 -- updateOffset: "restart(Loop) " E.ATd: 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  
 -- loadPathII:E: "restart(Loop) " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "restart(Loop) " 
 -- loadPathII:before:newInvoke: "restart(Loop) " true 
 -- checkForProxy:E: "restart(Loop) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "restart(Loop) " 
 -- ptn:newInvoke: "restart(V: var integer) " staticOff: 0 
 -- bPTN:newInvoke: "restart(V: var integer) " 
 break  1 1 107 0
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $111 111 1 Loop 107
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- handleAssign: "nxt := nxt " 
 -- handleInv: "nxt " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "nxt " 
 --  "nxt " false 
 -- needOriginII: "nxt " 
 -- E: ObjectInvocation_Unary D: "nxt: ref link " 
 -- needOrigin: true "nxt " 
 -- exps.range: 1 exps[i]: "nxt " needOrigin: true 
 -- isConst: "nxt " ObjectInvocation_Unary "nxt: ref link " 
 -- isConst:DI: "nxt: ref link " 
 -- updateOffset: "nxt " E.ATd: "nxt: ref link " 
 -- loadPathII:E: "nxt " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "nxt " 
 pushThis 
 -- items:goOrigin:encOG: "$111 "on: 2 isValueObj: false 
 --  origin: Loop origin:isValueObj: false 
 rpushg $111$111 1
 -- items:goOrigin:encOG: "Loop "on: 1 isValueObj: false 
 --  origin: scan origin:isValueObj: false 
 rpushg Loop$107 1
 -- loadPathII:before:newInvoke: "nxt " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "nxt := nxt " leftE: "nxt " 
 -- OG:before:super.gen: "nxt "
 -- handleInv: "nxt " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "nxt " 
 --  "nxt " false 
 -- needOriginII: "nxt " 
 -- E: ObjectInvocation_Unary D: "nxt: ref link " 
 -- needOrigin: true "nxt " 
 -- exps.range: 1 exps[i]: "nxt " needOrigin: true 
 -- isConst: "nxt " ObjectInvocation_Unary "nxt: ref link " 
 -- isConst:DI: "nxt: ref link " 
 -- updateOffset: "nxt " E.ATd: "nxt: ref link " 
 -- loadPathII:E: "nxt " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "nxt " 
 pushThis 
 -- items:goOrigin:encOG: "$111 "on: 2 isValueObj: false 
 --  origin: Loop origin:isValueObj: false 
 rpushg $111$111 1
 -- items:goOrigin:encOG: "Loop "on: 1 isValueObj: false 
 --  origin: scan origin:isValueObj: false 
 rpushg Loop$107 1
 -- loadPathII:before:newInvoke: "nxt " true 
 -- checkForProxy:E: "nxt " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "nxt " 
 -- DI:newInvoke: "nxt: ref link " off: 3 valueOff: 0 E: "nxt " 
 --  next: none isAdr: false 
 -- DI:newInvoke:loadObj: "nxt: ref link " 
 rpushg newInvoke 3
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "nxt := nxt " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- checkI2F2I: "nxt := nxt " left.isFloat: false right.isFloat: 
 --  false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- Assign:end: "nxt := nxt " isNotRemote: false qual: 
 --  in e: ref elm
 --     in next: ref link
 --  
 --  D: none 
 -- DI:newStore: "nxt " off: 3 valueOff: 0 dstE: "nxt " 
 --  isNotRemote: false originIsValueObj: false isUnitValueObj: false 
 --  rightQual:primNo: 0 rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 -- DI:newStore:ref/String: "nxt: ref link " 
 rswap 0
 rstoreg  link$78 3
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS scan$103 103 4 has 101
 -- vdtTableCopy: I:1:102 I:2:0
 tstOriginIsNone 
 rstore  4 origin
 -- super scan
 -- computeAdrX:superAdj: 4 "scan " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "scan " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 rpushg has$101 4
 -- items:goOrigin:encOG: "has "on: 1 isValueObj: false 
 --  origin: Set origin:isValueObj: false 
 rpushg has$101 1
 -- computeAdrX:isLast:E:  "scan "
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- DI:gen: "current: ref elm " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 -- DI:gen: "nxt: ref link " DI:isConst: false isBasicValue: false 
 --  primNo: 0 
 rtnAlloc 1
 toSuper 102
DO:
 mvStack 
 L1:
 -- OG:before:super.gen: "
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  :else 
 --     B := B "
 -- handleInv: 
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  :else staticOff: 0 doLoad: true useRtnVal: false 
 -- isPtnWithOrigin: 
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  :else 
 --  
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  :else false 
 -- needOriginII: 
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  :else 
 -- E: IfThenElse D: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- needOrigin: false 
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  :else 
 -- exps.range: 1 exps[i]: 
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  :else needOrigin: false 
 -- isConst: 
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  :else IfThenElse 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- noOrigin: 
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  :else 
 -- loadPathII:E: 
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  :else 1 1 exps.range: 1 staticOff: 0 
 -- loadPathII:before:newInvoke: 
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  :else true 
 -- checkForProxy:E: 
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  :else isBasicValue: false origin.isValueObj: false staticOff: 0 rec: 
 --  none 
 -- loadPathII:next: 1 1 
 -- IfThenElse:newInvoke: 
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  :else 
 -- OG:before:super.gen: "(current == e) "
 -- handleInv: "(current == e) " staticOff: 0 doLoad: true 
 --  useRtnVal: true 
 -- isPtnWithOrigin: "(current == e) " 
 --  "current " false "== e " true 
 -- needOriginII: "(current == e) " 
 -- E: ObjectInvocation_Unary D: "current: ref elm " 
 -- E: ObjectInvocation_Binary D: 
 --  ==  : 
 --     %basic 56
 --     in objx: ref Object
 --     out V: var boolean
 --  
 -- needOrigin: true "== e " 
 -- exps.range: 2 exps[i]: "current " exps[i]: "== e " needOrigin: 
 --  true 
 -- isConst: "current " ObjectInvocation_Unary "current: ref elm " 
 -- isConst:DI: "current: ref elm " 
 -- updateOffset: "current " E.ATd: "current: ref elm " 
 -- isConst: "== e " ObjectInvocation_Binary 
 --  ==  : 
 --     %basic 56
 --     in objx: ref Object
 --     out V: var boolean
 --  
 -- updateOffset: "== e " E.ATd: 
 --  ==  : 
 --     %basic 56
 --     in objx: ref Object
 --     out V: var boolean
 --  
 -- loadPathII:E: "current " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "current " 
 pushThis 
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "current " 
 -- DI:loadAccessor: "current " 
 -- DI:loadAccessor:Obj: "current: ref elm " 
 rpushg newInvoke 2
 -- loadPathII:E: "== e " 1 2 exps.range: 2 staticOff: 0 
 -- E: "== e " E:isPrimitiveIntWithFloatArg: false rec: "current " 
 --  isFloat: false 
 -- NonVirt: "== e " "ObjectInvocation_Binary " ActArg: "e "isValue: 
 --  false formalArg: "in objx: ref Object " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "== e " isCompositeValueObj: false 
 -- OG:before:super.gen: "e "
 -- handleInv: "e " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "e " 
 --  "e " false 
 -- needOriginII: "e " 
 -- E: ObjectInvocation_Unary D: "in E: ref elm " 
 -- needOrigin: true "e " 
 -- exps.range: 1 exps[i]: "e " needOrigin: true 
 -- isConst: "e " ObjectInvocation_Unary "in E: ref elm " 
 -- isConst:DI: "in E: ref elm " 
 -- updateOffset: "e " E.ATd: "in E: ref elm " 
 -- loadPathII:E: "e " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "e " 
 pushThis 
 -- items:goOrigin:encOG: "scan$103 "on: 1 isValueObj: false 
 --  origin: has origin:isValueObj: false 
 rpushg scan$103$103 4
 -- loadPathII:before:newInvoke: "e " true 
 -- checkForProxy:E: "e " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "e " 
 -- DI:newInvoke: "in E: ref elm " off: 2 valueOff: 0 E: "e " 
 --  next: none isAdr: false 
 -- DI:newInvoke:loadObj: "in E: ref elm " 
 rpushg newInvoke 2
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: false formalArg:isPtn: "in objx: ref Object "
 --  :isBasicVal: false :valueObj: false 
 --  :actArg: "e ":isBasicVal: false 
 -- case:B: e ObjectGenerator 64 0 64 false false 
 -- isIntForFloatArg: "e " D: "in objx: ref Object " false false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "e " 
 --  B: false 
 --  "in E: ref elm " 
 -- end:loadArgs:NonVirt: "== e "
 -- loadPathII:before:newInvoke: "== e " true 
 -- checkForProxy:E: "== e " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: "current " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "== e " 
 -- ptn:newInvoke: "==   " staticOff: 0 
 -- gPTN:newInvoke: "==   " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: "current " 
 -- checkInt2IntWithUnitArg:E: "== e " false false 
 req
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  105   "$105 "
 invoke $105 105 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L5
 L4:
 pushThis 
 -- before objTmpStack:add:  106   "$106 "
 invoke $106 106 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L5:
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0

 CLASS $105 105 1 scan$103 103
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- handleAssign: "B := true " 
 -- handleInv: "B " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "B " 
 --  "B " false 
 -- needOriginII: "B " 
 -- E: ObjectInvocation_Unary D: "out B: var boolean " 
 -- needOrigin: true "B " 
 -- exps.range: 1 exps[i]: "B " needOrigin: true 
 -- isConst: "B " ObjectInvocation_Unary "out B: var boolean " 
 -- isConst:DI: "out B: var boolean " 
 -- updateOffset: "B " E.ATd: "out B: var boolean " 
 -- loadPathII:E: "B " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "B " 
 pushThis 
 -- items:goOrigin:encOG: "$105 "on: 2 isValueObj: false 
 --  origin: scan$103 origin:isValueObj: false 
 rpushg $105$105 1
 -- items:goOrigin:encOG: "scan$103 "on: 1 isValueObj: false 
 --  origin: has origin:isValueObj: false 
 rpushg scan$103$103 4
 -- loadPathII:before:newInvoke: "B " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "B := true " leftE: "B " 
 -- OG:before:super.gen: "true "
 -- handleInv: "true " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "true " 
 --  "true " false 
 -- needOriginII: "true " 
 -- E: ObjectInvocation_Unary D: 
 --  True: 
 --     %globals
 --     out B: var boolean
 --     B := 1
 --  
 -- needOrigin: false "true " 
 -- exps.range: 1 exps[i]: "true " needOrigin: false 
 -- isConst: "true " ObjectInvocation_Unary 
 --  True: 
 --     %globals
 --     out B: var boolean
 --     B := 1
 --  
 -- noOrigin: "true " 
 -- loadPathII:E: "true " 1 1 exps.range: 1 staticOff: 0 
 -- loadPathII:before:newInvoke: "true " true 
 -- checkForProxy:E: "true " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "true " 
 -- ptn:newInvoke: "True " staticOff: 0 
 -- gPTN:newInvoke: "True " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: none 
 -- invoke:nonVirtual: "True " isAdr: false 
 invoke True 23 0 0
 -- global:pushOut: B off: 1 
 pushg 1 
 -- callInvoke:after:pushOut: 1 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "B := true " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- right:isPTN:not:valueObj: "out B: var boolean " 
 -- checkI2F2I: "B := true " left.isFloat: false right.isFloat: 
 --  false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- Assign:end: "B := true " isNotRemote: false qual: 
 --  value
 --     %id "Boolean"
 --     %globals inSub
 --     %basic 4, 8
 --  D: none 
 -- DI:newStore: "B " off: 3 valueOff: 0 dstE: "B " isNotRemote: 
 --  false originIsValueObj: false isUnitValueObj: false rightQual:primNo: 4 
 --  rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 storeg Boolean$42 3
 -- OG:before:super.gen: "leave(has) "
 -- handleInv: "leave(has) " staticOff: 0 doLoad: true useRtnVal: 
 --  false 
 -- isPtnWithOrigin: "leave(has) " 
 --  "leave(has) " true 
 -- needOriginII: "leave(has) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- needOrigin: true "leave(has) " 
 -- exps.range: 1 exps[i]: "leave(has) " needOrigin: true 
 -- isConst: "leave(has) " ObjectInvocation_KeyWord 
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- updateOffset: "leave(has) " E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- loadPathII:E: "leave(has) " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "leave(has) " 
 -- loadPathII:before:newInvoke: "leave(has) " true 
 -- checkForProxy:E: "leave(has) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "leave(has) " 
 -- ptn:newInvoke: "leave(V: var integer) " staticOff: 0 
 -- bPTN:newInvoke: "leave(V: var integer) " 
 break  2 2 96 1
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $106 106 1 scan$103 103
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- handleAssign: "B := B " 
 -- handleInv: "B " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "B " 
 --  "B " false 
 -- needOriginII: "B " 
 -- E: ObjectInvocation_Unary D: "out B: var boolean " 
 -- needOrigin: true "B " 
 -- exps.range: 1 exps[i]: "B " needOrigin: true 
 -- isConst: "B " ObjectInvocation_Unary "out B: var boolean " 
 -- isConst:DI: "out B: var boolean " 
 -- updateOffset: "B " E.ATd: "out B: var boolean " 
 -- loadPathII:E: "B " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "B " 
 pushThis 
 -- items:goOrigin:encOG: "$106 "on: 2 isValueObj: false 
 --  origin: scan$103 origin:isValueObj: false 
 rpushg $106$106 1
 -- items:goOrigin:encOG: "scan$103 "on: 1 isValueObj: false 
 --  origin: has origin:isValueObj: false 
 rpushg scan$103$103 4
 -- loadPathII:before:newInvoke: "B " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "B := B " leftE: "B " 
 -- OG:before:super.gen: "B "
 -- handleInv: "B " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "B " 
 --  "B " false 
 -- needOriginII: "B " 
 -- E: ObjectInvocation_Unary D: "out B: var boolean " 
 -- needOrigin: true "B " 
 -- exps.range: 1 exps[i]: "B " needOrigin: true 
 -- isConst: "B " ObjectInvocation_Unary "out B: var boolean " 
 -- isConst:DI: "out B: var boolean " 
 -- updateOffset: "B " E.ATd: "out B: var boolean " 
 -- loadPathII:E: "B " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "B " 
 pushThis 
 -- items:goOrigin:encOG: "$106 "on: 2 isValueObj: false 
 --  origin: scan$103 origin:isValueObj: false 
 rpushg $106$106 1
 -- items:goOrigin:encOG: "scan$103 "on: 1 isValueObj: false 
 --  origin: has origin:isValueObj: false 
 rpushg scan$103$103 4
 -- loadPathII:before:newInvoke: "B " true 
 -- checkForProxy:E: "B " isBasicValue: true origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "B " 
 -- DI:newInvoke: "out B: var boolean " off: 1 valueOff: 0 E: "B " 
 --  next: none isAdr: false 
 -- DI:newInvoke:loadPrimitive: "B " isAdr: false valueOff: 0 
 pushg 3 newInvoke
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "B := B " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- checkI2F2I: "B := B " left.isFloat: false right.isFloat: false 
 --  false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- Assign:end: "B := B " isNotRemote: false qual: 
 --  value
 --     %id "Boolean"
 --     %globals inSub
 --     %basic 4, 8
 --  D: none 
 -- DI:newStore: "B " off: 3 valueOff: 0 dstE: "B " isNotRemote: 
 --  false originIsValueObj: false isUnitValueObj: false rightQual:primNo: 4 
 --  rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 storeg Boolean$42 3
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS isEmpty 112 1 Set 83
 -- vdtTableCopy: I:1:98 I:2:0
 tstOriginIsNone 
 rstore  1 origin
 -- super isEmpty
 pushThis 
 rpushg iOrigin 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 rtnAlloc 1
 toSuper 98
DO:
 mvStack 
 L1:
 -- handleAssign: "B := head == none " 
 -- handleInv: "B " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "B " 
 --  "B " false 
 -- needOriginII: "B " 
 -- E: ObjectInvocation_Unary D: "B: var Boolean " 
 -- needOrigin: true "B " 
 -- exps.range: 1 exps[i]: "B " needOrigin: true 
 -- isConst: "B " ObjectInvocation_Unary "B: var Boolean " 
 -- isConst:DI: "B: var Boolean " 
 -- updateOffset: "B " E.ATd: "B: var Boolean " 
 -- loadPathII:E: "B " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "B " 
 pushThis 
 -- loadPathII:before:newInvoke: "B " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "B := head == none " leftE: "B " 
 -- OG:before:super.gen: "head == none "
 -- handleInv: "head == none " staticOff: 0 doLoad: true useRtnVal: 
 --  true 
 -- isPtnWithOrigin: "head == none " 
 --  "head " false "== none " true 
 -- needOriginII: "head == none " 
 -- E: ObjectInvocation_Unary D: "head: ref link " 
 -- E: ObjectInvocation_Binary D: 
 --  ==  : 
 --     %basic 56
 --     in objx: ref Object
 --     out V: var boolean
 --  
 -- needOrigin: true "== none " 
 -- exps.range: 2 exps[i]: "head " exps[i]: "== none " needOrigin: 
 --  true 
 -- isConst: "head " ObjectInvocation_Unary "head: ref link " 
 -- isConst:DI: "head: ref link " 
 -- updateOffset: "head " E.ATd: "head: ref link " 
 -- isConst: "== none " ObjectInvocation_Binary 
 --  ==  : 
 --     %basic 56
 --     in objx: ref Object
 --     out V: var boolean
 --  
 -- updateOffset: "== none " E.ATd: 
 --  ==  : 
 --     %basic 56
 --     in objx: ref Object
 --     out V: var boolean
 --  
 -- loadPathII:E: "head " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "head " 
 pushThis 
 -- items:goOrigin:encOG: "isEmpty "on: 1 isValueObj: false 
 --  origin: Set origin:isValueObj: false 
 rpushg isEmpty$112 1
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "head " 
 -- DI:loadAccessor: "head " 
 -- DI:loadAccessor:Obj: "head: ref link " 
 rpushg newInvoke 1
 -- loadPathII:E: "== none " 1 2 exps.range: 2 staticOff: 0 
 -- E: "== none " E:isPrimitiveIntWithFloatArg: false rec: "head " 
 --  isFloat: false 
 -- NonVirt: "== none " "ObjectInvocation_Binary " ActArg: "none "
 --  isValue: false formalArg: "in objx: ref Object " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "== none " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "none "
 -- handleInv: "none " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "none " 
 --  "none " true 
 -- needOriginII: "none " 
 -- E: ObjectInvocation_Unary D: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  
 -- needOrigin: true "none " 
 -- exps.range: 1 exps[i]: "none " needOrigin: true 
 -- isConst: "none " ObjectInvocation_Unary 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  
 -- updateOffset: "none " E.ATd: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  
 -- loadPathII:E: "none " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "none " 
 -- loadPathII:before:newInvoke: "none " true 
 -- checkForProxy:E: "none " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "none " 
 -- ptn:newInvoke: "none " staticOff: 0 
 -- oPTN:newInvoke: "none " 19 
 pushNone 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: true formalArg:isPtn: "in objx: ref Object "
 --  :isBasicVal: false :valueObj: false 
 --  :actArg: "none ":isBasicVal: false 
 -- case:B: none ObjectGenerator 64 19 19 false false 
 -- isIntForFloatArg: "none " D: "in objx: ref Object " false false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "none " false 
 --  B: false 
 --  
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  
 -- end:loadArgs:NonVirt: "== none "
 -- loadPathII:before:newInvoke: "== none " true 
 -- checkForProxy:E: "== none " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: "head " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "== none " 
 -- ptn:newInvoke: "==   " staticOff: 0 
 -- gPTN:newInvoke: "==   " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: "head " 
 -- checkInt2IntWithUnitArg:E: "== none " false false 
 req
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "B := head == none " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- right:isPTN:not:valueObj: "out V: var boolean " 
 -- "== none " 
 -- "== none " 
 -- checkI2F2I: "B := head == none " left.isFloat: false 
 --  right.isFloat: false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- "== none " 
 -- "== none " 
 -- Assign:end: "B := head == none " isNotRemote: false qual: 
 --  value
 --     %id "Boolean"
 --     %globals inSub
 --     %basic 4, 8
 --  D: none 
 -- DI:newStore: "B " off: 2 valueOff: 0 dstE: "B " isNotRemote: 
 --  false originIsValueObj: false isUnitValueObj: false rightQual:primNo: 4 
 --  rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 storeg Boolean$42 2
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS insert 75 1 Set 83
 -- vdtTableCopy: I:1:74 I:2:0
 rShiftUp  1
 tstOriginIsNone 
 rstore  1 origin
 -- super insert
 pushThis 
 rpushg iOrigin 1
 rShiftDown  1
 pushThis 
 rstoreg  e 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- DI:gen: "in e: ref elm " DI:isConst: false isBasicValue: false 
 --  primNo: 0 
 rtnAlloc 1
 toSuper 74
DO:
 mvStack 
 L1:
 -- OG:before:super.gen: "
 --  if has(e).not :then 
 --     head := link(e,head) "
 -- handleInv: 
 --  if has(e).not :then 
 --     head := link(e,head)
 --  staticOff: 0 doLoad: true useRtnVal: false 
 -- isPtnWithOrigin: 
 --  if has(e).not :then 
 --     head := link(e,head)
 --  
 --  
 --  if has(e).not :then 
 --     head := link(e,head)
 --  false 
 -- needOriginII: 
 --  if has(e).not :then 
 --     head := link(e,head)
 --  
 -- E: IfThen D: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- needOrigin: false 
 --  if has(e).not :then 
 --     head := link(e,head)
 --  
 -- exps.range: 1 exps[i]: 
 --  if has(e).not :then 
 --     head := link(e,head)
 --  needOrigin: false 
 -- isConst: 
 --  if has(e).not :then 
 --     head := link(e,head)
 --  IfThen 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- noOrigin: 
 --  if has(e).not :then 
 --     head := link(e,head)
 --  
 -- loadPathII:E: 
 --  if has(e).not :then 
 --     head := link(e,head)
 --  1 1 exps.range: 1 staticOff: 0 
 -- loadPathII:before:newInvoke: 
 --  if has(e).not :then 
 --     head := link(e,head)
 --  true 
 -- checkForProxy:E: 
 --  if has(e).not :then 
 --     head := link(e,head)
 --  isBasicValue: false origin.isValueObj: false staticOff: 0 rec: 
 --  none 
 -- loadPathII:next: 1 1 
 -- IfThen:newInvoke: 
 --  if has(e).not :then 
 --     head := link(e,head)
 --  
 -- OG:before:super.gen: "has(e).not "
 -- handleInv: "has(e).not " staticOff: 0 doLoad: true useRtnVal: 
 --  true 
 -- isPtnWithOrigin: "has(e).not " 
 --  "has(e) " true "not " true 
 -- needOriginII: "has(e).not " 
 -- E: ObjectInvocation_KeyWord D: 
 --  has:: 
 --     B := false
 --     scan
 --        if (current == e) :then 
 -- E: ObjectInvocation_Unary D: 
 --  not: 
 --     %basic 65
 --     out R: var boolean
 --  
 -- needOrigin: true "not " 
 -- exps.range: 2 exps[i]: "has(e) " exps[i]: "not " needOrigin: 
 --  true 
 -- isConst: "has(e) " ObjectInvocation_KeyWord 
 --  has:: 
 --     B := false
 --     scan
 --        if (current == e) :then 
 -- updateOffset: "has(e) " E.ATd: 
 --  has:: 
 --     B := false
 --     scan
 --        if (current == e) :then 
 -- isConst: "not " ObjectInvocation_Unary 
 --  not: 
 --     %basic 65
 --     out R: var boolean
 --  
 -- updateOffset: "not " E.ATd: 
 --  not: 
 --     %basic 65
 --     out R: var boolean
 --  
 -- loadPathII:E: "has(e) " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "has(e) " 
 pushThis 
 -- items:goOrigin:encOG: "insert "on: 1 isValueObj: false 
 --  origin: Set origin:isValueObj: false 
 rpushg insert$75 1
 -- NonVirt: "has(e) " "ObjectInvocation_KeyWord " ActArg: "e "
 --  isValue: false formalArg: "in E: ref elm " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "has(e) " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "e "
 -- handleInv: "e " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "e " 
 --  "e " false 
 -- needOriginII: "e " 
 -- E: ObjectInvocation_Unary D: "in e: ref elm " 
 -- needOrigin: true "e " 
 -- exps.range: 1 exps[i]: "e " needOrigin: true 
 -- isConst: "e " ObjectInvocation_Unary "in e: ref elm " 
 -- isConst:DI: "in e: ref elm " 
 -- updateOffset: "e " E.ATd: "in e: ref elm " 
 -- loadPathII:E: "e " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "e " 
 pushThis 
 -- loadPathII:before:newInvoke: "e " true 
 -- checkForProxy:E: "e " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "e " 
 -- DI:newInvoke: "in e: ref elm " off: 2 valueOff: 0 E: "e " 
 --  next: none isAdr: false 
 -- DI:newInvoke:loadObj: "in e: ref elm " 
 rpushg newInvoke 2
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: false formalArg:isPtn: "in E: ref elm "
 --  :isBasicVal: false :valueObj: false 
 --  :actArg: "e ":isBasicVal: false 
 -- case:B: e ObjectGenerator 0 0 64 false false 
 -- isIntForFloatArg: "e " D: "in E: ref elm " false false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "e " 
 --  B: false 
 --  "in e: ref elm " 
 -- end:loadArgs:NonVirt: "has(e) "
 -- loadPathII:loadAccessor:isPTN: "has(e) " 
 -- checkForProxy:E: "has(e) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 2 
 -- OI:newInvoke: "has(e) " 
 -- ptn:newInvoke: "has " staticOff: 0 
 -- gPTN:newInvoke: "has " ptnKind: 3 staticOff: 0 valueOff: 0 
 --  rec: none 
 -- invoke:Virtual: "has " E: "has(e) " E.ATd.isValueObj: false 
 --  this:isVal: false rec: none isStatic: false 
 invokev 4 1 has$101 0
 -- global:pushOut: B off: 3 
 pushg 3 has$101
 -- GeneralPTN:invoke:after:pushOut: 
 -- loadPathII:E: "not " 1 2 exps.range: 2 staticOff: 0 
 -- E: "not " E:isPrimitiveIntWithFloatArg: false rec: "has(e) " 
 --  isFloat: false 
 -- loadPathII:before:newInvoke: "not " true 
 -- checkForProxy:E: "not " isBasicValue: true origin.isValueObj: 
 --  true staticOff: 0 rec: "has(e) " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "not " 
 -- ptn:newInvoke: "not " staticOff: 0 
 -- gPTN:newInvoke: "not " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: "has(e) " 
 -- checkInt2IntWithUnitArg:E: "not " false false 
 nott
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  77   "$77 "
 invoke $77 77 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS $77 77 1 insert 75
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- handleAssign: "head := link(e,head) " 
 -- handleInv: "head " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "head " 
 --  "head " false 
 -- needOriginII: "head " 
 -- E: ObjectInvocation_Unary D: "head: ref link " 
 -- needOrigin: true "head " 
 -- exps.range: 1 exps[i]: "head " needOrigin: true 
 -- isConst: "head " ObjectInvocation_Unary "head: ref link " 
 -- isConst:DI: "head: ref link " 
 -- updateOffset: "head " E.ATd: "head: ref link " 
 -- loadPathII:E: "head " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "head " 
 pushThis 
 -- items:goOrigin:encOG: "$77 "on: 2 isValueObj: false 
 --  origin: insert origin:isValueObj: false 
 rpushg $77$77 1
 -- items:goOrigin:encOG: "insert "on: 1 isValueObj: false 
 --  origin: Set origin:isValueObj: false 
 rpushg insert$75 1
 -- loadPathII:before:newInvoke: "head " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "head := link(e,head) " leftE: "head " 
 -- OG:before:super.gen: "link(e,head) "
 -- handleInv: "link(e,head) " staticOff: 0 doLoad: true useRtnVal: 
 --  true 
 -- isPtnWithOrigin: "link(e,head) " 
 --  "link(e,head) " true 
 -- needOriginII: "link(e,head) " 
 -- E: ObjectInvocation_Function D: 
 --  link: 
 --     in e: ref elm
 --     in next: ref link
 --  
 -- needOrigin: true "link(e,head) " 
 -- exps.range: 1 exps[i]: "link(e,head) " needOrigin: true 
 -- isConst: "link(e,head) " ObjectInvocation_Function 
 --  link: 
 --     in e: ref elm
 --     in next: ref link
 --  
 -- updateOffset: "link(e,head) " E.ATd: 
 --  link: 
 --     in e: ref elm
 --     in next: ref link
 --  
 -- loadPathII:E: "link(e,head) " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "link(e,head) " 
 pushThis 
 -- items:goOrigin:encOG: "$77 "on: 2 isValueObj: false 
 --  origin: insert origin:isValueObj: false 
 rpushg $77$77 1
 -- items:goOrigin:encOG: "insert "on: 1 isValueObj: false 
 --  origin: Set origin:isValueObj: false 
 rpushg insert$75 1
 -- NonVirt: "link(e,head) " "ObjectInvocation_Function " ActArg: "e "
 --  isValue: false formalArg: "in e: ref elm " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "link(e,head) "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "e "
 -- handleInv: "e " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "e " 
 --  "e " false 
 -- needOriginII: "e " 
 -- E: ObjectInvocation_Unary D: "in e: ref elm " 
 -- needOrigin: true "e " 
 -- exps.range: 1 exps[i]: "e " needOrigin: true 
 -- isConst: "e " ObjectInvocation_Unary "in e: ref elm " 
 -- isConst:DI: "in e: ref elm " 
 -- updateOffset: "e " E.ATd: "in e: ref elm " 
 -- loadPathII:E: "e " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "e " 
 pushThis 
 -- items:goOrigin:encOG: "$77 "on: 1 isValueObj: false 
 --  origin: insert origin:isValueObj: false 
 rpushg $77$77 1
 -- loadPathII:before:newInvoke: "e " true 
 -- checkForProxy:E: "e " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "e " 
 -- DI:newInvoke: "in e: ref elm " off: 2 valueOff: 0 E: "e " 
 --  next: none isAdr: false 
 -- DI:newInvoke:loadObj: "in e: ref elm " 
 rpushg newInvoke 2
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: false formalArg:isPtn: "in e: ref elm "
 --  :isBasicVal: false :valueObj: false 
 --  :actArg: "e ":isBasicVal: false 
 -- case:B: e ObjectGenerator 0 0 64 false false 
 -- isIntForFloatArg: "e " D: "in e: ref elm " false false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "e " 
 --  B: false 
 --  "in e: ref elm " 
 -- end:loadArgs:NonVirt: "link(e,head) "
 -- NonVirt: "link(e,head) " "ObjectInvocation_Function " ActArg: "
 --  head "isValue: false formalArg: "in next: ref link " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "link(e,head) "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "head "
 -- handleInv: "head " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "head " 
 --  "head " false 
 -- needOriginII: "head " 
 -- E: ObjectInvocation_Unary D: "head: ref link " 
 -- needOrigin: true "head " 
 -- exps.range: 1 exps[i]: "head " needOrigin: true 
 -- isConst: "head " ObjectInvocation_Unary "head: ref link " 
 -- isConst:DI: "head: ref link " 
 -- updateOffset: "head " E.ATd: "head: ref link " 
 -- loadPathII:E: "head " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "head " 
 pushThis 
 -- items:goOrigin:encOG: "$77 "on: 2 isValueObj: false 
 --  origin: insert origin:isValueObj: false 
 rpushg $77$77 1
 -- items:goOrigin:encOG: "insert "on: 1 isValueObj: false 
 --  origin: Set origin:isValueObj: false 
 rpushg insert$75 1
 -- loadPathII:before:newInvoke: "head " true 
 -- checkForProxy:E: "head " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "head " 
 -- DI:newInvoke: "head: ref link " off: 1 valueOff: 0 E: "head " 
 --  next: none isAdr: false 
 -- DI:newInvoke:loadObj: "head: ref link " 
 rpushg newInvoke 1
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: false formalArg:isPtn: "in next: ref link "
 --  :isBasicVal: false :valueObj: false 
 --  :actArg: "head ":isBasicVal: false 
 -- case:B: head ObjectGenerator 0 0 0 false false 
 -- isIntForFloatArg: "head " D: "in next: ref link " false false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "head " 
 --  B: false 
 --  "head: ref link " 
 -- end:loadArgs:NonVirt: "link(e,head) "
 -- loadPathII:before:newInvoke: "link(e,head) " true 
 -- checkForProxy:E: "link(e,head) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "link(e,head) " 
 -- ptn:newInvoke: "link " staticOff: 0 
 -- gPTN:newInvoke: "link " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: none 
 -- invoke:nonVirtual: "link " isAdr: false 
 invoke link 78 0 1
 -- callInvoke:after:pushOut: -1 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "head := link(e,head) " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- checkI2F2I: "head := link(e,head) " left.isFloat: false 
 --  right.isFloat: false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- Assign:end: "head := link(e,head) " isNotRemote: false qual: 
 --  in e: ref elm
 --     in next: ref link
 --  
 --  D: none 
 -- DI:newStore: "head " off: 1 valueOff: 0 dstE: "head " 
 --  isNotRemote: false originIsValueObj: false isUnitValueObj: false 
 --  rightQual:primNo: 0 rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 -- DI:newStore:ref/String: "head: ref link " 
 rswap 0
 rstoreg  link$78 1
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS remove 113 1 Set 83
 -- vdtTableCopy: I:1:97 I:2:0
 rShiftUp  1
 tstOriginIsNone 
 rstore  1 origin
 -- super remove
 pushThis 
 rpushg iOrigin 1
 rShiftDown  1
 pushThis 
 rstoreg  E 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- DI:gen: "in E: ref elm " DI:isConst: false isBasicValue: false 
 --  primNo: 0 
 rtnAlloc 1
 toSuper 97
DO:
 mvStack 
 L1:
 -- OG:before:super.gen: "
 --  "\nObs! Set:remove:not implemented!\n".print "
 -- handleInv: ""\nObs! Set:remove:not implemented!\n".print " 
 --  staticOff: 0 doLoad: true useRtnVal: false 
 -- isPtnWithOrigin: ""\nObs! Set:remove:not implemented!\n".print " 
 --  ""\nObs! Set:remove:not implemented!\n" " false "print " true 
 -- needOriginII: ""\nObs! Set:remove:not implemented!\n".print " 
 -- E: String: D: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- E: ObjectInvocation_Unary D: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeat
 -- needOrigin: true "print " 
 -- exps.range: 2 exps[i]: "
 --  "\nObs! Set:remove:not implemented!\n" " exps[i]: "print " needOrigin: true 
 -- isConst: ""\nObs! Set:remove:not implemented!\n" " String: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- updateOffset: ""\nObs! Set:remove:not implemented!\n" " E.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- isConst: "print " ObjectInvocation_Unary 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeat
 -- updateOffset: "print " E.ATd: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeat
 -- loadPathII:E: ""\nObs! Set:remove:not implemented!\n" " 1 1 
 --  exps.range: 2 staticOff: 0 
 -- loadOriginII: ""\nObs! Set:remove:not implemented!\n" " 
 -- StringObj:loadOrigin: "\nObs! Set:remove:not implemented!\n" 
 -- loadPathII:loadAccessor:isPTN: "
 --  "\nObs! Set:remove:not implemented!\n" " 
 -- checkForProxy:E: ""\nObs! Set:remove:not implemented!\n" " 
 --  isBasicValue: false origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 2 
 -- StringObj:newInvoke \nObs! Set:remove:not implemented!\n 
 pushText "\nObs! Set:remove:not implemented!\n"
 -- loadPathII:E: "print " 1 2 exps.range: 2 staticOff: 0 
 -- E: "print " E:isPrimitiveIntWithFloatArg: false rec: "
 --  "\nObs! Set:remove:not implemented!\n" " isFloat: false 
 -- loadPathII:before:newInvoke: "print " true 
 -- checkForProxy:E: "print " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: ""\nObs! Set:remove:not implemented!\n" " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "print " 
 -- ptn:newInvoke: "print " staticOff: 0 
 -- gPTN:newInvoke: "print " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: ""\nObs! Set:remove:not implemented!\n" " 
 -- invoke:nonVirtual: "print " isAdr: false 
 invoke print 114 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS print 114 1 String 10
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 pushThis 
 -- before objTmpStack:add:  117   "for:to:repeat$117 "
 invoke for:to:repeat$117 117 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS repeat$115 115 1 for:to:repeat$117 117
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "put(get[inx]) "
 -- handleInv: "put(get[inx]) " staticOff: 0 doLoad: true 
 --  useRtnVal: false 
 -- isPtnWithOrigin: "put(get[inx]) " 
 --  "put(get[inx]) " false 
 -- needOriginII: "put(get[inx]) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- needOrigin: false "put(get[inx]) " 
 -- exps.range: 1 exps[i]: "put(get[inx]) " needOrigin: false 
 -- isConst: "put(get[inx]) " ObjectInvocation_KeyWord 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- noOrigin: "put(get[inx]) " 
 -- loadPathII:E: "put(get[inx]) " 1 1 exps.range: 1 staticOff: 0 
 -- NonVirt: "put(get[inx]) " "ObjectInvocation_KeyWord " ActArg: "
 --  get[inx] "isValue: false formalArg: "in ch: val char " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(get[inx]) "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "get[inx] "
 -- handleInv: "get[inx] " staticOff: 0 doLoad: true useRtnVal: 
 --  true 
 -- isPtnWithOrigin: "get[inx] " 
 --  "get[inx] " true 
 -- needOriginII: "get[inx] " 
 -- E: ObjectInvocation_KeyWord D: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- needOrigin: true "get[inx] " 
 -- exps.range: 1 exps[i]: "get[inx] " needOrigin: true 
 -- isConst: "get[inx] " ObjectInvocation_KeyWord 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- updateOffset: "get[inx] " E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- loadPathII:E: "get[inx] " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "get[inx] " 
 pushThis 
 -- items:goOrigin:encOG: "repeat$115 "on: 3 isValueObj: false 
 --  origin: for:to:repeat$117 origin:isValueObj: false 
 rpushg repeat$115$115 1
 -- items:goOrigin:encOG: "for:to:repeat$117 "on: 2 isValueObj: 
 --  false 
 --  origin: print origin:isValueObj: false 
 rpushg for:to:repeat$117$117 4
 -- items:goOrigin:encOG: "print "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg print$114 1
 -- NonVirt: "get[inx] " "ObjectInvocation_KeyWord " ActArg: "inx "
 --  isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx] " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "inx "
 -- handleInv: "inx " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "inx " 
 --  "inx " false 
 -- needOriginII: "inx " 
 -- E: ObjectInvocation_Unary D: "inx: var integer " 
 -- needOrigin: true "inx " 
 -- exps.range: 1 exps[i]: "inx " needOrigin: true 
 -- isConst: "inx " ObjectInvocation_Unary "inx: var integer " 
 -- isConst:DI: "inx: var integer " 
 -- updateOffset: "inx " E.ATd: "inx: var integer " 
 -- loadPathII:E: "inx " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "inx " 
 pushThis 
 -- items:goOrigin:encOG: "repeat$115 "on: 1 isValueObj: false 
 --  origin: for:to:repeat$117 origin:isValueObj: false 
 rpushg repeat$115$115 1
 -- loadPathII:before:newInvoke: "inx " true 
 -- checkForProxy:E: "inx " isBasicValue: true origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "inx " 
 -- DI:newInvoke: "inx: var integer " off: 1 valueOff: 0 E: "inx " 
 --  next: none isAdr: false 
 -- DI:newInvoke:loadPrimitive: "inx " isAdr: false valueOff: 0 
 pushg 3 newInvoke
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- isIntForFloatArg: "inx " D: "inx: var integer " true false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "inx " 
 --  B: false 
 --  "inx: var integer " 
 -- end:loadArgs:NonVirt: "get[inx] "
 -- loadPathII:before:newInvoke: "get[inx] " true 
 -- checkForProxy:E: "get[inx] " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "get[inx] " 
 -- ptn:newInvoke: "get[inx: var integer] " staticOff: 0 
 -- indexPTN:newInvoke: "get[inx: var integer] " isAdr: false 
 xpushg  inx 1 0 1
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "get[inx] ":isBasicVal: true 
 -- case:B: get[inx] ObjectGenerator 3 117 117 false false 
 -- isIntForFloatArg: "get[inx] " D: "in ch: val char " false false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "get[inx] " false 
 --  B: false 
 --  
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- end:loadArgs:NonVirt: "put(get[inx]) "
 -- loadPathII:before:newInvoke: "put(get[inx]) " true 
 -- checkForProxy:E: "put(get[inx]) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "put(get[inx]) " 
 -- ptn:newInvoke: "put " staticOff: 0 
 -- oPTN:newInvoke: "put " 2 
 %put 2
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS put 116 0 BETA 2
 pushThis 
 storeg char$7 1
 allocEventQ
 mvStack 
 -- DI:gen: "in ch: val char " DI:isConst: true isBasicValue: true 
 --  primNo: 3 
 -- DI:gen:primitiveType: ch 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS for:to:repeat$117 117 4 print 114
 -- vdtTableCopy: I:1:28 V:2:29
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- NonVirt: 
 --  for(1):to(length):repeat
 --     put(get[inx])
 --  "ObjectInvocation_KeyWord " ActArg: "1 "isValue: true formalArg: "
 --  first: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  for(1):to(length):repeat
 --     put(get[inx])
 --   " isCompositeValueObj: false 
 -- OG:before:super.gen: "1 "
 -- handleInv: "1 " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "1 " 
 --  "1 " false 
 -- needOriginII: "1 " 
 -- E: ConstLiteral D: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- needOrigin: true "1 " 
 -- exps.range: 1 exps[i]: "1 " needOrigin: true 
 -- isConst: "1 " ConstLiteral 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- isConstLiteral: "1 " 
 pushc 1
 -- const:cst: "1 " 1 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: true formalArg:isPtn: "first: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- isIntForFloatArg: "1 " D: "first: var integer " true false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "1 " false 
 --  B: false 
 --  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- end:loadArgs:NonVirt: "for(1):to(length):repeat
 --     put(get[inx])
 --   "
 -- NonVirt: 
 --  for(1):to(length):repeat
 --     put(get[inx])
 --  "ObjectInvocation_KeyWord " ActArg: "length "isValue: false 
 --  formalArg: "last: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  for(1):to(length):repeat
 --     put(get[inx])
 --   " isCompositeValueObj: false 
 -- OG:before:super.gen: "length "
 -- handleInv: "length " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "length " 
 --  "length " true 
 -- needOriginII: "length " 
 -- E: ObjectInvocation_Unary D: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- needOrigin: true "length " 
 -- exps.range: 1 exps[i]: "length " needOrigin: true 
 -- isConst: "length " ObjectInvocation_Unary 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- updateOffset: "length " E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- loadPathII:E: "length " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "length " 
 pushThis 
 rpushg print$114 4
 -- items:goOrigin:encOG: "print "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg print$114 1
 -- loadPathII:before:newInvoke: "length " true 
 -- checkForProxy:E: "length " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "length " 
 -- ptn:newInvoke: "length " staticOff: 0 
 -- gPTN:newInvoke: "length " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: none 
 -- invoke:nonVirtual: "length " isAdr: false 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: true formalArg:isPtn: "last: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "length ":isBasicVal: true 
 -- case:B: length ObjectGenerator 1 0 0 false false 
 -- isIntForFloatArg: "length " D: "last: var integer " true false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "length " false 
 --  B: false 
 --  
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- end:loadArgs:NonVirt: "for(1):to(length):repeat
 --     put(get[inx])
 --   "
 pushThis 
 storeg integer$5 2
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- DI:gen: "inx: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: inx 
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0

 CLASS size 118 1 Set 83
 -- vdtTableCopy: I:1:99 I:2:0
 tstOriginIsNone 
 rstore  1 origin
 -- super size
 pushThis 
 rpushg iOrigin 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 rtnAlloc 1
 toSuper 99
DO:
 mvStack 
 L1:
 pushThis 
 -- before objTmpStack:add:  119   "scan$119 "
 invoke scan$119 119 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS scan$119 119 4 size 118
 -- vdtTableCopy: I:1:102 I:2:0
 tstOriginIsNone 
 rstore  4 origin
 -- super scan
 -- computeAdrX:superAdj: 4 "scan " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "scan " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 rpushg size$118 4
 -- items:goOrigin:encOG: "size "on: 1 isValueObj: false 
 --  origin: Set origin:isValueObj: false 
 rpushg size$118 1
 -- computeAdrX:isLast:E:  "scan "
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- DI:gen: "current: ref elm " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 -- DI:gen: "nxt: ref link " DI:isConst: false isBasicValue: false 
 --  primNo: 0 
 rtnAlloc 1
 toSuper 102
DO:
 mvStack 
 L1:
 -- handleAssign: "N := N + 1 " 
 -- handleInv: "N " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "N " 
 --  "N " false 
 -- needOriginII: "N " 
 -- E: ObjectInvocation_Unary D: "N: var integer " 
 -- needOrigin: true "N " 
 -- exps.range: 1 exps[i]: "N " needOrigin: true 
 -- isConst: "N " ObjectInvocation_Unary "N: var integer " 
 -- isConst:DI: "N: var integer " 
 -- updateOffset: "N " E.ATd: "N: var integer " 
 -- loadPathII:E: "N " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "N " 
 pushThis 
 -- items:goOrigin:encOG: "scan$119 "on: 1 isValueObj: false 
 --  origin: size origin:isValueObj: false 
 rpushg scan$119$119 4
 -- loadPathII:before:newInvoke: "N " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "N := N + 1 " leftE: "N " 
 -- OG:before:super.gen: "N + 1 "
 -- handleInv: "N + 1 " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "N + 1 " 
 --  "N " false "+ 1 " true 
 -- needOriginII: "N + 1 " 
 -- E: ObjectInvocation_Unary D: "N: var integer " 
 -- E: ObjectInvocation_Binary D: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- needOrigin: true "+ 1 " 
 -- exps.range: 2 exps[i]: "N " exps[i]: "+ 1 " needOrigin: true 
 -- isConst: "N " ObjectInvocation_Unary "N: var integer " 
 -- isConst:DI: "N: var integer " 
 -- updateOffset: "N " E.ATd: "N: var integer " 
 -- isConst: "+ 1 " ObjectInvocation_Binary 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- updateOffset: "+ 1 " E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- loadPathII:E: "N " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "N " 
 pushThis 
 -- items:goOrigin:encOG: "scan$119 "on: 1 isValueObj: false 
 --  origin: size origin:isValueObj: false 
 rpushg scan$119$119 4
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "N " 
 -- DI:loadAccessor: "N " 
 -- DI:loadAccesor:loadPrimitive: "N " 
 pushg 2 newInvoke
 -- loadPathII:E: "+ 1 " 1 2 exps.range: 2 staticOff: 0 
 -- E: "+ 1 " E:isPrimitiveIntWithFloatArg: false rec: "N " isFloat: 
 --  false 
 -- NonVirt: "+ 1 " "ObjectInvocation_Binary " ActArg: "1 "isValue: 
 --  true formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ 1 " isCompositeValueObj: false 
 -- OG:before:super.gen: "1 "
 -- handleInv: "1 " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "1 " 
 --  "1 " false 
 -- needOriginII: "1 " 
 -- E: ConstLiteral D: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- needOrigin: true "1 " 
 -- exps.range: 1 exps[i]: "1 " needOrigin: true 
 -- isConst: "1 " ConstLiteral 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- isConstLiteral: "1 " 
 pushc 1
 -- const:cst: "1 " 1 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- isIntForFloatArg: "1 " D: "in V: var integer " true false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "1 " false 
 --  B: false 
 --  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- end:loadArgs:NonVirt: "+ 1 "
 -- loadPathII:before:newInvoke: "+ 1 " true 
 -- checkForProxy:E: "+ 1 " isBasicValue: true origin.isValueObj: 
 --  true staticOff: 0 rec: "N " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "+ 1 " 
 -- ptn:newInvoke: "+   " staticOff: 0 
 -- gPTN:newInvoke: "+   " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: "N " 
 -- checkInt2IntWithUnitArg:E: "+ 1 " false false 
 plus
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "N := N + 1 " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- right:isPTN:not:valueObj: "out R: var integer " 
 -- "+ 1 " 
 -- "+ 1 " 
 -- checkI2F2I: "N := N + 1 " left.isFloat: false right.isFloat: 
 --  false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- "+ 1 " 
 -- "+ 1 " 
 -- Assign:end: "N := N + 1 " isNotRemote: false qual: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  D: none 
 -- DI:newStore: "N " off: 2 valueOff: 0 dstE: "N " isNotRemote: 
 --  false originIsValueObj: false isUnitValueObj: false rightQual:primNo: 1 
 --  rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 storeg integer$5 2
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0

 CLASS clear 120 1 Set 83
 -- vdtTableCopy: I:1:100 I:2:0
 tstOriginIsNone 
 rstore  1 origin
 -- super clear
 pushThis 
 rpushg iOrigin 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 rtnAlloc 1
 toSuper 100
DO:
 mvStack 
 L1:
 -- handleAssign: "head := none " 
 -- handleInv: "head " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "head " 
 --  "head " false 
 -- needOriginII: "head " 
 -- E: ObjectInvocation_Unary D: "head: ref link " 
 -- needOrigin: true "head " 
 -- exps.range: 1 exps[i]: "head " needOrigin: true 
 -- isConst: "head " ObjectInvocation_Unary "head: ref link " 
 -- isConst:DI: "head: ref link " 
 -- updateOffset: "head " E.ATd: "head: ref link " 
 -- loadPathII:E: "head " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "head " 
 pushThis 
 -- items:goOrigin:encOG: "clear "on: 1 isValueObj: false 
 --  origin: Set origin:isValueObj: false 
 rpushg clear$120 1
 -- loadPathII:before:newInvoke: "head " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "head := none " leftE: "head " 
 -- OG:before:super.gen: "none "
 -- handleInv: "none " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "none " 
 --  "none " true 
 -- needOriginII: "none " 
 -- E: ObjectInvocation_Unary D: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  
 -- needOrigin: true "none " 
 -- exps.range: 1 exps[i]: "none " needOrigin: true 
 -- isConst: "none " ObjectInvocation_Unary 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  
 -- updateOffset: "none " E.ATd: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  
 -- loadPathII:E: "none " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "none " 
 -- loadPathII:before:newInvoke: "none " true 
 -- checkForProxy:E: "none " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "none " 
 -- ptn:newInvoke: "none " staticOff: 0 
 -- oPTN:newInvoke: "none " 19 
 pushNone 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "head := none " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- checkI2F2I: "head := none " left.isFloat: false right.isFloat: 
 --  false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- Assign:end: "head := none " isNotRemote: false qual: 
 --  %basic 19
 --     none_x: var integer
 --  
 --  D: none 
 -- DI:newStore: "head " off: 1 valueOff: 0 dstE: "head " 
 --  isNotRemote: false originIsValueObj: false isUnitValueObj: false 
 --  rightQual:primNo: 19 rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 -- DI:newStore:ref/String: "head: ref link " 
 rswap 0
 rstoreg  link$78 1
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0

 CLASS Symbol 72 1 Grammar 71
 pushThis 
 rstoreg  printName 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "id: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: id 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(Symbol) "
 -- handleInv: "inner(Symbol) " staticOff: 0 doLoad: true 
 --  useRtnVal: false 
 -- isPtnWithOrigin: "inner(Symbol) " 
 --  "inner(Symbol) " true 
 -- needOriginII: "inner(Symbol) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- needOrigin: true "inner(Symbol) " 
 -- exps.range: 1 exps[i]: "inner(Symbol) " needOrigin: true 
 -- isConst: "inner(Symbol) " ObjectInvocation_KeyWord 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- updateOffset: "inner(Symbol) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- loadPathII:E: "inner(Symbol) " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "inner(Symbol) " 
 -- loadPathII:before:newInvoke: "inner(Symbol) " true 
 -- checkForProxy:E: "inner(Symbol) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "inner(Symbol) " 
 -- ptn:newInvoke: "inner " staticOff: 0 
 -- oPTN:newInvoke: "inner " 101 
 pushThis 
 innerP  4
 rpopThisObj 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS print 121 1 Symbol 72
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(print) "
 -- handleInv: "inner(print) " staticOff: 0 doLoad: true useRtnVal: 
 --  false 
 -- isPtnWithOrigin: "inner(print) " 
 --  "inner(print) " true 
 -- needOriginII: "inner(print) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- needOrigin: true "inner(print) " 
 -- exps.range: 1 exps[i]: "inner(print) " needOrigin: true 
 -- isConst: "inner(print) " ObjectInvocation_KeyWord 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- updateOffset: "inner(print) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- loadPathII:E: "inner(print) " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "inner(print) " 
 -- loadPathII:before:newInvoke: "inner(print) " true 
 -- checkForProxy:E: "inner(print) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "inner(print) " 
 -- ptn:newInvoke: "inner " staticOff: 0 
 -- oPTN:newInvoke: "inner " 101 
 pushThis 
 innerP  2
 rpopThisObj 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS isTerminal 122 1 Symbol 72
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "out V: var Boolean " DI:isConst: false isBasicValue: 
 --  true primNo: 4 
 -- DI:gen:primitiveType: V 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(isTerminal) "
 -- handleInv: "inner(isTerminal) " staticOff: 0 doLoad: true 
 --  useRtnVal: false 
 -- isPtnWithOrigin: "inner(isTerminal) " 
 --  "inner(isTerminal) " true 
 -- needOriginII: "inner(isTerminal) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- needOrigin: true "inner(isTerminal) " 
 -- exps.range: 1 exps[i]: "inner(isTerminal) " needOrigin: true 
 -- isConst: "inner(isTerminal) " ObjectInvocation_KeyWord 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- updateOffset: "inner(isTerminal) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- loadPathII:E: "inner(isTerminal) " 1 1 exps.range: 1 
 --  staticOff: 0 
 -- loadOriginII: "inner(isTerminal) " 
 -- loadPathII:before:newInvoke: "inner(isTerminal) " true 
 -- checkForProxy:E: "inner(isTerminal) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "inner(isTerminal) " 
 -- ptn:newInvoke: "inner " staticOff: 0 
 -- oPTN:newInvoke: "inner " 101 
 pushThis 
 innerP  2
 rpopThisObj 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS NonTerminal 73 1 Grammar 71
 -- vdtTableCopy: I:1:72 V:2:121 V:3:122 I:4:0
 rShiftUp  1
 tstOriginIsNone 
 rstore  1 origin
 -- super Symbol
 -- computeAdrX:superAdj: 1 "Symbol " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Symbol " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 rpushg Grammar$71 1
 -- computeAdrX:isLast:E:  "Symbol "
 rShiftDown  1
 pushThis 
 rstoreg  printName 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- DI:gen: "id: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: id 
 rtnAlloc 1
 toSuper 72
DO:
 mvStack 
 L1:
 -- OG:before:super.gen: "nonTerminals.insert(this(Nonterminal)) "
 -- handleInv: "nonTerminals.insert(this(Nonterminal)) " staticOff: 0 
 --  doLoad: true useRtnVal: false 
 -- isPtnWithOrigin: "nonTerminals.insert(this(Nonterminal)) " 
 --  "nonTerminals " false "insert(this(Nonterminal)) " true 
 -- needOriginII: "nonTerminals.insert(this(Nonterminal)) " 
 -- E: ObjectInvocation_Unary D: "
 --  nonTerminals: obj Set(#Nonterminal) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  insert:: 
 --     if has(e).not :then 
 --        head := link(e,head)
 --  
 -- needOrigin: true "insert(this(Nonterminal)) " 
 -- exps.range: 2 exps[i]: "nonTerminals " exps[i]: "
 --  insert(this(Nonterminal)) " needOrigin: true 
 -- isConst: "nonTerminals " ObjectInvocation_Unary "
 --  nonTerminals: obj Set(#Nonterminal) " 
 -- isConst:DI: "nonTerminals: obj Set(#Nonterminal) " 
 -- updateOffset: "nonTerminals " E.ATd: "
 --  nonTerminals: obj Set(#Nonterminal) " 
 -- isConst: "insert(this(Nonterminal)) " ObjectInvocation_KeyWord 
 --  insert:: 
 --     if has(e).not :then 
 --        head := link(e,head)
 --  
 -- updateOffset: "insert(this(Nonterminal)) " E.ATd: 
 --  insert:: 
 --     if has(e).not :then 
 --        head := link(e,head)
 --  
 -- loadPathII:E: "nonTerminals " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "nonTerminals " 
 pushThis 
 -- items:goOrigin:encOG: "NonTerminal "on: 1 isValueObj: false 
 --  origin: Grammar origin:isValueObj: false 
 rpushg NonTerminal$73 1
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "nonTerminals " 
 -- DI:loadAccessor: "nonTerminals " 
 -- DI:loadAccessor:Obj: "nonTerminals: obj Set(#Nonterminal) " 
 rpushg newInvoke 2
 -- loadPathII:E: "insert(this(Nonterminal)) " 1 2 exps.range: 2 
 --  staticOff: 0 
 -- E: "insert(this(Nonterminal)) " E:isPrimitiveIntWithFloatArg: 
 --  false rec: "nonTerminals " isFloat: false 
 -- NonVirt: "insert(this(Nonterminal)) " "
 --  ObjectInvocation_KeyWord " ActArg: "this(Nonterminal) "isValue: false formalArg: "
 --  in e: ref elm " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "insert(this(Nonterminal)) "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "this(Nonterminal) "
 -- handleInv: "this(Nonterminal) " staticOff: 0 doLoad: true 
 --  useRtnVal: true 
 -- isPtnWithOrigin: "this(Nonterminal) " 
 --  "this(Nonterminal) " true 
 -- needOriginII: "this(Nonterminal) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  this: 
 --     %basic 18
 --     in this: ref Object
 --  
 -- needOrigin: true "this(Nonterminal) " 
 -- exps.range: 1 exps[i]: "this(Nonterminal) " needOrigin: true 
 -- isConst: "this(Nonterminal) " ObjectInvocation_KeyWord 
 --  this: 
 --     %basic 18
 --     in this: ref Object
 --  
 -- updateOffset: "this(Nonterminal) " E.ATd: 
 --  this: 
 --     %basic 18
 --     in this: ref Object
 --  
 -- loadPathII:E: "this(Nonterminal) " 1 1 exps.range: 1 
 --  staticOff: 0 
 -- loadOriginII: "this(Nonterminal) " 
 pushThis 
 -- loadPathII:before:newInvoke: "this(Nonterminal) " true 
 -- checkForProxy:E: "this(Nonterminal) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "this(Nonterminal) " 
 -- ptn:newInvoke: "this " staticOff: 0 
 -- gPTN:newInvoke: "this " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: none 
 -- invoke:nonVirtual: "this " isAdr: false 
 -- invoke:primitive: "this " 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: true formalArg:isPtn: "in e: ref elm "
 --  :isBasicVal: false :valueObj: false 
 --  :actArg: "this(Nonterminal) ":isBasicVal: false 
 -- case:B: this(Nonterminal) ObjectGenerator 0 18 18 false false 
 -- isIntForFloatArg: "this(Nonterminal) " D: "in e: ref elm " false 
 --  false srcOG.isFloat: false src.isUnitValueObj: false this: "
 --  this(Nonterminal) " false 
 --  B: false 
 --  
 --  this: 
 --     %basic 18
 --     in this: ref Object
 --  
 -- end:loadArgs:NonVirt: "insert(this(Nonterminal)) "
 -- loadPathII:before:newInvoke: "insert(this(Nonterminal)) " true 
 -- checkForProxy:E: "insert(this(Nonterminal)) " isBasicValue: 
 --  false origin.isValueObj: false staticOff: 0 rec: "nonTerminals " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "insert(this(Nonterminal)) " 
 -- ptn:newInvoke: "insert " staticOff: 0 
 -- gPTN:newInvoke: "insert " ptnKind: 3 staticOff: 0 valueOff: 0 
 --  rec: "nonTerminals " 
 -- invoke:Virtual: "insert " E: "insert(this(Nonterminal)) " 
 --  E.ATd.isValueObj: false this:isVal: false rec: "nonTerminals " rec:isConst: 
 --  isStatic: true 
 invoke insert 75 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 rtnInner  M
 END OSDV:0 objSize:3 isIndexed:0

 CLASS print 123 1 NonTerminal 73
 -- vdtTableCopy: I:1:121 I:2:0
 tstOriginIsNone 
 rstore  1 origin
 -- super print
 pushThis 
 rpushg iOrigin 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 rtnAlloc 1
 toSuper 121
DO:
 mvStack 
 L1:
 -- OG:before:super.gen: "put('<') "
 -- handleInv: "put('<') " staticOff: 0 doLoad: true useRtnVal: 
 --  false 
 -- isPtnWithOrigin: "put('<') " 
 --  "put('<') " false 
 -- needOriginII: "put('<') " 
 -- E: ObjectInvocation_KeyWord D: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- needOrigin: false "put('<') " 
 -- exps.range: 1 exps[i]: "put('<') " needOrigin: false 
 -- isConst: "put('<') " ObjectInvocation_KeyWord 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- noOrigin: "put('<') " 
 -- loadPathII:E: "put('<') " 1 1 exps.range: 1 staticOff: 0 
 -- NonVirt: "put('<') " "ObjectInvocation_KeyWord " ActArg: "'<' "
 --  isValue: true formalArg: "in ch: val char " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put('<') " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "'<' "
 -- handleInv: "'<' " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "'<' " 
 --  "'<' " false 
 -- needOriginII: "'<' " 
 -- E: Char: D: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 -- needOrigin: true "'<' " 
 -- exps.range: 1 exps[i]: "'<' " needOrigin: true 
 -- isConst: "'<' " Char: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 -- isConstLiteral: "'<' " 
 pushc 60
 -- const:cst: "'<' " 60 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "'<' ":isBasicVal: true 
 -- case:B: '<' ObjectGenerator 3 3 3 false true 
 -- isIntForFloatArg: "'<' " D: "in ch: val char " false false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "'<' " false 
 --  B: false 
 --  
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 -- end:loadArgs:NonVirt: "put('<') "
 -- loadPathII:before:newInvoke: "put('<') " true 
 -- checkForProxy:E: "put('<') " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "put('<') " 
 -- ptn:newInvoke: "put " staticOff: 0 
 -- oPTN:newInvoke: "put " 2 
 %put 2
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OG:before:super.gen: "printName.print "
 -- handleInv: "printName.print " staticOff: 0 doLoad: true 
 --  useRtnVal: false 
 -- isPtnWithOrigin: "printName.print " 
 --  "printName " false "print " true 
 -- needOriginII: "printName.print " 
 -- E: ObjectInvocation_Unary D: "printName: var String " 
 -- E: ObjectInvocation_Unary D: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeat
 -- needOrigin: true "print " 
 -- exps.range: 2 exps[i]: "printName " exps[i]: "print " 
 --  needOrigin: true 
 -- isConst: "printName " ObjectInvocation_Unary "
 --  printName: var String " 
 -- isConst:DI: "printName: var String " 
 -- updateOffset: "printName " E.ATd: "printName: var String " 
 -- isConst: "print " ObjectInvocation_Unary 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeat
 -- updateOffset: "print " E.ATd: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeat
 -- loadPathII:E: "printName " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "printName " 
 pushThis 
 -- items:goOrigin:encOG: "print "on: 1 isValueObj: false 
 --  origin: NonTerminal origin:isValueObj: false 
 rpushg print$123 1
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "printName " 
 -- DI:loadAccessor: "printName " 
 -- DI:loadAccessor:Obj: "printName: var String " 
 rpushg newInvoke 2
 -- loadPathII:E: "print " 1 2 exps.range: 2 staticOff: 0 
 -- E: "print " E:isPrimitiveIntWithFloatArg: false rec: "
 --  printName " isFloat: false 
 -- loadPathII:before:newInvoke: "print " true 
 -- checkForProxy:E: "print " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: "printName " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "print " 
 -- ptn:newInvoke: "print " staticOff: 0 
 -- gPTN:newInvoke: "print " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: "printName " 
 -- invoke:nonVirtual: "print " isAdr: false 
 invoke print 114 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OG:before:super.gen: "put('>') "
 -- handleInv: "put('>') " staticOff: 0 doLoad: true useRtnVal: 
 --  false 
 -- isPtnWithOrigin: "put('>') " 
 --  "put('>') " false 
 -- needOriginII: "put('>') " 
 -- E: ObjectInvocation_KeyWord D: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- needOrigin: false "put('>') " 
 -- exps.range: 1 exps[i]: "put('>') " needOrigin: false 
 -- isConst: "put('>') " ObjectInvocation_KeyWord 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- noOrigin: "put('>') " 
 -- loadPathII:E: "put('>') " 1 1 exps.range: 1 staticOff: 0 
 -- NonVirt: "put('>') " "ObjectInvocation_KeyWord " ActArg: "'>' "
 --  isValue: true formalArg: "in ch: val char " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put('>') " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "'>' "
 -- handleInv: "'>' " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "'>' " 
 --  "'>' " false 
 -- needOriginII: "'>' " 
 -- E: Char: D: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 -- needOrigin: true "'>' " 
 -- exps.range: 1 exps[i]: "'>' " needOrigin: true 
 -- isConst: "'>' " Char: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 -- isConstLiteral: "'>' " 
 pushc 62
 -- const:cst: "'>' " 62 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "'>' ":isBasicVal: true 
 -- case:B: '>' ObjectGenerator 3 3 3 false true 
 -- isIntForFloatArg: "'>' " D: "in ch: val char " false false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "'>' " false 
 --  B: false 
 --  
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 -- end:loadArgs:NonVirt: "put('>') "
 -- loadPathII:before:newInvoke: "put('>') " true 
 -- checkForProxy:E: "put('>') " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "put('>') " 
 -- ptn:newInvoke: "put " staticOff: 0 
 -- oPTN:newInvoke: "put " 2 
 %put 2
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0

 CLASS nonTerminals 85 0 Grammar 71
 -- vdtTableCopy: I:1:80 V:2:0 V:3:75 V:4:101 V:5:113 V:6:112 V:7:118 V:8:120 I:9:83 I:10:0
 -- super Set
 -- super Set
 allocEventQ
 -- DI:gen: "head: ref link " DI:isConst: false isBasicValue: false 
 --  primNo: 0 
 rtnAlloc 1
 toSuper 80
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0

 CLASS Terminal 86 1 Grammar 71
 -- vdtTableCopy: I:1:72 V:2:121 V:3:122 I:4:0
 rShiftUp  1
 tstOriginIsNone 
 rstore  1 origin
 -- super Symbol
 -- computeAdrX:superAdj: 1 "Symbol " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Symbol " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 rpushg Grammar$71 1
 -- computeAdrX:isLast:E:  "Symbol "
 rShiftDown  1
 pushThis 
 rstoreg  printName 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- DI:gen: "id: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: id 
 rtnAlloc 1
 toSuper 72
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:0 objSize:3 isIndexed:0

 CLASS isTerminal 124 1 Terminal 86
 -- vdtTableCopy: I:1:122 I:2:0
 tstOriginIsNone 
 rstore  1 origin
 -- super isTerminal
 pushThis 
 rpushg iOrigin 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- DI:gen: "out V: var Boolean " DI:isConst: false isBasicValue: 
 --  true primNo: 4 
 -- DI:gen:primitiveType: V 
 rtnAlloc 1
 toSuper 122
DO:
 mvStack 
 L1:
 -- handleAssign: "V := true " 
 -- handleInv: "V " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "V " 
 --  "V " false 
 -- needOriginII: "V " 
 -- E: ObjectInvocation_Unary D: "out V: var Boolean " 
 -- needOrigin: true "V " 
 -- exps.range: 1 exps[i]: "V " needOrigin: true 
 -- isConst: "V " ObjectInvocation_Unary "out V: var Boolean " 
 -- isConst:DI: "out V: var Boolean " 
 -- updateOffset: "V " E.ATd: "out V: var Boolean " 
 -- loadPathII:E: "V " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "V " 
 pushThis 
 -- loadPathII:before:newInvoke: "V " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "V := true " leftE: "V " 
 -- OG:before:super.gen: "true "
 -- handleInv: "true " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "true " 
 --  "true " false 
 -- needOriginII: "true " 
 -- E: ObjectInvocation_Unary D: 
 --  True: 
 --     %globals
 --     out B: var boolean
 --     B := 1
 --  
 -- needOrigin: false "true " 
 -- exps.range: 1 exps[i]: "true " needOrigin: false 
 -- isConst: "true " ObjectInvocation_Unary 
 --  True: 
 --     %globals
 --     out B: var boolean
 --     B := 1
 --  
 -- noOrigin: "true " 
 -- loadPathII:E: "true " 1 1 exps.range: 1 staticOff: 0 
 -- loadPathII:before:newInvoke: "true " true 
 -- checkForProxy:E: "true " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "true " 
 -- ptn:newInvoke: "True " staticOff: 0 
 -- gPTN:newInvoke: "True " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: none 
 -- invoke:nonVirtual: "True " isAdr: false 
 invoke True 23 0 0
 -- global:pushOut: B off: 1 
 pushg 1 
 -- callInvoke:after:pushOut: 1 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "V := true " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- right:isPTN:not:valueObj: "out B: var boolean " 
 -- checkI2F2I: "V := true " left.isFloat: false right.isFloat: 
 --  false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- Assign:end: "V := true " isNotRemote: false qual: 
 --  value
 --     %id "Boolean"
 --     %globals inSub
 --     %basic 4, 8
 --  D: none 
 -- DI:newStore: "V " off: 2 valueOff: 0 dstE: "V " isNotRemote: 
 --  false originIsValueObj: false isUnitValueObj: false rightQual:primNo: 4 
 --  rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 storeg Boolean$42 2
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS print 125 1 Terminal 86
 -- vdtTableCopy: I:1:121 I:2:0
 tstOriginIsNone 
 rstore  1 origin
 -- super print
 pushThis 
 rpushg iOrigin 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 rtnAlloc 1
 toSuper 121
DO:
 mvStack 
 L1:
 -- OG:before:super.gen: "put('"') "
 -- handleInv: "put('"') " staticOff: 0 doLoad: true useRtnVal: 
 --  false 
 -- isPtnWithOrigin: "put('"') " 
 --  "put('"') " false 
 -- needOriginII: "put('"') " 
 -- E: ObjectInvocation_KeyWord D: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- needOrigin: false "put('"') " 
 -- exps.range: 1 exps[i]: "put('"') " needOrigin: false 
 -- isConst: "put('"') " ObjectInvocation_KeyWord 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- noOrigin: "put('"') " 
 -- loadPathII:E: "put('"') " 1 1 exps.range: 1 staticOff: 0 
 -- NonVirt: "put('"') " "ObjectInvocation_KeyWord " ActArg: "'"' "
 --  isValue: true formalArg: "in ch: val char " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put('"') " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "'"' "
 -- handleInv: "'"' " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "'"' " 
 --  "'"' " false 
 -- needOriginII: "'"' " 
 -- E: Char: D: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 -- needOrigin: true "'"' " 
 -- exps.range: 1 exps[i]: "'"' " needOrigin: true 
 -- isConst: "'"' " Char: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 -- isConstLiteral: "'"' " 
 pushc 34
 -- const:cst: "'"' " 34 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "'"' ":isBasicVal: true 
 -- case:B: '"' ObjectGenerator 3 3 3 false true 
 -- isIntForFloatArg: "'"' " D: "in ch: val char " false false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "'"' " false 
 --  B: false 
 --  
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 -- end:loadArgs:NonVirt: "put('"') "
 -- loadPathII:before:newInvoke: "put('"') " true 
 -- checkForProxy:E: "put('"') " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "put('"') " 
 -- ptn:newInvoke: "put " staticOff: 0 
 -- oPTN:newInvoke: "put " 2 
 %put 2
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OG:before:super.gen: "printName.print "
 -- handleInv: "printName.print " staticOff: 0 doLoad: true 
 --  useRtnVal: false 
 -- isPtnWithOrigin: "printName.print " 
 --  "printName " false "print " true 
 -- needOriginII: "printName.print " 
 -- E: ObjectInvocation_Unary D: "printName: var String " 
 -- E: ObjectInvocation_Unary D: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeat
 -- needOrigin: true "print " 
 -- exps.range: 2 exps[i]: "printName " exps[i]: "print " 
 --  needOrigin: true 
 -- isConst: "printName " ObjectInvocation_Unary "
 --  printName: var String " 
 -- isConst:DI: "printName: var String " 
 -- updateOffset: "printName " E.ATd: "printName: var String " 
 -- isConst: "print " ObjectInvocation_Unary 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeat
 -- updateOffset: "print " E.ATd: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeat
 -- loadPathII:E: "printName " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "printName " 
 pushThis 
 -- items:goOrigin:encOG: "print "on: 1 isValueObj: false 
 --  origin: Terminal origin:isValueObj: false 
 rpushg print$125 1
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "printName " 
 -- DI:loadAccessor: "printName " 
 -- DI:loadAccessor:Obj: "printName: var String " 
 rpushg newInvoke 2
 -- loadPathII:E: "print " 1 2 exps.range: 2 staticOff: 0 
 -- E: "print " E:isPrimitiveIntWithFloatArg: false rec: "
 --  printName " isFloat: false 
 -- loadPathII:before:newInvoke: "print " true 
 -- checkForProxy:E: "print " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: "printName " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "print " 
 -- ptn:newInvoke: "print " staticOff: 0 
 -- gPTN:newInvoke: "print " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: "printName " 
 -- invoke:nonVirtual: "print " isAdr: false 
 invoke print 114 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OG:before:super.gen: "put('"') "
 -- handleInv: "put('"') " staticOff: 0 doLoad: true useRtnVal: 
 --  false 
 -- isPtnWithOrigin: "put('"') " 
 --  "put('"') " false 
 -- needOriginII: "put('"') " 
 -- E: ObjectInvocation_KeyWord D: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- needOrigin: false "put('"') " 
 -- exps.range: 1 exps[i]: "put('"') " needOrigin: false 
 -- isConst: "put('"') " ObjectInvocation_KeyWord 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- noOrigin: "put('"') " 
 -- loadPathII:E: "put('"') " 1 1 exps.range: 1 staticOff: 0 
 -- NonVirt: "put('"') " "ObjectInvocation_KeyWord " ActArg: "'"' "
 --  isValue: true formalArg: "in ch: val char " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put('"') " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "'"' "
 -- handleInv: "'"' " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "'"' " 
 --  "'"' " false 
 -- needOriginII: "'"' " 
 -- E: Char: D: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 -- needOrigin: true "'"' " 
 -- exps.range: 1 exps[i]: "'"' " needOrigin: true 
 -- isConst: "'"' " Char: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 -- isConstLiteral: "'"' " 
 pushc 34
 -- const:cst: "'"' " 34 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "'"' ":isBasicVal: true 
 -- case:B: '"' ObjectGenerator 3 3 3 false true 
 -- isIntForFloatArg: "'"' " D: "in ch: val char " false false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "'"' " false 
 --  B: false 
 --  
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 -- end:loadArgs:NonVirt: "put('"') "
 -- loadPathII:before:newInvoke: "put('"') " true 
 -- checkForProxy:E: "put('"') " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "put('"') " 
 -- ptn:newInvoke: "put " staticOff: 0 
 -- oPTN:newInvoke: "put " 2 
 %put 2
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0

 CLASS terminals 88 0 Grammar 71
 -- vdtTableCopy: I:1:80 V:2:0 V:3:75 V:4:101 V:5:113 V:6:112 V:7:118 V:8:120 I:9:83 I:10:0
 -- super Set
 -- super Set
 allocEventQ
 -- DI:gen: "head: ref link " DI:isConst: false isBasicValue: false 
 --  primNo: 0 
 rtnAlloc 1
 toSuper 80
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0

 CLASS OrderedList 92 0 OrderedList 39
 -- vdtTableCopy: I:1:80 V:2:0 V:3:74 V:4:96 V:5:97 V:6:98 V:7:99 V:8:100 I:9:0
 -- super Collection
 allocEventQ
 -- DI:gen: "head: ref link:next " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 -- DI:gen: "tail: ref Link:next " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 rtnAlloc 1
 toSuper 80
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS has 126 1 OrderedList 92
 -- vdtTableCopy: I:1:96 I:2:0
 rShiftUp  1
 tstOriginIsNone 
 rstore  1 origin
 -- super has
 pushThis 
 rpushg iOrigin 1
 rShiftDown  1
 pushThis 
 rstoreg  E 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- DI:gen: "in E: ref elm " DI:isConst: false isBasicValue: false 
 --  primNo: 0 
 -- DI:gen: "out B: var boolean " DI:isConst: false isBasicValue: 
 --  true primNo: 4 
 -- DI:gen:primitiveType: B 
 rtnAlloc 1
 toSuper 96
DO:
 mvStack 
 L1:
 -- handleAssign: "B := false " 
 -- handleInv: "B " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "B " 
 --  "B " false 
 -- needOriginII: "B " 
 -- E: ObjectInvocation_Unary D: "out B: var boolean " 
 -- needOrigin: true "B " 
 -- exps.range: 1 exps[i]: "B " needOrigin: true 
 -- isConst: "B " ObjectInvocation_Unary "out B: var boolean " 
 -- isConst:DI: "out B: var boolean " 
 -- updateOffset: "B " E.ATd: "out B: var boolean " 
 -- loadPathII:E: "B " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "B " 
 pushThis 
 -- loadPathII:before:newInvoke: "B " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "B := false " leftE: "B " 
 -- OG:before:super.gen: "false "
 -- handleInv: "false " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "false " 
 --  "false " false 
 -- needOriginII: "false " 
 -- E: ObjectInvocation_Unary D: 
 --  False: 
 --     %globals
 --     out B: var boolean
 --     B := 0
 --  
 -- needOrigin: false "false " 
 -- exps.range: 1 exps[i]: "false " needOrigin: false 
 -- isConst: "false " ObjectInvocation_Unary 
 --  False: 
 --     %globals
 --     out B: var boolean
 --     B := 0
 --  
 -- noOrigin: "false " 
 -- loadPathII:E: "false " 1 1 exps.range: 1 staticOff: 0 
 -- loadPathII:before:newInvoke: "false " true 
 -- checkForProxy:E: "false " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "false " 
 -- ptn:newInvoke: "False " staticOff: 0 
 -- gPTN:newInvoke: "False " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: none 
 -- invoke:nonVirtual: "False " isAdr: false 
 invoke False 27 0 0
 -- global:pushOut: B off: 1 
 pushg 1 
 -- callInvoke:after:pushOut: 1 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "B := false " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- right:isPTN:not:valueObj: "out B: var boolean " 
 -- checkI2F2I: "B := false " left.isFloat: false right.isFloat: 
 --  false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- Assign:end: "B := false " isNotRemote: false qual: 
 --  value
 --     %id "Boolean"
 --     %globals inSub
 --     %basic 4, 8
 --  D: none 
 -- DI:newStore: "B " off: 3 valueOff: 0 dstE: "B " isNotRemote: 
 --  false originIsValueObj: false isUnitValueObj: false rightQual:primNo: 4 
 --  rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 storeg Boolean$42 3
 pushThis 
 -- before objTmpStack:add:  129   "scan$129 "
 invoke scan$129 129 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 rtnInner  M
 END OSDV:0 objSize:3 isIndexed:0

 CLASS scan 127 1 OrderedList 92
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "current: ref elm " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 -- DI:gen: "nxt: ref Link:next " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- handleAssign: "nxt := head " 
 -- handleInv: "nxt " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "nxt " 
 --  "nxt " false 
 -- needOriginII: "nxt " 
 -- E: ObjectInvocation_Unary D: "nxt: ref Link:next " 
 -- needOrigin: true "nxt " 
 -- exps.range: 1 exps[i]: "nxt " needOrigin: true 
 -- isConst: "nxt " ObjectInvocation_Unary "nxt: ref Link:next " 
 -- isConst:DI: "nxt: ref Link:next " 
 -- updateOffset: "nxt " E.ATd: "nxt: ref Link:next " 
 -- loadPathII:E: "nxt " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "nxt " 
 pushThis 
 -- loadPathII:before:newInvoke: "nxt " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "nxt := head " leftE: "nxt " 
 -- OG:before:super.gen: "head "
 -- handleInv: "head " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "head " 
 --  "head " false 
 -- needOriginII: "head " 
 -- E: ObjectInvocation_Unary D: "head: ref link:next " 
 -- needOrigin: true "head " 
 -- exps.range: 1 exps[i]: "head " needOrigin: true 
 -- isConst: "head " ObjectInvocation_Unary "head: ref link:next " 
 -- isConst:DI: "head: ref link:next " 
 -- updateOffset: "head " E.ATd: "head: ref link:next " 
 -- loadPathII:E: "head " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "head " 
 pushThis 
 -- items:goOrigin:encOG: "scan "on: 1 isValueObj: false 
 --  origin: OrderedList origin:isValueObj: false 
 rpushg scan$127 1
 -- loadPathII:before:newInvoke: "head " true 
 -- checkForProxy:E: "head " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "head " 
 -- DI:newInvoke: "head: ref link:next " off: 1 valueOff: 0 E: "
 --  head " next: none isAdr: false 
 -- DI:newInvoke:loadObj: "head: ref link:next " 
 rpushg newInvoke 1
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "nxt := head " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- checkI2F2I: "nxt := head " left.isFloat: false right.isFloat: 
 --  false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- Assign:end: "nxt := head " isNotRemote: false qual: 
 --  %id "link:next"
 --     ...
 --  
 --  D: none 
 -- DI:newStore: "nxt " off: 3 valueOff: 0 dstE: "nxt " 
 --  isNotRemote: false originIsValueObj: false isUnitValueObj: false 
 --  rightQual:primNo: 0 rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 -- DI:newStore:ref/String: "nxt: ref Link:next " 
 rswap 0
 rstoreg  link:next$128 3
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 pushThis 
 -- before objTmpStack:add:  131   "loop "
 invoke loop 131 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS link:next 128 1 OrderedList 92
 pushThis 
 rstoreg  next 3
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 pushThis 
 rstoreg  E 2
   ;; vTop(0,0)=[] rTop(-4,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS loop 131 1 scan 127
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "
 --  if (nxt =/= none) :then 
 --     current := nxt.E
 --     inner(scan)
 --     nxt := nxt.next
 --     restart(loop) "
 -- handleInv: 
 --  if (nxt =/= none) :then 
 --     current := nxt.E
 --     inner(scan)
 --     nxt := nxt.nextstaticOff: 0 doLoad: true useRtnVal: false 
 -- isPtnWithOrigin: 
 --  if (nxt =/= none) :then 
 --     current := nxt.E
 --     inner(scan)
 --     nxt := nxt.next
 --  
 --  if (nxt =/= none) :then 
 --     current := nxt.E
 --     inner(scan)
 --     nxt := nxt.nextfalse 
 -- needOriginII: 
 --  if (nxt =/= none) :then 
 --     current := nxt.E
 --     inner(scan)
 --     nxt := nxt.next
 -- E: IfThen D: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- needOrigin: false 
 --  if (nxt =/= none) :then 
 --     current := nxt.E
 --     inner(scan)
 --     nxt := nxt.next
 -- exps.range: 1 exps[i]: 
 --  if (nxt =/= none) :then 
 --     current := nxt.E
 --     inner(scan)
 --     nxt := nxt.nextneedOrigin: false 
 -- isConst: 
 --  if (nxt =/= none) :then 
 --     current := nxt.E
 --     inner(scan)
 --     nxt := nxt.nextIfThen 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- noOrigin: 
 --  if (nxt =/= none) :then 
 --     current := nxt.E
 --     inner(scan)
 --     nxt := nxt.next
 -- loadPathII:E: 
 --  if (nxt =/= none) :then 
 --     current := nxt.E
 --     inner(scan)
 --     nxt := nxt.next1 1 exps.range: 1 staticOff: 0 
 -- loadPathII:before:newInvoke: 
 --  if (nxt =/= none) :then 
 --     current := nxt.E
 --     inner(scan)
 --     nxt := nxt.nexttrue 
 -- checkForProxy:E: 
 --  if (nxt =/= none) :then 
 --     current := nxt.E
 --     inner(scan)
 --     nxt := nxt.nextisBasicValue: false origin.isValueObj: false staticOff: 0 rec: 
 --  none 
 -- loadPathII:next: 1 1 
 -- IfThen:newInvoke: 
 --  if (nxt =/= none) :then 
 --     current := nxt.E
 --     inner(scan)
 --     nxt := nxt.next
 -- OG:before:super.gen: "(nxt =/= none) "
 -- handleInv: "(nxt =/= none) " staticOff: 0 doLoad: true 
 --  useRtnVal: true 
 -- isPtnWithOrigin: "(nxt =/= none) " 
 --  "nxt " false "=/= none " true 
 -- needOriginII: "(nxt =/= none) " 
 -- E: ObjectInvocation_Unary D: "nxt: ref Link:next " 
 -- E: ObjectInvocation_Binary D: 
 --  =/=  : 
 --     %basic 57
 --     in objx: ref Object
 --     out V: var boolean
 --  
 -- needOrigin: true "=/= none " 
 -- exps.range: 2 exps[i]: "nxt " exps[i]: "=/= none " needOrigin: 
 --  true 
 -- isConst: "nxt " ObjectInvocation_Unary "nxt: ref Link:next " 
 -- isConst:DI: "nxt: ref Link:next " 
 -- updateOffset: "nxt " E.ATd: "nxt: ref Link:next " 
 -- isConst: "=/= none " ObjectInvocation_Binary 
 --  =/=  : 
 --     %basic 57
 --     in objx: ref Object
 --     out V: var boolean
 --  
 -- updateOffset: "=/= none " E.ATd: 
 --  =/=  : 
 --     %basic 57
 --     in objx: ref Object
 --     out V: var boolean
 --  
 -- loadPathII:E: "nxt " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "nxt " 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: scan origin:isValueObj: false 
 rpushg loop$131 1
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "nxt " 
 -- DI:loadAccessor: "nxt " 
 -- DI:loadAccessor:Obj: "nxt: ref Link:next " 
 rpushg newInvoke 3
 -- loadPathII:E: "=/= none " 1 2 exps.range: 2 staticOff: 0 
 -- E: "=/= none " E:isPrimitiveIntWithFloatArg: false rec: "nxt " 
 --  isFloat: false 
 -- NonVirt: "=/= none " "ObjectInvocation_Binary " ActArg: "none "
 --  isValue: false formalArg: "in objx: ref Object " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "=/= none " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "none "
 -- handleInv: "none " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "none " 
 --  "none " true 
 -- needOriginII: "none " 
 -- E: ObjectInvocation_Unary D: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  
 -- needOrigin: true "none " 
 -- exps.range: 1 exps[i]: "none " needOrigin: true 
 -- isConst: "none " ObjectInvocation_Unary 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  
 -- updateOffset: "none " E.ATd: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  
 -- loadPathII:E: "none " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "none " 
 -- loadPathII:before:newInvoke: "none " true 
 -- checkForProxy:E: "none " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "none " 
 -- ptn:newInvoke: "none " staticOff: 0 
 -- oPTN:newInvoke: "none " 19 
 pushNone 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: true formalArg:isPtn: "in objx: ref Object "
 --  :isBasicVal: false :valueObj: false 
 --  :actArg: "none ":isBasicVal: false 
 -- case:B: none ObjectGenerator 64 19 19 false false 
 -- isIntForFloatArg: "none " D: "in objx: ref Object " false false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "none " false 
 --  B: false 
 --  
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  
 -- end:loadArgs:NonVirt: "=/= none "
 -- loadPathII:before:newInvoke: "=/= none " true 
 -- checkForProxy:E: "=/= none " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: "nxt " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "=/= none " 
 -- ptn:newInvoke: "=/=   " staticOff: 0 
 -- gPTN:newInvoke: "=/=   " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: "nxt " 
 -- checkInt2IntWithUnitArg:E: "=/= none " false false 
 rne
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  132   "$132 "
 invoke $132 132 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $132 132 1 loop 131
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- handleAssign: "current := nxt.E " 
 -- handleInv: "current " staticOff: 0 doLoad: false useRtnVal: 
 --  false 
 -- isPtnWithOrigin: "current " 
 --  "current " false 
 -- needOriginII: "current " 
 -- E: ObjectInvocation_Unary D: "current: ref elm " 
 -- needOrigin: true "current " 
 -- exps.range: 1 exps[i]: "current " needOrigin: true 
 -- isConst: "current " ObjectInvocation_Unary "current: ref elm " 
 -- isConst:DI: "current: ref elm " 
 -- updateOffset: "current " E.ATd: "current: ref elm " 
 -- loadPathII:E: "current " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "current " 
 pushThis 
 -- items:goOrigin:encOG: "$132 "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $132$132 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: scan origin:isValueObj: false 
 rpushg loop$131 1
 -- loadPathII:before:newInvoke: "current " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "current := nxt.E " leftE: "current " 
 -- OG:before:super.gen: "nxt.E "
 -- handleInv: "nxt.E " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "nxt.E " 
 --  "nxt " false "E " false 
 -- needOriginII: "nxt.E " 
 -- E: ObjectInvocation_Unary D: "nxt: ref Link:next " 
 -- E: ObjectInvocation_Unary D: "E: ref Elm " 
 -- needOrigin: true "E " 
 -- exps.range: 2 exps[i]: "nxt " exps[i]: "E " needOrigin: true 
 -- isConst: "nxt " ObjectInvocation_Unary "nxt: ref Link:next " 
 -- isConst:DI: "nxt: ref Link:next " 
 -- updateOffset: "nxt " E.ATd: "nxt: ref Link:next " 
 -- isConst: "E " ObjectInvocation_Unary "E: ref Elm " 
 -- isConst:DI: "E: ref Elm " 
 -- updateOffset: "E " E.ATd: "E: ref Elm " 
 -- loadPathII:E: "nxt " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "nxt " 
 pushThis 
 -- items:goOrigin:encOG: "$132 "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $132$132 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: scan origin:isValueObj: false 
 rpushg loop$131 1
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "nxt " 
 -- DI:loadAccessor: "nxt " 
 -- DI:loadAccessor:Obj: "nxt: ref Link:next " 
 rpushg newInvoke 3
 -- loadPathII:E: "E " 1 2 exps.range: 2 staticOff: 0 
 -- E: "E " E:isPrimitiveIntWithFloatArg: false rec: "nxt " isFloat: 
 --  false 
 -- loadPathII:before:newInvoke: "E " true 
 -- checkForProxy:E: "E " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: "nxt " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "E " 
 -- DI:newInvoke: "E: ref Elm " off: 2 valueOff: 0 E: "E " next: 
 --  none isAdr: false 
 -- DI:newInvoke:loadObj: "E: ref Elm " 
 rpushg newInvoke 2
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "current := nxt.E " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- "E " 
 -- "E " 
 -- checkI2F2I: "current := nxt.E " left.isFloat: false 
 --  right.isFloat: false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- "E " 
 -- "E " 
 -- Assign:end: "current := nxt.E " isNotRemote: false qual: 
 --  %ID Object
 --     %basic 64
 --     %public
 --     ==  : 
 --  D: none 
 -- DI:newStore: "current " off: 2 valueOff: 0 dstE: "current " 
 --  isNotRemote: false originIsValueObj: false isUnitValueObj: false 
 --  rightQual:primNo: 64 rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 -- DI:newStore:ref/String: "current: ref elm " 
 rswap 0
 rstoreg  Object$0 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- OG:before:super.gen: "inner(scan) "
 -- handleInv: "inner(scan) " staticOff: 0 doLoad: true useRtnVal: 
 --  false 
 -- isPtnWithOrigin: "inner(scan) " 
 --  "inner(scan) " true 
 -- needOriginII: "inner(scan) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- needOrigin: true "inner(scan) " 
 -- exps.range: 1 exps[i]: "inner(scan) " needOrigin: true 
 -- isConst: "inner(scan) " ObjectInvocation_KeyWord 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- updateOffset: "inner(scan) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- loadPathII:E: "inner(scan) " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "inner(scan) " 
 -- loadPathII:before:newInvoke: "inner(scan) " true 
 -- checkForProxy:E: "inner(scan) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "inner(scan) " 
 -- ptn:newInvoke: "inner " staticOff: 0 
 -- oPTN:newInvoke: "inner " 101 
 pushThis 
 -- items:goOrigin:encOG: "$132 "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $132$132 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: scan origin:isValueObj: false 
 rpushg loop$131 1
 innerP  2
 rpopThisObj 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign: "nxt := nxt.next " 
 -- handleInv: "nxt " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "nxt " 
 --  "nxt " false 
 -- needOriginII: "nxt " 
 -- E: ObjectInvocation_Unary D: "nxt: ref Link:next " 
 -- needOrigin: true "nxt " 
 -- exps.range: 1 exps[i]: "nxt " needOrigin: true 
 -- isConst: "nxt " ObjectInvocation_Unary "nxt: ref Link:next " 
 -- isConst:DI: "nxt: ref Link:next " 
 -- updateOffset: "nxt " E.ATd: "nxt: ref Link:next " 
 -- loadPathII:E: "nxt " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "nxt " 
 pushThis 
 -- items:goOrigin:encOG: "$132 "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $132$132 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: scan origin:isValueObj: false 
 rpushg loop$131 1
 -- loadPathII:before:newInvoke: "nxt " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "nxt := nxt.next " leftE: "nxt " 
 -- OG:before:super.gen: "nxt.next "
 -- handleInv: "nxt.next " staticOff: 0 doLoad: true useRtnVal: 
 --  true 
 -- isPtnWithOrigin: "nxt.next " 
 --  "nxt " false "next " false 
 -- needOriginII: "nxt.next " 
 -- E: ObjectInvocation_Unary D: "nxt: ref Link:next " 
 -- E: ObjectInvocation_Unary D: "next: ref Link:next " 
 -- needOrigin: true "next " 
 -- exps.range: 2 exps[i]: "nxt " exps[i]: "next " needOrigin: true 
 -- isConst: "nxt " ObjectInvocation_Unary "nxt: ref Link:next " 
 -- isConst:DI: "nxt: ref Link:next " 
 -- updateOffset: "nxt " E.ATd: "nxt: ref Link:next " 
 -- isConst: "next " ObjectInvocation_Unary "next: ref Link:next " 
 -- isConst:DI: "next: ref Link:next " 
 -- updateOffset: "next " E.ATd: "next: ref Link:next " 
 -- loadPathII:E: "nxt " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "nxt " 
 pushThis 
 -- items:goOrigin:encOG: "$132 "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $132$132 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: scan origin:isValueObj: false 
 rpushg loop$131 1
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "nxt " 
 -- DI:loadAccessor: "nxt " 
 -- DI:loadAccessor:Obj: "nxt: ref Link:next " 
 rpushg newInvoke 3
 -- loadPathII:E: "next " 1 2 exps.range: 2 staticOff: 0 
 -- E: "next " E:isPrimitiveIntWithFloatArg: false rec: "nxt " 
 --  isFloat: false 
 -- loadPathII:before:newInvoke: "next " true 
 -- checkForProxy:E: "next " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: "nxt " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "next " 
 -- DI:newInvoke: "next: ref Link:next " off: 3 valueOff: 0 E: "
 --  next " next: none isAdr: false 
 -- DI:newInvoke:loadObj: "next: ref Link:next " 
 rpushg newInvoke 3
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "nxt := nxt.next " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- "next " 
 -- "next " 
 -- checkI2F2I: "nxt := nxt.next " left.isFloat: false 
 --  right.isFloat: false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- "next " 
 -- "next " 
 -- Assign:end: "nxt := nxt.next " isNotRemote: false qual: 
 --  %id "link:next"
 --     ...
 --  
 --  D: none 
 -- DI:newStore: "nxt " off: 3 valueOff: 0 dstE: "nxt " 
 --  isNotRemote: false originIsValueObj: false isUnitValueObj: false 
 --  rightQual:primNo: 0 rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 -- DI:newStore:ref/String: "nxt: ref Link:next " 
 rswap 0
 rstoreg  link:next$128 3
   ;; vTop(0,0)=[] rTop(-4,0)=[]
 -- OG:before:super.gen: "restart(loop) "
 -- handleInv: "restart(loop) " staticOff: 0 doLoad: true 
 --  useRtnVal: false 
 -- isPtnWithOrigin: "restart(loop) " 
 --  "restart(loop) " true 
 -- needOriginII: "restart(loop) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  
 -- needOrigin: true "restart(loop) " 
 -- exps.range: 1 exps[i]: "restart(loop) " needOrigin: true 
 -- isConst: "restart(loop) " ObjectInvocation_KeyWord 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  
 -- updateOffset: "restart(loop) " E.ATd: 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  
 -- loadPathII:E: "restart(loop) " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "restart(loop) " 
 -- loadPathII:before:newInvoke: "restart(loop) " true 
 -- checkForProxy:E: "restart(loop) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "restart(loop) " 
 -- ptn:newInvoke: "restart(V: var integer) " staticOff: 0 
 -- bPTN:newInvoke: "restart(V: var integer) " 
 break  1 1 131 0
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS scan$129 129 4 has 126
 -- vdtTableCopy: I:1:127 I:2:0
 tstOriginIsNone 
 rstore  4 origin
 -- super scan
 -- computeAdrX:superAdj: 4 "scan " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "scan " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 rpushg has$126 4
 -- items:goOrigin:encOG: "has "on: 1 isValueObj: false 
 --  origin: OrderedList origin:isValueObj: false 
 rpushg has$126 1
 -- computeAdrX:isLast:E:  "scan "
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- DI:gen: "current: ref elm " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 -- DI:gen: "nxt: ref Link:next " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 rtnAlloc 1
 toSuper 127
DO:
 mvStack 
 L1:
 -- OG:before:super.gen: "
 --  if (current == e) :then 
 --     B := true
 --     leave(has) "
 -- handleInv: 
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  staticOff: 0 doLoad: true useRtnVal: false 
 -- isPtnWithOrigin: 
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  
 --  
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  false 
 -- needOriginII: 
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  
 -- E: IfThen D: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- needOrigin: false 
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  
 -- exps.range: 1 exps[i]: 
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  needOrigin: false 
 -- isConst: 
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  IfThen 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- noOrigin: 
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  
 -- loadPathII:E: 
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  1 1 exps.range: 1 staticOff: 0 
 -- loadPathII:before:newInvoke: 
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  true 
 -- checkForProxy:E: 
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  isBasicValue: false origin.isValueObj: false staticOff: 0 rec: 
 --  none 
 -- loadPathII:next: 1 1 
 -- IfThen:newInvoke: 
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  
 -- OG:before:super.gen: "(current == e) "
 -- handleInv: "(current == e) " staticOff: 0 doLoad: true 
 --  useRtnVal: true 
 -- isPtnWithOrigin: "(current == e) " 
 --  "current " false "== e " true 
 -- needOriginII: "(current == e) " 
 -- E: ObjectInvocation_Unary D: "current: ref elm " 
 -- E: ObjectInvocation_Binary D: 
 --  ==  : 
 --     %basic 56
 --     in objx: ref Object
 --     out V: var boolean
 --  
 -- needOrigin: true "== e " 
 -- exps.range: 2 exps[i]: "current " exps[i]: "== e " needOrigin: 
 --  true 
 -- isConst: "current " ObjectInvocation_Unary "current: ref elm " 
 -- isConst:DI: "current: ref elm " 
 -- updateOffset: "current " E.ATd: "current: ref elm " 
 -- isConst: "== e " ObjectInvocation_Binary 
 --  ==  : 
 --     %basic 56
 --     in objx: ref Object
 --     out V: var boolean
 --  
 -- updateOffset: "== e " E.ATd: 
 --  ==  : 
 --     %basic 56
 --     in objx: ref Object
 --     out V: var boolean
 --  
 -- loadPathII:E: "current " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "current " 
 pushThis 
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "current " 
 -- DI:loadAccessor: "current " 
 -- DI:loadAccessor:Obj: "current: ref elm " 
 rpushg newInvoke 2
 -- loadPathII:E: "== e " 1 2 exps.range: 2 staticOff: 0 
 -- E: "== e " E:isPrimitiveIntWithFloatArg: false rec: "current " 
 --  isFloat: false 
 -- NonVirt: "== e " "ObjectInvocation_Binary " ActArg: "e "isValue: 
 --  false formalArg: "in objx: ref Object " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "== e " isCompositeValueObj: false 
 -- OG:before:super.gen: "e "
 -- handleInv: "e " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "e " 
 --  "e " false 
 -- needOriginII: "e " 
 -- E: ObjectInvocation_Unary D: "in E: ref elm " 
 -- needOrigin: true "e " 
 -- exps.range: 1 exps[i]: "e " needOrigin: true 
 -- isConst: "e " ObjectInvocation_Unary "in E: ref elm " 
 -- isConst:DI: "in E: ref elm " 
 -- updateOffset: "e " E.ATd: "in E: ref elm " 
 -- loadPathII:E: "e " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "e " 
 pushThis 
 -- items:goOrigin:encOG: "scan$129 "on: 1 isValueObj: false 
 --  origin: has origin:isValueObj: false 
 rpushg scan$129$129 4
 -- loadPathII:before:newInvoke: "e " true 
 -- checkForProxy:E: "e " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "e " 
 -- DI:newInvoke: "in E: ref elm " off: 2 valueOff: 0 E: "e " 
 --  next: none isAdr: false 
 -- DI:newInvoke:loadObj: "in E: ref elm " 
 rpushg newInvoke 2
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: false formalArg:isPtn: "in objx: ref Object "
 --  :isBasicVal: false :valueObj: false 
 --  :actArg: "e ":isBasicVal: false 
 -- case:B: e ObjectGenerator 64 0 64 false false 
 -- isIntForFloatArg: "e " D: "in objx: ref Object " false false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "e " 
 --  B: false 
 --  "in E: ref elm " 
 -- end:loadArgs:NonVirt: "== e "
 -- loadPathII:before:newInvoke: "== e " true 
 -- checkForProxy:E: "== e " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: "current " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "== e " 
 -- ptn:newInvoke: "==   " staticOff: 0 
 -- gPTN:newInvoke: "==   " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: "current " 
 -- checkInt2IntWithUnitArg:E: "== e " false false 
 req
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  130   "$130 "
 invoke $130 130 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 rtnInner  M
 END OSDV:0 objSize:4 isIndexed:0

 CLASS $130 130 1 scan$129 129
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- handleAssign: "B := true " 
 -- handleInv: "B " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "B " 
 --  "B " false 
 -- needOriginII: "B " 
 -- E: ObjectInvocation_Unary D: "out B: var boolean " 
 -- needOrigin: true "B " 
 -- exps.range: 1 exps[i]: "B " needOrigin: true 
 -- isConst: "B " ObjectInvocation_Unary "out B: var boolean " 
 -- isConst:DI: "out B: var boolean " 
 -- updateOffset: "B " E.ATd: "out B: var boolean " 
 -- loadPathII:E: "B " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "B " 
 pushThis 
 -- items:goOrigin:encOG: "$130 "on: 2 isValueObj: false 
 --  origin: scan$129 origin:isValueObj: false 
 rpushg $130$130 1
 -- items:goOrigin:encOG: "scan$129 "on: 1 isValueObj: false 
 --  origin: has origin:isValueObj: false 
 rpushg scan$129$129 4
 -- loadPathII:before:newInvoke: "B " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "B := true " leftE: "B " 
 -- OG:before:super.gen: "true "
 -- handleInv: "true " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "true " 
 --  "true " false 
 -- needOriginII: "true " 
 -- E: ObjectInvocation_Unary D: 
 --  True: 
 --     %globals
 --     out B: var boolean
 --     B := 1
 --  
 -- needOrigin: false "true " 
 -- exps.range: 1 exps[i]: "true " needOrigin: false 
 -- isConst: "true " ObjectInvocation_Unary 
 --  True: 
 --     %globals
 --     out B: var boolean
 --     B := 1
 --  
 -- noOrigin: "true " 
 -- loadPathII:E: "true " 1 1 exps.range: 1 staticOff: 0 
 -- loadPathII:before:newInvoke: "true " true 
 -- checkForProxy:E: "true " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "true " 
 -- ptn:newInvoke: "True " staticOff: 0 
 -- gPTN:newInvoke: "True " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: none 
 -- invoke:nonVirtual: "True " isAdr: false 
 invoke True 23 0 0
 -- global:pushOut: B off: 1 
 pushg 1 
 -- callInvoke:after:pushOut: 1 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "B := true " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- right:isPTN:not:valueObj: "out B: var boolean " 
 -- checkI2F2I: "B := true " left.isFloat: false right.isFloat: 
 --  false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- Assign:end: "B := true " isNotRemote: false qual: 
 --  value
 --     %id "Boolean"
 --     %globals inSub
 --     %basic 4, 8
 --  D: none 
 -- DI:newStore: "B " off: 3 valueOff: 0 dstE: "B " isNotRemote: 
 --  false originIsValueObj: false isUnitValueObj: false rightQual:primNo: 4 
 --  rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 storeg Boolean$42 3
 -- OG:before:super.gen: "leave(has) "
 -- handleInv: "leave(has) " staticOff: 0 doLoad: true useRtnVal: 
 --  false 
 -- isPtnWithOrigin: "leave(has) " 
 --  "leave(has) " true 
 -- needOriginII: "leave(has) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- needOrigin: true "leave(has) " 
 -- exps.range: 1 exps[i]: "leave(has) " needOrigin: true 
 -- isConst: "leave(has) " ObjectInvocation_KeyWord 
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- updateOffset: "leave(has) " E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- loadPathII:E: "leave(has) " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "leave(has) " 
 -- loadPathII:before:newInvoke: "leave(has) " true 
 -- checkForProxy:E: "leave(has) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "leave(has) " 
 -- ptn:newInvoke: "leave(V: var integer) " staticOff: 0 
 -- bPTN:newInvoke: "leave(V: var integer) " 
 break  2 2 96 1
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS isEmpty 133 1 OrderedList 92
 -- vdtTableCopy: I:1:98 I:2:0
 tstOriginIsNone 
 rstore  1 origin
 -- super isEmpty
 pushThis 
 rpushg iOrigin 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 rtnAlloc 1
 toSuper 98
DO:
 mvStack 
 L1:
 -- handleAssign: "B := head == none " 
 -- handleInv: "B " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "B " 
 --  "B " false 
 -- needOriginII: "B " 
 -- E: ObjectInvocation_Unary D: "B: var Boolean " 
 -- needOrigin: true "B " 
 -- exps.range: 1 exps[i]: "B " needOrigin: true 
 -- isConst: "B " ObjectInvocation_Unary "B: var Boolean " 
 -- isConst:DI: "B: var Boolean " 
 -- updateOffset: "B " E.ATd: "B: var Boolean " 
 -- loadPathII:E: "B " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "B " 
 pushThis 
 -- loadPathII:before:newInvoke: "B " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "B := head == none " leftE: "B " 
 -- OG:before:super.gen: "head == none "
 -- handleInv: "head == none " staticOff: 0 doLoad: true useRtnVal: 
 --  true 
 -- isPtnWithOrigin: "head == none " 
 --  "head " false "== none " true 
 -- needOriginII: "head == none " 
 -- E: ObjectInvocation_Unary D: "head: ref link:next " 
 -- E: ObjectInvocation_Binary D: 
 --  ==  : 
 --     %basic 56
 --     in objx: ref Object
 --     out V: var boolean
 --  
 -- needOrigin: true "== none " 
 -- exps.range: 2 exps[i]: "head " exps[i]: "== none " needOrigin: 
 --  true 
 -- isConst: "head " ObjectInvocation_Unary "head: ref link:next " 
 -- isConst:DI: "head: ref link:next " 
 -- updateOffset: "head " E.ATd: "head: ref link:next " 
 -- isConst: "== none " ObjectInvocation_Binary 
 --  ==  : 
 --     %basic 56
 --     in objx: ref Object
 --     out V: var boolean
 --  
 -- updateOffset: "== none " E.ATd: 
 --  ==  : 
 --     %basic 56
 --     in objx: ref Object
 --     out V: var boolean
 --  
 -- loadPathII:E: "head " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "head " 
 pushThis 
 -- items:goOrigin:encOG: "isEmpty "on: 1 isValueObj: false 
 --  origin: OrderedList origin:isValueObj: false 
 rpushg isEmpty$133 1
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "head " 
 -- DI:loadAccessor: "head " 
 -- DI:loadAccessor:Obj: "head: ref link:next " 
 rpushg newInvoke 1
 -- loadPathII:E: "== none " 1 2 exps.range: 2 staticOff: 0 
 -- E: "== none " E:isPrimitiveIntWithFloatArg: false rec: "head " 
 --  isFloat: false 
 -- NonVirt: "== none " "ObjectInvocation_Binary " ActArg: "none "
 --  isValue: false formalArg: "in objx: ref Object " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "== none " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "none "
 -- handleInv: "none " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "none " 
 --  "none " true 
 -- needOriginII: "none " 
 -- E: ObjectInvocation_Unary D: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  
 -- needOrigin: true "none " 
 -- exps.range: 1 exps[i]: "none " needOrigin: true 
 -- isConst: "none " ObjectInvocation_Unary 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  
 -- updateOffset: "none " E.ATd: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  
 -- loadPathII:E: "none " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "none " 
 -- loadPathII:before:newInvoke: "none " true 
 -- checkForProxy:E: "none " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "none " 
 -- ptn:newInvoke: "none " staticOff: 0 
 -- oPTN:newInvoke: "none " 19 
 pushNone 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: true formalArg:isPtn: "in objx: ref Object "
 --  :isBasicVal: false :valueObj: false 
 --  :actArg: "none ":isBasicVal: false 
 -- case:B: none ObjectGenerator 64 19 19 false false 
 -- isIntForFloatArg: "none " D: "in objx: ref Object " false false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "none " false 
 --  B: false 
 --  
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  
 -- end:loadArgs:NonVirt: "== none "
 -- loadPathII:before:newInvoke: "== none " true 
 -- checkForProxy:E: "== none " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: "head " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "== none " 
 -- ptn:newInvoke: "==   " staticOff: 0 
 -- gPTN:newInvoke: "==   " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: "head " 
 -- checkInt2IntWithUnitArg:E: "== none " false false 
 req
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "B := head == none " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- right:isPTN:not:valueObj: "out V: var boolean " 
 -- "== none " 
 -- "== none " 
 -- checkI2F2I: "B := head == none " left.isFloat: false 
 --  right.isFloat: false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- "== none " 
 -- "== none " 
 -- Assign:end: "B := head == none " isNotRemote: false qual: 
 --  value
 --     %id "Boolean"
 --     %globals inSub
 --     %basic 4, 8
 --  D: none 
 -- DI:newStore: "B " off: 2 valueOff: 0 dstE: "B " isNotRemote: 
 --  false originIsValueObj: false isUnitValueObj: false rightQual:primNo: 4 
 --  rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 storeg Boolean$42 2
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS size 134 1 OrderedList 92
 -- vdtTableCopy: I:1:99 I:2:0
 tstOriginIsNone 
 rstore  1 origin
 -- super size
 pushThis 
 rpushg iOrigin 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 rtnAlloc 1
 toSuper 99
DO:
 mvStack 
 L1:
 pushThis 
 -- before objTmpStack:add:  135   "scan$135 "
 invoke scan$135 135 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS scan$135 135 4 size 134
 -- vdtTableCopy: I:1:127 I:2:0
 tstOriginIsNone 
 rstore  4 origin
 -- super scan
 -- computeAdrX:superAdj: 4 "scan " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "scan " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 rpushg size$134 4
 -- items:goOrigin:encOG: "size "on: 1 isValueObj: false 
 --  origin: OrderedList origin:isValueObj: false 
 rpushg size$134 1
 -- computeAdrX:isLast:E:  "scan "
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- DI:gen: "current: ref elm " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 -- DI:gen: "nxt: ref Link:next " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 rtnAlloc 1
 toSuper 127
DO:
 mvStack 
 L1:
 -- handleAssign: "N := N + 1 " 
 -- handleInv: "N " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "N " 
 --  "N " false 
 -- needOriginII: "N " 
 -- E: ObjectInvocation_Unary D: "N: var integer " 
 -- needOrigin: true "N " 
 -- exps.range: 1 exps[i]: "N " needOrigin: true 
 -- isConst: "N " ObjectInvocation_Unary "N: var integer " 
 -- isConst:DI: "N: var integer " 
 -- updateOffset: "N " E.ATd: "N: var integer " 
 -- loadPathII:E: "N " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "N " 
 pushThis 
 -- items:goOrigin:encOG: "scan$135 "on: 1 isValueObj: false 
 --  origin: size origin:isValueObj: false 
 rpushg scan$135$135 4
 -- loadPathII:before:newInvoke: "N " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "N := N + 1 " leftE: "N " 
 -- OG:before:super.gen: "N + 1 "
 -- handleInv: "N + 1 " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "N + 1 " 
 --  "N " false "+ 1 " true 
 -- needOriginII: "N + 1 " 
 -- E: ObjectInvocation_Unary D: "N: var integer " 
 -- E: ObjectInvocation_Binary D: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- needOrigin: true "+ 1 " 
 -- exps.range: 2 exps[i]: "N " exps[i]: "+ 1 " needOrigin: true 
 -- isConst: "N " ObjectInvocation_Unary "N: var integer " 
 -- isConst:DI: "N: var integer " 
 -- updateOffset: "N " E.ATd: "N: var integer " 
 -- isConst: "+ 1 " ObjectInvocation_Binary 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- updateOffset: "+ 1 " E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- loadPathII:E: "N " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "N " 
 pushThis 
 -- items:goOrigin:encOG: "scan$135 "on: 1 isValueObj: false 
 --  origin: size origin:isValueObj: false 
 rpushg scan$135$135 4
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "N " 
 -- DI:loadAccessor: "N " 
 -- DI:loadAccesor:loadPrimitive: "N " 
 pushg 2 newInvoke
 -- loadPathII:E: "+ 1 " 1 2 exps.range: 2 staticOff: 0 
 -- E: "+ 1 " E:isPrimitiveIntWithFloatArg: false rec: "N " isFloat: 
 --  false 
 -- NonVirt: "+ 1 " "ObjectInvocation_Binary " ActArg: "1 "isValue: 
 --  true formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ 1 " isCompositeValueObj: false 
 -- OG:before:super.gen: "1 "
 -- handleInv: "1 " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "1 " 
 --  "1 " false 
 -- needOriginII: "1 " 
 -- E: ConstLiteral D: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- needOrigin: true "1 " 
 -- exps.range: 1 exps[i]: "1 " needOrigin: true 
 -- isConst: "1 " ConstLiteral 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- isConstLiteral: "1 " 
 pushc 1
 -- const:cst: "1 " 1 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- isIntForFloatArg: "1 " D: "in V: var integer " true false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "1 " false 
 --  B: false 
 --  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- end:loadArgs:NonVirt: "+ 1 "
 -- loadPathII:before:newInvoke: "+ 1 " true 
 -- checkForProxy:E: "+ 1 " isBasicValue: true origin.isValueObj: 
 --  true staticOff: 0 rec: "N " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "+ 1 " 
 -- ptn:newInvoke: "+   " staticOff: 0 
 -- gPTN:newInvoke: "+   " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: "N " 
 -- checkInt2IntWithUnitArg:E: "+ 1 " false false 
 plus
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "N := N + 1 " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- right:isPTN:not:valueObj: "out R: var integer " 
 -- "+ 1 " 
 -- "+ 1 " 
 -- checkI2F2I: "N := N + 1 " left.isFloat: false right.isFloat: 
 --  false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- "+ 1 " 
 -- "+ 1 " 
 -- Assign:end: "N := N + 1 " isNotRemote: false qual: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  D: none 
 -- DI:newStore: "N " off: 2 valueOff: 0 dstE: "N " isNotRemote: 
 --  false originIsValueObj: false isUnitValueObj: false rightQual:primNo: 1 
 --  rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 storeg integer$5 2
 L2:
 rtnInner  M
 END OSDV:0 objSize:4 isIndexed:0

 CLASS clear 136 1 OrderedList 92
 -- vdtTableCopy: I:1:100 I:2:0
 tstOriginIsNone 
 rstore  1 origin
 -- super clear
 pushThis 
 rpushg iOrigin 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 rtnAlloc 1
 toSuper 100
DO:
 mvStack 
 L1:
 -- handleAssign: "head := none " 
 -- handleInv: "head " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "head " 
 --  "head " false 
 -- needOriginII: "head " 
 -- E: ObjectInvocation_Unary D: "head: ref link:next " 
 -- needOrigin: true "head " 
 -- exps.range: 1 exps[i]: "head " needOrigin: true 
 -- isConst: "head " ObjectInvocation_Unary "head: ref link:next " 
 -- isConst:DI: "head: ref link:next " 
 -- updateOffset: "head " E.ATd: "head: ref link:next " 
 -- loadPathII:E: "head " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "head " 
 pushThis 
 -- items:goOrigin:encOG: "clear "on: 1 isValueObj: false 
 --  origin: OrderedList origin:isValueObj: false 
 rpushg clear$136 1
 -- loadPathII:before:newInvoke: "head " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "head := none " leftE: "head " 
 -- OG:before:super.gen: "none "
 -- handleInv: "none " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "none " 
 --  "none " true 
 -- needOriginII: "none " 
 -- E: ObjectInvocation_Unary D: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  
 -- needOrigin: true "none " 
 -- exps.range: 1 exps[i]: "none " needOrigin: true 
 -- isConst: "none " ObjectInvocation_Unary 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  
 -- updateOffset: "none " E.ATd: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  
 -- loadPathII:E: "none " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "none " 
 -- loadPathII:before:newInvoke: "none " true 
 -- checkForProxy:E: "none " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "none " 
 -- ptn:newInvoke: "none " staticOff: 0 
 -- oPTN:newInvoke: "none " 19 
 pushNone 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "head := none " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- checkI2F2I: "head := none " left.isFloat: false right.isFloat: 
 --  false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- Assign:end: "head := none " isNotRemote: false qual: 
 --  %basic 19
 --     none_x: var integer
 --  
 --  D: none 
 -- DI:newStore: "head " off: 1 valueOff: 0 dstE: "head " 
 --  isNotRemote: false originIsValueObj: false isUnitValueObj: false 
 --  rightQual:primNo: 19 rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 -- DI:newStore:ref/String: "head: ref link:next " 
 rswap 0
 rstoreg  link:next$128 1
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 -- handleAssign: "tail := none " 
 -- handleInv: "tail " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "tail " 
 --  "tail " false 
 -- needOriginII: "tail " 
 -- E: ObjectInvocation_Unary D: "tail: ref Link:next " 
 -- needOrigin: true "tail " 
 -- exps.range: 1 exps[i]: "tail " needOrigin: true 
 -- isConst: "tail " ObjectInvocation_Unary "tail: ref Link:next " 
 -- isConst:DI: "tail: ref Link:next " 
 -- updateOffset: "tail " E.ATd: "tail: ref Link:next " 
 -- loadPathII:E: "tail " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "tail " 
 pushThis 
 -- items:goOrigin:encOG: "clear "on: 1 isValueObj: false 
 --  origin: OrderedList origin:isValueObj: false 
 rpushg clear$136 1
 -- loadPathII:before:newInvoke: "tail " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "tail := none " leftE: "tail " 
 -- OG:before:super.gen: "none "
 -- handleInv: "none " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "none " 
 --  "none " true 
 -- needOriginII: "none " 
 -- E: ObjectInvocation_Unary D: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  
 -- needOrigin: true "none " 
 -- exps.range: 1 exps[i]: "none " needOrigin: true 
 -- isConst: "none " ObjectInvocation_Unary 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  
 -- updateOffset: "none " E.ATd: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  
 -- loadPathII:E: "none " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "none " 
 -- loadPathII:before:newInvoke: "none " true 
 -- checkForProxy:E: "none " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "none " 
 -- ptn:newInvoke: "none " staticOff: 0 
 -- oPTN:newInvoke: "none " 19 
 pushNone 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "tail := none " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- checkI2F2I: "tail := none " left.isFloat: false right.isFloat: 
 --  false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- Assign:end: "tail := none " isNotRemote: false qual: 
 --  %basic 19
 --     none_x: var integer
 --  
 --  D: none 
 -- DI:newStore: "tail " off: 2 valueOff: 0 dstE: "tail " 
 --  isNotRemote: false originIsValueObj: false isUnitValueObj: false 
 --  rightQual:primNo: 19 rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 -- DI:newStore:ref/String: "tail: ref Link:next " 
 rswap 0
 rstoreg  link:next$128 2
   ;; vTop(0,0)=[] rTop(-2,1)=[]
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0

 CLASS insert 137 1 OrderedList 92
 -- vdtTableCopy: I:1:74 I:2:0
 rShiftUp  1
 tstOriginIsNone 
 rstore  1 origin
 -- super insert
 pushThis 
 rpushg iOrigin 1
 rShiftDown  1
 pushThis 
 rstoreg  e 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- DI:gen: "in e: ref elm " DI:isConst: false isBasicValue: false 
 --  primNo: 0 
 rtnAlloc 1
 toSuper 74
DO:
 mvStack 
 L1:
 -- OG:before:super.gen: "
 --  if (head == none) :then 
 --     head := Link(e):next(none)
 --     tail := head
 --  :else 
 --     t: ref Link:next
 --     t := link(e):next(none)
 --     tail.next := t
 --     tail := t "
 -- handleInv: 
 --  if (head == none) :then 
 --     head := Link(e):next(none)
 --     tail := head
 --  :else staticOff: 0 doLoad: true useRtnVal: false 
 -- isPtnWithOrigin: 
 --  if (head == none) :then 
 --     head := Link(e):next(none)
 --     tail := head
 --  :else 
 --  
 --  if (head == none) :then 
 --     head := Link(e):next(none)
 --     tail := head
 --  :else false 
 -- needOriginII: 
 --  if (head == none) :then 
 --     head := Link(e):next(none)
 --     tail := head
 --  :else 
 -- E: IfThenElse D: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- needOrigin: false 
 --  if (head == none) :then 
 --     head := Link(e):next(none)
 --     tail := head
 --  :else 
 -- exps.range: 1 exps[i]: 
 --  if (head == none) :then 
 --     head := Link(e):next(none)
 --     tail := head
 --  :else needOrigin: false 
 -- isConst: 
 --  if (head == none) :then 
 --     head := Link(e):next(none)
 --     tail := head
 --  :else IfThenElse 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- noOrigin: 
 --  if (head == none) :then 
 --     head := Link(e):next(none)
 --     tail := head
 --  :else 
 -- loadPathII:E: 
 --  if (head == none) :then 
 --     head := Link(e):next(none)
 --     tail := head
 --  :else 1 1 exps.range: 1 staticOff: 0 
 -- loadPathII:before:newInvoke: 
 --  if (head == none) :then 
 --     head := Link(e):next(none)
 --     tail := head
 --  :else true 
 -- checkForProxy:E: 
 --  if (head == none) :then 
 --     head := Link(e):next(none)
 --     tail := head
 --  :else isBasicValue: false origin.isValueObj: false staticOff: 0 rec: 
 --  none 
 -- loadPathII:next: 1 1 
 -- IfThenElse:newInvoke: 
 --  if (head == none) :then 
 --     head := Link(e):next(none)
 --     tail := head
 --  :else 
 -- OG:before:super.gen: "(head == none) "
 -- handleInv: "(head == none) " staticOff: 0 doLoad: true 
 --  useRtnVal: true 
 -- isPtnWithOrigin: "(head == none) " 
 --  "head " false "== none " true 
 -- needOriginII: "(head == none) " 
 -- E: ObjectInvocation_Unary D: "head: ref link:next " 
 -- E: ObjectInvocation_Binary D: 
 --  ==  : 
 --     %basic 56
 --     in objx: ref Object
 --     out V: var boolean
 --  
 -- needOrigin: true "== none " 
 -- exps.range: 2 exps[i]: "head " exps[i]: "== none " needOrigin: 
 --  true 
 -- isConst: "head " ObjectInvocation_Unary "head: ref link:next " 
 -- isConst:DI: "head: ref link:next " 
 -- updateOffset: "head " E.ATd: "head: ref link:next " 
 -- isConst: "== none " ObjectInvocation_Binary 
 --  ==  : 
 --     %basic 56
 --     in objx: ref Object
 --     out V: var boolean
 --  
 -- updateOffset: "== none " E.ATd: 
 --  ==  : 
 --     %basic 56
 --     in objx: ref Object
 --     out V: var boolean
 --  
 -- loadPathII:E: "head " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "head " 
 pushThis 
 -- items:goOrigin:encOG: "insert "on: 1 isValueObj: false 
 --  origin: OrderedList origin:isValueObj: false 
 rpushg insert$137 1
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "head " 
 -- DI:loadAccessor: "head " 
 -- DI:loadAccessor:Obj: "head: ref link:next " 
 rpushg newInvoke 1
 -- loadPathII:E: "== none " 1 2 exps.range: 2 staticOff: 0 
 -- E: "== none " E:isPrimitiveIntWithFloatArg: false rec: "head " 
 --  isFloat: false 
 -- NonVirt: "== none " "ObjectInvocation_Binary " ActArg: "none "
 --  isValue: false formalArg: "in objx: ref Object " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "== none " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "none "
 -- handleInv: "none " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "none " 
 --  "none " true 
 -- needOriginII: "none " 
 -- E: ObjectInvocation_Unary D: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  
 -- needOrigin: true "none " 
 -- exps.range: 1 exps[i]: "none " needOrigin: true 
 -- isConst: "none " ObjectInvocation_Unary 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  
 -- updateOffset: "none " E.ATd: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  
 -- loadPathII:E: "none " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "none " 
 -- loadPathII:before:newInvoke: "none " true 
 -- checkForProxy:E: "none " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "none " 
 -- ptn:newInvoke: "none " staticOff: 0 
 -- oPTN:newInvoke: "none " 19 
 pushNone 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: true formalArg:isPtn: "in objx: ref Object "
 --  :isBasicVal: false :valueObj: false 
 --  :actArg: "none ":isBasicVal: false 
 -- case:B: none ObjectGenerator 64 19 19 false false 
 -- isIntForFloatArg: "none " D: "in objx: ref Object " false false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "none " false 
 --  B: false 
 --  
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  
 -- end:loadArgs:NonVirt: "== none "
 -- loadPathII:before:newInvoke: "== none " true 
 -- checkForProxy:E: "== none " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: "head " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "== none " 
 -- ptn:newInvoke: "==   " staticOff: 0 
 -- gPTN:newInvoke: "==   " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: "head " 
 -- checkInt2IntWithUnitArg:E: "== none " false false 
 req
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  138   "$138 "
 invoke $138 138 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L5
 L4:
 pushThis 
 -- before objTmpStack:add:  139   "$139 "
 invoke $139 139 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L5:
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS $138 138 1 insert 137
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- handleAssign: "head := Link(e):next(none) " 
 -- handleInv: "head " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "head " 
 --  "head " false 
 -- needOriginII: "head " 
 -- E: ObjectInvocation_Unary D: "head: ref link:next " 
 -- needOrigin: true "head " 
 -- exps.range: 1 exps[i]: "head " needOrigin: true 
 -- isConst: "head " ObjectInvocation_Unary "head: ref link:next " 
 -- isConst:DI: "head: ref link:next " 
 -- updateOffset: "head " E.ATd: "head: ref link:next " 
 -- loadPathII:E: "head " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "head " 
 pushThis 
 -- items:goOrigin:encOG: "$138 "on: 2 isValueObj: false 
 --  origin: insert origin:isValueObj: false 
 rpushg $138$138 1
 -- items:goOrigin:encOG: "insert "on: 1 isValueObj: false 
 --  origin: OrderedList origin:isValueObj: false 
 rpushg insert$137 1
 -- loadPathII:before:newInvoke: "head " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "head := Link(e):next(none) " leftE: "
 --  head " 
 -- OG:before:super.gen: "Link(e):next(none) "
 -- handleInv: "Link(e):next(none) " staticOff: 0 doLoad: true 
 --  useRtnVal: true 
 -- isPtnWithOrigin: "Link(e):next(none) " 
 --  "Link(e):next(none) " true 
 -- needOriginII: "Link(e):next(none) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  link(E: ref Elm):next(next: ref Link:next): 
 --     %id "link:next"
 --     ...
 --  
 -- needOrigin: true "Link(e):next(none) " 
 -- exps.range: 1 exps[i]: "Link(e):next(none) " needOrigin: true 
 -- isConst: "Link(e):next(none) " ObjectInvocation_KeyWord 
 --  link(E: ref Elm):next(next: ref Link:next): 
 --     %id "link:next"
 --     ...
 --  
 -- updateOffset: "Link(e):next(none) " E.ATd: 
 --  link(E: ref Elm):next(next: ref Link:next): 
 --     %id "link:next"
 --     ...
 --  
 -- loadPathII:E: "Link(e):next(none) " 1 1 exps.range: 1 
 --  staticOff: 0 
 -- loadOriginII: "Link(e):next(none) " 
 pushThis 
 -- items:goOrigin:encOG: "$138 "on: 2 isValueObj: false 
 --  origin: insert origin:isValueObj: false 
 rpushg $138$138 1
 -- items:goOrigin:encOG: "insert "on: 1 isValueObj: false 
 --  origin: OrderedList origin:isValueObj: false 
 rpushg insert$137 1
 -- NonVirt: "Link(e):next(none) " "ObjectInvocation_KeyWord " 
 --  ActArg: "e "isValue: false formalArg: "E: ref Elm " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "Link(e):next(none) "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "e "
 -- handleInv: "e " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "e " 
 --  "e " false 
 -- needOriginII: "e " 
 -- E: ObjectInvocation_Unary D: "in e: ref elm " 
 -- needOrigin: true "e " 
 -- exps.range: 1 exps[i]: "e " needOrigin: true 
 -- isConst: "e " ObjectInvocation_Unary "in e: ref elm " 
 -- isConst:DI: "in e: ref elm " 
 -- updateOffset: "e " E.ATd: "in e: ref elm " 
 -- loadPathII:E: "e " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "e " 
 pushThis 
 -- items:goOrigin:encOG: "$138 "on: 1 isValueObj: false 
 --  origin: insert origin:isValueObj: false 
 rpushg $138$138 1
 -- loadPathII:before:newInvoke: "e " true 
 -- checkForProxy:E: "e " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "e " 
 -- DI:newInvoke: "in e: ref elm " off: 2 valueOff: 0 E: "e " 
 --  next: none isAdr: false 
 -- DI:newInvoke:loadObj: "in e: ref elm " 
 rpushg newInvoke 2
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: false formalArg:isPtn: "E: ref Elm "
 --  :isBasicVal: false :valueObj: false 
 --  :actArg: "e ":isBasicVal: false 
 -- case:B: e ObjectGenerator 0 0 64 false false 
 -- isIntForFloatArg: "e " D: "E: ref Elm " false false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "e " 
 --  B: false 
 --  "in e: ref elm " 
 -- end:loadArgs:NonVirt: "Link(e):next(none) "
 -- NonVirt: "Link(e):next(none) " "ObjectInvocation_KeyWord " 
 --  ActArg: "none "isValue: false formalArg: "next: ref Link:next " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "Link(e):next(none) "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "none "
 -- handleInv: "none " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "none " 
 --  "none " true 
 -- needOriginII: "none " 
 -- E: ObjectInvocation_Unary D: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  
 -- needOrigin: true "none " 
 -- exps.range: 1 exps[i]: "none " needOrigin: true 
 -- isConst: "none " ObjectInvocation_Unary 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  
 -- updateOffset: "none " E.ATd: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  
 -- loadPathII:E: "none " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "none " 
 -- loadPathII:before:newInvoke: "none " true 
 -- checkForProxy:E: "none " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "none " 
 -- ptn:newInvoke: "none " staticOff: 0 
 -- oPTN:newInvoke: "none " 19 
 pushNone 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: true formalArg:isPtn: "next: ref Link:next "
 --  :isBasicVal: false :valueObj: false 
 --  :actArg: "none ":isBasicVal: false 
 -- case:B: none ObjectGenerator 0 19 19 false false 
 -- isIntForFloatArg: "none " D: "next: ref Link:next " false false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "none " false 
 --  B: false 
 --  
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  
 -- end:loadArgs:NonVirt: "Link(e):next(none) "
 -- loadPathII:before:newInvoke: "Link(e):next(none) " true 
 -- checkForProxy:E: "Link(e):next(none) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "Link(e):next(none) " 
 -- ptn:newInvoke: "link(E: ref Elm):next(next: ref Link:next) " 
 --  staticOff: 0 
 -- gPTN:newInvoke: "link(E: ref Elm):next(next: ref Link:next) " 
 --  ptnKind: 0 staticOff: 0 valueOff: 0 rec: none 
 -- invoke:nonVirtual: "link(E: ref Elm):next(next: ref Link:next) " 
 --  isAdr: false 
 invoke link:next 128 0 1
 -- callInvoke:after:pushOut: -1 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "head := Link(e):next(none) " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- checkI2F2I: "head := Link(e):next(none) " left.isFloat: false 
 --  right.isFloat: false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- Assign:end: "head := Link(e):next(none) " isNotRemote: false 
 --  qual: 
 --  %id "link:next"
 --     ...
 --  
 --  D: none 
 -- DI:newStore: "head " off: 1 valueOff: 0 dstE: "head " 
 --  isNotRemote: false originIsValueObj: false isUnitValueObj: false 
 --  rightQual:primNo: 0 rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 -- DI:newStore:ref/String: "head: ref link:next " 
 rswap 0
 rstoreg  link:next$128 1
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 -- handleAssign: "tail := head " 
 -- handleInv: "tail " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "tail " 
 --  "tail " false 
 -- needOriginII: "tail " 
 -- E: ObjectInvocation_Unary D: "tail: ref Link:next " 
 -- needOrigin: true "tail " 
 -- exps.range: 1 exps[i]: "tail " needOrigin: true 
 -- isConst: "tail " ObjectInvocation_Unary "tail: ref Link:next " 
 -- isConst:DI: "tail: ref Link:next " 
 -- updateOffset: "tail " E.ATd: "tail: ref Link:next " 
 -- loadPathII:E: "tail " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "tail " 
 pushThis 
 -- items:goOrigin:encOG: "$138 "on: 2 isValueObj: false 
 --  origin: insert origin:isValueObj: false 
 rpushg $138$138 1
 -- items:goOrigin:encOG: "insert "on: 1 isValueObj: false 
 --  origin: OrderedList origin:isValueObj: false 
 rpushg insert$137 1
 -- loadPathII:before:newInvoke: "tail " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "tail := head " leftE: "tail " 
 -- OG:before:super.gen: "head "
 -- handleInv: "head " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "head " 
 --  "head " false 
 -- needOriginII: "head " 
 -- E: ObjectInvocation_Unary D: "head: ref link:next " 
 -- needOrigin: true "head " 
 -- exps.range: 1 exps[i]: "head " needOrigin: true 
 -- isConst: "head " ObjectInvocation_Unary "head: ref link:next " 
 -- isConst:DI: "head: ref link:next " 
 -- updateOffset: "head " E.ATd: "head: ref link:next " 
 -- loadPathII:E: "head " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "head " 
 pushThis 
 -- items:goOrigin:encOG: "$138 "on: 2 isValueObj: false 
 --  origin: insert origin:isValueObj: false 
 rpushg $138$138 1
 -- items:goOrigin:encOG: "insert "on: 1 isValueObj: false 
 --  origin: OrderedList origin:isValueObj: false 
 rpushg insert$137 1
 -- loadPathII:before:newInvoke: "head " true 
 -- checkForProxy:E: "head " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "head " 
 -- DI:newInvoke: "head: ref link:next " off: 1 valueOff: 0 E: "
 --  head " next: none isAdr: false 
 -- DI:newInvoke:loadObj: "head: ref link:next " 
 rpushg newInvoke 1
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "tail := head " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- checkI2F2I: "tail := head " left.isFloat: false right.isFloat: 
 --  false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- Assign:end: "tail := head " isNotRemote: false qual: 
 --  %id "link:next"
 --     ...
 --  
 --  D: none 
 -- DI:newStore: "tail " off: 2 valueOff: 0 dstE: "tail " 
 --  isNotRemote: false originIsValueObj: false isUnitValueObj: false 
 --  rightQual:primNo: 0 rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 -- DI:newStore:ref/String: "tail: ref Link:next " 
 rswap 0
 rstoreg  link:next$128 2
   ;; vTop(0,0)=[] rTop(-3,1)=[]
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $139 139 1 insert 137
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "t: ref Link:next " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- handleAssign: "t := link(e):next(none) " 
 -- handleInv: "t " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "t " 
 --  "t " false 
 -- needOriginII: "t " 
 -- E: ObjectInvocation_Unary D: "t: ref Link:next " 
 -- needOrigin: true "t " 
 -- exps.range: 1 exps[i]: "t " needOrigin: true 
 -- isConst: "t " ObjectInvocation_Unary "t: ref Link:next " 
 -- isConst:DI: "t: ref Link:next " 
 -- updateOffset: "t " E.ATd: "t: ref Link:next " 
 -- loadPathII:E: "t " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "t " 
 pushThis 
 -- loadPathII:before:newInvoke: "t " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "t := link(e):next(none) " leftE: "t " 
 -- OG:before:super.gen: "link(e):next(none) "
 -- handleInv: "link(e):next(none) " staticOff: 0 doLoad: true 
 --  useRtnVal: true 
 -- isPtnWithOrigin: "link(e):next(none) " 
 --  "link(e):next(none) " true 
 -- needOriginII: "link(e):next(none) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  link(E: ref Elm):next(next: ref Link:next): 
 --     %id "link:next"
 --     ...
 --  
 -- needOrigin: true "link(e):next(none) " 
 -- exps.range: 1 exps[i]: "link(e):next(none) " needOrigin: true 
 -- isConst: "link(e):next(none) " ObjectInvocation_KeyWord 
 --  link(E: ref Elm):next(next: ref Link:next): 
 --     %id "link:next"
 --     ...
 --  
 -- updateOffset: "link(e):next(none) " E.ATd: 
 --  link(E: ref Elm):next(next: ref Link:next): 
 --     %id "link:next"
 --     ...
 --  
 -- loadPathII:E: "link(e):next(none) " 1 1 exps.range: 1 
 --  staticOff: 0 
 -- loadOriginII: "link(e):next(none) " 
 pushThis 
 -- items:goOrigin:encOG: "$139 "on: 2 isValueObj: false 
 --  origin: insert origin:isValueObj: false 
 rpushg $139$139 1
 -- items:goOrigin:encOG: "insert "on: 1 isValueObj: false 
 --  origin: OrderedList origin:isValueObj: false 
 rpushg insert$137 1
 -- NonVirt: "link(e):next(none) " "ObjectInvocation_KeyWord " 
 --  ActArg: "e "isValue: false formalArg: "E: ref Elm " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "link(e):next(none) "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "e "
 -- handleInv: "e " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "e " 
 --  "e " false 
 -- needOriginII: "e " 
 -- E: ObjectInvocation_Unary D: "in e: ref elm " 
 -- needOrigin: true "e " 
 -- exps.range: 1 exps[i]: "e " needOrigin: true 
 -- isConst: "e " ObjectInvocation_Unary "in e: ref elm " 
 -- isConst:DI: "in e: ref elm " 
 -- updateOffset: "e " E.ATd: "in e: ref elm " 
 -- loadPathII:E: "e " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "e " 
 pushThis 
 -- items:goOrigin:encOG: "$139 "on: 1 isValueObj: false 
 --  origin: insert origin:isValueObj: false 
 rpushg $139$139 1
 -- loadPathII:before:newInvoke: "e " true 
 -- checkForProxy:E: "e " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "e " 
 -- DI:newInvoke: "in e: ref elm " off: 2 valueOff: 0 E: "e " 
 --  next: none isAdr: false 
 -- DI:newInvoke:loadObj: "in e: ref elm " 
 rpushg newInvoke 2
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: false formalArg:isPtn: "E: ref Elm "
 --  :isBasicVal: false :valueObj: false 
 --  :actArg: "e ":isBasicVal: false 
 -- case:B: e ObjectGenerator 0 0 64 false false 
 -- isIntForFloatArg: "e " D: "E: ref Elm " false false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "e " 
 --  B: false 
 --  "in e: ref elm " 
 -- end:loadArgs:NonVirt: "link(e):next(none) "
 -- NonVirt: "link(e):next(none) " "ObjectInvocation_KeyWord " 
 --  ActArg: "none "isValue: false formalArg: "next: ref Link:next " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "link(e):next(none) "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "none "
 -- handleInv: "none " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "none " 
 --  "none " true 
 -- needOriginII: "none " 
 -- E: ObjectInvocation_Unary D: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  
 -- needOrigin: true "none " 
 -- exps.range: 1 exps[i]: "none " needOrigin: true 
 -- isConst: "none " ObjectInvocation_Unary 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  
 -- updateOffset: "none " E.ATd: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  
 -- loadPathII:E: "none " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "none " 
 -- loadPathII:before:newInvoke: "none " true 
 -- checkForProxy:E: "none " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "none " 
 -- ptn:newInvoke: "none " staticOff: 0 
 -- oPTN:newInvoke: "none " 19 
 pushNone 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: true formalArg:isPtn: "next: ref Link:next "
 --  :isBasicVal: false :valueObj: false 
 --  :actArg: "none ":isBasicVal: false 
 -- case:B: none ObjectGenerator 0 19 19 false false 
 -- isIntForFloatArg: "none " D: "next: ref Link:next " false false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "none " false 
 --  B: false 
 --  
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  
 -- end:loadArgs:NonVirt: "link(e):next(none) "
 -- loadPathII:before:newInvoke: "link(e):next(none) " true 
 -- checkForProxy:E: "link(e):next(none) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "link(e):next(none) " 
 -- ptn:newInvoke: "link(E: ref Elm):next(next: ref Link:next) " 
 --  staticOff: 0 
 -- gPTN:newInvoke: "link(E: ref Elm):next(next: ref Link:next) " 
 --  ptnKind: 0 staticOff: 0 valueOff: 0 rec: none 
 -- invoke:nonVirtual: "link(E: ref Elm):next(next: ref Link:next) " 
 --  isAdr: false 
 invoke link:next 128 0 1
 -- callInvoke:after:pushOut: -1 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "t := link(e):next(none) " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- checkI2F2I: "t := link(e):next(none) " left.isFloat: false 
 --  right.isFloat: false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- Assign:end: "t := link(e):next(none) " isNotRemote: false qual: 
 --  %id "link:next"
 --     ...
 --  
 --  D: none 
 -- DI:newStore: "t " off: 2 valueOff: 0 dstE: "t " isNotRemote: 
 --  false originIsValueObj: false isUnitValueObj: false rightQual:primNo: 0 
 --  rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 -- DI:newStore:ref/String: "t: ref Link:next " 
 rswap 0
 rstoreg  link:next$128 2
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 -- handleAssign: "tail.next := t " 
 -- handleInv: "tail.next " staticOff: 0 doLoad: false useRtnVal: 
 --  false 
 -- isPtnWithOrigin: "tail.next " 
 --  "tail " false "next " false 
 -- needOriginII: "tail.next " 
 -- E: ObjectInvocation_Unary D: "tail: ref Link:next " 
 -- E: ObjectInvocation_Unary D: "next: ref Link:next " 
 -- needOrigin: true "next " 
 -- exps.range: 2 exps[i]: "tail " exps[i]: "next " needOrigin: 
 --  true 
 -- isConst: "tail " ObjectInvocation_Unary "tail: ref Link:next " 
 -- isConst:DI: "tail: ref Link:next " 
 -- updateOffset: "tail " E.ATd: "tail: ref Link:next " 
 -- isConst: "next " ObjectInvocation_Unary "next: ref Link:next " 
 -- isConst:DI: "next: ref Link:next " 
 -- updateOffset: "next " E.ATd: "next: ref Link:next " 
 -- loadPathII:E: "tail " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "tail " 
 pushThis 
 -- items:goOrigin:encOG: "$139 "on: 2 isValueObj: false 
 --  origin: insert origin:isValueObj: false 
 rpushg $139$139 1
 -- items:goOrigin:encOG: "insert "on: 1 isValueObj: false 
 --  origin: OrderedList origin:isValueObj: false 
 rpushg insert$137 1
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "tail " 
 -- DI:loadAccessor: "tail " 
 -- DI:loadAccessor:Obj: "tail: ref Link:next " 
 rpushg newInvoke 2
 -- loadPathII:E: "next " 1 2 exps.range: 2 staticOff: 0 
 -- E: "next " E:isPrimitiveIntWithFloatArg: false rec: "tail " 
 --  isFloat: false 
 -- loadPathII:before:newInvoke: "next " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "tail.next := t " leftE: "next " 
 -- OG:before:super.gen: "t "
 -- handleInv: "t " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "t " 
 --  "t " false 
 -- needOriginII: "t " 
 -- E: ObjectInvocation_Unary D: "t: ref Link:next " 
 -- needOrigin: true "t " 
 -- exps.range: 1 exps[i]: "t " needOrigin: true 
 -- isConst: "t " ObjectInvocation_Unary "t: ref Link:next " 
 -- isConst:DI: "t: ref Link:next " 
 -- updateOffset: "t " E.ATd: "t: ref Link:next " 
 -- loadPathII:E: "t " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "t " 
 pushThis 
 -- loadPathII:before:newInvoke: "t " true 
 -- checkForProxy:E: "t " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "t " 
 -- DI:newInvoke: "t: ref Link:next " off: 2 valueOff: 0 E: "t " 
 --  next: none isAdr: false 
 -- DI:newInvoke:loadObj: "t: ref Link:next " 
 rpushg newInvoke 2
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "tail.next := t " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- checkI2F2I: "tail.next := t " left.isFloat: false right.isFloat: 
 --  false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- Assign:end: "tail.next := t " isNotRemote: false qual: 
 --  %id "link:next"
 --     ...
 --  
 --  D: none 
 -- DI:newStore: "next " off: 3 valueOff: 0 dstE: "tail.next " 
 --  isNotRemote: false originIsValueObj: false isUnitValueObj: false 
 --  rightQual:primNo: 0 rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 -- DI:newStore:ref/String: "next: ref Link:next " 
 rswap 0
 rstoreg  link:next$128 3
   ;; vTop(0,0)=[] rTop(-3,1)=[]
 -- handleAssign: "tail := t " 
 -- handleInv: "tail " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "tail " 
 --  "tail " false 
 -- needOriginII: "tail " 
 -- E: ObjectInvocation_Unary D: "tail: ref Link:next " 
 -- needOrigin: true "tail " 
 -- exps.range: 1 exps[i]: "tail " needOrigin: true 
 -- isConst: "tail " ObjectInvocation_Unary "tail: ref Link:next " 
 -- isConst:DI: "tail: ref Link:next " 
 -- updateOffset: "tail " E.ATd: "tail: ref Link:next " 
 -- loadPathII:E: "tail " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "tail " 
 pushThis 
 -- items:goOrigin:encOG: "$139 "on: 2 isValueObj: false 
 --  origin: insert origin:isValueObj: false 
 rpushg $139$139 1
 -- items:goOrigin:encOG: "insert "on: 1 isValueObj: false 
 --  origin: OrderedList origin:isValueObj: false 
 rpushg insert$137 1
 -- loadPathII:before:newInvoke: "tail " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "tail := t " leftE: "tail " 
 -- OG:before:super.gen: "t "
 -- handleInv: "t " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "t " 
 --  "t " false 
 -- needOriginII: "t " 
 -- E: ObjectInvocation_Unary D: "t: ref Link:next " 
 -- needOrigin: true "t " 
 -- exps.range: 1 exps[i]: "t " needOrigin: true 
 -- isConst: "t " ObjectInvocation_Unary "t: ref Link:next " 
 -- isConst:DI: "t: ref Link:next " 
 -- updateOffset: "t " E.ATd: "t: ref Link:next " 
 -- loadPathII:E: "t " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "t " 
 pushThis 
 -- loadPathII:before:newInvoke: "t " true 
 -- checkForProxy:E: "t " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "t " 
 -- DI:newInvoke: "t: ref Link:next " off: 2 valueOff: 0 E: "t " 
 --  next: none isAdr: false 
 -- DI:newInvoke:loadObj: "t: ref Link:next " 
 rpushg newInvoke 2
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "tail := t " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- checkI2F2I: "tail := t " left.isFloat: false right.isFloat: 
 --  false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- Assign:end: "tail := t " isNotRemote: false qual: 
 --  %id "link:next"
 --     ...
 --  
 --  D: none 
 -- DI:newStore: "tail " off: 2 valueOff: 0 dstE: "tail " 
 --  isNotRemote: false originIsValueObj: false isUnitValueObj: false 
 --  rightQual:primNo: 0 rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 -- DI:newStore:ref/String: "tail: ref Link:next " 
 rswap 0
 rstoreg  link:next$128 2
   ;; vTop(0,0)=[] rTop(-5,1)=[]
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS Rule 89 1 Grammar 71
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "leftSide: ref Nonterminal " DI:isConst: false 
 --  isBasicValue: false primNo: 0 
 -- DI:gen: 
 --  alternatives: obj OrderedList(#Alternative)
 --     print: 
 --        i: var integer
 --        scanDI:isConst: true isBasicValue: false primNo: 0 
 -- DI:isConst: alternatives 
 -- DI:off: 3 this: 
 --  alternatives: obj OrderedList(#Alternative)
 --     print: 
 --        i: var integer
 --        scan
 --  
 -- before objTmpStack:add:  93   "alternatives "
 invoke alternatives 93 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS SymbolList 141 0 Grammar 71
 -- vdtTableCopy: I:1:80 V:2:0 V:3:137 V:4:126 V:5:97 V:6:133 V:7:134 V:8:136 I:9:92
 -- super OrderedList
 -- super OrderedList
 allocEventQ
 -- DI:gen: "head: ref link:next " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 -- DI:gen: "tail: ref Link:next " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 rtnAlloc 1
 toSuper 80
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS Alternative 90 1 Grammar 71
 pushThis 
 rstoreg  symbols 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS alternatives 93 0 Rule 89
 -- vdtTableCopy: I:1:80 V:2:0 V:3:137 V:4:126 V:5:97 V:6:133 V:7:134 V:8:136 I:9:92
 -- super OrderedList
 -- super OrderedList
 allocEventQ
 -- DI:gen: "head: ref link:next " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 -- DI:gen: "tail: ref Link:next " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 rtnAlloc 1
 toSuper 80
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS rules 95 0 Grammar 71
 -- vdtTableCopy: I:1:80 V:2:0 V:3:137 V:4:126 V:5:97 V:6:133 V:7:134 V:8:136 I:9:92
 -- super OrderedList
 -- super OrderedList
 allocEventQ
 -- DI:gen: "head: ref link:next " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 -- DI:gen: "tail: ref Link:next " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 rtnAlloc 1
 toSuper 80
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS Text 142 1 GrammarLib 69
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS parse 143 1 Grammar 71
 pushThis 
 rstoreg  input 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: 
 --  output: ref AbstractSyntaxTree
 --  -- Parse the input string according to the grammar
 --  -- and produce an abstract syntax tree
 --  --return output
 --  DI:isConst: false isBasicValue: false primNo: 0 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS AbstractSyntaxTree 144 1 GrammarLib 69
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS gTst 145 7 demo 70
 -- vdtTableCopy: I:1:71 V:2:143 I:3:0
 tstOriginIsNone 
 rstore  7 origin
 -- super Grammar
 -- computeAdrX:superAdj: 7 "Grammar " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Grammar " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:7 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 rpushg demo$70 7
 -- items:goOrigin:encOG: "demo "on: 1 isValueObj: false 
 --  origin: GrammarLib origin:isValueObj: false 
 rpushg demo$70 1
 -- computeAdrX:isLast:E:  "Grammar "
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- DI:gen: "nonTerminals: obj Set(#Nonterminal) " DI:isConst: true 
 --  isBasicValue: false primNo: 0 
 -- DI:isConst: nonTerminals 
 -- DI:off: 2 this: "nonTerminals: obj Set(#Nonterminal) " 
 --  
 -- before objTmpStack:add:  85   "nonTerminals "
 invoke nonTerminals 85 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- DI:gen: "terminals: obj Set(#Terminal) " DI:isConst: true 
 --  isBasicValue: false primNo: 0 
 -- DI:isConst: terminals 
 -- DI:off: 3 this: "terminals: obj Set(#Terminal) " 
 --  
 -- before objTmpStack:add:  88   "terminals "
 invoke terminals 88 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- DI:gen: "rules: obj OrderedList(#Rule) " DI:isConst: true 
 --  isBasicValue: false primNo: 0 
 -- DI:isConst: rules 
 -- DI:off: 4 this: "rules: obj OrderedList(#Rule) " 
 --  
 -- before objTmpStack:add:  95   "rules "
 invoke rules 95 4 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- DI:gen: "start: ref Nonterminal " DI:isConst: false 
 --  isBasicValue: false primNo: 0 
 -- DI:gen: "noOfRules: var integer " DI:isConst: false 
 --  isBasicValue: true primNo: 1 
 -- DI:gen:primitiveType: noOfRules 
 -- DI:gen: "expSy: obj Nonterminal("Exp") " DI:isConst: true 
 --  isBasicValue: false primNo: 0 
 -- DI:isConst: expSy 
 -- DI:off: 8 this: "expSy: obj Nonterminal("Exp") " 
 --  
 -- OG:before:super.gen: "Nonterminal("Exp") "
 -- handleInv: "Nonterminal("Exp") " staticOff: 8 doLoad: true 
 --  useRtnVal: false 
 -- isPtnWithOrigin: "Nonterminal("Exp") " 
 --  "Nonterminal("Exp") " true 
 -- needOriginII: "Nonterminal("Exp") " 
 -- E: ObjectInvocation_KeyWord D: 
 --  NonTerminal: Symbol
 --     ...
 --     print:: 
 --        put('<')
 -- needOrigin: true "Nonterminal("Exp") " 
 -- exps.range: 1 exps[i]: "Nonterminal("Exp") " needOrigin: true 
 -- isConst: "Nonterminal("Exp") " ObjectInvocation_KeyWord 
 --  NonTerminal: Symbol
 --     ...
 --     print:: 
 --        put('<')
 -- updateOffset: "Nonterminal("Exp") " E.ATd: 
 --  NonTerminal: Symbol
 --     ...
 --     print:: 
 --        put('<')
 -- loadPathII:E: "Nonterminal("Exp") " 1 1 exps.range: 1 
 --  staticOff: 8 
 -- loadOriginII: "Nonterminal("Exp") " 
 pushThis 
 -- NonVirt: "Nonterminal("Exp") " "ObjectInvocation_KeyWord " 
 --  ActArg: ""Exp" "isValue: false formalArg: "printName: var String " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "Nonterminal("Exp") "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: ""Exp" "
 -- handleInv: ""Exp" " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: ""Exp" " 
 --  ""Exp" " false 
 -- needOriginII: ""Exp" " 
 -- E: String: D: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- needOrigin: true ""Exp" " 
 -- exps.range: 1 exps[i]: ""Exp" " needOrigin: true 
 -- isConst: ""Exp" " String: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- updateOffset: ""Exp" " E.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- loadPathII:E: ""Exp" " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: ""Exp" " 
 -- StringObj:loadOrigin: "Exp" 
 -- loadPathII:before:newInvoke: ""Exp" " true 
 -- checkForProxy:E: ""Exp" " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- StringObj:newInvoke Exp 
 pushText "Exp"
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: true formalArg:isPtn: "printName: var String "
 --  :isBasicVal: false :valueObj: false 
 --  :actArg: ""Exp" ":isBasicVal: false 
 -- case:B: "Exp" ObjectGenerator 5 5 5 false false 
 -- isIntForFloatArg: ""Exp" " D: "printName: var String " false 
 --  false srcOG.isFloat: false src.isUnitValueObj: false this: ""Exp" " 
 --  false 
 --  B: false 
 --  
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- end:loadArgs:NonVirt: "Nonterminal("Exp") "
 -- loadPathII:before:newInvoke: "Nonterminal("Exp") " true 
 -- checkForProxy:E: "Nonterminal("Exp") " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 8 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "Nonterminal("Exp") " 
 -- ptn:newInvoke: "NonTerminal " staticOff: 8 
 -- gPTN:newInvoke: "NonTerminal " ptnKind: 0 staticOff: 8 
 --  valueOff: 0 rec: none 
 -- invoke:nonVirtual: "NonTerminal " isAdr: false 
 invoke NonTerminal 73 8 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- DI:gen: "termSy: obj Nonterminal("Term") " DI:isConst: true 
 --  isBasicValue: false primNo: 0 
 -- DI:isConst: termSy 
 -- DI:off: 9 this: "termSy: obj Nonterminal("Term") " 
 --  
 -- OG:before:super.gen: "Nonterminal("Term") "
 -- handleInv: "Nonterminal("Term") " staticOff: 9 doLoad: true 
 --  useRtnVal: false 
 -- isPtnWithOrigin: "Nonterminal("Term") " 
 --  "Nonterminal("Term") " true 
 -- needOriginII: "Nonterminal("Term") " 
 -- E: ObjectInvocation_KeyWord D: 
 --  NonTerminal: Symbol
 --     ...
 --     print:: 
 --        put('<')
 -- needOrigin: true "Nonterminal("Term") " 
 -- exps.range: 1 exps[i]: "Nonterminal("Term") " needOrigin: true 
 -- isConst: "Nonterminal("Term") " ObjectInvocation_KeyWord 
 --  NonTerminal: Symbol
 --     ...
 --     print:: 
 --        put('<')
 -- updateOffset: "Nonterminal("Term") " E.ATd: 
 --  NonTerminal: Symbol
 --     ...
 --     print:: 
 --        put('<')
 -- loadPathII:E: "Nonterminal("Term") " 1 1 exps.range: 1 
 --  staticOff: 9 
 -- loadOriginII: "Nonterminal("Term") " 
 pushThis 
 -- NonVirt: "Nonterminal("Term") " "ObjectInvocation_KeyWord " 
 --  ActArg: ""Term" "isValue: false formalArg: "printName: var String " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "Nonterminal("Term") "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: ""Term" "
 -- handleInv: ""Term" " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: ""Term" " 
 --  ""Term" " false 
 -- needOriginII: ""Term" " 
 -- E: String: D: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- needOrigin: true ""Term" " 
 -- exps.range: 1 exps[i]: ""Term" " needOrigin: true 
 -- isConst: ""Term" " String: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- updateOffset: ""Term" " E.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- loadPathII:E: ""Term" " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: ""Term" " 
 -- StringObj:loadOrigin: "Term" 
 -- loadPathII:before:newInvoke: ""Term" " true 
 -- checkForProxy:E: ""Term" " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- StringObj:newInvoke Term 
 pushText "Term"
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: true formalArg:isPtn: "printName: var String "
 --  :isBasicVal: false :valueObj: false 
 --  :actArg: ""Term" ":isBasicVal: false 
 -- case:B: "Term" ObjectGenerator 5 5 5 false false 
 -- isIntForFloatArg: ""Term" " D: "printName: var String " false 
 --  false srcOG.isFloat: false src.isUnitValueObj: false this: ""Term" " 
 --  false 
 --  B: false 
 --  
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- end:loadArgs:NonVirt: "Nonterminal("Term") "
 -- loadPathII:before:newInvoke: "Nonterminal("Term") " true 
 -- checkForProxy:E: "Nonterminal("Term") " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 9 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "Nonterminal("Term") " 
 -- ptn:newInvoke: "NonTerminal " staticOff: 9 
 -- gPTN:newInvoke: "NonTerminal " ptnKind: 0 staticOff: 9 
 --  valueOff: 0 rec: none 
 -- invoke:nonVirtual: "NonTerminal " isAdr: false 
 invoke NonTerminal 73 9 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- DI:gen: "add: obj Terminal("+") " DI:isConst: true isBasicValue: 
 --  false primNo: 0 
 -- DI:isConst: add 
 -- DI:off: 10 this: "add: obj Terminal("+") " 
 --  
 -- OG:before:super.gen: "Terminal("+") "
 -- handleInv: "Terminal("+") " staticOff: 10 doLoad: true 
 --  useRtnVal: false 
 -- isPtnWithOrigin: "Terminal("+") " 
 --  "Terminal("+") " true 
 -- needOriginII: "Terminal("+") " 
 -- E: ObjectInvocation_KeyWord D: 
 --  Terminal: Symbol
 --     isTerminal:: 
 --        V := true
 --     print:: 
 -- needOrigin: true "Terminal("+") " 
 -- exps.range: 1 exps[i]: "Terminal("+") " needOrigin: true 
 -- isConst: "Terminal("+") " ObjectInvocation_KeyWord 
 --  Terminal: Symbol
 --     isTerminal:: 
 --        V := true
 --     print:: 
 -- updateOffset: "Terminal("+") " E.ATd: 
 --  Terminal: Symbol
 --     isTerminal:: 
 --        V := true
 --     print:: 
 -- loadPathII:E: "Terminal("+") " 1 1 exps.range: 1 staticOff: 10 
 -- loadOriginII: "Terminal("+") " 
 pushThis 
 -- NonVirt: "Terminal("+") " "ObjectInvocation_KeyWord " ActArg: "
 --  "+" "isValue: false formalArg: "printName: var String " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "Terminal("+") "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: ""+" "
 -- handleInv: ""+" " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: ""+" " 
 --  ""+" " false 
 -- needOriginII: ""+" " 
 -- E: String: D: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- needOrigin: true ""+" " 
 -- exps.range: 1 exps[i]: ""+" " needOrigin: true 
 -- isConst: ""+" " String: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- updateOffset: ""+" " E.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- loadPathII:E: ""+" " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: ""+" " 
 -- StringObj:loadOrigin: "+" 
 -- loadPathII:before:newInvoke: ""+" " true 
 -- checkForProxy:E: ""+" " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- StringObj:newInvoke + 
 pushText "+"
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: true formalArg:isPtn: "printName: var String "
 --  :isBasicVal: false :valueObj: false 
 --  :actArg: ""+" ":isBasicVal: false 
 -- case:B: "+" ObjectGenerator 5 5 5 false false 
 -- isIntForFloatArg: ""+" " D: "printName: var String " false false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: ""+" " false 
 --  B: false 
 --  
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- end:loadArgs:NonVirt: "Terminal("+") "
 -- loadPathII:before:newInvoke: "Terminal("+") " true 
 -- checkForProxy:E: "Terminal("+") " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 10 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "Terminal("+") " 
 -- ptn:newInvoke: "Terminal " staticOff: 10 
 -- gPTN:newInvoke: "Terminal " ptnKind: 0 staticOff: 10 valueOff: 0 
 --  rec: none 
 -- invoke:nonVirtual: "Terminal " isAdr: false 
 invoke Terminal 86 10 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
 toSuper 71
DO:
 mvStack 
 L1:
 -- OG:before:super.gen: "kuk "
 -- handleInv: "kuk " staticOff: 0 doLoad: true useRtnVal: false 
 -- isPtnWithOrigin: "kuk " 
 --  "kuk " true 
 -- needOriginII: "kuk " 
 -- E: ObjectInvocation_Unary D: 
 --  KUK: 
 --     S: ref SymbolList
 --     S := SymbolList
 --     S := SymbolList.insertList((ExpSy,add,termSy))
 --  
 -- needOrigin: true "kuk " 
 -- exps.range: 1 exps[i]: "kuk " needOrigin: true 
 -- isConst: "kuk " ObjectInvocation_Unary 
 --  KUK: 
 --     S: ref SymbolList
 --     S := SymbolList
 --     S := SymbolList.insertList((ExpSy,add,termSy))
 --  
 -- updateOffset: "kuk " E.ATd: 
 --  KUK: 
 --     S: ref SymbolList
 --     S := SymbolList
 --     S := SymbolList.insertList((ExpSy,add,termSy))
 --  
 -- loadPathII:E: "kuk " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "kuk " 
 pushThis 
 -- loadPathII:before:newInvoke: "kuk " true 
 -- checkForProxy:E: "kuk " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "kuk " 
 -- ptn:newInvoke: "KUK " staticOff: 0 
 -- gPTN:newInvoke: "KUK " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: none 
 -- invoke:nonVirtual: "KUK " isAdr: false 
 invoke KUK 146 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 rtnInner  M
 END OSDV:0 objSize:10 isIndexed:0

 CLASS KUK 146 1 gTst 145
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "S: ref SymbolList " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- handleAssign: "S := SymbolList " 
 -- handleInv: "S " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "S " 
 --  "S " false 
 -- needOriginII: "S " 
 -- E: ObjectInvocation_Unary D: "S: ref SymbolList " 
 -- needOrigin: true "S " 
 -- exps.range: 1 exps[i]: "S " needOrigin: true 
 -- isConst: "S " ObjectInvocation_Unary "S: ref SymbolList " 
 -- isConst:DI: "S: ref SymbolList " 
 -- updateOffset: "S " E.ATd: "S: ref SymbolList " 
 -- loadPathII:E: "S " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "S " 
 pushThis 
 -- loadPathII:before:newInvoke: "S " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "S := SymbolList " leftE: "S " 
 -- OG:before:super.gen: "SymbolList "
 -- handleInv: "SymbolList " staticOff: 0 doLoad: true useRtnVal: 
 --  true 
 -- isPtnWithOrigin: "SymbolList " 
 --  "SymbolList " false 
 -- needOriginII: "SymbolList " 
 -- E: ObjectInvocation_Unary D: 
 --  SymbolList: OrderedList(#Symbol)
 --     print: 
 --        scan
 --           current.print
 -- needOrigin: false "SymbolList " 
 -- exps.range: 1 exps[i]: "SymbolList " needOrigin: false 
 -- isConst: "SymbolList " ObjectInvocation_Unary 
 --  SymbolList: OrderedList(#Symbol)
 --     print: 
 --        scan
 --           current.print
 -- noOrigin: "SymbolList " 
 -- loadPathII:E: "SymbolList " 1 1 exps.range: 1 staticOff: 0 
 -- loadPathII:before:newInvoke: "SymbolList " true 
 -- checkForProxy:E: "SymbolList " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "SymbolList " 
 -- ptn:newInvoke: "SymbolList " staticOff: 0 
 -- gPTN:newInvoke: "SymbolList " ptnKind: 0 staticOff: 0 
 --  valueOff: 0 rec: none 
 -- invoke:nonVirtual: "SymbolList " isAdr: false 
 invoke SymbolList 141 0 1
 -- callInvoke:after:pushOut: -1 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "S := SymbolList " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- checkI2F2I: "S := SymbolList " left.isFloat: false 
 --  right.isFloat: false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- Assign:end: "S := SymbolList " isNotRemote: false qual: 
 --  OrderedList(#Symbol)
 --     print: 
 --        scan
 --           current.print
 --  D: none 
 -- DI:newStore: "S " off: 2 valueOff: 0 dstE: "S " isNotRemote: 
 --  false originIsValueObj: false isUnitValueObj: false rightQual:primNo: 0 
 --  rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 -- DI:newStore:ref/String: "S: ref SymbolList " 
 rswap 0
 rstoreg  SymbolList$141 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- handleAssign: "S := SymbolList.insertList((ExpSy,add,termSy)) " 
 -- handleInv: "S " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "S " 
 --  "S " false 
 -- needOriginII: "S " 
 -- E: ObjectInvocation_Unary D: "S: ref SymbolList " 
 -- needOrigin: true "S " 
 -- exps.range: 1 exps[i]: "S " needOrigin: true 
 -- isConst: "S " ObjectInvocation_Unary "S: ref SymbolList " 
 -- isConst:DI: "S: ref SymbolList " 
 -- updateOffset: "S " E.ATd: "S: ref SymbolList " 
 -- loadPathII:E: "S " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "S " 
 pushThis 
 -- loadPathII:before:newInvoke: "S " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "
 --  S := SymbolList.insertList((ExpSy,add,termSy)) " leftE: "S " 
 -- OG:before:super.gen: "SymbolList.insertList((ExpSy,add,termSy)) "
 -- handleInv: "SymbolList.insertList((ExpSy,add,termSy)) " 
 --  staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "SymbolList.insertList((ExpSy,add,termSy)) " 
 --  "SymbolList " false "insertList((ExpSy,add,termSy)) " true 
 -- needOriginII: "SymbolList.insertList((ExpSy,add,termSy)) " 
 -- E: ObjectInvocation_Unary D: 
 --  SymbolList: OrderedList(#Symbol)
 --     print: 
 --        scan
 --           current.print
 -- needOrigin: false "SymbolList " 
 -- exps.range: 2 exps[i]: "SymbolList " exps[i]: "
 --  insertList((ExpSy,add,termSy)) " needOrigin: false 
 -- isConst: "SymbolList " ObjectInvocation_Unary 
 --  SymbolList: OrderedList(#Symbol)
 --     print: 
 --        scan
 --           current.print
 -- noOrigin: "SymbolList " 
 -- isConst: "insertList((ExpSy,add,termSy)) " 
 --  ObjectInvocation_KeyWord 
 --  insertList(elms: ref IndexedRef(3,#Elm)): 
 --     out OL: ref OrderedList
 --     put('%')
 --     for(1):to(elms.length):repeat
 -- noOrigin: "insertList((ExpSy,add,termSy)) " 
 -- loadPathII:E: "SymbolList " 1 1 exps.range: 2 staticOff: 0 
 -- loadPathII:loadAccessor:isPTN: "SymbolList " 
 -- checkForProxy:E: "SymbolList " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 2 
 -- OI:newInvoke: "SymbolList " 
 -- ptn:newInvoke: "SymbolList " staticOff: 0 
 -- gPTN:newInvoke: "SymbolList " ptnKind: 0 staticOff: 0 
 --  valueOff: 0 rec: none 
 -- invoke:nonVirtual: "SymbolList " isAdr: false 
 invoke SymbolList 141 0 1
 -- callInvoke:after:pushOut: -1 
 -- loadPathII:E: "insertList((ExpSy,add,termSy)) " 1 2 
 --  exps.range: 2 staticOff: 0 
 -- E: "insertList((ExpSy,add,termSy)) " 
 --  E:isPrimitiveIntWithFloatArg: false rec: "SymbolList " isFloat: false 
 -- NonVirt: "insertList((ExpSy,add,termSy)) " "
 --  ObjectInvocation_KeyWord " ActArg: "(ExpSy,add,termSy) "isValue: false formalArg: "
 --  elms: ref IndexedRef(3,#Elm) " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "insertList((ExpSy,add,termSy)) "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "(ExpSy,add,termSy) "
 -- handleInv: "(ExpSy,add,termSy) " staticOff: 0 doLoad: true 
 --  useRtnVal: true 
 -- isPtnWithOrigin: "(ExpSy,add,termSy) " 
 --  "(ExpSy,add,termSy) " false 
 -- needOriginII: "(ExpSy,add,termSy) " 
 -- needOrigin: false "(ExpSy,add,termSy) " 
 -- exps.range: 1 exps[i]: "(ExpSy,add,termSy) " needOrigin: false 
 -- isConst: "(ExpSy,add,termSy) " BracketedExp "
 --  expSy: obj Nonterminal("Exp") " 
 -- isConst:DI: "expSy: obj Nonterminal("Exp") " 
 -- noOrigin: "(ExpSy,add,termSy) " 
 -- loadPathII:E: "(ExpSy,add,termSy) " 1 1 exps.range: 1 
 --  staticOff: 0 
 -- BracketedExp:loadArgs:  (ExpSy,add,termSy) 
 -- loadPathII:before:newInvoke: "(ExpSy,add,termSy) " true 
 -- checkForProxy:E: "(ExpSy,add,termSy) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- Bracketed newInvoke:  (ExpSy,add,termSy) useRtnVal: true 
 --  staticOff: 0 
 -- handleInv: "ExpSy " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "ExpSy " 
 --  "ExpSy " false 
 -- needOriginII: "ExpSy " 
 -- E: ObjectInvocation_Unary D: "expSy: obj Nonterminal("Exp") " 
 -- needOrigin: true "ExpSy " 
 -- exps.range: 1 exps[i]: "ExpSy " needOrigin: true 
 -- isConst: "ExpSy " ObjectInvocation_Unary "
 --  expSy: obj Nonterminal("Exp") " 
 -- isConst:DI: "expSy: obj Nonterminal("Exp") " 
 -- updateOffset: "ExpSy " E.ATd: "expSy: obj Nonterminal("Exp") " 
 -- loadPathII:E: "ExpSy " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "ExpSy " 
 pushThis 
 -- items:goOrigin:encOG: "KUK "on: 1 isValueObj: false 
 --  origin: gTst origin:isValueObj: false 
 rpushg KUK$146 1
 -- loadPathII:before:newInvoke: "ExpSy " true 
 -- checkForProxy:E: "ExpSy " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "ExpSy " 
 -- DI:newInvoke: "expSy: obj Nonterminal("Exp") " off: 7 valueOff: 0 
 --  E: "ExpSy " next: none isAdr: false 
 -- DI:newInvoke:loadObj: "expSy: obj Nonterminal("Exp") " 
 rpushg newInvoke 8
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleInv: "add " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "add " 
 --  "add " false 
 -- needOriginII: "add " 
 -- E: ObjectInvocation_Unary D: "add: obj Terminal("+") " 
 -- needOrigin: true "add " 
 -- exps.range: 1 exps[i]: "add " needOrigin: true 
 -- isConst: "add " ObjectInvocation_Unary "add: obj Terminal("+") " 
 -- isConst:DI: "add: obj Terminal("+") " 
 -- updateOffset: "add " E.ATd: "add: obj Terminal("+") " 
 -- loadPathII:E: "add " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "add " 
 pushThis 
 -- items:goOrigin:encOG: "KUK "on: 1 isValueObj: false 
 --  origin: gTst origin:isValueObj: false 
 rpushg KUK$146 1
 -- loadPathII:before:newInvoke: "add " true 
 -- checkForProxy:E: "add " isBasicValue: false origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "add " 
 -- DI:newInvoke: "add: obj Terminal("+") " off: 9 valueOff: 0 E: "
 --  add " next: none isAdr: false 
 -- DI:newInvoke:loadObj: "add: obj Terminal("+") " 
 rpushg newInvoke 10
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleInv: "termSy " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "termSy " 
 --  "termSy " false 
 -- needOriginII: "termSy " 
 -- E: ObjectInvocation_Unary D: "termSy: obj Nonterminal("Term") " 
 -- needOrigin: true "termSy " 
 -- exps.range: 1 exps[i]: "termSy " needOrigin: true 
 -- isConst: "termSy " ObjectInvocation_Unary "
 --  termSy: obj Nonterminal("Term") " 
 -- isConst:DI: "termSy: obj Nonterminal("Term") " 
 -- updateOffset: "termSy " E.ATd: "
 --  termSy: obj Nonterminal("Term") " 
 -- loadPathII:E: "termSy " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "termSy " 
 pushThis 
 -- items:goOrigin:encOG: "KUK "on: 1 isValueObj: false 
 --  origin: gTst origin:isValueObj: false 
 rpushg KUK$146 1
 -- loadPathII:before:newInvoke: "termSy " true 
 -- checkForProxy:E: "termSy " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "termSy " 
 -- DI:newInvoke: "termSy: obj Nonterminal("Term") " off: 8 
 --  valueOff: 0 E: "termSy " next: none isAdr: false 
 -- DI:newInvoke:loadObj: "termSy: obj Nonterminal("Term") " 
 rpushg newInvoke 9
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: false formalArg:isPtn: "
 --  elms: ref IndexedRef(3,#Elm) ":isBasicVal: false :valueObj: false 
 --  :actArg: "(ExpSy,add,termSy) ":isBasicVal: false 
 -- case:B: (ExpSy,add,termSy) ObjectGenerator 160 0 0 false false 
 -- isIntForFloatArg: "(ExpSy,add,termSy) " D: "
 --  elms: ref IndexedRef(3,#Elm) " false false srcOG.isFloat: false src.isUnitValueObj: false this: "
 --  (ExpSy,add,termSy) " 
 --  B: false 
 --  "expSy: obj Nonterminal("Exp") " 
 -- 153 
 --  IndexedRef: 
 --     %globals
 --     %basic 160
 --     %public
 pushc 3
 mkRindexed 153
 -- end:loadArgs:NonVirt: "insertList((ExpSy,add,termSy)) "
 -- loadPathII:before:newInvoke: "insertList((ExpSy,add,termSy)) " 
 --  true 
 -- checkForProxy:E: "insertList((ExpSy,add,termSy)) " isBasicValue: 
 --  false origin.isValueObj: false staticOff: 0 rec: "SymbolList " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "insertList((ExpSy,add,termSy)) " 
 -- ptn:newInvoke: "insertList(elms: ref IndexedRef(3,#Elm)) " 
 --  staticOff: 0 
 -- gPTN:newInvoke: "insertList(elms: ref IndexedRef(3,#Elm)) " 
 --  ptnKind: 0 staticOff: 0 valueOff: 0 rec: "SymbolList " 
 -- invoke:nonVirtual: "insertList(elms: ref IndexedRef(3,#Elm)) " 
 --  isAdr: false 
 invoke insertList 147 0 0
 -- global:pushOut: OL off: 3 
 rpushg  3
 -- callInvoke:after:pushOut: 3 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "
 --  S := SymbolList.insertList((ExpSy,add,termSy)) " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- right:isPTN:not:valueObj: "out OL: ref OrderedList " 
 -- "insertList((ExpSy,add,termSy)) " 
 -- "insertList((ExpSy,add,termSy)) " 
 -- checkI2F2I: "S := SymbolList.insertList((ExpSy,add,termSy)) " 
 --  left.isFloat: false right.isFloat: false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- "insertList((ExpSy,add,termSy)) " 
 -- "insertList((ExpSy,add,termSy)) " 
 -- Assign:end: "S := SymbolList.insertList((ExpSy,add,termSy)) " 
 --  isNotRemote: false qual: 
 --  Collection
 --     %id "OrderedList"
 --     has::< 
 --        B := false
 --  D: none 
 -- DI:newStore: "S " off: 2 valueOff: 0 dstE: "S " isNotRemote: 
 --  false originIsValueObj: false isUnitValueObj: false rightQual:primNo: 0 
 --  rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 -- DI:newStore:ref/String: "S: ref SymbolList " 
 rswap 0
 rstoreg  SymbolList$141 2
   ;; vTop(0,0)=[] rTop(-4,0)=[]
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS IndexedRef 153 0 BETA 2
 pushThis 
 storeg integer$5 1
 allocEventQ
 mvStack 
 -- DI:gen: "in range: var Integer " DI:isConst: false isBasicValue: 
 --  true primNo: 1 
 -- DI:gen:primitiveType: range 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:1

 CLASS insertList 147 1 OrderedList 92
 pushThis 
 rstoreg  elms 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "out OL: ref OrderedList " DI:isConst: false 
 --  isBasicValue: false primNo: 0 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "put('%') "
 -- handleInv: "put('%') " staticOff: 0 doLoad: true useRtnVal: 
 --  false 
 -- isPtnWithOrigin: "put('%') " 
 --  "put('%') " false 
 -- needOriginII: "put('%') " 
 -- E: ObjectInvocation_KeyWord D: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- needOrigin: false "put('%') " 
 -- exps.range: 1 exps[i]: "put('%') " needOrigin: false 
 -- isConst: "put('%') " ObjectInvocation_KeyWord 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- noOrigin: "put('%') " 
 -- loadPathII:E: "put('%') " 1 1 exps.range: 1 staticOff: 0 
 -- NonVirt: "put('%') " "ObjectInvocation_KeyWord " ActArg: "'%' "
 --  isValue: true formalArg: "in ch: val char " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put('%') " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "'%' "
 -- handleInv: "'%' " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "'%' " 
 --  "'%' " false 
 -- needOriginII: "'%' " 
 -- E: Char: D: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 -- needOrigin: true "'%' " 
 -- exps.range: 1 exps[i]: "'%' " needOrigin: true 
 -- isConst: "'%' " Char: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 -- isConstLiteral: "'%' " 
 pushc 37
 -- const:cst: "'%' " 37 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "'%' ":isBasicVal: true 
 -- case:B: '%' ObjectGenerator 3 3 3 false true 
 -- isIntForFloatArg: "'%' " D: "in ch: val char " false false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "'%' " false 
 --  B: false 
 --  
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 -- end:loadArgs:NonVirt: "put('%') "
 -- loadPathII:before:newInvoke: "put('%') " true 
 -- checkForProxy:E: "put('%') " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "put('%') " 
 -- ptn:newInvoke: "put " staticOff: 0 
 -- oPTN:newInvoke: "put " 2 
 %put 2
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  151   "for:to:repeat$151 "
 invoke for:to:repeat$151 151 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign: "OL := this(OrderedList) " 
 -- handleInv: "OL " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "OL " 
 --  "OL " false 
 -- needOriginII: "OL " 
 -- E: ObjectInvocation_Unary D: "out OL: ref OrderedList " 
 -- needOrigin: true "OL " 
 -- exps.range: 1 exps[i]: "OL " needOrigin: true 
 -- isConst: "OL " ObjectInvocation_Unary "out OL: ref OrderedList " 
 -- isConst:DI: "out OL: ref OrderedList " 
 -- updateOffset: "OL " E.ATd: "out OL: ref OrderedList " 
 -- loadPathII:E: "OL " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "OL " 
 pushThis 
 -- loadPathII:before:newInvoke: "OL " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "OL := this(OrderedList) " leftE: "OL " 
 -- OG:before:super.gen: "this(OrderedList) "
 -- handleInv: "this(OrderedList) " staticOff: 0 doLoad: true 
 --  useRtnVal: true 
 -- isPtnWithOrigin: "this(OrderedList) " 
 --  "this(OrderedList) " true 
 -- needOriginII: "this(OrderedList) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  this: 
 --     %basic 18
 --     in this: ref Object
 --  
 -- needOrigin: true "this(OrderedList) " 
 -- exps.range: 1 exps[i]: "this(OrderedList) " needOrigin: true 
 -- isConst: "this(OrderedList) " ObjectInvocation_KeyWord 
 --  this: 
 --     %basic 18
 --     in this: ref Object
 --  
 -- updateOffset: "this(OrderedList) " E.ATd: 
 --  this: 
 --     %basic 18
 --     in this: ref Object
 --  
 -- loadPathII:E: "this(OrderedList) " 1 1 exps.range: 1 
 --  staticOff: 0 
 -- loadOriginII: "this(OrderedList) " 
 pushThis 
 -- items:goOrigin:encOG: "insertList "on: 1 isValueObj: false 
 --  origin: OrderedList origin:isValueObj: false 
 rpushg insertList$147 1
 -- loadPathII:before:newInvoke: "this(OrderedList) " true 
 -- checkForProxy:E: "this(OrderedList) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "this(OrderedList) " 
 -- ptn:newInvoke: "this " staticOff: 0 
 -- gPTN:newInvoke: "this " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: none 
 -- invoke:nonVirtual: "this " isAdr: false 
 -- invoke:primitive: "this " 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "OL := this(OrderedList) " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- checkI2F2I: "OL := this(OrderedList) " left.isFloat: false 
 --  right.isFloat: false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- Assign:end: "OL := this(OrderedList) " isNotRemote: false qual: 
 --  Collection
 --     %id "OrderedList"
 --     has::< 
 --        B := false
 --  D: none 
 -- DI:newStore: "OL " off: 3 valueOff: 0 dstE: "OL " isNotRemote: 
 --  false originIsValueObj: false isUnitValueObj: false rightQual:primNo: 0 
 --  rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 -- DI:newStore:ref/String: "out OL: ref OrderedList " 
 rswap 0
 rstoreg  OL$0 3
   ;; vTop(0,0)=[] rTop(-5,0)=[]
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS length 148 1 IndexedRef 153
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "out res: var integer " DI:isConst: false isBasicValue: 
 --  true primNo: 1 
 -- DI:gen:primitiveType: res 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- handleAssign: "res := get[0] " 
 -- handleInv: "res " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "res " 
 --  "res " false 
 -- needOriginII: "res " 
 -- E: ObjectInvocation_Unary D: "out res: var integer " 
 -- needOrigin: true "res " 
 -- exps.range: 1 exps[i]: "res " needOrigin: true 
 -- isConst: "res " ObjectInvocation_Unary "out res: var integer " 
 -- isConst:DI: "out res: var integer " 
 -- updateOffset: "res " E.ATd: "out res: var integer " 
 -- loadPathII:E: "res " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "res " 
 pushThis 
 -- loadPathII:before:newInvoke: "res " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "res := get[0] " leftE: "res " 
 -- OG:before:super.gen: "get[0] "
 -- handleInv: "get[0] " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "get[0] " 
 --  "get[0] " true 
 -- needOriginII: "get[0] " 
 -- E: ObjectInvocation_KeyWord D: 
 --  get[inx: var integer]: 
 --     %basic 116
 --     out V: ref elm
 --  
 -- needOrigin: true "get[0] " 
 -- exps.range: 1 exps[i]: "get[0] " needOrigin: true 
 -- isConst: "get[0] " ObjectInvocation_KeyWord 
 --  get[inx: var integer]: 
 --     %basic 116
 --     out V: ref elm
 --  
 -- updateOffset: "get[0] " E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 116
 --     out V: ref elm
 --  
 -- loadPathII:E: "get[0] " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "get[0] " 
 pushThis 
 -- items:goOrigin:encOG: "length "on: 1 isValueObj: false 
 --  origin: IndexedRef origin:isValueObj: false 
 rpushg length$148 1
 -- NonVirt: "get[0] " "ObjectInvocation_KeyWord " ActArg: "0 "
 --  isValue: true formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[0] " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "0 "
 -- handleInv: "0 " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "0 " 
 --  "0 " false 
 -- needOriginII: "0 " 
 -- E: ConstLiteral D: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- needOrigin: true "0 " 
 -- exps.range: 1 exps[i]: "0 " needOrigin: true 
 -- isConst: "0 " ConstLiteral 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- isConstLiteral: "0 " 
 pushc 0
 -- const:cst: "0 " 0 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: true formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "0 ":isBasicVal: true 
 -- case:B: 0 ObjectGenerator 1 1 1 false true 
 -- isIntForFloatArg: "0 " D: "inx: var integer " true false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "0 " false 
 --  B: false 
 --  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- end:loadArgs:NonVirt: "get[0] "
 -- loadPathII:before:newInvoke: "get[0] " true 
 -- checkForProxy:E: "get[0] " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "get[0] " 
 -- ptn:newInvoke: "get[inx: var integer] " staticOff: 0 
 -- indexPTN:newInvoke: "get[inx: var integer] " isAdr: false 
 -- IndexedPTN:newInvoke: 
 --  get[inx: var integer]: 
 --     %basic 116
 --     out V: ref elm
 --  E: "get[0] " rec: none 
 -- isAdr: false 
 xpushg  inx 1 0 1
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "res := get[0] " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- right:isPTN:not:valueObj: "out V: ref elm " 
 -- checkI2F2I: "res := get[0] " left.isFloat: false right.isFloat: 
 --  false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- Assign:end: "res := get[0] " isNotRemote: false qual: 
 --  %ID Object
 --     %basic 64
 --     %public
 --     ==  : 
 --  D: none 
 -- DI:newStore: "res " off: 2 valueOff: 0 dstE: "res " 
 --  isNotRemote: false originIsValueObj: false isUnitValueObj: false 
 --  rightQual:primNo: 64 rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 storeg integer$5 2
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS repeat$150 150 1 for:to:repeat$151 151
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "insert(elms.get[inx]) "
 -- handleInv: "insert(elms.get[inx]) " staticOff: 0 doLoad: true 
 --  useRtnVal: false 
 -- isPtnWithOrigin: "insert(elms.get[inx]) " 
 --  "insert(elms.get[inx]) " true 
 -- needOriginII: "insert(elms.get[inx]) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  insert:: 
 --     if (head == none) :then 
 --        head := Link(e):next(none)
 --        tail := head
 -- needOrigin: true "insert(elms.get[inx]) " 
 -- exps.range: 1 exps[i]: "insert(elms.get[inx]) " needOrigin: 
 --  true 
 -- isConst: "insert(elms.get[inx]) " ObjectInvocation_KeyWord 
 --  insert:: 
 --     if (head == none) :then 
 --        head := Link(e):next(none)
 --        tail := head
 -- updateOffset: "insert(elms.get[inx]) " E.ATd: 
 --  insert:: 
 --     if (head == none) :then 
 --        head := Link(e):next(none)
 --        tail := head
 -- loadPathII:E: "insert(elms.get[inx]) " 1 1 exps.range: 1 
 --  staticOff: 0 
 -- loadOriginII: "insert(elms.get[inx]) " 
 pushThis 
 -- items:goOrigin:encOG: "repeat$150 "on: 3 isValueObj: false 
 --  origin: for:to:repeat$151 origin:isValueObj: false 
 rpushg repeat$150$150 1
 -- items:goOrigin:encOG: "for:to:repeat$151 "on: 2 isValueObj: 
 --  false 
 --  origin: insertList origin:isValueObj: false 
 rpushg for:to:repeat$151$151 4
 -- items:goOrigin:encOG: "insertList "on: 1 isValueObj: false 
 --  origin: OrderedList origin:isValueObj: false 
 rpushg insertList$147 1
 -- NonVirt: "insert(elms.get[inx]) " "ObjectInvocation_KeyWord " 
 --  ActArg: "elms.get[inx] "isValue: false formalArg: "in e: ref elm " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "insert(elms.get[inx]) "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "elms.get[inx] "
 -- handleInv: "elms.get[inx] " staticOff: 0 doLoad: true 
 --  useRtnVal: true 
 -- isPtnWithOrigin: "elms.get[inx] " 
 --  "elms " false "get[inx] " true 
 -- needOriginII: "elms.get[inx] " 
 -- E: ObjectInvocation_Unary D: "elms: ref IndexedRef(3,#Elm) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  get[inx: var integer]: 
 --     %basic 116
 --     out V: ref elm
 --  
 -- needOrigin: true "get[inx] " 
 -- exps.range: 2 exps[i]: "elms " exps[i]: "get[inx] " needOrigin: 
 --  true 
 -- isConst: "elms " ObjectInvocation_Unary "
 --  elms: ref IndexedRef(3,#Elm) " 
 -- isConst:DI: "elms: ref IndexedRef(3,#Elm) " 
 -- updateOffset: "elms " E.ATd: "elms: ref IndexedRef(3,#Elm) " 
 -- isConst: "get[inx] " ObjectInvocation_KeyWord 
 --  get[inx: var integer]: 
 --     %basic 116
 --     out V: ref elm
 --  
 -- updateOffset: "get[inx] " E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 116
 --     out V: ref elm
 --  
 -- loadPathII:E: "elms " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "elms " 
 pushThis 
 -- items:goOrigin:encOG: "repeat$150 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$151 origin:isValueObj: false 
 rpushg repeat$150$150 1
 -- items:goOrigin:encOG: "for:to:repeat$151 "on: 1 isValueObj: 
 --  false 
 --  origin: insertList origin:isValueObj: false 
 rpushg for:to:repeat$151$151 4
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "elms " 
 -- DI:loadAccessor: "elms " 
 -- DI:loadAccessor:Obj: "elms: ref IndexedRef(3,#Elm) " 
 rpushg newInvoke 2
 -- loadPathII:E: "get[inx] " 1 2 exps.range: 2 staticOff: 0 
 -- E: "get[inx] " E:isPrimitiveIntWithFloatArg: false rec: "elms " 
 --  isFloat: false 
 -- NonVirt: "get[inx] " "ObjectInvocation_KeyWord " ActArg: "inx "
 --  isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx] " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "inx "
 -- handleInv: "inx " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "inx " 
 --  "inx " false 
 -- needOriginII: "inx " 
 -- E: ObjectInvocation_Unary D: "inx: var integer " 
 -- needOrigin: true "inx " 
 -- exps.range: 1 exps[i]: "inx " needOrigin: true 
 -- isConst: "inx " ObjectInvocation_Unary "inx: var integer " 
 -- isConst:DI: "inx: var integer " 
 -- updateOffset: "inx " E.ATd: "inx: var integer " 
 -- loadPathII:E: "inx " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "inx " 
 pushThis 
 -- items:goOrigin:encOG: "repeat$150 "on: 1 isValueObj: false 
 --  origin: for:to:repeat$151 origin:isValueObj: false 
 rpushg repeat$150$150 1
 -- loadPathII:before:newInvoke: "inx " true 
 -- checkForProxy:E: "inx " isBasicValue: true origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "inx " 
 -- DI:newInvoke: "inx: var integer " off: 1 valueOff: 0 E: "inx " 
 --  next: none isAdr: false 
 -- DI:newInvoke:loadPrimitive: "inx " isAdr: false valueOff: 0 
 pushg 3 newInvoke
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- isIntForFloatArg: "inx " D: "inx: var integer " true false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "inx " 
 --  B: false 
 --  "inx: var integer " 
 -- end:loadArgs:NonVirt: "get[inx] "
 -- loadPathII:before:newInvoke: "get[inx] " true 
 -- checkForProxy:E: "get[inx] " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: "elms " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "get[inx] " 
 -- ptn:newInvoke: "get[inx: var integer] " staticOff: 0 
 -- indexPTN:newInvoke: "get[inx: var integer] " isAdr: false 
 -- IndexedPTN:newInvoke: 
 --  get[inx: var integer]: 
 --     %basic 116
 --     out V: ref elm
 --  E: "get[inx] " rec: "elms " 
 -- isAdr: false 
 xrpushg  1 inx
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: true formalArg:isPtn: "in e: ref elm "
 --  :isBasicVal: false :valueObj: false 
 --  :actArg: "elms.get[inx] ":isBasicVal: false 
 -- case:B: elms.get[inx] ObjectGenerator 0 116 116 false false 
 -- isIntForFloatArg: "elms.get[inx] " D: "in e: ref elm " false 
 --  false srcOG.isFloat: false src.isUnitValueObj: false this: "
 --  elms.get[inx] " false 
 --  B: false 
 --  
 --  get[inx: var integer]: 
 --     %basic 116
 --     out V: ref elm
 --  
 -- end:loadArgs:NonVirt: "insert(elms.get[inx]) "
 -- loadPathII:before:newInvoke: "insert(elms.get[inx]) " true 
 -- checkForProxy:E: "insert(elms.get[inx]) " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "insert(elms.get[inx]) " 
 -- ptn:newInvoke: "insert " staticOff: 0 
 -- gPTN:newInvoke: "insert " ptnKind: 3 staticOff: 0 valueOff: 0 
 --  rec: none 
 -- invoke:Virtual: "insert " E: "insert(elms.get[inx]) " 
 --  E.ATd.isValueObj: false this:isVal: false rec: none isStatic: false 
 invokev 3 1 insert$137 0
 -- GeneralPTN:invoke:after:pushOut: 
 rpop 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS for:to:repeat$151 151 4 insertList 147
 -- vdtTableCopy: I:1:28 V:2:29
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- NonVirt: 
 --  for(1):to(elms.length):repeat
 --     insert(elms.get[inx])
 --  "ObjectInvocation_KeyWord " ActArg: "1 "isValue: true formalArg: "
 --  first: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  for(1):to(elms.length):repeat
 --     insert(elms.get[inx])
 --   " isCompositeValueObj: false 
 -- OG:before:super.gen: "1 "
 -- handleInv: "1 " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "1 " 
 --  "1 " false 
 -- needOriginII: "1 " 
 -- E: ConstLiteral D: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- needOrigin: true "1 " 
 -- exps.range: 1 exps[i]: "1 " needOrigin: true 
 -- isConst: "1 " ConstLiteral 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- isConstLiteral: "1 " 
 pushc 1
 -- const:cst: "1 " 1 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: true formalArg:isPtn: "first: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- isIntForFloatArg: "1 " D: "first: var integer " true false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "1 " false 
 --  B: false 
 --  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- end:loadArgs:NonVirt: "
 --  for(1):to(elms.length):repeat
 --     insert(elms.get[inx])
 --   "
 -- NonVirt: 
 --  for(1):to(elms.length):repeat
 --     insert(elms.get[inx])
 --  "ObjectInvocation_KeyWord " ActArg: "elms.length "isValue: false 
 --  formalArg: "last: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  for(1):to(elms.length):repeat
 --     insert(elms.get[inx])
 --   " isCompositeValueObj: false 
 -- OG:before:super.gen: "elms.length "
 -- handleInv: "elms.length " staticOff: 0 doLoad: true useRtnVal: 
 --  true 
 -- isPtnWithOrigin: "elms.length " 
 --  "elms " false "length " true 
 -- needOriginII: "elms.length " 
 -- E: ObjectInvocation_Unary D: "elms: ref IndexedRef(3,#Elm) " 
 -- E: ObjectInvocation_Unary D: 
 --  length: 
 --     out res: var integer
 --     res := get[0]
 --  
 -- needOrigin: true "length " 
 -- exps.range: 2 exps[i]: "elms " exps[i]: "length " needOrigin: 
 --  true 
 -- isConst: "elms " ObjectInvocation_Unary "
 --  elms: ref IndexedRef(3,#Elm) " 
 -- isConst:DI: "elms: ref IndexedRef(3,#Elm) " 
 -- updateOffset: "elms " E.ATd: "elms: ref IndexedRef(3,#Elm) " 
 -- isConst: "length " ObjectInvocation_Unary 
 --  length: 
 --     out res: var integer
 --     res := get[0]
 --  
 -- updateOffset: "length " E.ATd: 
 --  length: 
 --     out res: var integer
 --     res := get[0]
 --  
 -- loadPathII:E: "elms " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "elms " 
 pushThis 
 rpushg insertList$147 4
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "elms " 
 -- DI:loadAccessor: "elms " 
 -- DI:loadAccessor:Obj: "elms: ref IndexedRef(3,#Elm) " 
 rpushg newInvoke 2
 -- loadPathII:E: "length " 1 2 exps.range: 2 staticOff: 0 
 -- E: "length " E:isPrimitiveIntWithFloatArg: false rec: "elms " 
 --  isFloat: false 
 -- loadPathII:before:newInvoke: "length " true 
 -- checkForProxy:E: "length " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: "elms " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "length " 
 -- ptn:newInvoke: "length " staticOff: 0 
 -- gPTN:newInvoke: "length " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: "elms " 
 -- invoke:nonVirtual: "length " isAdr: false 
 invoke length 148 0 0
 -- global:pushOut: res off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: true formalArg:isPtn: "last: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "elms.length ":isBasicVal: true 
 -- case:B: elms.length ObjectGenerator 1 0 0 false false 
 -- isIntForFloatArg: "elms.length " D: "last: var integer " true 
 --  false srcOG.isFloat: false src.isUnitValueObj: false this: "
 --  elms.length " false 
 --  B: false 
 --  
 --  length: 
 --     out res: var integer
 --     res := get[0]
 --  
 -- end:loadArgs:NonVirt: "
 --  for(1):to(elms.length):repeat
 --     insert(elms.get[inx])
 --   "
 pushThis 
 storeg integer$5 2
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- DI:gen: "inx: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: inx 
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0

 CLASS OrderedList$152 152 0 insertList 147
 -- vdtTableCopy: I:1:80 V:2:0 V:3:137 V:4:126 V:5:97 V:6:133 V:7:134 V:8:136 I:9:92
 -- super OrderedList
 -- super OrderedList
 allocEventQ
 -- DI:gen: "head: ref link:next " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 -- DI:gen: "tail: ref Link:next " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 rtnAlloc 1
 toSuper 80
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS + 155 1 String 10
 pushThis 
 rstoreg  S 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in S: var String " DI:isConst: false isBasicValue: 
 --  false primNo: 5 
 -- DI:gen: "out V: var String " DI:isConst: false isBasicValue: 
 --  false primNo: 5 
 -- DI:StringVar "out V: var String "
 pushText ""
 pushThis 
 rstoreg  V 3
   ;; vTop(0,0)=[] rTop(-3,0)=[]
 -- DI:gen: "L: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: L 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- handleAssign: "L := Length " 
 -- handleInv: "L " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "L " 
 --  "L " false 
 -- needOriginII: "L " 
 -- E: ObjectInvocation_Unary D: "L: var integer " 
 -- needOrigin: true "L " 
 -- exps.range: 1 exps[i]: "L " needOrigin: true 
 -- isConst: "L " ObjectInvocation_Unary "L: var integer " 
 -- isConst:DI: "L: var integer " 
 -- updateOffset: "L " E.ATd: "L: var integer " 
 -- loadPathII:E: "L " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "L " 
 pushThis 
 -- loadPathII:before:newInvoke: "L " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "L := Length " leftE: "L " 
 -- OG:before:super.gen: "Length "
 -- handleInv: "Length " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "Length " 
 --  "Length " true 
 -- needOriginII: "Length " 
 -- E: ObjectInvocation_Unary D: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- needOrigin: true "Length " 
 -- exps.range: 1 exps[i]: "Length " needOrigin: true 
 -- isConst: "Length " ObjectInvocation_Unary 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- updateOffset: "Length " E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- loadPathII:E: "Length " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "Length " 
 pushThis 
 -- items:goOrigin:encOG: "+ "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg +$155 1
 -- loadPathII:before:newInvoke: "Length " true 
 -- checkForProxy:E: "Length " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "Length " 
 -- ptn:newInvoke: "length " staticOff: 0 
 -- gPTN:newInvoke: "length " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: none 
 -- invoke:nonVirtual: "length " isAdr: false 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "L := Length " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- right:isPTN:not:valueObj: "out V: var integer " 
 -- checkI2F2I: "L := Length " left.isFloat: false right.isFloat: 
 --  false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- Assign:end: "L := Length " isNotRemote: false qual: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  D: none 
 -- DI:newStore: "L " off: 4 valueOff: 0 dstE: "L " isNotRemote: 
 --  false originIsValueObj: false isUnitValueObj: false rightQual:primNo: 1 
 --  rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 storeg integer$5 4
 pushThis 
 -- before objTmpStack:add:  156   "doplus "
 invoke doplus 156 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS doplus 156 1 + 155
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "e: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: e 
 -- DI:gen: "i: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: i 
 -- DI:gen: "T: obj Indexed(L + S.length,Integer) " DI:isConst: true 
 --  isBasicValue: false primNo: 114 
 -- DI:isConst: T 
 -- DI:off: 4 this: "T: obj Indexed(L + S.length,Integer) " 
 --  
 -- OG:before:super.gen: "Indexed(L + S.length,Integer) "
 -- handleInv: "Indexed(L + S.length,Integer) " staticOff: 4 
 --  doLoad: true useRtnVal: false 
 -- isPtnWithOrigin: "Indexed(L + S.length,Integer) " 
 --  "Indexed(L + S.length,Integer) " false 
 -- needOriginII: "Indexed(L + S.length,Integer) " 
 -- E: ObjectInvocation_Function D: 
 --  Indexed: 
 --     %globals
 --     %basic 114
 --     %public
 -- needOrigin: false "Indexed(L + S.length,Integer) " 
 -- exps.range: 1 exps[i]: "Indexed(L + S.length,Integer) " 
 --  needOrigin: false 
 -- isConst: "Indexed(L + S.length,Integer) " 
 --  ObjectInvocation_Function 
 --  Indexed: 
 --     %globals
 --     %basic 114
 --     %public
 -- noOrigin: "Indexed(L + S.length,Integer) " 
 -- loadPathII:E: "Indexed(L + S.length,Integer) " 1 1 exps.range: 1 
 --  staticOff: 4 
 -- NonVirt: "Indexed(L + S.length,Integer) " "
 --  ObjectInvocation_Function " ActArg: "L + S.length "isValue: false formalArg: "
 --  in range: var Integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "Indexed(L + S.length,Integer) "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "L + S.length "
 -- handleInv: "L + S.length " staticOff: 0 doLoad: true useRtnVal: 
 --  true 
 -- isPtnWithOrigin: "L + S.length " 
 --  "L " false "+ S.length " true 
 -- needOriginII: "L + S.length " 
 -- E: ObjectInvocation_Unary D: "L: var integer " 
 -- E: ObjectInvocation_Binary D: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- needOrigin: true "+ S.length " 
 -- exps.range: 2 exps[i]: "L " exps[i]: "+ S.length " needOrigin: 
 --  true 
 -- isConst: "L " ObjectInvocation_Unary "L: var integer " 
 -- isConst:DI: "L: var integer " 
 -- updateOffset: "L " E.ATd: "L: var integer " 
 -- isConst: "+ S.length " ObjectInvocation_Binary 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- updateOffset: "+ S.length " E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- loadPathII:E: "L " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "L " 
 pushThis 
 -- items:goOrigin:encOG: "doplus "on: 1 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$156 1
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "L " 
 -- DI:loadAccessor: "L " 
 -- DI:loadAccesor:loadPrimitive: "L " 
 pushg 4 newInvoke
 -- loadPathII:E: "+ S.length " 1 2 exps.range: 2 staticOff: 0 
 -- "length " 
 -- "length " 
 -- E: "+ S.length " E:isPrimitiveIntWithFloatArg: false rec: "L " 
 --  isFloat: false 
 -- NonVirt: "+ S.length " "ObjectInvocation_Binary " ActArg: "
 --  S.length "isValue: false formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ S.length " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "S.length "
 -- handleInv: "S.length " staticOff: 0 doLoad: true useRtnVal: 
 --  true 
 -- isPtnWithOrigin: "S.length " 
 --  "S " false "length " true 
 -- needOriginII: "S.length " 
 -- E: ObjectInvocation_Unary D: "in S: var String " 
 -- E: ObjectInvocation_Unary D: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- needOrigin: true "length " 
 -- exps.range: 2 exps[i]: "S " exps[i]: "length " needOrigin: true 
 -- isConst: "S " ObjectInvocation_Unary "in S: var String " 
 -- isConst:DI: "in S: var String " 
 -- updateOffset: "S " E.ATd: "in S: var String " 
 -- isConst: "length " ObjectInvocation_Unary 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- updateOffset: "length " E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- loadPathII:E: "S " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "S " 
 pushThis 
 -- items:goOrigin:encOG: "doplus "on: 1 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$156 1
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "S " 
 -- DI:loadAccessor: "S " 
 -- DI:loadAccessor:Obj: "in S: var String " 
 rpushg newInvoke 2
 -- loadPathII:E: "length " 1 2 exps.range: 2 staticOff: 0 
 -- E: "length " E:isPrimitiveIntWithFloatArg: false rec: "S " 
 --  isFloat: false 
 -- loadPathII:before:newInvoke: "length " true 
 -- checkForProxy:E: "length " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: "S " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "length " 
 -- ptn:newInvoke: "length " staticOff: 0 
 -- gPTN:newInvoke: "length " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: "S " 
 -- invoke:nonVirtual: "length " isAdr: false 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "S.length ":isBasicVal: true 
 -- case:B: S.length ObjectGenerator 1 0 0 false false 
 -- isIntForFloatArg: "S.length " D: "in V: var integer " true false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "S.length " false 
 --  B: false 
 --  
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- end:loadArgs:NonVirt: "+ S.length "
 -- loadPathII:before:newInvoke: "+ S.length " true 
 -- checkForProxy:E: "+ S.length " isBasicValue: true 
 --  origin.isValueObj: true staticOff: 0 rec: "L " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "+ S.length " 
 -- ptn:newInvoke: "+   " staticOff: 0 
 -- gPTN:newInvoke: "+   " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: "L " 
 -- "length " 
 -- checkInt2IntWithUnitArg:E: "+ S.length " false false 
 -- "length " 
 plus
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: true formalArg:isPtn: "in range: var Integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "L + S.length ":isBasicVal: true 
 -- case:B: L + S.length ObjectGenerator 1 61 61 false false 
 -- isIntForFloatArg: "L + S.length " D: "in range: var Integer " 
 --  true false srcOG.isFloat: false src.isUnitValueObj: false this: "
 --  L + S.length " false 
 --  B: false 
 --  
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- end:loadArgs:NonVirt: "Indexed(L + S.length,Integer) "
 -- loadPathII:before:newInvoke: "Indexed(L + S.length,Integer) " 
 --  true 
 -- checkForProxy:E: "Indexed(L + S.length,Integer) " isBasicValue: 
 --  false origin.isValueObj: false staticOff: 4 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "Indexed(L + S.length,Integer) " 
 -- ptn:newInvoke: "Indexed " staticOff: 4 
 -- indexPTN:newInvoke: "Indexed " isAdr: false 
 pushThis 
 pushc 1
 allocIndexed doplus$156 157 1 0
 pushThis 
 rstoreg  doplus$156 4
   ;; vTop(2,2)=[0/0,0/0] rTop(-4,0)=[]
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 pushThis 
 -- before objTmpStack:add:  161   "for:to:repeat$161 "
 invoke for:to:repeat$161 161 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  163   "for:to:repeat$163 "
 invoke for:to:repeat$163 163 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign: 
 --  V := T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- handleInv: "V " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "V " 
 --  "V " false 
 -- needOriginII: "V " 
 -- E: ObjectInvocation_Unary D: "out V: var String " 
 -- needOrigin: true "V " 
 -- exps.range: 1 exps[i]: "V " needOrigin: true 
 -- isConst: "V " ObjectInvocation_Unary "out V: var String " 
 -- isConst:DI: "out V: var String " 
 -- updateOffset: "V " E.ATd: "out V: var String " 
 -- loadPathII:E: "V " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "V " 
 pushThis 
 -- items:goOrigin:encOG: "doplus "on: 1 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$156 1
 -- loadPathII:before:newInvoke: "V " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: 
 --  V := T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  leftE: "V " 
 -- OG:before:super.gen: "
 --  T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "
 -- handleInv: 
 --  T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: 
 --  T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 --  "T " false 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  true 
 -- needOriginII: 
 --  T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- E: ObjectInvocation_Unary D: "
 --  T: obj Indexed(L + S.length,Integer) " 
 -- E: ObjectInvocation_Unary D: 
 --  asString: 
 --     %basic 118
 --     out S: var LIB.StringLib.String
 --  
 -- needOrigin: true 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- exps.range: 2 exps[i]: "T " exps[i]: 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  needOrigin: true 
 -- isConst: "T " ObjectInvocation_Unary "
 --  T: obj Indexed(L + S.length,Integer) " 
 -- isConst:DI: "T: obj Indexed(L + S.length,Integer) " 
 -- updateOffset: "T " E.ATd: "
 --  T: obj Indexed(L + S.length,Integer) " 
 -- isConst: 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  ObjectInvocation_Unary 
 --  asString: 
 --     %basic 118
 --     out S: var LIB.StringLib.String
 --  
 -- updateOffset: 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  E.ATd: 
 --  asString: 
 --     %basic 118
 --     out S: var LIB.StringLib.String
 --  
 -- loadPathII:E: "T " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "T " 
 pushThis 
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "T " 
 -- DI:loadAccessor: "T " 
 -- DI:loadAccessor:Obj: "T: obj Indexed(L + S.length,Integer) " 
 rpushg newInvoke 4
 -- loadPathII:E: 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  1 2 exps.range: 2 staticOff: 0 
 -- E: 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  E:isPrimitiveIntWithFloatArg: false rec: "T " isFloat: false 
 -- loadPathII:before:newInvoke: 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  true 
 -- checkForProxy:E: 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  isBasicValue: false origin.isValueObj: false staticOff: 0 rec: "
 --  T " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- ptn:newInvoke: "asString " staticOff: 0 
 -- indexPTN:newInvoke: "asString " isAdr: false 
 %asString 118
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: 
 --  V := T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- right:isPTN:not:valueObj: "out S: var LIB.StringLib.String " 
 -- "StringLib " 
 -- 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- checkI2F2I: 
 --  V := T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  left.isFloat: false right.isFloat: false false left.isFloat:X: 
 --  false 
 -- ???:left.isFloat: false 
 -- "StringLib " 
 -- 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- Assign:end: 
 --  V := T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  isNotRemote: false qual: 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 --  D: none 
 -- DI:newStore: "V " off: 3 valueOff: 0 dstE: "V " isNotRemote: 
 --  false originIsValueObj: false isUnitValueObj: false rightQual:primNo: 5 
 --  rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 -- DI:newStore:ref/String: "out V: var String " 
 rswap 0
 rstoreg  String$10 3
   ;; vTop(2,2)=[0/0,0/0] rTop(-8,0)=[]
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS Indexed 157 0 BETA 2
 pushThis 
 storeg integer$5 1
 allocEventQ
 mvStack 
 -- DI:gen: "in range: var Integer " DI:isConst: false isBasicValue: 
 --  true primNo: 1 
 -- DI:gen:primitiveType: range 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:1

 CLASS repeat$159 159 1 for:to:repeat$161 161
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- handleAssign: "e := get[inx] " 
 -- handleInv: "e " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "e " 
 --  "e " false 
 -- needOriginII: "e " 
 -- E: ObjectInvocation_Unary D: "e: var integer " 
 -- needOrigin: true "e " 
 -- exps.range: 1 exps[i]: "e " needOrigin: true 
 -- isConst: "e " ObjectInvocation_Unary "e: var integer " 
 -- isConst:DI: "e: var integer " 
 -- updateOffset: "e " E.ATd: "e: var integer " 
 -- loadPathII:E: "e " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "e " 
 pushThis 
 -- items:goOrigin:encOG: "repeat$159 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$161 origin:isValueObj: false 
 rpushg repeat$159$159 1
 -- items:goOrigin:encOG: "for:to:repeat$161 "on: 1 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$161$161 4
 -- loadPathII:before:newInvoke: "e " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "e := get[inx] " leftE: "e " 
 -- OG:before:super.gen: "get[inx] "
 -- handleInv: "get[inx] " staticOff: 0 doLoad: true useRtnVal: 
 --  true 
 -- isPtnWithOrigin: "get[inx] " 
 --  "get[inx] " true 
 -- needOriginII: "get[inx] " 
 -- E: ObjectInvocation_KeyWord D: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- needOrigin: true "get[inx] " 
 -- exps.range: 1 exps[i]: "get[inx] " needOrigin: true 
 -- isConst: "get[inx] " ObjectInvocation_KeyWord 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- updateOffset: "get[inx] " E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- loadPathII:E: "get[inx] " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "get[inx] " 
 pushThis 
 -- items:goOrigin:encOG: "repeat$159 "on: 4 isValueObj: false 
 --  origin: for:to:repeat$161 origin:isValueObj: false 
 rpushg repeat$159$159 1
 -- items:goOrigin:encOG: "for:to:repeat$161 "on: 3 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$161$161 4
 -- items:goOrigin:encOG: "doplus "on: 2 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$156 1
 -- items:goOrigin:encOG: "+ "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg +$155 1
 -- NonVirt: "get[inx] " "ObjectInvocation_KeyWord " ActArg: "inx "
 --  isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx] " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "inx "
 -- handleInv: "inx " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "inx " 
 --  "inx " false 
 -- needOriginII: "inx " 
 -- E: ObjectInvocation_Unary D: "inx: var integer " 
 -- needOrigin: true "inx " 
 -- exps.range: 1 exps[i]: "inx " needOrigin: true 
 -- isConst: "inx " ObjectInvocation_Unary "inx: var integer " 
 -- isConst:DI: "inx: var integer " 
 -- updateOffset: "inx " E.ATd: "inx: var integer " 
 -- loadPathII:E: "inx " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "inx " 
 pushThis 
 -- items:goOrigin:encOG: "repeat$159 "on: 1 isValueObj: false 
 --  origin: for:to:repeat$161 origin:isValueObj: false 
 rpushg repeat$159$159 1
 -- loadPathII:before:newInvoke: "inx " true 
 -- checkForProxy:E: "inx " isBasicValue: true origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "inx " 
 -- DI:newInvoke: "inx: var integer " off: 1 valueOff: 0 E: "inx " 
 --  next: none isAdr: false 
 -- DI:newInvoke:loadPrimitive: "inx " isAdr: false valueOff: 0 
 pushg 3 newInvoke
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- isIntForFloatArg: "inx " D: "inx: var integer " true false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "inx " 
 --  B: false 
 --  "inx: var integer " 
 -- end:loadArgs:NonVirt: "get[inx] "
 -- loadPathII:before:newInvoke: "get[inx] " true 
 -- checkForProxy:E: "get[inx] " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "get[inx] " 
 -- ptn:newInvoke: "get[inx: var integer] " staticOff: 0 
 -- indexPTN:newInvoke: "get[inx: var integer] " isAdr: false 
 xpushg  inx 1 0 1
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "e := get[inx] " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- right:isPTN:not:valueObj: "out ch: var char " 
 -- checkI2F2I: "e := get[inx] " left.isFloat: false right.isFloat: 
 --  false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- Assign:end: "e := get[inx] " isNotRemote: false qual: 
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  D: none 
 -- DI:newStore: "e " off: 2 valueOff: 0 dstE: "e " isNotRemote: 
 --  false originIsValueObj: false isUnitValueObj: false rightQual:primNo: 3 
 --  rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 storeg integer$5 2
 -- OG:before:super.gen: "T.put(e):at[inx] "
 -- handleInv: "T.put(e):at[inx] " staticOff: 0 doLoad: true 
 --  useRtnVal: false 
 -- isPtnWithOrigin: "T.put(e):at[inx] " 
 --  "T " false "put(e):at[inx] " true 
 -- needOriginII: "T.put(e):at[inx] " 
 -- E: ObjectInvocation_Unary D: "
 --  T: obj Indexed(L + S.length,Integer) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  put(V: var integer):at[inx: var integer]: 
 --     %basic 115
 --  
 -- needOrigin: true "put(e):at[inx] " 
 -- exps.range: 2 exps[i]: "T " exps[i]: "put(e):at[inx] " 
 --  needOrigin: true 
 -- isConst: "T " ObjectInvocation_Unary "
 --  T: obj Indexed(L + S.length,Integer) " 
 -- isConst:DI: "T: obj Indexed(L + S.length,Integer) " 
 -- updateOffset: "T " E.ATd: "
 --  T: obj Indexed(L + S.length,Integer) " 
 -- isConst: "put(e):at[inx] " ObjectInvocation_KeyWord 
 --  put(V: var integer):at[inx: var integer]: 
 --     %basic 115
 --  
 -- updateOffset: "put(e):at[inx] " E.ATd: 
 --  put(V: var integer):at[inx: var integer]: 
 --     %basic 115
 --  
 -- loadPathII:E: "T " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "T " 
 pushThis 
 -- items:goOrigin:encOG: "repeat$159 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$161 origin:isValueObj: false 
 rpushg repeat$159$159 1
 -- items:goOrigin:encOG: "for:to:repeat$161 "on: 1 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$161$161 4
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "T " 
 -- DI:loadAccessor: "T " 
 -- DI:loadAccessor:Obj: "T: obj Indexed(L + S.length,Integer) " 
 rpushg newInvoke 4
 -- loadPathII:E: "put(e):at[inx] " 1 2 exps.range: 2 staticOff: 0 
 -- E: "put(e):at[inx] " E:isPrimitiveIntWithFloatArg: false rec: "
 --  T " isFloat: false 
 -- NonVirt: "put(e):at[inx] " "ObjectInvocation_KeyWord " ActArg: "e "
 --  isValue: false formalArg: "V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(e):at[inx] "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "e "
 -- handleInv: "e " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "e " 
 --  "e " false 
 -- needOriginII: "e " 
 -- E: ObjectInvocation_Unary D: "e: var integer " 
 -- needOrigin: true "e " 
 -- exps.range: 1 exps[i]: "e " needOrigin: true 
 -- isConst: "e " ObjectInvocation_Unary "e: var integer " 
 -- isConst:DI: "e: var integer " 
 -- updateOffset: "e " E.ATd: "e: var integer " 
 -- loadPathII:E: "e " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "e " 
 pushThis 
 -- items:goOrigin:encOG: "repeat$159 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$161 origin:isValueObj: false 
 rpushg repeat$159$159 1
 -- items:goOrigin:encOG: "for:to:repeat$161 "on: 1 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$161$161 4
 -- loadPathII:before:newInvoke: "e " true 
 -- checkForProxy:E: "e " isBasicValue: true origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "e " 
 -- DI:newInvoke: "e: var integer " off: 1 valueOff: 0 E: "e " 
 --  next: none isAdr: false 
 -- DI:newInvoke:loadPrimitive: "e " isAdr: false valueOff: 0 
 pushg 2 newInvoke
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: false formalArg:isPtn: "V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "e ":isBasicVal: true 
 -- case:B: e ObjectGenerator 1 0 1 false false 
 -- isIntForFloatArg: "e " D: "V: var integer " true false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "e " 
 --  B: false 
 --  "e: var integer " 
 -- end:loadArgs:NonVirt: "put(e):at[inx] "
 -- NonVirt: "put(e):at[inx] " "ObjectInvocation_KeyWord " ActArg: "
 --  inx "isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(e):at[inx] "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "inx "
 -- handleInv: "inx " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "inx " 
 --  "inx " false 
 -- needOriginII: "inx " 
 -- E: ObjectInvocation_Unary D: "inx: var integer " 
 -- needOrigin: true "inx " 
 -- exps.range: 1 exps[i]: "inx " needOrigin: true 
 -- isConst: "inx " ObjectInvocation_Unary "inx: var integer " 
 -- isConst:DI: "inx: var integer " 
 -- updateOffset: "inx " E.ATd: "inx: var integer " 
 -- loadPathII:E: "inx " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "inx " 
 pushThis 
 -- items:goOrigin:encOG: "repeat$159 "on: 1 isValueObj: false 
 --  origin: for:to:repeat$161 origin:isValueObj: false 
 rpushg repeat$159$159 1
 -- loadPathII:before:newInvoke: "inx " true 
 -- checkForProxy:E: "inx " isBasicValue: true origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "inx " 
 -- DI:newInvoke: "inx: var integer " off: 1 valueOff: 0 E: "inx " 
 --  next: none isAdr: false 
 -- DI:newInvoke:loadPrimitive: "inx " isAdr: false valueOff: 0 
 pushg 3 newInvoke
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- isIntForFloatArg: "inx " D: "inx: var integer " true false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "inx " 
 --  B: false 
 --  "inx: var integer " 
 -- end:loadArgs:NonVirt: "put(e):at[inx] "
 -- loadPathII:before:newInvoke: "put(e):at[inx] " true 
 -- checkForProxy:E: "put(e):at[inx] " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: "T " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "put(e):at[inx] " 
 -- ptn:newInvoke: "put(V: var integer):at[inx: var integer] " 
 --  staticOff: 0 
 -- indexPTN:newInvoke: "put(V: var integer):at[inx: var integer] " 
 --  isAdr: false 
 -- IndexedPTN:newInvoke: 
 --  put(V: var integer):at[inx: var integer]: 
 --     %basic 115
 --  E: "put(e):at[inx] " rec: "T " 
 xstoreg  inx 1 0 1
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS for:to:repeat$161 161 4 doplus 156
 -- vdtTableCopy: I:1:28 V:2:29
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- NonVirt: 
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --  "ObjectInvocation_KeyWord " ActArg: "1 "isValue: true formalArg: "
 --  first: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --   " isCompositeValueObj: false 
 -- OG:before:super.gen: "1 "
 -- handleInv: "1 " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "1 " 
 --  "1 " false 
 -- needOriginII: "1 " 
 -- E: ConstLiteral D: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- needOrigin: true "1 " 
 -- exps.range: 1 exps[i]: "1 " needOrigin: true 
 -- isConst: "1 " ConstLiteral 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- isConstLiteral: "1 " 
 pushc 1
 -- const:cst: "1 " 1 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: true formalArg:isPtn: "first: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- isIntForFloatArg: "1 " D: "first: var integer " true false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "1 " false 
 --  B: false 
 --  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- end:loadArgs:NonVirt: "
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --   "
 -- NonVirt: 
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --  "ObjectInvocation_KeyWord " ActArg: "L "isValue: false 
 --  formalArg: "last: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --   " isCompositeValueObj: false 
 -- OG:before:super.gen: "L "
 -- handleInv: "L " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "L " 
 --  "L " false 
 -- needOriginII: "L " 
 -- E: ObjectInvocation_Unary D: "L: var integer " 
 -- needOrigin: true "L " 
 -- exps.range: 1 exps[i]: "L " needOrigin: true 
 -- isConst: "L " ObjectInvocation_Unary "L: var integer " 
 -- isConst:DI: "L: var integer " 
 -- updateOffset: "L " E.ATd: "L: var integer " 
 -- loadPathII:E: "L " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "L " 
 pushThis 
 rpushg doplus$156 4
 -- items:goOrigin:encOG: "doplus "on: 1 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$156 1
 -- loadPathII:before:newInvoke: "L " true 
 -- checkForProxy:E: "L " isBasicValue: true origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "L " 
 -- DI:newInvoke: "L: var integer " off: 1 valueOff: 0 E: "L " 
 --  next: none isAdr: false 
 -- DI:newInvoke:loadPrimitive: "L " isAdr: false valueOff: 0 
 pushg 4 newInvoke
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: false formalArg:isPtn: "last: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "L ":isBasicVal: true 
 -- case:B: L ObjectGenerator 1 0 1 false false 
 -- isIntForFloatArg: "L " D: "last: var integer " true false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "L " 
 --  B: false 
 --  "L: var integer " 
 -- end:loadArgs:NonVirt: "
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --   "
 pushThis 
 storeg integer$5 2
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- DI:gen: "inx: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: inx 
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0

 CLASS repeat$162 162 1 for:to:repeat$163 163
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- handleAssign: "e := S.get[inx] " 
 -- handleInv: "e " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "e " 
 --  "e " false 
 -- needOriginII: "e " 
 -- E: ObjectInvocation_Unary D: "e: var integer " 
 -- needOrigin: true "e " 
 -- exps.range: 1 exps[i]: "e " needOrigin: true 
 -- isConst: "e " ObjectInvocation_Unary "e: var integer " 
 -- isConst:DI: "e: var integer " 
 -- updateOffset: "e " E.ATd: "e: var integer " 
 -- loadPathII:E: "e " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "e " 
 pushThis 
 -- items:goOrigin:encOG: "repeat$162 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$163 origin:isValueObj: false 
 rpushg repeat$162$162 1
 -- items:goOrigin:encOG: "for:to:repeat$163 "on: 1 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$163$163 4
 -- loadPathII:before:newInvoke: "e " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "e := S.get[inx] " leftE: "e " 
 -- OG:before:super.gen: "S.get[inx] "
 -- handleInv: "S.get[inx] " staticOff: 0 doLoad: true useRtnVal: 
 --  true 
 -- isPtnWithOrigin: "S.get[inx] " 
 --  "S " false "get[inx] " true 
 -- needOriginII: "S.get[inx] " 
 -- E: ObjectInvocation_Unary D: "in S: var String " 
 -- E: ObjectInvocation_KeyWord D: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- needOrigin: true "get[inx] " 
 -- exps.range: 2 exps[i]: "S " exps[i]: "get[inx] " needOrigin: 
 --  true 
 -- isConst: "S " ObjectInvocation_Unary "in S: var String " 
 -- isConst:DI: "in S: var String " 
 -- updateOffset: "S " E.ATd: "in S: var String " 
 -- isConst: "get[inx] " ObjectInvocation_KeyWord 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- updateOffset: "get[inx] " E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- loadPathII:E: "S " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "S " 
 pushThis 
 -- items:goOrigin:encOG: "repeat$162 "on: 3 isValueObj: false 
 --  origin: for:to:repeat$163 origin:isValueObj: false 
 rpushg repeat$162$162 1
 -- items:goOrigin:encOG: "for:to:repeat$163 "on: 2 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$163$163 4
 -- items:goOrigin:encOG: "doplus "on: 1 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$156 1
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "S " 
 -- DI:loadAccessor: "S " 
 -- DI:loadAccessor:Obj: "in S: var String " 
 rpushg newInvoke 2
 -- loadPathII:E: "get[inx] " 1 2 exps.range: 2 staticOff: 0 
 -- E: "get[inx] " E:isPrimitiveIntWithFloatArg: false rec: "S " 
 --  isFloat: false 
 -- NonVirt: "get[inx] " "ObjectInvocation_KeyWord " ActArg: "inx "
 --  isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx] " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "inx "
 -- handleInv: "inx " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "inx " 
 --  "inx " false 
 -- needOriginII: "inx " 
 -- E: ObjectInvocation_Unary D: "inx: var integer " 
 -- needOrigin: true "inx " 
 -- exps.range: 1 exps[i]: "inx " needOrigin: true 
 -- isConst: "inx " ObjectInvocation_Unary "inx: var integer " 
 -- isConst:DI: "inx: var integer " 
 -- updateOffset: "inx " E.ATd: "inx: var integer " 
 -- loadPathII:E: "inx " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "inx " 
 pushThis 
 -- items:goOrigin:encOG: "repeat$162 "on: 1 isValueObj: false 
 --  origin: for:to:repeat$163 origin:isValueObj: false 
 rpushg repeat$162$162 1
 -- loadPathII:before:newInvoke: "inx " true 
 -- checkForProxy:E: "inx " isBasicValue: true origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "inx " 
 -- DI:newInvoke: "inx: var integer " off: 1 valueOff: 0 E: "inx " 
 --  next: none isAdr: false 
 -- DI:newInvoke:loadPrimitive: "inx " isAdr: false valueOff: 0 
 pushg 3 newInvoke
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- isIntForFloatArg: "inx " D: "inx: var integer " true false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "inx " 
 --  B: false 
 --  "inx: var integer " 
 -- end:loadArgs:NonVirt: "get[inx] "
 -- loadPathII:before:newInvoke: "get[inx] " true 
 -- checkForProxy:E: "get[inx] " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: "S " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "get[inx] " 
 -- ptn:newInvoke: "get[inx: var integer] " staticOff: 0 
 -- indexPTN:newInvoke: "get[inx: var integer] " isAdr: false 
 xpushg  inx 1 0 1
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "e := S.get[inx] " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- right:isPTN:not:valueObj: "out ch: var char " 
 -- "get[inx] " 
 -- "get[inx] " 
 -- checkI2F2I: "e := S.get[inx] " left.isFloat: false 
 --  right.isFloat: false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- "get[inx] " 
 -- "get[inx] " 
 -- Assign:end: "e := S.get[inx] " isNotRemote: false qual: 
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  D: none 
 -- DI:newStore: "e " off: 2 valueOff: 0 dstE: "e " isNotRemote: 
 --  false originIsValueObj: false isUnitValueObj: false rightQual:primNo: 3 
 --  rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 storeg integer$5 2
 -- handleAssign: "i := L + inx " 
 -- handleInv: "i " staticOff: 0 doLoad: false useRtnVal: false 
 -- isPtnWithOrigin: "i " 
 --  "i " false 
 -- needOriginII: "i " 
 -- E: ObjectInvocation_Unary D: "i: var integer " 
 -- needOrigin: true "i " 
 -- exps.range: 1 exps[i]: "i " needOrigin: true 
 -- isConst: "i " ObjectInvocation_Unary "i: var integer " 
 -- isConst:DI: "i: var integer " 
 -- updateOffset: "i " E.ATd: "i: var integer " 
 -- loadPathII:E: "i " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "i " 
 pushThis 
 -- items:goOrigin:encOG: "repeat$162 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$163 origin:isValueObj: false 
 rpushg repeat$162$162 1
 -- items:goOrigin:encOG: "for:to:repeat$163 "on: 1 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$163$163 4
 -- loadPathII:before:newInvoke: "i " false 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- handleAssign:after:left: "i := L + inx " leftE: "i " 
 -- OG:before:super.gen: "L + inx "
 -- handleInv: "L + inx " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "L + inx " 
 --  "L " false "+ inx " true 
 -- needOriginII: "L + inx " 
 -- E: ObjectInvocation_Unary D: "L: var integer " 
 -- E: ObjectInvocation_Binary D: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- needOrigin: true "+ inx " 
 -- exps.range: 2 exps[i]: "L " exps[i]: "+ inx " needOrigin: true 
 -- isConst: "L " ObjectInvocation_Unary "L: var integer " 
 -- isConst:DI: "L: var integer " 
 -- updateOffset: "L " E.ATd: "L: var integer " 
 -- isConst: "+ inx " ObjectInvocation_Binary 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- updateOffset: "+ inx " E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- loadPathII:E: "L " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "L " 
 pushThis 
 -- items:goOrigin:encOG: "repeat$162 "on: 3 isValueObj: false 
 --  origin: for:to:repeat$163 origin:isValueObj: false 
 rpushg repeat$162$162 1
 -- items:goOrigin:encOG: "for:to:repeat$163 "on: 2 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$163$163 4
 -- items:goOrigin:encOG: "doplus "on: 1 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$156 1
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "L " 
 -- DI:loadAccessor: "L " 
 -- DI:loadAccesor:loadPrimitive: "L " 
 pushg 4 newInvoke
 -- loadPathII:E: "+ inx " 1 2 exps.range: 2 staticOff: 0 
 -- E: "+ inx " E:isPrimitiveIntWithFloatArg: false rec: "L " 
 --  isFloat: false 
 -- NonVirt: "+ inx " "ObjectInvocation_Binary " ActArg: "inx "
 --  isValue: false formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ inx " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "inx "
 -- handleInv: "inx " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "inx " 
 --  "inx " false 
 -- needOriginII: "inx " 
 -- E: ObjectInvocation_Unary D: "inx: var integer " 
 -- needOrigin: true "inx " 
 -- exps.range: 1 exps[i]: "inx " needOrigin: true 
 -- isConst: "inx " ObjectInvocation_Unary "inx: var integer " 
 -- isConst:DI: "inx: var integer " 
 -- updateOffset: "inx " E.ATd: "inx: var integer " 
 -- loadPathII:E: "inx " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "inx " 
 pushThis 
 -- items:goOrigin:encOG: "repeat$162 "on: 1 isValueObj: false 
 --  origin: for:to:repeat$163 origin:isValueObj: false 
 rpushg repeat$162$162 1
 -- loadPathII:before:newInvoke: "inx " true 
 -- checkForProxy:E: "inx " isBasicValue: true origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "inx " 
 -- DI:newInvoke: "inx: var integer " off: 1 valueOff: 0 E: "inx " 
 --  next: none isAdr: false 
 -- DI:newInvoke:loadPrimitive: "inx " isAdr: false valueOff: 0 
 pushg 3 newInvoke
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- isIntForFloatArg: "inx " D: "in V: var integer " true false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "inx " 
 --  B: false 
 --  "inx: var integer " 
 -- end:loadArgs:NonVirt: "+ inx "
 -- loadPathII:before:newInvoke: "+ inx " true 
 -- checkForProxy:E: "+ inx " isBasicValue: true origin.isValueObj: 
 --  true staticOff: 0 rec: "L " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "+ inx " 
 -- ptn:newInvoke: "+   " staticOff: 0 
 -- gPTN:newInvoke: "+   " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: "L " 
 -- checkInt2IntWithUnitArg:E: "+ inx " false false 
 plus
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- handleAssign:after:right: "i := L + inx " OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- right:isPTN:not:valueObj: "out R: var integer " 
 -- "+ inx " 
 -- "+ inx " 
 -- checkI2F2I: "i := L + inx " left.isFloat: false right.isFloat: 
 --  false false left.isFloat:X: false 
 -- ???:left.isFloat: false 
 -- "+ inx " 
 -- "+ inx " 
 -- Assign:end: "i := L + inx " isNotRemote: false qual: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  D: none 
 -- DI:newStore: "i " off: 3 valueOff: 0 dstE: "i " isNotRemote: 
 --  false originIsValueObj: false isUnitValueObj: false rightQual:primNo: 1 
 --  rightQual.isUnitValueObj: false 
 -- originIsValueObj: false 
 storeg integer$5 3
 -- OG:before:super.gen: "T.put(e):at[i] "
 -- handleInv: "T.put(e):at[i] " staticOff: 0 doLoad: true 
 --  useRtnVal: false 
 -- isPtnWithOrigin: "T.put(e):at[i] " 
 --  "T " false "put(e):at[i] " true 
 -- needOriginII: "T.put(e):at[i] " 
 -- E: ObjectInvocation_Unary D: "
 --  T: obj Indexed(L + S.length,Integer) " 
 -- E: ObjectInvocation_KeyWord D: 
 --  put(V: var integer):at[inx: var integer]: 
 --     %basic 115
 --  
 -- needOrigin: true "put(e):at[i] " 
 -- exps.range: 2 exps[i]: "T " exps[i]: "put(e):at[i] " 
 --  needOrigin: true 
 -- isConst: "T " ObjectInvocation_Unary "
 --  T: obj Indexed(L + S.length,Integer) " 
 -- isConst:DI: "T: obj Indexed(L + S.length,Integer) " 
 -- updateOffset: "T " E.ATd: "
 --  T: obj Indexed(L + S.length,Integer) " 
 -- isConst: "put(e):at[i] " ObjectInvocation_KeyWord 
 --  put(V: var integer):at[inx: var integer]: 
 --     %basic 115
 --  
 -- updateOffset: "put(e):at[i] " E.ATd: 
 --  put(V: var integer):at[inx: var integer]: 
 --     %basic 115
 --  
 -- loadPathII:E: "T " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "T " 
 pushThis 
 -- items:goOrigin:encOG: "repeat$162 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$163 origin:isValueObj: false 
 rpushg repeat$162$162 1
 -- items:goOrigin:encOG: "for:to:repeat$163 "on: 1 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$163$163 4
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "T " 
 -- DI:loadAccessor: "T " 
 -- DI:loadAccessor:Obj: "T: obj Indexed(L + S.length,Integer) " 
 rpushg newInvoke 4
 -- loadPathII:E: "put(e):at[i] " 1 2 exps.range: 2 staticOff: 0 
 -- E: "put(e):at[i] " E:isPrimitiveIntWithFloatArg: false rec: "T " 
 --  isFloat: false 
 -- NonVirt: "put(e):at[i] " "ObjectInvocation_KeyWord " ActArg: "e "
 --  isValue: false formalArg: "V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(e):at[i] "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "e "
 -- handleInv: "e " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "e " 
 --  "e " false 
 -- needOriginII: "e " 
 -- E: ObjectInvocation_Unary D: "e: var integer " 
 -- needOrigin: true "e " 
 -- exps.range: 1 exps[i]: "e " needOrigin: true 
 -- isConst: "e " ObjectInvocation_Unary "e: var integer " 
 -- isConst:DI: "e: var integer " 
 -- updateOffset: "e " E.ATd: "e: var integer " 
 -- loadPathII:E: "e " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "e " 
 pushThis 
 -- items:goOrigin:encOG: "repeat$162 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$163 origin:isValueObj: false 
 rpushg repeat$162$162 1
 -- items:goOrigin:encOG: "for:to:repeat$163 "on: 1 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$163$163 4
 -- loadPathII:before:newInvoke: "e " true 
 -- checkForProxy:E: "e " isBasicValue: true origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "e " 
 -- DI:newInvoke: "e: var integer " off: 1 valueOff: 0 E: "e " 
 --  next: none isAdr: false 
 -- DI:newInvoke:loadPrimitive: "e " isAdr: false valueOff: 0 
 pushg 2 newInvoke
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: false formalArg:isPtn: "V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "e ":isBasicVal: true 
 -- case:B: e ObjectGenerator 1 0 1 false false 
 -- isIntForFloatArg: "e " D: "V: var integer " true false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "e " 
 --  B: false 
 --  "e: var integer " 
 -- end:loadArgs:NonVirt: "put(e):at[i] "
 -- NonVirt: "put(e):at[i] " "ObjectInvocation_KeyWord " ActArg: "i "
 --  isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(e):at[i] "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "i "
 -- handleInv: "i " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "i " 
 --  "i " false 
 -- needOriginII: "i " 
 -- E: ObjectInvocation_Unary D: "i: var integer " 
 -- needOrigin: true "i " 
 -- exps.range: 1 exps[i]: "i " needOrigin: true 
 -- isConst: "i " ObjectInvocation_Unary "i: var integer " 
 -- isConst:DI: "i: var integer " 
 -- updateOffset: "i " E.ATd: "i: var integer " 
 -- loadPathII:E: "i " 1 1 exps.range: 1 staticOff: 0 
 -- loadOriginII: "i " 
 pushThis 
 -- items:goOrigin:encOG: "repeat$162 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$163 origin:isValueObj: false 
 rpushg repeat$162$162 1
 -- items:goOrigin:encOG: "for:to:repeat$163 "on: 1 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$163$163 4
 -- loadPathII:before:newInvoke: "i " true 
 -- checkForProxy:E: "i " isBasicValue: true origin.isValueObj: 
 --  false staticOff: 0 rec: none 
 -- loadPathII:next: 1 1 
 -- OI:newInvoke: "i " 
 -- DI:newInvoke: "i: var integer " off: 2 valueOff: 0 E: "i " 
 --  next: none isAdr: false 
 -- DI:newInvoke:loadPrimitive: "i " isAdr: false valueOff: 0 
 pushg 3 newInvoke
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "i ":isBasicVal: true 
 -- case:B: i ObjectGenerator 1 0 1 false false 
 -- isIntForFloatArg: "i " D: "inx: var integer " true false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "i " 
 --  B: false 
 --  "i: var integer " 
 -- end:loadArgs:NonVirt: "put(e):at[i] "
 -- loadPathII:before:newInvoke: "put(e):at[i] " true 
 -- checkForProxy:E: "put(e):at[i] " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: "T " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "put(e):at[i] " 
 -- ptn:newInvoke: "put(V: var integer):at[inx: var integer] " 
 --  staticOff: 0 
 -- indexPTN:newInvoke: "put(V: var integer):at[inx: var integer] " 
 --  isAdr: false 
 -- IndexedPTN:newInvoke: 
 --  put(V: var integer):at[inx: var integer]: 
 --     %basic 115
 --  E: "put(e):at[i] " rec: "T " 
 xstoreg  inx 1 0 1
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS for:to:repeat$163 163 4 doplus 156
 -- vdtTableCopy: I:1:28 V:2:29
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- NonVirt: 
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]"ObjectInvocation_KeyWord " ActArg: "1 "isValue: true formalArg: "
 --  first: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 --   " isCompositeValueObj: false 
 -- OG:before:super.gen: "1 "
 -- handleInv: "1 " staticOff: 0 doLoad: true useRtnVal: true 
 -- isPtnWithOrigin: "1 " 
 --  "1 " false 
 -- needOriginII: "1 " 
 -- E: ConstLiteral D: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- needOrigin: true "1 " 
 -- exps.range: 1 exps[i]: "1 " needOrigin: true 
 -- isConst: "1 " ConstLiteral 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- isConstLiteral: "1 " 
 pushc 1
 -- const:cst: "1 " 1 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: true formalArg:isPtn: "first: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- isIntForFloatArg: "1 " D: "first: var integer " true false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "1 " false 
 --  B: false 
 --  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- end:loadArgs:NonVirt: "
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 --   "
 -- NonVirt: 
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]"ObjectInvocation_KeyWord " ActArg: "S.length "isValue: false 
 --  formalArg: "last: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 --   " isCompositeValueObj: false 
 -- OG:before:super.gen: "S.length "
 -- handleInv: "S.length " staticOff: 0 doLoad: true useRtnVal: 
 --  true 
 -- isPtnWithOrigin: "S.length " 
 --  "S " false "length " true 
 -- needOriginII: "S.length " 
 -- E: ObjectInvocation_Unary D: "in S: var String " 
 -- E: ObjectInvocation_Unary D: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- needOrigin: true "length " 
 -- exps.range: 2 exps[i]: "S " exps[i]: "length " needOrigin: true 
 -- isConst: "S " ObjectInvocation_Unary "in S: var String " 
 -- isConst:DI: "in S: var String " 
 -- updateOffset: "S " E.ATd: "in S: var String " 
 -- isConst: "length " ObjectInvocation_Unary 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- updateOffset: "length " E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- loadPathII:E: "S " 1 1 exps.range: 2 staticOff: 0 
 -- loadOriginII: "S " 
 pushThis 
 rpushg doplus$156 4
 -- items:goOrigin:encOG: "doplus "on: 1 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$156 1
 -- loadPathII:next: 1 2 
 -- OI:loadAccessor: "S " 
 -- DI:loadAccessor: "S " 
 -- DI:loadAccessor:Obj: "in S: var String " 
 rpushg newInvoke 2
 -- loadPathII:E: "length " 1 2 exps.range: 2 staticOff: 0 
 -- E: "length " E:isPrimitiveIntWithFloatArg: false rec: "S " 
 --  isFloat: false 
 -- loadPathII:before:newInvoke: "length " true 
 -- checkForProxy:E: "length " isBasicValue: false 
 --  origin.isValueObj: false staticOff: 0 rec: "S " 
 -- loadPathII:next: 2 2 
 -- OI:newInvoke: "length " 
 -- ptn:newInvoke: "length " staticOff: 0 
 -- gPTN:newInvoke: "length " ptnKind: 0 staticOff: 0 valueOff: 0 
 --  rec: "S " 
 -- invoke:nonVirtual: "length " isAdr: false 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- handleINV:end: isNotRemote: false valueOff: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- actualArg:isPtn: true formalArg:isPtn: "last: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "S.length ":isBasicVal: true 
 -- case:B: S.length ObjectGenerator 1 0 0 false false 
 -- isIntForFloatArg: "S.length " D: "last: var integer " true false 
 --  srcOG.isFloat: false src.isUnitValueObj: false this: "S.length " false 
 --  B: false 
 --  
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- end:loadArgs:NonVirt: "
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 --   "
 pushThis 
 storeg integer$5 2
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- DI:gen: "inx: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: inx 
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0

 CLASS asString 164 1 Indexed 157
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "out S: var LIB.StringLib.String " DI:isConst: false 
 --  isBasicValue: false primNo: 5 
 -- DI:StringVar "out S: var LIB.StringLib.String "
 pushText ""
 pushThis 
 rstoreg  S 2
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS valProx 165 1 Object 0
 END OSDV:0 objSize:4 isIndexed:0

 CLASS VM 166 0 Object 0
 L1:
 pushThis 
 invoke BETAworld 1 0 1
 stop
 L2:
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS EventProcessor 167 0 Object 0
 stop
 END OSDV:0 objSize:1 isIndexed:0

 CLASS ThreadStub 168 0 Object 0
DO:
 call(D)ThreadStub
 stop
 END OSDV:0 objSize:1 isIndexed:0

Class BETAworld descInx:1 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	pushthis 
7:	saveBETAworld
8:	mvStack
allocE: 
9:	pushthis 
10:	invoke 2 2 1
16:	rpop 
17:	pushthis 
18:	invoke 33 3 1
24:	rpop 
25:	pushthis 
26:	invoke 67 4 1
32:	rpop 
33:	rtnAlloc 1
doE: 
35:	doEventQ 
36:	mvStack
37:	setThisStack
38:	pushthis 
39:	rtn D


Class BETA descInx:2 objSize:3 originOff: 1 visibility: 2
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 3 2 1
14:	rpop 
15:	rtnAlloc 1
doE: 
17:	doEventQ 
18:	mvStack
19:	setThisStack
20:	pushthis 
21:	rtn D


Class ascii descInx:3 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushc 10
9:	pushthis 
10:	storeg 2
12:	pushc 13
14:	pushthis 
15:	storeg 3
17:	pushc 0
19:	pushthis 
20:	storeg 4
22:	rtnAlloc 1
doE: 
24:	doEventQ 
25:	mvStack
26:	pushthis 
27:	pushc 10
29:	storeg 5
31:	setThisStack
32:	pushthis 
33:	rtn D


Class Value descInx:4 objSize:0 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	mvStack
allocE: 
2:	rtnAlloc 1
doE: 
4:	mvStack
5:	setThisStack
6:	pushthis 
7:	rtn D


Class integer descInx:5 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	mvStack
allocE: 
2:	rtnAlloc 1
doE: 
4:	mvStack
5:	setThisStack
6:	pushthis 
7:	rtn D


Class universal descInx:6 objSize:0 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	mvStack
allocE: 
2:	rtnAlloc 1
doE: 
4:	mvStack
5:	setThisStack
6:	pushthis 
7:	rtn D


Class char descInx:7 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	mvStack
allocE: 
2:	rtnAlloc 1
doE: 
4:	mvStack
5:	setThisStack
6:	pushthis 
7:	rtn D


Class ConsoleIF descInx:8 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class put descInx:9 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class String descInx:10 objSize:0 originOff: 0 visibility: 2
storeOrgAndArgsE:
1:	allocEventQ 1
3:	mvStack
allocE: 
4:	rtnAlloc 1
doE: 
6:	doEventQ 
7:	mvStack
8:	setThisStack
9:	pushthis 
10:	rtn D


Class = descInx:11 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	jmpFalse 13
4:	pushthis 
5:	vassign 4 2 0
10:	jmp 20
13:	invokeVal 31 3 0
19:	rpop 
20:	tstOriginNone 
21:	rstore 1
23:	allocEventQ 0
25:	mvStack
allocE: 
26:	rtnAlloc 1
doE: 
28:	doEventQ 
29:	mvStack
30:	pushthis 
31:	innerP 2
33:	rpopThisObj
34:	setThisStack
35:	pushthis 
36:	rtn D


Class = descInx:13 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	rshiftup 1
3:	tstOriginNone 
4:	rstore 1
6:	allocEventQ 0
8:	pushthis 
9:	rpushg 1
11:	rshiftdown 1
13:	pushthis 
14:	rstoreg 2
16:	tstOriginNone 
17:	rstore 1
19:	allocEventQ 0
21:	mvStack
allocE: 
doE: 
22:	doEventQ 
23:	mvStack
24:	pushthis 
25:	invoke 14 0 0
31:	rpop 
32:	setThisStack
33:	pushthis 
34:	rtn D


Class loop descInx:14 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	rpushg 1
17:	invoke 15 0 0
23:	pushg 2
25:	storeg 4
27:	pushthis 
28:	pushg 4
30:	pushthis 
31:	rpushg 1
33:	rpushg 2
35:	invoke 15 0 0
41:	pushg 2
43:	ne 
44:	jmpFalse 55
47:	pushthis 
48:	invoke 18 0 0
54:	rpop 
55:	pushthis 
56:	rpushg 1
58:	invoke 23 0 0
64:	pushg 1
66:	storeg 3
68:	pushthis 
69:	invoke 30 0 0
75:	rpop 
76:	setThisStack
77:	pushthis 
78:	rtn D


Class length descInx:15 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	pushc 0
17:	xpushg 1 0 1
21:	storeg 2
23:	setThisStack
24:	pushthis 
25:	rtn D


Class $18 descInx:18 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	break 1 2 14 0
18:	setThisStack
19:	pushthis 
20:	rtn D


Class if:then descInx:20 objSize:1 originOff: 0 visibility: 1
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class BETAworld descInx:21 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	innerP 2
14:	rpopThisObj
15:	setThisStack
16:	pushthis 
17:	rtn D


Class thenPart#22 descInx:22 objSize:3 originOff: 0 visibility: 1
storeOrgAndArgsE:
1:	invoke 21 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class True descInx:23 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
3:	mvStack
allocE: 
4:	rtnAlloc 1
doE: 
6:	doEventQ 
7:	mvStack
8:	pushthis 
9:	pushc 1
11:	storeg 1
13:	setThisStack
14:	pushthis 
15:	rtn D


Class repeat$24 descInx:24 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	pushthis 
17:	rpushg 1
19:	rpushg 4
21:	rpushg 1
23:	rpushg 1
25:	pushthis 
26:	rpushg 1
28:	pushg 3
30:	xpushg 1 0 1
34:	storeg 2
36:	pushthis 
37:	rpushg 1
39:	rpushg 4
41:	pushthis 
42:	rpushg 1
44:	rpushg 4
46:	rpushg 1
48:	rpushg 2
50:	pushthis 
51:	rpushg 1
53:	pushg 3
55:	xpushg 1 0 1
59:	storeg 3
61:	pushthis 
62:	rpushg 1
64:	rpushg 4
66:	pushg 2
68:	pushthis 
69:	rpushg 1
71:	rpushg 4
73:	pushg 3
75:	ne 
76:	jmpFalse 87
79:	pushthis 
80:	invoke 26 0 0
86:	rpop 
87:	setThisStack
88:	pushthis 
89:	rtn D


Class $26 descInx:26 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 4
18:	rpushg 1
20:	invoke 27 0 0
26:	pushg 1
28:	storeg 3
30:	break 3 2 14 0
37:	setThisStack
38:	pushthis 
39:	rtn D


Class False descInx:27 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
3:	mvStack
allocE: 
4:	rtnAlloc 1
doE: 
6:	doEventQ 
7:	mvStack
8:	pushthis 
9:	pushc 0
11:	storeg 1
13:	setThisStack
14:	pushthis 
15:	rtn D


Class for:to:repeat descInx:28 objSize:3 originOff: 0 visibility: 1
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 2
4:	pushthis 
5:	storeg 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	pushthis 
16:	pushg 1
18:	storeg 3
20:	pushthis 
21:	invoke 43 0 0
27:	rpop 
28:	setThisStack
29:	pushthis 
30:	rtn D


Class repeat#29 descInx:29 objSize:3 originOff: 0 visibility: 1
storeOrgAndArgsE:
1:	invoke 21 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class for:to:repeat$30 descInx:30 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	rpushg 1
13:	invoke 15 0 0
19:	pushg 2
21:	pushthis 
22:	storeg 2
24:	pushthis 
25:	storeg 1
27:	allocEventQ 0
allocE: 
29:	rtnAlloc 1
31:	toSuper 28
doE: 
34:	mvStack
35:	rtnInner


Class this descInx:31 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	setThisStack
15:	pushthis 
16:	rtn D


Class X_asString descInx:32 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushText 1
9:	pushthis 
10:	rstoreg 2
12:	rtnAlloc 1
doE: 
14:	doEventQ 
15:	mvStack
16:	pushthis 
17:	innerP 2
19:	rpopThisObj
20:	setThisStack
21:	pushthis 
22:	rtn D


Class LIB descInx:33 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 34 3 1
14:	rpop 
15:	pushthis 
16:	invoke 38 4 1
22:	rpop 
23:	pushthis 
24:	invoke 41 5 1
30:	rpop 
31:	rtnAlloc 1
doE: 
33:	doEventQ 
34:	mvStack
35:	setThisStack
36:	pushthis 
37:	rtn D


Class BasicIO descInx:34 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 35 2 1
14:	rpop 
15:	pushthis 
16:	invoke 36 3 1
22:	rpop 
23:	rtnAlloc 1
doE: 
25:	doEventQ 
26:	mvStack
27:	setThisStack
28:	pushthis 
29:	rtn D


Class keyboard descInx:35 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class screen descInx:36 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	rpushg 1
10:	invoke 37 2 1
16:	rpop 
17:	rtnAlloc 1
doE: 
19:	doEventQ 
20:	mvStack
21:	setThisStack
22:	pushthis 
23:	rtn D


Class Lock descInx:37 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class Collections descInx:38 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	invoke 39 2 1
13:	rpop 
14:	pushthis 
15:	invoke 40 3 1
21:	rpop 
22:	rtnAlloc 1
doE: 
24:	doEventQ 
25:	mvStack
26:	setThisStack
27:	pushthis 
28:	rtn D


Class OrderedList descInx:39 objSize:0 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 1
3:	mvStack
allocE: 
4:	rtnAlloc 1
doE: 
6:	doEventQ 
7:	mvStack
8:	setThisStack
9:	pushthis 
10:	rtn D


Class SetLib descInx:40 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class StringLib descInx:41 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	saveStringOrigin
7:	mvStack
allocE: 
8:	rtnAlloc 1
doE: 
10:	doEventQ 
11:	mvStack
12:	setThisStack
13:	pushthis 
14:	rtn D


Class Boolean descInx:42 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	mvStack
allocE: 
2:	rtnAlloc 1
doE: 
4:	mvStack
5:	setThisStack
6:	pushthis 
7:	rtn D


Class _doIt descInx:43 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushg 3
16:	pushthis 
17:	rpushg 1
19:	pushg 2
21:	le
22:	jmpFalse 36
25:	pushthis 
26:	invoke 45 0 0
32:	rpop 
33:	jmp 44
36:	pushthis 
37:	invoke 48 0 0
43:	rpop 
44:	setThisStack
45:	pushthis 
46:	rtn D


Class <= descInx:44 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	jmpFalse 13
4:	pushthis 
5:	vassign 4 2 0
10:	jmp 20
13:	invokeVal 31 3 0
19:	rpop 
20:	tstOriginNone 
21:	rstore 1
23:	allocEventQ 0
25:	mvStack
allocE: 
26:	rtnAlloc 1
doE: 
28:	doEventQ 
29:	mvStack
30:	setThisStack
31:	pushthis 
32:	rtn D


Class $45 descInx:45 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	invokev 2 0 0
20:	rpop 
21:	pushthis 
22:	rpushg 1
24:	rpushg 1
26:	pushthis 
27:	rpushg 1
29:	rpushg 1
31:	pushg 3
33:	pushc 1
35:	+
36:	storeg 3
38:	break 1 1 43 0
45:	setThisStack
46:	pushthis 
47:	rtn D


Class $48 descInx:48 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushthis 
17:	rpushg 1
19:	rpushg 1
21:	pushg 3
23:	storeg 3
25:	setThisStack
26:	pushthis 
27:	rtn D


Class <= descInx:49 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	rshiftup 1
3:	tstOriginNone 
4:	rstore 1
6:	allocEventQ 0
8:	pushthis 
9:	rpushg 1
11:	rshiftdown 1
13:	pushthis 
14:	rstoreg 2
16:	tstOriginNone 
17:	rstore 1
19:	allocEventQ 0
21:	mvStack
allocE: 
22:	pushthis 
23:	invoke 50 4 1
29:	rpop 
doE: 
30:	doEventQ 
31:	mvStack
32:	setThisStack
33:	pushthis 
34:	rtn D


Class loop descInx:50 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	rpushg 1
17:	invoke 15 0 0
23:	pushg 2
25:	storeg 3
27:	pushthis 
28:	pushthis 
29:	rpushg 1
31:	rpushg 2
33:	invoke 15 0 0
39:	pushg 2
41:	storeg 4
43:	pushthis 
44:	pushg 3
46:	pushthis 
47:	pushg 4
49:	lt
50:	jmpFalse 64
53:	pushthis 
54:	invoke 52 0 0
60:	rpop 
61:	jmp 72
64:	pushthis 
65:	invoke 53 0 0
71:	rpop 
72:	pushthis 
73:	invoke 54 0 0
79:	rpop 
80:	setThisStack
81:	pushthis 
82:	rtn D


Class $52 descInx:52 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushthis 
15:	rpushg 1
17:	pushg 3
19:	storeg 2
21:	setThisStack
22:	pushthis 
23:	rtn D


Class $53 descInx:53 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushthis 
15:	rpushg 1
17:	pushg 4
19:	storeg 2
21:	setThisStack
22:	pushthis 
23:	rtn D


Class matchEq descInx:54 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	invoke 55 0 0
18:	rpop 
19:	pushthis 
20:	invoke 58 0 0
26:	rpop 
27:	pushthis 
28:	invoke 61 0 0
34:	rpop 
35:	setThisStack
36:	pushthis 
37:	rtn D


Class isEmpty descInx:55 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushg 3
18:	pushc 0
20:	eq 
21:	jmpFalse 32
24:	pushthis 
25:	invoke 56 0 0
31:	rpop 
32:	pushthis 
33:	rpushg 1
35:	rpushg 1
37:	pushg 4
39:	pushc 0
41:	eq 
42:	jmpFalse 53
45:	pushthis 
46:	invoke 57 0 0
52:	rpop 
53:	setThisStack
54:	pushthis 
55:	rtn D


Class $56 descInx:56 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 1
20:	pushthis 
21:	rpushg 1
23:	rpushg 1
25:	rpushg 1
27:	pushg 3
29:	pushthis 
30:	rpushg 1
32:	rpushg 1
34:	rpushg 1
36:	pushg 4
38:	le
39:	storeg 3
41:	break 2 2 54 0
48:	setThisStack
49:	pushthis 
50:	rtn D


Class $57 descInx:57 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 1
20:	invoke 27 0 0
26:	pushg 1
28:	storeg 3
30:	break 2 2 54 0
37:	setThisStack
38:	pushthis 
39:	rtn D


Class loop descInx:58 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushthis 
15:	rpushg 1
17:	pushg 2
19:	pushc 1
21:	+
22:	storeg 2
24:	pushthis 
25:	rpushg 1
27:	pushthis 
28:	rpushg 1
30:	rpushg 1
32:	rpushg 1
34:	rpushg 1
36:	pushthis 
37:	rpushg 1
39:	pushg 2
41:	xpushg 1 0 1
45:	storeg 3
47:	pushthis 
48:	rpushg 1
50:	pushthis 
51:	rpushg 1
53:	rpushg 1
55:	rpushg 1
57:	rpushg 2
59:	pushthis 
60:	rpushg 1
62:	pushg 2
64:	xpushg 1 0 1
68:	storeg 4
70:	pushthis 
71:	rpushg 1
73:	pushg 3
75:	pushthis 
76:	rpushg 1
78:	pushg 4
80:	eq 
81:	jmpFalse 92
84:	pushthis 
85:	invoke 59 0 0
91:	rpop 
92:	setThisStack
93:	pushthis 
94:	rtn D


Class $59 descInx:59 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushg 2
18:	pushthis 
19:	rpushg 1
21:	rpushg 1
23:	rpushg 1
25:	pushg 2
27:	lt
28:	jmpFalse 39
31:	pushthis 
32:	invoke 60 0 0
38:	rpop 
39:	setThisStack
40:	pushthis 
41:	rtn D


Class $60 descInx:60 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	break 2 1 58 0
18:	setThisStack
19:	pushthis 
20:	rtn D


Class doit descInx:61 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushg 3
16:	pushthis 
17:	rpushg 1
19:	pushg 4
21:	eq 
22:	jmpFalse 36
25:	pushthis 
26:	invoke 62 0 0
32:	rpop 
33:	jmp 44
36:	pushthis 
37:	invoke 63 0 0
43:	rpop 
44:	setThisStack
45:	pushthis 
46:	rtn D


Class $62 descInx:62 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 1
20:	pushthis 
21:	rpushg 1
23:	rpushg 1
25:	rpushg 1
27:	pushg 3
29:	pushthis 
30:	rpushg 1
32:	rpushg 1
34:	rpushg 1
36:	pushg 4
38:	le
39:	storeg 3
41:	break 2 2 54 0
48:	setThisStack
49:	pushthis 
50:	rtn D


Class $63 descInx:63 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 1
20:	pushthis 
21:	rpushg 1
23:	rpushg 1
25:	pushg 3
27:	pushthis 
28:	rpushg 1
30:	rpushg 1
32:	pushg 4
34:	lt
35:	storeg 3
37:	break 2 2 54 0
44:	setThisStack
45:	pushthis 
46:	rtn D


Class puttext descInx:65 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	innerP 2
17:	rpopThisObj
18:	setThisStack
19:	pushthis 
20:	rtn D


Class putint descInx:66 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	innerP 2
17:	rpopThisObj
18:	setThisStack
19:	pushthis 
20:	rtn D


Class OOPM descInx:67 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 68 3 1
14:	rpop 
15:	pushthis 
16:	invoke 69 4 1
22:	rpop 
23:	rtnAlloc 1
doE: 
25:	doEventQ 
26:	mvStack
27:	setThisStack
28:	pushthis 
29:	rtn D


Class console descInx:68 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class GrammarLib descInx:69 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 70 2 1
14:	rpop 
15:	rtnAlloc 1
doE: 
17:	doEventQ 
18:	mvStack
19:	setThisStack
20:	pushthis 
21:	rtn D


Class demo descInx:70 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 145 2 1
14:	rpop 
15:	rtnAlloc 1
doE: 
17:	doEventQ 
18:	mvStack
19:	setThisStack
20:	pushthis 
21:	rtn D


Class Grammar descInx:71 objSize:6 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	invoke 85 2 1
13:	rpop 
14:	invoke 88 3 1
20:	rpop 
21:	invoke 95 4 1
27:	rpop 
28:	rtnAlloc 1
doE: 
30:	doEventQ 
31:	mvStack
32:	pushthis 
33:	innerP 3
35:	rpopThisObj
36:	setThisStack
37:	pushthis 
38:	rtn D


Class Symbol descInx:72 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	innerP 4
17:	rpopThisObj
18:	setThisStack
19:	pushthis 
20:	rtn D


Class NonTerminal descInx:73 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	rshiftup 1
3:	tstOriginNone 
4:	rstore 1
6:	pushthis 
7:	rpushg 1
9:	rshiftdown 1
11:	pushthis 
12:	rstoreg 2
14:	tstOriginNone 
15:	rstore 1
17:	allocEventQ 0
allocE: 
19:	rtnAlloc 1
21:	toSuper 72
doE: 
24:	mvStack
25:	pushthis 
26:	rpushg 1
28:	rpushg 2
30:	pushthis 
31:	invoke 75 0 0
37:	rpop 
38:	rtnInner


Class insert descInx:74 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	innerP 2
17:	rpopThisObj
18:	setThisStack
19:	pushthis 
20:	rtn D


Class insert descInx:75 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	rshiftup 1
3:	tstOriginNone 
4:	rstore 1
6:	pushthis 
7:	rpushg 1
9:	rshiftdown 1
11:	pushthis 
12:	rstoreg 2
14:	tstOriginNone 
15:	rstore 1
17:	allocEventQ 0
allocE: 
19:	rtnAlloc 1
21:	toSuper 74
doE: 
24:	mvStack
25:	pushthis 
26:	rpushg 1
28:	pushthis 
29:	rpushg 2
31:	invokev 4 1 0
35:	pushg 3
37:	nott
38:	jmpFalse 49
41:	pushthis 
42:	invoke 77 0 0
48:	rpop 
49:	rtnInner


Class $77 descInx:77 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushthis 
17:	rpushg 1
19:	rpushg 1
21:	pushthis 
22:	rpushg 1
24:	rpushg 2
26:	pushthis 
27:	rpushg 1
29:	rpushg 1
31:	rpushg 1
33:	invoke 78 0 1
39:	rswap 0
41:	rstoreg 1
43:	setThisStack
44:	pushthis 
45:	rtn D


Class link descInx:78 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 3
4:	pushthis 
5:	rstoreg 2
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 1
12:	mvStack
allocE: 
13:	rtnAlloc 1
doE: 
15:	doEventQ 
16:	mvStack
17:	setThisStack
18:	pushthis 
19:	rtn D


Class Collection descInx:80 objSize:0 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
3:	mvStack
allocE: 
4:	rtnAlloc 1
doE: 
6:	doEventQ 
7:	mvStack
8:	pushthis 
9:	innerP 9
11:	rpopThisObj
12:	setThisStack
13:	pushthis 
14:	rtn D


Class Set descInx:83 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
allocE: 
3:	rtnAlloc 1
5:	toSuper 80
doE: 
8:	mvStack
9:	pushthis 
10:	innerP 10
12:	rpopThisObj
13:	rtnInner


Class nonTerminals descInx:85 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
allocE: 
3:	rtnAlloc 1
5:	toSuper 80
doE: 
8:	mvStack
9:	rtnInner


Class Terminal descInx:86 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	rshiftup 1
3:	tstOriginNone 
4:	rstore 1
6:	pushthis 
7:	rpushg 1
9:	rshiftdown 1
11:	pushthis 
12:	rstoreg 2
14:	tstOriginNone 
15:	rstore 1
17:	allocEventQ 0
allocE: 
19:	rtnAlloc 1
21:	toSuper 72
doE: 
24:	mvStack
25:	rtnInner


Class terminals descInx:88 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
allocE: 
3:	rtnAlloc 1
5:	toSuper 80
doE: 
8:	mvStack
9:	rtnInner


Class Rule descInx:89 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	invoke 93 3 1
13:	rpop 
14:	rtnAlloc 1
doE: 
16:	doEventQ 
17:	mvStack
18:	setThisStack
19:	pushthis 
20:	rtn D


Class Alternative descInx:90 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	setThisStack
15:	pushthis 
16:	rtn D


Class OrderedList descInx:92 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
allocE: 
3:	rtnAlloc 1
5:	toSuper 80
doE: 
8:	mvStack
9:	rtnInner


Class alternatives descInx:93 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
allocE: 
3:	rtnAlloc 1
5:	toSuper 80
doE: 
8:	mvStack
9:	rtnInner


Class rules descInx:95 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
allocE: 
3:	rtnAlloc 1
5:	toSuper 80
doE: 
8:	mvStack
9:	rtnInner


Class has descInx:96 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	innerP 2
17:	rpopThisObj
18:	setThisStack
19:	pushthis 
20:	rtn D


Class remove descInx:97 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	innerP 2
17:	rpopThisObj
18:	setThisStack
19:	pushthis 
20:	rtn D


Class isEmpty descInx:98 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	innerP 2
14:	rpopThisObj
15:	setThisStack
16:	pushthis 
17:	rtn D


Class size descInx:99 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	innerP 2
14:	rpopThisObj
15:	setThisStack
16:	pushthis 
17:	rtn D


Class clear descInx:100 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	innerP 2
14:	rpopThisObj
15:	setThisStack
16:	pushthis 
17:	rtn D


Class has descInx:101 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	rshiftup 1
3:	tstOriginNone 
4:	rstore 1
6:	pushthis 
7:	rpushg 1
9:	rshiftdown 1
11:	pushthis 
12:	rstoreg 2
14:	tstOriginNone 
15:	rstore 1
17:	allocEventQ 0
allocE: 
19:	rtnAlloc 1
21:	toSuper 96
doE: 
24:	mvStack
25:	pushthis 
26:	invoke 27 0 0
32:	pushg 1
34:	storeg 3
36:	pushthis 
37:	invoke 103 0 0
43:	rpop 
44:	rtnInner


Class scan descInx:102 objSize:3 originOff: 1 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	rpushg 1
17:	rswap 0
19:	rstoreg 3
21:	pushthis 
22:	invoke 107 0 0
28:	rpop 
29:	setThisStack
30:	pushthis 
31:	rtn D


Class scan$103 descInx:103 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushthis 
5:	rpushg 4
7:	rpushg 1
9:	tstOriginNone 
10:	rstore 1
12:	allocEventQ 1
allocE: 
14:	rtnAlloc 1
16:	toSuper 102
doE: 
19:	mvStack
20:	pushthis 
21:	rpushg 2
23:	pushthis 
24:	rpushg 4
26:	rpushg 2
28:	req 
29:	jmpFalse 43
32:	pushthis 
33:	invoke 105 0 0
39:	rpop 
40:	jmp 51
43:	pushthis 
44:	invoke 106 0 0
50:	rpop 
51:	rtnInner


Class $105 descInx:105 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	invoke 23 0 0
22:	pushg 1
24:	storeg 3
26:	break 2 2 96 1
33:	setThisStack
34:	pushthis 
35:	rtn D


Class $106 descInx:106 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	pushthis 
17:	rpushg 1
19:	rpushg 4
21:	pushg 3
23:	storeg 3
25:	setThisStack
26:	pushthis 
27:	rtn D


Class Loop descInx:107 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 3
16:	pushNone 
17:	57
18:	jmpFalse 32
21:	pushthis 
22:	invoke 110 0 0
28:	rpop 
29:	jmp 40
32:	pushthis 
33:	invoke 111 0 0
39:	rpop 
40:	setThisStack
41:	pushthis 
42:	rtn D


Class $110 descInx:110 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushthis 
17:	rpushg 1
19:	rpushg 1
21:	rpushg 3
23:	rpushg 2
25:	rswap 0
27:	rstoreg 2
29:	pushthis 
30:	rpushg 1
32:	rpushg 1
34:	innerP 2
36:	rpopThisObj
37:	pushthis 
38:	rpushg 1
40:	rpushg 1
42:	pushthis 
43:	rpushg 1
45:	rpushg 1
47:	rpushg 3
49:	rpushg 3
51:	rswap 0
53:	rstoreg 3
55:	break 1 1 107 0
62:	setThisStack
63:	pushthis 
64:	rtn D


Class $111 descInx:111 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushthis 
17:	rpushg 1
19:	rpushg 1
21:	rpushg 3
23:	rswap 0
25:	rstoreg 3
27:	setThisStack
28:	pushthis 
29:	rtn D


Class isEmpty descInx:112 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 98
doE: 
17:	mvStack
18:	pushthis 
19:	pushthis 
20:	rpushg 1
22:	rpushg 1
24:	pushNone 
25:	req 
26:	storeg 2
28:	rtnInner


Class remove descInx:113 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	rshiftup 1
3:	tstOriginNone 
4:	rstore 1
6:	pushthis 
7:	rpushg 1
9:	rshiftdown 1
11:	pushthis 
12:	rstoreg 2
14:	tstOriginNone 
15:	rstore 1
17:	allocEventQ 0
allocE: 
19:	rtnAlloc 1
21:	toSuper 97
doE: 
24:	mvStack
25:	pushText 5
27:	invoke 114 0 0
33:	rpop 
34:	rtnInner


Class print descInx:114 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	invoke 117 0 0
18:	rpop 
19:	setThisStack
20:	pushthis 
21:	rtn D


Class repeat$115 descInx:115 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	rpushg 1
18:	pushthis 
19:	rpushg 1
21:	pushg 3
23:	xpushg 1 0 1
27:	%prim put 2
29:	setThisStack
30:	pushthis 
31:	rtn D


Class put descInx:116 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class for:to:repeat$117 descInx:117 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	invoke 15 0 0
17:	pushg 2
19:	pushthis 
20:	storeg 2
22:	pushthis 
23:	storeg 1
25:	allocEventQ 0
allocE: 
27:	rtnAlloc 1
29:	toSuper 28
doE: 
32:	mvStack
33:	rtnInner


Class size descInx:118 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 99
doE: 
17:	mvStack
18:	pushthis 
19:	invoke 119 0 0
25:	rpop 
26:	rtnInner


Class scan$119 descInx:119 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushthis 
5:	rpushg 4
7:	rpushg 1
9:	tstOriginNone 
10:	rstore 1
12:	allocEventQ 1
allocE: 
14:	rtnAlloc 1
16:	toSuper 102
doE: 
19:	mvStack
20:	pushthis 
21:	rpushg 4
23:	pushthis 
24:	rpushg 4
26:	pushg 2
28:	pushc 1
30:	+
31:	storeg 2
33:	rtnInner


Class clear descInx:120 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 100
doE: 
17:	mvStack
18:	pushthis 
19:	rpushg 1
21:	pushNone 
22:	rswap 0
24:	rstoreg 1
26:	rtnInner


Class print descInx:121 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	innerP 2
14:	rpopThisObj
15:	setThisStack
16:	pushthis 
17:	rtn D


Class isTerminal descInx:122 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	innerP 2
14:	rpopThisObj
15:	setThisStack
16:	pushthis 
17:	rtn D


Class print descInx:123 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 121
doE: 
17:	mvStack
18:	pushc 60
20:	%prim put 2
22:	pushthis 
23:	rpushg 1
25:	rpushg 2
27:	invoke 114 0 0
33:	rpop 
34:	pushc 62
36:	%prim put 2
38:	rtnInner


Class isTerminal descInx:124 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 122
doE: 
17:	mvStack
18:	pushthis 
19:	invoke 23 0 0
25:	pushg 1
27:	storeg 2
29:	rtnInner


Class print descInx:125 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 121
doE: 
17:	mvStack
18:	pushc 34
20:	%prim put 2
22:	pushthis 
23:	rpushg 1
25:	rpushg 2
27:	invoke 114 0 0
33:	rpop 
34:	pushc 34
36:	%prim put 2
38:	rtnInner


Class has descInx:126 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	rshiftup 1
3:	tstOriginNone 
4:	rstore 1
6:	pushthis 
7:	rpushg 1
9:	rshiftdown 1
11:	pushthis 
12:	rstoreg 2
14:	tstOriginNone 
15:	rstore 1
17:	allocEventQ 0
allocE: 
19:	rtnAlloc 1
21:	toSuper 96
doE: 
24:	mvStack
25:	pushthis 
26:	invoke 27 0 0
32:	pushg 1
34:	storeg 3
36:	pushthis 
37:	invoke 129 0 0
43:	rpop 
44:	rtnInner


Class scan descInx:127 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	rpushg 1
17:	rswap 0
19:	rstoreg 3
21:	pushthis 
22:	invoke 131 0 0
28:	rpop 
29:	setThisStack
30:	pushthis 
31:	rtn D


Class link:next descInx:128 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 3
4:	pushthis 
5:	rstoreg 2
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 1
12:	mvStack
allocE: 
13:	rtnAlloc 1
doE: 
15:	doEventQ 
16:	mvStack
17:	setThisStack
18:	pushthis 
19:	rtn D


Class scan$129 descInx:129 objSize:4 originOff: 4 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushthis 
5:	rpushg 4
7:	rpushg 1
9:	tstOriginNone 
10:	rstore 1
12:	allocEventQ 0
allocE: 
14:	rtnAlloc 1
16:	toSuper 127
doE: 
19:	mvStack
20:	pushthis 
21:	rpushg 2
23:	pushthis 
24:	rpushg 4
26:	rpushg 2
28:	req 
29:	jmpFalse 40
32:	pushthis 
33:	invoke 130 0 0
39:	rpop 
40:	rtnInner


Class $130 descInx:130 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	invoke 23 0 0
22:	pushg 1
24:	storeg 3
26:	break 2 2 96 1
33:	setThisStack
34:	pushthis 
35:	rtn D


Class loop descInx:131 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 3
16:	pushNone 
17:	57
18:	jmpFalse 29
21:	pushthis 
22:	invoke 132 0 0
28:	rpop 
29:	setThisStack
30:	pushthis 
31:	rtn D


Class $132 descInx:132 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushthis 
17:	rpushg 1
19:	rpushg 1
21:	rpushg 3
23:	rpushg 2
25:	rswap 0
27:	rstoreg 2
29:	pushthis 
30:	rpushg 1
32:	rpushg 1
34:	innerP 2
36:	rpopThisObj
37:	pushthis 
38:	rpushg 1
40:	rpushg 1
42:	pushthis 
43:	rpushg 1
45:	rpushg 1
47:	rpushg 3
49:	rpushg 3
51:	rswap 0
53:	rstoreg 3
55:	break 1 1 131 0
62:	setThisStack
63:	pushthis 
64:	rtn D


Class isEmpty descInx:133 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 98
doE: 
17:	mvStack
18:	pushthis 
19:	pushthis 
20:	rpushg 1
22:	rpushg 1
24:	pushNone 
25:	req 
26:	storeg 2
28:	rtnInner


Class size descInx:134 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 99
doE: 
17:	mvStack
18:	pushthis 
19:	invoke 135 0 0
25:	rpop 
26:	rtnInner


Class scan$135 descInx:135 objSize:4 originOff: 4 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushthis 
5:	rpushg 4
7:	rpushg 1
9:	tstOriginNone 
10:	rstore 1
12:	allocEventQ 0
allocE: 
14:	rtnAlloc 1
16:	toSuper 127
doE: 
19:	mvStack
20:	pushthis 
21:	rpushg 4
23:	pushthis 
24:	rpushg 4
26:	pushg 2
28:	pushc 1
30:	+
31:	storeg 2
33:	rtnInner


Class clear descInx:136 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 100
doE: 
17:	mvStack
18:	pushthis 
19:	rpushg 1
21:	pushNone 
22:	rswap 0
24:	rstoreg 1
26:	pushthis 
27:	rpushg 1
29:	pushNone 
30:	rswap 0
32:	rstoreg 2
34:	rtnInner


Class insert descInx:137 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	rshiftup 1
3:	tstOriginNone 
4:	rstore 1
6:	pushthis 
7:	rpushg 1
9:	rshiftdown 1
11:	pushthis 
12:	rstoreg 2
14:	tstOriginNone 
15:	rstore 1
17:	allocEventQ 0
allocE: 
19:	rtnAlloc 1
21:	toSuper 74
doE: 
24:	mvStack
25:	pushthis 
26:	rpushg 1
28:	rpushg 1
30:	pushNone 
31:	req 
32:	jmpFalse 46
35:	pushthis 
36:	invoke 138 0 0
42:	rpop 
43:	jmp 54
46:	pushthis 
47:	invoke 139 0 0
53:	rpop 
54:	rtnInner


Class $138 descInx:138 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushthis 
17:	rpushg 1
19:	rpushg 1
21:	pushthis 
22:	rpushg 1
24:	rpushg 2
26:	pushNone 
27:	invoke 128 0 1
33:	rswap 0
35:	rstoreg 1
37:	pushthis 
38:	rpushg 1
40:	rpushg 1
42:	pushthis 
43:	rpushg 1
45:	rpushg 1
47:	rpushg 1
49:	rswap 0
51:	rstoreg 2
53:	setThisStack
54:	pushthis 
55:	rtn D


Class $139 descInx:139 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	rpushg 1
17:	pushthis 
18:	rpushg 1
20:	rpushg 2
22:	pushNone 
23:	invoke 128 0 1
29:	rswap 0
31:	rstoreg 2
33:	pushthis 
34:	rpushg 1
36:	rpushg 1
38:	rpushg 2
40:	pushthis 
41:	rpushg 2
43:	rswap 0
45:	rstoreg 3
47:	pushthis 
48:	rpushg 1
50:	rpushg 1
52:	pushthis 
53:	rpushg 2
55:	rswap 0
57:	rstoreg 2
59:	setThisStack
60:	pushthis 
61:	rtn D


Class SymbolList descInx:141 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
allocE: 
3:	rtnAlloc 1
5:	toSuper 80
doE: 
8:	mvStack
9:	rtnInner


Class Text descInx:142 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class parse descInx:143 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	setThisStack
15:	pushthis 
16:	rtn D


Class AbstractSyntaxTree descInx:144 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class gTst descInx:145 objSize:10 originOff: 7 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 7
4:	pushthis 
5:	rpushg 7
7:	rpushg 1
9:	tstOriginNone 
10:	rstore 1
12:	allocEventQ 0
allocE: 
14:	invoke 85 2 1
20:	rpop 
21:	invoke 88 3 1
27:	rpop 
28:	invoke 95 4 1
34:	rpop 
35:	pushthis 
36:	pushText 5
38:	invoke 73 8 1
44:	rpop 
45:	pushthis 
46:	pushText 9
48:	invoke 73 9 1
54:	rpop 
55:	pushthis 
56:	pushText 14
58:	invoke 86 10 0
64:	rpop 
65:	rtnAlloc 1
67:	toSuper 71
doE: 
70:	mvStack
71:	pushthis 
72:	invoke 146 0 0
78:	rpop 
79:	rtnInner


Class KUK descInx:146 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	invoke 141 0 1
18:	rswap 0
20:	rstoreg 2
22:	pushthis 
23:	invoke 141 0 1
29:	pushthis 
30:	rpushg 1
32:	rpushg 8
34:	pushthis 
35:	rpushg 1
37:	rpushg 10
39:	pushthis 
40:	rpushg 1
42:	rpushg 9
44:	pushc 3
46:	mkRindexed 153
49:	invoke 147 0 0
55:	rpushg 3
57:	rswap 0
59:	rstoreg 2
61:	setThisStack
62:	pushthis 
63:	rtn D


Class insertList descInx:147 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushc 37
16:	%prim put 2
18:	pushthis 
19:	invoke 151 0 0
25:	rpop 
26:	pushthis 
27:	pushthis 
28:	rpushg 1
30:	rswap 0
32:	rstoreg 3
34:	setThisStack
35:	pushthis 
36:	rtn D


Class length descInx:148 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	pushc 0
17:	xpushg 1 0 1
21:	storeg 2
23:	setThisStack
24:	pushthis 
25:	rtn D


Class repeat$150 descInx:150 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	rpushg 1
18:	pushthis 
19:	rpushg 1
21:	rpushg 4
23:	rpushg 2
25:	pushthis 
26:	rpushg 1
28:	pushg 3
30:	xrpushg 1
32:	invokev 3 1 0
36:	rpop 
37:	setThisStack
38:	pushthis 
39:	rtn D


Class for:to:repeat$151 descInx:151 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 2
11:	invoke 148 0 0
17:	pushg 2
19:	pushthis 
20:	storeg 2
22:	pushthis 
23:	storeg 1
25:	allocEventQ 0
allocE: 
27:	rtnAlloc 1
29:	toSuper 28
doE: 
32:	mvStack
33:	rtnInner


Class OrderedList$152 descInx:152 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
allocE: 
3:	rtnAlloc 1
5:	toSuper 80
doE: 
8:	mvStack
9:	rtnInner


Class IndexedRef descInx:153 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class + descInx:155 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	pushText 1
12:	pushthis 
13:	rstoreg 3
15:	rtnAlloc 1
doE: 
17:	doEventQ 
18:	mvStack
19:	pushthis 
20:	pushthis 
21:	rpushg 1
23:	invoke 15 0 0
29:	pushg 2
31:	storeg 4
33:	pushthis 
34:	invoke 156 0 0
40:	rpop 
41:	setThisStack
42:	pushthis 
43:	rtn D


Class doplus descInx:156 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushthis 
8:	rpushg 1
10:	pushg 4
12:	pushthis 
13:	rpushg 1
15:	rpushg 2
17:	invoke 15 0 0
23:	pushg 2
25:	+
26:	pushthis 
27:	pushc 1
29:	allocIndexed 157 1 0 
34:	pushthis 
35:	rstoreg 4
37:	rtnAlloc 1
doE: 
39:	doEventQ 
40:	mvStack
41:	pushthis 
42:	invoke 161 0 0
48:	rpop 
49:	pushthis 
50:	invoke 163 0 0
56:	rpop 
57:	pushthis 
58:	rpushg 1
60:	pushthis 
61:	rpushg 4
63:	%prim asString 118
65:	rswap 0
67:	rstoreg 3
69:	setThisStack
70:	pushthis 
71:	rtn D


Class Indexed descInx:157 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class repeat$159 descInx:159 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	pushthis 
17:	rpushg 1
19:	rpushg 4
21:	rpushg 1
23:	rpushg 1
25:	pushthis 
26:	rpushg 1
28:	pushg 3
30:	xpushg 1 0 1
34:	storeg 2
36:	pushthis 
37:	rpushg 1
39:	rpushg 4
41:	rpushg 4
43:	pushthis 
44:	rpushg 1
46:	rpushg 4
48:	pushg 2
50:	pushthis 
51:	rpushg 1
53:	pushg 3
55:	xstoreg 1 0 1 
59:	setThisStack
60:	pushthis 
61:	rtn D


Class for:to:repeat$161 descInx:161 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	pushg 4
13:	pushthis 
14:	storeg 2
16:	pushthis 
17:	storeg 1
19:	allocEventQ 0
allocE: 
21:	rtnAlloc 1
23:	toSuper 28
doE: 
26:	mvStack
27:	rtnInner


Class repeat$162 descInx:162 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	pushthis 
17:	rpushg 1
19:	rpushg 4
21:	rpushg 1
23:	rpushg 2
25:	pushthis 
26:	rpushg 1
28:	pushg 3
30:	xpushg 1 0 1
34:	storeg 2
36:	pushthis 
37:	rpushg 1
39:	rpushg 4
41:	pushthis 
42:	rpushg 1
44:	rpushg 4
46:	rpushg 1
48:	pushg 4
50:	pushthis 
51:	rpushg 1
53:	pushg 3
55:	+
56:	storeg 3
58:	pushthis 
59:	rpushg 1
61:	rpushg 4
63:	rpushg 4
65:	pushthis 
66:	rpushg 1
68:	rpushg 4
70:	pushg 2
72:	pushthis 
73:	rpushg 1
75:	rpushg 4
77:	pushg 3
79:	xstoreg 1 0 1 
83:	setThisStack
84:	pushthis 
85:	rtn D


Class for:to:repeat$163 descInx:163 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	rpushg 2
13:	invoke 15 0 0
19:	pushg 2
21:	pushthis 
22:	storeg 2
24:	pushthis 
25:	storeg 1
27:	allocEventQ 0
allocE: 
29:	rtnAlloc 1
31:	toSuper 28
doE: 
34:	mvStack
35:	rtnInner


Class asString descInx:164 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushText 1
9:	pushthis 
10:	rstoreg 2
12:	rtnAlloc 1
doE: 
14:	doEventQ 
15:	mvStack
16:	setThisStack
17:	pushthis 
18:	rtn D


Class valProx descInx:165 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	0


Class VM descInx:166 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	invoke 1 0 1
8:	stop 
9:	rtn D


Class EventProcessor descInx:167 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	stop 


Class ThreadStub descInx:168 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
doE: 
1:	call D
3:	stop 

