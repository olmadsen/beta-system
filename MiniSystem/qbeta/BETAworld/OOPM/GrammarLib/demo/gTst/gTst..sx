
 CLASS BETAworld 21 1 BETA 2
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(Object) "
 -- INV:gen: "inner(Object) " 
 -- needorigin: "inner(Object) " 
 -- needOrigin:E: "inner(Object) "  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(Object) " rec: "inner(Object) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  E.ATd.desc: 
 --  %basic 101
 --  in inner: ref Object
 --  E.ATd.IT: 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- doNeedOrigin:Ex: "inner(Object) "originIsValueObj: false 
 --  origin.isPrimitive: true 
 -- KUK 
 -- after:needOrigin: "inner(Object) " 
 -- doNeedOrigin:E: "inner(Object) " 
 -- computeAdrX:superAdj: 0 "inner(Object) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(Object) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(Object) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:- 
 --  rec:  "inner(Object) "E:  "inner(Object) "
 -- INV:gen:E.loadArgs "inner(Object) "
 -- INV:gen:after:E.loadArgs "inner(Object) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  inner(Object) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(Object) "ptnKind: 0 useRtnV: 
 --  false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:inner(Object) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:inner(Object) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:inner(Object) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS BETAworld 1 1 Object 21
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 pushThis 
 saveBETAworld
 mvStack 
 pushThis 
 -- before objTmpStack:add:  2   "BETA "
 invoke BETA 2 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  33   "LIB "
 invoke LIB 33 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  67   "OOPM "
 invoke OOPM 67 4 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS BETA 2 1 BETAworld 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: 
 --  ascii: obj 
 --     asciiFoo: 
 --        msg1:  -- obj
 --           _put('F')DI:isConst: true isBasicValue: false primNo: 0 
 -- DI:isConst: ascii 
 -- DI:off: 2 this: 
 --  ascii: obj 
 --     asciiFoo: 
 --        msg1:  -- obj
 --           _put('F')
 --  
 pushThis 
 -- before objTmpStack:add:  3   "ascii "
 invoke ascii 3 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- DI:gen: "console: ref ConsoleIF " DI:isConst: false 
 --  isBasicValue: false primNo: 0 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:2 objSize:3 isIndexed:0

 CLASS ascii 3 1 BETA 2
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "nl: val 10 " DI:isConst: true isBasicValue: true 
 --  primNo: 1 
 -- DI:valueObj: nl 
 -- OG:before:super.gen: "10 "
 -- INV:gen: "10 " 
 -- needorigin: "10 " 
 -- needOrigin:E: "10 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "10 " rec: "10 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "10 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "10 "E:  "10 "
 -- INV:gen:E.loadArgs "10 "
 -- INV:gen:after:E.loadArgs "10 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "10 "
 pushc 10
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- DI:store:basicValue: off: 1 NewOff: 2 
 pushThis 
 storeg nl 2
 -- DI:gen: "cr: val 13 " DI:isConst: true isBasicValue: true 
 --  primNo: 1 
 -- DI:valueObj: cr 
 -- OG:before:super.gen: "13 "
 -- INV:gen: "13 " 
 -- needorigin: "13 " 
 -- needOrigin:E: "13 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "13 " rec: "13 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "13 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "13 "E:  "13 "
 -- INV:gen:E.loadArgs "13 "
 -- INV:gen:after:E.loadArgs "13 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "13 "
 pushc 13
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- DI:store:basicValue: off: 2 NewOff: 3 
 pushThis 
 storeg cr 3
 -- DI:gen: "null: val 0 " DI:isConst: true isBasicValue: true 
 --  primNo: 1 
 -- DI:valueObj: null 
 -- OG:before:super.gen: "0 "
 -- INV:gen: "0 " 
 -- needorigin: "0 " 
 -- needOrigin:E: "0 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "0 " rec: "0 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "0 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "0 "E:  "0 "
 -- INV:gen:E.loadArgs "0 "
 -- INV:gen:after:E.loadArgs "0 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0 "
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- DI:store:basicValue: off: 3 NewOff: 4 
 pushThis 
 storeg null 4
 -- DI:gen: "newline: var char " DI:isConst: false isBasicValue: 
 --  true primNo: 3 
 -- DI:gen:primitiveType: newline 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: 
 --  newline := nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  
 pushThis 
 -- AssignmentStatement:gen: 
 --  
 --  newline := nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  right.label: "ObjectGenerator "
 --  nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  
 -- OG:before:super.gen: "
 --  nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1 "
 -- INV:gen: 
 --  nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  
 pushc 10
 -- OG:gen:end: OIadr: none 
 -- checkNumberConvert: 
 --  nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  D: "newline: var char " 
 -- assign:adr.store:A: 
 storeg ascii$3 5
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0

 CLASS Value 4 0 BETA 2 isValueObj
 mvStack 
 rtnAlloc 1
DO:
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:0 isIndexed:0

 CLASS integer 5 0 BETA 2 isValueObj
 mvStack 
 -- DI:gen: "_thisBasicValue: var Universal " DI:isConst: false 
 --  isBasicValue: true primNo: 1 
 -- DI:gen:primitiveType: _thisBasicValue 
 rtnAlloc 1
DO:
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS universal 6 0 BETA 2 isValueObj
 mvStack 
 rtnAlloc 1
DO:
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:0 isIndexed:0

 CLASS char 7 0 BETA 2 isValueObj
 mvStack 
 -- DI:gen: "_thisBasicValue: var Universal " DI:isConst: false 
 --  isBasicValue: true primNo: 1 
 -- DI:gen:primitiveType: _thisBasicValue 
 rtnAlloc 1
DO:
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS ConsoleIF 8 1 BETA 2
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS put 9 1 ConsoleIF 8
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS String 10 0 StringLib 41
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:2 objSize:0 isIndexed:1

 CLASS = 11 1 Value 4
 jmpFalse  L3
 pushThis 
 -- vassign:B: Veq off: 4 size: 2 mode: 0 
 vassign  4 2 0
 jmp L4
 L3:
 invokeVal  Veq 31 3
 rpop 
 L4:
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in Veq: var this(Value) " DI:isConst: false 
 --  isBasicValue: false primNo: 18 
 -- DI:isConst: Veq 
 -- inArg: in Veq: var this(Value) 
 -- DI:gen: "out Beq: var boolean " DI:isConst: false isBasicValue: 
 --  true primNo: 4 
 -- DI:gen:primitiveType: Beq 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(= ) "
 -- INV:gen: "inner(= ) " 
 -- needorigin: "inner(= ) " 
 -- needOrigin:E: "inner(= ) "  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(= ) " rec: "inner(= ) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  E.ATd.desc: 
 --  %basic 101
 --  in inner: ref Object
 --  E.ATd.IT: 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- doNeedOrigin:Ex: "inner(= ) "originIsValueObj: false 
 --  origin.isPrimitive: true 
 -- KUK 
 -- after:needOrigin: "inner(= ) " 
 -- doNeedOrigin:E: "inner(= ) " 
 -- computeAdrX:superAdj: 0 "inner(= ) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(= ) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(= ) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:- 
 --  rec:  "inner(= ) "E:  "inner(= ) "
 -- INV:gen:E.loadArgs "inner(= ) "
 -- INV:gen:after:E.loadArgs "inner(= ) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  inner(= ) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(= ) "ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:inner(= ) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:inner(= ) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:inner(= ) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0

 CLASS = 13 1 String 10
 -- vdtTableCopy: I:1:11 I:2:0
 rShiftUp  1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- super =
 pushThis 
 rpushg iOrigin 1
 rShiftDown  1
 pushThis 
 rstoreg  Veq 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in Veq: var this(Value) " DI:isConst: false 
 --  isBasicValue: false primNo: 18 
 -- DI:isConst: Veq 
 -- inArg: in Veq: var this(Value) 
 -- DI:gen: "out Beq: var boolean " DI:isConst: false isBasicValue: 
 --  true primNo: 4 
 -- DI:gen:primitiveType: Beq 
DO:
 doEventQ
 mvStack 
 L1:
 pushThis 
 -- before objTmpStack:add:  14   "loop "
 invoke loop 14 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS loop 14 1 = 13
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "c1: var char " DI:isConst: false isBasicValue: true 
 --  primNo: 3 
 -- DI:gen:primitiveType: c1 
 -- DI:gen: "c2: var char " DI:isConst: false isBasicValue: true 
 --  primNo: 3 
 -- DI:gen:primitiveType: c2 
 -- DI:gen: "L: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: L 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "L := length " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "L := length " right.label: "ObjectGenerator ""length " 
 -- OG:before:super.gen: "length "
 -- INV:gen: "length " 
 -- needorigin: "length " 
 -- needOrigin:E: "length "  E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  Ex: "length " rec: "length " E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  E.ATd.desc: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  E.ATd.IT: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- doNeedOrigin:Ex: "length "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "length " 
 -- doNeedOrigin:E: "length " 
 -- computeAdrX:superAdj: 0 "length " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "length " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 2 isValueObj: false 
 --  origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- items:goOrigin:encOG: "= "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg =$13 1
 -- computeAdrX:isLast:E:  "length "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 --  rec:  "length "E:  "length "
 -- INV:gen:E.loadArgs "length "
 -- INV:gen:after:E.loadArgs "length "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- ptn:invoke: "length "E: "length "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "length " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- checkNumberConvert: "length " D: "L: var integer " 
 -- assign:adr.store:A: 
 storeg loop$14 4
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "if (L <> Veq.length) :then 
 --     leave(loop) "
 -- INV:gen: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  
 -- needorigin: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  
 -- needOrigin:E: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  rec: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 -- \
 --      %globals inSub
 --  E.ATd.desc: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  E.ATd.IT: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "if (L <> Veq.length) :then 
 --     leave(loop) "E:  "
 --  if (L <> Veq.length) :then 
 --     leave(loop) "
 -- INV:gen:E.loadArgs "if (L <> Veq.length) :then 
 --     leave(loop) "
 -- INV:gen:after:E.loadArgs "
 --  if (L <> Veq.length) :then 
 --     leave(loop) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "
 --  if (L <> Veq.length) :then 
 --     leave(loop) "
 -- OG:before:super.gen: "(L <> Veq.length) "
 -- INV:gen: "(L <> Veq.length) " 
 -- needorigin: "(L <> Veq.length) " 
 -- needOrigin:E: "(L <> Veq.length) "  E.ATd: 
 --  <>  : 
 --     %basic 55
 --     in V: var integer
 --     out B: var boolean
 --  Ex: "(L <> Veq.length) " rec: "(L <> Veq.length) " E.ATd: 
 --  <>  : 
 --     %basic 55
 --     in V: var integer
 --     out B: var boolean
 --  E.ATd.desc: 
 --  %basic 55
 --  in V: var integer
 --  out B: var boolean
 --  E.ATd.IT: 
 --  %basic 55
 --  in V: var integer
 --  out B: var boolean
 -- \
 --   
 -- doNeedOrigin:Ex: "(L <> Veq.length) "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(L <> Veq.length) " 
 -- doNeedOrigin:E: "(L <> Veq.length) " 
 -- computeAdrX:superAdj: 0 "(L <> Veq.length) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(L <> Veq.length) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "L <> Veq.length "superAdj: 0 
 -- BE:loadOrigin:E: L <> Veq.length 
 -- computeAdrX:isLast:E:  "L <> Veq.length "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "L <> Veq.length "E:  "L <> Veq.length "
 -- INV:gen:E.loadArgs "L <> Veq.length "
 -- BinaryExp:loadArgs: "L <> Veq.length " superAdj: 0 
 -- INV:gen: "L " 
 -- needorigin: "L " 
 -- needOrigin:E: "L "  E.ATd: "L: var integer " Ex: "L " rec: "L " 
 --  E.ATd: "L: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L " 
 -- doNeedOrigin:E: "L " 
 -- computeAdrX:superAdj: 0 "L " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "L "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 --  rec:  "L "E:  "L "
 -- INV:gen:E.loadArgs "L "
 -- INV:gen:after:E.loadArgs "L "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- DI:invoke: "L: var integer " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L isNotRemote: true 
 pushg 4 loop$14
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:end:off: 4 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- NonVirt: "<> Veq.length " "ObjectInvocation_Binary " ActArg: "
 --  Veq.length "isValue: false formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "<> Veq.length "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "Veq.length "
 -- INV:gen: "Veq.length " 
 -- needorigin: "Veq.length " 
 -- needOrigin:E: "length "  E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  Ex: "length " rec: "Veq " E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  E.ATd.desc: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  E.ATd.IT: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- doNeedOrigin:Ex: "length "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "length " 
 -- doNeedOrigin:E: "length " 
 -- computeAdrX:superAdj: 0 "Veq.length " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Veq " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- computeAdrX:En: 2 pRec: "Veq " rec: "Veq " E: "length " 
 --  A.E: none 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "Veq " rec: "Veq " E: "length " 
 --  rec.ATd: "in Veq: var this(Value) " rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --     inner(= )
 --  
 --  recA: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 --  pRecA: none 
 -- pRec: "Veq " rec: "Veq " E: "length " 
 --  false true 
 -- computeAdrX:before:rec:: "Veq " 
 -- OI:invoke:before:ATdx.invoke: var Veq 
 -- DI:invoke: "in Veq: var this(Value) " 
 -- isValueObj:isAdr: true objSize: 2  rec "Veq ",E: "length ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- Address:loadAdr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 rpushg loop$14 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- computeAdrX:after:rec.invoke: "Veq " 
 -- computeAdrX:isLast:E:  "length "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 --  rec:  "Veq "E:  "length "
 -- INV:gen:E.loadArgs "length "
 -- INV:gen:after:E.loadArgs "length "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- ptn:invoke: "length "E: "length "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "Veq " 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "Veq.length ":isBasicVal: true 
 -- case:B: Veq.length ObjectGenerator 1 0 0 false false 
 -- checkNumberConvert: "Veq.length " D: "in V: var integer " 
 -- end:loadArgs:NonVirt: "<> Veq.length "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:after:E.loadArgs "L <> Veq.length "
 --  OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L <> Veq.length "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- BinaryExp:invoke: "L "rec: "L <> Veq.length "
 -- M: "<> Veq.length "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:before:ATdx.invoke: pattern <>   
 -- ptn:invoke: "<>   "E: "<> Veq.length "ptnKind: 0 useRtnV: true 
 ne
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<> Veq.length":rec:L 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<> Veq.length":rec:L 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  18   "$18 "
 invoke $18 18 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- AssignmentStatement:gen: "beq := true " 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- AssignmentStatement:gen: 
 --  "beq := true " right.label: "ObjectGenerator ""true " 
 -- OG:before:super.gen: "true "
 -- INV:gen: "true " 
 -- needorigin: "true " 
 -- needOrigin:E: "true "  E.ATd: 
 --  True: 
 --     %globals
 --     out B: var boolean
 --     B := 1
 --  Ex: "true " rec: "true " E.ATd: 
 --  True: 
 --     %globals
 --     out B: var boolean
 --     B := 1
 --  E.ATd.desc: 
 --  %globals
 --  out B: var boolean
 --  B := 1
 --  E.ATd.IT: 
 --  %globals
 --  out B: var boolean
 --  B := 1
 -- \
 --   
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %globals
 --     out B: var boolean
 --     B := 1
 --  
 -- after:needOrigin: "true " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "true "E:  "true "
 -- INV:gen:E.loadArgs "true "
 -- INV:gen:after:E.loadArgs "true "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "true "
 -- OI:invoke:before:ATdx.invoke: pattern True 
 -- ptn:invoke: "True "E: "true "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "true " 
 --  adr:none 
 invoke True 23 0 0
 -- global:pushOut: B off: 1 
 pushg 1 
 -- callInvoke:after:pushOut: 1 
 -- GeneralPTN:invoke:after:callInvoke: 1 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- checkNumberConvert: "true " D: "out Beq: var boolean " 
 -- assign:adr.store:A: 
 storeg =$13 3
 -- assign:adr.store:B: 
 pushThis 
 -- before objTmpStack:add:  30   "for:to:repeat$30 "
 invoke for:to:repeat$30 30 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS length 15 1 String 10
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "out V: var integer " DI:isConst: false isBasicValue: 
 --  true primNo: 1 
 -- DI:gen:primitiveType: V 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "
 --  V := get[0] -- actually an index error, accessing length " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "V := get[0] -- actually an index error, accessing length " 
 --  right.label: "ObjectGenerator ""
 --  get[0] -- actually an index error, accessing length " 
 -- OG:before:super.gen: "
 --  get[0] -- actually an index error, accessing length "
 -- INV:gen: "get[0] -- actually an index error, accessing length " 
 -- needorigin: "
 --  get[0] -- actually an index error, accessing length " 
 -- needOrigin:E: "
 --  get[0] -- actually an index error, accessing length "  E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  Ex: "get[0] -- actually an index error, accessing length " rec: "
 --  get[0] -- actually an index error, accessing length " E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  E.ATd.desc: 
 --  %basic 117
 --  out ch: var char
 --  E.ATd.IT: 
 --  %basic 117
 --  out ch: var char
 --  
 -- doNeedOrigin:Ex: "
 --  get[0] -- actually an index error, accessing length "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "
 --  get[0] -- actually an index error, accessing length " 
 -- doNeedOrigin:E: "
 --  get[0] -- actually an index error, accessing length " 
 -- computeAdrX:superAdj: 0 "
 --  get[0] -- actually an index error, accessing length " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "
 --  get[0] -- actually an index error, accessing length " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "length "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg length$15 1
 -- computeAdrX:isLast:E:  "
 --  get[0] -- actually an index error, accessing length "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, accessing length":rec:- 
 --  rec:  "get[0] -- actually an index error, accessing length "E:  "
 --  get[0] -- actually an index error, accessing length "
 -- INV:gen:E.loadArgs "
 --  get[0] -- actually an index error, accessing length "
 -- NonVirt: "get[0] -- actually an index error, accessing length " "
 --  ObjectInvocation_KeyWord " ActArg: "0 "isValue: true formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  get[0] -- actually an index error, accessing length " isCompositeValueObj: false 
 -- OG:before:super.gen: "0 "
 -- INV:gen: "0 " 
 -- needorigin: "0 " 
 -- needOrigin:E: "0 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "0 " rec: "0 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "0 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "0 "E:  "0 "
 -- INV:gen:E.loadArgs "0 "
 -- INV:gen:after:E.loadArgs "0 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0 "
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "0 ":isBasicVal: true 
 -- case:B: 0 ObjectGenerator 1 1 1 false true 
 -- checkNumberConvert: "0 " D: "inx: var integer " 
 -- end:loadArgs:NonVirt: "
 --  get[0] -- actually an index error, accessing length "
 -- INV:gen:after:E.loadArgs "
 --  get[0] -- actually an index error, accessing length "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "
 --  get[0] -- actually an index error, accessing length "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, accessing length":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- ptn:invoke: "get[inx: var integer] "E: "
 --  get[0] -- actually an index error, accessing length "ptnKind: 0 useRtnV: true 
 xpushg  inx 1 0 1
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, accessing length":rec:get[0] -- actually an index error, accessing length 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, accessing length":rec:get[0] -- actually an index error, accessing length 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, accessing length":rec:get[0] -- actually an index error, accessing length 
 -- checkNumberConvert: "
 --  get[0] -- actually an index error, accessing length " D: "out V: var integer " 
 -- assign:adr.store:A: 
 storeg length$15 2
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS this 31 1 BETA 2
 pushThis 
 rstoreg  this 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in this: ref Object " DI:isConst: false isBasicValue: 
 --  false primNo: 64 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS X_asString 32 1 Object 21
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "out S: var LIB.StringLib.String " DI:isConst: false 
 --  isBasicValue: false primNo: 5 
 -- DI:StringVar "out S: var LIB.StringLib.String "
 pushText ""
 pushThis 
 rstoreg  S 2
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(X_asString) "
 -- INV:gen: "inner(X_asString) " 
 -- needorigin: "inner(X_asString) " 
 -- needOrigin:E: "inner(X_asString) "  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(X_asString) " rec: "inner(X_asString) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  E.ATd.desc: 
 --  %basic 101
 --  in inner: ref Object
 --  E.ATd.IT: 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- doNeedOrigin:Ex: "inner(X_asString) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inner(X_asString) " 
 -- doNeedOrigin:E: "inner(X_asString) " 
 -- computeAdrX:superAdj: 0 "inner(X_asString) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(X_asString) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(X_asString) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:- 
 --  rec:  "inner(X_asString) "E:  "inner(X_asString) "
 -- INV:gen:E.loadArgs "inner(X_asString) "
 -- INV:gen:after:E.loadArgs "inner(X_asString) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  inner(X_asString) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(X_asString) "ptnKind: 0 useRtnV: 
 --  false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:inner(X_asString) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:inner(X_asString) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:inner(X_asString) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS LIB 33 1 BETAworld 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 pushThis 
 -- before objTmpStack:add:  34   "BasicIO "
 invoke BasicIO 34 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  38   "Collections "
 invoke Collections 38 4 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  41   "StringLib "
 invoke StringLib 41 5 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- DI:gen: "x_dummy_LIB: var integer " DI:isConst: false 
 --  isBasicValue: true primNo: 1 
 -- DI:gen:primitiveType: x_dummy_LIB 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0

 CLASS BasicIO 34 1 LIB 33
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: 
 --  keyboard: obj 
 --     %Public
 --     readLine: 
 --        out M: var LIB.StringLib.StringDI:isConst: true isBasicValue: false primNo: 0 
 -- DI:isConst: keyboard 
 -- DI:off: 2 this: 
 --  keyboard: obj 
 --     %Public
 --     readLine: 
 --        out M: var LIB.StringLib.String
 --  
 pushThis 
 -- before objTmpStack:add:  35   "keyboard "
 invoke keyboard 35 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- DI:gen: 
 --  screen: obj 
 --     L: obj Lock
 --     %Public
 --     init: DI:isConst: true isBasicValue: false primNo: 0 
 -- DI:isConst: screen 
 -- DI:off: 3 this: 
 --  screen: obj 
 --     L: obj Lock
 --     %Public
 --     init: 
 --  
 pushThis 
 -- before objTmpStack:add:  36   "screen "
 invoke screen 36 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS keyboard 35 1 BasicIO 34
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS screen 36 1 BasicIO 34
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "L: obj Lock " DI:isConst: true isBasicValue: false 
 --  primNo: 0 
 -- DI:isConst: L 
 -- DI:off: 2 this: "L: obj Lock " 
 --  
 -- OG:before:super.gen: "Lock "
 -- INV:gen: "Lock " 
 -- needorigin: "Lock " 
 -- needOrigin:E: "Lock "  E.ATd: 
 --  Lock: 
 --     dummy: var integer
 --     %Public
 --     M: var integerEx: "Lock " rec: "Lock " E.ATd: 
 --  Lock: 
 --     dummy: var integer
 --     %Public
 --     M: var integerE.ATd.desc: 
 --  dummy: var integer
 --  %Public
 --  M: var integer
 --  init: E.ATd.IT: 
 --  dummy: var integer
 --  %Public
 --  M: var integer
 --  init: 
 -- doNeedOrigin:Ex: "Lock "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "Lock " 
 -- doNeedOrigin:E: "Lock " 
 -- computeAdrX:superAdj: 0 "Lock " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Lock " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "screen "on: 1 isValueObj: false 
 --  origin: BasicIO origin:isValueObj: false 
 rpushg screen$36 1
 -- computeAdrX:isLast:E:  "Lock "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:- 
 --  rec:  "Lock "E:  "Lock "
 -- INV:gen:E.loadArgs "Lock "
 -- INV:gen:after:E.loadArgs "Lock "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "Lock "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern Lock 
 -- ptn:invoke: "Lock "E: "Lock "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 2 rec: "Lock " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:Lock 
 invoke Lock 37 2 1
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:Lock 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:Lock 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:Lock 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS Lock 37 1 BasicIO 34
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "dummy: var integer " DI:isConst: false isBasicValue: 
 --  true primNo: 1 
 -- DI:gen:primitiveType: dummy 
 -- DI:gen: "M: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: M 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS Collections 38 1 LIB 33
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- before objTmpStack:add:  39   "OrderedList "
 invoke OrderedList 39 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  40   "SetLib "
 invoke SetLib 40 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS OrderedList 39 0 Collections 38
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:0 isIndexed:0

 CLASS SetLib 40 1 Collections 38
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS StringLib 41 1 LIB 33
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 saveStringOrigin
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $18 18 1 loop 14
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "leave(loop) "
 -- INV:gen: "leave(loop) " 
 -- needorigin: "leave(loop) " 
 -- needOrigin:E: "leave(loop) "  E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  Ex: "leave(loop) " rec: "leave(loop) " E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  E.ATd.desc: "%basic 103 " E.ATd.IT: "%basic 103 " 
 -- doNeedOrigin:Ex: "leave(loop) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "leave(loop) " 
 -- doNeedOrigin:E: "leave(loop) " 
 -- computeAdrX:superAdj: 0 "leave(loop) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "leave(loop) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "leave(loop) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:- 
 --  rec:  "leave(loop) "E:  "leave(loop) "
 -- INV:gen:E.loadArgs "leave(loop) "
 -- INV:gen:after:E.loadArgs "leave(loop) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  leave(loop) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- ptn:invoke: "leave(V: var integer) "E: "leave(loop) "ptnKind: 0 
 --  useRtnV: false 
 break  1 2 14 0
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS if:then 20 0 BETA 2
 pushThis 
 storeg Boolean$42 1
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:1 objSize:1 isIndexed:0

 CLASS thenPart#22 22 0 if:then$20 20 isVstub
 invoke Object 21 0 1
 pushThis 
 rstoreg   2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:1 objSize:3 isIndexed:0

 CLASS Boolean 42 0 BETA 2 isValueObj
 mvStack 
 -- DI:gen: "_thisBasicValue: var Universal " DI:isConst: false 
 --  isBasicValue: true primNo: 1 
 -- DI:gen:primitiveType: _thisBasicValue 
 rtnAlloc 1
DO:
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS True 23 0 BETA 2
 allocEventQ
 mvStack 
 -- DI:gen: "out B: var boolean " DI:isConst: false isBasicValue: 
 --  true primNo: 4 
 -- DI:gen:primitiveType: B 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "B := 1 " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "B := 1 " right.label: "ObjectGenerator ""1 " 
 -- OG:before:super.gen: "1 "
 -- INV:gen: "1 " 
 -- needorigin: "1 " 
 -- needOrigin:E: "1 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "1 " rec: "1 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "1 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "1 "E:  "1 "
 -- INV:gen:E.loadArgs "1 "
 -- INV:gen:after:E.loadArgs "1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1 "
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- checkNumberConvert: "1 " D: "out B: var boolean " 
 -- assign:adr.store:A: 
 storeg True$23 1
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS for:to:repeat 28 0 BETA 2
 pushThis 
 storeg integer$5 2
 pushThis 
 storeg integer$5 1
 allocEventQ
 mvStack 
 -- DI:gen: "inx: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: inx 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "inx := first " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "inx := first " right.label: "ObjectGenerator ""first " 
 -- OG:before:super.gen: "first "
 -- INV:gen: "first " 
 -- needorigin: "first " 
 -- needOrigin:E: "first "  E.ATd: "first: var integer " Ex: "
 --  first " rec: "first " E.ATd: "first: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "first " 
 -- doNeedOrigin:E: "first " 
 -- computeAdrX:superAdj: 0 "first " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "first " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "first "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:- 
 --  rec:  "first "E:  "first "
 -- INV:gen:E.loadArgs "first "
 -- INV:gen:after:E.loadArgs "first "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "first "
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:- 
 -- OI:invoke:before:ATdx.invoke: var first 
 -- DI:invoke: "first: var integer " 
 -- load: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:first isNotRemote: true 
 pushg 1 for:to:repeat$28
 -- OI:invoke:V: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:first 
 -- OI:invoke:X: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:first 
 -- INV:gen:end:off: 1 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:first 
 -- checkNumberConvert: "first " D: "inx: var integer " 
 -- assign:adr.store:A: 
 storeg for:to:repeat$28 3
 -- assign:adr.store:B: 
 pushThis 
 -- before objTmpStack:add:  43   "_doIt "
 invoke _doIt 43 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:1 objSize:3 isIndexed:0

 CLASS repeat#29 29 0 for:to:repeat$28 28 isVstub
 invoke Object 21 0 1
 pushThis 
 rstoreg   2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:1 objSize:3 isIndexed:0

 CLASS _doIt 43 1 for:to:repeat 28
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  :else 
 --     inx := inx "
 -- INV:gen: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 -- needorigin: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 -- needOrigin:E: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt) E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)rec: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)E.ATd: 
 -- \
 --   if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  E.ATd.desc: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  E.ATd.IT: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  :else 
 --     inx := inx "E:  "
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  :else 
 --     inx := inx "
 -- INV:gen:E.loadArgs "
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  :else 
 --     inx := inx "
 -- INV:gen:after:E.loadArgs "
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  :else 
 --     inx := inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThenElse "
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  :else 
 --     inx := inx "
 -- OG:before:super.gen: "(inx <= last) "
 -- INV:gen: "(inx <= last) " 
 -- needorigin: "(inx <= last) " 
 -- needOrigin:E: "(inx <= last) "  E.ATd: 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  Ex: "(inx <= last) " rec: "(inx <= last) " E.ATd: 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  E.ATd.desc: 
 --  %basic 52
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  E.ATd.IT: 
 --  %basic 52
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 -- \
 --   
 -- doNeedOrigin:Ex: "(inx <= last) "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(inx <= last) " 
 -- doNeedOrigin:E: "(inx <= last) " 
 -- computeAdrX:superAdj: 0 "(inx <= last) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(inx <= last) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "inx <= last "superAdj: 0 
 -- BE:loadOrigin:E: inx <= last 
 -- computeAdrX:isLast:E:  "inx <= last "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "inx <= last "E:  "inx <= last "
 -- INV:gen:E.loadArgs "inx <= last "
 -- BinaryExp:loadArgs: "inx <= last " superAdj: 0 
 -- INV:gen: "inx " 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "_doIt "on: 1 isValueObj: false 
 --  origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$43 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 3 for:to:repeat$28
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- NonVirt: "<= last " "ObjectInvocation_Binary " ActArg: "last "
 --  isValue: false formalArg: "in Veq: var this(Value) " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "<= last " isCompositeValueObj: 
 --  true 
 -- OG:before:super.gen: "last "
 -- INV:gen: "last " 
 -- needorigin: "last " 
 -- needOrigin:E: "last "  E.ATd: "last: var integer " Ex: "last " 
 --  rec: "last " E.ATd: "last: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "last " 
 -- doNeedOrigin:E: "last " 
 -- computeAdrX:superAdj: 0 "last " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "last " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "_doIt "on: 1 isValueObj: false 
 --  origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$43 1
 -- computeAdrX:isLast:E:  "last "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:- 
 --  rec:  "last "E:  "last "
 -- INV:gen:E.loadArgs "last "
 -- INV:gen:after:E.loadArgs "last "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "last "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:- 
 -- OI:invoke:before:ATdx.invoke: var last 
 -- DI:invoke: "last: var integer " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:last isNotRemote: true 
 pushg 2 for:to:repeat$28
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:last 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:last 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:last 
 -- vEq: 
 -- end:loadArgs:NonVirt: "<= last "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:after:E.loadArgs "inx <= last "
 --  OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- IV:E.invoke:useRtnVal: true E: BinOp "inx <= last "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- BinaryExp:invoke: "inx "rec: "inx <= last "
 -- M: "<= last "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:before:ATdx.invoke: pattern <=   
 -- ptn:invoke: "<=   "E: "<= last "ptnKind: 1 useRtnV: true 
 -- E: "<= last " rec: "inx ""Invocation "OGx: "integer " 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- rec.ATd: "inx: var integer " 
 -- bobs: 1 OGx: "integer " 
 -- 
 le
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<= last":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<= last":rec:inx 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  45   "$45 "
 invoke $45 45 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L5
 L4:
 pushThis 
 -- before objTmpStack:add:  48   "$48 "
 invoke $48 48 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L5:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $45 45 1 _doIt 43
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "repeat "
 -- INV:gen: "repeat " 
 -- needorigin: "repeat " 
 -- needOrigin:E: "repeat "  E.ATd: "repeat:< object " Ex: "repeat " 
 --  rec: "repeat " E.ATd: "repeat:< object " E.ATd.desc: 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : E.ATd.IT: " " 
 -- doNeedOrigin:Ex: "repeat "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "repeat " 
 -- doNeedOrigin:E: "repeat " 
 -- computeAdrX:superAdj: 0 "repeat " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "repeat " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$45 "on: 2 isValueObj: false 
 --  origin: _doIt origin:isValueObj: false 
 rpushg $45$45 1
 -- items:goOrigin:encOG: "_doIt "on: 1 isValueObj: false 
 --  origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$43 1
 -- computeAdrX:isLast:E:  "repeat "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:- 
 --  rec:  "repeat "E:  "repeat "
 -- INV:gen:E.loadArgs "repeat "
 -- INV:gen:after:E.loadArgs "repeat "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "repeat "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern repeat 
 -- ptn:invoke: "repeat "E: "repeat "ptnKind: 1 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 1 staticOff: 0 rec: "repeat " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:repeat 
 -- isStatic: false rec: "repeat "
 invokev 2 0 repeat$29$29 0
 -- GeneralPTN:invoke:after:pushOut: 
 rpop 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:repeat 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:repeat 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:repeat 
 -- AssignmentStatement:gen: "inx := inx + 1 " 
 pushThis 
 -- items:goOrigin:encOG: "$45 "on: 2 isValueObj: false 
 --  origin: _doIt origin:isValueObj: false 
 rpushg $45$45 1
 -- items:goOrigin:encOG: "_doIt "on: 1 isValueObj: false 
 --  origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$43 1
 -- AssignmentStatement:gen: 
 --  "inx := inx + 1 " right.label: "ObjectGenerator ""inx + 1 " 
 -- OG:before:super.gen: "inx + 1 "
 -- INV:gen: "inx + 1 " 
 -- needorigin: "inx + 1 " 
 -- needOrigin:E: "inx + 1 "  E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  Ex: "inx + 1 " rec: "inx + 1 " E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  E.ATd.desc: 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 --  E.ATd.IT: 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 -- \
 --   
 -- doNeedOrigin:Ex: "inx + 1 "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inx + 1 " 
 -- doNeedOrigin:E: "inx + 1 " 
 -- computeAdrX:superAdj: 0 "inx + 1 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx + 1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "inx + 1 "superAdj: 0 
 -- computeAdrX:isLast:E:  "inx + 1 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "inx + 1 "E:  "inx + 1 "
 -- INV:gen:E.loadArgs "inx + 1 "
 -- BinaryExp:loadArgs: "inx + 1 " superAdj: 0 
 -- INV:gen: "inx " 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$45 "on: 2 isValueObj: false 
 --  origin: _doIt origin:isValueObj: false 
 rpushg $45$45 1
 -- items:goOrigin:encOG: "_doIt "on: 1 isValueObj: false 
 --  origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$43 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 3 for:to:repeat$28
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- NonVirt: "+ 1 " "ObjectInvocation_Binary " ActArg: "1 "isValue: 
 --  true formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ 1 " isCompositeValueObj: false 
 -- OG:before:super.gen: "1 "
 -- INV:gen: "1 " 
 -- needorigin: "1 " 
 -- needOrigin:E: "1 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "1 " rec: "1 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "1 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "1 "E:  "1 "
 -- INV:gen:E.loadArgs "1 "
 -- INV:gen:after:E.loadArgs "1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1 "
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- checkNumberConvert: "1 " D: "in V: var integer " 
 -- end:loadArgs:NonVirt: "+ 1 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:after:E.loadArgs "inx + 1 "
 --  OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- IV:E.invoke:useRtnVal: true E: BinOp "inx + 1 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- BinaryExp:invoke: "inx "rec: "inx + 1 "
 -- M: "+ 1 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- ptn:invoke: "+   "E: "+ 1 "ptnKind: 0 useRtnV: true 
 plus
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:inx 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- checkNumberConvert: "inx + 1 " D: "inx: var integer " 
 -- assign:adr.store:A: 
 storeg for:to:repeat$28 3
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "restart(_doIt) "
 -- INV:gen: "restart(_doIt) " 
 -- needorigin: "restart(_doIt) " 
 -- needOrigin:E: "restart(_doIt) "  E.ATd: 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  Ex: "restart(_doIt) " rec: "restart(_doIt) " E.ATd: 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  E.ATd.desc: "%basic 102 " E.ATd.IT: "%basic 102 " 
 -- doNeedOrigin:Ex: "restart(_doIt) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "restart(_doIt) " 
 -- doNeedOrigin:E: "restart(_doIt) " 
 -- computeAdrX:superAdj: 0 "restart(_doIt) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "restart(_doIt) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "restart(_doIt) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:- 
 --  rec:  "restart(_doIt) "E:  "restart(_doIt) "
 -- INV:gen:E.loadArgs "restart(_doIt) "
 -- INV:gen:after:E.loadArgs "restart(_doIt) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  restart(_doIt) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern restart(V: var integer) 
 -- ptn:invoke: "restart(V: var integer) "E: "restart(_doIt) "
 --  ptnKind: 0 useRtnV: false 
 break  1 1 43 0
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:restart(_doIt) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:restart(_doIt) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:restart(_doIt) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $48 48 1 _doIt 43
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "inx := inx " 
 pushThis 
 -- items:goOrigin:encOG: "$48 "on: 2 isValueObj: false 
 --  origin: _doIt origin:isValueObj: false 
 rpushg $48$48 1
 -- items:goOrigin:encOG: "_doIt "on: 1 isValueObj: false 
 --  origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$43 1
 -- AssignmentStatement:gen: 
 --  "inx := inx " right.label: "ObjectGenerator ""inx " 
 -- OG:before:super.gen: "inx "
 -- INV:gen: "inx " 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$48 "on: 2 isValueObj: false 
 --  origin: _doIt origin:isValueObj: false 
 rpushg $48$48 1
 -- items:goOrigin:encOG: "_doIt "on: 1 isValueObj: false 
 --  origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$43 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 3 for:to:repeat$28
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- checkNumberConvert: "inx " D: "inx: var integer " 
 -- assign:adr.store:A: 
 storeg for:to:repeat$28 3
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS repeat$24 24 1 for:to:repeat$30 30
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "c1 := get[inx] " 
 pushThis 
 -- items:goOrigin:encOG: "repeat$24 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30 "on: 1 isValueObj: 
 --  false 
 --  origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- AssignmentStatement:gen: 
 --  "c1 := get[inx] " right.label: "ObjectGenerator ""get[inx] " 
 -- OG:before:super.gen: "get[inx] "
 -- INV:gen: "get[inx] " 
 -- needorigin: "get[inx] " 
 -- needOrigin:E: "get[inx] "  E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  Ex: "get[inx] " rec: "get[inx] " E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  E.ATd.desc: 
 --  %basic 117
 --  out ch: var char
 --  E.ATd.IT: 
 --  %basic 117
 --  out ch: var char
 --  
 -- doNeedOrigin:Ex: "get[inx] "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "get[inx] " 
 -- doNeedOrigin:E: "get[inx] " 
 -- computeAdrX:superAdj: 0 "get[inx] " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "get[inx] " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$24 "on: 4 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30 "on: 3 isValueObj: 
 --  false 
 --  origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- items:goOrigin:encOG: "loop "on: 2 isValueObj: false 
 --  origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- items:goOrigin:encOG: "= "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg =$13 1
 -- computeAdrX:isLast:E:  "get[inx] "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 --  rec:  "get[inx] "E:  "get[inx] "
 -- INV:gen:E.loadArgs "get[inx] "
 -- NonVirt: "get[inx] " "ObjectInvocation_KeyWord " ActArg: "inx "
 --  isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx] " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "inx "
 -- INV:gen: "inx " 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$24 "on: 1 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 3 for:to:repeat$30$30
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- checkNumberConvert: "inx " D: "inx: var integer " 
 -- end:loadArgs:NonVirt: "get[inx] "
 -- INV:gen:after:E.loadArgs "get[inx] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx] "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- ptn:invoke: "get[inx: var integer] "E: "get[inx] "ptnKind: 0 
 --  useRtnV: true 
 xpushg  inx 1 0 1
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- checkNumberConvert: "get[inx] " D: "c1: var char " 
 -- assign:adr.store:A: 
 storeg loop$14 2
 -- assign:adr.store:B: 
 -- AssignmentStatement:gen: "c2 := Veq.get[inx] " 
 pushThis 
 -- items:goOrigin:encOG: "repeat$24 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30 "on: 1 isValueObj: 
 --  false 
 --  origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- AssignmentStatement:gen: 
 --  "c2 := Veq.get[inx] " right.label: "ObjectGenerator ""
 --  Veq.get[inx] " 
 -- OG:before:super.gen: "Veq.get[inx] "
 -- INV:gen: "Veq.get[inx] " 
 -- needorigin: "Veq.get[inx] " 
 -- needOrigin:E: "get[inx] "  E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  Ex: "get[inx] " rec: "Veq " E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  E.ATd.desc: 
 --  %basic 117
 --  out ch: var char
 --  E.ATd.IT: 
 --  %basic 117
 --  out ch: var char
 --  
 -- doNeedOrigin:Ex: "get[inx] "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "get[inx] " 
 -- doNeedOrigin:E: "get[inx] " 
 -- computeAdrX:superAdj: 0 "Veq.get[inx] " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Veq " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$24 "on: 3 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30 "on: 2 isValueObj: 
 --  false 
 --  origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- computeAdrX:En: 2 pRec: "Veq " rec: "Veq " E: "get[inx] " 
 --  A.E: none 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "Veq " rec: "Veq " E: "get[inx] " 
 --  rec.ATd: "in Veq: var this(Value) " rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --     inner(= )
 --  
 --  recA: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 --  pRecA: none 
 -- pRec: "Veq " rec: "Veq " E: "get[inx] " 
 --  false true 
 -- computeAdrX:before:rec:: "Veq " 
 -- OI:invoke:before:ATdx.invoke: var Veq 
 -- DI:invoke: "in Veq: var this(Value) " 
 -- isValueObj:isAdr: true objSize: 2  rec "Veq ",E: "get[inx] ""
 --  ObjectInvocation_KeyWord "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- Address:loadAdr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 rpushg repeat$24$24 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- computeAdrX:after:rec.invoke: "Veq " 
 -- computeAdrX:isLast:E:  "get[inx] "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 --  rec:  "Veq "E:  "get[inx] "
 -- INV:gen:E.loadArgs "get[inx] "
 -- NonVirt: "get[inx] " "ObjectInvocation_KeyWord " ActArg: "inx "
 --  isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx] " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "inx "
 -- INV:gen: "inx " 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$24 "on: 1 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 3 for:to:repeat$30$30
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- checkNumberConvert: "inx " D: "inx: var integer " 
 -- end:loadArgs:NonVirt: "get[inx] "
 -- INV:gen:after:E.loadArgs "get[inx] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx] "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- ptn:invoke: "get[inx: var integer] "E: "get[inx] "ptnKind: 0 
 --  useRtnV: true 
 xpushg  inx 1 0 1
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- checkNumberConvert: "Veq.get[inx] " D: "c2: var char " 
 -- assign:adr.store:A: 
 storeg loop$14 3
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop) "
 -- INV:gen: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  
 -- needorigin: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  
 -- needOrigin:E: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  rec: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  E.ATd: 
 -- \
 --   if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  E.ATd.desc: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  E.ATd.IT: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop) "E:  "
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop) "
 -- INV:gen:E.loadArgs "
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop) "
 -- INV:gen:after:E.loadArgs "
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop) "
 -- OG:before:super.gen: "(c1 <> c2) "
 -- INV:gen: "(c1 <> c2) " 
 -- needorigin: "(c1 <> c2) " 
 -- needOrigin:E: "(c1 <> c2) "  E.ATd: 
 --  <>  : 
 --     %basic 55
 --     in V: var char
 --     out B: var boolean
 --  Ex: "(c1 <> c2) " rec: "(c1 <> c2) " E.ATd: 
 --  <>  : 
 --     %basic 55
 --     in V: var char
 --     out B: var boolean
 --  E.ATd.desc: 
 --  %basic 55
 --  in V: var char
 --  out B: var boolean
 --  E.ATd.IT: 
 --  %basic 55
 --  in V: var char
 --  out B: var boolean
 -- \
 --   
 -- doNeedOrigin:Ex: "(c1 <> c2) "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(c1 <> c2) " 
 -- doNeedOrigin:E: "(c1 <> c2) " 
 -- computeAdrX:superAdj: 0 "(c1 <> c2) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(c1 <> c2) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "c1 <> c2 "superAdj: 0 
 -- BE:loadOrigin:E: c1 <> c2 
 -- computeAdrX:isLast:E:  "c1 <> c2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "c1 <> c2 "E:  "c1 <> c2 "
 -- INV:gen:E.loadArgs "c1 <> c2 "
 -- BinaryExp:loadArgs: "c1 <> c2 " superAdj: 0 
 -- INV:gen: "c1 " 
 -- needorigin: "c1 " 
 -- needOrigin:E: "c1 "  E.ATd: "c1: var char " Ex: "c1 " rec: "c1 " 
 --  E.ATd: "c1: var char " E.ATd.desc: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "c1 " 
 -- doNeedOrigin:E: "c1 " 
 -- computeAdrX:superAdj: 0 "c1 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "c1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$24 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30 "on: 1 isValueObj: 
 --  false 
 --  origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- computeAdrX:isLast:E:  "c1 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 --  rec:  "c1 "E:  "c1 "
 -- INV:gen:E.loadArgs "c1 "
 -- INV:gen:after:E.loadArgs "c1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c1 "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var c1 
 -- DI:invoke: "c1: var char " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 isNotRemote: true 
 pushg 2 loop$14
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- NonVirt: "<> c2 " "ObjectInvocation_Binary " ActArg: "c2 "
 --  isValue: false formalArg: "in V: var char " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "<> c2 " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "c2 "
 -- INV:gen: "c2 " 
 -- needorigin: "c2 " 
 -- needOrigin:E: "c2 "  E.ATd: "c2: var char " Ex: "c2 " rec: "c2 " 
 --  E.ATd: "c2: var char " E.ATd.desc: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "c2 " 
 -- doNeedOrigin:E: "c2 " 
 -- computeAdrX:superAdj: 0 "c2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "c2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$24 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30 "on: 1 isValueObj: 
 --  false 
 --  origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- computeAdrX:isLast:E:  "c2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 --  rec:  "c2 "E:  "c2 "
 -- INV:gen:E.loadArgs "c2 "
 -- INV:gen:after:E.loadArgs "c2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c2 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var c2 
 -- DI:invoke: "c2: var char " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 isNotRemote: true 
 pushg 3 loop$14
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var char "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "c2 ":isBasicVal: true 
 -- case:B: c2 ObjectGenerator 3 0 3 false false 
 -- checkNumberConvert: "c2 " D: "in V: var char " 
 -- end:loadArgs:NonVirt: "<> c2 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:after:E.loadArgs "c1 <> c2 "
 --  OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "c1 <> c2 "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- BinaryExp:invoke: "c1 "rec: "c1 <> c2 "
 -- M: "<> c2 "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:before:ATdx.invoke: pattern <>   
 -- ptn:invoke: "<>   "E: "<> c2 "ptnKind: 0 useRtnV: true 
 ne
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<> c2":rec:c1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<> c2":rec:c1 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  26   "$26 "
 invoke $26 26 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $26 26 1 repeat$24 24
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "Beq := false " 
 pushThis 
 -- items:goOrigin:encOG: "$26 "on: 4 isValueObj: false 
 --  origin: repeat$24 origin:isValueObj: false 
 rpushg $26$26 1
 -- items:goOrigin:encOG: "repeat$24 "on: 3 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30 "on: 2 isValueObj: 
 --  false 
 --  origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- AssignmentStatement:gen: 
 --  "Beq := false " right.label: "ObjectGenerator ""false " 
 -- OG:before:super.gen: "false "
 -- INV:gen: "false " 
 -- needorigin: "false " 
 -- needOrigin:E: "false "  E.ATd: 
 --  False: 
 --     %globals
 --     out B: var boolean
 --     B := 0
 --  Ex: "false " rec: "false " E.ATd: 
 --  False: 
 --     %globals
 --     out B: var boolean
 --     B := 0
 --  E.ATd.desc: 
 --  %globals
 --  out B: var boolean
 --  B := 0
 --  E.ATd.IT: 
 --  %globals
 --  out B: var boolean
 --  B := 0
 -- \
 --   
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %globals
 --     out B: var boolean
 --     B := 0
 --  
 -- after:needOrigin: "false " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "false "E:  "false "
 -- INV:gen:E.loadArgs "false "
 -- INV:gen:after:E.loadArgs "false "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "false "
 -- OI:invoke:before:ATdx.invoke: pattern False 
 -- ptn:invoke: "False "E: "false "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "false " 
 --  adr:none 
 invoke False 27 0 0
 -- global:pushOut: B off: 1 
 pushg 1 
 -- callInvoke:after:pushOut: 1 
 -- GeneralPTN:invoke:after:callInvoke: 1 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- checkNumberConvert: "false " D: "out Beq: var boolean " 
 -- assign:adr.store:A: 
 storeg =$13 3
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "leave(loop) "
 -- INV:gen: "leave(loop) " 
 -- needorigin: "leave(loop) " 
 -- needOrigin:E: "leave(loop) "  E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  Ex: "leave(loop) " rec: "leave(loop) " E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  E.ATd.desc: "%basic 103 " E.ATd.IT: "%basic 103 " 
 -- doNeedOrigin:Ex: "leave(loop) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "leave(loop) " 
 -- doNeedOrigin:E: "leave(loop) " 
 -- computeAdrX:superAdj: 0 "leave(loop) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "leave(loop) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "leave(loop) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:- 
 --  rec:  "leave(loop) "E:  "leave(loop) "
 -- INV:gen:E.loadArgs "leave(loop) "
 -- INV:gen:after:E.loadArgs "leave(loop) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  leave(loop) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- ptn:invoke: "leave(V: var integer) "E: "leave(loop) "ptnKind: 0 
 --  useRtnV: false 
 break  3 2 14 0
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS False 27 0 BETA 2
 allocEventQ
 mvStack 
 -- DI:gen: "out B: var boolean " DI:isConst: false isBasicValue: 
 --  true primNo: 4 
 -- DI:gen:primitiveType: B 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "B := 0 " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "B := 0 " right.label: "ObjectGenerator ""0 " 
 -- OG:before:super.gen: "0 "
 -- INV:gen: "0 " 
 -- needorigin: "0 " 
 -- needOrigin:E: "0 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "0 " rec: "0 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "0 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "0 "E:  "0 "
 -- INV:gen:E.loadArgs "0 "
 -- INV:gen:after:E.loadArgs "0 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0 "
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- checkNumberConvert: "0 " D: "out B: var boolean " 
 -- assign:adr.store:A: 
 storeg False$27 1
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS for:to:repeat$30 30 4 loop 14
 -- vdtTableCopy: I:1:28 V:2:29
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- NonVirt: 
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then "ObjectInvocation_KeyWord " ActArg: "1 "isValue: true formalArg: "
 --  first: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --        Beq := false
 --        leave(loop)
 --   " isCompositeValueObj: false 
 -- OG:before:super.gen: "1 "
 -- INV:gen: "1 " 
 -- needorigin: "1 " 
 -- needOrigin:E: "1 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "1 " rec: "1 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "1 " 
 -- IV:after:computeAdr:superAdj: 4 
 --  rec:  "1 "E:  "1 "
 -- INV:gen:E.loadArgs "1 "
 -- INV:gen:after:E.loadArgs "1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1 "
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "first: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- checkNumberConvert: "1 " D: "first: var integer " 
 -- end:loadArgs:NonVirt: "
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --        Beq := false
 --        leave(loop)
 --   "
 -- NonVirt: 
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then "ObjectInvocation_KeyWord " ActArg: "length "isValue: false 
 --  formalArg: "last: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --        Beq := false
 --        leave(loop)
 --   " isCompositeValueObj: false 
 -- OG:before:super.gen: "length "
 -- INV:gen: "length " 
 -- needorigin: "length " 
 -- needOrigin:E: "length "  E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  Ex: "length " rec: "length " E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  E.ATd.desc: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  E.ATd.IT: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- doNeedOrigin:Ex: "length "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "length " 
 -- doNeedOrigin:E: "length " 
 -- computeAdrX:superAdj: 4 "length " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "length " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 rpushg loop$14 4
 -- items:goOrigin:encOG: "loop "on: 2 isValueObj: false 
 --  origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- items:goOrigin:encOG: "= "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg =$13 1
 -- computeAdrX:isLast:E:  "length "
 -- IV:after:computeAdr:superAdj: 4 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 --  rec:  "length "E:  "length "
 -- INV:gen:E.loadArgs "length "
 -- INV:gen:after:E.loadArgs "length "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- ptn:invoke: "length "E: "length "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "length " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- actualArg:isPtn: true formalArg:isPtn: "last: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "length ":isBasicVal: true 
 -- case:B: length ObjectGenerator 1 0 0 false false 
 -- checkNumberConvert: "length " D: "last: var integer " 
 -- end:loadArgs:NonVirt: "
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --        Beq := false
 --        leave(loop)
 --   "
 pushThis 
 storeg integer$5 2
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- DI:gen: "inx: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: inx 
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0

 CLASS <= 44 1 Value 4
 jmpFalse  L3
 pushThis 
 -- vassign:B: Veq off: 4 size: 2 mode: 0 
 vassign  4 2 0
 jmp L4
 L3:
 invokeVal  Veq 31 3
 rpop 
 L4:
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in Veq: var this(Value) " DI:isConst: false 
 --  isBasicValue: false primNo: 18 
 -- DI:isConst: Veq 
 -- inArg: in Veq: var this(Value) 
 -- DI:gen: "out Beq: var boolean " DI:isConst: false isBasicValue: 
 --  true primNo: 4 
 -- DI:gen:primitiveType: Beq 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0

 CLASS <= 49 1 String 10
 -- vdtTableCopy: I:1:44
 rShiftUp  1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- super <=
 pushThis 
 rpushg iOrigin 1
 rShiftDown  1
 pushThis 
 rstoreg  Veq 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in Veq: var this(Value) " DI:isConst: false 
 --  isBasicValue: false primNo: 18 
 -- DI:isConst: Veq 
 -- inArg: in Veq: var this(Value) 
 -- DI:gen: "out Beq: var boolean " DI:isConst: false isBasicValue: 
 --  true primNo: 4 
 -- DI:gen:primitiveType: Beq 
 -- DI:gen: 
 --  loop: obj 
 --     -- "Hello"  <= "World" since H <= W
 --     -- "Qweabc" <= "Qwevwxy" since a <= e
 --     -- "Qweayc" <= "Qwexby"DI:isConst: true isBasicValue: false primNo: 0 
 -- DI:isConst: loop 
 -- DI:off: 4 this: 
 --  loop: obj 
 --     -- "Hello"  <= "World" since H <= W
 --     -- "Qweabc" <= "Qwevwxy" since a <= e
 --     -- "Qweayc" <= "Qwexby"
 --  
 pushThis 
 -- before objTmpStack:add:  50   "loop "
 invoke loop 50 4 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS loop 50 1 <= 49
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "L: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: L 
 -- DI:gen: "L1: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: L1 
 -- DI:gen: "L2: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: L2 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: 
 --  L1 := length
 --  -- min length of this and V
 --  
 pushThis 
 -- AssignmentStatement:gen: 
 --  
 --  L1 := length
 --  -- min length of this and V
 --  right.label: "ObjectGenerator "
 --  length
 --  -- min length of this and V
 --  
 -- OG:before:super.gen: "length
 --  -- min length of this and V "
 -- INV:gen: 
 --  length
 --  -- min length of this and V
 --  
 -- needorigin: 
 --  length
 --  -- min length of this and V
 --  
 -- needOrigin:E: 
 --  length
 --  -- min length of this and V
 --   E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  Ex: 
 --  length
 --  -- min length of this and V
 --  rec: 
 --  length
 --  -- min length of this and V
 --  E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  E.ATd.desc: 
 -- \
 --   out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  E.ATd.IT: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- doNeedOrigin:Ex: "length
 --  -- min length of this and V "
 --  originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: 
 --  length
 --  -- min length of this and V
 --  
 -- doNeedOrigin:E: 
 --  length
 --  -- min length of this and V
 --  
 -- computeAdrX:superAdj: 0 
 --  length
 --  -- min length of this and V
 --  
 -- computeAdrX:En: 1 pRec: none rec: none E: 
 --  length
 --  -- min length of this and V
 --  
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 2 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$50 1
 -- items:goOrigin:encOG: "<= "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg <=$49 1
 -- computeAdrX:isLast:E:  "length
 --  -- min length of this and V "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length
 --  -- min length of this and V":rec:- 
 --  rec:  "length
 --  -- min length of this and V "E:  "
 --  length
 --  -- min length of this and V "
 -- INV:gen:E.loadArgs "length
 --  -- min length of this and V "
 -- INV:gen:after:E.loadArgs "length
 --  -- min length of this and V "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "
 --  length
 --  -- min length of this and V "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length
 --  -- min length of this and V":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- ptn:invoke: "length "E: "length
 --  -- min length of this and V "
 --  ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: 
 --  length
 --  -- min length of this and V
 --  
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length
 --  -- min length of this and V":rec:length
 --  -- min length of this and V 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length
 --  -- min length of this and V":rec:length
 --  -- min length of this and V 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length
 --  -- min length of this and V":rec:length
 --  -- min length of this and V 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length
 --  -- min length of this and V":rec:length
 --  -- min length of this and V 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length
 --  -- min length of this and V":rec:length
 --  -- min length of this and V 
 -- checkNumberConvert: 
 --  length
 --  -- min length of this and V
 --  D: "L1: var integer " 
 -- assign:adr.store:A: 
 storeg loop$50 3
 -- assign:adr.store:B: 
 -- AssignmentStatement:gen: "L2 := Veq.length " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "L2 := Veq.length " right.label: "ObjectGenerator ""Veq.length " 
 -- OG:before:super.gen: "Veq.length "
 -- INV:gen: "Veq.length " 
 -- needorigin: "Veq.length " 
 -- needOrigin:E: "length "  E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  Ex: "length " rec: "Veq " E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  E.ATd.desc: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  E.ATd.IT: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- doNeedOrigin:Ex: "length "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "length " 
 -- doNeedOrigin:E: "length " 
 -- computeAdrX:superAdj: 0 "Veq.length " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Veq " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$50 1
 -- computeAdrX:En: 2 pRec: "Veq " rec: "Veq " E: "length " 
 --  A.E: none 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "Veq " rec: "Veq " E: "length " 
 --  rec.ATd: "in Veq: var this(Value) " rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 --  recA: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 --  pRecA: none 
 -- pRec: "Veq " rec: "Veq " E: "length " 
 --  false true 
 -- computeAdrX:before:rec:: "Veq " 
 -- OI:invoke:before:ATdx.invoke: var Veq 
 -- DI:invoke: "in Veq: var this(Value) " 
 -- isValueObj:isAdr: true objSize: 2  rec "Veq ",E: "length ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- Address:loadAdr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 rpushg loop$50 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- computeAdrX:after:rec.invoke: "Veq " 
 -- computeAdrX:isLast:E:  "length "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 --  rec:  "Veq "E:  "length "
 -- INV:gen:E.loadArgs "length "
 -- INV:gen:after:E.loadArgs "length "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- ptn:invoke: "length "E: "length "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "Veq " 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- checkNumberConvert: "Veq.length " D: "L2: var integer " 
 -- assign:adr.store:A: 
 storeg loop$50 4
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2 "
 -- INV:gen: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  
 -- needorigin: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  
 -- needOrigin:E: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  rec: 
 --  if (L1 < L2) :then 
 --     L := L1
 -- \
 --   :else 
 --     L := L2
 --  E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  E.ATd.desc: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  E.ATd.IT: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2 "E:  "
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2 "
 -- INV:gen:E.loadArgs "
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2 "
 -- INV:gen:after:E.loadArgs "
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThenElse "
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2 "
 -- OG:before:super.gen: "(L1 < L2) "
 -- INV:gen: "(L1 < L2) " 
 -- needorigin: "(L1 < L2) " 
 -- needOrigin:E: "(L1 < L2) "  E.ATd: 
 --  <  : 
 --     %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  Ex: "(L1 < L2) " rec: "(L1 < L2) " E.ATd: 
 --  <  : 
 --     %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  E.ATd.desc: 
 --  %basic 51
 --  in V: var integer
 --  out B: var boolean
 --  E.ATd.IT: 
 --  %basic 51
 --  in V: var integer
 --  out B: var boolean
 -- \
 --   
 -- doNeedOrigin:Ex: "(L1 < L2) "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(L1 < L2) " 
 -- doNeedOrigin:E: "(L1 < L2) " 
 -- computeAdrX:superAdj: 0 "(L1 < L2) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(L1 < L2) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "L1 < L2 "superAdj: 0 
 -- BE:loadOrigin:E: L1 < L2 
 -- computeAdrX:isLast:E:  "L1 < L2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "L1 < L2 "E:  "L1 < L2 "
 -- INV:gen:E.loadArgs "L1 < L2 "
 -- BinaryExp:loadArgs: "L1 < L2 " superAdj: 0 
 -- INV:gen: "L1 " 
 -- needorigin: "L1 " 
 -- needOrigin:E: "L1 "  E.ATd: "L1: var integer " Ex: "L1 " rec: "
 --  L1 " E.ATd: "L1: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L1 " 
 -- doNeedOrigin:E: "L1 " 
 -- computeAdrX:superAdj: 0 "L1 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "L1 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 --  rec:  "L1 "E:  "L1 "
 -- INV:gen:E.loadArgs "L1 "
 -- INV:gen:after:E.loadArgs "L1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L1 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- DI:invoke: "L1: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 isNotRemote: true 
 pushg 3 loop$50
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- NonVirt: "< L2 " "ObjectInvocation_Binary " ActArg: "L2 "
 --  isValue: false formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "< L2 " isCompositeValueObj: false 
 -- OG:before:super.gen: "L2 "
 -- INV:gen: "L2 " 
 -- needorigin: "L2 " 
 -- needOrigin:E: "L2 "  E.ATd: "L2: var integer " Ex: "L2 " rec: "
 --  L2 " E.ATd: "L2: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L2 " 
 -- doNeedOrigin:E: "L2 " 
 -- computeAdrX:superAdj: 0 "L2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "L2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 --  rec:  "L2 "E:  "L2 "
 -- INV:gen:E.loadArgs "L2 "
 -- INV:gen:after:E.loadArgs "L2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L2 "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- DI:invoke: "L2: var integer " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 isNotRemote: true 
 pushg 4 loop$50
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "L2 ":isBasicVal: true 
 -- case:B: L2 ObjectGenerator 1 0 1 false false 
 -- checkNumberConvert: "L2 " D: "in V: var integer " 
 -- end:loadArgs:NonVirt: "< L2 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:after:E.loadArgs "L1 < L2 "
 --  OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L1 < L2 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- BinaryExp:invoke: "L1 "rec: "L1 < L2 "
 -- M: "< L2 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:before:ATdx.invoke: pattern <   
 -- ptn:invoke: "<   "E: "< L2 "ptnKind: 0 useRtnV: true 
 lt
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< L2":rec:L1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< L2":rec:L1 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  52   "$52 "
 invoke $52 52 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L5
 L4:
 pushThis 
 -- before objTmpStack:add:  53   "$53 "
 invoke $53 53 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L5:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- OG:before:super.gen: "matchEq "
 -- INV:gen: "matchEq " 
 -- needorigin: "matchEq " 
 -- needOrigin:E: "matchEq "  E.ATd: 
 --  matchEq: 
 --     inx: var integer
 --     c1: var char
 --     c2: var charEx: "matchEq " rec: "matchEq " E.ATd: 
 --  matchEq: 
 --     inx: var integer
 --     c1: var char
 --     c2: var charE.ATd.desc: 
 --  inx: var integer
 --  c1: var char
 --  c2: var char
 --  isEmpty: do E.ATd.IT: 
 --  inx: var integer
 --  c1: var char
 --  c2: var char
 --  isEmpty: do 
 -- doNeedOrigin:Ex: "matchEq "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "matchEq " 
 -- doNeedOrigin:E: "matchEq " 
 -- computeAdrX:superAdj: 0 "matchEq " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "matchEq " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "matchEq "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:- 
 --  rec:  "matchEq "E:  "matchEq "
 -- INV:gen:E.loadArgs "matchEq "
 -- INV:gen:after:E.loadArgs "matchEq "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "matchEq "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern matchEq 
 -- ptn:invoke: "matchEq "E: "matchEq "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "matchEq " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:matchEq 
 invoke matchEq 54 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:matchEq 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:matchEq 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:matchEq 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS $52 52 1 loop 50
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "L := L1 " 
 pushThis 
 -- items:goOrigin:encOG: "$52 "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $52$52 1
 -- AssignmentStatement:gen: 
 --  "L := L1 " right.label: "ObjectGenerator ""L1 " 
 -- OG:before:super.gen: "L1 "
 -- INV:gen: "L1 " 
 -- needorigin: "L1 " 
 -- needOrigin:E: "L1 "  E.ATd: "L1: var integer " Ex: "L1 " rec: "
 --  L1 " E.ATd: "L1: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L1 " 
 -- doNeedOrigin:E: "L1 " 
 -- computeAdrX:superAdj: 0 "L1 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$52 "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $52$52 1
 -- computeAdrX:isLast:E:  "L1 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 --  rec:  "L1 "E:  "L1 "
 -- INV:gen:E.loadArgs "L1 "
 -- INV:gen:after:E.loadArgs "L1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L1 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- DI:invoke: "L1: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 isNotRemote: true 
 pushg 3 loop$50
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- checkNumberConvert: "L1 " D: "L: var integer " 
 -- assign:adr.store:A: 
 storeg loop$50 2
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $53 53 1 loop 50
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "L := L2 " 
 pushThis 
 -- items:goOrigin:encOG: "$53 "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $53$53 1
 -- AssignmentStatement:gen: 
 --  "L := L2 " right.label: "ObjectGenerator ""L2 " 
 -- OG:before:super.gen: "L2 "
 -- INV:gen: "L2 " 
 -- needorigin: "L2 " 
 -- needOrigin:E: "L2 "  E.ATd: "L2: var integer " Ex: "L2 " rec: "
 --  L2 " E.ATd: "L2: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L2 " 
 -- doNeedOrigin:E: "L2 " 
 -- computeAdrX:superAdj: 0 "L2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$53 "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $53$53 1
 -- computeAdrX:isLast:E:  "L2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 --  rec:  "L2 "E:  "L2 "
 -- INV:gen:E.loadArgs "L2 "
 -- INV:gen:after:E.loadArgs "L2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L2 "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- DI:invoke: "L2: var integer " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 isNotRemote: true 
 pushg 4 loop$50
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- checkNumberConvert: "L2 " D: "L: var integer " 
 -- assign:adr.store:A: 
 storeg loop$50 2
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS matchEq 54 1 loop 50
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "inx: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: inx 
 -- DI:gen: "c1: var char " DI:isConst: false isBasicValue: true 
 --  primNo: 3 
 -- DI:gen:primitiveType: c1 
 -- DI:gen: "c2: var char " DI:isConst: false isBasicValue: true 
 --  primNo: 3 
 -- DI:gen:primitiveType: c2 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 pushThis 
 -- before objTmpStack:add:  55   "isEmpty "
 invoke isEmpty 55 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  58   "loop "
 invoke loop 58 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  61   "doit "
 invoke doit 61 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS isEmpty 55 1 matchEq 54
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq) "
 -- INV:gen: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  
 -- needorigin: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  
 -- needOrigin:E: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  rec: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  E.ATd: 
 -- \
 --   if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  E.ATd.desc: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  E.ATd.IT: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq) "
 --  E:  "if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq) "
 -- INV:gen:E.loadArgs "
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq) "
 -- INV:gen:after:E.loadArgs "
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq) "
 -- OG:before:super.gen: "(L1 = 0) "
 -- INV:gen: "(L1 = 0) " 
 -- needorigin: "(L1 = 0) " 
 -- needOrigin:E: "(L1 = 0) "  E.ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var booleanEx: "(L1 = 0) " rec: "(L1 = 0) " E.ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var booleanE.ATd.desc: 
 --  %basic 50
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  inner(= )
 --  E.ATd.IT: 
 --  %basic 50
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  inner(= )
 -- \
 --   
 -- doNeedOrigin:Ex: "(L1 = 0) "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(L1 = 0) " 
 -- doNeedOrigin:E: "(L1 = 0) " 
 -- computeAdrX:superAdj: 0 "(L1 = 0) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(L1 = 0) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "L1 = 0 "superAdj: 0 
 -- BE:loadOrigin:E: L1 = 0 
 -- computeAdrX:isLast:E:  "L1 = 0 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "L1 = 0 "E:  "L1 = 0 "
 -- INV:gen:E.loadArgs "L1 = 0 "
 -- BinaryExp:loadArgs: "L1 = 0 " superAdj: 0 
 -- INV:gen: "L1 " 
 -- needorigin: "L1 " 
 -- needOrigin:E: "L1 "  E.ATd: "L1: var integer " Ex: "L1 " rec: "
 --  L1 " E.ATd: "L1: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L1 " 
 -- doNeedOrigin:E: "L1 " 
 -- computeAdrX:superAdj: 0 "L1 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "isEmpty "on: 2 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$55 1
 -- items:goOrigin:encOG: "matchEq "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$54 1
 -- computeAdrX:isLast:E:  "L1 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 --  rec:  "L1 "E:  "L1 "
 -- INV:gen:E.loadArgs "L1 "
 -- INV:gen:after:E.loadArgs "L1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L1 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- DI:invoke: "L1: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 isNotRemote: true 
 pushg 3 loop$50
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- NonVirt: "= 0 " "ObjectInvocation_Binary " ActArg: "0 "isValue: 
 --  true formalArg: "in Veq: var this(Value) " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "= 0 " isCompositeValueObj: true 
 -- OG:before:super.gen: "0 "
 -- INV:gen: "0 " 
 -- needorigin: "0 " 
 -- needOrigin:E: "0 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "0 " rec: "0 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "0 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "0 "E:  "0 "
 -- INV:gen:E.loadArgs "0 "
 -- INV:gen:after:E.loadArgs "0 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0 "
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- vEq: 
 -- end:loadArgs:NonVirt: "= 0 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:after:E.loadArgs "L1 = 0 "
 --  OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L1 = 0 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- BinaryExp:invoke: "L1 "rec: "L1 = 0 "
 -- M: "= 0 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:before:ATdx.invoke: pattern =   
 -- ptn:invoke: "=   "E: "= 0 "ptnKind: 1 useRtnV: true 
 -- E: "= 0 " rec: "L1 ""Invocation "OGx: "integer " 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- rec.ATd: "L1: var integer " 
 -- bobs: 1 OGx: "integer " 
 -- 
 eq
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= 0":rec:L1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= 0":rec:L1 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  56   "$56 "
 invoke $56 56 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- OG:before:super.gen: "
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq) "
 -- INV:gen: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  
 -- needorigin: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  
 -- needOrigin:E: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  rec: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  E.ATd: 
 -- \
 --   if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  E.ATd.desc: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  E.ATd.IT: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq) "E:  "
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq) "
 -- INV:gen:E.loadArgs "
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq) "
 -- INV:gen:after:E.loadArgs "
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq) "
 -- OG:before:super.gen: "(L2 = 0) "
 -- INV:gen: "(L2 = 0) " 
 -- needorigin: "(L2 = 0) " 
 -- needOrigin:E: "(L2 = 0) "  E.ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var booleanEx: "(L2 = 0) " rec: "(L2 = 0) " E.ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var booleanE.ATd.desc: 
 --  %basic 50
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  inner(= )
 --  E.ATd.IT: 
 --  %basic 50
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  inner(= )
 -- \
 --   
 -- doNeedOrigin:Ex: "(L2 = 0) "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(L2 = 0) " 
 -- doNeedOrigin:E: "(L2 = 0) " 
 -- computeAdrX:superAdj: 0 "(L2 = 0) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(L2 = 0) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "L2 = 0 "superAdj: 0 
 -- BE:loadOrigin:E: L2 = 0 
 -- computeAdrX:isLast:E:  "L2 = 0 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "L2 = 0 "E:  "L2 = 0 "
 -- INV:gen:E.loadArgs "L2 = 0 "
 -- BinaryExp:loadArgs: "L2 = 0 " superAdj: 0 
 -- INV:gen: "L2 " 
 -- needorigin: "L2 " 
 -- needOrigin:E: "L2 "  E.ATd: "L2: var integer " Ex: "L2 " rec: "
 --  L2 " E.ATd: "L2: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L2 " 
 -- doNeedOrigin:E: "L2 " 
 -- computeAdrX:superAdj: 0 "L2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "isEmpty "on: 2 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$55 1
 -- items:goOrigin:encOG: "matchEq "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$54 1
 -- computeAdrX:isLast:E:  "L2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 --  rec:  "L2 "E:  "L2 "
 -- INV:gen:E.loadArgs "L2 "
 -- INV:gen:after:E.loadArgs "L2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L2 "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- DI:invoke: "L2: var integer " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 isNotRemote: true 
 pushg 4 loop$50
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- INV:gen:end:off: 4 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- NonVirt: "= 0 " "ObjectInvocation_Binary " ActArg: "0 "isValue: 
 --  true formalArg: "in Veq: var this(Value) " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "= 0 " isCompositeValueObj: true 
 -- OG:before:super.gen: "0 "
 -- INV:gen: "0 " 
 -- needorigin: "0 " 
 -- needOrigin:E: "0 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "0 " rec: "0 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "0 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "0 "E:  "0 "
 -- INV:gen:E.loadArgs "0 "
 -- INV:gen:after:E.loadArgs "0 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0 "
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- vEq: 
 -- end:loadArgs:NonVirt: "= 0 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- INV:gen:after:E.loadArgs "L2 = 0 "
 --  OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L2 = 0 "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- BinaryExp:invoke: "L2 "rec: "L2 = 0 "
 -- M: "= 0 "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:before:ATdx.invoke: pattern =   
 -- ptn:invoke: "=   "E: "= 0 "ptnKind: 1 useRtnV: true 
 -- E: "= 0 " rec: "L2 ""Invocation "OGx: "integer " 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- rec.ATd: "L2: var integer " 
 -- bobs: 1 OGx: "integer " 
 -- 
 eq
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= 0":rec:L2 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= 0":rec:L2 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L7
 L6:
 pushThis 
 -- before objTmpStack:add:  57   "$57 "
 invoke $57 57 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L7:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $56 56 1 isEmpty 55
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "Beq := L1 <= L2 " 
 pushThis 
 -- items:goOrigin:encOG: "$56 "on: 4 isValueObj: false 
 --  origin: isEmpty origin:isValueObj: false 
 rpushg $56$56 1
 -- items:goOrigin:encOG: "isEmpty "on: 3 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$55 1
 -- items:goOrigin:encOG: "matchEq "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$54 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$50 1
 -- AssignmentStatement:gen: 
 --  "Beq := L1 <= L2 " right.label: "ObjectGenerator ""L1 <= L2 " 
 -- OG:before:super.gen: "L1 <= L2 "
 -- INV:gen: "L1 <= L2 " 
 -- needorigin: "L1 <= L2 " 
 -- needOrigin:E: "L1 <= L2 "  E.ATd: 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  Ex: "L1 <= L2 " rec: "L1 <= L2 " E.ATd: 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  E.ATd.desc: 
 --  %basic 52
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  E.ATd.IT: 
 --  %basic 52
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 -- \
 --   
 -- doNeedOrigin:Ex: "L1 <= L2 "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "L1 <= L2 " 
 -- doNeedOrigin:E: "L1 <= L2 " 
 -- computeAdrX:superAdj: 0 "L1 <= L2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L1 <= L2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "L1 <= L2 "superAdj: 0 
 -- computeAdrX:isLast:E:  "L1 <= L2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "L1 <= L2 "E:  "L1 <= L2 "
 -- INV:gen:E.loadArgs "L1 <= L2 "
 -- BinaryExp:loadArgs: "L1 <= L2 " superAdj: 0 
 -- INV:gen: "L1 " 
 -- needorigin: "L1 " 
 -- needOrigin:E: "L1 "  E.ATd: "L1: var integer " Ex: "L1 " rec: "
 --  L1 " E.ATd: "L1: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L1 " 
 -- doNeedOrigin:E: "L1 " 
 -- computeAdrX:superAdj: 0 "L1 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$56 "on: 3 isValueObj: false 
 --  origin: isEmpty origin:isValueObj: false 
 rpushg $56$56 1
 -- items:goOrigin:encOG: "isEmpty "on: 2 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$55 1
 -- items:goOrigin:encOG: "matchEq "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$54 1
 -- computeAdrX:isLast:E:  "L1 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 --  rec:  "L1 "E:  "L1 "
 -- INV:gen:E.loadArgs "L1 "
 -- INV:gen:after:E.loadArgs "L1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L1 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- DI:invoke: "L1: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 isNotRemote: true 
 pushg 3 loop$50
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- NonVirt: "<= L2 " "ObjectInvocation_Binary " ActArg: "L2 "
 --  isValue: false formalArg: "in Veq: var this(Value) " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "<= L2 " isCompositeValueObj: true 
 -- OG:before:super.gen: "L2 "
 -- INV:gen: "L2 " 
 -- needorigin: "L2 " 
 -- needOrigin:E: "L2 "  E.ATd: "L2: var integer " Ex: "L2 " rec: "
 --  L2 " E.ATd: "L2: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L2 " 
 -- doNeedOrigin:E: "L2 " 
 -- computeAdrX:superAdj: 0 "L2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$56 "on: 3 isValueObj: false 
 --  origin: isEmpty origin:isValueObj: false 
 rpushg $56$56 1
 -- items:goOrigin:encOG: "isEmpty "on: 2 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$55 1
 -- items:goOrigin:encOG: "matchEq "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$54 1
 -- computeAdrX:isLast:E:  "L2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 --  rec:  "L2 "E:  "L2 "
 -- INV:gen:E.loadArgs "L2 "
 -- INV:gen:after:E.loadArgs "L2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L2 "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- DI:invoke: "L2: var integer " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 isNotRemote: true 
 pushg 4 loop$50
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- vEq: 
 -- end:loadArgs:NonVirt: "<= L2 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:after:E.loadArgs "L1 <= L2 "
 --  OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L1 <= L2 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- BinaryExp:invoke: "L1 "rec: "L1 <= L2 "
 -- M: "<= L2 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:before:ATdx.invoke: pattern <=   
 -- ptn:invoke: "<=   "E: "<= L2 "ptnKind: 1 useRtnV: true 
 -- E: "<= L2 " rec: "L1 ""Invocation "OGx: "integer " 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- rec.ATd: "L1: var integer " 
 -- bobs: 1 OGx: "integer " 
 -- 
 le
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<= L2":rec:L1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<= L2":rec:L1 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- checkNumberConvert: "L1 <= L2 " D: "out Beq: var boolean " 
 -- assign:adr.store:A: 
 storeg <=$49 3
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "leave(matchEq) "
 -- INV:gen: "leave(matchEq) " 
 -- needorigin: "leave(matchEq) " 
 -- needOrigin:E: "leave(matchEq) "  E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  Ex: "leave(matchEq) " rec: "leave(matchEq) " E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  E.ATd.desc: "%basic 103 " E.ATd.IT: "%basic 103 " 
 -- doNeedOrigin:Ex: "leave(matchEq) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "leave(matchEq) " 
 -- doNeedOrigin:E: "leave(matchEq) " 
 -- computeAdrX:superAdj: 0 "leave(matchEq) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "leave(matchEq) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "leave(matchEq) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 --  rec:  "leave(matchEq) "E:  "leave(matchEq) "
 -- INV:gen:E.loadArgs "leave(matchEq) "
 -- INV:gen:after:E.loadArgs "leave(matchEq) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  leave(matchEq) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- ptn:invoke: "leave(V: var integer) "E: "leave(matchEq) "ptnKind: 0 
 --  useRtnV: false 
 break  2 2 54 0
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $57 57 1 isEmpty 55
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "Beq := false " 
 pushThis 
 -- items:goOrigin:encOG: "$57 "on: 4 isValueObj: false 
 --  origin: isEmpty origin:isValueObj: false 
 rpushg $57$57 1
 -- items:goOrigin:encOG: "isEmpty "on: 3 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$55 1
 -- items:goOrigin:encOG: "matchEq "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$54 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$50 1
 -- AssignmentStatement:gen: 
 --  "Beq := false " right.label: "ObjectGenerator ""false " 
 -- OG:before:super.gen: "false "
 -- INV:gen: "false " 
 -- needorigin: "false " 
 -- needOrigin:E: "false "  E.ATd: 
 --  False: 
 --     %globals
 --     out B: var boolean
 --     B := 0
 --  Ex: "false " rec: "false " E.ATd: 
 --  False: 
 --     %globals
 --     out B: var boolean
 --     B := 0
 --  E.ATd.desc: 
 --  %globals
 --  out B: var boolean
 --  B := 0
 --  E.ATd.IT: 
 --  %globals
 --  out B: var boolean
 --  B := 0
 -- \
 --   
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %globals
 --     out B: var boolean
 --     B := 0
 --  
 -- after:needOrigin: "false " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "false "E:  "false "
 -- INV:gen:E.loadArgs "false "
 -- INV:gen:after:E.loadArgs "false "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "false "
 -- OI:invoke:before:ATdx.invoke: pattern False 
 -- ptn:invoke: "False "E: "false "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "false " 
 --  adr:none 
 invoke False 27 0 0
 -- global:pushOut: B off: 1 
 pushg 1 
 -- callInvoke:after:pushOut: 1 
 -- GeneralPTN:invoke:after:callInvoke: 1 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- checkNumberConvert: "false " D: "out Beq: var boolean " 
 -- assign:adr.store:A: 
 storeg <=$49 3
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "leave(matchEq) "
 -- INV:gen: "leave(matchEq) " 
 -- needorigin: "leave(matchEq) " 
 -- needOrigin:E: "leave(matchEq) "  E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  Ex: "leave(matchEq) " rec: "leave(matchEq) " E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  E.ATd.desc: "%basic 103 " E.ATd.IT: "%basic 103 " 
 -- doNeedOrigin:Ex: "leave(matchEq) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "leave(matchEq) " 
 -- doNeedOrigin:E: "leave(matchEq) " 
 -- computeAdrX:superAdj: 0 "leave(matchEq) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "leave(matchEq) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "leave(matchEq) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 --  rec:  "leave(matchEq) "E:  "leave(matchEq) "
 -- INV:gen:E.loadArgs "leave(matchEq) "
 -- INV:gen:after:E.loadArgs "leave(matchEq) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  leave(matchEq) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- ptn:invoke: "leave(V: var integer) "E: "leave(matchEq) "ptnKind: 0 
 --  useRtnV: false 
 break  2 2 54 0
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS loop 58 1 matchEq 54
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "inx := inx + 1 " 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$58 1
 -- AssignmentStatement:gen: 
 --  "inx := inx + 1 " right.label: "ObjectGenerator ""inx + 1 " 
 -- OG:before:super.gen: "inx + 1 "
 -- INV:gen: "inx + 1 " 
 -- needorigin: "inx + 1 " 
 -- needOrigin:E: "inx + 1 "  E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  Ex: "inx + 1 " rec: "inx + 1 " E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  E.ATd.desc: 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 --  E.ATd.IT: 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 -- \
 --   
 -- doNeedOrigin:Ex: "inx + 1 "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inx + 1 " 
 -- doNeedOrigin:E: "inx + 1 " 
 -- computeAdrX:superAdj: 0 "inx + 1 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx + 1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "inx + 1 "superAdj: 0 
 -- computeAdrX:isLast:E:  "inx + 1 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "inx + 1 "E:  "inx + 1 "
 -- INV:gen:E.loadArgs "inx + 1 "
 -- BinaryExp:loadArgs: "inx + 1 " superAdj: 0 
 -- INV:gen: "inx " 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$58 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 2 matchEq$54
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- NonVirt: "+ 1 " "ObjectInvocation_Binary " ActArg: "1 "isValue: 
 --  true formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ 1 " isCompositeValueObj: false 
 -- OG:before:super.gen: "1 "
 -- INV:gen: "1 " 
 -- needorigin: "1 " 
 -- needOrigin:E: "1 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "1 " rec: "1 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "1 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "1 "E:  "1 "
 -- INV:gen:E.loadArgs "1 "
 -- INV:gen:after:E.loadArgs "1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1 "
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- checkNumberConvert: "1 " D: "in V: var integer " 
 -- end:loadArgs:NonVirt: "+ 1 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:after:E.loadArgs "inx + 1 "
 --  OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- IV:E.invoke:useRtnVal: true E: BinOp "inx + 1 "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- BinaryExp:invoke: "inx "rec: "inx + 1 "
 -- M: "+ 1 "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- ptn:invoke: "+   "E: "+ 1 "ptnKind: 0 useRtnV: true 
 plus
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:inx 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- checkNumberConvert: "inx + 1 " D: "inx: var integer " 
 -- assign:adr.store:A: 
 storeg matchEq$54 2
 -- assign:adr.store:B: 
 -- AssignmentStatement:gen: "c1 := get[inx] " 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$58 1
 -- AssignmentStatement:gen: 
 --  "c1 := get[inx] " right.label: "ObjectGenerator ""get[inx] " 
 -- OG:before:super.gen: "get[inx] "
 -- INV:gen: "get[inx] " 
 -- needorigin: "get[inx] " 
 -- needOrigin:E: "get[inx] "  E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  Ex: "get[inx] " rec: "get[inx] " E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  E.ATd.desc: 
 --  %basic 117
 --  out ch: var char
 --  E.ATd.IT: 
 --  %basic 117
 --  out ch: var char
 --  
 -- doNeedOrigin:Ex: "get[inx] "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "get[inx] " 
 -- doNeedOrigin:E: "get[inx] " 
 -- computeAdrX:superAdj: 0 "get[inx] " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "get[inx] " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 4 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$58 1
 -- items:goOrigin:encOG: "matchEq "on: 3 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$54 1
 -- items:goOrigin:encOG: "loop "on: 2 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$50 1
 -- items:goOrigin:encOG: "<= "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg <=$49 1
 -- computeAdrX:isLast:E:  "get[inx] "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 --  rec:  "get[inx] "E:  "get[inx] "
 -- INV:gen:E.loadArgs "get[inx] "
 -- NonVirt: "get[inx] " "ObjectInvocation_KeyWord " ActArg: "inx "
 --  isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx] " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "inx "
 -- INV:gen: "inx " 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$58 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 2 matchEq$54
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- checkNumberConvert: "inx " D: "inx: var integer " 
 -- end:loadArgs:NonVirt: "get[inx] "
 -- INV:gen:after:E.loadArgs "get[inx] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx] "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- ptn:invoke: "get[inx: var integer] "E: "get[inx] "ptnKind: 0 
 --  useRtnV: true 
 xpushg  inx 1 0 1
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- checkNumberConvert: "get[inx] " D: "c1: var char " 
 -- assign:adr.store:A: 
 storeg matchEq$54 3
 -- assign:adr.store:B: 
 -- AssignmentStatement:gen: "c2 := Veq.get[inx] " 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$58 1
 -- AssignmentStatement:gen: 
 --  "c2 := Veq.get[inx] " right.label: "ObjectGenerator ""
 --  Veq.get[inx] " 
 -- OG:before:super.gen: "Veq.get[inx] "
 -- INV:gen: "Veq.get[inx] " 
 -- needorigin: "Veq.get[inx] " 
 -- needOrigin:E: "get[inx] "  E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  Ex: "get[inx] " rec: "Veq " E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  E.ATd.desc: 
 --  %basic 117
 --  out ch: var char
 --  E.ATd.IT: 
 --  %basic 117
 --  out ch: var char
 --  
 -- doNeedOrigin:Ex: "get[inx] "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "get[inx] " 
 -- doNeedOrigin:E: "get[inx] " 
 -- computeAdrX:superAdj: 0 "Veq.get[inx] " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Veq " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 3 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$58 1
 -- items:goOrigin:encOG: "matchEq "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$54 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$50 1
 -- computeAdrX:En: 2 pRec: "Veq " rec: "Veq " E: "get[inx] " 
 --  A.E: none 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "Veq " rec: "Veq " E: "get[inx] " 
 --  rec.ATd: "in Veq: var this(Value) " rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 --  recA: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 --  pRecA: none 
 -- pRec: "Veq " rec: "Veq " E: "get[inx] " 
 --  false true 
 -- computeAdrX:before:rec:: "Veq " 
 -- OI:invoke:before:ATdx.invoke: var Veq 
 -- DI:invoke: "in Veq: var this(Value) " 
 -- isValueObj:isAdr: true objSize: 2  rec "Veq ",E: "get[inx] ""
 --  ObjectInvocation_KeyWord "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- Address:loadAdr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 rpushg loop$58 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- computeAdrX:after:rec.invoke: "Veq " 
 -- computeAdrX:isLast:E:  "get[inx] "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 --  rec:  "Veq "E:  "get[inx] "
 -- INV:gen:E.loadArgs "get[inx] "
 -- NonVirt: "get[inx] " "ObjectInvocation_KeyWord " ActArg: "inx "
 --  isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx] " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "inx "
 -- INV:gen: "inx " 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$58 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 2 matchEq$54
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- checkNumberConvert: "inx " D: "inx: var integer " 
 -- end:loadArgs:NonVirt: "get[inx] "
 -- INV:gen:after:E.loadArgs "get[inx] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx] "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- ptn:invoke: "get[inx: var integer] "E: "get[inx] "ptnKind: 0 
 --  useRtnV: true 
 xpushg  inx 1 0 1
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- checkNumberConvert: "Veq.get[inx] " D: "c2: var char " 
 -- assign:adr.store:A: 
 storeg matchEq$54 4
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop) "
 -- INV:gen: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  
 -- needorigin: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  
 -- needOrigin:E: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  rec: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  E.ATd: 
 -- \
 --   if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  E.ATd.desc: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  E.ATd.IT: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop) "E:  "
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop) "
 -- INV:gen:E.loadArgs "
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop) "
 -- INV:gen:after:E.loadArgs "
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop) "
 -- OG:before:super.gen: "(c1 = c2) "
 -- INV:gen: "(c1 = c2) " 
 -- needorigin: "(c1 = c2) " 
 -- needOrigin:E: "(c1 = c2) "  E.ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var booleanEx: "(c1 = c2) " rec: "(c1 = c2) " E.ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var booleanE.ATd.desc: 
 --  %basic 50
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  inner(= )
 --  E.ATd.IT: 
 --  %basic 50
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  inner(= )
 -- \
 --   
 -- doNeedOrigin:Ex: "(c1 = c2) "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(c1 = c2) " 
 -- doNeedOrigin:E: "(c1 = c2) " 
 -- computeAdrX:superAdj: 0 "(c1 = c2) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(c1 = c2) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "c1 = c2 "superAdj: 0 
 -- BE:loadOrigin:E: c1 = c2 
 -- computeAdrX:isLast:E:  "c1 = c2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "c1 = c2 "E:  "c1 = c2 "
 -- INV:gen:E.loadArgs "c1 = c2 "
 -- BinaryExp:loadArgs: "c1 = c2 " superAdj: 0 
 -- INV:gen: "c1 " 
 -- needorigin: "c1 " 
 -- needOrigin:E: "c1 "  E.ATd: "c1: var char " Ex: "c1 " rec: "c1 " 
 --  E.ATd: "c1: var char " E.ATd.desc: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "c1 " 
 -- doNeedOrigin:E: "c1 " 
 -- computeAdrX:superAdj: 0 "c1 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "c1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$58 1
 -- computeAdrX:isLast:E:  "c1 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 --  rec:  "c1 "E:  "c1 "
 -- INV:gen:E.loadArgs "c1 "
 -- INV:gen:after:E.loadArgs "c1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c1 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var c1 
 -- DI:invoke: "c1: var char " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 isNotRemote: true 
 pushg 3 matchEq$54
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- NonVirt: "= c2 " "ObjectInvocation_Binary " ActArg: "c2 "
 --  isValue: false formalArg: "in Veq: var this(Value) " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "= c2 " isCompositeValueObj: true 
 -- OG:before:super.gen: "c2 "
 -- INV:gen: "c2 " 
 -- needorigin: "c2 " 
 -- needOrigin:E: "c2 "  E.ATd: "c2: var char " Ex: "c2 " rec: "c2 " 
 --  E.ATd: "c2: var char " E.ATd.desc: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "c2 " 
 -- doNeedOrigin:E: "c2 " 
 -- computeAdrX:superAdj: 0 "c2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "c2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$58 1
 -- computeAdrX:isLast:E:  "c2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 --  rec:  "c2 "E:  "c2 "
 -- INV:gen:E.loadArgs "c2 "
 -- INV:gen:after:E.loadArgs "c2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c2 "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var c2 
 -- DI:invoke: "c2: var char " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 isNotRemote: true 
 pushg 4 matchEq$54
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- vEq: 
 -- end:loadArgs:NonVirt: "= c2 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:after:E.loadArgs "c1 = c2 "
 --  OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "c1 = c2 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- BinaryExp:invoke: "c1 "rec: "c1 = c2 "
 -- M: "= c2 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:before:ATdx.invoke: pattern =   
 -- ptn:invoke: "=   "E: "= c2 "ptnKind: 1 useRtnV: true 
 -- E: "= c2 " rec: "c1 ""Invocation "OGx: "char " 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- rec.ATd: "c1: var char " 
 -- bobs: 3 OGx: "char " 
 -- 
 eq
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= c2":rec:c1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= c2":rec:c1 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  59   "$59 "
 invoke $59 59 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $59 59 1 loop 58
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "if (inx < L) :then 
 --     restart(loop) "
 -- INV:gen: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  
 -- needorigin: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  
 -- needOrigin:E: 
 --  if (inx < L) :then 
 --     restart(loop)
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  rec: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 -- \
 --      %globals inSub
 --  E.ATd.desc: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  E.ATd.IT: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "if (inx < L) :then 
 --     restart(loop) "E:  "
 --  if (inx < L) :then 
 --     restart(loop) "
 -- INV:gen:E.loadArgs "if (inx < L) :then 
 --     restart(loop) "
 -- INV:gen:after:E.loadArgs "if (inx < L) :then 
 --     restart(loop) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "
 --  if (inx < L) :then 
 --     restart(loop) "
 -- OG:before:super.gen: "(inx < L) "
 -- INV:gen: "(inx < L) " 
 -- needorigin: "(inx < L) " 
 -- needOrigin:E: "(inx < L) "  E.ATd: 
 --  <  : 
 --     %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  Ex: "(inx < L) " rec: "(inx < L) " E.ATd: 
 --  <  : 
 --     %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  E.ATd.desc: 
 --  %basic 51
 --  in V: var integer
 --  out B: var boolean
 --  E.ATd.IT: 
 --  %basic 51
 --  in V: var integer
 --  out B: var boolean
 -- \
 --   
 -- doNeedOrigin:Ex: "(inx < L) "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(inx < L) " 
 -- doNeedOrigin:E: "(inx < L) " 
 -- computeAdrX:superAdj: 0 "(inx < L) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(inx < L) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "inx < L "superAdj: 0 
 -- BE:loadOrigin:E: inx < L 
 -- computeAdrX:isLast:E:  "inx < L "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "inx < L "E:  "inx < L "
 -- INV:gen:E.loadArgs "inx < L "
 -- BinaryExp:loadArgs: "inx < L " superAdj: 0 
 -- INV:gen: "inx " 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$59 "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $59$59 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$58 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 2 matchEq$54
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- NonVirt: "< L " "ObjectInvocation_Binary " ActArg: "L "isValue: 
 --  false formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "< L " isCompositeValueObj: false 
 -- OG:before:super.gen: "L "
 -- INV:gen: "L " 
 -- needorigin: "L " 
 -- needOrigin:E: "L "  E.ATd: "L: var integer " Ex: "L " rec: "L " 
 --  E.ATd: "L: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L " 
 -- doNeedOrigin:E: "L " 
 -- computeAdrX:superAdj: 0 "L " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$59 "on: 3 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $59$59 1
 -- items:goOrigin:encOG: "loop "on: 2 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$58 1
 -- items:goOrigin:encOG: "matchEq "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$54 1
 -- computeAdrX:isLast:E:  "L "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 --  rec:  "L "E:  "L "
 -- INV:gen:E.loadArgs "L "
 -- INV:gen:after:E.loadArgs "L "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- DI:invoke: "L: var integer " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L isNotRemote: true 
 pushg 2 loop$50
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "L ":isBasicVal: true 
 -- case:B: L ObjectGenerator 1 0 1 false false 
 -- checkNumberConvert: "L " D: "in V: var integer " 
 -- end:loadArgs:NonVirt: "< L "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:after:E.loadArgs "inx < L "
 --  OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- IV:E.invoke:useRtnVal: true E: BinOp "inx < L "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- BinaryExp:invoke: "inx "rec: "inx < L "
 -- M: "< L "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:before:ATdx.invoke: pattern <   
 -- ptn:invoke: "<   "E: "< L "ptnKind: 0 useRtnV: true 
 lt
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< L":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< L":rec:inx 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  60   "$60 "
 invoke $60 60 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $60 60 1 $59 59
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "restart(loop) "
 -- INV:gen: "restart(loop) " 
 -- needorigin: "restart(loop) " 
 -- needOrigin:E: "restart(loop) "  E.ATd: 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  Ex: "restart(loop) " rec: "restart(loop) " E.ATd: 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  E.ATd.desc: "%basic 102 " E.ATd.IT: "%basic 102 " 
 -- doNeedOrigin:Ex: "restart(loop) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "restart(loop) " 
 -- doNeedOrigin:E: "restart(loop) " 
 -- computeAdrX:superAdj: 0 "restart(loop) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "restart(loop) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "restart(loop) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:- 
 --  rec:  "restart(loop) "E:  "restart(loop) "
 -- INV:gen:E.loadArgs "restart(loop) "
 -- INV:gen:after:E.loadArgs "restart(loop) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  restart(loop) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern restart(V: var integer) 
 -- ptn:invoke: "restart(V: var integer) "E: "restart(loop) "
 --  ptnKind: 0 useRtnV: false 
 break  2 1 58 0
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS doit 61 1 matchEq 54
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 --     Beq := c1 < c2
 --     leave(matchEq) "
 -- INV:gen: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 -- needorigin: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 -- needOrigin:E: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else  E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else rec: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else E.ATd: 
 -- \
 --   if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  E.ATd.desc: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  E.ATd.IT: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 --     Beq := c1 < c2
 --     leave(matchEq) "E:  "
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 --     Beq := c1 < c2
 --     leave(matchEq) "
 -- INV:gen:E.loadArgs "
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 --     Beq := c1 < c2
 --     leave(matchEq) "
 -- INV:gen:after:E.loadArgs "
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 --     Beq := c1 < c2
 --     leave(matchEq) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThenElse "
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 --     Beq := c1 < c2
 --     leave(matchEq) "
 -- OG:before:super.gen: "(c1 = c2) "
 -- INV:gen: "(c1 = c2) " 
 -- needorigin: "(c1 = c2) " 
 -- needOrigin:E: "(c1 = c2) "  E.ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var booleanEx: "(c1 = c2) " rec: "(c1 = c2) " E.ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var booleanE.ATd.desc: 
 --  %basic 50
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  inner(= )
 --  E.ATd.IT: 
 --  %basic 50
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  inner(= )
 -- \
 --   
 -- doNeedOrigin:Ex: "(c1 = c2) "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(c1 = c2) " 
 -- doNeedOrigin:E: "(c1 = c2) " 
 -- computeAdrX:superAdj: 0 "(c1 = c2) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(c1 = c2) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "c1 = c2 "superAdj: 0 
 -- BE:loadOrigin:E: c1 = c2 
 -- computeAdrX:isLast:E:  "c1 = c2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "c1 = c2 "E:  "c1 = c2 "
 -- INV:gen:E.loadArgs "c1 = c2 "
 -- BinaryExp:loadArgs: "c1 = c2 " superAdj: 0 
 -- INV:gen: "c1 " 
 -- needorigin: "c1 " 
 -- needOrigin:E: "c1 "  E.ATd: "c1: var char " Ex: "c1 " rec: "c1 " 
 --  E.ATd: "c1: var char " E.ATd.desc: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "c1 " 
 -- doNeedOrigin:E: "c1 " 
 -- computeAdrX:superAdj: 0 "c1 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "c1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "doit "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$61 1
 -- computeAdrX:isLast:E:  "c1 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 --  rec:  "c1 "E:  "c1 "
 -- INV:gen:E.loadArgs "c1 "
 -- INV:gen:after:E.loadArgs "c1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c1 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var c1 
 -- DI:invoke: "c1: var char " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 isNotRemote: true 
 pushg 3 matchEq$54
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- NonVirt: "= c2 " "ObjectInvocation_Binary " ActArg: "c2 "
 --  isValue: false formalArg: "in Veq: var this(Value) " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "= c2 " isCompositeValueObj: true 
 -- OG:before:super.gen: "c2 "
 -- INV:gen: "c2 " 
 -- needorigin: "c2 " 
 -- needOrigin:E: "c2 "  E.ATd: "c2: var char " Ex: "c2 " rec: "c2 " 
 --  E.ATd: "c2: var char " E.ATd.desc: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "c2 " 
 -- doNeedOrigin:E: "c2 " 
 -- computeAdrX:superAdj: 0 "c2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "c2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "doit "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$61 1
 -- computeAdrX:isLast:E:  "c2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 --  rec:  "c2 "E:  "c2 "
 -- INV:gen:E.loadArgs "c2 "
 -- INV:gen:after:E.loadArgs "c2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c2 "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var c2 
 -- DI:invoke: "c2: var char " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 isNotRemote: true 
 pushg 4 matchEq$54
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- vEq: 
 -- end:loadArgs:NonVirt: "= c2 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:after:E.loadArgs "c1 = c2 "
 --  OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "c1 = c2 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- BinaryExp:invoke: "c1 "rec: "c1 = c2 "
 -- M: "= c2 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:before:ATdx.invoke: pattern =   
 -- ptn:invoke: "=   "E: "= c2 "ptnKind: 1 useRtnV: true 
 -- E: "= c2 " rec: "c1 ""Invocation "OGx: "char " 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- rec.ATd: "c1: var char " 
 -- bobs: 3 OGx: "char " 
 -- 
 eq
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= c2":rec:c1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= c2":rec:c1 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  62   "$62 "
 invoke $62 62 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L5
 L4:
 pushThis 
 -- before objTmpStack:add:  63   "$63 "
 invoke $63 63 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L5:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $62 62 1 doit 61
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "Beq := L1 <= L2 " 
 pushThis 
 -- items:goOrigin:encOG: "$62 "on: 4 isValueObj: false 
 --  origin: doit origin:isValueObj: false 
 rpushg $62$62 1
 -- items:goOrigin:encOG: "doit "on: 3 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$61 1
 -- items:goOrigin:encOG: "matchEq "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$54 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$50 1
 -- AssignmentStatement:gen: 
 --  "Beq := L1 <= L2 " right.label: "ObjectGenerator ""L1 <= L2 " 
 -- OG:before:super.gen: "L1 <= L2 "
 -- INV:gen: "L1 <= L2 " 
 -- needorigin: "L1 <= L2 " 
 -- needOrigin:E: "L1 <= L2 "  E.ATd: 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  Ex: "L1 <= L2 " rec: "L1 <= L2 " E.ATd: 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  E.ATd.desc: 
 --  %basic 52
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  E.ATd.IT: 
 --  %basic 52
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 -- \
 --   
 -- doNeedOrigin:Ex: "L1 <= L2 "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "L1 <= L2 " 
 -- doNeedOrigin:E: "L1 <= L2 " 
 -- computeAdrX:superAdj: 0 "L1 <= L2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L1 <= L2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "L1 <= L2 "superAdj: 0 
 -- computeAdrX:isLast:E:  "L1 <= L2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "L1 <= L2 "E:  "L1 <= L2 "
 -- INV:gen:E.loadArgs "L1 <= L2 "
 -- BinaryExp:loadArgs: "L1 <= L2 " superAdj: 0 
 -- INV:gen: "L1 " 
 -- needorigin: "L1 " 
 -- needOrigin:E: "L1 "  E.ATd: "L1: var integer " Ex: "L1 " rec: "
 --  L1 " E.ATd: "L1: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L1 " 
 -- doNeedOrigin:E: "L1 " 
 -- computeAdrX:superAdj: 0 "L1 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$62 "on: 3 isValueObj: false 
 --  origin: doit origin:isValueObj: false 
 rpushg $62$62 1
 -- items:goOrigin:encOG: "doit "on: 2 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$61 1
 -- items:goOrigin:encOG: "matchEq "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$54 1
 -- computeAdrX:isLast:E:  "L1 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 --  rec:  "L1 "E:  "L1 "
 -- INV:gen:E.loadArgs "L1 "
 -- INV:gen:after:E.loadArgs "L1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L1 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- DI:invoke: "L1: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 isNotRemote: true 
 pushg 3 loop$50
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- NonVirt: "<= L2 " "ObjectInvocation_Binary " ActArg: "L2 "
 --  isValue: false formalArg: "in Veq: var this(Value) " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "<= L2 " isCompositeValueObj: true 
 -- OG:before:super.gen: "L2 "
 -- INV:gen: "L2 " 
 -- needorigin: "L2 " 
 -- needOrigin:E: "L2 "  E.ATd: "L2: var integer " Ex: "L2 " rec: "
 --  L2 " E.ATd: "L2: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L2 " 
 -- doNeedOrigin:E: "L2 " 
 -- computeAdrX:superAdj: 0 "L2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$62 "on: 3 isValueObj: false 
 --  origin: doit origin:isValueObj: false 
 rpushg $62$62 1
 -- items:goOrigin:encOG: "doit "on: 2 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$61 1
 -- items:goOrigin:encOG: "matchEq "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$54 1
 -- computeAdrX:isLast:E:  "L2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 --  rec:  "L2 "E:  "L2 "
 -- INV:gen:E.loadArgs "L2 "
 -- INV:gen:after:E.loadArgs "L2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L2 "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- DI:invoke: "L2: var integer " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 isNotRemote: true 
 pushg 4 loop$50
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- vEq: 
 -- end:loadArgs:NonVirt: "<= L2 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:after:E.loadArgs "L1 <= L2 "
 --  OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L1 <= L2 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- BinaryExp:invoke: "L1 "rec: "L1 <= L2 "
 -- M: "<= L2 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:before:ATdx.invoke: pattern <=   
 -- ptn:invoke: "<=   "E: "<= L2 "ptnKind: 1 useRtnV: true 
 -- E: "<= L2 " rec: "L1 ""Invocation "OGx: "integer " 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- rec.ATd: "L1: var integer " 
 -- bobs: 1 OGx: "integer " 
 -- 
 le
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<= L2":rec:L1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<= L2":rec:L1 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- checkNumberConvert: "L1 <= L2 " D: "out Beq: var boolean " 
 -- assign:adr.store:A: 
 storeg <=$49 3
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "leave(matchEq) "
 -- INV:gen: "leave(matchEq) " 
 -- needorigin: "leave(matchEq) " 
 -- needOrigin:E: "leave(matchEq) "  E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  Ex: "leave(matchEq) " rec: "leave(matchEq) " E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  E.ATd.desc: "%basic 103 " E.ATd.IT: "%basic 103 " 
 -- doNeedOrigin:Ex: "leave(matchEq) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "leave(matchEq) " 
 -- doNeedOrigin:E: "leave(matchEq) " 
 -- computeAdrX:superAdj: 0 "leave(matchEq) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "leave(matchEq) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "leave(matchEq) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 --  rec:  "leave(matchEq) "E:  "leave(matchEq) "
 -- INV:gen:E.loadArgs "leave(matchEq) "
 -- INV:gen:after:E.loadArgs "leave(matchEq) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  leave(matchEq) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- ptn:invoke: "leave(V: var integer) "E: "leave(matchEq) "ptnKind: 0 
 --  useRtnV: false 
 break  2 2 54 0
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $63 63 1 doit 61
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "Beq := c1 < c2 " 
 pushThis 
 -- items:goOrigin:encOG: "$63 "on: 4 isValueObj: false 
 --  origin: doit origin:isValueObj: false 
 rpushg $63$63 1
 -- items:goOrigin:encOG: "doit "on: 3 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$61 1
 -- items:goOrigin:encOG: "matchEq "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$54 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$50 1
 -- AssignmentStatement:gen: 
 --  "Beq := c1 < c2 " right.label: "ObjectGenerator ""c1 < c2 " 
 -- OG:before:super.gen: "c1 < c2 "
 -- INV:gen: "c1 < c2 " 
 -- needorigin: "c1 < c2 " 
 -- needOrigin:E: "c1 < c2 "  E.ATd: 
 --  <  : 
 --     %basic 51
 --     in V: var char
 --     out B: var boolean
 --  Ex: "c1 < c2 " rec: "c1 < c2 " E.ATd: 
 --  <  : 
 --     %basic 51
 --     in V: var char
 --     out B: var boolean
 --  E.ATd.desc: 
 --  %basic 51
 --  in V: var char
 --  out B: var boolean
 --  E.ATd.IT: 
 --  %basic 51
 --  in V: var char
 --  out B: var boolean
 -- \
 --   
 -- doNeedOrigin:Ex: "c1 < c2 "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "c1 < c2 " 
 -- doNeedOrigin:E: "c1 < c2 " 
 -- computeAdrX:superAdj: 0 "c1 < c2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "c1 < c2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "c1 < c2 "superAdj: 0 
 -- computeAdrX:isLast:E:  "c1 < c2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "c1 < c2 "E:  "c1 < c2 "
 -- INV:gen:E.loadArgs "c1 < c2 "
 -- BinaryExp:loadArgs: "c1 < c2 " superAdj: 0 
 -- INV:gen: "c1 " 
 -- needorigin: "c1 " 
 -- needOrigin:E: "c1 "  E.ATd: "c1: var char " Ex: "c1 " rec: "c1 " 
 --  E.ATd: "c1: var char " E.ATd.desc: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "c1 " 
 -- doNeedOrigin:E: "c1 " 
 -- computeAdrX:superAdj: 0 "c1 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "c1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$63 "on: 2 isValueObj: false 
 --  origin: doit origin:isValueObj: false 
 rpushg $63$63 1
 -- items:goOrigin:encOG: "doit "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$61 1
 -- computeAdrX:isLast:E:  "c1 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 --  rec:  "c1 "E:  "c1 "
 -- INV:gen:E.loadArgs "c1 "
 -- INV:gen:after:E.loadArgs "c1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c1 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var c1 
 -- DI:invoke: "c1: var char " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 isNotRemote: true 
 pushg 3 matchEq$54
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- NonVirt: "< c2 " "ObjectInvocation_Binary " ActArg: "c2 "
 --  isValue: false formalArg: "in V: var char " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "< c2 " isCompositeValueObj: false 
 -- OG:before:super.gen: "c2 "
 -- INV:gen: "c2 " 
 -- needorigin: "c2 " 
 -- needOrigin:E: "c2 "  E.ATd: "c2: var char " Ex: "c2 " rec: "c2 " 
 --  E.ATd: "c2: var char " E.ATd.desc: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "c2 " 
 -- doNeedOrigin:E: "c2 " 
 -- computeAdrX:superAdj: 0 "c2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "c2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$63 "on: 2 isValueObj: false 
 --  origin: doit origin:isValueObj: false 
 rpushg $63$63 1
 -- items:goOrigin:encOG: "doit "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$61 1
 -- computeAdrX:isLast:E:  "c2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 --  rec:  "c2 "E:  "c2 "
 -- INV:gen:E.loadArgs "c2 "
 -- INV:gen:after:E.loadArgs "c2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c2 "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var c2 
 -- DI:invoke: "c2: var char " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 isNotRemote: true 
 pushg 4 matchEq$54
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var char "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "c2 ":isBasicVal: true 
 -- case:B: c2 ObjectGenerator 3 0 3 false false 
 -- checkNumberConvert: "c2 " D: "in V: var char " 
 -- end:loadArgs:NonVirt: "< c2 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:after:E.loadArgs "c1 < c2 "
 --  OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "c1 < c2 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- BinaryExp:invoke: "c1 "rec: "c1 < c2 "
 -- M: "< c2 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:before:ATdx.invoke: pattern <   
 -- ptn:invoke: "<   "E: "< c2 "ptnKind: 0 useRtnV: true 
 lt
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< c2":rec:c1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< c2":rec:c1 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- checkNumberConvert: "c1 < c2 " D: "out Beq: var boolean " 
 -- assign:adr.store:A: 
 storeg <=$49 3
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "leave(matchEq) "
 -- INV:gen: "leave(matchEq) " 
 -- needorigin: "leave(matchEq) " 
 -- needOrigin:E: "leave(matchEq) "  E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  Ex: "leave(matchEq) " rec: "leave(matchEq) " E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  E.ATd.desc: "%basic 103 " E.ATd.IT: "%basic 103 " 
 -- doNeedOrigin:Ex: "leave(matchEq) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "leave(matchEq) " 
 -- doNeedOrigin:E: "leave(matchEq) " 
 -- computeAdrX:superAdj: 0 "leave(matchEq) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "leave(matchEq) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "leave(matchEq) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 --  rec:  "leave(matchEq) "E:  "leave(matchEq) "
 -- INV:gen:E.loadArgs "leave(matchEq) "
 -- INV:gen:after:E.loadArgs "leave(matchEq) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  leave(matchEq) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- ptn:invoke: "leave(V: var integer) "E: "leave(matchEq) "ptnKind: 0 
 --  useRtnV: false 
 break  2 2 54 0
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS puttext 65 1 ConsoleIF 8
 pushThis 
 rstoreg  T 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(puttext) "
 -- INV:gen: "inner(puttext) " 
 -- needorigin: "inner(puttext) " 
 -- needOrigin:E: "inner(puttext) "  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(puttext) " rec: "inner(puttext) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  E.ATd.desc: 
 --  %basic 101
 --  in inner: ref Object
 --  E.ATd.IT: 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- doNeedOrigin:Ex: "inner(puttext) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inner(puttext) " 
 -- doNeedOrigin:E: "inner(puttext) " 
 -- computeAdrX:superAdj: 0 "inner(puttext) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(puttext) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(puttext) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:- 
 --  rec:  "inner(puttext) "E:  "inner(puttext) "
 -- INV:gen:E.loadArgs "inner(puttext) "
 -- INV:gen:after:E.loadArgs "inner(puttext) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  inner(puttext) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(puttext) "ptnKind: 0 useRtnV: 
 --  false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:inner(puttext) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:inner(puttext) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:inner(puttext) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS putint 66 1 ConsoleIF 8
 pushThis 
 storeg integer$5 2
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(putint) "
 -- INV:gen: "inner(putint) " 
 -- needorigin: "inner(putint) " 
 -- needOrigin:E: "inner(putint) "  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(putint) " rec: "inner(putint) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  E.ATd.desc: 
 --  %basic 101
 --  in inner: ref Object
 --  E.ATd.IT: 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- doNeedOrigin:Ex: "inner(putint) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inner(putint) " 
 -- doNeedOrigin:E: "inner(putint) " 
 -- computeAdrX:superAdj: 0 "inner(putint) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(putint) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(putint) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:- 
 --  rec:  "inner(putint) "E:  "inner(putint) "
 -- INV:gen:E.loadArgs "inner(putint) "
 -- INV:gen:after:E.loadArgs "inner(putint) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  inner(putint) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(putint) "ptnKind: 0 useRtnV: 
 --  false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:inner(putint) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:inner(putint) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:inner(putint) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS OOPM 67 1 BETAworld 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "dummy: var integer " DI:isConst: false isBasicValue: 
 --  true primNo: 1 
 -- DI:gen:primitiveType: dummy 
 -- DI:gen: 
 --  console: obj 
 --     readString: 
 --        ch: var Char
 --        i: var integerDI:isConst: true isBasicValue: false primNo: 0 
 -- DI:isConst: console 
 -- DI:off: 3 this: 
 --  console: obj 
 --     readString: 
 --        ch: var Char
 --        i: var integer
 --  
 pushThis 
 -- before objTmpStack:add:  68   "console "
 invoke console 68 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  69   "GrammarLib "
 invoke GrammarLib 69 4 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS console 68 1 OOPM 67
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS GrammarLib 69 1 OOPM 67
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 pushThis 
 -- before objTmpStack:add:  70   "demo "
 invoke demo 70 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS demo 70 1 GrammarLib 69
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 pushThis 
 -- before objTmpStack:add:  145   "gTst "
 invoke gTst 145 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS Grammar 71 1 GrammarLib 69
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "nonTerminals: obj Set(#Nonterminal) " DI:isConst: true 
 --  isBasicValue: false primNo: 0 
 -- DI:isConst: nonTerminals 
 -- DI:off: 2 this: "nonTerminals: obj Set(#Nonterminal) " 
 --  
 -- before objTmpStack:add:  85   "nonTerminals "
 invoke nonTerminals 85 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- DI:gen: "terminals: obj Set(#Terminal) " DI:isConst: true 
 --  isBasicValue: false primNo: 0 
 -- DI:isConst: terminals 
 -- DI:off: 3 this: "terminals: obj Set(#Terminal) " 
 --  
 -- before objTmpStack:add:  88   "terminals "
 invoke terminals 88 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- DI:gen: "rules: obj OrderedList(#Rule) " DI:isConst: true 
 --  isBasicValue: false primNo: 0 
 -- DI:isConst: rules 
 -- DI:off: 4 this: "rules: obj OrderedList(#Rule) " 
 --  
 -- before objTmpStack:add:  95   "rules "
 invoke rules 95 4 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- DI:gen: "start: ref Nonterminal " DI:isConst: false 
 --  isBasicValue: false primNo: 0 
 -- DI:gen: "noOfRules: var integer " DI:isConst: false 
 --  isBasicValue: true primNo: 1 
 -- DI:gen:primitiveType: noOfRules 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(Grammar) "
 -- INV:gen: "inner(Grammar) " 
 -- needorigin: "inner(Grammar) " 
 -- needOrigin:E: "inner(Grammar) "  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(Grammar) " rec: "inner(Grammar) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  E.ATd.desc: 
 --  %basic 101
 --  in inner: ref Object
 --  E.ATd.IT: 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- doNeedOrigin:Ex: "inner(Grammar) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inner(Grammar) " 
 -- doNeedOrigin:E: "inner(Grammar) " 
 -- computeAdrX:superAdj: 0 "inner(Grammar) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(Grammar) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(Grammar) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Grammar)":rec:- 
 --  rec:  "inner(Grammar) "E:  "inner(Grammar) "
 -- INV:gen:E.loadArgs "inner(Grammar) "
 -- INV:gen:after:E.loadArgs "inner(Grammar) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  inner(Grammar) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Grammar)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(Grammar) "ptnKind: 0 useRtnV: 
 --  false 
 pushThis 
 innerP  3
 rpopThisObj 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Grammar)":rec:inner(Grammar) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Grammar)":rec:inner(Grammar) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Grammar)":rec:inner(Grammar) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:6 isIndexed:0

 CLASS Collection 80 0 Collections 38
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(Collection) "
 -- INV:gen: "inner(Collection) " 
 -- needorigin: "inner(Collection) " 
 -- needOrigin:E: "inner(Collection) "  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(Collection) " rec: "inner(Collection) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  E.ATd.desc: 
 --  %basic 101
 --  in inner: ref Object
 --  E.ATd.IT: 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- doNeedOrigin:Ex: "inner(Collection) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inner(Collection) " 
 -- doNeedOrigin:E: "inner(Collection) " 
 -- computeAdrX:superAdj: 0 "inner(Collection) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(Collection) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(Collection) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Collection)":rec:- 
 --  rec:  "inner(Collection) "E:  "inner(Collection) "
 -- INV:gen:E.loadArgs "inner(Collection) "
 -- INV:gen:after:E.loadArgs "inner(Collection) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  inner(Collection) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Collection)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(Collection) "ptnKind: 0 useRtnV: 
 --  false 
 pushThis 
 innerP  9
 rpopThisObj 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Collection)":rec:inner(Collection) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Collection)":rec:inner(Collection) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Collection)":rec:inner(Collection) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:0 isIndexed:0

 CLASS insert 74 1 Collection 80
 pushThis 
 rstoreg  e 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in e: ref elm " DI:isConst: false isBasicValue: false 
 --  primNo: 0 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(insert) "
 -- INV:gen: "inner(insert) " 
 -- needorigin: "inner(insert) " 
 -- needOrigin:E: "inner(insert) "  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(insert) " rec: "inner(insert) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  E.ATd.desc: 
 --  %basic 101
 --  in inner: ref Object
 --  E.ATd.IT: 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- doNeedOrigin:Ex: "inner(insert) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inner(insert) " 
 -- doNeedOrigin:E: "inner(insert) " 
 -- computeAdrX:superAdj: 0 "inner(insert) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(insert) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(insert) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(insert)":rec:- 
 --  rec:  "inner(insert) "E:  "inner(insert) "
 -- INV:gen:E.loadArgs "inner(insert) "
 -- INV:gen:after:E.loadArgs "inner(insert) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  inner(insert) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(insert)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(insert) "ptnKind: 0 useRtnV: 
 --  false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(insert)":rec:inner(insert) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(insert)":rec:inner(insert) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(insert)":rec:inner(insert) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS has 96 1 Collection 80
 pushThis 
 rstoreg  E 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in E: ref elm " DI:isConst: false isBasicValue: false 
 --  primNo: 0 
 -- DI:gen: "out B: var boolean " DI:isConst: false isBasicValue: 
 --  true primNo: 4 
 -- DI:gen:primitiveType: B 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(has) "
 -- INV:gen: "inner(has) " 
 -- needorigin: "inner(has) " 
 -- needOrigin:E: "inner(has) "  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(has) " rec: "inner(has) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  E.ATd.desc: 
 --  %basic 101
 --  in inner: ref Object
 --  E.ATd.IT: 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- doNeedOrigin:Ex: "inner(has) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inner(has) " 
 -- doNeedOrigin:E: "inner(has) " 
 -- computeAdrX:superAdj: 0 "inner(has) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(has) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(has) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(has)":rec:- 
 --  rec:  "inner(has) "E:  "inner(has) "
 -- INV:gen:E.loadArgs "inner(has) "
 -- INV:gen:after:E.loadArgs "inner(has) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  inner(has) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(has)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(has) "ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(has)":rec:inner(has) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(has)":rec:inner(has) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(has)":rec:inner(has) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS remove 97 1 Collection 80
 pushThis 
 rstoreg  E 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in E: ref elm " DI:isConst: false isBasicValue: false 
 --  primNo: 0 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(remove) "
 -- INV:gen: "inner(remove) " 
 -- needorigin: "inner(remove) " 
 -- needOrigin:E: "inner(remove) "  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(remove) " rec: "inner(remove) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  E.ATd.desc: 
 --  %basic 101
 --  in inner: ref Object
 --  E.ATd.IT: 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- doNeedOrigin:Ex: "inner(remove) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inner(remove) " 
 -- doNeedOrigin:E: "inner(remove) " 
 -- computeAdrX:superAdj: 0 "inner(remove) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(remove) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(remove) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(remove)":rec:- 
 --  rec:  "inner(remove) "E:  "inner(remove) "
 -- INV:gen:E.loadArgs "inner(remove) "
 -- INV:gen:after:E.loadArgs "inner(remove) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  inner(remove) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(remove)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(remove) "ptnKind: 0 useRtnV: 
 --  false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(remove)":rec:inner(remove) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(remove)":rec:inner(remove) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(remove)":rec:inner(remove) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS isEmpty 98 1 Collection 80
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(isEmpty) "
 -- INV:gen: "inner(isEmpty) " 
 -- needorigin: "inner(isEmpty) " 
 -- needOrigin:E: "inner(isEmpty) "  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(isEmpty) " rec: "inner(isEmpty) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  E.ATd.desc: 
 --  %basic 101
 --  in inner: ref Object
 --  E.ATd.IT: 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- doNeedOrigin:Ex: "inner(isEmpty) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inner(isEmpty) " 
 -- doNeedOrigin:E: "inner(isEmpty) " 
 -- computeAdrX:superAdj: 0 "inner(isEmpty) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(isEmpty) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(isEmpty) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(isEmpty)":rec:- 
 --  rec:  "inner(isEmpty) "E:  "inner(isEmpty) "
 -- INV:gen:E.loadArgs "inner(isEmpty) "
 -- INV:gen:after:E.loadArgs "inner(isEmpty) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  inner(isEmpty) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(isEmpty)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(isEmpty) "ptnKind: 0 useRtnV: 
 --  false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(isEmpty)":rec:inner(isEmpty) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(isEmpty)":rec:inner(isEmpty) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(isEmpty)":rec:inner(isEmpty) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS size 99 1 Collection 80
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(size) "
 -- INV:gen: "inner(size) " 
 -- needorigin: "inner(size) " 
 -- needOrigin:E: "inner(size) "  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(size) " rec: "inner(size) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  E.ATd.desc: 
 --  %basic 101
 --  in inner: ref Object
 --  E.ATd.IT: 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- doNeedOrigin:Ex: "inner(size) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inner(size) " 
 -- doNeedOrigin:E: "inner(size) " 
 -- computeAdrX:superAdj: 0 "inner(size) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(size) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(size) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(size)":rec:- 
 --  rec:  "inner(size) "E:  "inner(size) "
 -- INV:gen:E.loadArgs "inner(size) "
 -- INV:gen:after:E.loadArgs "inner(size) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  inner(size) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(size)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(size) "ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(size)":rec:inner(size) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(size)":rec:inner(size) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(size)":rec:inner(size) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS clear 100 1 Collection 80
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(clear) "
 -- INV:gen: "inner(clear) " 
 -- needorigin: "inner(clear) " 
 -- needOrigin:E: "inner(clear) "  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(clear) " rec: "inner(clear) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  E.ATd.desc: 
 --  %basic 101
 --  in inner: ref Object
 --  E.ATd.IT: 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- doNeedOrigin:Ex: "inner(clear) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inner(clear) " 
 -- doNeedOrigin:E: "inner(clear) " 
 -- computeAdrX:superAdj: 0 "inner(clear) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(clear) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(clear) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(clear)":rec:- 
 --  rec:  "inner(clear) "E:  "inner(clear) "
 -- INV:gen:E.loadArgs "inner(clear) "
 -- INV:gen:after:E.loadArgs "inner(clear) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  inner(clear) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(clear)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(clear) "ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(clear)":rec:inner(clear) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(clear)":rec:inner(clear) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(clear)":rec:inner(clear) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS Set 83 0 SetLib 40
 -- vdtTableCopy: I:1:80 V:2:0 V:3:74 V:4:96 V:5:97 V:6:98 V:7:99 V:8:100 I:9:0
 -- super Collection
 allocEventQ
 -- DI:gen: "head: ref link " DI:isConst: false isBasicValue: false 
 --  primNo: 0 
 rtnAlloc 1
 toSuper 80
DO:
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(Set) "
 -- INV:gen: "inner(Set) " 
 -- needorigin: "inner(Set) " 
 -- needOrigin:E: "inner(Set) "  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(Set) " rec: "inner(Set) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  E.ATd.desc: 
 --  %basic 101
 --  in inner: ref Object
 --  E.ATd.IT: 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- doNeedOrigin:Ex: "inner(Set) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inner(Set) " 
 -- doNeedOrigin:E: "inner(Set) " 
 -- computeAdrX:superAdj: 0 "inner(Set) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(Set) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(Set) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Set)":rec:- 
 --  rec:  "inner(Set) "E:  "inner(Set) "
 -- INV:gen:E.loadArgs "inner(Set) "
 -- INV:gen:after:E.loadArgs "inner(Set) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  inner(Set) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Set)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(Set) "ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  10
 rpopThisObj 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Set)":rec:inner(Set) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Set)":rec:inner(Set) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Set)":rec:inner(Set) 
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0

 CLASS has 101 1 Set 83
 -- vdtTableCopy: I:1:96 I:2:0
 rShiftUp  1
 tstOriginIsNone 
 rstore  1 origin
 -- super has
 pushThis 
 rpushg iOrigin 1
 rShiftDown  1
 pushThis 
 rstoreg  E 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- DI:gen: "in E: ref elm " DI:isConst: false isBasicValue: false 
 --  primNo: 0 
 -- DI:gen: "out B: var boolean " DI:isConst: false isBasicValue: 
 --  true primNo: 4 
 -- DI:gen:primitiveType: B 
 rtnAlloc 1
 toSuper 96
DO:
 mvStack 
 L1:
 -- AssignmentStatement:gen: "B := false " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "B := false " right.label: "ObjectGenerator ""false " 
 -- OG:before:super.gen: "false "
 -- INV:gen: "false " 
 -- needorigin: "false " 
 -- needOrigin:E: "false "  E.ATd: 
 --  False: 
 --     %globals
 --     out B: var boolean
 --     B := 0
 --  Ex: "false " rec: "false " E.ATd: 
 --  False: 
 --     %globals
 --     out B: var boolean
 --     B := 0
 --  E.ATd.desc: 
 --  %globals
 --  out B: var boolean
 --  B := 0
 --  E.ATd.IT: 
 --  %globals
 --  out B: var boolean
 --  B := 0
 -- \
 --   
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %globals
 --     out B: var boolean
 --     B := 0
 --  
 -- after:needOrigin: "false " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "false "E:  "false "
 -- INV:gen:E.loadArgs "false "
 -- INV:gen:after:E.loadArgs "false "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "false "
 -- OI:invoke:before:ATdx.invoke: pattern False 
 -- ptn:invoke: "False "E: "false "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "false " 
 --  adr:none 
 invoke False 27 0 0
 -- global:pushOut: B off: 1 
 pushg 1 
 -- callInvoke:after:pushOut: 1 
 -- GeneralPTN:invoke:after:callInvoke: 1 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- checkNumberConvert: "false " D: "out B: var boolean " 
 -- assign:adr.store:A: 
 storeg has$101 3
 -- assign:adr.store:B: 
 pushThis 
 -- before objTmpStack:add:  103   "scan$103 "
 invoke scan$103 103 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 rtnInner  M
 END OSDV:0 objSize:3 isIndexed:0

 CLASS scan 102 1 Set 83
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "current: ref elm " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 -- DI:gen: "nxt: ref link " DI:isConst: false isBasicValue: false 
 --  primNo: 0 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "nxt := head " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "nxt := head " right.label: "ObjectGenerator ""head " 
 -- OG:before:super.gen: "head "
 -- INV:gen: "head " 
 -- needorigin: "head " 
 -- needOrigin:E: "head "  E.ATd: "head: ref link " Ex: "head " rec: "
 --  head " E.ATd: "head: ref link " E.ATd.desc: 
 --  in e: ref elm
 --  in next: ref link
 --  E.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "head " 
 -- doNeedOrigin:E: "head " 
 -- computeAdrX:superAdj: 0 "head " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "head " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "scan "on: 1 isValueObj: false 
 --  origin: Set origin:isValueObj: false 
 rpushg scan$102 1
 -- computeAdrX:isLast:E:  "head "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "head "E:  "head "
 -- INV:gen:E.loadArgs "head "
 -- INV:gen:after:E.loadArgs "head "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "head "
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: ref head 
 -- DI:invoke: "head: ref link " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head isNotRemote: true 
 rpushg Set$83 1
 -- OI:invoke:V: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- OI:invoke:X: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- INV:gen:end:off: 1 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- assign:adr.store:A: 
 rswap 0
 rstoreg  EisNone 3
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- assign:adr.store:B: 
 pushThis 
 -- before objTmpStack:add:  107   "Loop "
 invoke Loop 107 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:1 objSize:3 isIndexed:0

 CLASS link 78 1 Set 83
 pushThis 
 rstoreg  next 3
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 pushThis 
 rstoreg  e 2
   ;; vTop(0,0)=[] rTop(-4,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in e: ref elm " DI:isConst: false isBasicValue: false 
 --  primNo: 0 
 -- DI:gen: "in next: ref link " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS Loop 107 1 scan 102
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "
 --  if (nxt =/= none) :then 
 --     current := nxt.e
 --     inner(scan)
 --     nxt := nxt.next
 --     restart(Loop)
 --  :else 
 --     nxt := nxt "
 -- INV:gen: 
 --  if (nxt =/= none) :then 
 --     current := nxt.e
 --     inner(scan)
 --     nxt := nxt.next
 -- needorigin: 
 --  if (nxt =/= none) :then 
 --     current := nxt.e
 --     inner(scan)
 --     nxt := nxt.next
 -- needOrigin:E: 
 --  if (nxt =/= none) :then 
 --     current := nxt.e
 --     inner(scan)
 --     nxt := nxt.next E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (nxt =/= none) :then 
 --     current := nxt.e
 --     inner(scan)
 --     nxt := nxt.nextrec: 
 --  if (nxt =/= none) :then 
 --     current := nxt.e
 --     inner(scan)
 --     nxt := nxt.nextE.ATd: 
 -- \
 --   if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  E.ATd.desc: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  E.ATd.IT: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (nxt =/= none) :then 
 --     current := nxt.e
 --     inner(scan)
 --     nxt := nxt.next
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "
 --  if (nxt =/= none) :then 
 --     current := nxt.e
 --     inner(scan)
 --     nxt := nxt.next
 --     restart(Loop)
 --  :else 
 --     nxt := nxt "E:  "
 --  if (nxt =/= none) :then 
 --     current := nxt.e
 --     inner(scan)
 --     nxt := nxt.next
 --     restart(Loop)
 --  :else 
 --     nxt := nxt "
 -- INV:gen:E.loadArgs "
 --  if (nxt =/= none) :then 
 --     current := nxt.e
 --     inner(scan)
 --     nxt := nxt.next
 --     restart(Loop)
 --  :else 
 --     nxt := nxt "
 -- INV:gen:after:E.loadArgs "
 --  if (nxt =/= none) :then 
 --     current := nxt.e
 --     inner(scan)
 --     nxt := nxt.next
 --     restart(Loop)
 --  :else 
 --     nxt := nxt "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThenElse "
 --  if (nxt =/= none) :then 
 --     current := nxt.e
 --     inner(scan)
 --     nxt := nxt.next
 --     restart(Loop)
 --  :else 
 --     nxt := nxt "
 -- OG:before:super.gen: "(nxt =/= none) "
 -- INV:gen: "(nxt =/= none) " 
 -- needorigin: "(nxt =/= none) " 
 -- needOrigin:E: "(nxt =/= none) "  E.ATd: 
 --  =/=  : 
 --     %basic 57
 --     in objx: ref Object
 --     out V: var boolean
 --  Ex: "(nxt =/= none) " rec: "(nxt =/= none) " E.ATd: 
 --  =/=  : 
 --     %basic 57
 --     in objx: ref Object
 --     out V: var boolean
 --  E.ATd.desc: 
 --  %basic 57
 --  in objx: ref Object
 --  out V: var boolean
 --  E.ATd.IT: 
 --  %basic 57
 --  in objx: ref Object
 --  out V: var boolean
 -- \
 --   
 -- doNeedOrigin:Ex: "(nxt =/= none) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(nxt =/= none) " 
 -- doNeedOrigin:E: "(nxt =/= none) " 
 -- computeAdrX:superAdj: 0 "(nxt =/= none) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(nxt =/= none) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "nxt =/= none "superAdj: 0 
 -- BE:loadOrigin:E: nxt =/= none 
 -- computeAdrX:isLast:E:  "nxt =/= none "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "nxt =/= none "E:  "nxt =/= none "
 -- INV:gen:E.loadArgs "nxt =/= none "
 -- BinaryExp:loadArgs: "nxt =/= none " superAdj: 0 
 -- INV:gen: "nxt " 
 -- needorigin: "nxt " 
 -- needOrigin:E: "nxt "  E.ATd: "nxt: ref link " Ex: "nxt " rec: "
 --  nxt " E.ATd: "nxt: ref link " E.ATd.desc: 
 --  in e: ref elm
 --  in next: ref link
 --  E.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "nxt " 
 -- doNeedOrigin:E: "nxt " 
 -- computeAdrX:superAdj: 0 "nxt " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "nxt " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "Loop "on: 1 isValueObj: false 
 --  origin: scan origin:isValueObj: false 
 rpushg Loop$107 1
 -- computeAdrX:isLast:E:  "nxt "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "nxt "E:  "nxt "
 -- INV:gen:E.loadArgs "nxt "
 -- INV:gen:after:E.loadArgs "nxt "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "nxt "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: ref nxt 
 -- DI:invoke: "nxt: ref link " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"nxt":rec:nxt isNotRemote: true 
 rpushg scan$102 3
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"nxt":rec:nxt 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"nxt":rec:nxt 
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"nxt":rec:nxt 
 -- NonVirt: "=/= none " "ObjectInvocation_Binary " ActArg: "none "
 --  isValue: false formalArg: "in objx: ref Object " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "=/= none " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "none "
 -- INV:gen: "none " 
 -- needorigin: "none " 
 -- needOrigin:E: "none "  E.ATd: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  Ex: "none " rec: "none " E.ATd: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  E.ATd.desc: 
 --  %basic 19
 --  none_x: var integer
 --  E.ATd.IT: 
 --  %basic 19
 --  none_x: var integer
 --  
 -- doNeedOrigin:Ex: "none "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "none " 
 -- doNeedOrigin:E: "none " 
 -- computeAdrX:superAdj: 0 "none " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "none " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "none "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "none "E:  "none "
 -- INV:gen:E.loadArgs "none "
 -- INV:gen:after:E.loadArgs "none "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "none "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern none 
 -- ptn:invoke: "none "E: "none "ptnKind: 0 useRtnV: true 
 pushNone 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- actualArg:isPtn: true formalArg:isPtn: "in objx: ref Object "
 --  :isBasicVal: false :valueObj: false 
 --  :actArg: "none ":isBasicVal: false 
 -- case:B: none ObjectGenerator 64 19 19 false false 
 -- checkNumberConvert: "none " D: "in objx: ref Object " 
 -- end:loadArgs:NonVirt: "=/= none "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"nxt":rec:nxt 
 -- INV:gen:after:E.loadArgs "nxt =/= none "
 --  OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"nxt":rec:nxt 
 -- IV:E.invoke:useRtnVal: true E: BinOp "nxt =/= none "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"nxt":rec:nxt 
 -- BinaryExp:invoke: "nxt "rec: "nxt =/= none "
 -- M: "=/= none "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"nxt":rec:nxt 
 -- OI:invoke:before:ATdx.invoke: pattern =/=   
 -- ptn:invoke: "=/=   "E: "=/= none "ptnKind: 0 useRtnV: true 
 rne
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"=/= none":rec:nxt 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"=/= none":rec:nxt 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  110   "$110 "
 invoke $110 110 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L5
 L4:
 pushThis 
 -- before objTmpStack:add:  111   "$111 "
 invoke $111 111 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L5:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $110 110 1 Loop 107
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "current := nxt.e " 
 pushThis 
 -- items:goOrigin:encOG: "$110 "on: 2 isValueObj: false 
 --  origin: Loop origin:isValueObj: false 
 rpushg $110$110 1
 -- items:goOrigin:encOG: "Loop "on: 1 isValueObj: false 
 --  origin: scan origin:isValueObj: false 
 rpushg Loop$107 1
 -- AssignmentStatement:gen: 
 --  "current := nxt.e " right.label: "ObjectGenerator ""nxt.e " 
 -- OG:before:super.gen: "nxt.e "
 -- INV:gen: "nxt.e " 
 -- needorigin: "nxt.e " 
 -- needOrigin:E: "e "  E.ATd: "in e: ref elm " Ex: none rec: "nxt " 
 --  E.ATd: "in e: ref elm " E.ATd.desc: 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : E.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "e " 
 -- doNeedOrigin:E: "e " 
 -- computeAdrX:superAdj: 0 "nxt.e " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "nxt " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$110 "on: 2 isValueObj: false 
 --  origin: Loop origin:isValueObj: false 
 rpushg $110$110 1
 -- items:goOrigin:encOG: "Loop "on: 1 isValueObj: false 
 --  origin: scan origin:isValueObj: false 
 rpushg Loop$107 1
 -- computeAdrX:En: 2 pRec: "nxt " rec: "nxt " E: "e " 
 --  A.E: none 
 --  
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "nxt " rec: "nxt " E: "e " 
 --  rec.ATd: "nxt: ref link " rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  %OSDvisibility skipInternal
 --     current: ref elm
 --     nxt: ref link
 --     nxt := head
 --  recA: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"e":rec:- 
 --  pRecA: none 
 -- pRec: "nxt " rec: "nxt " E: "e " 
 --  false false 
 -- computeAdrX:before:rec:: "nxt " 
 -- OI:invoke:before:ATdx.invoke: ref nxt 
 -- DI:invoke: "nxt: ref link " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"e":rec:nxt isNotRemote: false 
 rpushg $110$110 3
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"e":rec:nxt 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"e":rec:nxt 
 -- computeAdrX:after:rec.invoke: "nxt " 
 -- computeAdrX:isLast:E:  "e "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "nxt "E:  "e "
 -- INV:gen:E.loadArgs "e "
 -- INV:gen:after:E.loadArgs "e "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "e "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: ref e 
 -- DI:invoke: "in e: ref elm " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"e":rec:nxt isNotRemote: false 
 rpushg $110$110 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"e":rec:nxt 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"e":rec:nxt 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"e":rec:nxt 
 -- assign:adr.store:A: 
 rswap 0
 rstoreg  EisNone 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "inner(scan) "
 -- INV:gen: "inner(scan) " 
 -- needorigin: "inner(scan) " 
 -- needOrigin:E: "inner(scan) "  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(scan) " rec: "inner(scan) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  E.ATd.desc: 
 --  %basic 101
 --  in inner: ref Object
 --  E.ATd.IT: 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- doNeedOrigin:Ex: "inner(scan) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inner(scan) " 
 -- doNeedOrigin:E: "inner(scan) " 
 -- computeAdrX:superAdj: 0 "inner(scan) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(scan) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(scan) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(scan)":rec:- 
 --  rec:  "inner(scan) "E:  "inner(scan) "
 -- INV:gen:E.loadArgs "inner(scan) "
 -- INV:gen:after:E.loadArgs "inner(scan) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  inner(scan) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(scan)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(scan) "ptnKind: 0 useRtnV: false 
 pushThis 
 -- items:goOrigin:encOG: "$110 "on: 2 isValueObj: false 
 --  origin: Loop origin:isValueObj: false 
 rpushg $110$110 1
 -- items:goOrigin:encOG: "Loop "on: 1 isValueObj: false 
 --  origin: scan origin:isValueObj: false 
 rpushg Loop$107 1
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(scan)":rec:inner(scan) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(scan)":rec:inner(scan) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(scan)":rec:inner(scan) 
 -- AssignmentStatement:gen: "nxt := nxt.next " 
 pushThis 
 -- items:goOrigin:encOG: "$110 "on: 2 isValueObj: false 
 --  origin: Loop origin:isValueObj: false 
 rpushg $110$110 1
 -- items:goOrigin:encOG: "Loop "on: 1 isValueObj: false 
 --  origin: scan origin:isValueObj: false 
 rpushg Loop$107 1
 -- AssignmentStatement:gen: 
 --  "nxt := nxt.next " right.label: "ObjectGenerator ""nxt.next " 
 -- OG:before:super.gen: "nxt.next "
 -- INV:gen: "nxt.next " 
 -- needorigin: "nxt.next " 
 -- needOrigin:E: "next "  E.ATd: "in next: ref link " Ex: none rec: "
 --  nxt " E.ATd: "in next: ref link " E.ATd.desc: 
 --  in e: ref elm
 --  in next: ref link
 --  E.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "next " 
 -- doNeedOrigin:E: "next " 
 -- computeAdrX:superAdj: 0 "nxt.next " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "nxt " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$110 "on: 2 isValueObj: false 
 --  origin: Loop origin:isValueObj: false 
 rpushg $110$110 1
 -- items:goOrigin:encOG: "Loop "on: 1 isValueObj: false 
 --  origin: scan origin:isValueObj: false 
 rpushg Loop$107 1
 -- computeAdrX:En: 2 pRec: "nxt " rec: "nxt " E: "next " 
 --  A.E: none 
 --  
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "nxt " rec: "nxt " E: "next " 
 --  rec.ATd: "nxt: ref link " rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  %OSDvisibility skipInternal
 --     current: ref elm
 --     nxt: ref link
 --     nxt := head
 --  recA: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"next":rec:- 
 --  pRecA: none 
 -- pRec: "nxt " rec: "nxt " E: "next " 
 --  false false 
 -- computeAdrX:before:rec:: "nxt " 
 -- OI:invoke:before:ATdx.invoke: ref nxt 
 -- DI:invoke: "nxt: ref link " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"next":rec:nxt isNotRemote: false 
 rpushg $110$110 3
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"next":rec:nxt 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"next":rec:nxt 
 -- computeAdrX:after:rec.invoke: "nxt " 
 -- computeAdrX:isLast:E:  "next "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "nxt "E:  "next "
 -- INV:gen:E.loadArgs "next "
 -- INV:gen:after:E.loadArgs "next "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "next "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: ref next 
 -- DI:invoke: "in next: ref link " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"next":rec:nxt isNotRemote: false 
 rpushg $110$110 3
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"next":rec:nxt 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"next":rec:nxt 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"next":rec:nxt 
 -- assign:adr.store:A: 
 rswap 0
 rstoreg  EisNone 3
   ;; vTop(0,0)=[] rTop(-4,0)=[]
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "restart(Loop) "
 -- INV:gen: "restart(Loop) " 
 -- needorigin: "restart(Loop) " 
 -- needOrigin:E: "restart(Loop) "  E.ATd: 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  Ex: "restart(Loop) " rec: "restart(Loop) " E.ATd: 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  E.ATd.desc: "%basic 102 " E.ATd.IT: "%basic 102 " 
 -- doNeedOrigin:Ex: "restart(Loop) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "restart(Loop) " 
 -- doNeedOrigin:E: "restart(Loop) " 
 -- computeAdrX:superAdj: 0 "restart(Loop) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "restart(Loop) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "restart(Loop) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(Loop)":rec:- 
 --  rec:  "restart(Loop) "E:  "restart(Loop) "
 -- INV:gen:E.loadArgs "restart(Loop) "
 -- INV:gen:after:E.loadArgs "restart(Loop) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  restart(Loop) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(Loop)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern restart(V: var integer) 
 -- ptn:invoke: "restart(V: var integer) "E: "restart(Loop) "
 --  ptnKind: 0 useRtnV: false 
 break  1 1 107 0
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(Loop)":rec:restart(Loop) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(Loop)":rec:restart(Loop) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(Loop)":rec:restart(Loop) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $111 111 1 Loop 107
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "nxt := nxt " 
 pushThis 
 -- items:goOrigin:encOG: "$111 "on: 2 isValueObj: false 
 --  origin: Loop origin:isValueObj: false 
 rpushg $111$111 1
 -- items:goOrigin:encOG: "Loop "on: 1 isValueObj: false 
 --  origin: scan origin:isValueObj: false 
 rpushg Loop$107 1
 -- AssignmentStatement:gen: 
 --  "nxt := nxt " right.label: "ObjectGenerator ""nxt " 
 -- OG:before:super.gen: "nxt "
 -- INV:gen: "nxt " 
 -- needorigin: "nxt " 
 -- needOrigin:E: "nxt "  E.ATd: "nxt: ref link " Ex: "nxt " rec: "
 --  nxt " E.ATd: "nxt: ref link " E.ATd.desc: 
 --  in e: ref elm
 --  in next: ref link
 --  E.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "nxt " 
 -- doNeedOrigin:E: "nxt " 
 -- computeAdrX:superAdj: 0 "nxt " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "nxt " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$111 "on: 2 isValueObj: false 
 --  origin: Loop origin:isValueObj: false 
 rpushg $111$111 1
 -- items:goOrigin:encOG: "Loop "on: 1 isValueObj: false 
 --  origin: scan origin:isValueObj: false 
 rpushg Loop$107 1
 -- computeAdrX:isLast:E:  "nxt "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "nxt "E:  "nxt "
 -- INV:gen:E.loadArgs "nxt "
 -- INV:gen:after:E.loadArgs "nxt "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "nxt "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: ref nxt 
 -- DI:invoke: "nxt: ref link " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"nxt":rec:nxt isNotRemote: true 
 rpushg scan$102 3
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"nxt":rec:nxt 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"nxt":rec:nxt 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"nxt":rec:nxt 
 -- assign:adr.store:A: 
 rswap 0
 rstoreg  EisNone 3
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS scan$103 103 4 has 101
 -- vdtTableCopy: I:1:102 I:2:0
 tstOriginIsNone 
 rstore  4 origin
 -- super scan
 -- computeAdrX:superAdj: 4 "scan " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "scan " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 rpushg has$101 4
 -- items:goOrigin:encOG: "has "on: 1 isValueObj: false 
 --  origin: Set origin:isValueObj: false 
 rpushg has$101 1
 -- computeAdrX:isLast:E:  "scan "
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- DI:gen: "current: ref elm " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 -- DI:gen: "nxt: ref link " DI:isConst: false isBasicValue: false 
 --  primNo: 0 
 rtnAlloc 1
 toSuper 102
DO:
 mvStack 
 L1:
 -- OG:before:super.gen: "
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  :else 
 --     B := B "
 -- INV:gen: 
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  :else 
 -- needorigin: 
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  :else 
 -- needOrigin:E: 
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  :else  E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  :else rec: 
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  :else E.ATd: 
 -- \
 --   if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  E.ATd.desc: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  E.ATd.IT: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  :else 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  :else 
 --     B := B "E:  "
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  :else 
 --     B := B "
 -- INV:gen:E.loadArgs "
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  :else 
 --     B := B "
 -- INV:gen:after:E.loadArgs "
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  :else 
 --     B := B "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThenElse "
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  :else 
 --     B := B "
 -- OG:before:super.gen: "(current == e) "
 -- INV:gen: "(current == e) " 
 -- needorigin: "(current == e) " 
 -- needOrigin:E: "(current == e) "  E.ATd: 
 --  ==  : 
 --     %basic 56
 --     in objx: ref Object
 --     out V: var boolean
 --  Ex: "(current == e) " rec: "(current == e) " E.ATd: 
 --  ==  : 
 --     %basic 56
 --     in objx: ref Object
 --     out V: var boolean
 --  E.ATd.desc: 
 --  %basic 56
 --  in objx: ref Object
 --  out V: var boolean
 --  E.ATd.IT: 
 --  %basic 56
 --  in objx: ref Object
 --  out V: var boolean
 -- \
 --   
 -- doNeedOrigin:Ex: "(current == e) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(current == e) " 
 -- doNeedOrigin:E: "(current == e) " 
 -- computeAdrX:superAdj: 0 "(current == e) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(current == e) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "current == e "superAdj: 0 
 -- BE:loadOrigin:E: current == e 
 -- computeAdrX:isLast:E:  "current == e "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "current == e "E:  "current == e "
 -- INV:gen:E.loadArgs "current == e "
 -- BinaryExp:loadArgs: "current == e " superAdj: 0 
 -- INV:gen: "current " 
 -- needorigin: "current " 
 -- needOrigin:E: "current "  E.ATd: "current: ref elm " Ex: "
 --  current " rec: "current " E.ATd: "current: ref elm " E.ATd.desc: 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : E.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "current " 
 -- doNeedOrigin:E: "current " 
 -- computeAdrX:superAdj: 0 "current " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "current " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "current "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "current "E:  "current "
 -- INV:gen:E.loadArgs "current "
 -- INV:gen:after:E.loadArgs "current "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "current "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: ref current 
 -- DI:invoke: "current: ref elm " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"current":rec:current isNotRemote: true 
 rpushg scan$103$103 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"current":rec:current 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"current":rec:current 
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"current":rec:current 
 -- NonVirt: "== e " "ObjectInvocation_Binary " ActArg: "e "isValue: 
 --  false formalArg: "in objx: ref Object " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "== e " isCompositeValueObj: false 
 -- OG:before:super.gen: "e "
 -- INV:gen: "e " 
 -- needorigin: "e " 
 -- needOrigin:E: "e "  E.ATd: "in E: ref elm " Ex: "e " rec: "e " 
 --  E.ATd: "in E: ref elm " E.ATd.desc: 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : E.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "e " 
 -- doNeedOrigin:E: "e " 
 -- computeAdrX:superAdj: 0 "e " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "e " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "scan$103 "on: 1 isValueObj: false 
 --  origin: has origin:isValueObj: false 
 rpushg scan$103$103 4
 -- computeAdrX:isLast:E:  "e "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "e "E:  "e "
 -- INV:gen:E.loadArgs "e "
 -- INV:gen:after:E.loadArgs "e "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "e "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: ref E 
 -- DI:invoke: "in E: ref elm " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"e":rec:e isNotRemote: true 
 rpushg has$101 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"e":rec:e 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"e":rec:e 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"e":rec:e 
 -- actualArg:isPtn: false formalArg:isPtn: "in objx: ref Object "
 --  :isBasicVal: false :valueObj: false 
 --  :actArg: "e ":isBasicVal: false 
 -- case:B: e ObjectGenerator 64 0 64 false false 
 -- checkNumberConvert: "e " D: "in objx: ref Object " 
 -- end:loadArgs:NonVirt: "== e "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"current":rec:current 
 -- INV:gen:after:E.loadArgs "current == e "
 --  OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"current":rec:current 
 -- IV:E.invoke:useRtnVal: true E: BinOp "current == e "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"current":rec:current 
 -- BinaryExp:invoke: "current "rec: "current == e "
 -- M: "== e "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"current":rec:current 
 -- OI:invoke:before:ATdx.invoke: pattern ==   
 -- ptn:invoke: "==   "E: "== e "ptnKind: 0 useRtnV: true 
 req
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"== e":rec:current 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"== e":rec:current 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  105   "$105 "
 invoke $105 105 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L5
 L4:
 pushThis 
 -- before objTmpStack:add:  106   "$106 "
 invoke $106 106 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L5:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0

 CLASS $105 105 1 scan$103 103
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "B := true " 
 pushThis 
 -- items:goOrigin:encOG: "$105 "on: 2 isValueObj: false 
 --  origin: scan$103 origin:isValueObj: false 
 rpushg $105$105 1
 -- items:goOrigin:encOG: "scan$103 "on: 1 isValueObj: false 
 --  origin: has origin:isValueObj: false 
 rpushg scan$103$103 4
 -- AssignmentStatement:gen: 
 --  "B := true " right.label: "ObjectGenerator ""true " 
 -- OG:before:super.gen: "true "
 -- INV:gen: "true " 
 -- needorigin: "true " 
 -- needOrigin:E: "true "  E.ATd: 
 --  True: 
 --     %globals
 --     out B: var boolean
 --     B := 1
 --  Ex: "true " rec: "true " E.ATd: 
 --  True: 
 --     %globals
 --     out B: var boolean
 --     B := 1
 --  E.ATd.desc: 
 --  %globals
 --  out B: var boolean
 --  B := 1
 --  E.ATd.IT: 
 --  %globals
 --  out B: var boolean
 --  B := 1
 -- \
 --   
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %globals
 --     out B: var boolean
 --     B := 1
 --  
 -- after:needOrigin: "true " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "true "E:  "true "
 -- INV:gen:E.loadArgs "true "
 -- INV:gen:after:E.loadArgs "true "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "true "
 -- OI:invoke:before:ATdx.invoke: pattern True 
 -- ptn:invoke: "True "E: "true "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "true " 
 --  adr:none 
 invoke True 23 0 0
 -- global:pushOut: B off: 1 
 pushg 1 
 -- callInvoke:after:pushOut: 1 
 -- GeneralPTN:invoke:after:callInvoke: 1 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- checkNumberConvert: "true " D: "out B: var boolean " 
 -- assign:adr.store:A: 
 storeg has$101 3
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "leave(has) "
 -- INV:gen: "leave(has) " 
 -- needorigin: "leave(has) " 
 -- needOrigin:E: "leave(has) "  E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  Ex: "leave(has) " rec: "leave(has) " E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  E.ATd.desc: "%basic 103 " E.ATd.IT: "%basic 103 " 
 -- doNeedOrigin:Ex: "leave(has) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "leave(has) " 
 -- doNeedOrigin:E: "leave(has) " 
 -- computeAdrX:superAdj: 0 "leave(has) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "leave(has) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "leave(has) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(has)":rec:- 
 --  rec:  "leave(has) "E:  "leave(has) "
 -- INV:gen:E.loadArgs "leave(has) "
 -- INV:gen:after:E.loadArgs "leave(has) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  leave(has) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(has)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- ptn:invoke: "leave(V: var integer) "E: "leave(has) "ptnKind: 0 
 --  useRtnV: false 
 break  2 2 96 1
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(has)":rec:leave(has) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(has)":rec:leave(has) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(has)":rec:leave(has) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $106 106 1 scan$103 103
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "B := B " 
 pushThis 
 -- items:goOrigin:encOG: "$106 "on: 2 isValueObj: false 
 --  origin: scan$103 origin:isValueObj: false 
 rpushg $106$106 1
 -- items:goOrigin:encOG: "scan$103 "on: 1 isValueObj: false 
 --  origin: has origin:isValueObj: false 
 rpushg scan$103$103 4
 -- AssignmentStatement:gen: 
 --  "B := B " right.label: "ObjectGenerator ""B " 
 -- OG:before:super.gen: "B "
 -- INV:gen: "B " 
 -- needorigin: "B " 
 -- needOrigin:E: "B "  E.ATd: "out B: var boolean " Ex: "B " rec: "
 --  B " E.ATd: "out B: var boolean " E.ATd.desc: 
 --  %id "Boolean"
 --  %globals inSub
 --  %basic 4, 8
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "B " 
 -- doNeedOrigin:E: "B " 
 -- computeAdrX:superAdj: 0 "B " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "B " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$106 "on: 2 isValueObj: false 
 --  origin: scan$103 origin:isValueObj: false 
 rpushg $106$106 1
 -- items:goOrigin:encOG: "scan$103 "on: 1 isValueObj: false 
 --  origin: has origin:isValueObj: false 
 rpushg scan$103$103 4
 -- computeAdrX:isLast:E:  "B "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 --  rec:  "B "E:  "B "
 -- INV:gen:E.loadArgs "B "
 -- INV:gen:after:E.loadArgs "B "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "B "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- OI:invoke:before:ATdx.invoke: var B 
 -- DI:invoke: "out B: var boolean " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:B isNotRemote: true 
 pushg 3 has$101
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:B 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:B 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:B 
 -- checkNumberConvert: "B " D: "out B: var boolean " 
 -- assign:adr.store:A: 
 storeg has$101 3
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS isEmpty 112 1 Set 83
 -- vdtTableCopy: I:1:98 I:2:0
 tstOriginIsNone 
 rstore  1 origin
 -- super isEmpty
 pushThis 
 rpushg iOrigin 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 rtnAlloc 1
 toSuper 98
DO:
 mvStack 
 L1:
 -- AssignmentStatement:gen: "B := head == none " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "B := head == none " right.label: "ObjectGenerator ""
 --  head == none " 
 -- OG:before:super.gen: "head == none "
 -- INV:gen: "head == none " 
 -- needorigin: "head == none " 
 -- needOrigin:E: "head == none "  E.ATd: 
 --  ==  : 
 --     %basic 56
 --     in objx: ref Object
 --     out V: var boolean
 --  Ex: "head == none " rec: "head == none " E.ATd: 
 --  ==  : 
 --     %basic 56
 --     in objx: ref Object
 --     out V: var boolean
 --  E.ATd.desc: 
 --  %basic 56
 --  in objx: ref Object
 --  out V: var boolean
 --  E.ATd.IT: 
 --  %basic 56
 --  in objx: ref Object
 --  out V: var boolean
 -- \
 --   
 -- doNeedOrigin:Ex: "head == none "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "head == none " 
 -- doNeedOrigin:E: "head == none " 
 -- computeAdrX:superAdj: 0 "head == none " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "head == none " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "head == none "superAdj: 0 
 -- computeAdrX:isLast:E:  "head == none "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "head == none "E:  "head == none "
 -- INV:gen:E.loadArgs "head == none "
 -- BinaryExp:loadArgs: "head == none " superAdj: 0 
 -- INV:gen: "head " 
 -- needorigin: "head " 
 -- needOrigin:E: "head "  E.ATd: "head: ref link " Ex: "head " rec: "
 --  head " E.ATd: "head: ref link " E.ATd.desc: 
 --  in e: ref elm
 --  in next: ref link
 --  E.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "head " 
 -- doNeedOrigin:E: "head " 
 -- computeAdrX:superAdj: 0 "head " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "head " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "isEmpty "on: 1 isValueObj: false 
 --  origin: Set origin:isValueObj: false 
 rpushg isEmpty$112 1
 -- computeAdrX:isLast:E:  "head "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "head "E:  "head "
 -- INV:gen:E.loadArgs "head "
 -- INV:gen:after:E.loadArgs "head "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "head "
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: ref head 
 -- DI:invoke: "head: ref link " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head isNotRemote: true 
 rpushg Set$83 1
 -- OI:invoke:V: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- OI:invoke:X: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- INV:gen:end:off: 1 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- NonVirt: "== none " "ObjectInvocation_Binary " ActArg: "none "
 --  isValue: false formalArg: "in objx: ref Object " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "== none " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "none "
 -- INV:gen: "none " 
 -- needorigin: "none " 
 -- needOrigin:E: "none "  E.ATd: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  Ex: "none " rec: "none " E.ATd: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  E.ATd.desc: 
 --  %basic 19
 --  none_x: var integer
 --  E.ATd.IT: 
 --  %basic 19
 --  none_x: var integer
 --  
 -- doNeedOrigin:Ex: "none "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "none " 
 -- doNeedOrigin:E: "none " 
 -- computeAdrX:superAdj: 0 "none " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "none " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "none "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "none "E:  "none "
 -- INV:gen:E.loadArgs "none "
 -- INV:gen:after:E.loadArgs "none "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "none "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern none 
 -- ptn:invoke: "none "E: "none "ptnKind: 0 useRtnV: true 
 pushNone 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- actualArg:isPtn: true formalArg:isPtn: "in objx: ref Object "
 --  :isBasicVal: false :valueObj: false 
 --  :actArg: "none ":isBasicVal: false 
 -- case:B: none ObjectGenerator 64 19 19 false false 
 -- checkNumberConvert: "none " D: "in objx: ref Object " 
 -- end:loadArgs:NonVirt: "== none "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- INV:gen:after:E.loadArgs "head == none "
 --  OIadr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- IV:E.invoke:useRtnVal: true E: BinOp "head == none "
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- BinaryExp:invoke: "head "rec: "head == none "
 -- M: "== none "
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- OI:invoke:before:ATdx.invoke: pattern ==   
 -- ptn:invoke: "==   "E: "== none "ptnKind: 0 useRtnV: true 
 req
 -- OI:invoke:V: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"== none":rec:head 
 -- OI:invoke:X: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"== none":rec:head 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- checkNumberConvert: "head == none " D: "B: var Boolean " 
 -- assign:adr.store:A: 
 storeg isEmpty$112 2
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS insert 75 1 Set 83
 -- vdtTableCopy: I:1:74 I:2:0
 rShiftUp  1
 tstOriginIsNone 
 rstore  1 origin
 -- super insert
 pushThis 
 rpushg iOrigin 1
 rShiftDown  1
 pushThis 
 rstoreg  e 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- DI:gen: "in e: ref elm " DI:isConst: false isBasicValue: false 
 --  primNo: 0 
 rtnAlloc 1
 toSuper 74
DO:
 mvStack 
 L1:
 -- OG:before:super.gen: "
 --  if has(e).not :then 
 --     head := link(e,head) "
 -- INV:gen: 
 --  if has(e).not :then 
 --     head := link(e,head)
 --  
 -- needorigin: 
 --  if has(e).not :then 
 --     head := link(e,head)
 --  
 -- needOrigin:E: 
 --  if has(e).not :then 
 --     head := link(e,head)
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if has(e).not :then 
 --     head := link(e,head)
 --  rec: 
 --  if has(e).not :then 
 --     head := link(e,head)
 --  E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 -- \
 --      %globals inSub
 --  E.ATd.desc: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  E.ATd.IT: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if has(e).not :then 
 --     head := link(e,head)
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "if has(e).not :then 
 --     head := link(e,head) "E:  "
 --  if has(e).not :then 
 --     head := link(e,head) "
 -- INV:gen:E.loadArgs "if has(e).not :then 
 --     head := link(e,head) "
 -- INV:gen:after:E.loadArgs "
 --  if has(e).not :then 
 --     head := link(e,head) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "
 --  if has(e).not :then 
 --     head := link(e,head) "
 -- OG:before:super.gen: "has(e).not "
 -- INV:gen: "has(e).not " 
 -- needorigin: "has(e).not " 
 -- needOrigin:E: "not "  E.ATd: 
 --  not: 
 --     %basic 65
 --     out R: var boolean
 --  Ex: "has(e) " rec: "has(e) " E.ATd: 
 --  not: 
 --     %basic 65
 --     out R: var boolean
 --  E.ATd.desc: 
 --  %basic 65
 --  out R: var boolean
 --  E.ATd.IT: 
 --  %basic 65
 --  out R: var boolean
 --  
 -- doNeedOrigin:Ex: "has(e) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "has(e) " 
 -- doNeedOrigin:E: "has(e) " 
 -- computeAdrX:superAdj: 0 "has(e).not " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "has(e) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "insert "on: 1 isValueObj: false 
 --  origin: Set origin:isValueObj: false 
 rpushg insert$75 1
 -- computeAdrX:En: 2 pRec: "has(e) " rec: "has(e) " E: "not " 
 --  A.E: "has(e) "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"has(e)":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "has(e) " rec: "has(e) " E: "not " 
 --  rec.ATd: 
 --  has:: 
 --     B := false
 --     scan
 --        if (current == e) :then rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  Collection
 --     %globals
 --     has:: 
 --        B := false
 --  recA: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"has(e)":rec:- 
 --  pRecA: none 
 -- pRec: "has(e) " rec: "has(e) " E: "not " 
 --  false false 
 -- NonVirt: "has(e) " "ObjectInvocation_KeyWord " ActArg: "e "
 --  isValue: false formalArg: "in E: ref elm " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "has(e) " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "e "
 -- INV:gen: "e " 
 -- needorigin: "e " 
 -- needOrigin:E: "e "  E.ATd: "in e: ref elm " Ex: "e " rec: "e " 
 --  E.ATd: "in e: ref elm " E.ATd.desc: 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : E.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "e " 
 -- doNeedOrigin:E: "e " 
 -- computeAdrX:superAdj: 0 "e " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "e " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "e "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "e "E:  "e "
 -- INV:gen:E.loadArgs "e "
 -- INV:gen:after:E.loadArgs "e "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "e "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: ref e 
 -- DI:invoke: "in e: ref elm " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"e":rec:e isNotRemote: true 
 rpushg insert$75 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"e":rec:e 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"e":rec:e 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"e":rec:e 
 -- actualArg:isPtn: false formalArg:isPtn: "in E: ref elm "
 --  :isBasicVal: false :valueObj: false 
 --  :actArg: "e ":isBasicVal: false 
 -- case:B: e ObjectGenerator 0 0 64 false false 
 -- checkNumberConvert: "e " D: "in E: ref elm " 
 -- end:loadArgs:NonVirt: "has(e) "
 -- computeAdrX:before:rec:: "has(e) " 
 -- OI:invoke:before:ATdx.invoke: pattern has 
 -- ptn:invoke: "has "E: "not "ptnKind: 3 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 rec: "has(e) " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"not":rec:has(e) 
 -- isStatic: true rec: "has(e) "
 invoke has 101 0 0
 -- global:pushOut: B off: 3 
 pushg 3 
 -- callInvoke:after:pushOut: 3 
 -- GeneralPTN:invoke:after:callInvoke:X: 3 
 -- GeneralPTN:invoke:end: 3 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"not":rec:has(e) 
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"not":rec:has(e) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"not":rec:has(e) 
 -- computeAdrX:after:rec.invoke: "has(e) " 
 -- computeAdrX:isLast:E:  "not "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"not":rec:has(e) 
 --  rec:  "has(e) "E:  "not "
 -- INV:gen:E.loadArgs "not "
 -- INV:gen:after:E.loadArgs "not "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "not "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"not":rec:has(e) 
 -- OI:invoke:before:ATdx.invoke: pattern not 
 -- ptn:invoke: "not "E: "not "ptnKind: 0 useRtnV: true 
 nott
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"not":rec:has(e) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"not":rec:has(e) 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"not":rec:has(e) 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  77   "$77 "
 invoke $77 77 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS $77 77 1 insert 75
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "head := link(e,head) " 
 pushThis 
 -- items:goOrigin:encOG: "$77 "on: 2 isValueObj: false 
 --  origin: insert origin:isValueObj: false 
 rpushg $77$77 1
 -- items:goOrigin:encOG: "insert "on: 1 isValueObj: false 
 --  origin: Set origin:isValueObj: false 
 rpushg insert$75 1
 -- AssignmentStatement:gen: 
 --  "head := link(e,head) " right.label: "ObjectGenerator ""
 --  link(e,head) " 
 -- OG:before:super.gen: "link(e,head) "
 -- INV:gen: "link(e,head) " 
 -- needorigin: "link(e,head) " 
 -- needOrigin:E: "link(e,head) "  E.ATd: 
 --  link: 
 --     in e: ref elm
 --     in next: ref link
 --  Ex: "link(e,head) " rec: "link(e,head) " E.ATd: 
 --  link: 
 --     in e: ref elm
 --     in next: ref link
 --  E.ATd.desc: 
 --  in e: ref elm
 --  in next: ref link
 --  E.ATd.IT: 
 --  in e: ref elm
 --  in next: ref link
 --  
 -- doNeedOrigin:Ex: "link(e,head) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "link(e,head) " 
 -- doNeedOrigin:E: "link(e,head) " 
 -- computeAdrX:superAdj: 0 "link(e,head) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "link(e,head) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$77 "on: 2 isValueObj: false 
 --  origin: insert origin:isValueObj: false 
 rpushg $77$77 1
 -- items:goOrigin:encOG: "insert "on: 1 isValueObj: false 
 --  origin: Set origin:isValueObj: false 
 rpushg insert$75 1
 -- computeAdrX:isLast:E:  "link(e,head) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"link(e,head)":rec:- 
 --  rec:  "link(e,head) "E:  "link(e,head) "
 -- INV:gen:E.loadArgs "link(e,head) "
 -- NonVirt: "link(e,head) " "ObjectInvocation_Function " ActArg: "e "
 --  isValue: false formalArg: "in e: ref elm " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "link(e,head) "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "e "
 -- INV:gen: "e " 
 -- needorigin: "e " 
 -- needOrigin:E: "e "  E.ATd: "in e: ref elm " Ex: "e " rec: "e " 
 --  E.ATd: "in e: ref elm " E.ATd.desc: 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : E.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "e " 
 -- doNeedOrigin:E: "e " 
 -- computeAdrX:superAdj: 0 "e " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "e " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$77 "on: 1 isValueObj: false 
 --  origin: insert origin:isValueObj: false 
 rpushg $77$77 1
 -- computeAdrX:isLast:E:  "e "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "e "E:  "e "
 -- INV:gen:E.loadArgs "e "
 -- INV:gen:after:E.loadArgs "e "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "e "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: ref e 
 -- DI:invoke: "in e: ref elm " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"e":rec:e isNotRemote: true 
 rpushg insert$75 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"e":rec:e 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"e":rec:e 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"e":rec:e 
 -- actualArg:isPtn: false formalArg:isPtn: "in e: ref elm "
 --  :isBasicVal: false :valueObj: false 
 --  :actArg: "e ":isBasicVal: false 
 -- case:B: e ObjectGenerator 0 0 64 false false 
 -- checkNumberConvert: "e " D: "in e: ref elm " 
 -- end:loadArgs:NonVirt: "link(e,head) "
 -- NonVirt: "link(e,head) " "ObjectInvocation_Function " ActArg: "
 --  head "isValue: false formalArg: "in next: ref link " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "link(e,head) "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "head "
 -- INV:gen: "head " 
 -- needorigin: "head " 
 -- needOrigin:E: "head "  E.ATd: "head: ref link " Ex: "head " rec: "
 --  head " E.ATd: "head: ref link " E.ATd.desc: 
 --  in e: ref elm
 --  in next: ref link
 --  E.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "head " 
 -- doNeedOrigin:E: "head " 
 -- computeAdrX:superAdj: 0 "head " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "head " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$77 "on: 2 isValueObj: false 
 --  origin: insert origin:isValueObj: false 
 rpushg $77$77 1
 -- items:goOrigin:encOG: "insert "on: 1 isValueObj: false 
 --  origin: Set origin:isValueObj: false 
 rpushg insert$75 1
 -- computeAdrX:isLast:E:  "head "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "head "E:  "head "
 -- INV:gen:E.loadArgs "head "
 -- INV:gen:after:E.loadArgs "head "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "head "
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: ref head 
 -- DI:invoke: "head: ref link " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head isNotRemote: true 
 rpushg Set$83 1
 -- OI:invoke:V: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- OI:invoke:X: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- INV:gen:end:off: 1 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- actualArg:isPtn: false formalArg:isPtn: "in next: ref link "
 --  :isBasicVal: false :valueObj: false 
 --  :actArg: "head ":isBasicVal: false 
 -- case:B: head ObjectGenerator 0 0 0 false false 
 -- checkNumberConvert: "head " D: "in next: ref link " 
 -- end:loadArgs:NonVirt: "link(e,head) "
 -- INV:gen:after:E.loadArgs "link(e,head) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Function "
 --  link(e,head) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"link(e,head)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern link 
 -- ptn:invoke: "link "E: "link(e,head) "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "link(e,head) " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"link(e,head)":rec:link(e,head) 
 invoke link 78 0 1
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"link(e,head)":rec:link(e,head) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"link(e,head)":rec:link(e,head) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"link(e,head)":rec:link(e,head) 
 -- assign:adr.store:A: 
 rswap 0
 rstoreg  EisNone 1
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS remove 113 1 Set 83
 -- vdtTableCopy: I:1:97 I:2:0
 rShiftUp  1
 tstOriginIsNone 
 rstore  1 origin
 -- super remove
 pushThis 
 rpushg iOrigin 1
 rShiftDown  1
 pushThis 
 rstoreg  E 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- DI:gen: "in E: ref elm " DI:isConst: false isBasicValue: false 
 --  primNo: 0 
 rtnAlloc 1
 toSuper 97
DO:
 mvStack 
 L1:
 -- OG:before:super.gen: "
 --  "\nObs! Set:remove:not implemented!\n".print "
 -- INV:gen: ""\nObs! Set:remove:not implemented!\n".print " 
 -- needorigin: ""\nObs! Set:remove:not implemented!\n".print " 
 -- needOrigin:E: "print "  E.ATd: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeatEx: ""\nObs! Set:remove:not implemented!\n" " rec: "
 --  "\nObs! Set:remove:not implemented!\n" " E.ATd: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeatE.ATd.desc: 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])E.ATd.IT: 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- after:needOrigin: ""\nObs! Set:remove:not implemented!\n" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  ""\nObs! Set:remove:not implemented!\n" "E:  "
 --  "\nObs! Set:remove:not implemented!\n" "
 -- INV:gen:E.loadArgs ""\nObs! Set:remove:not implemented!\n" "
 -- INV:gen:after:E.loadArgs ""\nObs! Set:remove:not implemented!\n" "
 --  OIadr: 
 pushText "\nObs! Set:remove:not implemented!\n"
 -- IV:gen:checkTail: ""\nObs! Set:remove:not implemented!\n".print "
 --  E: ""\nObs! Set:remove:not implemented!\n" "tail: "print "
 --   not isLast: false 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "
 --  "\nObs! Set:remove:not implemented!\n" " 
 --  adr:none 
 invoke print 114 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS print 114 1 String 10
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 pushThis 
 -- before objTmpStack:add:  117   "for:to:repeat$117 "
 invoke for:to:repeat$117 117 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS repeat$115 115 1 for:to:repeat$117 117
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "put(get[inx]) "
 -- INV:gen: "put(get[inx]) " 
 -- needorigin: "put(get[inx]) " 
 -- needOrigin:E: "put(get[inx]) "  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put(get[inx]) " rec: "put(get[inx]) " E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  E.ATd.desc: 
 --  %globals
 --  %basic 2
 --  in ch: val char
 --  E.ATd.IT: 
 --  %globals
 --  %basic 2
 --  in ch: val char
 -- \
 --   
 -- Ex:loadOrgin:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put(get[inx]) " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put(get[inx]) "E:  "put(get[inx]) "
 -- INV:gen:E.loadArgs "put(get[inx]) "
 -- NonVirt: "put(get[inx]) " "ObjectInvocation_KeyWord " ActArg: "
 --  get[inx] "isValue: false formalArg: "in ch: val char " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(get[inx]) "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "get[inx] "
 -- INV:gen: "get[inx] " 
 -- needorigin: "get[inx] " 
 -- needOrigin:E: "get[inx] "  E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  Ex: "get[inx] " rec: "get[inx] " E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  E.ATd.desc: 
 --  %basic 117
 --  out ch: var char
 --  E.ATd.IT: 
 --  %basic 117
 --  out ch: var char
 --  
 -- doNeedOrigin:Ex: "get[inx] "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "get[inx] " 
 -- doNeedOrigin:E: "get[inx] " 
 -- computeAdrX:superAdj: 0 "get[inx] " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "get[inx] " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$115 "on: 3 isValueObj: false 
 --  origin: for:to:repeat$117 origin:isValueObj: false 
 rpushg repeat$115$115 1
 -- items:goOrigin:encOG: "for:to:repeat$117 "on: 2 isValueObj: 
 --  false 
 --  origin: print origin:isValueObj: false 
 rpushg for:to:repeat$117$117 4
 -- items:goOrigin:encOG: "print "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg print$114 1
 -- computeAdrX:isLast:E:  "get[inx] "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 --  rec:  "get[inx] "E:  "get[inx] "
 -- INV:gen:E.loadArgs "get[inx] "
 -- NonVirt: "get[inx] " "ObjectInvocation_KeyWord " ActArg: "inx "
 --  isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx] " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "inx "
 -- INV:gen: "inx " 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$115 "on: 1 isValueObj: false 
 --  origin: for:to:repeat$117 origin:isValueObj: false 
 rpushg repeat$115$115 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 3 for:to:repeat$117$117
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- checkNumberConvert: "inx " D: "inx: var integer " 
 -- end:loadArgs:NonVirt: "get[inx] "
 -- INV:gen:after:E.loadArgs "get[inx] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx] "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- ptn:invoke: "get[inx: var integer] "E: "get[inx] "ptnKind: 0 
 --  useRtnV: true 
 xpushg  inx 1 0 1
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "get[inx] ":isBasicVal: true 
 -- case:B: get[inx] ObjectGenerator 3 117 117 false false 
 -- checkNumberConvert: "get[inx] " D: "in ch: val char " 
 -- end:loadArgs:NonVirt: "put(get[inx]) "
 -- INV:gen:after:E.loadArgs "put(get[inx]) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  put(get[inx]) "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put(get[inx]) "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS put 116 0 BETA 2
 pushThis 
 storeg char$7 1
 allocEventQ
 mvStack 
 -- DI:gen: "in ch: val char " DI:isConst: true isBasicValue: true 
 --  primNo: 3 
 -- DI:gen:primitiveType: ch 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS for:to:repeat$117 117 4 print 114
 -- vdtTableCopy: I:1:28 V:2:29
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- NonVirt: 
 --  for(1):to(length):repeat
 --     put(get[inx])
 --  "ObjectInvocation_KeyWord " ActArg: "1 "isValue: true formalArg: "
 --  first: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  for(1):to(length):repeat
 --     put(get[inx])
 --   " isCompositeValueObj: false 
 -- OG:before:super.gen: "1 "
 -- INV:gen: "1 " 
 -- needorigin: "1 " 
 -- needOrigin:E: "1 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "1 " rec: "1 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "1 " 
 -- IV:after:computeAdr:superAdj: 4 
 --  rec:  "1 "E:  "1 "
 -- INV:gen:E.loadArgs "1 "
 -- INV:gen:after:E.loadArgs "1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1 "
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "first: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- checkNumberConvert: "1 " D: "first: var integer " 
 -- end:loadArgs:NonVirt: "for(1):to(length):repeat
 --     put(get[inx])
 --   "
 -- NonVirt: 
 --  for(1):to(length):repeat
 --     put(get[inx])
 --  "ObjectInvocation_KeyWord " ActArg: "length "isValue: false 
 --  formalArg: "last: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  for(1):to(length):repeat
 --     put(get[inx])
 --   " isCompositeValueObj: false 
 -- OG:before:super.gen: "length "
 -- INV:gen: "length " 
 -- needorigin: "length " 
 -- needOrigin:E: "length "  E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  Ex: "length " rec: "length " E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  E.ATd.desc: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  E.ATd.IT: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- doNeedOrigin:Ex: "length "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "length " 
 -- doNeedOrigin:E: "length " 
 -- computeAdrX:superAdj: 4 "length " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "length " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 rpushg print$114 4
 -- items:goOrigin:encOG: "print "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg print$114 1
 -- computeAdrX:isLast:E:  "length "
 -- IV:after:computeAdr:superAdj: 4 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 --  rec:  "length "E:  "length "
 -- INV:gen:E.loadArgs "length "
 -- INV:gen:after:E.loadArgs "length "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- ptn:invoke: "length "E: "length "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "length " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- actualArg:isPtn: true formalArg:isPtn: "last: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "length ":isBasicVal: true 
 -- case:B: length ObjectGenerator 1 0 0 false false 
 -- checkNumberConvert: "length " D: "last: var integer " 
 -- end:loadArgs:NonVirt: "for(1):to(length):repeat
 --     put(get[inx])
 --   "
 pushThis 
 storeg integer$5 2
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- DI:gen: "inx: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: inx 
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0

 CLASS size 118 1 Set 83
 -- vdtTableCopy: I:1:99 I:2:0
 tstOriginIsNone 
 rstore  1 origin
 -- super size
 pushThis 
 rpushg iOrigin 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 rtnAlloc 1
 toSuper 99
DO:
 mvStack 
 L1:
 pushThis 
 -- before objTmpStack:add:  119   "scan$119 "
 invoke scan$119 119 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS scan$119 119 4 size 118
 -- vdtTableCopy: I:1:102 I:2:0
 tstOriginIsNone 
 rstore  4 origin
 -- super scan
 -- computeAdrX:superAdj: 4 "scan " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "scan " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 rpushg size$118 4
 -- items:goOrigin:encOG: "size "on: 1 isValueObj: false 
 --  origin: Set origin:isValueObj: false 
 rpushg size$118 1
 -- computeAdrX:isLast:E:  "scan "
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- DI:gen: "current: ref elm " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 -- DI:gen: "nxt: ref link " DI:isConst: false isBasicValue: false 
 --  primNo: 0 
 rtnAlloc 1
 toSuper 102
DO:
 mvStack 
 L1:
 -- AssignmentStatement:gen: "N := N + 1 " 
 pushThis 
 -- items:goOrigin:encOG: "scan$119 "on: 1 isValueObj: false 
 --  origin: size origin:isValueObj: false 
 rpushg scan$119$119 4
 -- AssignmentStatement:gen: 
 --  "N := N + 1 " right.label: "ObjectGenerator ""N + 1 " 
 -- OG:before:super.gen: "N + 1 "
 -- INV:gen: "N + 1 " 
 -- needorigin: "N + 1 " 
 -- needOrigin:E: "N + 1 "  E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  Ex: "N + 1 " rec: "N + 1 " E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  E.ATd.desc: 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 --  E.ATd.IT: 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 -- \
 --   
 -- doNeedOrigin:Ex: "N + 1 "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "N + 1 " 
 -- doNeedOrigin:E: "N + 1 " 
 -- computeAdrX:superAdj: 0 "N + 1 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "N + 1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "N + 1 "superAdj: 0 
 -- computeAdrX:isLast:E:  "N + 1 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "N + 1 "E:  "N + 1 "
 -- INV:gen:E.loadArgs "N + 1 "
 -- BinaryExp:loadArgs: "N + 1 " superAdj: 0 
 -- INV:gen: "N " 
 -- needorigin: "N " 
 -- needOrigin:E: "N "  E.ATd: "N: var integer " Ex: "N " rec: "N " 
 --  E.ATd: "N: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "N " 
 -- doNeedOrigin:E: "N " 
 -- computeAdrX:superAdj: 0 "N " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "N " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "scan$119 "on: 1 isValueObj: false 
 --  origin: size origin:isValueObj: false 
 rpushg scan$119$119 4
 -- computeAdrX:isLast:E:  "N "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"N":rec:- 
 --  rec:  "N "E:  "N "
 -- INV:gen:E.loadArgs "N "
 -- INV:gen:after:E.loadArgs "N "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "N "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"N":rec:- 
 -- OI:invoke:before:ATdx.invoke: var N 
 -- DI:invoke: "N: var integer " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"N":rec:N isNotRemote: true 
 pushg 2 size$118
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"N":rec:N 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"N":rec:N 
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"N":rec:N 
 -- NonVirt: "+ 1 " "ObjectInvocation_Binary " ActArg: "1 "isValue: 
 --  true formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ 1 " isCompositeValueObj: false 
 -- OG:before:super.gen: "1 "
 -- INV:gen: "1 " 
 -- needorigin: "1 " 
 -- needOrigin:E: "1 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "1 " rec: "1 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "1 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "1 "E:  "1 "
 -- INV:gen:E.loadArgs "1 "
 -- INV:gen:after:E.loadArgs "1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1 "
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- checkNumberConvert: "1 " D: "in V: var integer " 
 -- end:loadArgs:NonVirt: "+ 1 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"N":rec:N 
 -- INV:gen:after:E.loadArgs "N + 1 "
 --  OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"N":rec:N 
 -- IV:E.invoke:useRtnVal: true E: BinOp "N + 1 "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"N":rec:N 
 -- BinaryExp:invoke: "N "rec: "N + 1 "
 -- M: "+ 1 "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"N":rec:N 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- ptn:invoke: "+   "E: "+ 1 "ptnKind: 0 useRtnV: true 
 plus
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:N 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:N 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- checkNumberConvert: "N + 1 " D: "N: var integer " 
 -- assign:adr.store:A: 
 storeg size$118 2
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0

 CLASS clear 120 1 Set 83
 -- vdtTableCopy: I:1:100 I:2:0
 tstOriginIsNone 
 rstore  1 origin
 -- super clear
 pushThis 
 rpushg iOrigin 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 rtnAlloc 1
 toSuper 100
DO:
 mvStack 
 L1:
 -- AssignmentStatement:gen: "head := none " 
 pushThis 
 -- items:goOrigin:encOG: "clear "on: 1 isValueObj: false 
 --  origin: Set origin:isValueObj: false 
 rpushg clear$120 1
 -- AssignmentStatement:gen: 
 --  "head := none " right.label: "ObjectGenerator ""none " 
 -- OG:before:super.gen: "none "
 -- INV:gen: "none " 
 -- needorigin: "none " 
 -- needOrigin:E: "none "  E.ATd: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  Ex: "none " rec: "none " E.ATd: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  E.ATd.desc: 
 --  %basic 19
 --  none_x: var integer
 --  E.ATd.IT: 
 --  %basic 19
 --  none_x: var integer
 --  
 -- doNeedOrigin:Ex: "none "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "none " 
 -- doNeedOrigin:E: "none " 
 -- computeAdrX:superAdj: 0 "none " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "none " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "none "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "none "E:  "none "
 -- INV:gen:E.loadArgs "none "
 -- INV:gen:after:E.loadArgs "none "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "none "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern none 
 -- ptn:invoke: "none "E: "none "ptnKind: 0 useRtnV: true 
 pushNone 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- assign:adr.store:A: 
 rswap 0
 rstoreg  EisNone 1
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0

 CLASS Symbol 72 1 Grammar 71
 pushThis 
 rstoreg  printName 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "id: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: id 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(Symbol) "
 -- INV:gen: "inner(Symbol) " 
 -- needorigin: "inner(Symbol) " 
 -- needOrigin:E: "inner(Symbol) "  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(Symbol) " rec: "inner(Symbol) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  E.ATd.desc: 
 --  %basic 101
 --  in inner: ref Object
 --  E.ATd.IT: 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- doNeedOrigin:Ex: "inner(Symbol) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inner(Symbol) " 
 -- doNeedOrigin:E: "inner(Symbol) " 
 -- computeAdrX:superAdj: 0 "inner(Symbol) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(Symbol) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(Symbol) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Symbol)":rec:- 
 --  rec:  "inner(Symbol) "E:  "inner(Symbol) "
 -- INV:gen:E.loadArgs "inner(Symbol) "
 -- INV:gen:after:E.loadArgs "inner(Symbol) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  inner(Symbol) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Symbol)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(Symbol) "ptnKind: 0 useRtnV: 
 --  false 
 pushThis 
 innerP  4
 rpopThisObj 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Symbol)":rec:inner(Symbol) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Symbol)":rec:inner(Symbol) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Symbol)":rec:inner(Symbol) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS print 121 1 Symbol 72
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(print) "
 -- INV:gen: "inner(print) " 
 -- needorigin: "inner(print) " 
 -- needOrigin:E: "inner(print) "  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(print) " rec: "inner(print) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  E.ATd.desc: 
 --  %basic 101
 --  in inner: ref Object
 --  E.ATd.IT: 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- doNeedOrigin:Ex: "inner(print) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inner(print) " 
 -- doNeedOrigin:E: "inner(print) " 
 -- computeAdrX:superAdj: 0 "inner(print) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(print) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(print) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(print)":rec:- 
 --  rec:  "inner(print) "E:  "inner(print) "
 -- INV:gen:E.loadArgs "inner(print) "
 -- INV:gen:after:E.loadArgs "inner(print) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  inner(print) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(print)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(print) "ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(print)":rec:inner(print) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(print)":rec:inner(print) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(print)":rec:inner(print) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS isTerminal 122 1 Symbol 72
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "out V: var Boolean " DI:isConst: false isBasicValue: 
 --  true primNo: 4 
 -- DI:gen:primitiveType: V 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "inner(isTerminal) "
 -- INV:gen: "inner(isTerminal) " 
 -- needorigin: "inner(isTerminal) " 
 -- needOrigin:E: "inner(isTerminal) "  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(isTerminal) " rec: "inner(isTerminal) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  E.ATd.desc: 
 --  %basic 101
 --  in inner: ref Object
 --  E.ATd.IT: 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- doNeedOrigin:Ex: "inner(isTerminal) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inner(isTerminal) " 
 -- doNeedOrigin:E: "inner(isTerminal) " 
 -- computeAdrX:superAdj: 0 "inner(isTerminal) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(isTerminal) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(isTerminal) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(isTerminal)":rec:- 
 --  rec:  "inner(isTerminal) "E:  "inner(isTerminal) "
 -- INV:gen:E.loadArgs "inner(isTerminal) "
 -- INV:gen:after:E.loadArgs "inner(isTerminal) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  inner(isTerminal) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(isTerminal)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(isTerminal) "ptnKind: 0 useRtnV: 
 --  false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(isTerminal)":rec:inner(isTerminal) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(isTerminal)":rec:inner(isTerminal) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(isTerminal)":rec:inner(isTerminal) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS NonTerminal 73 1 Grammar 71
 -- vdtTableCopy: I:1:72 V:2:121 V:3:122 I:4:0
 rShiftUp  1
 tstOriginIsNone 
 rstore  1 origin
 -- super Symbol
 -- computeAdrX:superAdj: 1 "Symbol " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Symbol " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 rpushg Grammar$71 1
 -- computeAdrX:isLast:E:  "Symbol "
 rShiftDown  1
 pushThis 
 rstoreg  printName 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- DI:gen: "id: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: id 
 rtnAlloc 1
 toSuper 72
DO:
 mvStack 
 L1:
 -- OG:before:super.gen: "nonTerminals.insert(this(Nonterminal)) "
 -- INV:gen: "nonTerminals.insert(this(Nonterminal)) " 
 -- needorigin: "nonTerminals.insert(this(Nonterminal)) " 
 -- needOrigin:E: "insert(this(Nonterminal)) "  E.ATd: 
 --  insert:: 
 --     if has(e).not :then 
 --        head := link(e,head)
 --  Ex: "insert(this(Nonterminal)) " rec: "nonTerminals " E.ATd: 
 --  insert:: 
 --     if has(e).not :then 
 --        head := link(e,head)
 --  E.ATd.desc: 
 --  if has(e).not :then 
 --     head := link(e,head)
 --  E.ATd.IT: 
 --  if has(e).not :then 
 --     head := link(e,head)
 --  
 -- doNeedOrigin:Ex: "insert(this(Nonterminal)) "originIsValueObj: 
 --  false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "insert(this(Nonterminal)) " 
 -- doNeedOrigin:E: "insert(this(Nonterminal)) " 
 -- computeAdrX:superAdj: 0 "
 --  nonTerminals.insert(this(Nonterminal)) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "nonTerminals " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "NonTerminal "on: 1 isValueObj: false 
 --  origin: Grammar origin:isValueObj: false 
 rpushg NonTerminal$73 1
 -- computeAdrX:En: 2 pRec: "nonTerminals " rec: "nonTerminals " E: "
 --  insert(this(Nonterminal)) " 
 --  A.E: none 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "nonTerminals " rec: "
 --  nonTerminals " E: "insert(this(Nonterminal)) " 
 --  rec.ATd: "nonTerminals: obj Set(#Nonterminal) " 
 --  rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  nonTerminals: obj Set(#Nonterminal)
 --     terminals: obj Set(#Terminal)
 --     rules: obj OrderedList(#Rule)
 --     start: ref Nonterminal
 --  recA: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(this(Nonterminal))":rec:- 
 --  pRecA: none 
 -- pRec: "nonTerminals " rec: "nonTerminals " E: "
 --  insert(this(Nonterminal)) " 
 --  false false 
 -- computeAdrX:before:rec:: "nonTerminals " 
 -- OI:invoke:before:ATdx.invoke: obj nonTerminals 
 -- DI:invoke: "nonTerminals: obj Set(#Nonterminal) " 
 -- >Object:unique: false 
 -- Address:loadAdr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(this(Nonterminal))":rec:nonTerminals 
 rpushg NonTerminal$73 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(this(Nonterminal))":rec:nonTerminals 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(this(Nonterminal))":rec:nonTerminals 
 -- computeAdrX:after:rec.invoke: "nonTerminals " 
 -- computeAdrX:isLast:E:  "insert(this(Nonterminal)) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(this(Nonterminal))":rec:nonTerminals 
 --  rec:  "nonTerminals "E:  "insert(this(Nonterminal)) "
 -- INV:gen:E.loadArgs "insert(this(Nonterminal)) "
 -- NonVirt: "insert(this(Nonterminal)) " "
 --  ObjectInvocation_KeyWord " ActArg: "this(Nonterminal) "isValue: false formalArg: "
 --  in e: ref elm " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "insert(this(Nonterminal)) "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "this(Nonterminal) "
 -- INV:gen: "this(Nonterminal) " 
 -- needorigin: "this(Nonterminal) " 
 -- needOrigin:E: "this(Nonterminal) "  E.ATd: 
 --  this: 
 --     %basic 18
 --     in this: ref Object
 --  Ex: "this(Nonterminal) " rec: "this(Nonterminal) " E.ATd: 
 --  this: 
 --     %basic 18
 --     in this: ref Object
 --  E.ATd.desc: 
 --  %basic 18
 --  in this: ref Object
 --  E.ATd.IT: 
 --  %basic 18
 --  in this: ref Object
 --  
 -- doNeedOrigin:Ex: "this(Nonterminal) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "this(Nonterminal) " 
 -- doNeedOrigin:E: "this(Nonterminal) " 
 -- computeAdrX:superAdj: 0 "this(Nonterminal) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "this(Nonterminal) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "this(Nonterminal) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(Nonterminal)":rec:- 
 --  rec:  "this(Nonterminal) "E:  "this(Nonterminal) "
 -- INV:gen:E.loadArgs "this(Nonterminal) "
 -- INV:gen:after:E.loadArgs "this(Nonterminal) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "
 --  this(Nonterminal) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(Nonterminal)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern this 
 -- ptn:invoke: "this "E: "this(Nonterminal) "ptnKind: 0 useRtnV: 
 --  true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "
 --  this(Nonterminal) " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(Nonterminal)":rec:this(Nonterminal) 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(Nonterminal)":rec:this(Nonterminal) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(Nonterminal)":rec:this(Nonterminal) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(Nonterminal)":rec:this(Nonterminal) 
 -- actualArg:isPtn: true formalArg:isPtn: "in e: ref elm "
 --  :isBasicVal: false :valueObj: false 
 --  :actArg: "this(Nonterminal) ":isBasicVal: false 
 -- case:B: this(Nonterminal) ObjectGenerator 0 18 18 false false 
 -- checkNumberConvert: "this(Nonterminal) " D: "in e: ref elm " 
 -- end:loadArgs:NonVirt: "insert(this(Nonterminal)) "
 -- INV:gen:after:E.loadArgs "insert(this(Nonterminal)) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  insert(this(Nonterminal)) "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(this(Nonterminal))":rec:nonTerminals 
 -- OI:invoke:before:ATdx.invoke: pattern insert 
 -- ptn:invoke: "insert "E: "insert(this(Nonterminal)) "ptnKind: 3 
 --  useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 rec: "nonTerminals " 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(this(Nonterminal))":rec:nonTerminals 
 -- isStatic: true rec: "nonTerminals "
 invoke insert 75 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(this(Nonterminal))":rec:nonTerminals 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(this(Nonterminal))":rec:nonTerminals 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(this(Nonterminal))":rec:nonTerminals 
 L2:
 rtnInner  M
 END OSDV:0 objSize:3 isIndexed:0

 CLASS print 123 1 NonTerminal 73
 -- vdtTableCopy: I:1:121 I:2:0
 tstOriginIsNone 
 rstore  1 origin
 -- super print
 pushThis 
 rpushg iOrigin 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 rtnAlloc 1
 toSuper 121
DO:
 mvStack 
 L1:
 -- OG:before:super.gen: "put('<') "
 -- INV:gen: "put('<') " 
 -- needorigin: "put('<') " 
 -- needOrigin:E: "put('<') "  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put('<') " rec: "put('<') " E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  E.ATd.desc: 
 --  %globals
 --  %basic 2
 --  in ch: val char
 --  E.ATd.IT: 
 --  %globals
 --  %basic 2
 --  in ch: val char
 -- \
 --   
 -- Ex:loadOrgin:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put('<') " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put('<') "E:  "put('<') "
 -- INV:gen:E.loadArgs "put('<') "
 -- NonVirt: "put('<') " "ObjectInvocation_KeyWord " ActArg: "'<' "
 --  isValue: true formalArg: "in ch: val char " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put('<') " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "'<' "
 -- INV:gen: "'<' " 
 -- needorigin: "'<' " 
 -- needOrigin:E: "'<' "  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16Ex: "'<' " rec: "'<' " E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16E.ATd.desc: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %publicE.ATd.IT: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 -- after:needOrigin: "'<' " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "'<' "E:  "'<' "
 -- INV:gen:E.loadArgs "'<' "
 -- INV:gen:after:E.loadArgs "'<' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "'<' "
 pushc 60
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "'<' ":isBasicVal: true 
 -- case:B: '<' ObjectGenerator 3 3 3 false true 
 -- checkNumberConvert: "'<' " D: "in ch: val char " 
 -- end:loadArgs:NonVirt: "put('<') "
 -- INV:gen:after:E.loadArgs "put('<') "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  put('<') "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put('<') "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- OG:before:super.gen: "printName.print "
 -- INV:gen: "printName.print " 
 -- needorigin: "printName.print " 
 -- needOrigin:E: "print "  E.ATd: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeatEx: "print " rec: "printName " E.ATd: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeatE.ATd.desc: 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])E.ATd.IT: 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])
 -- doNeedOrigin:Ex: "print "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "print " 
 -- doNeedOrigin:E: "print " 
 -- computeAdrX:superAdj: 0 "printName.print " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "printName " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "print "on: 1 isValueObj: false 
 --  origin: NonTerminal origin:isValueObj: false 
 rpushg print$123 1
 -- computeAdrX:En: 2 pRec: "printName " rec: "printName " E: "
 --  print " 
 --  A.E: none 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "printName " rec: "printName " E: "
 --  print " 
 --  rec.ATd: "printName: var String " rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  id: var integer
 --     print:< 
 --        inner(print)
 --     isTerminal:< 
 --  recA: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:- 
 --  pRecA: none 
 -- pRec: "printName " rec: "printName " E: "print " 
 --  false false 
 -- computeAdrX:before:rec:: "printName " 
 -- OI:invoke:before:ATdx.invoke: var printName 
 -- DI:invoke: "printName: var String " 
 -- >Object:unique: false 
 -- Address:loadAdr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:printName 
 rpushg print$123 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:printName 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:printName 
 -- computeAdrX:after:rec.invoke: "printName " 
 -- computeAdrX:isLast:E:  "print "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:printName 
 --  rec:  "printName "E:  "print "
 -- INV:gen:E.loadArgs "print "
 -- INV:gen:after:E.loadArgs "print "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:printName 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "printName " 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:printName 
 invoke print 114 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:printName 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:printName 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:printName 
 -- OG:before:super.gen: "put('>') "
 -- INV:gen: "put('>') " 
 -- needorigin: "put('>') " 
 -- needOrigin:E: "put('>') "  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put('>') " rec: "put('>') " E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  E.ATd.desc: 
 --  %globals
 --  %basic 2
 --  in ch: val char
 --  E.ATd.IT: 
 --  %globals
 --  %basic 2
 --  in ch: val char
 -- \
 --   
 -- Ex:loadOrgin:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put('>') " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put('>') "E:  "put('>') "
 -- INV:gen:E.loadArgs "put('>') "
 -- NonVirt: "put('>') " "ObjectInvocation_KeyWord " ActArg: "'>' "
 --  isValue: true formalArg: "in ch: val char " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put('>') " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "'>' "
 -- INV:gen: "'>' " 
 -- needorigin: "'>' " 
 -- needOrigin:E: "'>' "  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16Ex: "'>' " rec: "'>' " E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16E.ATd.desc: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %publicE.ATd.IT: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 -- after:needOrigin: "'>' " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "'>' "E:  "'>' "
 -- INV:gen:E.loadArgs "'>' "
 -- INV:gen:after:E.loadArgs "'>' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "'>' "
 pushc 62
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "'>' ":isBasicVal: true 
 -- case:B: '>' ObjectGenerator 3 3 3 false true 
 -- checkNumberConvert: "'>' " D: "in ch: val char " 
 -- end:loadArgs:NonVirt: "put('>') "
 -- INV:gen:after:E.loadArgs "put('>') "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  put('>') "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put('>') "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0

 CLASS nonTerminals 85 0 Grammar 71
 -- vdtTableCopy: I:1:80 V:2:0 V:3:75 V:4:101 V:5:113 V:6:112 V:7:118 V:8:120 I:9:83 I:10:0
 -- super Set
 -- super Set
 allocEventQ
 -- DI:gen: "head: ref link " DI:isConst: false isBasicValue: false 
 --  primNo: 0 
 rtnAlloc 1
 toSuper 80
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0

 CLASS Terminal 86 1 Grammar 71
 -- vdtTableCopy: I:1:72 V:2:121 V:3:122 I:4:0
 rShiftUp  1
 tstOriginIsNone 
 rstore  1 origin
 -- super Symbol
 -- computeAdrX:superAdj: 1 "Symbol " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Symbol " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 rpushg Grammar$71 1
 -- computeAdrX:isLast:E:  "Symbol "
 rShiftDown  1
 pushThis 
 rstoreg  printName 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- DI:gen: "id: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: id 
 rtnAlloc 1
 toSuper 72
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:0 objSize:3 isIndexed:0

 CLASS isTerminal 124 1 Terminal 86
 -- vdtTableCopy: I:1:122 I:2:0
 tstOriginIsNone 
 rstore  1 origin
 -- super isTerminal
 pushThis 
 rpushg iOrigin 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- DI:gen: "out V: var Boolean " DI:isConst: false isBasicValue: 
 --  true primNo: 4 
 -- DI:gen:primitiveType: V 
 rtnAlloc 1
 toSuper 122
DO:
 mvStack 
 L1:
 -- AssignmentStatement:gen: "V := true " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "V := true " right.label: "ObjectGenerator ""true " 
 -- OG:before:super.gen: "true "
 -- INV:gen: "true " 
 -- needorigin: "true " 
 -- needOrigin:E: "true "  E.ATd: 
 --  True: 
 --     %globals
 --     out B: var boolean
 --     B := 1
 --  Ex: "true " rec: "true " E.ATd: 
 --  True: 
 --     %globals
 --     out B: var boolean
 --     B := 1
 --  E.ATd.desc: 
 --  %globals
 --  out B: var boolean
 --  B := 1
 --  E.ATd.IT: 
 --  %globals
 --  out B: var boolean
 --  B := 1
 -- \
 --   
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %globals
 --     out B: var boolean
 --     B := 1
 --  
 -- after:needOrigin: "true " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "true "E:  "true "
 -- INV:gen:E.loadArgs "true "
 -- INV:gen:after:E.loadArgs "true "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "true "
 -- OI:invoke:before:ATdx.invoke: pattern True 
 -- ptn:invoke: "True "E: "true "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "true " 
 --  adr:none 
 invoke True 23 0 0
 -- global:pushOut: B off: 1 
 pushg 1 
 -- callInvoke:after:pushOut: 1 
 -- GeneralPTN:invoke:after:callInvoke: 1 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- checkNumberConvert: "true " D: "out V: var Boolean " 
 -- assign:adr.store:A: 
 storeg isTerminal$124 2
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS print 125 1 Terminal 86
 -- vdtTableCopy: I:1:121 I:2:0
 tstOriginIsNone 
 rstore  1 origin
 -- super print
 pushThis 
 rpushg iOrigin 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 rtnAlloc 1
 toSuper 121
DO:
 mvStack 
 L1:
 -- OG:before:super.gen: "put('"') "
 -- INV:gen: "put('"') " 
 -- needorigin: "put('"') " 
 -- needOrigin:E: "put('"') "  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put('"') " rec: "put('"') " E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  E.ATd.desc: 
 --  %globals
 --  %basic 2
 --  in ch: val char
 --  E.ATd.IT: 
 --  %globals
 --  %basic 2
 --  in ch: val char
 -- \
 --   
 -- Ex:loadOrgin:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put('"') " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put('"') "E:  "put('"') "
 -- INV:gen:E.loadArgs "put('"') "
 -- NonVirt: "put('"') " "ObjectInvocation_KeyWord " ActArg: "'"' "
 --  isValue: true formalArg: "in ch: val char " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put('"') " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "'"' "
 -- INV:gen: "'"' " 
 -- needorigin: "'"' " 
 -- needOrigin:E: "'"' "  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16Ex: "'"' " rec: "'"' " E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16E.ATd.desc: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %publicE.ATd.IT: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 -- after:needOrigin: "'"' " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "'"' "E:  "'"' "
 -- INV:gen:E.loadArgs "'"' "
 -- INV:gen:after:E.loadArgs "'"' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "'"' "
 pushc 34
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "'"' ":isBasicVal: true 
 -- case:B: '"' ObjectGenerator 3 3 3 false true 
 -- checkNumberConvert: "'"' " D: "in ch: val char " 
 -- end:loadArgs:NonVirt: "put('"') "
 -- INV:gen:after:E.loadArgs "put('"') "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  put('"') "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put('"') "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- OG:before:super.gen: "printName.print "
 -- INV:gen: "printName.print " 
 -- needorigin: "printName.print " 
 -- needOrigin:E: "print "  E.ATd: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeatEx: "print " rec: "printName " E.ATd: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeatE.ATd.desc: 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])E.ATd.IT: 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])
 -- doNeedOrigin:Ex: "print "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "print " 
 -- doNeedOrigin:E: "print " 
 -- computeAdrX:superAdj: 0 "printName.print " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "printName " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "print "on: 1 isValueObj: false 
 --  origin: Terminal origin:isValueObj: false 
 rpushg print$125 1
 -- computeAdrX:En: 2 pRec: "printName " rec: "printName " E: "
 --  print " 
 --  A.E: none 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "printName " rec: "printName " E: "
 --  print " 
 --  rec.ATd: "printName: var String " rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  id: var integer
 --     print:< 
 --        inner(print)
 --     isTerminal:< 
 --  recA: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:- 
 --  pRecA: none 
 -- pRec: "printName " rec: "printName " E: "print " 
 --  false false 
 -- computeAdrX:before:rec:: "printName " 
 -- OI:invoke:before:ATdx.invoke: var printName 
 -- DI:invoke: "printName: var String " 
 -- >Object:unique: false 
 -- Address:loadAdr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:printName 
 rpushg print$125 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:printName 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:printName 
 -- computeAdrX:after:rec.invoke: "printName " 
 -- computeAdrX:isLast:E:  "print "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:printName 
 --  rec:  "printName "E:  "print "
 -- INV:gen:E.loadArgs "print "
 -- INV:gen:after:E.loadArgs "print "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:printName 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print "E: "print "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "printName " 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:printName 
 invoke print 114 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:printName 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:printName 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:printName 
 -- OG:before:super.gen: "put('"') "
 -- INV:gen: "put('"') " 
 -- needorigin: "put('"') " 
 -- needOrigin:E: "put('"') "  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put('"') " rec: "put('"') " E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  E.ATd.desc: 
 --  %globals
 --  %basic 2
 --  in ch: val char
 --  E.ATd.IT: 
 --  %globals
 --  %basic 2
 --  in ch: val char
 -- \
 --   
 -- Ex:loadOrgin:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put('"') " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put('"') "E:  "put('"') "
 -- INV:gen:E.loadArgs "put('"') "
 -- NonVirt: "put('"') " "ObjectInvocation_KeyWord " ActArg: "'"' "
 --  isValue: true formalArg: "in ch: val char " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put('"') " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "'"' "
 -- INV:gen: "'"' " 
 -- needorigin: "'"' " 
 -- needOrigin:E: "'"' "  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16Ex: "'"' " rec: "'"' " E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16E.ATd.desc: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %publicE.ATd.IT: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 -- after:needOrigin: "'"' " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "'"' "E:  "'"' "
 -- INV:gen:E.loadArgs "'"' "
 -- INV:gen:after:E.loadArgs "'"' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "'"' "
 pushc 34
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "'"' ":isBasicVal: true 
 -- case:B: '"' ObjectGenerator 3 3 3 false true 
 -- checkNumberConvert: "'"' " D: "in ch: val char " 
 -- end:loadArgs:NonVirt: "put('"') "
 -- INV:gen:after:E.loadArgs "put('"') "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  put('"') "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put('"') "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0

 CLASS terminals 88 0 Grammar 71
 -- vdtTableCopy: I:1:80 V:2:0 V:3:75 V:4:101 V:5:113 V:6:112 V:7:118 V:8:120 I:9:83 I:10:0
 -- super Set
 -- super Set
 allocEventQ
 -- DI:gen: "head: ref link " DI:isConst: false isBasicValue: false 
 --  primNo: 0 
 rtnAlloc 1
 toSuper 80
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0

 CLASS OrderedList 92 0 OrderedList 39
 -- vdtTableCopy: I:1:80 V:2:0 V:3:74 V:4:96 V:5:97 V:6:98 V:7:99 V:8:100 I:9:0
 -- super Collection
 allocEventQ
 -- DI:gen: "head: ref link:next " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 -- DI:gen: "tail: ref Link:next " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 rtnAlloc 1
 toSuper 80
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS has 126 1 OrderedList 92
 -- vdtTableCopy: I:1:96 I:2:0
 rShiftUp  1
 tstOriginIsNone 
 rstore  1 origin
 -- super has
 pushThis 
 rpushg iOrigin 1
 rShiftDown  1
 pushThis 
 rstoreg  E 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- DI:gen: "in E: ref elm " DI:isConst: false isBasicValue: false 
 --  primNo: 0 
 -- DI:gen: "out B: var boolean " DI:isConst: false isBasicValue: 
 --  true primNo: 4 
 -- DI:gen:primitiveType: B 
 rtnAlloc 1
 toSuper 96
DO:
 mvStack 
 L1:
 -- AssignmentStatement:gen: "B := false " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "B := false " right.label: "ObjectGenerator ""false " 
 -- OG:before:super.gen: "false "
 -- INV:gen: "false " 
 -- needorigin: "false " 
 -- needOrigin:E: "false "  E.ATd: 
 --  False: 
 --     %globals
 --     out B: var boolean
 --     B := 0
 --  Ex: "false " rec: "false " E.ATd: 
 --  False: 
 --     %globals
 --     out B: var boolean
 --     B := 0
 --  E.ATd.desc: 
 --  %globals
 --  out B: var boolean
 --  B := 0
 --  E.ATd.IT: 
 --  %globals
 --  out B: var boolean
 --  B := 0
 -- \
 --   
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %globals
 --     out B: var boolean
 --     B := 0
 --  
 -- after:needOrigin: "false " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "false "E:  "false "
 -- INV:gen:E.loadArgs "false "
 -- INV:gen:after:E.loadArgs "false "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "false "
 -- OI:invoke:before:ATdx.invoke: pattern False 
 -- ptn:invoke: "False "E: "false "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "false " 
 --  adr:none 
 invoke False 27 0 0
 -- global:pushOut: B off: 1 
 pushg 1 
 -- callInvoke:after:pushOut: 1 
 -- GeneralPTN:invoke:after:callInvoke: 1 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- checkNumberConvert: "false " D: "out B: var boolean " 
 -- assign:adr.store:A: 
 storeg has$126 3
 -- assign:adr.store:B: 
 pushThis 
 -- before objTmpStack:add:  129   "scan$129 "
 invoke scan$129 129 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 rtnInner  M
 END OSDV:0 objSize:3 isIndexed:0

 CLASS scan 127 1 OrderedList 92
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "current: ref elm " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 -- DI:gen: "nxt: ref Link:next " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "nxt := head " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "nxt := head " right.label: "ObjectGenerator ""head " 
 -- OG:before:super.gen: "head "
 -- INV:gen: "head " 
 -- needorigin: "head " 
 -- needOrigin:E: "head "  E.ATd: "head: ref link:next " Ex: "head " 
 --  rec: "head " E.ATd: "head: ref link:next " E.ATd.desc: 
 --  %id "link:next"
 --  ...
 --  E.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "head " 
 -- doNeedOrigin:E: "head " 
 -- computeAdrX:superAdj: 0 "head " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "head " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "scan "on: 1 isValueObj: false 
 --  origin: OrderedList origin:isValueObj: false 
 rpushg scan$127 1
 -- computeAdrX:isLast:E:  "head "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "head "E:  "head "
 -- INV:gen:E.loadArgs "head "
 -- INV:gen:after:E.loadArgs "head "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "head "
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: ref head 
 -- DI:invoke: "head: ref link:next " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head isNotRemote: true 
 rpushg OrderedList$92 1
 -- OI:invoke:V: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- OI:invoke:X: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- INV:gen:end:off: 1 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- assign:adr.store:A: 
 rswap 0
 rstoreg  EisNone 3
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- assign:adr.store:B: 
 pushThis 
 -- before objTmpStack:add:  131   "loop "
 invoke loop 131 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS link:next 128 1 OrderedList 92
 pushThis 
 rstoreg  next 3
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 pushThis 
 rstoreg  E 2
   ;; vTop(0,0)=[] rTop(-4,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS loop 131 1 scan 127
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "
 --  if (nxt =/= none) :then 
 --     current := nxt.E
 --     inner(scan)
 --     nxt := nxt.next
 --     restart(loop) "
 -- INV:gen: 
 --  if (nxt =/= none) :then 
 --     current := nxt.E
 --     inner(scan)
 --     nxt := nxt.next
 -- needorigin: 
 --  if (nxt =/= none) :then 
 --     current := nxt.E
 --     inner(scan)
 --     nxt := nxt.next
 -- needOrigin:E: 
 --  if (nxt =/= none) :then 
 --     current := nxt.E
 --     inner(scan)
 --     nxt := nxt.next E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (nxt =/= none) :then 
 --     current := nxt.E
 --     inner(scan)
 --     nxt := nxt.nextrec: 
 --  if (nxt =/= none) :then 
 --     current := nxt.E
 --     inner(scan)
 --     nxt := nxt.nextE.ATd: 
 -- \
 --   if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  E.ATd.desc: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  E.ATd.IT: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (nxt =/= none) :then 
 --     current := nxt.E
 --     inner(scan)
 --     nxt := nxt.next
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "
 --  if (nxt =/= none) :then 
 --     current := nxt.E
 --     inner(scan)
 --     nxt := nxt.next
 --     restart(loop) "E:  "
 --  if (nxt =/= none) :then 
 --     current := nxt.E
 --     inner(scan)
 --     nxt := nxt.next
 --     restart(loop) "
 -- INV:gen:E.loadArgs "
 --  if (nxt =/= none) :then 
 --     current := nxt.E
 --     inner(scan)
 --     nxt := nxt.next
 --     restart(loop) "
 -- INV:gen:after:E.loadArgs "
 --  if (nxt =/= none) :then 
 --     current := nxt.E
 --     inner(scan)
 --     nxt := nxt.next
 --     restart(loop) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "
 --  if (nxt =/= none) :then 
 --     current := nxt.E
 --     inner(scan)
 --     nxt := nxt.next
 --     restart(loop) "
 -- OG:before:super.gen: "(nxt =/= none) "
 -- INV:gen: "(nxt =/= none) " 
 -- needorigin: "(nxt =/= none) " 
 -- needOrigin:E: "(nxt =/= none) "  E.ATd: 
 --  =/=  : 
 --     %basic 57
 --     in objx: ref Object
 --     out V: var boolean
 --  Ex: "(nxt =/= none) " rec: "(nxt =/= none) " E.ATd: 
 --  =/=  : 
 --     %basic 57
 --     in objx: ref Object
 --     out V: var boolean
 --  E.ATd.desc: 
 --  %basic 57
 --  in objx: ref Object
 --  out V: var boolean
 --  E.ATd.IT: 
 --  %basic 57
 --  in objx: ref Object
 --  out V: var boolean
 -- \
 --   
 -- doNeedOrigin:Ex: "(nxt =/= none) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(nxt =/= none) " 
 -- doNeedOrigin:E: "(nxt =/= none) " 
 -- computeAdrX:superAdj: 0 "(nxt =/= none) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(nxt =/= none) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "nxt =/= none "superAdj: 0 
 -- BE:loadOrigin:E: nxt =/= none 
 -- computeAdrX:isLast:E:  "nxt =/= none "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "nxt =/= none "E:  "nxt =/= none "
 -- INV:gen:E.loadArgs "nxt =/= none "
 -- BinaryExp:loadArgs: "nxt =/= none " superAdj: 0 
 -- INV:gen: "nxt " 
 -- needorigin: "nxt " 
 -- needOrigin:E: "nxt "  E.ATd: "nxt: ref Link:next " Ex: "nxt " 
 --  rec: "nxt " E.ATd: "nxt: ref Link:next " E.ATd.desc: 
 --  %id "link:next"
 --  ...
 --  E.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "nxt " 
 -- doNeedOrigin:E: "nxt " 
 -- computeAdrX:superAdj: 0 "nxt " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "nxt " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: scan origin:isValueObj: false 
 rpushg loop$131 1
 -- computeAdrX:isLast:E:  "nxt "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "nxt "E:  "nxt "
 -- INV:gen:E.loadArgs "nxt "
 -- INV:gen:after:E.loadArgs "nxt "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "nxt "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: ref nxt 
 -- DI:invoke: "nxt: ref Link:next " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"nxt":rec:nxt isNotRemote: true 
 rpushg scan$127 3
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"nxt":rec:nxt 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"nxt":rec:nxt 
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"nxt":rec:nxt 
 -- NonVirt: "=/= none " "ObjectInvocation_Binary " ActArg: "none "
 --  isValue: false formalArg: "in objx: ref Object " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "=/= none " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "none "
 -- INV:gen: "none " 
 -- needorigin: "none " 
 -- needOrigin:E: "none "  E.ATd: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  Ex: "none " rec: "none " E.ATd: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  E.ATd.desc: 
 --  %basic 19
 --  none_x: var integer
 --  E.ATd.IT: 
 --  %basic 19
 --  none_x: var integer
 --  
 -- doNeedOrigin:Ex: "none "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "none " 
 -- doNeedOrigin:E: "none " 
 -- computeAdrX:superAdj: 0 "none " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "none " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "none "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "none "E:  "none "
 -- INV:gen:E.loadArgs "none "
 -- INV:gen:after:E.loadArgs "none "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "none "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern none 
 -- ptn:invoke: "none "E: "none "ptnKind: 0 useRtnV: true 
 pushNone 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- actualArg:isPtn: true formalArg:isPtn: "in objx: ref Object "
 --  :isBasicVal: false :valueObj: false 
 --  :actArg: "none ":isBasicVal: false 
 -- case:B: none ObjectGenerator 64 19 19 false false 
 -- checkNumberConvert: "none " D: "in objx: ref Object " 
 -- end:loadArgs:NonVirt: "=/= none "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"nxt":rec:nxt 
 -- INV:gen:after:E.loadArgs "nxt =/= none "
 --  OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"nxt":rec:nxt 
 -- IV:E.invoke:useRtnVal: true E: BinOp "nxt =/= none "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"nxt":rec:nxt 
 -- BinaryExp:invoke: "nxt "rec: "nxt =/= none "
 -- M: "=/= none "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"nxt":rec:nxt 
 -- OI:invoke:before:ATdx.invoke: pattern =/=   
 -- ptn:invoke: "=/=   "E: "=/= none "ptnKind: 0 useRtnV: true 
 rne
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"=/= none":rec:nxt 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"=/= none":rec:nxt 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  132   "$132 "
 invoke $132 132 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $132 132 1 loop 131
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "current := nxt.E " 
 pushThis 
 -- items:goOrigin:encOG: "$132 "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $132$132 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: scan origin:isValueObj: false 
 rpushg loop$131 1
 -- AssignmentStatement:gen: 
 --  "current := nxt.E " right.label: "ObjectGenerator ""nxt.E " 
 -- OG:before:super.gen: "nxt.E "
 -- INV:gen: "nxt.E " 
 -- needorigin: "nxt.E " 
 -- needOrigin:E: "E "  E.ATd: "E: ref Elm " Ex: none rec: "nxt " 
 --  E.ATd: "E: ref Elm " E.ATd.desc: 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : E.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "E " 
 -- doNeedOrigin:E: "E " 
 -- computeAdrX:superAdj: 0 "nxt.E " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "nxt " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$132 "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $132$132 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: scan origin:isValueObj: false 
 rpushg loop$131 1
 -- computeAdrX:En: 2 pRec: "nxt " rec: "nxt " E: "E " 
 --  A.E: none 
 --  
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "nxt " rec: "nxt " E: "E " 
 --  rec.ATd: "nxt: ref Link:next " rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  current: ref elm
 --     nxt: ref Link:next
 --     nxt := head
 --     loop: do 
 --  recA: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"E":rec:- 
 --  pRecA: none 
 -- pRec: "nxt " rec: "nxt " E: "E " 
 --  false false 
 -- computeAdrX:before:rec:: "nxt " 
 -- OI:invoke:before:ATdx.invoke: ref nxt 
 -- DI:invoke: "nxt: ref Link:next " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"E":rec:nxt isNotRemote: false 
 rpushg $132$132 3
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"E":rec:nxt 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"E":rec:nxt 
 -- computeAdrX:after:rec.invoke: "nxt " 
 -- computeAdrX:isLast:E:  "E "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "nxt "E:  "E "
 -- INV:gen:E.loadArgs "E "
 -- INV:gen:after:E.loadArgs "E "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "E "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: ref E 
 -- DI:invoke: "E: ref Elm " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"E":rec:nxt isNotRemote: false 
 rpushg $132$132 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"E":rec:nxt 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"E":rec:nxt 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"E":rec:nxt 
 -- assign:adr.store:A: 
 rswap 0
 rstoreg  EisNone 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "inner(scan) "
 -- INV:gen: "inner(scan) " 
 -- needorigin: "inner(scan) " 
 -- needOrigin:E: "inner(scan) "  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(scan) " rec: "inner(scan) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  E.ATd.desc: 
 --  %basic 101
 --  in inner: ref Object
 --  E.ATd.IT: 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- doNeedOrigin:Ex: "inner(scan) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inner(scan) " 
 -- doNeedOrigin:E: "inner(scan) " 
 -- computeAdrX:superAdj: 0 "inner(scan) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(scan) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inner(scan) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(scan)":rec:- 
 --  rec:  "inner(scan) "E:  "inner(scan) "
 -- INV:gen:E.loadArgs "inner(scan) "
 -- INV:gen:after:E.loadArgs "inner(scan) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  inner(scan) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(scan)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner "E: "inner(scan) "ptnKind: 0 useRtnV: false 
 pushThis 
 -- items:goOrigin:encOG: "$132 "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $132$132 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: scan origin:isValueObj: false 
 rpushg loop$131 1
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(scan)":rec:inner(scan) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(scan)":rec:inner(scan) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(scan)":rec:inner(scan) 
 -- AssignmentStatement:gen: "nxt := nxt.next " 
 pushThis 
 -- items:goOrigin:encOG: "$132 "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $132$132 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: scan origin:isValueObj: false 
 rpushg loop$131 1
 -- AssignmentStatement:gen: 
 --  "nxt := nxt.next " right.label: "ObjectGenerator ""nxt.next " 
 -- OG:before:super.gen: "nxt.next "
 -- INV:gen: "nxt.next " 
 -- needorigin: "nxt.next " 
 -- needOrigin:E: "next "  E.ATd: "next: ref Link:next " Ex: none 
 --  rec: "nxt " E.ATd: "next: ref Link:next " E.ATd.desc: 
 --  %id "link:next"
 --  ...
 --  E.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "next " 
 -- doNeedOrigin:E: "next " 
 -- computeAdrX:superAdj: 0 "nxt.next " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "nxt " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$132 "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $132$132 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: scan origin:isValueObj: false 
 rpushg loop$131 1
 -- computeAdrX:En: 2 pRec: "nxt " rec: "nxt " E: "next " 
 --  A.E: none 
 --  
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "nxt " rec: "nxt " E: "next " 
 --  rec.ATd: "nxt: ref Link:next " rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  current: ref elm
 --     nxt: ref Link:next
 --     nxt := head
 --     loop: do 
 --  recA: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"next":rec:- 
 --  pRecA: none 
 -- pRec: "nxt " rec: "nxt " E: "next " 
 --  false false 
 -- computeAdrX:before:rec:: "nxt " 
 -- OI:invoke:before:ATdx.invoke: ref nxt 
 -- DI:invoke: "nxt: ref Link:next " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"next":rec:nxt isNotRemote: false 
 rpushg $132$132 3
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"next":rec:nxt 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"next":rec:nxt 
 -- computeAdrX:after:rec.invoke: "nxt " 
 -- computeAdrX:isLast:E:  "next "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "nxt "E:  "next "
 -- INV:gen:E.loadArgs "next "
 -- INV:gen:after:E.loadArgs "next "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "next "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: ref next 
 -- DI:invoke: "next: ref Link:next " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"next":rec:nxt isNotRemote: false 
 rpushg $132$132 3
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"next":rec:nxt 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"next":rec:nxt 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"next":rec:nxt 
 -- assign:adr.store:A: 
 rswap 0
 rstoreg  EisNone 3
   ;; vTop(0,0)=[] rTop(-4,0)=[]
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "restart(loop) "
 -- INV:gen: "restart(loop) " 
 -- needorigin: "restart(loop) " 
 -- needOrigin:E: "restart(loop) "  E.ATd: 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  Ex: "restart(loop) " rec: "restart(loop) " E.ATd: 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  E.ATd.desc: "%basic 102 " E.ATd.IT: "%basic 102 " 
 -- doNeedOrigin:Ex: "restart(loop) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "restart(loop) " 
 -- doNeedOrigin:E: "restart(loop) " 
 -- computeAdrX:superAdj: 0 "restart(loop) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "restart(loop) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "restart(loop) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:- 
 --  rec:  "restart(loop) "E:  "restart(loop) "
 -- INV:gen:E.loadArgs "restart(loop) "
 -- INV:gen:after:E.loadArgs "restart(loop) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  restart(loop) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern restart(V: var integer) 
 -- ptn:invoke: "restart(V: var integer) "E: "restart(loop) "
 --  ptnKind: 0 useRtnV: false 
 break  1 1 131 0
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS scan$129 129 4 has 126
 -- vdtTableCopy: I:1:127 I:2:0
 tstOriginIsNone 
 rstore  4 origin
 -- super scan
 -- computeAdrX:superAdj: 4 "scan " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "scan " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 rpushg has$126 4
 -- items:goOrigin:encOG: "has "on: 1 isValueObj: false 
 --  origin: OrderedList origin:isValueObj: false 
 rpushg has$126 1
 -- computeAdrX:isLast:E:  "scan "
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- DI:gen: "current: ref elm " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 -- DI:gen: "nxt: ref Link:next " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 rtnAlloc 1
 toSuper 127
DO:
 mvStack 
 L1:
 -- OG:before:super.gen: "
 --  if (current == e) :then 
 --     B := true
 --     leave(has) "
 -- INV:gen: 
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  
 -- needorigin: 
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  
 -- needOrigin:E: 
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  rec: 
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  E.ATd: 
 -- \
 --   if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  E.ATd.desc: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  E.ATd.IT: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (current == e) :then 
 --     B := true
 --     leave(has)
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "if (current == e) :then 
 --     B := true
 --     leave(has) "E:  "
 --  if (current == e) :then 
 --     B := true
 --     leave(has) "
 -- INV:gen:E.loadArgs "
 --  if (current == e) :then 
 --     B := true
 --     leave(has) "
 -- INV:gen:after:E.loadArgs "
 --  if (current == e) :then 
 --     B := true
 --     leave(has) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "
 --  if (current == e) :then 
 --     B := true
 --     leave(has) "
 -- OG:before:super.gen: "(current == e) "
 -- INV:gen: "(current == e) " 
 -- needorigin: "(current == e) " 
 -- needOrigin:E: "(current == e) "  E.ATd: 
 --  ==  : 
 --     %basic 56
 --     in objx: ref Object
 --     out V: var boolean
 --  Ex: "(current == e) " rec: "(current == e) " E.ATd: 
 --  ==  : 
 --     %basic 56
 --     in objx: ref Object
 --     out V: var boolean
 --  E.ATd.desc: 
 --  %basic 56
 --  in objx: ref Object
 --  out V: var boolean
 --  E.ATd.IT: 
 --  %basic 56
 --  in objx: ref Object
 --  out V: var boolean
 -- \
 --   
 -- doNeedOrigin:Ex: "(current == e) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(current == e) " 
 -- doNeedOrigin:E: "(current == e) " 
 -- computeAdrX:superAdj: 0 "(current == e) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(current == e) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "current == e "superAdj: 0 
 -- BE:loadOrigin:E: current == e 
 -- computeAdrX:isLast:E:  "current == e "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "current == e "E:  "current == e "
 -- INV:gen:E.loadArgs "current == e "
 -- BinaryExp:loadArgs: "current == e " superAdj: 0 
 -- INV:gen: "current " 
 -- needorigin: "current " 
 -- needOrigin:E: "current "  E.ATd: "current: ref elm " Ex: "
 --  current " rec: "current " E.ATd: "current: ref elm " E.ATd.desc: 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : E.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "current " 
 -- doNeedOrigin:E: "current " 
 -- computeAdrX:superAdj: 0 "current " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "current " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "current "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "current "E:  "current "
 -- INV:gen:E.loadArgs "current "
 -- INV:gen:after:E.loadArgs "current "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "current "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: ref current 
 -- DI:invoke: "current: ref elm " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"current":rec:current isNotRemote: true 
 rpushg scan$129$129 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"current":rec:current 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"current":rec:current 
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"current":rec:current 
 -- NonVirt: "== e " "ObjectInvocation_Binary " ActArg: "e "isValue: 
 --  false formalArg: "in objx: ref Object " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "== e " isCompositeValueObj: false 
 -- OG:before:super.gen: "e "
 -- INV:gen: "e " 
 -- needorigin: "e " 
 -- needOrigin:E: "e "  E.ATd: "in E: ref elm " Ex: "e " rec: "e " 
 --  E.ATd: "in E: ref elm " E.ATd.desc: 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : E.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "e " 
 -- doNeedOrigin:E: "e " 
 -- computeAdrX:superAdj: 0 "e " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "e " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "scan$129 "on: 1 isValueObj: false 
 --  origin: has origin:isValueObj: false 
 rpushg scan$129$129 4
 -- computeAdrX:isLast:E:  "e "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "e "E:  "e "
 -- INV:gen:E.loadArgs "e "
 -- INV:gen:after:E.loadArgs "e "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "e "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: ref E 
 -- DI:invoke: "in E: ref elm " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"e":rec:e isNotRemote: true 
 rpushg has$126 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"e":rec:e 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"e":rec:e 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"e":rec:e 
 -- actualArg:isPtn: false formalArg:isPtn: "in objx: ref Object "
 --  :isBasicVal: false :valueObj: false 
 --  :actArg: "e ":isBasicVal: false 
 -- case:B: e ObjectGenerator 64 0 64 false false 
 -- checkNumberConvert: "e " D: "in objx: ref Object " 
 -- end:loadArgs:NonVirt: "== e "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"current":rec:current 
 -- INV:gen:after:E.loadArgs "current == e "
 --  OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"current":rec:current 
 -- IV:E.invoke:useRtnVal: true E: BinOp "current == e "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"current":rec:current 
 -- BinaryExp:invoke: "current "rec: "current == e "
 -- M: "== e "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"current":rec:current 
 -- OI:invoke:before:ATdx.invoke: pattern ==   
 -- ptn:invoke: "==   "E: "== e "ptnKind: 0 useRtnV: true 
 req
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"== e":rec:current 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"== e":rec:current 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  130   "$130 "
 invoke $130 130 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 rtnInner  M
 END OSDV:0 objSize:4 isIndexed:0

 CLASS $130 130 1 scan$129 129
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "B := true " 
 pushThis 
 -- items:goOrigin:encOG: "$130 "on: 2 isValueObj: false 
 --  origin: scan$129 origin:isValueObj: false 
 rpushg $130$130 1
 -- items:goOrigin:encOG: "scan$129 "on: 1 isValueObj: false 
 --  origin: has origin:isValueObj: false 
 rpushg scan$129$129 4
 -- AssignmentStatement:gen: 
 --  "B := true " right.label: "ObjectGenerator ""true " 
 -- OG:before:super.gen: "true "
 -- INV:gen: "true " 
 -- needorigin: "true " 
 -- needOrigin:E: "true "  E.ATd: 
 --  True: 
 --     %globals
 --     out B: var boolean
 --     B := 1
 --  Ex: "true " rec: "true " E.ATd: 
 --  True: 
 --     %globals
 --     out B: var boolean
 --     B := 1
 --  E.ATd.desc: 
 --  %globals
 --  out B: var boolean
 --  B := 1
 --  E.ATd.IT: 
 --  %globals
 --  out B: var boolean
 --  B := 1
 -- \
 --   
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %globals
 --     out B: var boolean
 --     B := 1
 --  
 -- after:needOrigin: "true " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "true "E:  "true "
 -- INV:gen:E.loadArgs "true "
 -- INV:gen:after:E.loadArgs "true "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "true "
 -- OI:invoke:before:ATdx.invoke: pattern True 
 -- ptn:invoke: "True "E: "true "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "true " 
 --  adr:none 
 invoke True 23 0 0
 -- global:pushOut: B off: 1 
 pushg 1 
 -- callInvoke:after:pushOut: 1 
 -- GeneralPTN:invoke:after:callInvoke: 1 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- checkNumberConvert: "true " D: "out B: var boolean " 
 -- assign:adr.store:A: 
 storeg has$126 3
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "leave(has) "
 -- INV:gen: "leave(has) " 
 -- needorigin: "leave(has) " 
 -- needOrigin:E: "leave(has) "  E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  Ex: "leave(has) " rec: "leave(has) " E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  E.ATd.desc: "%basic 103 " E.ATd.IT: "%basic 103 " 
 -- doNeedOrigin:Ex: "leave(has) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "leave(has) " 
 -- doNeedOrigin:E: "leave(has) " 
 -- computeAdrX:superAdj: 0 "leave(has) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "leave(has) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "leave(has) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(has)":rec:- 
 --  rec:  "leave(has) "E:  "leave(has) "
 -- INV:gen:E.loadArgs "leave(has) "
 -- INV:gen:after:E.loadArgs "leave(has) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  leave(has) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(has)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- ptn:invoke: "leave(V: var integer) "E: "leave(has) "ptnKind: 0 
 --  useRtnV: false 
 break  2 2 96 1
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(has)":rec:leave(has) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(has)":rec:leave(has) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(has)":rec:leave(has) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS isEmpty 133 1 OrderedList 92
 -- vdtTableCopy: I:1:98 I:2:0
 tstOriginIsNone 
 rstore  1 origin
 -- super isEmpty
 pushThis 
 rpushg iOrigin 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 rtnAlloc 1
 toSuper 98
DO:
 mvStack 
 L1:
 -- AssignmentStatement:gen: "B := head == none " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "B := head == none " right.label: "ObjectGenerator ""
 --  head == none " 
 -- OG:before:super.gen: "head == none "
 -- INV:gen: "head == none " 
 -- needorigin: "head == none " 
 -- needOrigin:E: "head == none "  E.ATd: 
 --  ==  : 
 --     %basic 56
 --     in objx: ref Object
 --     out V: var boolean
 --  Ex: "head == none " rec: "head == none " E.ATd: 
 --  ==  : 
 --     %basic 56
 --     in objx: ref Object
 --     out V: var boolean
 --  E.ATd.desc: 
 --  %basic 56
 --  in objx: ref Object
 --  out V: var boolean
 --  E.ATd.IT: 
 --  %basic 56
 --  in objx: ref Object
 --  out V: var boolean
 -- \
 --   
 -- doNeedOrigin:Ex: "head == none "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "head == none " 
 -- doNeedOrigin:E: "head == none " 
 -- computeAdrX:superAdj: 0 "head == none " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "head == none " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "head == none "superAdj: 0 
 -- computeAdrX:isLast:E:  "head == none "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "head == none "E:  "head == none "
 -- INV:gen:E.loadArgs "head == none "
 -- BinaryExp:loadArgs: "head == none " superAdj: 0 
 -- INV:gen: "head " 
 -- needorigin: "head " 
 -- needOrigin:E: "head "  E.ATd: "head: ref link:next " Ex: "head " 
 --  rec: "head " E.ATd: "head: ref link:next " E.ATd.desc: 
 --  %id "link:next"
 --  ...
 --  E.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "head " 
 -- doNeedOrigin:E: "head " 
 -- computeAdrX:superAdj: 0 "head " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "head " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "isEmpty "on: 1 isValueObj: false 
 --  origin: OrderedList origin:isValueObj: false 
 rpushg isEmpty$133 1
 -- computeAdrX:isLast:E:  "head "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "head "E:  "head "
 -- INV:gen:E.loadArgs "head "
 -- INV:gen:after:E.loadArgs "head "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "head "
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: ref head 
 -- DI:invoke: "head: ref link:next " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head isNotRemote: true 
 rpushg OrderedList$92 1
 -- OI:invoke:V: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- OI:invoke:X: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- INV:gen:end:off: 1 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- NonVirt: "== none " "ObjectInvocation_Binary " ActArg: "none "
 --  isValue: false formalArg: "in objx: ref Object " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "== none " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "none "
 -- INV:gen: "none " 
 -- needorigin: "none " 
 -- needOrigin:E: "none "  E.ATd: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  Ex: "none " rec: "none " E.ATd: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  E.ATd.desc: 
 --  %basic 19
 --  none_x: var integer
 --  E.ATd.IT: 
 --  %basic 19
 --  none_x: var integer
 --  
 -- doNeedOrigin:Ex: "none "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "none " 
 -- doNeedOrigin:E: "none " 
 -- computeAdrX:superAdj: 0 "none " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "none " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "none "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "none "E:  "none "
 -- INV:gen:E.loadArgs "none "
 -- INV:gen:after:E.loadArgs "none "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "none "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern none 
 -- ptn:invoke: "none "E: "none "ptnKind: 0 useRtnV: true 
 pushNone 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- actualArg:isPtn: true formalArg:isPtn: "in objx: ref Object "
 --  :isBasicVal: false :valueObj: false 
 --  :actArg: "none ":isBasicVal: false 
 -- case:B: none ObjectGenerator 64 19 19 false false 
 -- checkNumberConvert: "none " D: "in objx: ref Object " 
 -- end:loadArgs:NonVirt: "== none "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- INV:gen:after:E.loadArgs "head == none "
 --  OIadr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- IV:E.invoke:useRtnVal: true E: BinOp "head == none "
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- BinaryExp:invoke: "head "rec: "head == none "
 -- M: "== none "
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- OI:invoke:before:ATdx.invoke: pattern ==   
 -- ptn:invoke: "==   "E: "== none "ptnKind: 0 useRtnV: true 
 req
 -- OI:invoke:V: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"== none":rec:head 
 -- OI:invoke:X: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"== none":rec:head 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- checkNumberConvert: "head == none " D: "B: var Boolean " 
 -- assign:adr.store:A: 
 storeg isEmpty$133 2
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS size 134 1 OrderedList 92
 -- vdtTableCopy: I:1:99 I:2:0
 tstOriginIsNone 
 rstore  1 origin
 -- super size
 pushThis 
 rpushg iOrigin 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 rtnAlloc 1
 toSuper 99
DO:
 mvStack 
 L1:
 pushThis 
 -- before objTmpStack:add:  135   "scan$135 "
 invoke scan$135 135 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS scan$135 135 4 size 134
 -- vdtTableCopy: I:1:127 I:2:0
 tstOriginIsNone 
 rstore  4 origin
 -- super scan
 -- computeAdrX:superAdj: 4 "scan " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "scan " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 rpushg size$134 4
 -- items:goOrigin:encOG: "size "on: 1 isValueObj: false 
 --  origin: OrderedList origin:isValueObj: false 
 rpushg size$134 1
 -- computeAdrX:isLast:E:  "scan "
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- DI:gen: "current: ref elm " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 -- DI:gen: "nxt: ref Link:next " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 rtnAlloc 1
 toSuper 127
DO:
 mvStack 
 L1:
 -- AssignmentStatement:gen: "N := N + 1 " 
 pushThis 
 -- items:goOrigin:encOG: "scan$135 "on: 1 isValueObj: false 
 --  origin: size origin:isValueObj: false 
 rpushg scan$135$135 4
 -- AssignmentStatement:gen: 
 --  "N := N + 1 " right.label: "ObjectGenerator ""N + 1 " 
 -- OG:before:super.gen: "N + 1 "
 -- INV:gen: "N + 1 " 
 -- needorigin: "N + 1 " 
 -- needOrigin:E: "N + 1 "  E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  Ex: "N + 1 " rec: "N + 1 " E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  E.ATd.desc: 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 --  E.ATd.IT: 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 -- \
 --   
 -- doNeedOrigin:Ex: "N + 1 "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "N + 1 " 
 -- doNeedOrigin:E: "N + 1 " 
 -- computeAdrX:superAdj: 0 "N + 1 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "N + 1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "N + 1 "superAdj: 0 
 -- computeAdrX:isLast:E:  "N + 1 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "N + 1 "E:  "N + 1 "
 -- INV:gen:E.loadArgs "N + 1 "
 -- BinaryExp:loadArgs: "N + 1 " superAdj: 0 
 -- INV:gen: "N " 
 -- needorigin: "N " 
 -- needOrigin:E: "N "  E.ATd: "N: var integer " Ex: "N " rec: "N " 
 --  E.ATd: "N: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "N " 
 -- doNeedOrigin:E: "N " 
 -- computeAdrX:superAdj: 0 "N " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "N " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "scan$135 "on: 1 isValueObj: false 
 --  origin: size origin:isValueObj: false 
 rpushg scan$135$135 4
 -- computeAdrX:isLast:E:  "N "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"N":rec:- 
 --  rec:  "N "E:  "N "
 -- INV:gen:E.loadArgs "N "
 -- INV:gen:after:E.loadArgs "N "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "N "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"N":rec:- 
 -- OI:invoke:before:ATdx.invoke: var N 
 -- DI:invoke: "N: var integer " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"N":rec:N isNotRemote: true 
 pushg 2 size$134
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"N":rec:N 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"N":rec:N 
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"N":rec:N 
 -- NonVirt: "+ 1 " "ObjectInvocation_Binary " ActArg: "1 "isValue: 
 --  true formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ 1 " isCompositeValueObj: false 
 -- OG:before:super.gen: "1 "
 -- INV:gen: "1 " 
 -- needorigin: "1 " 
 -- needOrigin:E: "1 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "1 " rec: "1 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "1 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "1 "E:  "1 "
 -- INV:gen:E.loadArgs "1 "
 -- INV:gen:after:E.loadArgs "1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1 "
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- checkNumberConvert: "1 " D: "in V: var integer " 
 -- end:loadArgs:NonVirt: "+ 1 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"N":rec:N 
 -- INV:gen:after:E.loadArgs "N + 1 "
 --  OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"N":rec:N 
 -- IV:E.invoke:useRtnVal: true E: BinOp "N + 1 "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"N":rec:N 
 -- BinaryExp:invoke: "N "rec: "N + 1 "
 -- M: "+ 1 "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"N":rec:N 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- ptn:invoke: "+   "E: "+ 1 "ptnKind: 0 useRtnV: true 
 plus
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:N 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:N 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- checkNumberConvert: "N + 1 " D: "N: var integer " 
 -- assign:adr.store:A: 
 storeg size$134 2
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:4 isIndexed:0

 CLASS clear 136 1 OrderedList 92
 -- vdtTableCopy: I:1:100 I:2:0
 tstOriginIsNone 
 rstore  1 origin
 -- super clear
 pushThis 
 rpushg iOrigin 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 rtnAlloc 1
 toSuper 100
DO:
 mvStack 
 L1:
 -- AssignmentStatement:gen: "head := none " 
 pushThis 
 -- items:goOrigin:encOG: "clear "on: 1 isValueObj: false 
 --  origin: OrderedList origin:isValueObj: false 
 rpushg clear$136 1
 -- AssignmentStatement:gen: 
 --  "head := none " right.label: "ObjectGenerator ""none " 
 -- OG:before:super.gen: "none "
 -- INV:gen: "none " 
 -- needorigin: "none " 
 -- needOrigin:E: "none "  E.ATd: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  Ex: "none " rec: "none " E.ATd: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  E.ATd.desc: 
 --  %basic 19
 --  none_x: var integer
 --  E.ATd.IT: 
 --  %basic 19
 --  none_x: var integer
 --  
 -- doNeedOrigin:Ex: "none "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "none " 
 -- doNeedOrigin:E: "none " 
 -- computeAdrX:superAdj: 0 "none " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "none " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "none "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "none "E:  "none "
 -- INV:gen:E.loadArgs "none "
 -- INV:gen:after:E.loadArgs "none "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "none "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern none 
 -- ptn:invoke: "none "E: "none "ptnKind: 0 useRtnV: true 
 pushNone 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- assign:adr.store:A: 
 rswap 0
 rstoreg  EisNone 1
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 -- assign:adr.store:B: 
 -- AssignmentStatement:gen: "tail := none " 
 pushThis 
 -- items:goOrigin:encOG: "clear "on: 1 isValueObj: false 
 --  origin: OrderedList origin:isValueObj: false 
 rpushg clear$136 1
 -- AssignmentStatement:gen: 
 --  "tail := none " right.label: "ObjectGenerator ""none " 
 -- OG:before:super.gen: "none "
 -- INV:gen: "none " 
 -- needorigin: "none " 
 -- needOrigin:E: "none "  E.ATd: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  Ex: "none " rec: "none " E.ATd: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  E.ATd.desc: 
 --  %basic 19
 --  none_x: var integer
 --  E.ATd.IT: 
 --  %basic 19
 --  none_x: var integer
 --  
 -- doNeedOrigin:Ex: "none "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "none " 
 -- doNeedOrigin:E: "none " 
 -- computeAdrX:superAdj: 0 "none " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "none " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "none "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "none "E:  "none "
 -- INV:gen:E.loadArgs "none "
 -- INV:gen:after:E.loadArgs "none "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "none "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern none 
 -- ptn:invoke: "none "E: "none "ptnKind: 0 useRtnV: true 
 pushNone 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- assign:adr.store:A: 
 rswap 0
 rstoreg  EisNone 2
   ;; vTop(0,0)=[] rTop(-2,1)=[]
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0

 CLASS insert 137 1 OrderedList 92
 -- vdtTableCopy: I:1:74 I:2:0
 rShiftUp  1
 tstOriginIsNone 
 rstore  1 origin
 -- super insert
 pushThis 
 rpushg iOrigin 1
 rShiftDown  1
 pushThis 
 rstoreg  e 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- DI:gen: "in e: ref elm " DI:isConst: false isBasicValue: false 
 --  primNo: 0 
 rtnAlloc 1
 toSuper 74
DO:
 mvStack 
 L1:
 -- OG:before:super.gen: "
 --  if (head == none) :then 
 --     head := Link(e):next(none)
 --     tail := head
 --  :else 
 --     t: ref Link:next
 --     t := link(e):next(none)
 --     tail.next := t
 --     tail := t "
 -- INV:gen: 
 --  if (head == none) :then 
 --     head := Link(e):next(none)
 --     tail := head
 --  :else 
 -- needorigin: 
 --  if (head == none) :then 
 --     head := Link(e):next(none)
 --     tail := head
 --  :else 
 -- needOrigin:E: 
 --  if (head == none) :then 
 --     head := Link(e):next(none)
 --     tail := head
 --  :else  E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (head == none) :then 
 --     head := Link(e):next(none)
 --     tail := head
 --  :else rec: 
 --  if (head == none) :then 
 --     head := Link(e):next(none)
 --     tail := head
 --  :else E.ATd: 
 -- \
 --   if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  E.ATd.desc: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  E.ATd.IT: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (head == none) :then 
 --     head := Link(e):next(none)
 --     tail := head
 --  :else 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "
 --  if (head == none) :then 
 --     head := Link(e):next(none)
 --     tail := head
 --  :else 
 --     t: ref Link:next
 --     t := link(e):next(none)
 --     tail.next := t
 --     tail := t "E:  "
 --  if (head == none) :then 
 --     head := Link(e):next(none)
 --     tail := head
 --  :else 
 --     t: ref Link:next
 --     t := link(e):next(none)
 --     tail.next := t
 --     tail := t "
 -- INV:gen:E.loadArgs "
 --  if (head == none) :then 
 --     head := Link(e):next(none)
 --     tail := head
 --  :else 
 --     t: ref Link:next
 --     t := link(e):next(none)
 --     tail.next := t
 --     tail := t "
 -- INV:gen:after:E.loadArgs "
 --  if (head == none) :then 
 --     head := Link(e):next(none)
 --     tail := head
 --  :else 
 --     t: ref Link:next
 --     t := link(e):next(none)
 --     tail.next := t
 --     tail := t "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThenElse "
 --  if (head == none) :then 
 --     head := Link(e):next(none)
 --     tail := head
 --  :else 
 --     t: ref Link:next
 --     t := link(e):next(none)
 --     tail.next := t
 --     tail := t "
 -- OG:before:super.gen: "(head == none) "
 -- INV:gen: "(head == none) " 
 -- needorigin: "(head == none) " 
 -- needOrigin:E: "(head == none) "  E.ATd: 
 --  ==  : 
 --     %basic 56
 --     in objx: ref Object
 --     out V: var boolean
 --  Ex: "(head == none) " rec: "(head == none) " E.ATd: 
 --  ==  : 
 --     %basic 56
 --     in objx: ref Object
 --     out V: var boolean
 --  E.ATd.desc: 
 --  %basic 56
 --  in objx: ref Object
 --  out V: var boolean
 --  E.ATd.IT: 
 --  %basic 56
 --  in objx: ref Object
 --  out V: var boolean
 -- \
 --   
 -- doNeedOrigin:Ex: "(head == none) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(head == none) " 
 -- doNeedOrigin:E: "(head == none) " 
 -- computeAdrX:superAdj: 0 "(head == none) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(head == none) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "head == none "superAdj: 0 
 -- BE:loadOrigin:E: head == none 
 -- computeAdrX:isLast:E:  "head == none "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "head == none "E:  "head == none "
 -- INV:gen:E.loadArgs "head == none "
 -- BinaryExp:loadArgs: "head == none " superAdj: 0 
 -- INV:gen: "head " 
 -- needorigin: "head " 
 -- needOrigin:E: "head "  E.ATd: "head: ref link:next " Ex: "head " 
 --  rec: "head " E.ATd: "head: ref link:next " E.ATd.desc: 
 --  %id "link:next"
 --  ...
 --  E.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "head " 
 -- doNeedOrigin:E: "head " 
 -- computeAdrX:superAdj: 0 "head " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "head " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "insert "on: 1 isValueObj: false 
 --  origin: OrderedList origin:isValueObj: false 
 rpushg insert$137 1
 -- computeAdrX:isLast:E:  "head "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "head "E:  "head "
 -- INV:gen:E.loadArgs "head "
 -- INV:gen:after:E.loadArgs "head "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "head "
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: ref head 
 -- DI:invoke: "head: ref link:next " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head isNotRemote: true 
 rpushg OrderedList$92 1
 -- OI:invoke:V: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- OI:invoke:X: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- INV:gen:end:off: 1 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- NonVirt: "== none " "ObjectInvocation_Binary " ActArg: "none "
 --  isValue: false formalArg: "in objx: ref Object " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "== none " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "none "
 -- INV:gen: "none " 
 -- needorigin: "none " 
 -- needOrigin:E: "none "  E.ATd: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  Ex: "none " rec: "none " E.ATd: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  E.ATd.desc: 
 --  %basic 19
 --  none_x: var integer
 --  E.ATd.IT: 
 --  %basic 19
 --  none_x: var integer
 --  
 -- doNeedOrigin:Ex: "none "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "none " 
 -- doNeedOrigin:E: "none " 
 -- computeAdrX:superAdj: 0 "none " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "none " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "none "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "none "E:  "none "
 -- INV:gen:E.loadArgs "none "
 -- INV:gen:after:E.loadArgs "none "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "none "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern none 
 -- ptn:invoke: "none "E: "none "ptnKind: 0 useRtnV: true 
 pushNone 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- actualArg:isPtn: true formalArg:isPtn: "in objx: ref Object "
 --  :isBasicVal: false :valueObj: false 
 --  :actArg: "none ":isBasicVal: false 
 -- case:B: none ObjectGenerator 64 19 19 false false 
 -- checkNumberConvert: "none " D: "in objx: ref Object " 
 -- end:loadArgs:NonVirt: "== none "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- INV:gen:after:E.loadArgs "head == none "
 --  OIadr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- IV:E.invoke:useRtnVal: true E: BinOp "head == none "
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- BinaryExp:invoke: "head "rec: "head == none "
 -- M: "== none "
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- OI:invoke:before:ATdx.invoke: pattern ==   
 -- ptn:invoke: "==   "E: "== none "ptnKind: 0 useRtnV: true 
 req
 -- OI:invoke:V: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"== none":rec:head 
 -- OI:invoke:X: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"== none":rec:head 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 pushThis 
 -- before objTmpStack:add:  138   "$138 "
 invoke $138 138 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L5
 L4:
 pushThis 
 -- before objTmpStack:add:  139   "$139 "
 invoke $139 139 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L5:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS $138 138 1 insert 137
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "head := Link(e):next(none) " 
 pushThis 
 -- items:goOrigin:encOG: "$138 "on: 2 isValueObj: false 
 --  origin: insert origin:isValueObj: false 
 rpushg $138$138 1
 -- items:goOrigin:encOG: "insert "on: 1 isValueObj: false 
 --  origin: OrderedList origin:isValueObj: false 
 rpushg insert$137 1
 -- AssignmentStatement:gen: 
 --  "head := Link(e):next(none) " right.label: "ObjectGenerator ""
 --  Link(e):next(none) " 
 -- OG:before:super.gen: "Link(e):next(none) "
 -- INV:gen: "Link(e):next(none) " 
 -- needorigin: "Link(e):next(none) " 
 -- needOrigin:E: "Link(e):next(none) "  E.ATd: 
 --  link(E: ref Elm):next(next: ref Link:next): 
 --     %id "link:next"
 --     ...
 --  Ex: "Link(e):next(none) " rec: "Link(e):next(none) " E.ATd: 
 --  link(E: ref Elm):next(next: ref Link:next): 
 --     %id "link:next"
 --     ...
 --  E.ATd.desc: 
 --  %id "link:next"
 --  ...
 --  E.ATd.IT: 
 --  %id "link:next"
 --  ...
 --  
 -- doNeedOrigin:Ex: "Link(e):next(none) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "Link(e):next(none) " 
 -- doNeedOrigin:E: "Link(e):next(none) " 
 -- computeAdrX:superAdj: 0 "Link(e):next(none) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Link(e):next(none) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$138 "on: 2 isValueObj: false 
 --  origin: insert origin:isValueObj: false 
 rpushg $138$138 1
 -- items:goOrigin:encOG: "insert "on: 1 isValueObj: false 
 --  origin: OrderedList origin:isValueObj: false 
 rpushg insert$137 1
 -- computeAdrX:isLast:E:  "Link(e):next(none) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Link(e):next(none)":rec:- 
 --  rec:  "Link(e):next(none) "E:  "Link(e):next(none) "
 -- INV:gen:E.loadArgs "Link(e):next(none) "
 -- NonVirt: "Link(e):next(none) " "ObjectInvocation_KeyWord " 
 --  ActArg: "e "isValue: false formalArg: "E: ref Elm " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "Link(e):next(none) "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "e "
 -- INV:gen: "e " 
 -- needorigin: "e " 
 -- needOrigin:E: "e "  E.ATd: "in e: ref elm " Ex: "e " rec: "e " 
 --  E.ATd: "in e: ref elm " E.ATd.desc: 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : E.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "e " 
 -- doNeedOrigin:E: "e " 
 -- computeAdrX:superAdj: 0 "e " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "e " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$138 "on: 1 isValueObj: false 
 --  origin: insert origin:isValueObj: false 
 rpushg $138$138 1
 -- computeAdrX:isLast:E:  "e "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "e "E:  "e "
 -- INV:gen:E.loadArgs "e "
 -- INV:gen:after:E.loadArgs "e "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "e "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: ref e 
 -- DI:invoke: "in e: ref elm " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"e":rec:e isNotRemote: true 
 rpushg insert$137 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"e":rec:e 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"e":rec:e 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"e":rec:e 
 -- actualArg:isPtn: false formalArg:isPtn: "E: ref Elm "
 --  :isBasicVal: false :valueObj: false 
 --  :actArg: "e ":isBasicVal: false 
 -- case:B: e ObjectGenerator 0 0 64 false false 
 -- checkNumberConvert: "e " D: "E: ref Elm " 
 -- end:loadArgs:NonVirt: "Link(e):next(none) "
 -- NonVirt: "Link(e):next(none) " "ObjectInvocation_KeyWord " 
 --  ActArg: "none "isValue: false formalArg: "next: ref Link:next " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "Link(e):next(none) "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "none "
 -- INV:gen: "none " 
 -- needorigin: "none " 
 -- needOrigin:E: "none "  E.ATd: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  Ex: "none " rec: "none " E.ATd: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  E.ATd.desc: 
 --  %basic 19
 --  none_x: var integer
 --  E.ATd.IT: 
 --  %basic 19
 --  none_x: var integer
 --  
 -- doNeedOrigin:Ex: "none "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "none " 
 -- doNeedOrigin:E: "none " 
 -- computeAdrX:superAdj: 0 "none " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "none " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "none "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "none "E:  "none "
 -- INV:gen:E.loadArgs "none "
 -- INV:gen:after:E.loadArgs "none "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "none "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern none 
 -- ptn:invoke: "none "E: "none "ptnKind: 0 useRtnV: true 
 pushNone 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- actualArg:isPtn: true formalArg:isPtn: "next: ref Link:next "
 --  :isBasicVal: false :valueObj: false 
 --  :actArg: "none ":isBasicVal: false 
 -- case:B: none ObjectGenerator 0 19 19 false false 
 -- checkNumberConvert: "none " D: "next: ref Link:next " 
 -- end:loadArgs:NonVirt: "Link(e):next(none) "
 -- INV:gen:after:E.loadArgs "Link(e):next(none) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "
 --  Link(e):next(none) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Link(e):next(none)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern 
 --  link(E: ref Elm):next(next: ref Link:next) 
 -- ptn:invoke: "link(E: ref Elm):next(next: ref Link:next) "E: "
 --  Link(e):next(none) "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "
 --  Link(e):next(none) " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Link(e):next(none)":rec:Link(e):next(none) 
 invoke link:next 128 0 1
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Link(e):next(none)":rec:Link(e):next(none) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Link(e):next(none)":rec:Link(e):next(none) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Link(e):next(none)":rec:Link(e):next(none) 
 -- assign:adr.store:A: 
 rswap 0
 rstoreg  EisNone 1
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 -- assign:adr.store:B: 
 -- AssignmentStatement:gen: "tail := head " 
 pushThis 
 -- items:goOrigin:encOG: "$138 "on: 2 isValueObj: false 
 --  origin: insert origin:isValueObj: false 
 rpushg $138$138 1
 -- items:goOrigin:encOG: "insert "on: 1 isValueObj: false 
 --  origin: OrderedList origin:isValueObj: false 
 rpushg insert$137 1
 -- AssignmentStatement:gen: 
 --  "tail := head " right.label: "ObjectGenerator ""head " 
 -- OG:before:super.gen: "head "
 -- INV:gen: "head " 
 -- needorigin: "head " 
 -- needOrigin:E: "head "  E.ATd: "head: ref link:next " Ex: "head " 
 --  rec: "head " E.ATd: "head: ref link:next " E.ATd.desc: 
 --  %id "link:next"
 --  ...
 --  E.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "head " 
 -- doNeedOrigin:E: "head " 
 -- computeAdrX:superAdj: 0 "head " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "head " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$138 "on: 2 isValueObj: false 
 --  origin: insert origin:isValueObj: false 
 rpushg $138$138 1
 -- items:goOrigin:encOG: "insert "on: 1 isValueObj: false 
 --  origin: OrderedList origin:isValueObj: false 
 rpushg insert$137 1
 -- computeAdrX:isLast:E:  "head "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "head "E:  "head "
 -- INV:gen:E.loadArgs "head "
 -- INV:gen:after:E.loadArgs "head "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "head "
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: ref head 
 -- DI:invoke: "head: ref link:next " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head isNotRemote: true 
 rpushg OrderedList$92 1
 -- OI:invoke:V: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- OI:invoke:X: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- INV:gen:end:off: 1 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"head":rec:head 
 -- assign:adr.store:A: 
 rswap 0
 rstoreg  EisNone 2
   ;; vTop(0,0)=[] rTop(-3,1)=[]
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $139 139 1 insert 137
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "t: ref Link:next " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "t := link(e):next(none) " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "t := link(e):next(none) " right.label: "ObjectGenerator ""
 --  link(e):next(none) " 
 -- OG:before:super.gen: "link(e):next(none) "
 -- INV:gen: "link(e):next(none) " 
 -- needorigin: "link(e):next(none) " 
 -- needOrigin:E: "link(e):next(none) "  E.ATd: 
 --  link(E: ref Elm):next(next: ref Link:next): 
 --     %id "link:next"
 --     ...
 --  Ex: "link(e):next(none) " rec: "link(e):next(none) " E.ATd: 
 --  link(E: ref Elm):next(next: ref Link:next): 
 --     %id "link:next"
 --     ...
 --  E.ATd.desc: 
 --  %id "link:next"
 --  ...
 --  E.ATd.IT: 
 --  %id "link:next"
 --  ...
 --  
 -- doNeedOrigin:Ex: "link(e):next(none) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "link(e):next(none) " 
 -- doNeedOrigin:E: "link(e):next(none) " 
 -- computeAdrX:superAdj: 0 "link(e):next(none) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "link(e):next(none) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$139 "on: 2 isValueObj: false 
 --  origin: insert origin:isValueObj: false 
 rpushg $139$139 1
 -- items:goOrigin:encOG: "insert "on: 1 isValueObj: false 
 --  origin: OrderedList origin:isValueObj: false 
 rpushg insert$137 1
 -- computeAdrX:isLast:E:  "link(e):next(none) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"link(e):next(none)":rec:- 
 --  rec:  "link(e):next(none) "E:  "link(e):next(none) "
 -- INV:gen:E.loadArgs "link(e):next(none) "
 -- NonVirt: "link(e):next(none) " "ObjectInvocation_KeyWord " 
 --  ActArg: "e "isValue: false formalArg: "E: ref Elm " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "link(e):next(none) "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "e "
 -- INV:gen: "e " 
 -- needorigin: "e " 
 -- needOrigin:E: "e "  E.ATd: "in e: ref elm " Ex: "e " rec: "e " 
 --  E.ATd: "in e: ref elm " E.ATd.desc: 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : E.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "e " 
 -- doNeedOrigin:E: "e " 
 -- computeAdrX:superAdj: 0 "e " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "e " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "$139 "on: 1 isValueObj: false 
 --  origin: insert origin:isValueObj: false 
 rpushg $139$139 1
 -- computeAdrX:isLast:E:  "e "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "e "E:  "e "
 -- INV:gen:E.loadArgs "e "
 -- INV:gen:after:E.loadArgs "e "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "e "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: ref e 
 -- DI:invoke: "in e: ref elm " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"e":rec:e isNotRemote: true 
 rpushg insert$137 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"e":rec:e 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"e":rec:e 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"e":rec:e 
 -- actualArg:isPtn: false formalArg:isPtn: "E: ref Elm "
 --  :isBasicVal: false :valueObj: false 
 --  :actArg: "e ":isBasicVal: false 
 -- case:B: e ObjectGenerator 0 0 64 false false 
 -- checkNumberConvert: "e " D: "E: ref Elm " 
 -- end:loadArgs:NonVirt: "link(e):next(none) "
 -- NonVirt: "link(e):next(none) " "ObjectInvocation_KeyWord " 
 --  ActArg: "none "isValue: false formalArg: "next: ref Link:next " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "link(e):next(none) "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "none "
 -- INV:gen: "none " 
 -- needorigin: "none " 
 -- needOrigin:E: "none "  E.ATd: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  Ex: "none " rec: "none " E.ATd: 
 --  none: 
 --     %basic 19
 --     none_x: var integer
 --  E.ATd.desc: 
 --  %basic 19
 --  none_x: var integer
 --  E.ATd.IT: 
 --  %basic 19
 --  none_x: var integer
 --  
 -- doNeedOrigin:Ex: "none "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "none " 
 -- doNeedOrigin:E: "none " 
 -- computeAdrX:superAdj: 0 "none " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "none " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "none "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "none "E:  "none "
 -- INV:gen:E.loadArgs "none "
 -- INV:gen:after:E.loadArgs "none "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "none "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern none 
 -- ptn:invoke: "none "E: "none "ptnKind: 0 useRtnV: true 
 pushNone 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:none 
 -- actualArg:isPtn: true formalArg:isPtn: "next: ref Link:next "
 --  :isBasicVal: false :valueObj: false 
 --  :actArg: "none ":isBasicVal: false 
 -- case:B: none ObjectGenerator 0 19 19 false false 
 -- checkNumberConvert: "none " D: "next: ref Link:next " 
 -- end:loadArgs:NonVirt: "link(e):next(none) "
 -- INV:gen:after:E.loadArgs "link(e):next(none) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "
 --  link(e):next(none) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"link(e):next(none)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern 
 --  link(E: ref Elm):next(next: ref Link:next) 
 -- ptn:invoke: "link(E: ref Elm):next(next: ref Link:next) "E: "
 --  link(e):next(none) "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "
 --  link(e):next(none) " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"link(e):next(none)":rec:link(e):next(none) 
 invoke link:next 128 0 1
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"link(e):next(none)":rec:link(e):next(none) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"link(e):next(none)":rec:link(e):next(none) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"link(e):next(none)":rec:link(e):next(none) 
 -- assign:adr.store:A: 
 rswap 0
 rstoreg  EisNone 2
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 -- assign:adr.store:B: 
 -- AssignmentStatement:gen: "tail.next := t " 
 pushThis 
 -- items:goOrigin:encOG: "$139 "on: 2 isValueObj: false 
 --  origin: insert origin:isValueObj: false 
 rpushg $139$139 1
 -- items:goOrigin:encOG: "insert "on: 1 isValueObj: false 
 --  origin: OrderedList origin:isValueObj: false 
 rpushg insert$137 1
 -- computeAdrG:pRec: "tail " E: "next " 
 -- OI:invoke:before:ATdx.invoke: ref tail 
 -- DI:invoke: "tail: ref Link:next " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"next":rec:tail isNotRemote: false 
 rpushg $139$139 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"next":rec:tail 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"next":rec:tail 
 -- AssignmentStatement:gen: 
 --  "tail.next := t " right.label: "ObjectGenerator ""t " 
 -- OG:before:super.gen: "t "
 -- INV:gen: "t " 
 -- needorigin: "t " 
 -- needOrigin:E: "t "  E.ATd: "t: ref Link:next " Ex: "t " rec: "
 --  t " E.ATd: "t: ref Link:next " E.ATd.desc: 
 --  %id "link:next"
 --  ...
 --  E.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "t " 
 -- doNeedOrigin:E: "t " 
 -- computeAdrX:superAdj: 0 "t " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "t " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "t "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "t "E:  "t "
 -- INV:gen:E.loadArgs "t "
 -- INV:gen:after:E.loadArgs "t "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "t "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: ref t 
 -- DI:invoke: "t: ref Link:next " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"t":rec:t isNotRemote: true 
 rpushg $139$139 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"t":rec:t 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"t":rec:t 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"t":rec:t 
 -- assign:adr.store:A: 
 rswap 0
 rstoreg  EisNone 3
   ;; vTop(0,0)=[] rTop(-3,1)=[]
 -- assign:adr.store:B: 
 -- AssignmentStatement:gen: "tail := t " 
 pushThis 
 -- items:goOrigin:encOG: "$139 "on: 2 isValueObj: false 
 --  origin: insert origin:isValueObj: false 
 rpushg $139$139 1
 -- items:goOrigin:encOG: "insert "on: 1 isValueObj: false 
 --  origin: OrderedList origin:isValueObj: false 
 rpushg insert$137 1
 -- AssignmentStatement:gen: 
 --  "tail := t " right.label: "ObjectGenerator ""t " 
 -- OG:before:super.gen: "t "
 -- INV:gen: "t " 
 -- needorigin: "t " 
 -- needOrigin:E: "t "  E.ATd: "t: ref Link:next " Ex: "t " rec: "
 --  t " E.ATd: "t: ref Link:next " E.ATd.desc: 
 --  %id "link:next"
 --  ...
 --  E.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "t " 
 -- doNeedOrigin:E: "t " 
 -- computeAdrX:superAdj: 0 "t " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "t " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "t "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "t "E:  "t "
 -- INV:gen:E.loadArgs "t "
 -- INV:gen:after:E.loadArgs "t "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "t "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: ref t 
 -- DI:invoke: "t: ref Link:next " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"t":rec:t isNotRemote: true 
 rpushg $139$139 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"t":rec:t 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"t":rec:t 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"t":rec:t 
 -- assign:adr.store:A: 
 rswap 0
 rstoreg  EisNone 2
   ;; vTop(0,0)=[] rTop(-5,1)=[]
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS Rule 89 1 Grammar 71
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "leftSide: ref Nonterminal " DI:isConst: false 
 --  isBasicValue: false primNo: 0 
 -- DI:gen: 
 --  alternatives: obj OrderedList(#Alternative)
 --     print: 
 --        i: var integer
 --        scanDI:isConst: true isBasicValue: false primNo: 0 
 -- DI:isConst: alternatives 
 -- DI:off: 3 this: 
 --  alternatives: obj OrderedList(#Alternative)
 --     print: 
 --        i: var integer
 --        scan
 --  
 -- before objTmpStack:add:  93   "alternatives "
 invoke alternatives 93 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS SymbolList 141 0 Grammar 71
 -- vdtTableCopy: I:1:80 V:2:0 V:3:137 V:4:126 V:5:97 V:6:133 V:7:134 V:8:136 I:9:92
 -- super OrderedList
 -- super OrderedList
 allocEventQ
 -- DI:gen: "head: ref link:next " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 -- DI:gen: "tail: ref Link:next " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 rtnAlloc 1
 toSuper 80
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS Alternative 90 1 Grammar 71
 pushThis 
 rstoreg  symbols 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS alternatives 93 0 Rule 89
 -- vdtTableCopy: I:1:80 V:2:0 V:3:137 V:4:126 V:5:97 V:6:133 V:7:134 V:8:136 I:9:92
 -- super OrderedList
 -- super OrderedList
 allocEventQ
 -- DI:gen: "head: ref link:next " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 -- DI:gen: "tail: ref Link:next " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 rtnAlloc 1
 toSuper 80
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS rules 95 0 Grammar 71
 -- vdtTableCopy: I:1:80 V:2:0 V:3:137 V:4:126 V:5:97 V:6:133 V:7:134 V:8:136 I:9:92
 -- super OrderedList
 -- super OrderedList
 allocEventQ
 -- DI:gen: "head: ref link:next " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 -- DI:gen: "tail: ref Link:next " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 rtnAlloc 1
 toSuper 80
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS Text 142 1 GrammarLib 69
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS parse 143 1 Grammar 71
 pushThis 
 rstoreg  input 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: 
 --  output: ref AbstractSyntaxTree
 --  -- Parse the input string according to the grammar
 --  -- and produce an abstract syntax tree
 --  --return output
 --  DI:isConst: false isBasicValue: false primNo: 0 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS AbstractSyntaxTree 144 1 GrammarLib 69
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS gTst 145 7 demo 70
 -- vdtTableCopy: I:1:71 V:2:143 I:3:0
 tstOriginIsNone 
 rstore  7 origin
 -- super Grammar
 -- computeAdrX:superAdj: 7 "Grammar " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Grammar " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:7 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 rpushg demo$70 7
 -- items:goOrigin:encOG: "demo "on: 1 isValueObj: false 
 --  origin: GrammarLib origin:isValueObj: false 
 rpushg demo$70 1
 -- computeAdrX:isLast:E:  "Grammar "
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- DI:gen: "nonTerminals: obj Set(#Nonterminal) " DI:isConst: true 
 --  isBasicValue: false primNo: 0 
 -- DI:isConst: nonTerminals 
 -- DI:off: 2 this: "nonTerminals: obj Set(#Nonterminal) " 
 --  
 -- before objTmpStack:add:  85   "nonTerminals "
 invoke nonTerminals 85 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- DI:gen: "terminals: obj Set(#Terminal) " DI:isConst: true 
 --  isBasicValue: false primNo: 0 
 -- DI:isConst: terminals 
 -- DI:off: 3 this: "terminals: obj Set(#Terminal) " 
 --  
 -- before objTmpStack:add:  88   "terminals "
 invoke terminals 88 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- DI:gen: "rules: obj OrderedList(#Rule) " DI:isConst: true 
 --  isBasicValue: false primNo: 0 
 -- DI:isConst: rules 
 -- DI:off: 4 this: "rules: obj OrderedList(#Rule) " 
 --  
 -- before objTmpStack:add:  95   "rules "
 invoke rules 95 4 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- DI:gen: "start: ref Nonterminal " DI:isConst: false 
 --  isBasicValue: false primNo: 0 
 -- DI:gen: "noOfRules: var integer " DI:isConst: false 
 --  isBasicValue: true primNo: 1 
 -- DI:gen:primitiveType: noOfRules 
 -- DI:gen: "expSy: obj Nonterminal("Exp") " DI:isConst: true 
 --  isBasicValue: false primNo: 0 
 -- DI:isConst: expSy 
 -- DI:off: 8 this: "expSy: obj Nonterminal("Exp") " 
 --  
 -- OG:before:super.gen: "Nonterminal("Exp") "
 -- INV:gen: "Nonterminal("Exp") " 
 -- needorigin: "Nonterminal("Exp") " 
 -- needOrigin:E: "Nonterminal("Exp") "  E.ATd: 
 --  NonTerminal: Symbol
 --     ...
 --     print:: 
 --        put('<')Ex: "Nonterminal("Exp") " rec: "Nonterminal("Exp") " E.ATd: 
 --  NonTerminal: Symbol
 --     ...
 --     print:: 
 --        put('<')E.ATd.desc: 
 --  ...
 --  print:: 
 --     put('<')
 --     printName.printE.ATd.IT: 
 --  ...
 --  print:: 
 --     put('<')
 --     printName.print
 -- doNeedOrigin:Ex: "Nonterminal("Exp") "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "Nonterminal("Exp") " 
 -- doNeedOrigin:E: "Nonterminal("Exp") " 
 -- computeAdrX:superAdj: 0 "Nonterminal("Exp") " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Nonterminal("Exp") " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "Nonterminal("Exp") "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Nonterminal("Exp")":rec:- 
 --  rec:  "Nonterminal("Exp") "E:  "Nonterminal("Exp") "
 -- INV:gen:E.loadArgs "Nonterminal("Exp") "
 -- NonVirt: "Nonterminal("Exp") " "ObjectInvocation_KeyWord " 
 --  ActArg: ""Exp" "isValue: false formalArg: "printName: var String " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "Nonterminal("Exp") "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: ""Exp" "
 -- INV:gen: ""Exp" " 
 -- needorigin: ""Exp" " 
 -- needOrigin:E: ""Exp" "  E.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5Ex: ""Exp" " rec: ""Exp" " E.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5E.ATd.desc: 
 --  %id "String pattern"
 --  %OSDvisibility disguised
 --  %basic 5
 --  %publicE.ATd.IT: 
 --  %id "String pattern"
 --  %OSDvisibility disguised
 --  %basic 5
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- after:needOrigin: ""Exp" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  ""Exp" "E:  ""Exp" "
 -- INV:gen:E.loadArgs ""Exp" "
 -- INV:gen:after:E.loadArgs ""Exp" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: String: ""Exp" "
 pushText "Exp"
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "printName: var String "
 --  :isBasicVal: false :valueObj: false 
 --  :actArg: ""Exp" ":isBasicVal: false 
 -- case:B: "Exp" ObjectGenerator 5 5 5 false false 
 -- checkNumberConvert: ""Exp" " D: "printName: var String " 
 -- end:loadArgs:NonVirt: "Nonterminal("Exp") "
 -- INV:gen:after:E.loadArgs "Nonterminal("Exp") "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  Nonterminal("Exp") "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Nonterminal("Exp")":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern NonTerminal 
 -- ptn:invoke: "NonTerminal "E: "Nonterminal("Exp") "ptnKind: 0 
 --  useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 8 rec: "
 --  Nonterminal("Exp") " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Nonterminal("Exp")":rec:Nonterminal("Exp") 
 invoke NonTerminal 73 8 1
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Nonterminal("Exp")":rec:Nonterminal("Exp") 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Nonterminal("Exp")":rec:Nonterminal("Exp") 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Nonterminal("Exp")":rec:Nonterminal("Exp") 
 -- DI:gen: "termSy: obj Nonterminal("Term") " DI:isConst: true 
 --  isBasicValue: false primNo: 0 
 -- DI:isConst: termSy 
 -- DI:off: 9 this: "termSy: obj Nonterminal("Term") " 
 --  
 -- OG:before:super.gen: "Nonterminal("Term") "
 -- INV:gen: "Nonterminal("Term") " 
 -- needorigin: "Nonterminal("Term") " 
 -- needOrigin:E: "Nonterminal("Term") "  E.ATd: 
 --  NonTerminal: Symbol
 --     ...
 --     print:: 
 --        put('<')Ex: "Nonterminal("Term") " rec: "Nonterminal("Term") " E.ATd: 
 --  NonTerminal: Symbol
 --     ...
 --     print:: 
 --        put('<')E.ATd.desc: 
 --  ...
 --  print:: 
 --     put('<')
 --     printName.printE.ATd.IT: 
 --  ...
 --  print:: 
 --     put('<')
 --     printName.print
 -- doNeedOrigin:Ex: "Nonterminal("Term") "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "Nonterminal("Term") " 
 -- doNeedOrigin:E: "Nonterminal("Term") " 
 -- computeAdrX:superAdj: 0 "Nonterminal("Term") " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "
 --  Nonterminal("Term") " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "Nonterminal("Term") "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Nonterminal("Term")":rec:- 
 --  rec:  "Nonterminal("Term") "E:  "Nonterminal("Term") "
 -- INV:gen:E.loadArgs "Nonterminal("Term") "
 -- NonVirt: "Nonterminal("Term") " "ObjectInvocation_KeyWord " 
 --  ActArg: ""Term" "isValue: false formalArg: "printName: var String " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "Nonterminal("Term") "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: ""Term" "
 -- INV:gen: ""Term" " 
 -- needorigin: ""Term" " 
 -- needOrigin:E: ""Term" "  E.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5Ex: ""Term" " rec: ""Term" " E.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5E.ATd.desc: 
 --  %id "String pattern"
 --  %OSDvisibility disguised
 --  %basic 5
 --  %publicE.ATd.IT: 
 --  %id "String pattern"
 --  %OSDvisibility disguised
 --  %basic 5
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- after:needOrigin: ""Term" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  ""Term" "E:  ""Term" "
 -- INV:gen:E.loadArgs ""Term" "
 -- INV:gen:after:E.loadArgs ""Term" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: String: ""Term" "
 pushText "Term"
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "printName: var String "
 --  :isBasicVal: false :valueObj: false 
 --  :actArg: ""Term" ":isBasicVal: false 
 -- case:B: "Term" ObjectGenerator 5 5 5 false false 
 -- checkNumberConvert: ""Term" " D: "printName: var String " 
 -- end:loadArgs:NonVirt: "Nonterminal("Term") "
 -- INV:gen:after:E.loadArgs "Nonterminal("Term") "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  Nonterminal("Term") "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Nonterminal("Term")":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern NonTerminal 
 -- ptn:invoke: "NonTerminal "E: "Nonterminal("Term") "ptnKind: 0 
 --  useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 9 rec: "
 --  Nonterminal("Term") " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Nonterminal("Term")":rec:Nonterminal("Term") 
 invoke NonTerminal 73 9 1
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Nonterminal("Term")":rec:Nonterminal("Term") 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Nonterminal("Term")":rec:Nonterminal("Term") 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Nonterminal("Term")":rec:Nonterminal("Term") 
 -- DI:gen: "add: obj Terminal("+") " DI:isConst: true isBasicValue: 
 --  false primNo: 0 
 -- DI:isConst: add 
 -- DI:off: 10 this: "add: obj Terminal("+") " 
 --  
 -- OG:before:super.gen: "Terminal("+") "
 -- INV:gen: "Terminal("+") " 
 -- needorigin: "Terminal("+") " 
 -- needOrigin:E: "Terminal("+") "  E.ATd: 
 --  Terminal: Symbol
 --     isTerminal:: 
 --        V := true
 --     print:: Ex: "Terminal("+") " rec: "Terminal("+") " E.ATd: 
 --  Terminal: Symbol
 --     isTerminal:: 
 --        V := true
 --     print:: E.ATd.desc: 
 --  isTerminal:: 
 --     V := true
 --  print:: 
 --     put('"')"E.ATd.IT: 
 --  isTerminal:: 
 --     V := true
 --  print:: 
 --     put('"')"
 -- doNeedOrigin:Ex: "Terminal("+") "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "Terminal("+") " 
 -- doNeedOrigin:E: "Terminal("+") " 
 -- computeAdrX:superAdj: 0 "Terminal("+") " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Terminal("+") " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "Terminal("+") "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Terminal("+")":rec:- 
 --  rec:  "Terminal("+") "E:  "Terminal("+") "
 -- INV:gen:E.loadArgs "Terminal("+") "
 -- NonVirt: "Terminal("+") " "ObjectInvocation_KeyWord " ActArg: "
 --  "+" "isValue: false formalArg: "printName: var String " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "Terminal("+") "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: ""+" "
 -- INV:gen: ""+" " 
 -- needorigin: ""+" " 
 -- needOrigin:E: ""+" "  E.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5Ex: ""+" " rec: ""+" " E.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5E.ATd.desc: 
 --  %id "String pattern"
 --  %OSDvisibility disguised
 --  %basic 5
 --  %publicE.ATd.IT: 
 --  %id "String pattern"
 --  %OSDvisibility disguised
 --  %basic 5
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- after:needOrigin: ""+" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  ""+" "E:  ""+" "
 -- INV:gen:E.loadArgs ""+" "
 -- INV:gen:after:E.loadArgs ""+" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: String: ""+" "
 pushText "+"
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "printName: var String "
 --  :isBasicVal: false :valueObj: false 
 --  :actArg: ""+" ":isBasicVal: false 
 -- case:B: "+" ObjectGenerator 5 5 5 false false 
 -- checkNumberConvert: ""+" " D: "printName: var String " 
 -- end:loadArgs:NonVirt: "Terminal("+") "
 -- INV:gen:after:E.loadArgs "Terminal("+") "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  Terminal("+") "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Terminal("+")":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern Terminal 
 -- ptn:invoke: "Terminal "E: "Terminal("+") "ptnKind: 0 useRtnV: 
 --  false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 10 rec: "
 --  Terminal("+") " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Terminal("+")":rec:Terminal("+") 
 invoke Terminal 86 10 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Terminal("+")":rec:Terminal("+") 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Terminal("+")":rec:Terminal("+") 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Terminal("+")":rec:Terminal("+") 
 rtnAlloc 1
 toSuper 71
DO:
 mvStack 
 L1:
 -- OG:before:super.gen: "kuk "
 -- INV:gen: "kuk " 
 -- needorigin: "kuk " 
 -- needOrigin:E: "kuk "  E.ATd: 
 --  KUK: 
 --     S: ref SymbolList
 --     S := SymbolList
 --     S := SymbolList.insertList((ExpSy,add,termSy))
 --  Ex: "kuk " rec: "kuk " E.ATd: 
 --  KUK: 
 --     S: ref SymbolList
 --     S := SymbolList
 --     S := SymbolList.insertList((ExpSy,add,termSy))
 --  E.ATd.desc: 
 --  S: ref SymbolList
 --  S := SymbolList
 --  S := SymbolList.insertList((ExpSy,add,termSy))
 --  E.ATd.IT: 
 --  S: ref SymbolList
 --  S := SymbolList
 --  S := SymbolList.insertList((ExpSy,add,termSy))
 -- \
 --   
 -- doNeedOrigin:Ex: "kuk "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "kuk " 
 -- doNeedOrigin:E: "kuk " 
 -- computeAdrX:superAdj: 0 "kuk " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "kuk " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:isLast:E:  "kuk "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"kuk":rec:- 
 --  rec:  "kuk "E:  "kuk "
 -- INV:gen:E.loadArgs "kuk "
 -- INV:gen:after:E.loadArgs "kuk "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "kuk "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"kuk":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern KUK 
 -- ptn:invoke: "KUK "E: "kuk "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "kuk " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"kuk":rec:kuk 
 invoke KUK 146 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"kuk":rec:kuk 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"kuk":rec:kuk 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"kuk":rec:kuk 
 L2:
 rtnInner  M
 END OSDV:0 objSize:10 isIndexed:0

 CLASS KUK 146 1 gTst 145
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "S: ref SymbolList " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "S := SymbolList " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "S := SymbolList " right.label: "ObjectGenerator ""SymbolList " 
 -- OG:before:super.gen: "SymbolList "
 -- INV:gen: "SymbolList " 
 -- needorigin: "SymbolList " 
 -- needOrigin:E: "SymbolList "  E.ATd: 
 --  SymbolList: OrderedList(#Symbol)
 --     print: 
 --        scan
 --           current.printEx: "SymbolList " rec: "SymbolList " E.ATd: 
 --  SymbolList: OrderedList(#Symbol)
 --     print: 
 --        scan
 --           current.printE.ATd.desc: 
 --  print: 
 --     scan
 --        current.print
 --  ...
 --  E.ATd.IT: 
 --  print: 
 --     scan
 --        current.print
 --  ...
 -- \
 --   
 -- Ex:loadOrgin:no:loadOrigin:  
 --  OrderedList(#Symbol)
 --     print: 
 --        scan
 --           current.print
 -- after:needOrigin: "SymbolList " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "SymbolList "E:  "SymbolList "
 -- INV:gen:E.loadArgs "SymbolList "
 -- INV:gen:after:E.loadArgs "SymbolList "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "SymbolList "
 -- OI:invoke:before:ATdx.invoke: pattern SymbolList 
 -- ptn:invoke: "SymbolList "E: "SymbolList "ptnKind: 0 useRtnV: 
 --  true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "SymbolList " 
 --  adr:none 
 invoke SymbolList 141 0 1
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 rswap 0
 rstoreg  EisNone 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- assign:adr.store:B: 
 -- AssignmentStatement:gen: "
 --  S := SymbolList.insertList((ExpSy,add,termSy)) " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "S := SymbolList.insertList((ExpSy,add,termSy)) " right.label: "
 --  ObjectGenerator ""SymbolList.insertList((ExpSy,add,termSy)) " 
 -- OG:before:super.gen: "SymbolList.insertList((ExpSy,add,termSy)) "
 -- INV:gen: "SymbolList.insertList((ExpSy,add,termSy)) " 
 -- needorigin: "SymbolList.insertList((ExpSy,add,termSy)) " 
 -- needOrigin:E: "insertList((ExpSy,add,termSy)) "  E.ATd: 
 --  insertList(elms: ref IndexedRef(3,#Elm)): 
 --     out OL: ref OrderedList
 --     put('%')
 --     for(1):to(elms.length):repeatEx: "SymbolList " rec: "SymbolList " E.ATd: 
 --  insertList(elms: ref IndexedRef(3,#Elm)): 
 --     out OL: ref OrderedList
 --     put('%')
 --     for(1):to(elms.length):repeatE.ATd.desc: 
 --  out OL: ref OrderedList
 --  put('%')
 --  for(1):to(elms.length):repeat
 --     insert(elms.get[inx])E.ATd.IT: 
 --  out OL: ref OrderedList
 --  put('%')
 --  for(1):to(elms.length):repeat
 --     insert(elms.get[inx])
 -- Ex:loadOrgin:no:loadOrigin:  
 --  OrderedList(#Symbol)
 --     print: 
 --        scan
 --           current.print
 -- after:needOrigin: "SymbolList " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "SymbolList "E:  "SymbolList "
 -- INV:gen:E.loadArgs "SymbolList "
 -- INV:gen:after:E.loadArgs "SymbolList "
 --  OIadr: 
 -- OI:invoke:before:ATdx.invoke: pattern SymbolList 
 -- ptn:invoke: "SymbolList "E: "SymbolList "ptnKind: 0 useRtnV: 
 --  true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "SymbolList " 
 --  adr:none 
 invoke SymbolList 141 0 1
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- IV:gen:checkTail: "SymbolList.insertList((ExpSy,add,termSy)) "E: "
 --  SymbolList "tail: "insertList((ExpSy,add,termSy)) " not isLast: false 
 -- NonVirt: "insertList((ExpSy,add,termSy)) " "
 --  ObjectInvocation_KeyWord " ActArg: "(ExpSy,add,termSy) "isValue: false formalArg: "
 --  elms: ref IndexedRef(3,#Elm) " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "insertList((ExpSy,add,termSy)) "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "(ExpSy,add,termSy) "
 -- INV:gen: "(ExpSy,add,termSy) " 
 -- BracketedExp:gen: "(ExpSy,add,termSy) " 
 -- INV:gen: "ExpSy " 
 -- needorigin: "ExpSy " 
 -- needOrigin:E: "ExpSy "  E.ATd: "expSy: obj Nonterminal("Exp") " 
 --  Ex: "ExpSy " rec: "ExpSy " E.ATd: "expSy: obj Nonterminal("Exp") " 
 --  E.ATd.desc: 
 --  ...
 --  print:: 
 --     put('<')
 --     printName.printE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "ExpSy " 
 -- doNeedOrigin:E: "ExpSy " 
 -- computeAdrX:superAdj: 0 "ExpSy " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "ExpSy " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "KUK "on: 1 isValueObj: false 
 --  origin: gTst origin:isValueObj: false 
 rpushg KUK$146 1
 -- computeAdrX:isLast:E:  "ExpSy "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "ExpSy "E:  "ExpSy "
 -- INV:gen:E.loadArgs "ExpSy "
 -- INV:gen:after:E.loadArgs "ExpSy "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "ExpSy "
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: obj expSy 
 -- DI:invoke: "expSy: obj Nonterminal("Exp") " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"ExpSy":rec:ExpSy isNotRemote: true 
 rpushg gTst$145 8
 -- OI:invoke:V: adr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"ExpSy":rec:ExpSy 
 -- OI:invoke:X: adr: 
 --  :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"ExpSy":rec:ExpSy 
 -- INV:gen:end:off: 8 
 -- INV:gen: "add " 
 -- needorigin: "add " 
 -- needOrigin:E: "add "  E.ATd: "add: obj Terminal("+") " Ex: "
 --  add " rec: "add " E.ATd: "add: obj Terminal("+") " E.ATd.desc: 
 --  isTerminal:: 
 --     V := true
 --  print:: 
 --     put('"')"E.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "add " 
 -- doNeedOrigin:E: "add " 
 -- computeAdrX:superAdj: 0 "add " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "add " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "KUK "on: 1 isValueObj: false 
 --  origin: gTst origin:isValueObj: false 
 rpushg KUK$146 1
 -- computeAdrX:isLast:E:  "add "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "add "E:  "add "
 -- INV:gen:E.loadArgs "add "
 -- INV:gen:after:E.loadArgs "add "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "add "
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: obj add 
 -- DI:invoke: "add: obj Terminal("+") " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"add":rec:add isNotRemote: true 
 rpushg gTst$145 10
 -- OI:invoke:V: adr: 
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"add":rec:add 
 -- OI:invoke:X: adr: 
 --  :Adr:off:10 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"add":rec:add 
 -- INV:gen:end:off: 10 
 -- INV:gen: "termSy " 
 -- needorigin: "termSy " 
 -- needOrigin:E: "termSy "  E.ATd: "
 --  termSy: obj Nonterminal("Term") " Ex: "termSy " rec: "termSy " E.ATd: "
 --  termSy: obj Nonterminal("Term") " E.ATd.desc: 
 --  ...
 --  print:: 
 --     put('<')
 --     printName.printE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "termSy " 
 -- doNeedOrigin:E: "termSy " 
 -- computeAdrX:superAdj: 0 "termSy " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "termSy " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "KUK "on: 1 isValueObj: false 
 --  origin: gTst origin:isValueObj: false 
 rpushg KUK$146 1
 -- computeAdrX:isLast:E:  "termSy "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:9 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "termSy "E:  "termSy "
 -- INV:gen:E.loadArgs "termSy "
 -- INV:gen:after:E.loadArgs "termSy "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "termSy "
 --  :Adr:off:9 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:before:ATdx.invoke: obj termSy 
 -- DI:invoke: "termSy: obj Nonterminal("Term") " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:9 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"termSy":rec:termSy isNotRemote: true 
 rpushg gTst$145 9
 -- OI:invoke:V: adr: 
 --  :Adr:off:9 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"termSy":rec:termSy 
 -- OI:invoke:X: adr: 
 --  :Adr:off:9 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"termSy":rec:termSy 
 -- INV:gen:end:off: 9 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: false formalArg:isPtn: "
 --  elms: ref IndexedRef(3,#Elm) ":isBasicVal: false :valueObj: false 
 --  :actArg: "(ExpSy,add,termSy) ":isBasicVal: false 
 -- case:B: (ExpSy,add,termSy) ObjectGenerator 160 0 0 false false 
 -- checkNumberConvert: "(ExpSy,add,termSy) " D: "
 --  elms: ref IndexedRef(3,#Elm) " 
 -- 153 
 --  IndexedRef: 
 --     %globals
 --     %basic 160
 --     %public
 pushc 3
 mkRindexed 153
 -- end:loadArgs:NonVirt: "insertList((ExpSy,add,termSy)) "
 -- OI:invoke:before:ATdx.invoke: pattern 
 --  insertList(elms: ref IndexedRef(3,#Elm)) 
 -- ptn:invoke: "insertList(elms: ref IndexedRef(3,#Elm)) "E: "
 --  insertList((ExpSy,add,termSy)) "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "SymbolList " 
 --  adr:none 
 invoke insertList 147 0 0
 -- global:pushOut: OL off: 3 
 rpushg  3
 -- callInvoke:after:pushOut: 3 
 -- GeneralPTN:invoke:after:callInvoke: 3 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- assign:adr.store:A: 
 rswap 0
 rstoreg  EisNone 2
   ;; vTop(0,0)=[] rTop(-4,0)=[]
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS IndexedRef 153 0 BETA 2
 pushThis 
 storeg integer$5 1
 allocEventQ
 mvStack 
 -- DI:gen: "in range: var Integer " DI:isConst: false isBasicValue: 
 --  true primNo: 1 
 -- DI:gen:primitiveType: range 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:1

 CLASS insertList 147 1 OrderedList 92
 pushThis 
 rstoreg  elms 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "out OL: ref OrderedList " DI:isConst: false 
 --  isBasicValue: false primNo: 0 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "put('%') "
 -- INV:gen: "put('%') " 
 -- needorigin: "put('%') " 
 -- needOrigin:E: "put('%') "  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put('%') " rec: "put('%') " E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  E.ATd.desc: 
 --  %globals
 --  %basic 2
 --  in ch: val char
 --  E.ATd.IT: 
 --  %globals
 --  %basic 2
 --  in ch: val char
 -- \
 --   
 -- Ex:loadOrgin:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put('%') " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put('%') "E:  "put('%') "
 -- INV:gen:E.loadArgs "put('%') "
 -- NonVirt: "put('%') " "ObjectInvocation_KeyWord " ActArg: "'%' "
 --  isValue: true formalArg: "in ch: val char " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put('%') " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "'%' "
 -- INV:gen: "'%' " 
 -- needorigin: "'%' " 
 -- needOrigin:E: "'%' "  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16Ex: "'%' " rec: "'%' " E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16E.ATd.desc: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %publicE.ATd.IT: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 -- after:needOrigin: "'%' " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "'%' "E:  "'%' "
 -- INV:gen:E.loadArgs "'%' "
 -- INV:gen:after:E.loadArgs "'%' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "'%' "
 pushc 37
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "'%' ":isBasicVal: true 
 -- case:B: '%' ObjectGenerator 3 3 3 false true 
 -- checkNumberConvert: "'%' " D: "in ch: val char " 
 -- end:loadArgs:NonVirt: "put('%') "
 -- INV:gen:after:E.loadArgs "put('%') "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  put('%') "
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put "E: "put('%') "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 pushThis 
 -- before objTmpStack:add:  151   "for:to:repeat$151 "
 invoke for:to:repeat$151 151 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- AssignmentStatement:gen: "OL := this(OrderedList) " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "OL := this(OrderedList) " right.label: "ObjectGenerator ""
 --  this(OrderedList) " 
 -- OG:before:super.gen: "this(OrderedList) "
 -- INV:gen: "this(OrderedList) " 
 -- needorigin: "this(OrderedList) " 
 -- needOrigin:E: "this(OrderedList) "  E.ATd: 
 --  this: 
 --     %basic 18
 --     in this: ref Object
 --  Ex: "this(OrderedList) " rec: "this(OrderedList) " E.ATd: 
 --  this: 
 --     %basic 18
 --     in this: ref Object
 --  E.ATd.desc: 
 --  %basic 18
 --  in this: ref Object
 --  E.ATd.IT: 
 --  %basic 18
 --  in this: ref Object
 --  
 -- doNeedOrigin:Ex: "this(OrderedList) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "this(OrderedList) " 
 -- doNeedOrigin:E: "this(OrderedList) " 
 -- computeAdrX:superAdj: 0 "this(OrderedList) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "this(OrderedList) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "insertList "on: 1 isValueObj: false 
 --  origin: OrderedList origin:isValueObj: false 
 rpushg insertList$147 1
 -- computeAdrX:isLast:E:  "this(OrderedList) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(OrderedList)":rec:- 
 --  rec:  "this(OrderedList) "E:  "this(OrderedList) "
 -- INV:gen:E.loadArgs "this(OrderedList) "
 -- INV:gen:after:E.loadArgs "this(OrderedList) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "
 --  this(OrderedList) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(OrderedList)":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern this 
 -- ptn:invoke: "this "E: "this(OrderedList) "ptnKind: 0 useRtnV: 
 --  true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "
 --  this(OrderedList) " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(OrderedList)":rec:this(OrderedList) 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(OrderedList)":rec:this(OrderedList) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(OrderedList)":rec:this(OrderedList) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"this(OrderedList)":rec:this(OrderedList) 
 -- assign:adr.store:A: 
 rswap 0
 rstoreg  EisNone 3
   ;; vTop(0,0)=[] rTop(-5,0)=[]
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS length 148 1 IndexedRef 153
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "out res: var integer " DI:isConst: false isBasicValue: 
 --  true primNo: 1 
 -- DI:gen:primitiveType: res 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "res := get[0] " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "res := get[0] " right.label: "ObjectGenerator ""get[0] " 
 -- OG:before:super.gen: "get[0] "
 -- INV:gen: "get[0] " 
 -- needorigin: "get[0] " 
 -- needOrigin:E: "get[0] "  E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 116
 --     out V: ref elm
 --  Ex: "get[0] " rec: "get[0] " E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 116
 --     out V: ref elm
 --  E.ATd.desc: 
 --  %basic 116
 --  out V: ref elm
 --  E.ATd.IT: 
 --  %basic 116
 --  out V: ref elm
 --  
 -- doNeedOrigin:Ex: "get[0] "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "get[0] " 
 -- doNeedOrigin:E: "get[0] " 
 -- computeAdrX:superAdj: 0 "get[0] " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "get[0] " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "length "on: 1 isValueObj: false 
 --  origin: IndexedRef origin:isValueObj: false 
 rpushg length$148 1
 -- computeAdrX:isLast:E:  "get[0] "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0]":rec:- 
 --  rec:  "get[0] "E:  "get[0] "
 -- INV:gen:E.loadArgs "get[0] "
 -- NonVirt: "get[0] " "ObjectInvocation_KeyWord " ActArg: "0 "
 --  isValue: true formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[0] " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "0 "
 -- INV:gen: "0 " 
 -- needorigin: "0 " 
 -- needOrigin:E: "0 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "0 " rec: "0 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "0 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "0 "E:  "0 "
 -- INV:gen:E.loadArgs "0 "
 -- INV:gen:after:E.loadArgs "0 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0 "
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "0 ":isBasicVal: true 
 -- case:B: 0 ObjectGenerator 1 1 1 false true 
 -- checkNumberConvert: "0 " D: "inx: var integer " 
 -- end:loadArgs:NonVirt: "get[0] "
 -- INV:gen:after:E.loadArgs "get[0] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[0] "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0]":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- ptn:invoke: "get[inx: var integer] "E: "get[0] "ptnKind: 0 
 --  useRtnV: true 
 xpushg  inx 1 0 1
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0]":rec:get[0] 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0]":rec:get[0] 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0]":rec:get[0] 
 -- checkNumberConvert: "get[0] " D: "out res: var integer " 
 -- assign:adr.store:A: 
 storeg length$148 2
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS repeat$150 150 1 for:to:repeat$151 151
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:before:super.gen: "insert(elms.get[inx]) "
 -- INV:gen: "insert(elms.get[inx]) " 
 -- needorigin: "insert(elms.get[inx]) " 
 -- needOrigin:E: "insert(elms.get[inx]) "  E.ATd: 
 --  insert:: 
 --     if (head == none) :then 
 --        head := Link(e):next(none)
 --        tail := headEx: "insert(elms.get[inx]) " rec: "insert(elms.get[inx]) " 
 --  E.ATd: 
 --  insert:: 
 --     if (head == none) :then 
 --        head := Link(e):next(none)
 --        tail := headE.ATd.desc: 
 --  if (head == none) :then 
 --     head := Link(e):next(none)
 --     tail := head
 --  :else E.ATd.IT: 
 --  if (head == none) :then 
 --     head := Link(e):next(none)
 --     tail := head
 --  :else 
 -- doNeedOrigin:Ex: "insert(elms.get[inx]) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "insert(elms.get[inx]) " 
 -- doNeedOrigin:E: "insert(elms.get[inx]) " 
 -- computeAdrX:superAdj: 0 "insert(elms.get[inx]) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "
 --  insert(elms.get[inx]) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$150 "on: 3 isValueObj: false 
 --  origin: for:to:repeat$151 origin:isValueObj: false 
 rpushg repeat$150$150 1
 -- items:goOrigin:encOG: "for:to:repeat$151 "on: 2 isValueObj: 
 --  false 
 --  origin: insertList origin:isValueObj: false 
 rpushg for:to:repeat$151$151 4
 -- items:goOrigin:encOG: "insertList "on: 1 isValueObj: false 
 --  origin: OrderedList origin:isValueObj: false 
 rpushg insertList$147 1
 -- computeAdrX:isLast:E:  "insert(elms.get[inx]) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(elms.get[inx])":rec:- 
 --  rec:  "insert(elms.get[inx]) "E:  "insert(elms.get[inx]) "
 -- INV:gen:E.loadArgs "insert(elms.get[inx]) "
 -- NonVirt: "insert(elms.get[inx]) " "ObjectInvocation_KeyWord " 
 --  ActArg: "elms.get[inx] "isValue: false formalArg: "in e: ref elm " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: false 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "insert(elms.get[inx]) "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "elms.get[inx] "
 -- INV:gen: "elms.get[inx] " 
 -- needorigin: "elms.get[inx] " 
 -- needOrigin:E: "get[inx] "  E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 116
 --     out V: ref elm
 --  Ex: "get[inx] " rec: "elms " E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 116
 --     out V: ref elm
 --  E.ATd.desc: 
 --  %basic 116
 --  out V: ref elm
 --  E.ATd.IT: 
 --  %basic 116
 --  out V: ref elm
 --  
 -- doNeedOrigin:Ex: "get[inx] "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "get[inx] " 
 -- doNeedOrigin:E: "get[inx] " 
 -- computeAdrX:superAdj: 0 "elms.get[inx] " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "elms " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$150 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$151 origin:isValueObj: false 
 rpushg repeat$150$150 1
 -- items:goOrigin:encOG: "for:to:repeat$151 "on: 1 isValueObj: 
 --  false 
 --  origin: insertList origin:isValueObj: false 
 rpushg for:to:repeat$151$151 4
 -- computeAdrX:En: 2 pRec: "elms " rec: "elms " E: "get[inx] " 
 --  A.E: none 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "elms " rec: "elms " E: "
 --  get[inx] " 
 --  rec.ATd: "elms: ref IndexedRef(3,#Elm) " rec.ATD.OG.isValueObj: 
 --  false 
 --  rec.ATd.origin: 
 --  out OL: ref OrderedList
 --     put('%')
 --     for(1):to(elms.length):repeat
 --        insert(elms.get[inx])
 --  recA: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 --  pRecA: none 
 -- pRec: "elms " rec: "elms " E: "get[inx] " 
 --  false false 
 -- computeAdrX:before:rec:: "elms " 
 -- OI:invoke:before:ATdx.invoke: ref elms 
 -- DI:invoke: "elms: ref IndexedRef(3,#Elm) " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:elms isNotRemote: false 
 rpushg repeat$150$150 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:elms 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:elms 
 -- computeAdrX:after:rec.invoke: "elms " 
 -- computeAdrX:isLast:E:  "get[inx] "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:elms 
 --  rec:  "elms "E:  "get[inx] "
 -- INV:gen:E.loadArgs "get[inx] "
 -- NonVirt: "get[inx] " "ObjectInvocation_KeyWord " ActArg: "inx "
 --  isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx] " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "inx "
 -- INV:gen: "inx " 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$150 "on: 1 isValueObj: false 
 --  origin: for:to:repeat$151 origin:isValueObj: false 
 rpushg repeat$150$150 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 3 for:to:repeat$151$151
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- checkNumberConvert: "inx " D: "inx: var integer " 
 -- end:loadArgs:NonVirt: "get[inx] "
 -- INV:gen:after:E.loadArgs "get[inx] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx] "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:elms 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- ptn:invoke: "get[inx: var integer] "E: "get[inx] "ptnKind: 0 
 --  useRtnV: true 
 -- IndexedPTN:invoke: 
 --  get[inx: var integer]: 
 --     %basic 116
 --     out V: ref elm
 --  E: "get[inx] " rec: "elms " "elms: ref IndexedRef(3,#Elm) " 
 xrpushg  1 inx
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:elms 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:elms 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:elms 
 -- actualArg:isPtn: true formalArg:isPtn: "in e: ref elm "
 --  :isBasicVal: false :valueObj: false 
 --  :actArg: "elms.get[inx] ":isBasicVal: false 
 -- case:B: elms.get[inx] ObjectGenerator 0 116 116 false false 
 -- checkNumberConvert: "elms.get[inx] " D: "in e: ref elm " 
 -- end:loadArgs:NonVirt: "insert(elms.get[inx]) "
 -- INV:gen:after:E.loadArgs "insert(elms.get[inx]) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  insert(elms.get[inx]) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(elms.get[inx])":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern insert 
 -- ptn:invoke: "insert "E: "insert(elms.get[inx]) "ptnKind: 3 
 --  useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 rec: "
 --  insert(elms.get[inx]) " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(elms.get[inx])":rec:insert(elms.get[inx]) 
 -- isStatic: false rec: "insert(elms.get[inx]) "
 invokev 3 1 insert$137 0
 -- GeneralPTN:invoke:after:pushOut: 
 rpop 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(elms.get[inx])":rec:insert(elms.get[inx]) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(elms.get[inx])":rec:insert(elms.get[inx]) 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"insert(elms.get[inx])":rec:insert(elms.get[inx]) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS for:to:repeat$151 151 4 insertList 147
 -- vdtTableCopy: I:1:28 V:2:29
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- NonVirt: 
 --  for(1):to(elms.length):repeat
 --     insert(elms.get[inx])
 --  "ObjectInvocation_KeyWord " ActArg: "1 "isValue: true formalArg: "
 --  first: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  for(1):to(elms.length):repeat
 --     insert(elms.get[inx])
 --   " isCompositeValueObj: false 
 -- OG:before:super.gen: "1 "
 -- INV:gen: "1 " 
 -- needorigin: "1 " 
 -- needOrigin:E: "1 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "1 " rec: "1 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "1 " 
 -- IV:after:computeAdr:superAdj: 4 
 --  rec:  "1 "E:  "1 "
 -- INV:gen:E.loadArgs "1 "
 -- INV:gen:after:E.loadArgs "1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1 "
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "first: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- checkNumberConvert: "1 " D: "first: var integer " 
 -- end:loadArgs:NonVirt: "
 --  for(1):to(elms.length):repeat
 --     insert(elms.get[inx])
 --   "
 -- NonVirt: 
 --  for(1):to(elms.length):repeat
 --     insert(elms.get[inx])
 --  "ObjectInvocation_KeyWord " ActArg: "elms.length "isValue: false 
 --  formalArg: "last: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  for(1):to(elms.length):repeat
 --     insert(elms.get[inx])
 --   " isCompositeValueObj: false 
 -- OG:before:super.gen: "elms.length "
 -- INV:gen: "elms.length " 
 -- needorigin: "elms.length " 
 -- needOrigin:E: "length "  E.ATd: 
 --  length: 
 --     out res: var integer
 --     res := get[0]
 --  Ex: "length " rec: "elms " E.ATd: 
 --  length: 
 --     out res: var integer
 --     res := get[0]
 --  E.ATd.desc: 
 --  out res: var integer
 --  res := get[0]
 --  E.ATd.IT: 
 --  out res: var integer
 --  res := get[0]
 --  
 -- doNeedOrigin:Ex: "length "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "length " 
 -- doNeedOrigin:E: "length " 
 -- computeAdrX:superAdj: 4 "elms.length " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "elms " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 rpushg insertList$147 4
 -- computeAdrX:En: 2 pRec: "elms " rec: "elms " E: "length " 
 --  A.E: none 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "elms " rec: "elms " E: "length " 
 --  rec.ATd: "elms: ref IndexedRef(3,#Elm) " rec.ATD.OG.isValueObj: 
 --  false 
 --  rec.ATd.origin: 
 --  out OL: ref OrderedList
 --     put('%')
 --     for(1):to(elms.length):repeat
 --        insert(elms.get[inx])
 --  recA: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 --  pRecA: none 
 -- pRec: "elms " rec: "elms " E: "length " 
 --  false false 
 -- computeAdrX:before:rec:: "elms " 
 -- OI:invoke:before:ATdx.invoke: ref elms 
 -- DI:invoke: "elms: ref IndexedRef(3,#Elm) " 
 -- >Object:unique: false 
 -- Address:loadAdr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:elms 
 rpushg insertList$147 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:elms 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:elms 
 -- computeAdrX:after:rec.invoke: "elms " 
 -- computeAdrX:isLast:E:  "length "
 -- IV:after:computeAdr:superAdj: 4 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:elms 
 --  rec:  "elms "E:  "length "
 -- INV:gen:E.loadArgs "length "
 -- INV:gen:after:E.loadArgs "length "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:elms 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- ptn:invoke: "length "E: "length "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "elms " 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:elms 
 invoke length 148 0 0
 -- global:pushOut: res off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:elms 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:elms 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:elms 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:elms 
 -- actualArg:isPtn: true formalArg:isPtn: "last: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "elms.length ":isBasicVal: true 
 -- case:B: elms.length ObjectGenerator 1 0 0 false false 
 -- checkNumberConvert: "elms.length " D: "last: var integer " 
 -- end:loadArgs:NonVirt: "
 --  for(1):to(elms.length):repeat
 --     insert(elms.get[inx])
 --   "
 pushThis 
 storeg integer$5 2
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- DI:gen: "inx: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: inx 
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0

 CLASS OrderedList$152 152 0 insertList 147
 -- vdtTableCopy: I:1:80 V:2:0 V:3:137 V:4:126 V:5:97 V:6:133 V:7:134 V:8:136 I:9:92
 -- super OrderedList
 -- super OrderedList
 allocEventQ
 -- DI:gen: "head: ref link:next " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 -- DI:gen: "tail: ref Link:next " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 rtnAlloc 1
 toSuper 80
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0

 CLASS + 155 1 String 10
 pushThis 
 rstoreg  S 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "in S: var String " DI:isConst: false isBasicValue: 
 --  false primNo: 5 
 -- DI:gen: "out V: var String " DI:isConst: false isBasicValue: 
 --  false primNo: 5 
 -- DI:StringVar "out V: var String "
 pushText ""
 pushThis 
 rstoreg  V 3
   ;; vTop(0,0)=[] rTop(-3,0)=[]
 -- DI:gen: "L: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: L 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "L := Length " 
 pushThis 
 -- AssignmentStatement:gen: 
 --  "L := Length " right.label: "ObjectGenerator ""Length " 
 -- OG:before:super.gen: "Length "
 -- INV:gen: "Length " 
 -- needorigin: "Length " 
 -- needOrigin:E: "Length "  E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  Ex: "Length " rec: "Length " E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  E.ATd.desc: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  E.ATd.IT: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- doNeedOrigin:Ex: "Length "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "Length " 
 -- doNeedOrigin:E: "Length " 
 -- computeAdrX:superAdj: 0 "Length " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Length " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "+ "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg +$155 1
 -- computeAdrX:isLast:E:  "Length "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:- 
 --  rec:  "Length "E:  "Length "
 -- INV:gen:E.loadArgs "Length "
 -- INV:gen:after:E.loadArgs "Length "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "Length "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- ptn:invoke: "length "E: "Length "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "Length " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 -- checkNumberConvert: "Length " D: "L: var integer " 
 -- assign:adr.store:A: 
 storeg +$155 4
 -- assign:adr.store:B: 
 pushThis 
 -- before objTmpStack:add:  156   "doplus "
 invoke doplus 156 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS doplus 156 1 + 155
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "e: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: e 
 -- DI:gen: "i: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: i 
 -- DI:gen: "T: obj Indexed(L + S.length,Integer) " DI:isConst: true 
 --  isBasicValue: false primNo: 114 
 -- DI:isConst: T 
 -- DI:off: 4 this: "T: obj Indexed(L + S.length,Integer) " 
 --  
 -- OG:before:super.gen: "Indexed(L + S.length,Integer) "
 -- INV:gen: "Indexed(L + S.length,Integer) " 
 -- needorigin: "Indexed(L + S.length,Integer) " 
 -- needOrigin:E: "Indexed(L + S.length,Integer) "  E.ATd: 
 --  Indexed: 
 --     %globals
 --     %basic 114
 --     %publicEx: "Indexed(L + S.length,Integer) " rec: "
 --  Indexed(L + S.length,Integer) " E.ATd: 
 --  Indexed: 
 --     %globals
 --     %basic 114
 --     %publicE.ATd.desc: 
 --  %globals
 --  %basic 114
 --  %public
 --  in range: var IntegerE.ATd.IT: 
 --  %globals
 --  %basic 114
 --  %public
 --  in range: var Integer
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %globals
 --     %basic 114
 --     %public
 --     in range: var Integer
 -- after:needOrigin: "Indexed(L + S.length,Integer) " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "Indexed(L + S.length,Integer) "E:  "
 --  Indexed(L + S.length,Integer) "
 -- INV:gen:E.loadArgs "Indexed(L + S.length,Integer) "
 -- NonVirt: "Indexed(L + S.length,Integer) " "
 --  ObjectInvocation_Function " ActArg: "L + S.length "isValue: false formalArg: "
 --  in range: var Integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "Indexed(L + S.length,Integer) "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "L + S.length "
 -- INV:gen: "L + S.length " 
 -- needorigin: "L + S.length " 
 -- needOrigin:E: "L + S.length "  E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  Ex: "L + S.length " rec: "L + S.length " E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  E.ATd.desc: 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 --  E.ATd.IT: 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 -- \
 --   
 -- doNeedOrigin:Ex: "L + S.length "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "L + S.length " 
 -- doNeedOrigin:E: "L + S.length " 
 -- computeAdrX:superAdj: 0 "L + S.length " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L + S.length " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "L + S.length "superAdj: 0 
 -- computeAdrX:isLast:E:  "L + S.length "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "L + S.length "E:  "L + S.length "
 -- INV:gen:E.loadArgs "L + S.length "
 -- BinaryExp:loadArgs: "L + S.length " superAdj: 0 
 -- INV:gen: "L " 
 -- needorigin: "L " 
 -- needOrigin:E: "L "  E.ATd: "L: var integer " Ex: "L " rec: "L " 
 --  E.ATd: "L: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L " 
 -- doNeedOrigin:E: "L " 
 -- computeAdrX:superAdj: 0 "L " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "doplus "on: 1 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$156 1
 -- computeAdrX:isLast:E:  "L "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 --  rec:  "L "E:  "L "
 -- INV:gen:E.loadArgs "L "
 -- INV:gen:after:E.loadArgs "L "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- DI:invoke: "L: var integer " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L isNotRemote: true 
 pushg 4 +$155
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:end:off: 4 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- NonVirt: "+ S.length " "ObjectInvocation_Binary " ActArg: "
 --  S.length "isValue: false formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ S.length " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "S.length "
 -- INV:gen: "S.length " 
 -- needorigin: "S.length " 
 -- needOrigin:E: "length "  E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  Ex: "length " rec: "S " E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  E.ATd.desc: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  E.ATd.IT: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- doNeedOrigin:Ex: "length "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "length " 
 -- doNeedOrigin:E: "length " 
 -- computeAdrX:superAdj: 0 "S.length " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "S " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "doplus "on: 1 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$156 1
 -- computeAdrX:En: 2 pRec: "S " rec: "S " E: "length " 
 --  A.E: none 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "S " rec: "S " E: "length " 
 --  rec.ATd: "in S: var String " rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  in S: var String
 --     out V: var String
 --     L: var integer
 --     L := Length
 --  recA: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 --  pRecA: none 
 -- pRec: "S " rec: "S " E: "length " 
 --  false false 
 -- computeAdrX:before:rec:: "S " 
 -- OI:invoke:before:ATdx.invoke: var S 
 -- DI:invoke: "in S: var String " 
 -- >Object:unique: false 
 -- Address:loadAdr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 rpushg doplus$156 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- computeAdrX:after:rec.invoke: "S " 
 -- computeAdrX:isLast:E:  "length "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 --  rec:  "S "E:  "length "
 -- INV:gen:E.loadArgs "length "
 -- INV:gen:after:E.loadArgs "length "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- ptn:invoke: "length "E: "length "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "S " 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "S.length ":isBasicVal: true 
 -- case:B: S.length ObjectGenerator 1 0 0 false false 
 -- checkNumberConvert: "S.length " D: "in V: var integer " 
 -- end:loadArgs:NonVirt: "+ S.length "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:after:E.loadArgs "L + S.length "
 --  OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L + S.length "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- BinaryExp:invoke: "L "rec: "L + S.length "
 -- M: "+ S.length "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- ptn:invoke: "+   "E: "+ S.length "ptnKind: 0 useRtnV: true 
 plus
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ S.length":rec:L 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ S.length":rec:L 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in range: var Integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "L + S.length ":isBasicVal: true 
 -- case:B: L + S.length ObjectGenerator 1 61 61 false false 
 -- checkNumberConvert: "L + S.length " D: "in range: var Integer " 
 -- end:loadArgs:NonVirt: "Indexed(L + S.length,Integer) "
 -- INV:gen:after:E.loadArgs "Indexed(L + S.length,Integer) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Function "
 --  Indexed(L + S.length,Integer) "
 -- OI:invoke:before:ATdx.invoke: pattern Indexed 
 -- ptn:invoke: "Indexed "E: "Indexed(L + S.length,Integer) "
 --  ptnKind: 0 useRtnV: false 
 pushThis 
 pushc 1
 allocIndexed doplus$156 157 1 0
 pushThis 
 rstoreg  doplus$156 4
   ;; vTop(2,2)=[0/0,0/0] rTop(-4,0)=[]
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 pushThis 
 -- before objTmpStack:add:  161   "for:to:repeat$161 "
 invoke for:to:repeat$161 161 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- before objTmpStack:add:  163   "for:to:repeat$163 "
 invoke for:to:repeat$163 163 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- AssignmentStatement:gen: 
 --  V := T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 pushThis 
 -- items:goOrigin:encOG: "doplus "on: 1 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$156 1
 -- AssignmentStatement:gen: 
 --  
 --  V := T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  right.label: "ObjectGenerator "
 --  T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- OG:before:super.gen: "
 --  T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "
 -- INV:gen: 
 --  T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- needorigin: 
 --  T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- needOrigin:E: 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --   E.ATd: 
 --  asString: 
 --     %basic 118
 --     out S: var LIB.StringLib.String
 --  Ex: 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  rec: "T " E.ATd: 
 --  asString: 
 --     %basic 118
 --     out S: var LIB.StringLib.String
 --  E.ATd.desc: 
 --  %basic 118
 -- \
 --   out S: var LIB.StringLib.String
 --  E.ATd.IT: 
 --  %basic 118
 --  out S: var LIB.StringLib.String
 --  
 -- doNeedOrigin:Ex: "
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- doNeedOrigin:E: 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- computeAdrX:superAdj: 0 
 --  T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- computeAdrX:En: 1 pRec: none rec: none E: "T " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- computeAdrX:En: 2 pRec: "T " rec: "T " E: 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 --  A.E: none 
 --  
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "T " rec: "T " E: 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 --  rec.ATd: "T: obj Indexed(L + S.length,Integer) " 
 --  rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  e: var integer
 --     i: var integer
 --     T: obj Indexed(L + S.length,Integer)
 --     for(1):to(L):repeat
 --  recA: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:- 
 --  pRecA: none 
 -- pRec: "T " rec: "T " E: 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 --  false false 
 -- computeAdrX:before:rec:: "T " 
 -- OI:invoke:before:ATdx.invoke: obj T 
 -- DI:invoke: "T: obj Indexed(L + S.length,Integer) " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:T isNotRemote: false 
 rpushg doplus$156 4
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:T 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:T 
 -- computeAdrX:after:rec.invoke: "T " 
 -- computeAdrX:isLast:E:  "
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:T 
 --  rec:  "T "E:  "
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "
 -- INV:gen:E.loadArgs "
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "
 -- INV:gen:after:E.loadArgs "
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:T 
 -- OI:invoke:before:ATdx.invoke: pattern asString 
 -- ptn:invoke: "asString "E: "
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "ptnKind: 0 useRtnV: true 
 %asString 118
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:T 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:T 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:T 
 -- assign:adr.store:A: 
 rswap 0
 rstoreg  EisNone 3
   ;; vTop(2,2)=[0/0,0/0] rTop(-8,0)=[]
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS Indexed 157 0 BETA 2
 pushThis 
 storeg integer$5 1
 allocEventQ
 mvStack 
 -- DI:gen: "in range: var Integer " DI:isConst: false isBasicValue: 
 --  true primNo: 1 
 -- DI:gen:primitiveType: range 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:1

 CLASS repeat$159 159 1 for:to:repeat$161 161
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "e := get[inx] " 
 pushThis 
 -- items:goOrigin:encOG: "repeat$159 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$161 origin:isValueObj: false 
 rpushg repeat$159$159 1
 -- items:goOrigin:encOG: "for:to:repeat$161 "on: 1 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$161$161 4
 -- AssignmentStatement:gen: 
 --  "e := get[inx] " right.label: "ObjectGenerator ""get[inx] " 
 -- OG:before:super.gen: "get[inx] "
 -- INV:gen: "get[inx] " 
 -- needorigin: "get[inx] " 
 -- needOrigin:E: "get[inx] "  E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  Ex: "get[inx] " rec: "get[inx] " E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  E.ATd.desc: 
 --  %basic 117
 --  out ch: var char
 --  E.ATd.IT: 
 --  %basic 117
 --  out ch: var char
 --  
 -- doNeedOrigin:Ex: "get[inx] "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "get[inx] " 
 -- doNeedOrigin:E: "get[inx] " 
 -- computeAdrX:superAdj: 0 "get[inx] " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "get[inx] " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$159 "on: 4 isValueObj: false 
 --  origin: for:to:repeat$161 origin:isValueObj: false 
 rpushg repeat$159$159 1
 -- items:goOrigin:encOG: "for:to:repeat$161 "on: 3 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$161$161 4
 -- items:goOrigin:encOG: "doplus "on: 2 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$156 1
 -- items:goOrigin:encOG: "+ "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg +$155 1
 -- computeAdrX:isLast:E:  "get[inx] "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 --  rec:  "get[inx] "E:  "get[inx] "
 -- INV:gen:E.loadArgs "get[inx] "
 -- NonVirt: "get[inx] " "ObjectInvocation_KeyWord " ActArg: "inx "
 --  isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx] " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "inx "
 -- INV:gen: "inx " 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$159 "on: 1 isValueObj: false 
 --  origin: for:to:repeat$161 origin:isValueObj: false 
 rpushg repeat$159$159 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 3 for:to:repeat$161$161
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- checkNumberConvert: "inx " D: "inx: var integer " 
 -- end:loadArgs:NonVirt: "get[inx] "
 -- INV:gen:after:E.loadArgs "get[inx] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx] "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- ptn:invoke: "get[inx: var integer] "E: "get[inx] "ptnKind: 0 
 --  useRtnV: true 
 xpushg  inx 1 0 1
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- checkNumberConvert: "get[inx] " D: "e: var integer " 
 -- assign:adr.store:A: 
 storeg doplus$156 2
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "T.put(e):at[inx] "
 -- INV:gen: "T.put(e):at[inx] " 
 -- needorigin: "T.put(e):at[inx] " 
 -- needOrigin:E: "put(e):at[inx] "  E.ATd: 
 --  put(V: var integer):at[inx: var integer]: 
 --     %basic 115
 --  Ex: "put(e):at[inx] " rec: "T " E.ATd: 
 --  put(V: var integer):at[inx: var integer]: 
 --     %basic 115
 --  E.ATd.desc: "%basic 115 " E.ATd.IT: "%basic 115 " 
 -- doNeedOrigin:Ex: "put(e):at[inx] "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "put(e):at[inx] " 
 -- doNeedOrigin:E: "put(e):at[inx] " 
 -- computeAdrX:superAdj: 0 "T.put(e):at[inx] " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "T " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$159 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$161 origin:isValueObj: false 
 rpushg repeat$159$159 1
 -- items:goOrigin:encOG: "for:to:repeat$161 "on: 1 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$161$161 4
 -- computeAdrX:En: 2 pRec: "T " rec: "T " E: "put(e):at[inx] " 
 --  A.E: none 
 --  
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "T " rec: "T " E: "
 --  put(e):at[inx] " 
 --  rec.ATd: "T: obj Indexed(L + S.length,Integer) " 
 --  rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  e: var integer
 --     i: var integer
 --     T: obj Indexed(L + S.length,Integer)
 --     for(1):to(L):repeat
 --  recA: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:- 
 --  pRecA: none 
 -- pRec: "T " rec: "T " E: "put(e):at[inx] " 
 --  false false 
 -- computeAdrX:before:rec:: "T " 
 -- OI:invoke:before:ATdx.invoke: obj T 
 -- DI:invoke: "T: obj Indexed(L + S.length,Integer) " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T isNotRemote: false 
 rpushg repeat$159$159 4
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- computeAdrX:after:rec.invoke: "T " 
 -- computeAdrX:isLast:E:  "put(e):at[inx] "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 --  rec:  "T "E:  "put(e):at[inx] "
 -- INV:gen:E.loadArgs "put(e):at[inx] "
 -- NonVirt: "put(e):at[inx] " "ObjectInvocation_KeyWord " ActArg: "e "
 --  isValue: false formalArg: "V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(e):at[inx] "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "e "
 -- INV:gen: "e " 
 -- needorigin: "e " 
 -- needOrigin:E: "e "  E.ATd: "e: var integer " Ex: "e " rec: "e " 
 --  E.ATd: "e: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "e " 
 -- doNeedOrigin:E: "e " 
 -- computeAdrX:superAdj: 0 "e " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "e " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$159 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$161 origin:isValueObj: false 
 rpushg repeat$159$159 1
 -- items:goOrigin:encOG: "for:to:repeat$161 "on: 1 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$161$161 4
 -- computeAdrX:isLast:E:  "e "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 --  rec:  "e "E:  "e "
 -- INV:gen:E.loadArgs "e "
 -- INV:gen:after:E.loadArgs "e "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "e "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- OI:invoke:before:ATdx.invoke: var e 
 -- DI:invoke: "e: var integer " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e isNotRemote: true 
 pushg 2 doplus$156
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- actualArg:isPtn: false formalArg:isPtn: "V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "e ":isBasicVal: true 
 -- case:B: e ObjectGenerator 1 0 1 false false 
 -- checkNumberConvert: "e " D: "V: var integer " 
 -- end:loadArgs:NonVirt: "put(e):at[inx] "
 -- NonVirt: "put(e):at[inx] " "ObjectInvocation_KeyWord " ActArg: "
 --  inx "isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(e):at[inx] "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "inx "
 -- INV:gen: "inx " 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$159 "on: 1 isValueObj: false 
 --  origin: for:to:repeat$161 origin:isValueObj: false 
 rpushg repeat$159$159 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 3 for:to:repeat$161$161
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- checkNumberConvert: "inx " D: "inx: var integer " 
 -- end:loadArgs:NonVirt: "put(e):at[inx] "
 -- INV:gen:after:E.loadArgs "put(e):at[inx] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  put(e):at[inx] "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- OI:invoke:before:ATdx.invoke: pattern 
 --  put(V: var integer):at[inx: var integer] 
 -- ptn:invoke: "put(V: var integer):at[inx: var integer] "E: "
 --  put(e):at[inx] "ptnKind: 0 useRtnV: false 
 -- IndexedPTN:invoke: 
 --  put(V: var integer):at[inx: var integer]: 
 --     %basic 115
 --  E: "put(e):at[inx] " rec: "T " "
 --  T: obj Indexed(L + S.length,Integer) " 
 xstoreg  inx 1 0 1
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS for:to:repeat$161 161 4 doplus 156
 -- vdtTableCopy: I:1:28 V:2:29
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- NonVirt: 
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --  "ObjectInvocation_KeyWord " ActArg: "1 "isValue: true formalArg: "
 --  first: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --   " isCompositeValueObj: false 
 -- OG:before:super.gen: "1 "
 -- INV:gen: "1 " 
 -- needorigin: "1 " 
 -- needOrigin:E: "1 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "1 " rec: "1 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "1 " 
 -- IV:after:computeAdr:superAdj: 4 
 --  rec:  "1 "E:  "1 "
 -- INV:gen:E.loadArgs "1 "
 -- INV:gen:after:E.loadArgs "1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1 "
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "first: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- checkNumberConvert: "1 " D: "first: var integer " 
 -- end:loadArgs:NonVirt: "
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --   "
 -- NonVirt: 
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --  "ObjectInvocation_KeyWord " ActArg: "L "isValue: false 
 --  formalArg: "last: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --   " isCompositeValueObj: false 
 -- OG:before:super.gen: "L "
 -- INV:gen: "L " 
 -- needorigin: "L " 
 -- needOrigin:E: "L "  E.ATd: "L: var integer " Ex: "L " rec: "L " 
 --  E.ATd: "L: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L " 
 -- doNeedOrigin:E: "L " 
 -- computeAdrX:superAdj: 4 "L " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 rpushg doplus$156 4
 -- items:goOrigin:encOG: "doplus "on: 1 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$156 1
 -- computeAdrX:isLast:E:  "L "
 -- IV:after:computeAdr:superAdj: 4 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 --  rec:  "L "E:  "L "
 -- INV:gen:E.loadArgs "L "
 -- INV:gen:after:E.loadArgs "L "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- DI:invoke: "L: var integer " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L isNotRemote: true 
 pushg 4 +$155
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- actualArg:isPtn: false formalArg:isPtn: "last: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "L ":isBasicVal: true 
 -- case:B: L ObjectGenerator 1 0 1 false false 
 -- checkNumberConvert: "L " D: "last: var integer " 
 -- end:loadArgs:NonVirt: "
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --   "
 pushThis 
 storeg integer$5 2
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- DI:gen: "inx: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: inx 
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0

 CLASS repeat$162 162 1 for:to:repeat$163 163
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- AssignmentStatement:gen: "e := S.get[inx] " 
 pushThis 
 -- items:goOrigin:encOG: "repeat$162 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$163 origin:isValueObj: false 
 rpushg repeat$162$162 1
 -- items:goOrigin:encOG: "for:to:repeat$163 "on: 1 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$163$163 4
 -- AssignmentStatement:gen: 
 --  "e := S.get[inx] " right.label: "ObjectGenerator ""S.get[inx] " 
 -- OG:before:super.gen: "S.get[inx] "
 -- INV:gen: "S.get[inx] " 
 -- needorigin: "S.get[inx] " 
 -- needOrigin:E: "get[inx] "  E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  Ex: "get[inx] " rec: "S " E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  E.ATd.desc: 
 --  %basic 117
 --  out ch: var char
 --  E.ATd.IT: 
 --  %basic 117
 --  out ch: var char
 --  
 -- doNeedOrigin:Ex: "get[inx] "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "get[inx] " 
 -- doNeedOrigin:E: "get[inx] " 
 -- computeAdrX:superAdj: 0 "S.get[inx] " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "S " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$162 "on: 3 isValueObj: false 
 --  origin: for:to:repeat$163 origin:isValueObj: false 
 rpushg repeat$162$162 1
 -- items:goOrigin:encOG: "for:to:repeat$163 "on: 2 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$163$163 4
 -- items:goOrigin:encOG: "doplus "on: 1 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$156 1
 -- computeAdrX:En: 2 pRec: "S " rec: "S " E: "get[inx] " 
 --  A.E: none 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "S " rec: "S " E: "get[inx] " 
 --  rec.ATd: "in S: var String " rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  in S: var String
 --     out V: var String
 --     L: var integer
 --     L := Length
 --  recA: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 --  pRecA: none 
 -- pRec: "S " rec: "S " E: "get[inx] " 
 --  false false 
 -- computeAdrX:before:rec:: "S " 
 -- OI:invoke:before:ATdx.invoke: var S 
 -- DI:invoke: "in S: var String " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S isNotRemote: false 
 rpushg repeat$162$162 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- computeAdrX:after:rec.invoke: "S " 
 -- computeAdrX:isLast:E:  "get[inx] "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 --  rec:  "S "E:  "get[inx] "
 -- INV:gen:E.loadArgs "get[inx] "
 -- NonVirt: "get[inx] " "ObjectInvocation_KeyWord " ActArg: "inx "
 --  isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx] " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "inx "
 -- INV:gen: "inx " 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$162 "on: 1 isValueObj: false 
 --  origin: for:to:repeat$163 origin:isValueObj: false 
 rpushg repeat$162$162 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 3 for:to:repeat$163$163
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- checkNumberConvert: "inx " D: "inx: var integer " 
 -- end:loadArgs:NonVirt: "get[inx] "
 -- INV:gen:after:E.loadArgs "get[inx] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx] "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- ptn:invoke: "get[inx: var integer] "E: "get[inx] "ptnKind: 0 
 --  useRtnV: true 
 xpushg  inx 1 0 1
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- checkNumberConvert: "S.get[inx] " D: "e: var integer " 
 -- assign:adr.store:A: 
 storeg doplus$156 2
 -- assign:adr.store:B: 
 -- AssignmentStatement:gen: "i := L + inx " 
 pushThis 
 -- items:goOrigin:encOG: "repeat$162 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$163 origin:isValueObj: false 
 rpushg repeat$162$162 1
 -- items:goOrigin:encOG: "for:to:repeat$163 "on: 1 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$163$163 4
 -- AssignmentStatement:gen: 
 --  "i := L + inx " right.label: "ObjectGenerator ""L + inx " 
 -- OG:before:super.gen: "L + inx "
 -- INV:gen: "L + inx " 
 -- needorigin: "L + inx " 
 -- needOrigin:E: "L + inx "  E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  Ex: "L + inx " rec: "L + inx " E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  E.ATd.desc: 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 --  E.ATd.IT: 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 -- \
 --   
 -- doNeedOrigin:Ex: "L + inx "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "L + inx " 
 -- doNeedOrigin:E: "L + inx " 
 -- computeAdrX:superAdj: 0 "L + inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L + inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- BinaryExp:loadOrigin:empty: "L + inx "superAdj: 0 
 -- computeAdrX:isLast:E:  "L + inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "L + inx "E:  "L + inx "
 -- INV:gen:E.loadArgs "L + inx "
 -- BinaryExp:loadArgs: "L + inx " superAdj: 0 
 -- INV:gen: "L " 
 -- needorigin: "L " 
 -- needOrigin:E: "L "  E.ATd: "L: var integer " Ex: "L " rec: "L " 
 --  E.ATd: "L: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L " 
 -- doNeedOrigin:E: "L " 
 -- computeAdrX:superAdj: 0 "L " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$162 "on: 3 isValueObj: false 
 --  origin: for:to:repeat$163 origin:isValueObj: false 
 rpushg repeat$162$162 1
 -- items:goOrigin:encOG: "for:to:repeat$163 "on: 2 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$163$163 4
 -- items:goOrigin:encOG: "doplus "on: 1 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$156 1
 -- computeAdrX:isLast:E:  "L "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 --  rec:  "L "E:  "L "
 -- INV:gen:E.loadArgs "L "
 -- INV:gen:after:E.loadArgs "L "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- DI:invoke: "L: var integer " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L isNotRemote: true 
 pushg 4 +$155
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:end:off: 4 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- NonVirt: "+ inx " "ObjectInvocation_Binary " ActArg: "inx "
 --  isValue: false formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ inx " isCompositeValueObj: 
 --  false 
 -- OG:before:super.gen: "inx "
 -- INV:gen: "inx " 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$162 "on: 1 isValueObj: false 
 --  origin: for:to:repeat$163 origin:isValueObj: false 
 rpushg repeat$162$162 1
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 pushg 3 for:to:repeat$163$163
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- checkNumberConvert: "inx " D: "in V: var integer " 
 -- end:loadArgs:NonVirt: "+ inx "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:after:E.loadArgs "L + inx "
 --  OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L + inx "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- BinaryExp:invoke: "L "rec: "L + inx "
 -- M: "+ inx "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- ptn:invoke: "+   "E: "+ inx "ptnKind: 0 useRtnV: true 
 plus
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ inx":rec:L 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ inx":rec:L 
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- checkNumberConvert: "L + inx " D: "i: var integer " 
 -- assign:adr.store:A: 
 storeg doplus$156 3
 -- assign:adr.store:B: 
 -- OG:before:super.gen: "T.put(e):at[i] "
 -- INV:gen: "T.put(e):at[i] " 
 -- needorigin: "T.put(e):at[i] " 
 -- needOrigin:E: "put(e):at[i] "  E.ATd: 
 --  put(V: var integer):at[inx: var integer]: 
 --     %basic 115
 --  Ex: "put(e):at[i] " rec: "T " E.ATd: 
 --  put(V: var integer):at[inx: var integer]: 
 --     %basic 115
 --  E.ATd.desc: "%basic 115 " E.ATd.IT: "%basic 115 " 
 -- doNeedOrigin:Ex: "put(e):at[i] "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "put(e):at[i] " 
 -- doNeedOrigin:E: "put(e):at[i] " 
 -- computeAdrX:superAdj: 0 "T.put(e):at[i] " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "T " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$162 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$163 origin:isValueObj: false 
 rpushg repeat$162$162 1
 -- items:goOrigin:encOG: "for:to:repeat$163 "on: 1 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$163$163 4
 -- computeAdrX:En: 2 pRec: "T " rec: "T " E: "put(e):at[i] " 
 --  A.E: none 
 --  
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "T " rec: "T " E: "put(e):at[i] " 
 --  rec.ATd: "T: obj Indexed(L + S.length,Integer) " 
 --  rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  e: var integer
 --     i: var integer
 --     T: obj Indexed(L + S.length,Integer)
 --     for(1):to(L):repeat
 --  recA: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:- 
 --  pRecA: none 
 -- pRec: "T " rec: "T " E: "put(e):at[i] " 
 --  false false 
 -- computeAdrX:before:rec:: "T " 
 -- OI:invoke:before:ATdx.invoke: obj T 
 -- DI:invoke: "T: obj Indexed(L + S.length,Integer) " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T isNotRemote: false 
 rpushg repeat$162$162 4
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- computeAdrX:after:rec.invoke: "T " 
 -- computeAdrX:isLast:E:  "put(e):at[i] "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 --  rec:  "T "E:  "put(e):at[i] "
 -- INV:gen:E.loadArgs "put(e):at[i] "
 -- NonVirt: "put(e):at[i] " "ObjectInvocation_KeyWord " ActArg: "e "
 --  isValue: false formalArg: "V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(e):at[i] "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "e "
 -- INV:gen: "e " 
 -- needorigin: "e " 
 -- needOrigin:E: "e "  E.ATd: "e: var integer " Ex: "e " rec: "e " 
 --  E.ATd: "e: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "e " 
 -- doNeedOrigin:E: "e " 
 -- computeAdrX:superAdj: 0 "e " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "e " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$162 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$163 origin:isValueObj: false 
 rpushg repeat$162$162 1
 -- items:goOrigin:encOG: "for:to:repeat$163 "on: 1 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$163$163 4
 -- computeAdrX:isLast:E:  "e "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 --  rec:  "e "E:  "e "
 -- INV:gen:E.loadArgs "e "
 -- INV:gen:after:E.loadArgs "e "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "e "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- OI:invoke:before:ATdx.invoke: var e 
 -- DI:invoke: "e: var integer " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e isNotRemote: true 
 pushg 2 doplus$156
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- actualArg:isPtn: false formalArg:isPtn: "V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "e ":isBasicVal: true 
 -- case:B: e ObjectGenerator 1 0 1 false false 
 -- checkNumberConvert: "e " D: "V: var integer " 
 -- end:loadArgs:NonVirt: "put(e):at[i] "
 -- NonVirt: "put(e):at[i] " "ObjectInvocation_KeyWord " ActArg: "i "
 --  isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(e):at[i] "
 --   isCompositeValueObj: false 
 -- OG:before:super.gen: "i "
 -- INV:gen: "i " 
 -- needorigin: "i " 
 -- needOrigin:E: "i "  E.ATd: "i: var integer " Ex: "i " rec: "i " 
 --  E.ATd: "i: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "i " 
 -- doNeedOrigin:E: "i " 
 -- computeAdrX:superAdj: 0 "i " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "i " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 -- items:goOrigin:encOG: "repeat$162 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$163 origin:isValueObj: false 
 rpushg repeat$162$162 1
 -- items:goOrigin:encOG: "for:to:repeat$163 "on: 1 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$163$163 4
 -- computeAdrX:isLast:E:  "i "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 --  rec:  "i "E:  "i "
 -- INV:gen:E.loadArgs "i "
 -- INV:gen:after:E.loadArgs "i "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "i "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- OI:invoke:before:ATdx.invoke: var i 
 -- DI:invoke: "i: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i isNotRemote: true 
 pushg 3 doplus$156
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "i ":isBasicVal: true 
 -- case:B: i ObjectGenerator 1 0 1 false false 
 -- checkNumberConvert: "i " D: "inx: var integer " 
 -- end:loadArgs:NonVirt: "put(e):at[i] "
 -- INV:gen:after:E.loadArgs "put(e):at[i] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  put(e):at[i] "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- OI:invoke:before:ATdx.invoke: pattern 
 --  put(V: var integer):at[inx: var integer] 
 -- ptn:invoke: "put(V: var integer):at[inx: var integer] "E: "
 --  put(e):at[i] "ptnKind: 0 useRtnV: false 
 -- IndexedPTN:invoke: 
 --  put(V: var integer):at[inx: var integer]: 
 --     %basic 115
 --  E: "put(e):at[i] " rec: "T " "
 --  T: obj Indexed(L + S.length,Integer) " 
 xstoreg  inx 1 0 1
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS for:to:repeat$163 163 4 doplus 156
 -- vdtTableCopy: I:1:28 V:2:29
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- NonVirt: 
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]"ObjectInvocation_KeyWord " ActArg: "1 "isValue: true formalArg: "
 --  first: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 --   " isCompositeValueObj: false 
 -- OG:before:super.gen: "1 "
 -- INV:gen: "1 " 
 -- needorigin: "1 " 
 -- needOrigin:E: "1 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "1 " rec: "1 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "1 " 
 -- IV:after:computeAdr:superAdj: 4 
 --  rec:  "1 "E:  "1 "
 -- INV:gen:E.loadArgs "1 "
 -- INV:gen:after:E.loadArgs "1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1 "
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "first: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- checkNumberConvert: "1 " D: "first: var integer " 
 -- end:loadArgs:NonVirt: "
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 --   "
 -- NonVirt: 
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]"ObjectInvocation_KeyWord " ActArg: "S.length "isValue: false 
 --  formalArg: "last: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 --   " isCompositeValueObj: false 
 -- OG:before:super.gen: "S.length "
 -- INV:gen: "S.length " 
 -- needorigin: "S.length " 
 -- needOrigin:E: "length "  E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  Ex: "length " rec: "S " E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  E.ATd.desc: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  E.ATd.IT: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- doNeedOrigin:Ex: "length "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "length " 
 -- doNeedOrigin:E: "length " 
 -- computeAdrX:superAdj: 4 "S.length " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "S " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 pushThis 
 rpushg doplus$156 4
 -- items:goOrigin:encOG: "doplus "on: 1 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$156 1
 -- computeAdrX:En: 2 pRec: "S " rec: "S " E: "length " 
 --  A.E: none 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:loadRec: 2 pRec: "S " rec: "S " E: "length " 
 --  rec.ATd: "in S: var String " rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  in S: var String
 --     out V: var String
 --     L: var integer
 --     L := Length
 --  recA: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 --  pRecA: none 
 -- pRec: "S " rec: "S " E: "length " 
 --  false false 
 -- computeAdrX:before:rec:: "S " 
 -- OI:invoke:before:ATdx.invoke: var S 
 -- DI:invoke: "in S: var String " 
 -- >Object:unique: false 
 -- Address:loadAdr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 rpushg doplus$156 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- computeAdrX:after:rec.invoke: "S " 
 -- computeAdrX:isLast:E:  "length "
 -- IV:after:computeAdr:superAdj: 4 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 --  rec:  "S "E:  "length "
 -- INV:gen:E.loadArgs "length "
 -- INV:gen:after:E.loadArgs "length "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- ptn:invoke: "length "E: "length "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "S " 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- actualArg:isPtn: true formalArg:isPtn: "last: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "S.length ":isBasicVal: true 
 -- case:B: S.length ObjectGenerator 1 0 0 false false 
 -- checkNumberConvert: "S.length " D: "last: var integer " 
 -- end:loadArgs:NonVirt: "
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 --   "
 pushThis 
 storeg integer$5 2
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- DI:gen: "inx: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: inx 
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0

 CLASS asString 164 1 Indexed 157
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- DI:gen: "out S: var LIB.StringLib.String " DI:isConst: false 
 --  isBasicValue: false primNo: 5 
 -- DI:StringVar "out S: var LIB.StringLib.String "
 pushText ""
 pushThis 
 rstoreg  S 2
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS valProx 165 1 Object 0
 END OSDV:0 objSize:4 isIndexed:0

 CLASS VM 166 0 Object 0
 L1:
 pushThis 
 invoke BETAworld 1 0 1
 stop
 L2:
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS EventProcessor 167 0 Object 0
 stop
 END OSDV:0 objSize:1 isIndexed:0

 CLASS ThreadStub 168 0 Object 0
DO:
 call(D)ThreadStub
 stop
 END OSDV:0 objSize:1 isIndexed:0

Class BETAworld descInx:1 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	pushthis 
7:	saveBETAworld
8:	mvStack
allocE: 
9:	pushthis 
10:	invoke 2 2 1
16:	rpop 
17:	pushthis 
18:	invoke 33 3 1
24:	rpop 
25:	pushthis 
26:	invoke 67 4 1
32:	rpop 
33:	rtnAlloc 1
doE: 
35:	doEventQ 
36:	mvStack
37:	setThisStack
38:	pushthis 
39:	rtn D


Class BETA descInx:2 objSize:3 originOff: 1 visibility: 2
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 3 2 1
14:	rpop 
15:	rtnAlloc 1
doE: 
17:	doEventQ 
18:	mvStack
19:	setThisStack
20:	pushthis 
21:	rtn D


Class ascii descInx:3 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushc 10
9:	pushthis 
10:	storeg 2
12:	pushc 13
14:	pushthis 
15:	storeg 3
17:	pushc 0
19:	pushthis 
20:	storeg 4
22:	rtnAlloc 1
doE: 
24:	doEventQ 
25:	mvStack
26:	pushthis 
27:	pushc 10
29:	storeg 5
31:	setThisStack
32:	pushthis 
33:	rtn D


Class Value descInx:4 objSize:0 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	mvStack
allocE: 
2:	rtnAlloc 1
doE: 
4:	mvStack
5:	setThisStack
6:	pushthis 
7:	rtn D


Class integer descInx:5 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	mvStack
allocE: 
2:	rtnAlloc 1
doE: 
4:	mvStack
5:	setThisStack
6:	pushthis 
7:	rtn D


Class universal descInx:6 objSize:0 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	mvStack
allocE: 
2:	rtnAlloc 1
doE: 
4:	mvStack
5:	setThisStack
6:	pushthis 
7:	rtn D


Class char descInx:7 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	mvStack
allocE: 
2:	rtnAlloc 1
doE: 
4:	mvStack
5:	setThisStack
6:	pushthis 
7:	rtn D


Class ConsoleIF descInx:8 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class put descInx:9 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class String descInx:10 objSize:0 originOff: 0 visibility: 2
storeOrgAndArgsE:
1:	allocEventQ 1
3:	mvStack
allocE: 
4:	rtnAlloc 1
doE: 
6:	doEventQ 
7:	mvStack
8:	setThisStack
9:	pushthis 
10:	rtn D


Class = descInx:11 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	jmpFalse 13
4:	pushthis 
5:	vassign 4 2 0
10:	jmp 20
13:	invokeVal 31 3 0
19:	rpop 
20:	tstOriginNone 
21:	rstore 1
23:	allocEventQ 0
25:	mvStack
allocE: 
26:	rtnAlloc 1
doE: 
28:	doEventQ 
29:	mvStack
30:	pushthis 
31:	innerP 2
33:	rpopThisObj
34:	setThisStack
35:	pushthis 
36:	rtn D


Class = descInx:13 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	rshiftup 1
3:	tstOriginNone 
4:	rstore 1
6:	allocEventQ 0
8:	pushthis 
9:	rpushg 1
11:	rshiftdown 1
13:	pushthis 
14:	rstoreg 2
16:	tstOriginNone 
17:	rstore 1
19:	allocEventQ 0
21:	mvStack
allocE: 
doE: 
22:	doEventQ 
23:	mvStack
24:	pushthis 
25:	invoke 14 0 0
31:	rpop 
32:	setThisStack
33:	pushthis 
34:	rtn D


Class loop descInx:14 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	rpushg 1
17:	invoke 15 0 0
23:	pushg 2
25:	storeg 4
27:	pushthis 
28:	pushg 4
30:	pushthis 
31:	rpushg 1
33:	rpushg 2
35:	invoke 15 0 0
41:	pushg 2
43:	ne 
44:	jmpFalse 55
47:	pushthis 
48:	invoke 18 0 0
54:	rpop 
55:	pushthis 
56:	rpushg 1
58:	invoke 23 0 0
64:	pushg 1
66:	storeg 3
68:	pushthis 
69:	invoke 30 0 0
75:	rpop 
76:	setThisStack
77:	pushthis 
78:	rtn D


Class length descInx:15 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	pushc 0
17:	xpushg 1 0 1
21:	storeg 2
23:	setThisStack
24:	pushthis 
25:	rtn D


Class $18 descInx:18 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	break 1 2 14 0
18:	setThisStack
19:	pushthis 
20:	rtn D


Class if:then descInx:20 objSize:1 originOff: 0 visibility: 1
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class BETAworld descInx:21 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	innerP 2
14:	rpopThisObj
15:	setThisStack
16:	pushthis 
17:	rtn D


Class thenPart#22 descInx:22 objSize:3 originOff: 0 visibility: 1
storeOrgAndArgsE:
1:	invoke 21 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class True descInx:23 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
3:	mvStack
allocE: 
4:	rtnAlloc 1
doE: 
6:	doEventQ 
7:	mvStack
8:	pushthis 
9:	pushc 1
11:	storeg 1
13:	setThisStack
14:	pushthis 
15:	rtn D


Class repeat$24 descInx:24 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	pushthis 
17:	rpushg 1
19:	rpushg 4
21:	rpushg 1
23:	rpushg 1
25:	pushthis 
26:	rpushg 1
28:	pushg 3
30:	xpushg 1 0 1
34:	storeg 2
36:	pushthis 
37:	rpushg 1
39:	rpushg 4
41:	pushthis 
42:	rpushg 1
44:	rpushg 4
46:	rpushg 1
48:	rpushg 2
50:	pushthis 
51:	rpushg 1
53:	pushg 3
55:	xpushg 1 0 1
59:	storeg 3
61:	pushthis 
62:	rpushg 1
64:	rpushg 4
66:	pushg 2
68:	pushthis 
69:	rpushg 1
71:	rpushg 4
73:	pushg 3
75:	ne 
76:	jmpFalse 87
79:	pushthis 
80:	invoke 26 0 0
86:	rpop 
87:	setThisStack
88:	pushthis 
89:	rtn D


Class $26 descInx:26 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 4
18:	rpushg 1
20:	invoke 27 0 0
26:	pushg 1
28:	storeg 3
30:	break 3 2 14 0
37:	setThisStack
38:	pushthis 
39:	rtn D


Class False descInx:27 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
3:	mvStack
allocE: 
4:	rtnAlloc 1
doE: 
6:	doEventQ 
7:	mvStack
8:	pushthis 
9:	pushc 0
11:	storeg 1
13:	setThisStack
14:	pushthis 
15:	rtn D


Class for:to:repeat descInx:28 objSize:3 originOff: 0 visibility: 1
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 2
4:	pushthis 
5:	storeg 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	pushthis 
16:	pushg 1
18:	storeg 3
20:	pushthis 
21:	invoke 43 0 0
27:	rpop 
28:	setThisStack
29:	pushthis 
30:	rtn D


Class repeat#29 descInx:29 objSize:3 originOff: 0 visibility: 1
storeOrgAndArgsE:
1:	invoke 21 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class for:to:repeat$30 descInx:30 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	rpushg 1
13:	invoke 15 0 0
19:	pushg 2
21:	pushthis 
22:	storeg 2
24:	pushthis 
25:	storeg 1
27:	allocEventQ 0
allocE: 
29:	rtnAlloc 1
31:	toSuper 28
doE: 
34:	mvStack
35:	rtnInner


Class this descInx:31 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	setThisStack
15:	pushthis 
16:	rtn D


Class X_asString descInx:32 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushText 1
9:	pushthis 
10:	rstoreg 2
12:	rtnAlloc 1
doE: 
14:	doEventQ 
15:	mvStack
16:	pushthis 
17:	innerP 2
19:	rpopThisObj
20:	setThisStack
21:	pushthis 
22:	rtn D


Class LIB descInx:33 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 34 3 1
14:	rpop 
15:	pushthis 
16:	invoke 38 4 1
22:	rpop 
23:	pushthis 
24:	invoke 41 5 1
30:	rpop 
31:	rtnAlloc 1
doE: 
33:	doEventQ 
34:	mvStack
35:	setThisStack
36:	pushthis 
37:	rtn D


Class BasicIO descInx:34 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 35 2 1
14:	rpop 
15:	pushthis 
16:	invoke 36 3 1
22:	rpop 
23:	rtnAlloc 1
doE: 
25:	doEventQ 
26:	mvStack
27:	setThisStack
28:	pushthis 
29:	rtn D


Class keyboard descInx:35 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class screen descInx:36 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	rpushg 1
10:	invoke 37 2 1
16:	rpop 
17:	rtnAlloc 1
doE: 
19:	doEventQ 
20:	mvStack
21:	setThisStack
22:	pushthis 
23:	rtn D


Class Lock descInx:37 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class Collections descInx:38 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	invoke 39 2 1
13:	rpop 
14:	pushthis 
15:	invoke 40 3 1
21:	rpop 
22:	rtnAlloc 1
doE: 
24:	doEventQ 
25:	mvStack
26:	setThisStack
27:	pushthis 
28:	rtn D


Class OrderedList descInx:39 objSize:0 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 1
3:	mvStack
allocE: 
4:	rtnAlloc 1
doE: 
6:	doEventQ 
7:	mvStack
8:	setThisStack
9:	pushthis 
10:	rtn D


Class SetLib descInx:40 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class StringLib descInx:41 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	saveStringOrigin
7:	mvStack
allocE: 
8:	rtnAlloc 1
doE: 
10:	doEventQ 
11:	mvStack
12:	setThisStack
13:	pushthis 
14:	rtn D


Class Boolean descInx:42 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	mvStack
allocE: 
2:	rtnAlloc 1
doE: 
4:	mvStack
5:	setThisStack
6:	pushthis 
7:	rtn D


Class _doIt descInx:43 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushg 3
16:	pushthis 
17:	rpushg 1
19:	pushg 2
21:	le
22:	jmpFalse 36
25:	pushthis 
26:	invoke 45 0 0
32:	rpop 
33:	jmp 44
36:	pushthis 
37:	invoke 48 0 0
43:	rpop 
44:	setThisStack
45:	pushthis 
46:	rtn D


Class <= descInx:44 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	jmpFalse 13
4:	pushthis 
5:	vassign 4 2 0
10:	jmp 20
13:	invokeVal 31 3 0
19:	rpop 
20:	tstOriginNone 
21:	rstore 1
23:	allocEventQ 0
25:	mvStack
allocE: 
26:	rtnAlloc 1
doE: 
28:	doEventQ 
29:	mvStack
30:	setThisStack
31:	pushthis 
32:	rtn D


Class $45 descInx:45 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	invokev 2 0 0
20:	rpop 
21:	pushthis 
22:	rpushg 1
24:	rpushg 1
26:	pushthis 
27:	rpushg 1
29:	rpushg 1
31:	pushg 3
33:	pushc 1
35:	+
36:	storeg 3
38:	break 1 1 43 0
45:	setThisStack
46:	pushthis 
47:	rtn D


Class $48 descInx:48 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushthis 
17:	rpushg 1
19:	rpushg 1
21:	pushg 3
23:	storeg 3
25:	setThisStack
26:	pushthis 
27:	rtn D


Class <= descInx:49 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	rshiftup 1
3:	tstOriginNone 
4:	rstore 1
6:	allocEventQ 0
8:	pushthis 
9:	rpushg 1
11:	rshiftdown 1
13:	pushthis 
14:	rstoreg 2
16:	tstOriginNone 
17:	rstore 1
19:	allocEventQ 0
21:	mvStack
allocE: 
22:	pushthis 
23:	invoke 50 4 1
29:	rpop 
doE: 
30:	doEventQ 
31:	mvStack
32:	setThisStack
33:	pushthis 
34:	rtn D


Class loop descInx:50 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	rpushg 1
17:	invoke 15 0 0
23:	pushg 2
25:	storeg 3
27:	pushthis 
28:	pushthis 
29:	rpushg 1
31:	rpushg 2
33:	invoke 15 0 0
39:	pushg 2
41:	storeg 4
43:	pushthis 
44:	pushg 3
46:	pushthis 
47:	pushg 4
49:	lt
50:	jmpFalse 64
53:	pushthis 
54:	invoke 52 0 0
60:	rpop 
61:	jmp 72
64:	pushthis 
65:	invoke 53 0 0
71:	rpop 
72:	pushthis 
73:	invoke 54 0 0
79:	rpop 
80:	setThisStack
81:	pushthis 
82:	rtn D


Class $52 descInx:52 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushthis 
15:	rpushg 1
17:	pushg 3
19:	storeg 2
21:	setThisStack
22:	pushthis 
23:	rtn D


Class $53 descInx:53 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushthis 
15:	rpushg 1
17:	pushg 4
19:	storeg 2
21:	setThisStack
22:	pushthis 
23:	rtn D


Class matchEq descInx:54 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	invoke 55 0 0
18:	rpop 
19:	pushthis 
20:	invoke 58 0 0
26:	rpop 
27:	pushthis 
28:	invoke 61 0 0
34:	rpop 
35:	setThisStack
36:	pushthis 
37:	rtn D


Class isEmpty descInx:55 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushg 3
18:	pushc 0
20:	eq 
21:	jmpFalse 32
24:	pushthis 
25:	invoke 56 0 0
31:	rpop 
32:	pushthis 
33:	rpushg 1
35:	rpushg 1
37:	pushg 4
39:	pushc 0
41:	eq 
42:	jmpFalse 53
45:	pushthis 
46:	invoke 57 0 0
52:	rpop 
53:	setThisStack
54:	pushthis 
55:	rtn D


Class $56 descInx:56 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 1
20:	pushthis 
21:	rpushg 1
23:	rpushg 1
25:	rpushg 1
27:	pushg 3
29:	pushthis 
30:	rpushg 1
32:	rpushg 1
34:	rpushg 1
36:	pushg 4
38:	le
39:	storeg 3
41:	break 2 2 54 0
48:	setThisStack
49:	pushthis 
50:	rtn D


Class $57 descInx:57 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 1
20:	invoke 27 0 0
26:	pushg 1
28:	storeg 3
30:	break 2 2 54 0
37:	setThisStack
38:	pushthis 
39:	rtn D


Class loop descInx:58 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushthis 
15:	rpushg 1
17:	pushg 2
19:	pushc 1
21:	+
22:	storeg 2
24:	pushthis 
25:	rpushg 1
27:	pushthis 
28:	rpushg 1
30:	rpushg 1
32:	rpushg 1
34:	rpushg 1
36:	pushthis 
37:	rpushg 1
39:	pushg 2
41:	xpushg 1 0 1
45:	storeg 3
47:	pushthis 
48:	rpushg 1
50:	pushthis 
51:	rpushg 1
53:	rpushg 1
55:	rpushg 1
57:	rpushg 2
59:	pushthis 
60:	rpushg 1
62:	pushg 2
64:	xpushg 1 0 1
68:	storeg 4
70:	pushthis 
71:	rpushg 1
73:	pushg 3
75:	pushthis 
76:	rpushg 1
78:	pushg 4
80:	eq 
81:	jmpFalse 92
84:	pushthis 
85:	invoke 59 0 0
91:	rpop 
92:	setThisStack
93:	pushthis 
94:	rtn D


Class $59 descInx:59 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushg 2
18:	pushthis 
19:	rpushg 1
21:	rpushg 1
23:	rpushg 1
25:	pushg 2
27:	lt
28:	jmpFalse 39
31:	pushthis 
32:	invoke 60 0 0
38:	rpop 
39:	setThisStack
40:	pushthis 
41:	rtn D


Class $60 descInx:60 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	break 2 1 58 0
18:	setThisStack
19:	pushthis 
20:	rtn D


Class doit descInx:61 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushg 3
16:	pushthis 
17:	rpushg 1
19:	pushg 4
21:	eq 
22:	jmpFalse 36
25:	pushthis 
26:	invoke 62 0 0
32:	rpop 
33:	jmp 44
36:	pushthis 
37:	invoke 63 0 0
43:	rpop 
44:	setThisStack
45:	pushthis 
46:	rtn D


Class $62 descInx:62 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 1
20:	pushthis 
21:	rpushg 1
23:	rpushg 1
25:	rpushg 1
27:	pushg 3
29:	pushthis 
30:	rpushg 1
32:	rpushg 1
34:	rpushg 1
36:	pushg 4
38:	le
39:	storeg 3
41:	break 2 2 54 0
48:	setThisStack
49:	pushthis 
50:	rtn D


Class $63 descInx:63 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 1
20:	pushthis 
21:	rpushg 1
23:	rpushg 1
25:	pushg 3
27:	pushthis 
28:	rpushg 1
30:	rpushg 1
32:	pushg 4
34:	lt
35:	storeg 3
37:	break 2 2 54 0
44:	setThisStack
45:	pushthis 
46:	rtn D


Class puttext descInx:65 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	innerP 2
17:	rpopThisObj
18:	setThisStack
19:	pushthis 
20:	rtn D


Class putint descInx:66 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	innerP 2
17:	rpopThisObj
18:	setThisStack
19:	pushthis 
20:	rtn D


Class OOPM descInx:67 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 68 3 1
14:	rpop 
15:	pushthis 
16:	invoke 69 4 1
22:	rpop 
23:	rtnAlloc 1
doE: 
25:	doEventQ 
26:	mvStack
27:	setThisStack
28:	pushthis 
29:	rtn D


Class console descInx:68 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class GrammarLib descInx:69 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 70 2 1
14:	rpop 
15:	rtnAlloc 1
doE: 
17:	doEventQ 
18:	mvStack
19:	setThisStack
20:	pushthis 
21:	rtn D


Class demo descInx:70 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 145 2 1
14:	rpop 
15:	rtnAlloc 1
doE: 
17:	doEventQ 
18:	mvStack
19:	setThisStack
20:	pushthis 
21:	rtn D


Class Grammar descInx:71 objSize:6 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	invoke 85 2 1
13:	rpop 
14:	invoke 88 3 1
20:	rpop 
21:	invoke 95 4 1
27:	rpop 
28:	rtnAlloc 1
doE: 
30:	doEventQ 
31:	mvStack
32:	pushthis 
33:	innerP 3
35:	rpopThisObj
36:	setThisStack
37:	pushthis 
38:	rtn D


Class Symbol descInx:72 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	innerP 4
17:	rpopThisObj
18:	setThisStack
19:	pushthis 
20:	rtn D


Class NonTerminal descInx:73 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	rshiftup 1
3:	tstOriginNone 
4:	rstore 1
6:	pushthis 
7:	rpushg 1
9:	rshiftdown 1
11:	pushthis 
12:	rstoreg 2
14:	tstOriginNone 
15:	rstore 1
17:	allocEventQ 0
allocE: 
19:	rtnAlloc 1
21:	toSuper 72
doE: 
24:	mvStack
25:	pushthis 
26:	rpushg 1
28:	rpushg 2
30:	pushthis 
31:	invoke 75 0 0
37:	rpop 
38:	rtnInner


Class insert descInx:74 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	innerP 2
17:	rpopThisObj
18:	setThisStack
19:	pushthis 
20:	rtn D


Class insert descInx:75 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	rshiftup 1
3:	tstOriginNone 
4:	rstore 1
6:	pushthis 
7:	rpushg 1
9:	rshiftdown 1
11:	pushthis 
12:	rstoreg 2
14:	tstOriginNone 
15:	rstore 1
17:	allocEventQ 0
allocE: 
19:	rtnAlloc 1
21:	toSuper 74
doE: 
24:	mvStack
25:	pushthis 
26:	rpushg 1
28:	pushthis 
29:	rpushg 2
31:	invoke 101 0 0
37:	pushg 3
39:	nott
40:	jmpFalse 51
43:	pushthis 
44:	invoke 77 0 0
50:	rpop 
51:	rtnInner


Class $77 descInx:77 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushthis 
17:	rpushg 1
19:	rpushg 1
21:	pushthis 
22:	rpushg 1
24:	rpushg 2
26:	pushthis 
27:	rpushg 1
29:	rpushg 1
31:	rpushg 1
33:	invoke 78 0 1
39:	rswap 0
41:	rstoreg 1
43:	setThisStack
44:	pushthis 
45:	rtn D


Class link descInx:78 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 3
4:	pushthis 
5:	rstoreg 2
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 1
12:	mvStack
allocE: 
13:	rtnAlloc 1
doE: 
15:	doEventQ 
16:	mvStack
17:	setThisStack
18:	pushthis 
19:	rtn D


Class Collection descInx:80 objSize:0 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
3:	mvStack
allocE: 
4:	rtnAlloc 1
doE: 
6:	doEventQ 
7:	mvStack
8:	pushthis 
9:	innerP 9
11:	rpopThisObj
12:	setThisStack
13:	pushthis 
14:	rtn D


Class Set descInx:83 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
allocE: 
3:	rtnAlloc 1
5:	toSuper 80
doE: 
8:	mvStack
9:	pushthis 
10:	innerP 10
12:	rpopThisObj
13:	rtnInner


Class nonTerminals descInx:85 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
allocE: 
3:	rtnAlloc 1
5:	toSuper 80
doE: 
8:	mvStack
9:	rtnInner


Class Terminal descInx:86 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	rshiftup 1
3:	tstOriginNone 
4:	rstore 1
6:	pushthis 
7:	rpushg 1
9:	rshiftdown 1
11:	pushthis 
12:	rstoreg 2
14:	tstOriginNone 
15:	rstore 1
17:	allocEventQ 0
allocE: 
19:	rtnAlloc 1
21:	toSuper 72
doE: 
24:	mvStack
25:	rtnInner


Class terminals descInx:88 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
allocE: 
3:	rtnAlloc 1
5:	toSuper 80
doE: 
8:	mvStack
9:	rtnInner


Class Rule descInx:89 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	invoke 93 3 1
13:	rpop 
14:	rtnAlloc 1
doE: 
16:	doEventQ 
17:	mvStack
18:	setThisStack
19:	pushthis 
20:	rtn D


Class Alternative descInx:90 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	setThisStack
15:	pushthis 
16:	rtn D


Class OrderedList descInx:92 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
allocE: 
3:	rtnAlloc 1
5:	toSuper 80
doE: 
8:	mvStack
9:	rtnInner


Class alternatives descInx:93 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
allocE: 
3:	rtnAlloc 1
5:	toSuper 80
doE: 
8:	mvStack
9:	rtnInner


Class rules descInx:95 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
allocE: 
3:	rtnAlloc 1
5:	toSuper 80
doE: 
8:	mvStack
9:	rtnInner


Class has descInx:96 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	innerP 2
17:	rpopThisObj
18:	setThisStack
19:	pushthis 
20:	rtn D


Class remove descInx:97 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	innerP 2
17:	rpopThisObj
18:	setThisStack
19:	pushthis 
20:	rtn D


Class isEmpty descInx:98 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	innerP 2
14:	rpopThisObj
15:	setThisStack
16:	pushthis 
17:	rtn D


Class size descInx:99 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	innerP 2
14:	rpopThisObj
15:	setThisStack
16:	pushthis 
17:	rtn D


Class clear descInx:100 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	innerP 2
14:	rpopThisObj
15:	setThisStack
16:	pushthis 
17:	rtn D


Class has descInx:101 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	rshiftup 1
3:	tstOriginNone 
4:	rstore 1
6:	pushthis 
7:	rpushg 1
9:	rshiftdown 1
11:	pushthis 
12:	rstoreg 2
14:	tstOriginNone 
15:	rstore 1
17:	allocEventQ 0
allocE: 
19:	rtnAlloc 1
21:	toSuper 96
doE: 
24:	mvStack
25:	pushthis 
26:	invoke 27 0 0
32:	pushg 1
34:	storeg 3
36:	pushthis 
37:	invoke 103 0 0
43:	rpop 
44:	rtnInner


Class scan descInx:102 objSize:3 originOff: 1 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	rpushg 1
17:	rswap 0
19:	rstoreg 3
21:	pushthis 
22:	invoke 107 0 0
28:	rpop 
29:	setThisStack
30:	pushthis 
31:	rtn D


Class scan$103 descInx:103 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushthis 
5:	rpushg 4
7:	rpushg 1
9:	tstOriginNone 
10:	rstore 1
12:	allocEventQ 1
allocE: 
14:	rtnAlloc 1
16:	toSuper 102
doE: 
19:	mvStack
20:	pushthis 
21:	rpushg 2
23:	pushthis 
24:	rpushg 4
26:	rpushg 2
28:	req 
29:	jmpFalse 43
32:	pushthis 
33:	invoke 105 0 0
39:	rpop 
40:	jmp 51
43:	pushthis 
44:	invoke 106 0 0
50:	rpop 
51:	rtnInner


Class $105 descInx:105 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	invoke 23 0 0
22:	pushg 1
24:	storeg 3
26:	break 2 2 96 1
33:	setThisStack
34:	pushthis 
35:	rtn D


Class $106 descInx:106 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	pushthis 
17:	rpushg 1
19:	rpushg 4
21:	pushg 3
23:	storeg 3
25:	setThisStack
26:	pushthis 
27:	rtn D


Class Loop descInx:107 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 3
16:	pushNone 
17:	57
18:	jmpFalse 32
21:	pushthis 
22:	invoke 110 0 0
28:	rpop 
29:	jmp 40
32:	pushthis 
33:	invoke 111 0 0
39:	rpop 
40:	setThisStack
41:	pushthis 
42:	rtn D


Class $110 descInx:110 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushthis 
17:	rpushg 1
19:	rpushg 1
21:	rpushg 3
23:	rpushg 2
25:	rswap 0
27:	rstoreg 2
29:	pushthis 
30:	rpushg 1
32:	rpushg 1
34:	innerP 2
36:	rpopThisObj
37:	pushthis 
38:	rpushg 1
40:	rpushg 1
42:	pushthis 
43:	rpushg 1
45:	rpushg 1
47:	rpushg 3
49:	rpushg 3
51:	rswap 0
53:	rstoreg 3
55:	break 1 1 107 0
62:	setThisStack
63:	pushthis 
64:	rtn D


Class $111 descInx:111 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushthis 
17:	rpushg 1
19:	rpushg 1
21:	rpushg 3
23:	rswap 0
25:	rstoreg 3
27:	setThisStack
28:	pushthis 
29:	rtn D


Class isEmpty descInx:112 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 98
doE: 
17:	mvStack
18:	pushthis 
19:	pushthis 
20:	rpushg 1
22:	rpushg 1
24:	pushNone 
25:	req 
26:	storeg 2
28:	rtnInner


Class remove descInx:113 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	rshiftup 1
3:	tstOriginNone 
4:	rstore 1
6:	pushthis 
7:	rpushg 1
9:	rshiftdown 1
11:	pushthis 
12:	rstoreg 2
14:	tstOriginNone 
15:	rstore 1
17:	allocEventQ 0
allocE: 
19:	rtnAlloc 1
21:	toSuper 97
doE: 
24:	mvStack
25:	pushText 5
27:	invoke 114 0 0
33:	rpop 
34:	rtnInner


Class print descInx:114 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	invoke 117 0 0
18:	rpop 
19:	setThisStack
20:	pushthis 
21:	rtn D


Class repeat$115 descInx:115 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	rpushg 1
18:	pushthis 
19:	rpushg 1
21:	pushg 3
23:	xpushg 1 0 1
27:	%prim put 2
29:	setThisStack
30:	pushthis 
31:	rtn D


Class put descInx:116 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class for:to:repeat$117 descInx:117 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	invoke 15 0 0
17:	pushg 2
19:	pushthis 
20:	storeg 2
22:	pushthis 
23:	storeg 1
25:	allocEventQ 0
allocE: 
27:	rtnAlloc 1
29:	toSuper 28
doE: 
32:	mvStack
33:	rtnInner


Class size descInx:118 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 99
doE: 
17:	mvStack
18:	pushthis 
19:	invoke 119 0 0
25:	rpop 
26:	rtnInner


Class scan$119 descInx:119 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushthis 
5:	rpushg 4
7:	rpushg 1
9:	tstOriginNone 
10:	rstore 1
12:	allocEventQ 1
allocE: 
14:	rtnAlloc 1
16:	toSuper 102
doE: 
19:	mvStack
20:	pushthis 
21:	rpushg 4
23:	pushthis 
24:	rpushg 4
26:	pushg 2
28:	pushc 1
30:	+
31:	storeg 2
33:	rtnInner


Class clear descInx:120 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 100
doE: 
17:	mvStack
18:	pushthis 
19:	rpushg 1
21:	pushNone 
22:	rswap 0
24:	rstoreg 1
26:	rtnInner


Class print descInx:121 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	innerP 2
14:	rpopThisObj
15:	setThisStack
16:	pushthis 
17:	rtn D


Class isTerminal descInx:122 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	innerP 2
14:	rpopThisObj
15:	setThisStack
16:	pushthis 
17:	rtn D


Class print descInx:123 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 121
doE: 
17:	mvStack
18:	pushc 60
20:	%prim put 2
22:	pushthis 
23:	rpushg 1
25:	rpushg 2
27:	invoke 114 0 0
33:	rpop 
34:	pushc 62
36:	%prim put 2
38:	rtnInner


Class isTerminal descInx:124 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 122
doE: 
17:	mvStack
18:	pushthis 
19:	invoke 23 0 0
25:	pushg 1
27:	storeg 2
29:	rtnInner


Class print descInx:125 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 121
doE: 
17:	mvStack
18:	pushc 34
20:	%prim put 2
22:	pushthis 
23:	rpushg 1
25:	rpushg 2
27:	invoke 114 0 0
33:	rpop 
34:	pushc 34
36:	%prim put 2
38:	rtnInner


Class has descInx:126 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	rshiftup 1
3:	tstOriginNone 
4:	rstore 1
6:	pushthis 
7:	rpushg 1
9:	rshiftdown 1
11:	pushthis 
12:	rstoreg 2
14:	tstOriginNone 
15:	rstore 1
17:	allocEventQ 0
allocE: 
19:	rtnAlloc 1
21:	toSuper 96
doE: 
24:	mvStack
25:	pushthis 
26:	invoke 27 0 0
32:	pushg 1
34:	storeg 3
36:	pushthis 
37:	invoke 129 0 0
43:	rpop 
44:	rtnInner


Class scan descInx:127 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	rpushg 1
17:	rswap 0
19:	rstoreg 3
21:	pushthis 
22:	invoke 131 0 0
28:	rpop 
29:	setThisStack
30:	pushthis 
31:	rtn D


Class link:next descInx:128 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 3
4:	pushthis 
5:	rstoreg 2
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 1
12:	mvStack
allocE: 
13:	rtnAlloc 1
doE: 
15:	doEventQ 
16:	mvStack
17:	setThisStack
18:	pushthis 
19:	rtn D


Class scan$129 descInx:129 objSize:4 originOff: 4 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushthis 
5:	rpushg 4
7:	rpushg 1
9:	tstOriginNone 
10:	rstore 1
12:	allocEventQ 0
allocE: 
14:	rtnAlloc 1
16:	toSuper 127
doE: 
19:	mvStack
20:	pushthis 
21:	rpushg 2
23:	pushthis 
24:	rpushg 4
26:	rpushg 2
28:	req 
29:	jmpFalse 40
32:	pushthis 
33:	invoke 130 0 0
39:	rpop 
40:	rtnInner


Class $130 descInx:130 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	invoke 23 0 0
22:	pushg 1
24:	storeg 3
26:	break 2 2 96 1
33:	setThisStack
34:	pushthis 
35:	rtn D


Class loop descInx:131 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 3
16:	pushNone 
17:	57
18:	jmpFalse 29
21:	pushthis 
22:	invoke 132 0 0
28:	rpop 
29:	setThisStack
30:	pushthis 
31:	rtn D


Class $132 descInx:132 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushthis 
17:	rpushg 1
19:	rpushg 1
21:	rpushg 3
23:	rpushg 2
25:	rswap 0
27:	rstoreg 2
29:	pushthis 
30:	rpushg 1
32:	rpushg 1
34:	innerP 2
36:	rpopThisObj
37:	pushthis 
38:	rpushg 1
40:	rpushg 1
42:	pushthis 
43:	rpushg 1
45:	rpushg 1
47:	rpushg 3
49:	rpushg 3
51:	rswap 0
53:	rstoreg 3
55:	break 1 1 131 0
62:	setThisStack
63:	pushthis 
64:	rtn D


Class isEmpty descInx:133 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 98
doE: 
17:	mvStack
18:	pushthis 
19:	pushthis 
20:	rpushg 1
22:	rpushg 1
24:	pushNone 
25:	req 
26:	storeg 2
28:	rtnInner


Class size descInx:134 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 99
doE: 
17:	mvStack
18:	pushthis 
19:	invoke 135 0 0
25:	rpop 
26:	rtnInner


Class scan$135 descInx:135 objSize:4 originOff: 4 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushthis 
5:	rpushg 4
7:	rpushg 1
9:	tstOriginNone 
10:	rstore 1
12:	allocEventQ 0
allocE: 
14:	rtnAlloc 1
16:	toSuper 127
doE: 
19:	mvStack
20:	pushthis 
21:	rpushg 4
23:	pushthis 
24:	rpushg 4
26:	pushg 2
28:	pushc 1
30:	+
31:	storeg 2
33:	rtnInner


Class clear descInx:136 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 100
doE: 
17:	mvStack
18:	pushthis 
19:	rpushg 1
21:	pushNone 
22:	rswap 0
24:	rstoreg 1
26:	pushthis 
27:	rpushg 1
29:	pushNone 
30:	rswap 0
32:	rstoreg 2
34:	rtnInner


Class insert descInx:137 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	rshiftup 1
3:	tstOriginNone 
4:	rstore 1
6:	pushthis 
7:	rpushg 1
9:	rshiftdown 1
11:	pushthis 
12:	rstoreg 2
14:	tstOriginNone 
15:	rstore 1
17:	allocEventQ 0
allocE: 
19:	rtnAlloc 1
21:	toSuper 74
doE: 
24:	mvStack
25:	pushthis 
26:	rpushg 1
28:	rpushg 1
30:	pushNone 
31:	req 
32:	jmpFalse 46
35:	pushthis 
36:	invoke 138 0 0
42:	rpop 
43:	jmp 54
46:	pushthis 
47:	invoke 139 0 0
53:	rpop 
54:	rtnInner


Class $138 descInx:138 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushthis 
17:	rpushg 1
19:	rpushg 1
21:	pushthis 
22:	rpushg 1
24:	rpushg 2
26:	pushNone 
27:	invoke 128 0 1
33:	rswap 0
35:	rstoreg 1
37:	pushthis 
38:	rpushg 1
40:	rpushg 1
42:	pushthis 
43:	rpushg 1
45:	rpushg 1
47:	rpushg 1
49:	rswap 0
51:	rstoreg 2
53:	setThisStack
54:	pushthis 
55:	rtn D


Class $139 descInx:139 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	rpushg 1
17:	pushthis 
18:	rpushg 1
20:	rpushg 2
22:	pushNone 
23:	invoke 128 0 1
29:	rswap 0
31:	rstoreg 2
33:	pushthis 
34:	rpushg 1
36:	rpushg 1
38:	rpushg 2
40:	pushthis 
41:	rpushg 2
43:	rswap 0
45:	rstoreg 3
47:	pushthis 
48:	rpushg 1
50:	rpushg 1
52:	pushthis 
53:	rpushg 2
55:	rswap 0
57:	rstoreg 2
59:	setThisStack
60:	pushthis 
61:	rtn D


Class SymbolList descInx:141 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
allocE: 
3:	rtnAlloc 1
5:	toSuper 80
doE: 
8:	mvStack
9:	rtnInner


Class Text descInx:142 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class parse descInx:143 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	setThisStack
15:	pushthis 
16:	rtn D


Class AbstractSyntaxTree descInx:144 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class gTst descInx:145 objSize:10 originOff: 7 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 7
4:	pushthis 
5:	rpushg 7
7:	rpushg 1
9:	tstOriginNone 
10:	rstore 1
12:	allocEventQ 0
allocE: 
14:	invoke 85 2 1
20:	rpop 
21:	invoke 88 3 1
27:	rpop 
28:	invoke 95 4 1
34:	rpop 
35:	pushthis 
36:	pushText 5
38:	invoke 73 8 1
44:	rpop 
45:	pushthis 
46:	pushText 9
48:	invoke 73 9 1
54:	rpop 
55:	pushthis 
56:	pushText 14
58:	invoke 86 10 0
64:	rpop 
65:	rtnAlloc 1
67:	toSuper 71
doE: 
70:	mvStack
71:	pushthis 
72:	invoke 146 0 0
78:	rpop 
79:	rtnInner


Class KUK descInx:146 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	invoke 141 0 1
18:	rswap 0
20:	rstoreg 2
22:	pushthis 
23:	invoke 141 0 1

29:	pushthis 
30:	rpushg 1
32:	rpushg 8

34:	pushthis 
35:	rpushg 1
37:	rpushg 10

39:	pushthis 
40:	rpushg 1
42:	rpushg 9
44:	pushc 3

46:	mkRindexed 153
49:	invoke 147 0 0
55:	rpushg 3
57:	rswap 0
59:	rstoreg 2
61:	setThisStack
62:	pushthis 
63:	rtn D


Class insertList descInx:147 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushc 37
16:	%prim put 2
18:	pushthis 
19:	invoke 151 0 0
25:	rpop 
26:	pushthis 
27:	pushthis 
28:	rpushg 1
30:	rswap 0
32:	rstoreg 3
34:	setThisStack
35:	pushthis 
36:	rtn D


Class length descInx:148 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	pushc 0
17:	xpushg 1 0 1
21:	storeg 2
23:	setThisStack
24:	pushthis 
25:	rtn D


Class repeat$150 descInx:150 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	rpushg 1
18:	pushthis 
19:	rpushg 1
21:	rpushg 4
23:	rpushg 2
25:	pushthis 
26:	rpushg 1
28:	pushg 3
30:	xrpushg 1
32:	invokev 3 1 0
36:	rpop 
37:	setThisStack
38:	pushthis 
39:	rtn D


Class for:to:repeat$151 descInx:151 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 2
11:	invoke 148 0 0
17:	pushg 2
19:	pushthis 
20:	storeg 2
22:	pushthis 
23:	storeg 1
25:	allocEventQ 0
allocE: 
27:	rtnAlloc 1
29:	toSuper 28
doE: 
32:	mvStack
33:	rtnInner


Class OrderedList$152 descInx:152 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
allocE: 
3:	rtnAlloc 1
5:	toSuper 80
doE: 
8:	mvStack
9:	rtnInner


Class IndexedRef descInx:153 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class + descInx:155 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	pushText 1
12:	pushthis 
13:	rstoreg 3
15:	rtnAlloc 1
doE: 
17:	doEventQ 
18:	mvStack
19:	pushthis 
20:	pushthis 
21:	rpushg 1
23:	invoke 15 0 0
29:	pushg 2
31:	storeg 4
33:	pushthis 
34:	invoke 156 0 0
40:	rpop 
41:	setThisStack
42:	pushthis 
43:	rtn D


Class doplus descInx:156 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushthis 
8:	rpushg 1
10:	pushg 4
12:	pushthis 
13:	rpushg 1
15:	rpushg 2
17:	invoke 15 0 0
23:	pushg 2
25:	+
26:	pushthis 
27:	pushc 1
29:	allocIndexed 157 1 0 
34:	pushthis 
35:	rstoreg 4
37:	rtnAlloc 1
doE: 
39:	doEventQ 
40:	mvStack
41:	pushthis 
42:	invoke 161 0 0
48:	rpop 
49:	pushthis 
50:	invoke 163 0 0
56:	rpop 
57:	pushthis 
58:	rpushg 1
60:	pushthis 
61:	rpushg 4
63:	%prim asString 118
65:	rswap 0
67:	rstoreg 3
69:	setThisStack
70:	pushthis 
71:	rtn D


Class Indexed descInx:157 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class repeat$159 descInx:159 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	pushthis 
17:	rpushg 1
19:	rpushg 4
21:	rpushg 1
23:	rpushg 1
25:	pushthis 
26:	rpushg 1
28:	pushg 3
30:	xpushg 1 0 1
34:	storeg 2
36:	pushthis 
37:	rpushg 1
39:	rpushg 4
41:	rpushg 4
43:	pushthis 
44:	rpushg 1
46:	rpushg 4
48:	pushg 2
50:	pushthis 
51:	rpushg 1
53:	pushg 3
55:	xstoreg 1 0 1 
59:	setThisStack
60:	pushthis 
61:	rtn D


Class for:to:repeat$161 descInx:161 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	pushg 4
13:	pushthis 
14:	storeg 2
16:	pushthis 
17:	storeg 1
19:	allocEventQ 0
allocE: 
21:	rtnAlloc 1
23:	toSuper 28
doE: 
26:	mvStack
27:	rtnInner


Class repeat$162 descInx:162 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	pushthis 
17:	rpushg 1
19:	rpushg 4
21:	rpushg 1
23:	rpushg 2
25:	pushthis 
26:	rpushg 1
28:	pushg 3
30:	xpushg 1 0 1
34:	storeg 2
36:	pushthis 
37:	rpushg 1
39:	rpushg 4
41:	pushthis 
42:	rpushg 1
44:	rpushg 4
46:	rpushg 1
48:	pushg 4
50:	pushthis 
51:	rpushg 1
53:	pushg 3
55:	+
56:	storeg 3
58:	pushthis 
59:	rpushg 1
61:	rpushg 4
63:	rpushg 4
65:	pushthis 
66:	rpushg 1
68:	rpushg 4
70:	pushg 2
72:	pushthis 
73:	rpushg 1
75:	rpushg 4
77:	pushg 3
79:	xstoreg 1 0 1 
83:	setThisStack
84:	pushthis 
85:	rtn D


Class for:to:repeat$163 descInx:163 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	rpushg 2
13:	invoke 15 0 0
19:	pushg 2
21:	pushthis 
22:	storeg 2
24:	pushthis 
25:	storeg 1
27:	allocEventQ 0
allocE: 
29:	rtnAlloc 1
31:	toSuper 28
doE: 
34:	mvStack
35:	rtnInner


Class asString descInx:164 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushText 1
9:	pushthis 
10:	rstoreg 2
12:	rtnAlloc 1
doE: 
14:	doEventQ 
15:	mvStack
16:	setThisStack
17:	pushthis 
18:	rtn D


Class valProx descInx:165 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	0


Class VM descInx:166 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	invoke 1 0 1
8:	stop 
9:	rtn D


Class EventProcessor descInx:167 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	stop 


Class ThreadStub descInx:168 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
doE: 
1:	call D
3:	stop 

