LottoExII: obj MonitorSystemLib.MonitorSystem
   %visible LIB.Collections.SetLib, RandomNumberGeneratorLib

   -- Extension of MonitorProcess with Monitor attributes
   -- If this works, it should be included in MonitorProcess
   class ExtendedMonitorProcess: MonitorProcess
      mutex: obj LIB.BasicSystemLib.SemaphoreLib.Semaphore(1)
      processRunning: var Boolean -- true if this(EMP) is running
      isClosed: var boolean -- this(XMP) has terminated: no more entry calls
      entry:
         mutex.wait
         wait
            cond := processRunning.not
         if (isClosed) :then
            console.display
                "Entry not possible\n".print
                leave(entry)        
         inner(entry)
         mutex.signal

      wait: 
         cond: var boolean
         loop: do 
            inner(wait)
            if (cond = false) :then 
               mutex.signal
               -- P_status.ACTIVE -> thisCore.main.active.status;
               -- thisCore.main.active.suspend;
               mutex.wait
               restart(loop)
      accept(t: var integer):
         -- currently a bit special
         -- it allows for entry-class for a period of t
         -- this should perhaps be reflected in the name
         -- We may also imagine a version of accept that allows for one
         -- entry-call     
         processRunning := false -- current entry can complete execution
         wait
            sleep(t)     
            cond := true
         mutex.wait   -- possibly await running entry method
         processRunning := true
         mutex.signal
      processRunning := true
      inner(ExtendedMonitorProcess)
      isClosed := true
      processRunning := false

   -- The Lotto example with integration of controller as an
   -- ExtendedMonitorProcess
   noOfPlayers: val 5
   betSize: val 3
   class Hand(RG: ref LinearRandomGenerator):
      %globals
      numbers: obj Array(betSize,#integer)
      print:
         for (1):to(betSize):repeat
             putint(numbers.get[inx])
             put(' ')
      for (1):to(betSize):repeat
           V: var integer
           V := RG.random(1,34)
           numbers.put(V):at[inx] -- problem if no V
   class Bet(thePlayer: ref Player, theHand: ref Hand):
      %globals
      %immutable
      equal(aBet: ref Bet) -> B: var boolean:
         V: var integer
         B := true
         for (1):to(betSize):repeat
             V := theHand.numbers.get[inx]
             L: do
                for (1):to(betSize):repeat
                    if (V = aBet.theHand.numbers.get[inx]) :then
                       leave(L)
                B := false
                leave(equal)     
      print:
         thePlayer.print
         " bet: ".print
         theHand.print     
         newline
   class Player(inx: var integer): MonitorProcess
      RG: obj LinearRandomGenerator(inx,5,9,34,200)    
      H: ref Hand
      play: do
         cycle
            H := Hand(RG)
            Lotto.submit(Bet(this(Player),H))
            if (Lotto.stop) :then
               leave(play)
      print:
          id.print    
   Lotto: obj ExtendedMonitorProcess("Lotto")
      seedCount: var integer      
      bets: obj Set(#Bet)
      submit(B: ref Bet): entry
         console.display
            "Submit ".print
            B.print     
         bets.insert(B)
      clearBets: 
         bets.clear
      findWinningBets: 
         WB: ref LinearRandomGenerator
         WH: ref Hand
         winningBet: ref Bet
         seedCount := seedCount + 1      
         WB :=  LinearRandomGenerator(seedCount,5,9,17,betSize)    
         WH := Hand(WB)          
         winningBet := Bet(Player("Winner",0),WH)
         console.display
              "\nfindWinningBets: ".print
              winningBet.print
              newline          
         bets.scan
             if (current.equal(winningBet)) :then
                "Winner: ".print
                current.print        
         newline          
      stop -> B: var Boolean: entry
         B := doStop
      setStop: 
         doStop := true
      doStop: var boolean     
      i: var integer
      -- active part of ExtendedMonitorProcess
      L: do
         i := i + 1
         accept(1500)
         console.display
            "\nRound: ".print
            putint(i)
            newline
         findWinningBets
         clearBets
         if (i < 5) :then
            restart(L)
         setStop        
   Lotto.start
   generatePlayers: do
       for (1):to(noOfPlayers):repeat
           P: Ref Player
           P := Player("Player" + I2S(inx),inx)
           P.start       

   
   