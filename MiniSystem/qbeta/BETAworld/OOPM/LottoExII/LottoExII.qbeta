LottoExII: obj MonitorSystemLib.MonitorSystem
   %visible LIB.BasicSystemLib, LIB.Collections.SetLib, RandomNumberGeneratorLib

   -- Extension of MonitorProcess with Monitor attributes
   -- If this works, it should be included in MonitorProcess
   class ExtendedMonitorProcess: MonitorProcess
      mutex: obj SemaphoreLib.Semaphore(0)  -- initially closed
      isClosed: var boolean -- this(XMP) has terminated: no more entry calls
      entry:
         mutex.wait
         if (isClosed) :then
            console.display
                "Entry not possible\n".print
                leave(entry)        
         inner(entry)
         mutex.signal

      wait: 
         cond: var boolean
         loop: do 
            inner(wait)
            if (cond = false) :then 
               mutex.signal
               -- sleep?	       
               mutex.wait
               restart(loop)
      waitAndAccept(t: var integer):
         -- No entry-method is running, but some may be at mutex.wait
         mutex.signal -- signal OK here
         -- A Procces may enter and pass wait(not processRunning)
         sleep(t)
         -- Possible Process is executing an entry method
         mutex.wait   -- wait for possible running entry method
         -- in competion with Players

      -- initial: mutex is locked 
      -- mutex is locked
      -- no entry-method can enter
      inner(ExtendedMonitorProcess)
      isClosed := true

   -- The Lotto example with integration of controller as an
   -- ExtendedMonitorProcess
   noOfPlayers: val 5
   betSize: val 3
   class Hand(RG: ref LinearRandomGenerator):
      %globals
      numbers: obj Array(betSize,#integer)
      print:
         for (1):to(betSize):repeat
             putint(numbers.get[inx])
             put(' ')
      for (1):to(betSize):repeat
           V: var integer
           V := RG.random(1,34)
           numbers.put(V):at[inx] -- problem if no V
   class Bet(thePlayer: ref Player, theHand: ref Hand):
      %globals
      %immutable
      equal(aBet: ref Bet) -> B: var boolean:
         V: var integer
         B := true
         for (1):to(betSize):repeat
             V := theHand.numbers.get[inx]
             L: do
                for (1):to(betSize):repeat
                    if (V = aBet.theHand.numbers.get[inx]) :then
                       leave(L)
                B := false
                leave(equal)     
      print:
         thePlayer.print
         " bet: ".print
         theHand.print     
         newline
   class Player(inx: var integer): MonitorProcess
      RG: obj LinearRandomGenerator(inx,5,9,34,200)    
      H: ref Hand
      play: do
         cycle
            H := Hand(RG)
            Lotto.submit(Bet(this(Player),H))
            if (Lotto.stop) :then
               leave(play)
      print:
          id.print    
   Lotto: obj ExtendedMonitorProcess("Lotto")
      -- interface for Players
      submit(B: ref Bet): entry
         console.display
            "Submit ".print
            B.print     
         bets.insert(B)         
      stop -> B: var Boolean: entry
         B := doStop
      -- private methods for Lotto	 
      clearBets: 
         bets.clear
      findWinningBets: 
         WB: ref LinearRandomGenerator
         WH: ref Hand
         winningBet: ref Bet
         seedCount := seedCount + 1      
         WB :=  LinearRandomGenerator(seedCount,5,9,17,betSize)    
         WH := Hand(WB)          
         winningBet := Bet(Player("Winner",0),WH)
         console.display
              "\nfindWinningBets: ".print
              winningBet.print
              newline          
         bets.scan
             if (current.equal(winningBet)) :then
                "Winner: ".print
                current.print        
         newline 
      setStop: 
         doStop := true
      bets: obj Set(#Bet)
      seedCount: var integer 
      doStop: var boolean
      
      -- active part of ExtendedMonitorProcess
      L: do
         i: var integer      
         i := i + 1
         waitAndAccept(1500)
         console.display
            "\nRound: ".print
            putint(i)
            newline
         findWinningBets
         clearBets
         if (i < 5) :then
            restart(L)
         setStop        
   Lotto.start
   generatePlayers: do
       for (1):to(noOfPlayers):repeat
           P: Ref Player
           P := Player("Player" + I2S(inx),inx)
           P.start       

   
   