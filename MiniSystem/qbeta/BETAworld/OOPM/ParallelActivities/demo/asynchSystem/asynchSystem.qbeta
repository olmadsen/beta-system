asynchSystem: obj LIB.SimpleConcurrentProcesses.System
   %visible LIB.SimpleConcurrentProcesses

   records: obj IndexedRef(100,#Person)
   search(first: var integer, last: var integer):
      %globals printer, records
      X: ref Person
      console.display
         "Search:\n".print
      X := records.get[1]
      --putint(X.age)
      --newline
      for (first) :to(last):repeat
          if ((18 <= records.get[inx].age)
              && (records.get[inx].age <= 24)) :then
             printer.add(records.get[inx])

   Person(name: ref String, age: var integer):
      %globals
      %immutable   
   Searcher: Process
      go: entry
         console.display
            "go:".print
      console.display
         "Searcher:\n".print
      inner(Searcher)
      console.display
         ("end:"+id+"\n").print
      isStopping := true
   searcherA: obj Searcher("SearcherA")
      console.display
         id.print
         newline
   searcherB: obj Searcher("SearcherB")
      console.display
         id.print
         newline
   searcherC: obj Searcher("SearcherC")
      console.display
         id.print
         newline
   printer: obj Process("Printer")
      add(P: ref Person): entry
         ("Found: " + P.name + "\n").print
      putS(S: ref String): entry
         S.print
      console.display
         id.print
   searcherA.start
   searcherB.start
   searcherC.start   
   "start:".print
   searcherA.go
   printer.start
   wait: obj Process("wait")
         if ((searcherA.STATUS = P_status.TERMINATED) &&
             (searcherB.STATUS = P_status.TERMINATED) &&
             (searcherC.STATUS = P_status.TERMINATED))
         :then
            isStopping := true
            printer.isStopping := true
         :else
            sleep(100000)
            restart(wait)
   wait.start