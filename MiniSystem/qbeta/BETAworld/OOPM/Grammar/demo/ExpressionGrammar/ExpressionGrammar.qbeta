ExpressionGrammar: obj Grammar
   %module expParser
   expSy: obj Nonterminal("Exp")
   termSy: obj Nonterminal("Term")
   primarySy: obj Nonterminal("Primary")
   numberSy: obj Nonterminal("Number")
   digitSy: obj Nonterminal("Digit")
   add: obj Terminal("+")
   mult: obj Terminal("*")
   leftB: obj Terminal("(")
   rightB: obj Terminal(")")
   mkRightside:
      out RS: obj SymbolList
      put('A')
      inner(mkRightSide)
      put('C')
      RS.print
   mkExpRulesx: addRule(expSy)
      S: ref SymbolList
      put('Q')      
      S := mkRightSide 
         put('B')
         RS.insert(ExpSy)
         put('b')
         RS.insert(add)
         RS.insert(termSy)
      alt := Alternative(S)
      alt.print      
   mkExpRules: addRule(expSy)
      S: ref SymbolList
      S := SymbolList
      S.insert(ExpSy)
      S.insert(add)
      S.insert(termSy)
      alt := Alternative(S)
      R.alternatives.insert(alt)
      S := SymbolList
      S.insert(termSy)
      alt := Alternative(S)
      R.alternatives.insert(alt)
   mkTermRules: addRule(termSy)
      S: ref SymbolList
      S := SymbolList
      S.insert(termSy)
      S.insert(mult)
      S.insert(primarySy)
      alt := Alternative(S)
      R.alternatives.insert(alt)
      S := SymbolList
      S.insert(primarySy)
      alt := Alternative(S)	 
      --alt.insert(S) - error not catched by checker!?
      R.alternatives.insert(alt)
   mkPrimaryRules: addRule(Nonterminal("Primary"))
      S: ref SymbolList
      S := SymbolList
      S.insert(numberSy)
      alt := Alternative(S)
      R.alternatives.insert(alt)
      S := SymbolList
      S.insert(leftB)
      S.insert(expSy)
      S.insert(rightB)
      alt := Alternative(S)	 
      R.alternatives.insert(alt)
   mkNumberRules: addRule(numberSy)
      S: ref SymbolList
      S := SymbolList
      S.insert(numberSy)
      S.insert(digitSy)
      alt := Alternative(S)
      R.alternatives.insert(alt)
      S := SymbolList
      S.insert(digitSy)
      alt := Alternative(S)	 
      R.alternatives.insert(alt)
   mkDigitRules: addRule(digitSy)
      mkDigit(sym: ref String):
         S: ref SymbolList
         A: ref Alternative	 
         S := SymbolList
         S.insert(Terminal(sym))
         A := Alternative(S)
         R.alternatives.insert(A)
      mkDigit("0")
      mkDigit("1")
      mkDigit("2")
      mkDigit("3")
      mkDigit("4")
      mkDigit("5")
      mkDigit("6")
      mkDigit("7")
      mkDigit("8")
      mkDigit("9")
   "Expression:\n".print
   start := expSy
   mkExpRulesx
   mkExpRules   
   mkTermRules
   mkPrimaryRules
   mkNumberRules
   mkDigitRules
   print
   expParser.parse
