ExpressionGrammar: obj Grammar
   %domain
   %module expParser
   expSy: obj Nonterminal("Exp")
   termSy: obj Nonterminal("Term")
   primarySy: obj Nonterminal("Primary")
   numberSy: obj Nonterminal("Number")
   digitSy: obj Nonterminal("Digit")
   add: obj Terminal("+")
   mult: obj Terminal("*")
   leftB: obj Terminal("(")
   rightB: obj Terminal(")")
   mkRightside:
      out RS: obj SymbolList
      inner(mkRightSide)
      RS.print
   mkExpRulesx: addRule(expSy)
      S: ref SymbolList
      S := mkRightSide 
         RS.insert(ExpSy)
         RS.insert(add)
         RS.insert(termSy)
      alt := Alternative(S)
      alt.print      
   mkExpRule: addRule(expSy)
      S: ref SymbolList
      S := SymbolList.insertList((ExpSy,add,termSy))
      R.alternatives.insert(Alternative(S))
      S := SymbolList.insertList(termSy)
      alt := Alternative(S)
      R.alternatives.insert(alt)
   mkTermRule: addRule(termSy)
      S: ref SymbolList
      S := SymbolList.insertList((termSy,mult,primarySy))
      alt := Alternative(S)
      R.alternatives.insert(alt)
      S := SymbolList.insertList(primarySy)
      alt := Alternative(S)	 
      --alt.insert(S) - error not catched by checker!?
      R.alternatives.insert(alt)
   mkPrimaryRule: addRule(Nonterminal("Primary"))
      S: ref SymbolList
      S := SymbolList
      S.insert(numberSy)
      alt := Alternative(S)
      R.alternatives.insert(alt)
      S := SymbolList.insertList((leftB,expSy,rightB))
      alt := Alternative(S)	 
      R.alternatives.insert(alt)
   mkNumberRule: addRule(numberSy)
      S: ref SymbolList
      S := SymbolList.insertList((numberSy,digitSy))
      alt := Alternative(S)
      R.alternatives.insert(alt)
      S := SymbolList
      S.insert(digitSy)
      alt := Alternative(S)	 
      R.alternatives.insert(alt)
   mkDigitRule: addRule(digitSy)
      mkDigit(sym: ref String):
         S: ref SymbolList
         A: ref Alternative	 
         S := SymbolList
         S.insert(Terminal(sym))
         A := Alternative(S)
         R.alternatives.insert(A)
      mkDigit("0")
      mkDigit("1")
      mkDigit("2")
      mkDigit("3")
      mkDigit("4")
      mkDigit("5")
      mkDigit("6")
      mkDigit("7")
      mkDigit("8")
      mkDigit("9")
   "Expression:\n".print
   start := expSy
   --mkExpRulesx
   mkExpRule   
   mkTermRule
   mkPrimaryRule
   mkNumberRule
   mkDigitRule
   print
   expParser.parse
