expParser: obj
   %visible expAst
   nextChar:
     -- read the next character from inn and assign it to ch
     -- skip white space like blanks and end-of-lines
     -- return ch = 0, if at the end of inn
     pos := pos + 1
     if (pos <= inn.length) :then
        ch :=  inn.get[pos]
        if (ch = ' ') :then	
           restart(nextChar)	
     :else
        ch := 0
   exp -> N: ref Node:left:right:
      -- parse an expression generated from <Exp>
      N := term
      addOp: do
         if (ch = '+') :then
            rN: ref Top
            nextChar
            rN := term
            N := expNode('+'):left(N):right(rN)	
            restart(addOp)
   term ->  N: ref node:left:right:
      -- parse an expression generated from <Term>
      N := primary
      multOp: do
         if (ch = '*') :then
            rN: ref Top
            nextChar
            rN := primary	 
            N := termNode('*'):left(N):right(rN)
            restart(multOP)
   primary -> N: ref Node:left:right:
     -- parse an expression generated from <Primary>
     if (ch = '(') :then
        nextChar        
        N := exp
        if (ch = ')') :then
           nextChar
        :else
           syntaxError(1)
     :else
        N := number     
   number -> N: ref node:left:right:
      N := digit
      moreDigits: do
         if (ascii.isDigit(ch)) :then
            rN: ref Node:left:right
            rN := digit
            N := NumberNode('N'):left(N):right(rN)	    
            restart(moreDigits)
         :else
            N := NumberNode('N'):left(N):right(top)
   digit -> N: ref Node:left:right:
      -- parse an expression generated from <Digit>
      if (ascii.isDigit(ch)) :then
         N:= digitNode(ch):left(empty):right(empty)
         nextChar
      :else
         syntaxError(2)      
   hasSyntaxErrors: var Boolean
   syntaxError(n: var integer):
      -- report a syntax error
      hasSyntaxErrors := true
      "\nSyntax error: ch = {C(ch)} {I2S(n)}\n".print
      inn.print
      newline
      for (1):to(pos - 1):repeat
         put(' ')
      put('^')
      newline
	 
   parse:
      -- parse the expression assigned to inn below
      -- return an AST in N 
      N: ref Node:left:right
      inn :=  "10 + 11 * (1 + 9)"
      ("\nParse: " + inn + "\n").print
      nextChar
      N := exp      
      if (ch <> ascii.null) :then
          syntaxError(3)
      if (hasSyntaxErrors.not) :then
         "\nResulting AST:\n".print	  
         N.print
         "\n\nEval of exp: {I2S(N.eval)}\n".print
   inn: ref String
   pos: var integer
   ch: var integer      