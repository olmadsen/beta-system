Grammar: obj
   %visible StringLib, Containers.OrderedList
   Grammar:
      noOfRules: var integer; 
      ...
      -- Other attributes for representing a grammar
      parse(input: ref text) :<       
         output: ref AbstractSyntaxTree
         -- Parse the input string according to the grammar
         -- and produce an abstract syntax tree
         --return output 
      Symbol(printName:  obj String): 
         id: var integer
         print:<
             inner(print)
         ... 
         isTerminal:
            out V: var Boolean
            ...
      NonTerminal: Symbol
         ...
         print::
            put('<')
            printName.print
            put('>')
      Terminal: Symbol
         ...
         print::
             put('"')
             printName.print
             put('"')
      Rule:
         leftSide: ref Nonterminal
         alternatives: obj OrderedList(#Alternative)
            print:
               i: var integer 	    
               scan
                  i := i + 1	       
                  if (i > 1) :then
                      " |".print	
                  current.print	    
         print:
            i: var integer	 
            leftSide.print
            " ::=".print
            alternatives.scan
               i := i + 1
               if (i > 1) :then
                  " |".print	       
               current.print
      SymbolList: OrderedList(#Symbol)
         ...
      Alternative(symbols: ref SymbolList):
         print:
            symbols.scan
               _put(' ')	    
               current.print
      rules: obj OrderedList(#Rule)
      addRule(L: ref Nonterminal):alt(alt: ref Alternative): 
         R: ref Rule
         R := Rule
         R.leftSide := L
         R.alternatives.insert(alt)
         rules.insert(R)
      addRule(L: ref Nonterminal): 
         R: ref Rule
         alt: ref Alternative 
         R := Rule
         R.leftSide := L
         alt := Alternative
         inner(addRule)	 
         R.alternatives.insert(alt)
         rules.insert(R)	 
      print:	 
         "Grammar:\n".print
         rules.scan
            "   ".print	 
            current.print
            newline	    
      inner(Grammar)
   Text:
      ...
   AbstractSyntaxTree:
      ...
   ExpressionGrammar: obj Grammar
      mkAlternative(sym: ref Symbol):
         S: ref SymbolList
         out A: ref Alternative	 
         S := SymbolList
         S.insert(sym)
         A := Alternative(S)
      mkAlternatives:
         out R: ref Rule
         R := Rule
         R.leftSide := NonTerminal("Digit")	 
         A: ref Alternative
         A := mkAlternative(Terminal("0"))
         R.alternatives.insert(A)
         A := mkAlternative(Terminal("1"))
         R.alternatives.insert(A)
         A := mkAlternative(Terminal("2"))
         R.alternatives.insert(A)
         A := mkAlternative(Terminal("3"))
         R.alternatives.insert(A)
         A := mkAlternative(Terminal("4"))
         R.alternatives.insert(A)
         A := mkAlternative(Terminal("5"))
         R.alternatives.insert(A)
         A := mkAlternative(Terminal("6"))
         R.alternatives.insert(A)
         A := mkAlternative(Terminal("7"))
         R.alternatives.insert(A)
         A := mkAlternative(Terminal("8"))
         R.alternatives.insert(A)
         A := mkAlternative(Terminal("9"))
         R.alternatives.insert(A)
         rules.insert(R)
      addRules:
         S: ref SymbolList
         S := SymBolList
         S.insert(Nonterminal("Exp"))
         S.insert(Terminal("+"))
         S.insert(Nonterminal("Term"))
         addRule(Nonterminal("Exp")):alt(Alternative(S))
         S := SymbolList
         S.insert(Nonterminal("Term"))
         S.insert(Terminal("*"))
         S.insert(Nonterminal("Primary"))
         addRule(Nonterminal("Term")):alt(Alternative(S))
         S := SymbolList
         S.insert(Nonterminal("Number"))
         addRule(Nonterminal("Primary")):alt(Alternative(S))
         S := SymbolList
         S.insert(Terminal("("))
         S.insert(NonTerminal("Exp"))
         S.insert(Terminal(")"))
         addRule(Nonterminal("Primary")):alt(Alternative(S))
         S := SymbolList
         S.insert(Nonterminal("Number"))
         addRule(Nonterminal("Digit")):alt(Alternative(S))
         S := SymbolList
         S.insert(NonTerminal("Number"))
         S.insert(NonTerminal("Digit"))
         addRule(Nonterminal("Digit")):alt(Alternative(S))
         S := SymbolList
         A: ref Alternative
         S.insert(Terminal("0"))
         A := Alternative(S)
         mkAlternatives
         print
      "Expression:\n".print
      addRules
