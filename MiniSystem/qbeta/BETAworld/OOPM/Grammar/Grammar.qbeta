Grammar: obj
   -- A grammar ia a 4-tuple G = (N,T,P,S) where
   --   N is a set of nonterminal symbols
   --   T is a set of terminal symbols, the intersection of N and T is empty
   --   P is a set of productions
   --   S is a sybol in N called the start symbol
   %visible StringLib, Containers.OrderedList, Containers.Set

   Grammar:
      nonTerminals: obj Set(#Nonterminal)
         expSy: obj Nonterminal("Exp")
         termSy: obj Nonterminal("Term")
         primarySy: obj Nonterminal("Primary")
         numbery: obj Nonterminal("Number")
         digitSy: obj Nonterminal("Digit")
      terminals: obj Set(#Terminal)
         add: obj Terminal("+")
         mult: obj Terminal("*")
         leftB: obj Terminal("(")
         rightB: obj Terminal(")")
      rules: obj OrderedList(#Rule)
      start: ref Nonterminal
      Symbol(printName:  obj String): 
         id: var integer
         print:<
             inner(print)
         isTerminal:
            out V: var Boolean
         inner(Symbol)	    
      NonTerminal: Symbol
         ...
         print::
            put('<')
            printName.print
            put('>')
      Terminal: Symbol
         ...
         print::
             put('"')
             printName.print
             put('"')	 
      Rule:
         leftSide: ref Nonterminal
         alternatives: obj OrderedList(#Alternative)
            print:
               i: var integer 	    
               scan
                  i := i + 1	       
                  if (i > 1) :then
                      " |".print	
                  current.print	    
         print:
            leftSide.print
            " ::=".print
            alternatives.print
      SymbolList: OrderedList(#Symbol)
         ...
      Alternative(symbols: ref SymbolList):
         print:
            symbols.scan
               _put(' ')	    
               current.print
      noOfRules: var integer;       
      addRule(L: ref Nonterminal): 
         R: ref Rule
         alt: ref Alternative
         R := Rule
         R.leftSide := L
         inner(addRule)
         rules.insert(R)	 
      print:	 
         "Grammar:\n".print
         "   start: ".print
         start.print
         newline	 
         rules.scan
            "   ".print	 
            current.print
            newline
      parse(input: ref text) :<       
         output: ref AbstractSyntaxTree
         -- Parse the input string according to the grammar
         -- and produce an abstract syntax tree
         --return output
      inner(Grammar)
   Text:
      ...
   AbstractSyntaxTree:
      ...
