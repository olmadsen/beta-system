Grammar: obj
   -- A grammar ia a 4-tuple G = (N,T,P,S) where
   --   N is a set of nonterminal symbols
   --   T is a set of terminal symbols, the intersection of N and T is empty
   --   P is a set of productions
   --   S is a sybol in N called the start symbol
   %visible StringLib, Containers.OrderedList, Containers.Set

   Grammar:
      nonTerminals: obj Set(#Nonterminal)
      terminals: obj Set(#Terminal)
      rules: obj OrderedList(#Rule)
      start: ref Nonterminal
      Symbol(printName:  obj String): 
         id: var integer
         print:<
             inner(print)
         isTerminal:<
            out V: var Boolean
            inner(isTerminal)	    
         inner(Symbol)	    
      NonTerminal: Symbol
         ...
         print::
            put('<')
            printName.print
            put('>')
         "NT:".print
         printName.print
         newline	 
         nonTerminals.insert(this(Nonterminal))
         "end\n".print	 
      Terminal: Symbol
         isTerminal::
            V := true	 
         print::
             put('"')
             printName.print
             put('"')	 
      Rule:
         leftSide: ref Nonterminal
         alternatives: obj OrderedList(#Alternative)
            print:
               i: var integer 	    
               scan
                  i := i + 1	       
                  if (i > 1) :then
                      " |".print	
                  current.print	    
         print:
            leftSide.print
            " ::=".print
            alternatives.print
      SymbolList: OrderedList(#Symbol)
         ...
      Alternative(symbols: ref SymbolList):
         print:
            symbols.scan
               _put(' ')	    
               current.print
      noOfRules: var integer;       
      addRule(L: ref Nonterminal): 
         R: ref Rule
         alt: ref Alternative
         R := Rule
         R.leftSide := L
         inner(addRule)
         rules.insert(R)	 
      print:	 
         "Grammar:\n".print
         "   start: ".print
         start.print
         newline	 
         rules.scan
            "   ".print	 
            current.print
            newline
      parse(input: ref text) :<       
         output: ref AbstractSyntaxTree
         -- Parse the input string according to the grammar
         -- and produce an abstract syntax tree
         --return output
      inner(Grammar)
   Text:
      ...
   AbstractSyntaxTree:
      ...
