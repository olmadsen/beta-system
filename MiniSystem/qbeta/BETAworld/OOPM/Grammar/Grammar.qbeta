Grammar: obj
   %visible StringLib, Containers.OrderedList, Containers.Set
   Grammar:
      Symbol(printName:  obj String): 
         id: var integer
         print:<
             inner(print)
         ... 
         isTerminal:
            out V: var Boolean
            ...
         inner(Symbol)	    
      NonTerminal: Symbol
         ...
         print::
            put('<')
            printName.print
            put('>')
      nonTerminals: obj Set(#Nonterminal)
         expSy: obj Nonterminal("Exp")
         termSy: obj Nonterminal("Term")
         primarySy: obj Nonterminal("Primary")
         numbery: obj Nonterminal("Number")
         digitSy: obj Nonterminal("Digit")
      Terminal: Symbol
         ...
         print::
             put('"')
             printName.print
             put('"')
      terminals: obj Set(#Terminal)
         add: obj Terminal("+")
         mult: obj Terminal("*")
         leftB: obj Terminal("(")
         rightB: obj Terminal(")")	 
      Rule:
         leftSide: ref Nonterminal
         alternatives: obj OrderedList(#Alternative)
            print:
               i: var integer 	    
               scan
                  i := i + 1	       
                  if (i > 1) :then
                      " |".print	
                  current.print	    
         print:
            i: var integer	 
            leftSide.print
            " ::=".print
            alternatives.scan
               i := i + 1
               if (i > 1) :then
                  " |".print	       
               current.print
      SymbolList: OrderedList(#Symbol)
         ...
      Alternative(symbols: ref SymbolList):
         print:
            symbols.scan
               _put(' ')	    
               current.print
      rules: obj OrderedList(#Rule)
      noOfRules: var integer;       
      addRule(L: ref Nonterminal): 
         R: ref Rule
         alt: ref Alternative
         R := Rule
         R.leftSide := L
         inner(addRule)
         rules.insert(R)	 
      print:	 
         "Grammar:\n".print
         rules.scan
            "   ".print	 
            current.print
            newline
      parse(input: ref text) :<       
         output: ref AbstractSyntaxTree
         -- Parse the input string according to the grammar
         -- and produce an abstract syntax tree
         --return output
      inner(Grammar)
   Text:
      ...
   AbstractSyntaxTree:
      ...
   ExpressionGrammar: obj Grammar
      mkExpRules: addRule(Nonterminal("Exp"))
         S: ref SymbolList
         R.leftSide := nonterminals.ExpSy
         S := SymbolList
         S.insert(nonterminals.ExpSy)
         S.insert(Terminal("+"))
         S.insert(nonterminals.termSy)
         alt := Alternative(S)
         R.alternatives.insert(alt)
         S := SymbolList
         S.insert(nonterminals.termSy)
         alt := Alternative(S)
         R.alternatives.insert(alt)
      mkTermRules: addRule(Nonterminal("Term"))
         S: ref SymbolList
         S := SymbolList
         S.insert(Nonterminal("Term"))
         S.insert(Terminal("*"))
         S.insert(Nonterminal("Primary"))
         alt := Alternative(S)
         R.alternatives.insert(alt)
         S := SymbolList
         S.insert(Nonterminal("Primary"))
         alt := Alternative(S)	 
         --alt.insert(S) - error not catched by checker!?
         R.alternatives.insert(alt)
      mkPrimaryRules: addRule(Nonterminal("Primary"))
         S: ref SymbolList
         S := SymbolList
         S.insert(Nonterminal("Number"))
         alt := Alternative(S)
         R.alternatives.insert(alt)
         S := SymbolList
         S.insert(Terminal("("))
         S.insert(NonTerminal("Exp"))
         S.insert(Terminal(")"))
         alt := Alternative(S)	 
         R.alternatives.insert(alt)
      mkNumberRules: addRule(Nonterminal("Number"))
         S: ref SymbolList
         S := SymbolList
         S.insert(Nonterminal("Number"))
         S.insert(NonTerminal("Digit"))
         alt := Alternative(S)
         R.alternatives.insert(alt)
         S := SymbolList
         S.insert(NonTerminal("Digit"))
         alt := Alternative(S)	 
         R.alternatives.insert(alt)
      mkDigitRules: addRule(Nonterminal("Digit"))
         mkDigit(sym: ref String):
            S: ref SymbolList
            A: ref Alternative	 
            S := SymbolList
            S.insert(Terminal(sym))
            A := Alternative(S)
            R.alternatives.insert(A)
         mkDigit("0")
         mkDigit("1")
         mkDigit("2")
         mkDigit("3")
         mkDigit("4")
         mkDigit("5")
         mkDigit("6")
         mkDigit("7")
         mkDigit("8")
         mkDigit("9")
      "Expression:\n".print
      if (nonterminals == none) :then
         "nonterminals is none\n!".print 
      if (nonterminals.expSY == none) :then
         "expSy is none\n!".print
      mkExpRules
      mkTermRules
      mkPrimaryRules
      mkNumberRules
      mkDigitRules
      print
