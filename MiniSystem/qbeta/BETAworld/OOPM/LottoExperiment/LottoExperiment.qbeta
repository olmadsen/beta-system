LottoExperiment: obj MonitorSystemLib.MonitorSystem
   %visible Collections.OrderedList,Collections.SetLib,LIB.DateTimeLib, LIB.Dimensions

   clock:
      %globals
      waitAweek -> B: var Boolean:
         sleep(100)
      now -> T: var DateTime(Date(0,0,0),0 min):
         ...
      oneWeek -> T: var DateTime(Date(0,0,0),0 min):
         ...
   randomGenerator: Monitor
      R : obj Indexed(10,#integer)
      ix: var integer
      init::
         --linearRandomGenerator(3,5,9,34,10)
      random(start: var integer,end: var integer) -> V: var integer: entry
         if (false) :then
            --console.display
            --   "random: start,end:ix;V ".print
            --   putint(start)
            --   put(',')	 
            --   putint(end)
            --   put(':')
            ix := (ix /% 10) + 1
            V := R.get[ix]
      linearRandomGenerator(x0: var integer, a: var integer,
                            b: var integer,
                            m: var integer,
                            n: var integer): entry
         -- x0=seed a=multiplie b=increment m=modulus n=desired array length;
         --"LinearRandomGenerator n:".print
         --putint(n)
         --newline
         for (1):to(n):repeat
             x0 := (a * x0 + b) /%m
             R.put(x0):at[inx]	  
             --putint(R.get[inx])
             --put(' ')
         -- newline	  

      sevenRandomNumbers -> srn: ref Indexed(7, Integer): entry
         inx: var Integer
         srn := Array(7, Integer)
         for (1):to(7):repeat
             srn.put(R.get[inx]):at[inx]
   ran: obj RandomGenerator
   ranLotto: obj RandomGenerator
   ranSeven1: obj RandomGenerator
   inTheMoodForPlaying -> m: var Boolean:
      %globals ran, console
      --console.display
      --   "inTheMoodForPlaying:\n".print
      m := (ran.random(0,1) /% 2) <> 0

   inTheMoodForPlayingSameNumbers -> m: var Boolean:
      %globals ran, console
      --console.display
      --   "inTheMoodForPlayingSameNumbers:\n".print
      m := (ran.random(0,1) /% 2) <> 0

   class Bet(timeIssued: var DateTime(Date(0,0,0),0 min), 
      playerKind: var String, numbers: ref Indexed(7, #Integer) ):
      %globals
      %immutable
      equal(B: ref Bet) -> B: var Boolean:
         ...
   class Player: MonitorProcess 
      kind: var String
      myBet: ref Bet
      dt: var DateTime(Date(0,0,0), 0 min)
      if (inTheMoodForPlayingSameNumbers) :then 
         --console.display
         --    "same:\n".print
         kind := "same"
      :else
         --console.display
         --    "random\n".print
         kind := "random"

      myBet := Bet(clock.now, this(Player).kind, ran.sevenRandomNumbers)
      L: do
         cycle -- for each week
            if (inTheMoodForPlaying) :then
               if (kind = "random") :then
                  myBet := Bet(dt, kind, ranseven1.sevenRandomNumbers)
               lotto.submitBet(myBet)
            sleep(600) --clock.waitAweek
            if (lotto.stop) :then
               leave(L)
   lotto: obj monitor
      bets: obj Set(#Bet)
      winningBet: ref Bet
      d: var Date(0,0,0)
      deadline: var DateTime(d,0 min)

      clearBets: entry
         bets.clear
 
      submitBet(b: ref Bet): entry
         --console.display
         --     "submitBet:\n".print	 
         if ((b.timeIssued <= deadline) &&
            (b.timeIssued >= (deadline - clock.oneWeek))) :then
               bets.insert(b)

      findWinningBets: entry
         noOfRandomWinners: var integer
         noOfSameWinners: var Integer
         d: var DateTime(Date(0,0,0),0 min)
         R: obj Indexed(7,#integer)
         --console.display
         --     "findWinningBets:\n".print
         winningBet := Bet(d, "",R)
         --winningBet := Bet(clock.now, "winning bet",ranLotto.sevenRandomNumbers)
         --console.display
         --     "before bets.scan:\n".print	 
         -- check if any bet matches winningBet
         bets.scan
            --if (current.numbers == winningBet.numbers) :then
            if (current.equal(winningBet)) :then
               if (current.playerKind = "random") :then
                   noOfRandomWinners := noOfRandomWinners + 1
               :else 
                   noOfSameWinners := noOfSameWinners + 1
               -- print noOfRandomWinners, noOfSameWinners
         console.display
             "winningBet:end\n".print
      stop -> B: var Boolean: entry
         B := doStop
      setStop: entry
         doStop := true
      doStop: var Boolean	 
   main: obj MonitorProcess("main")
      i: var integer
      L: do
         cycle
            i := i + 1      
            clock.waitAweek
            lotto.findWinningBets
            lotto.clearBets
            lotto.deadline := clock.now + clock.oneWeek
            if (i > 10) :then
               console.display
                   "stop\n".print
               leave(L)
      lotto.setStop
   maxNoOfPlayers: val 5
   inx: var Integer
   players: obj Set(#Player)
   generatePlayers: do
      inx := inx + 1
      if (inx <= maxNoOfPlayers) :then
         players.insert(Player("aPlayer" + I2S(inx)))
         restart(generatePlayers)
   -- starting lotto and the players:
   lotto.deadline := clock.now + clock.oneWeek
   -- deadline must be set before starting the players
   --ran.init
   ran.linearRandomGenerator(3,5,9,34,10)
   ranLotto.linearRandomGenerator(7,5,9,34,10)
   ranSeven1.linearRandomGenerator(9,5,9,34,10)	
   lotto.init
   main.start
   players.scan  
      current.start 
   newline
