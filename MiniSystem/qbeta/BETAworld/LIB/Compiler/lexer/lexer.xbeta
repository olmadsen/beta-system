lexer: obj
   init:< 
      in FN: ref String
      in SF: ref FileSys.File
      srcFN := FN
      srcF := SF
      lexer.symbols.init      
   srcFN: ref String
   srcF: ref FileSys.File
   hasLexError: var Boolean
   ch: var char
   token: var integer
   tokenStr: ref String
   nextCh: obj
      pos: var integer
      linePos: var integer
      onlyWhiteSpace: var Boolean
      get: 
         @if srcF.eof :then 
            ch := 255 
         :else 
            ch := srcF.get
         @if ch <= 13 :then
            linePos := 0
            onlyWhiteSpace := true
         :else
             linePos := linePos + 1
             @if (ch > ' ') && onlyWhiteSpace :then
                @if (ch = '-') ||  (ch = '§') :then
                :else
                   onlyWhiteSpace := false
         --"nextCh: {C(ch)}\n".print
   printLines:
      in n: var integer
      "\nprintLines {I2S(n)}\n".print
   readName: 
      in cx: var char
      isConst: var Boolean
      sym: obj indexed(20,#char)     
      prevCh: var char      
      i: var integer
      --"readName C = {C(cx)} ch = {C(ch)}\n".print
      isConst := ascii.isDigit(ch)
      @if cx > 0 :then {i := i + 1; sym.@put cx :at i}
      L: 
         @if (ascii.isLetter(ch) || ascii.isDigit(ch) 
              || (ch = '_') || (ch = '%') || (ch = '@')) :then 
            i := i + 1
            sym.@put ch :at i
            prevCh := ch
            nextCh.get
            @restart L
      L
      tokenStr := sym.asString
      switch(true)
            case(isConst && (ch = '.'))
               --"got float const:\n".print
               i :=i + 1
               sym.@put ch :at i  
               nextCh.get
               LL:
                  @if ascii.isDigit(ch) :then
                     i := i + 1	
                     sym.@put ch :at i
                     prevCh := ch
                     nextCh.get
                     @restart LL
               LL
               tokenStr := sym.asString
               token := symbols.floatConst
            case(prevCh = '%')
               --"got fatComma\n".print
               token := symbols.fatComma
            case(isConst)
               --"got const\n".print
               token := symbols.const
            case(tokenStr = "var")
               --"gotVar\n".print 
               token:= lexer.symbols.varVal
            case(tokenStr = "val")
               --"gotVal\n".print 
               token:= lexer.symbols.constVal
            case(tokenStr = "ref")
               --"gotRef\n".print 
               token:= lexer.symbols.varRef
            case(tokenStr = "obj")
               --"gotObj\n".print 
               token:= lexer.symbols.constRef
            case(tokenStr = "in")
               --"gotIn\n".print 
               token:= lexer.symbols.inArg
            case(tokenStr = "out")
               --"gotOut\n".print 
               token:= lexer.symbols.outArg
            token := symbols.idf
      --"readName: {tokenStr}\n".print
   readString:
      sym: obj indexed(200,#char)
      i: var integer
      --"readString {C(ch)} {I2s(sym.length) }".print      
      nextCh.get
      read:
         --" next: {C(ch)} {I2S(i)}".print
         switch(ch)
            case('"')
               -- end-of-string
               @leave read
            case('\\')
               i := i + 1
               sym.@put ch :at i
               nextCh.get
               i := i + 1
               sym.@put ch :at i
               nextCh.get
            case(ascii.nl)
               "\n\n*** ERROR: end-of-line when parsing String\n".print
               hasLexError := true
               printLines(3)
            case(('H','e','l','o'))   
               i := i + 1
               --put(' ')
               --putint(i)
               --put(' ')
               sym.@put ch :at i
               nextCh.get              
            i := i + 1
            put(' ' )
            putint(i)
            sym.@put ch :at i
            nextCh.get
         @restart read
      read
      token := lexer.symbols.stringSy
      tokenStr := sym.asString  
   comment: obj
      theCom: ref String
      i: var integer
      sym: obj Indexed(500,#char)
      skip:
         i: var integer
         putx:
            in c: var char
            i := i + 1
            sym.@put c :at i
         get:
            "comment.get!\n".print
         --@if theCom.length > 1 :then putx(ascii.nl)
         @if nextCh.onlyWhiteSpace :then putx('<')
         nextCh.get;
         int2chars(nextCh.linePos)
             i := i + 1
             sym.@put ch :at i
         putx('>')
         putx(ch)
         loop:
            nextCh.get
            @if (ch = ascii.nl) || (ch = 255) :then
            :else
                putx(ch)
                @restart loop
         loop 
         theCom := sym.asString
         "§{theCom}\n".print
   parenthLevel: var integer
   readNextToken: 
      out hasComment: var Boolean
      --"readNextToken: {C(ch)}\n".print
      tokenStr := ""
      switch(ch)
         case(0)
            nextCh.get
            tokenStr := "--0-"	 
         case('{')
            token := symbols.begin
            parenthLevel := parenthLevel + 1
            nextCh.get
         case('}')
            token := symbols.end
            parenthLevel := parenthLevel - 1
            nextCh.get
         case('(')
            token := symbols.leftBrack
            parenthLevel := parenthLevel + 1
            nextCh.get
         case(')')
            token := symbols.rightBrack
            parenthLevel := parenthLevel - 1
            nextCh.get
         case(':')
            nextCh.get
            switch(true)
               case(ch = '=')
                  symbols.readSpecial(':')
               case(ch = '<')
                  token := symbols.virtual
                  nextCh.get
               case(ch = ':')
                  nextCh.get
                  @if ch = '<' :then
                      nextCh.get
                      token := symbols.further
                  :else
                      token := symbols.final
               case(ascii.isLetter(ch))
                  --"read fat comma: {C(ch)}\n".print
                  readName(':')
                  token := symbols.fatComma
               token := symbols.colon
               tokenStr := ":"
         case(('=','<','>','&','|'))
            prevCh: var char
            prevCh := ch	    
            nextCh.get	 
            symbols.readSpecial(prevCh)
         case(';')
              token := symbols.semicolon
              nextCh.get
         case('§')
            comment.skip
            hasComment := true
         case(('@','#','%'))
            prevCh: var char
            prevCh := ch	 
            nextCh.get
            @if ascii.isLetter(ch) :then
                readName(prevCh)
            --"KW: ".print
            --tokenStr.print
            --put(ch)
            --newline	    
            token := symbols.keyword	    
         case('"')
            readString
            nextCh.get	    
         case(255)
            token := symbols.eos
            tokenStr := "eos"
         --"TTT: {C(ch)} {I2S(ch)}\nl".print
         @if ascii.isLetter(ch) || ascii.isDigit(ch) :then
            readName(0)
         :else
            "\nNo match for char: {C(ch)} {I2S(ch)}\n".print	
   indent: obj 
      skipBlanks: 
         out inOut: var integer
         skip: 
            @if ch <= 32 :then 
               nextCh.get
               @restart skip
         @if ch = 0 :then 
            nextCh.get
         skip
   nextTokens: 
      inOut: var integer
      inOut := indent.skipBlanks
      -- must check inOut
      @if readNextToken :then
             @restart nextTokens
      
   tokenBuf: obj 
      get: 
         dummy: var integer
         --"tokenBuf.get\n".print
         
   next: 
      nextTokens
      tokenBuf.get
   