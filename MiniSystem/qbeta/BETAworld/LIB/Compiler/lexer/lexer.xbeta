lexer: obj 
   init:< 
      in FN: ref String.String
      in SF: ref FileSys.File
      srcFN := FN
      srcF := SF
   srcFN: ref String.String
   srcF: ref FileSys.File
   ch: var char
   token: var integer
   tokenStr: ref String.String
   nextCh: obj 
      get: 
         @if srcF.eof :then 
            ch := 255 
         :else 
            ch := srcF.get
            --"nextCh:".print
            
            --put(ch)
            
            --newline
            
   symbols: obj 
      begin: val 1
      colon: val 5
      special: val 32
      idf: val 33
      eos: val 82
   readName: 
      isConst: var Boolean
      sym: obj indexed(20,#char)
      i: var integer
      isConst := ascii.isDigit(ch)
      L: 
         @if ascii.isLetter(ch) || ascii.isDigit(ch) :then 
            i := i + 1
            sym.@put ch :at i
            nextCh.get
            @restart L
            --"readName:".print
            
      L
      tokenStr := sym.asString
      token := symbols.idf
      --"readName: ".print
      
      --tokenStr.print
      
      --newline
      
   readNextToken: 
      --"readNextToken: ".print
      --put(ch)
      --newline
      tokenStr := ""
      @if ch = '{' :then 
         token := symbols.begin
         nextCh.get 
      :else 
         @if ch = ':' :then 
            nextCh.get
            @if ch = '=' :then 
               token := symbols.special
               tokenStr := ":="
               nextCh.get 
            :else 
               token := symbols.colon
               nextCh.get
               tokenStr := ":" 
         :else 
            @if ch = 255 :then 
               token := symbols.eos
               tokenStr := "eos" 
            :else 
               @if ascii.isLetter(ch) || ascii.isDigit(ch) :then 
                  readName
   indent: obj 
      skipBlanks: 
         out inOut: var integer
         skip: 
            @if ch <= 32 :then 
               nextCh.get
               @restart skip
         @if ch = 0 :then 
            nextCh.get
         skip
   nextTokens: 
      inOut: var integer
      inOut := indent.skipBlanks
      -- must check inOut
      
      readNextToken
   tokenBuf: obj 
      get: 
         dummy: var integer
         --"tokenBuf.get\n".print
         
   next: 
      nextTokens
      tokenBuf.get