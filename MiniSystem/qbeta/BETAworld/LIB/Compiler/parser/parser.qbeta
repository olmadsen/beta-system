parser: obj
   %requires FileSys,lexer.Symbols, AST
   %visible AST
   dummy: var integer
   pModule:
      sig: ref Signature(none):args(none)
      DI: ref SuperDataItem
      OG: ref ObjectGenerator(none):items(none)
      if(lexer.token = lexer.symbols.idf):then
          "OK".print
          sig := pSignature
          if (lexer.token = lexer.symbols.colon) :then
             lexer.next
             if (lexer.token = lexer.symbols.constRef) :then
                lexer.next
                OG :=pSuperDataItem
                "in pSuperDI:".print
                DI := Module(sig):OG(OG)
                DI.sig := sig
                DI.og := OG		
             :else
                syntaxError(1)
          :else
             syntaxError(2)
      :else
          syntaxError(3)
   pSuperDataItem:
      --in pSuperDataItem:< Object
      out OG: ref ObjectGenerator(none):items(none)
      OG := pObjectGenerator
      --pSuperDataItem
   pSignature:
      out sig: ref Signature(none):args(none)
      tokenStr: ref String
      prevToken: var integer
      if(lexer.token = lexer.symbols.idf):then
         tokenStr := lexer.tokenStr
         lexer.next
         switch(lexer.token)
             case((lexer.symbols.begin
                   ,lexer.symbols.leftBrack
                   ,lexer.symbols.leftSquare))
                _put('Q')
                prevToken := lexer.token
                lexer.next
                pSigArgs(tokenStr):leftB(prevToken)
             "unarySig:".print
   pSigArgs(tokenStr: ref String):leftB(leftB: var integer):
      tokenStr.print
   pObjectGenerator:
      out OG: ref ObjectGenerator(none):items(none)
      IV: ref Invocation
      IS: ref Items
      IV := pInvocation
      IS := pMainPart
      OG := ObjectGenerator(IV):items(IS)
   pInvocation:
      out IV: ref Invocation

   pMainPart:
      out IS: ref Items
      if (lexer.token = lexer.symbols.begin) :then
         lexer.next
         IS := pItems
         switch(lexer.token)
            case((lexer.symbols.end,lexer.symbols.eos))
                 lexer.next
            SyntaxError(4)
      :else
         IS := Items

   pItems:
      out IS: ref Items
      "items:".print
      if (lexer.token = lexer.symbols.idf) :then
         switch(lexer.peekNext(1))
            case((lexer.symbols.colon))
                pDecl
            pObjectGenerator
   pDecl:
       out D: ref Decl(none):OG(none)
       sig: ref Signature(none):args(none)
       "pDecl:".print
       sig := pSignature
       L: obj
          switch(lexer.token)
             case(lexer.symbols.constRef)
                 lexer.next
                 D := pDataItem(sig)
             syntaxError(5)
   pDataItem(sigx: ref Signature(none):args(none)): 
      out D: ref DataItem
      OG: ref ObjectGenerator(none):items(none)
      "pDataItem:".print 
      OG := pSuperDataItem
      D := DataItem
      D.setSig(sigx)
      D.OG := OG
   genTokenStream: 
      ind: var integer
      lexer.next
      --"Got: {I2S(lexer.token)} {lexer.tokenStr}\n".print
      switch(lexer.token)
         case(0)
            "-Z-".print
         case(lexer.symbols.begin)
            newline
            ind := ind + 2   
            for(1):to(ind):do
               put(' ')         
            put('{')
         case(lexer.symbols.semicolon)
            put(';')
            newline
            for(1):to(ind):do
               put(' ')
         case(lexer.symbols.end)
            newline
            for(1):to(ind):do
                put(' ')
            put('}')
            ind := ind - 2
            newline
            for(1):to(ind):do 
               put(' ')
         case(lexer.symbols.charSy)
            put('\'')
            lexer.tokenstr.print
            put('\'')
         case(lexer.symbols.stringSy)
            put('"')
            lexer.tokenStr.print
            put('"')
         case(
           (lexer.symbols.idf,
            lexer.symbols.const,
            lexer.symbols.floatConst,
            lexer.symbols.special,
            lexer.symbols.keyWord,
            lexer.symbols.fatComma))
            lexer.tokenStr.print
         lexer.symbols.asText(lexer.token).print
      put(' ')
      if(lexer.token <> lexer.symbols.eos):then 
         restart(genTokenStream)
   syntaxError(no: var integer):
      "\nsyntax error: ".print
      putint(no)
      newline
   go: 
      --genTokenStream
      lexer.next
      pModule
