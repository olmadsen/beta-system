parser: obj
   %requires lexer,lexer.Symbols, AST
   %visible AST
   dummy: var integer
   pModule:
      sig: ref Signature:args
      out DI: ref SuperDataItem:OG
      OG: ref ObjectGenerator:Items
      trace("pModule")
      if(lexer.token = lexer.symbols.idf):then
          sig := pSignature
          if (lexer.token = lexer.symbols.colon) :then
             lexer.next
             if (lexer.token = lexer.symbols.constRef) :then
                lexer.next
                OG := pSuperDataItem
                DI := Module(sig):OG(OG);
             :else
                syntaxError(1)
          :else
             syntaxError(2)
      :else
          syntaxError(3)
   pSuperDataItem:
      --in pSuperDataItem:< Object
      out OG: ref ObjectGenerator:Items
      trace("pSuperDataItem")
      OG := pObjectGenerator
   pSignature:
      out sig: ref Signature:args
      args: ref Arguments
      tokenStr: ref String
      prevToken: var integer
      id: ref String
      trace("pSignature")
      if(lexer.token = lexer.symbols.idf):then
         tokenStr := lexer.tokenStr
         lexer.next
         switch(lexer.token)
             case((lexer.symbols.begin
                   ,lexer.symbols.leftBrack
                   ,lexer.symbols.leftSquare))
                prevToken := lexer.token
                lexer.next
                trace("pSignature:brack")
                -- missing save of return value
                args := pSigArgs(tokenStr):leftB(prevToken)
                sig := Signature(tokenStr):args(args)
             trace("pSignature:unarySig")
             sig := Signature(tokenstr):args(args)
   brackAsText(sy: var integer):
         out T: ref String
         switch(sy)
            case((lexer.symbols.leftBrack))
               T := "("
            case((lexer.symbols.rightBrack))
               T := ")"
            case((lexer.symbols.begin))
               T := "{"
            case((lexer.symbols.end))
               T := "\}"
            case((lexer.symbols.leftSquare))
               T := "["
            case((lexer.symbols.rightSquare))
               T := "]"
   pArgs(tokenStr: ref String):leftB(leftB: var char):
      out args: ref Arguments
      id: ref String
      rightB: var char
      comma: ref String
      trace("pArgs")
      rightB := leftB + 1
      args := Arguments
      id := lexer.tokenStr
      args.addsep(brackAsText(leftB))
      pArg: do
         inner(#pArgs:leftB)
         trace("pArgs:after:inner")	 
         switch(lexer.token)
             case(rightB)
                trace("pArgs:rightB")
                lexer.next
                if(lexer.token = lexer.symbols.fatComma) :then
                   -- check what we append ')' :foo '('
                   -- or '):foo('		   
                   comma := brackAsText(rightB) + lexer.tokenStr
                   id := id + lexer.tokenStr		   
                   trace("pArg:got:fatComma")
                   lexer.next
                   trace("pArg:got:fatComma:B")		   
                   switch(lexer.token)
                        case((lexer.symbols.leftBrack
                             ,lexer.symbols.leftSquare
                             ,lexer.symbols.begin))
                             leftB := lexer.token
                             rightB := leftB + 1
                             lexer.next			     
                             trace("pArg:getParenth:A");
                             comma := comma + brackAsText(leftB)
                             trace("pArg:getParenth:B");
                             args.addSep(comma)
                             trace("pArg:getParenth:C");
                             restart(pArg)
                        syntaxError(111)
                :else
                   trace("pArg:else")		
                   args.addSep(brackAsText(rightB))
             case(lexer.symbols.comma)
                 args.addSep(",")
                 lexer.next
                 restart(pArg)
             case(lexer.symbols.semicolon)
                 -- skip
             case(lexer.symbols.eos)
                 "\nEOS\n".print
                 args.addSep("\}")		 
             syntaxError(112)
         args.id := id
         --args.id.print
   pSigArgs(tokenStr: ref String):leftB(leftB: var char): pArgs(tokenStr):leftB(leftB)
      D: ref Decl:OG
      trace("pSigArgs:main")
      D := pDecl
      args.append(D)
   convertLastArg(IV: ref Invocation):
      E: ref Exp
      E := IV.last
      if ((E.args.noOfSons = 4) \
         && (E.args.inBraces)  \
         && E.isObjectInvocation) :then
         _put('a')
   pObjectGenerator:
      out OG: ref ObjectGenerator:items
      IV: ref Invocation
      IS: ref Items
      trace("pObjectGenerator")
      IV := pInvocation
      if (IV.isEmpty) :then
         IS := pMainPart
      :else
         IS := Items
         IS.isEmpty := true
      -- must check if IV.last.args is actually a mainpart using convertLastArg
      OG := ObjectGenerator(IV):Items(IS)
   pInvocation:
      out IV: ref Invocation
      E: ref Exp 
      i: var integer
      trace("pinvocation")
      IV := Invocation
      loop: do
         trace("pInvocation:loop")
         i := i + 1
         E := pExp;
         IV.append(E)
         switch((lexer.token))
            case((lexer.symbols.dot))
               trace("pInvocation:special")
               lexer.next
               restart(loop)
            case((lexer.symbols.special))
               trace("pInvocation:special")
               restart(loop)
      IV.isEmpty := E.isEmpty
   pMainPart:
      out IS: ref Items
      trace("pMainPart")
      if (lexer.token = lexer.symbols.begin) :then
         lexer.next
         IS := pItems
         trace("pMainPart:after:pItems")
         switch(lexer.token)
            case((lexer.symbols.end,lexer.symbols.eos))
                 lexer.next
            SyntaxError(4)
      :else
         trace("pMainPart:IS.isEmpty")
         IS := Items
         IS.isEmpty := true
   pItems:
      out IS: ref Items
      D: ref Decl:OG
      OG: ref ObjectGenerator:Items
      trace("pItems")
      IS := Items
      trace("pItems:loop")
      Loop: do
         switch (lexer.token)
            case((lexer.symbols.inArg,lexer.symbols.outArg))
               "in/out arg".print	    
               IS.append(pDecl)	    
            case(lexer.symbols.idf)
               switch(lexer.peekNext(1))
                  case((lexer.symbols.colon
                       ,lexer.symbols.virtual
                       ,lexer.symbols.further
                       ,lexer.symbols.final))
                      D := pDecl
                      IS.append(D)
                  case(lexer.symbols.leftBrack)
                     switch (lexer.peekNext(3))
                         case((lexer.symbols.colon,lexer.symbols.virtual))
                             IS.append(pDecl)
                     IS.append(pObjectGenerator)
                  trace("pItems:before:pObjectGenerator")
                  OG := pObjectGenerator
                  IS.append(OG)
            case(lexer.symbols.special)
                 trace("pItems:got:special")
                 lexer.next
            case(lexer.symbols.property)
                propId: ref String
                propId :=  lexer.tokenStr
                lexer.next
                IS.append(pProperty(propId))
            case(lexer.symbols.leftBrack)
                lexer.next	    
                IS.append(pObjectGenerator) -- should be bracketedExp
                if (lexer.token = lexer.symbols.rightBrack) :then
                    lexer.next
                :else		    
                    "Syntax error - missign brackets\n".print
            case(lexer.symbols.StringSy)
                trace("pItems:got:String")
                --IS.append(StringSy(lexer.TokenStr))		
                --lexer.next
                IS.append(pObjectGenerator)
            case((lexer.symbols.const           -- are these meaningful?
                 ,lexer.symbols.floatConst
                 ,lexer.symbols.charSy))
                trace("pItems:got:charSy")
                IS.append(pObjectGenerator)

         if (lexer.token = lexer.symbols.semicolon) :then
            lexer.next
            trace("pItems:after:semicolon:next")
            restart(Loop)
   pProperty(propId: ref String):
      out P: ref Property:args
      args: ref PropertyArgs
      args := PropertyArgs
      parseArgs: do
         switch(lexer.token)
            case((lexer.symbols.idf
                 ,lexer.symbols.const,lexer.symbols.floatConst
                 ,lexer.symbols.StringSy))
                 trace("propArg")
                 args.append(pInvocation)
                 if (lexer.token = lexer.symbols.comma) :then
                     lexer.next
                     trace("propArg:next")
                     restart(parseArgs)
      P := Property(Name(propId)):args(args)
         
   pVarRefDI(sig: Ref Signature:args):isConst(isConst: var boolean):isValue(isValue: var Boolean):
      out DI : ref SuperDataItem:OG
      IV: ref Invocation
      typeid: Ref String
      E: ref Exp
      OG: ref ObjectGenerator:Items
      IV := Invocation
      next: do
         typeId := pVarRefTypeNoBrack(sig):isConst(isConst):isValue(isValue)
         E := unaryGen(typeId,Arguments)
         IV.append(E)	 
         if (lexer.token = lexer.symbols.dot) :then
            lexer.next
            restart(next)
      OG := ObjectGenerator(IV):Items(Items)	    
      DI := DataItem(isConst):isValue(isValue):sig(sig):OG(OG)
      
   pVarRefTypeNoBrack(sig: Ref Signature:args):isConst(isConst: var boolean):isValue(isValue: var Boolean):
      out typeId: ref String
      if (lexer.token = lexer.symbols.idf) :then
         typeId := lexer.tokenStr
         lexer.next
         L: do
            if (lexer.token = lexer.symbols.fatComma) :then	 
               typeId := typeId + lexer.tokenStr
               lexer.next
               restart(L)	       
   pDecl:
       out D: ref Decl:OG
       sig: ref Signature:args
       OD: ref ObjectGenerator:Items
       isInArg: var Boolean
       isOutArg: var Boolean
       ptnKind: var integer
       trace("pDecl")
       switch(lexer.token)
          case(lexer.symbols.inArg)
              lexer.next	  
              isInArg := true
          case(lexer.symbols.outArg)
              lexer.next	  
              isOutArg := true
       sig := pSignature
       sig.dopt(true)
       L: do       
          switch(lexer.token)
             case(lexer.symbols.colon)
                lexer.next       
                switch(lexer.token)
                   case(lexer.symbols.constRef)
                       lexer.next
                       D := pDataItem(sig):isConst(true):isValue(false)
                       leave(L)
                   case(lexer.symbols.varRef)
                       trace("pDecl:ref")
                       lexer.next
                       --D := pDataItem(sig):isConst(false):isValue(false)
                       -- OBS unfinished business!		       
                       D := pVarRefDI(sig):isConst(false):isValue(false)
                       leave(L)
                   case(lexer.symbols.constVal)
                       trace("pDecl:val")  
                       lexer.next
                       D := pDataItem(sig):isConst(true):isValue(true)
                       leave(L)
                   case(lexer.symbols.varVal)
                       trace("pDecl:var")
                       lexer.next
                       D := pDataItem(sig):isConst(false):isValue(true)
                       leave(L)
                   case(lexer.symbols.doSy)
                       trace("pDecl:doSy")
                       lexer.next
                       D := pLabelDecl(sig)
                       leave(L)
                   ptnKind := plainPtn
             case(lexer.symbols.virtual)
                trace("ptn:virtual")
                lexer.next
                ptnKind := virtualPtn
             case(lexer.symbols.further)
                lexer.next
                ptnKind := furtherPtn
             case(lexer.symbols.final)
                lexer.next
                ptnKind := finalPtn
          OD := pObjectGenerator
          D := PatternGen(sig):OG(OD):kind(ptnKind)
       --syntaxError(5)
   pDataItem(sigx: ref Signature:args):isConst(isConst: var Boolean):isValue(isValue: var Boolean):
      out D: ref DataItem:isValue:sig:OG
      OG: ref ObjectGenerator:Items
      trace("pDataItem")      
      OG := pSuperDataItem
      D := DataItem(isConst):isValue(isValue):sig(sigx):OG(OG) -- ref args and sub dont work?
      --D.setSigOg(sigx,OG)
   pLabelDecl(sig: ref Signature:args):
      out LD: ref LabelDecl:OG
      OG: ref ObjectGenerator:Items
      trace("pLabelDecl")
      OG := pObjectGenerator
      LD := LabelDecl(sig):OG(OG)
   pExp:
      out E: ref Exp
      symb: ref String
      prevToken: var integer
      rightB: var integer
      args: ref Arguments
      trace("pExp")
      switch(lexer.token)
         -- missing, const,floatConst,string,charSy
         case((lexer.symbols.const))
            C: ref Const
            C := Const(lexer.TokenStr)
            --C.T := lexer.TokenStr
            E := C
            lexer.next
         case(lexer.symbols.idf)
             -- incomplete
             trace("pExp:idf")
             symb:= lexer.tokenStr
             lexer.next
             trace("pExp:before:switch")
             switch(lexer.token)
                case((lexer.symbols.begin, -- need to fix!
                     lexer.symbols.leftBrack
                     ,lexer.symbols.leftSquare))
                   prevToken := lexer.token
                   rightB := prevToken + 1 		   
                   lexer.next
                   trace("pExp:keyWord")
                   args := pExpArgs(symb):leftB(prevToken):prevT(prevToken)
                   trace("pExp:afterp:ExpArgs")
                   E := KeyWordGen(symb,args)
                   if (lexer.token = rightB) :then
                      trace("pExp:got:rightB")		   
                trace("pExp:unary")
                E := UnaryGen(symb,Arguments) -- should be UnaryGen
         case(lexer.symbols.stringSy)
             S: ref StringSy
             S := StringSy(lexer.tokenStr)
             lexer.next
             E := S  	     
         case((lexer.symbols.special))
             symb := lexer.tokenStr
             lexer.next
             E := pBinary(symb)
         trace("pExp:empty")
         E := Exp
         E.isEmpty := true	 
   pExpArgs(tokenStr: ref String):leftB(leftB: var integer):prevT(prevT: var integer): pArgs(tokenStr):leftB(leftB)
      --E: ref Exp;
      --E := pExp;
      IV: ref Invocation
      IS: ref Items
      trace("pExpArgs")
      "leftB: ".print
      lexer.symbols.asText(leftB).print
      " prevT:".print
      lexer.symbols.asText(prevT).print
      newline
      if (leftB = prevT) :then
         --lexer.next
         trace("pExpArgs:leftB=prevT")
         IS := pItems
         IV := Invocation
         IV.append(Exp)
         IV.isEmpty := true
         args.append(ObjectGenerator(IV):Items(IS))
      :else
         --lexer.next
         trace("pExpArgs:leftB<>prevT")
         args.append(pObjectGenerator)
      trace("pExpArgs:end")	 
   pBinary(op: ref String):
      out B: ref Exp
      args: ref Arguments
      args := Arguments
      args.isBinary := true
      args.append(pObjectGenerator)
      B := BinaryGen(op,args)
   genTokenStream: 
      ind: var integer
      lexer.next
      --"Got: {I2S(lexer.token)} {lexer.tokenStr}\n".print
      switch(lexer.token)
         case(0)
            trace("genTokenStream:eof")
         case(lexer.symbols.begin)
            newline
            ind := ind + 2   
            for(1):to(ind):repeat
               put(' ')         
            put('{')
         case(lexer.symbols.semicolon)
            put(';')
            newline
            for(1):to(ind):repeat
               put(' ')
         case(lexer.symbols.end)
            newline
            for(1):to(ind):repeat
                put(' ')
            put('}')
            ind := ind - 2
            newline
            for(1):to(ind):repeat
               put(' ')
         case(lexer.symbols.charSy)
            put('\'')
            lexer.tokenstr.print
            put('\'')
         case(lexer.symbols.stringSy)
            put('"')
            lexer.tokenStr.print
            put('"')
         case(
           (lexer.symbols.idf,
            lexer.symbols.const,
            lexer.symbols.floatConst,
            lexer.symbols.special,
            lexer.symbols.keyWord,
            lexer.symbols.fatComma))
            lexer.tokenStr.print
         lexer.symbols.asText(lexer.token).print
      put(' ')
      if(lexer.token <> lexer.symbols.eos):then 
         restart(genTokenStream)
   syntaxError(no: var integer):
      "\nsyntax error: ".print
      putint(no)
      " at token: \"".print
      lexer.symbols.asText(lexer.token).print
      put('"')
      newline
      lexer.printLines(5)
      hasSyntaxError := true
   trace(msg: ref String):
      if (true) :then
         msg.print
         put(':')
         put(' ' )
         putint(lexer.token)
         put(' ' )
         lexer.symbols.asText(lexer.token).print
         put(' ')
         lexer.tokenStr.print
         newline
   go:
      out N: ref Item
      --genTokenStream
      "***parser.go:\n".print      
      lexer.next
      N := pModule
