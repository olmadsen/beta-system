parser: obj
   %requires lexer,lexer.Symbols, AST
   %visible AST
   dummy: var integer
   pModule:
      sig: ref Signature:args
      out DI: ref SuperDataItem:OG
      OG: ref ObjectGenerator:Items
      trace("pModule")
      if(lexer.token = lexer.symbols.idf):then
          sig := pSignature
          if (lexer.token = lexer.symbols.colon) :then
             lexer.next
             if (lexer.token = lexer.symbols.constRef) :then
                lexer.next
                OG := pSuperDataItem
                DI := Module(sig):OG(OG);
             :else
                syntaxError(1)
          :else
             syntaxError(2)
      :else
          syntaxError(3)
   pSuperDataItem:
      --in pSuperDataItem:< Object
      out OG: ref ObjectGenerator:Items
      trace("pSuperDataItem")
      OG := pObjectGenerator
   pSignature:
      out sig: ref Signature:args
      tokenStr: ref String
      prevToken: var integer
      if(lexer.token = lexer.symbols.idf):then
         tokenStr := lexer.tokenStr
         lexer.next
         switch(lexer.token)
             case((lexer.symbols.begin
                   ,lexer.symbols.leftBrack
                   ,lexer.symbols.leftSquare))
                prevToken := lexer.token
                lexer.next
                -- missing save of return value
                pSigArgs(tokenStr):leftB(prevToken)
             trace("pSignature:unarySig")
             sig := Signature(tokenstr):args(Arguments)
   pSigArgs(tokenStr: ref String):leftB(leftB: var integer):
      -- incomplete
      trace("pSigArgs")
   pObjectGenerator:
      out OG: ref ObjectGenerator:items
      IV: ref Invocation
      IS: ref Items
      trace("pObjectGenerator")
      IV := pInvocation
      IS := pMainPart
      OG := ObjectGenerator(IV):Items(IS)
   pInvocation:
      out IV: ref Invocation
      E: ref Exp
      i: var integer
      trace("pinvocation")
      IV := Invocation
      loop:
         trace("pInvocation:loop")
         i := i + 1
         E := pExp;
         IV.append(E)
         switch((lexer.token))
            case((lexer.symbols.dot))
               trace("pInvocation:special")
               lexer.next
               restart(loop)
            case((lexer.symbols.special))
               trace("pInvocation:special")
               restart(loop)
      loop
   pMainPart:
      out IS: ref Items
      trace("pMainPart")
      if (lexer.token = lexer.symbols.begin) :then
         lexer.next
         IS := pItems
         switch(lexer.token)
            case((lexer.symbols.end,lexer.symbols.eos))
                 lexer.next
            SyntaxError(4)
      :else
         trace("pMainPart:IS.isEmpty")
         IS := Items
         IS.isEmpty := true
   pItems:
      out IS: ref Items
      D: ref Decl:OG
      OG: ref ObjectGenerator:Items
      trace("pItems:")
      IS := Items
      trace("pItems:loop")
      Loop: do
         if (lexer.token = lexer.symbols.idf) :then
            switch(lexer.peekNext(1))
               case((lexer.symbols.colon))
                   D := pDecl
                   IS.append(D)
               trace("pItems:before:pObjectGenerator")		   
               OG := pObjectGenerator
               IS.append(OG)
         if (lexer.token = lexer.symbols.semicolon) :then
            lexer.next
            trace("pItems:after:semicolon:next")
            restart(Loop)
   pDecl:
       out D: ref Decl:OG
       sig: ref Signature:args
       OD: ref ObjectGenerator:Items
       ptnKind: var integer
       sig := pSignature
       if (lexer.token = lexer.symbols.colon) :then
          lexer.next       
          switch(lexer.token)
             case(lexer.symbols.constRef)
                 lexer.next
                 D := pDataItem(sig):isConst(true):isValue(false)
             case(lexer.symbols.varRef)
                 trace("pDecl:ref")
                 lexer.next
                 D := pDataItem(sig):isConst(false):isValue(false)
             case(lexer.symbols.constVal)
                 trace("pDecl:val")
                 lexer.next
                 D := pDataItem(sig):isConst(true):isValue(true)
             case(lexer.symbols.varVal)
                 trace("pDecl:var")
                 lexer.next
                 D := pDataItem(sig):isConst(false):isValue(true)
             case(lexer.symbols.doSy)
                 trace("pDecl:doSy")
                 lexer.next
                 D := pLabelDecl(sig)
             -- incomplet - missing virtuals
             ptnKind := plainPtn
             OD := pObjectGenerator
             D := PatternGen(sig):OG(OD):kind(plainPtn)
             --syntaxError(5)
   pDataItem(sigx: ref Signature:args):isConst(isConst: var Boolean):isValue(isValue: var Boolean):
      out D: ref DataItem:isValue:sig:OG
      OG: ref ObjectGenerator:Items
      trace("pDataItem")      
      OG := pSuperDataItem
      D := DataItem(isConst):isValue(isValue):sig(sigx):OG(OG) -- ref args and sub dont work?
      --D.setSigOg(sigx,OG)
   pLabelDecl(sig: ref Signature:args):
      out LD: ref LabelDecl:OG
      OG: ref ObjectGenerator:Items
      trace("pLabelDecl")
      OG := pObjectGenerator
      LD := LabelDecl(sig):OG(OG)
   pExp:
      out E: ref Exp
      symb: ref String
      trace("pExp")
      switch(lexer.token)
         -- missing, const,floatConst,string,charSy
         case((lexer.symbols.const))
            C: ref Const
            C := Const
            C.T := lexer.TokenStr
            E := C	    
            lexer.next
         case(lexer.symbols.idf)
             -- incomplete
             trace("pExp:idf")
             symb:= lexer.tokenStr
             lexer.next
             trace("pExp:idf:next")
             E := OI_Generator(symb,Arguments)	-- should be UnaryGen
         case((lexer.symbols.special))
             symb := lexer.tokenStr
             lexer.next
             E := pBinary(symb)
         trace("pExp:empty")
         E := Exp
   pBinary(op: ref String):
      out B: ref Exp
      args: ref Arguments
      args := Arguments
      args.isBinary := true
      args.append(pObjectGenerator)
      B := BinaryGen(op,args)
   genTokenStream: 
      ind: var integer
      lexer.next
      --"Got: {I2S(lexer.token)} {lexer.tokenStr}\n".print
      switch(lexer.token)
         case(0)
            trace("genTokenStream:eof")
         case(lexer.symbols.begin)
            newline
            ind := ind + 2   
            for(1):to(ind):repeat
               put(' ')         
            put('{')
         case(lexer.symbols.semicolon)
            put(';')
            newline
            for(1):to(ind):repeat
               put(' ')
         case(lexer.symbols.end)
            newline
            for(1):to(ind):repeat
                put(' ')
            put('}')
            ind := ind - 2
            newline
            for(1):to(ind):repeat
               put(' ')
         case(lexer.symbols.charSy)
            put('\'')
            lexer.tokenstr.print
            put('\'')
         case(lexer.symbols.stringSy)
            put('"')
            lexer.tokenStr.print
            put('"')
         case(
           (lexer.symbols.idf,
            lexer.symbols.const,
            lexer.symbols.floatConst,
            lexer.symbols.special,
            lexer.symbols.keyWord,
            lexer.symbols.fatComma))
            lexer.tokenStr.print
         lexer.symbols.asText(lexer.token).print
      put(' ')
      if(lexer.token <> lexer.symbols.eos):then 
         restart(genTokenStream)
   syntaxError(no: var integer):
      "\nsyntax error: ".print
      putint(no)
      newline
   trace(msg: ref String):
      if (false) :then
         msg.print
         put(':')
         putint(lexer.token)
         put(' ' )
         lexer.symbols.asText(lexer.token).print
         put(' ')
         lexer.tokenStr.print
         newline
   go:
      out N: ref Node
      --genTokenStream
      "***parser.go:\n".print      
      lexer.next
      N := pModule
