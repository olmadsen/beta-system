AST: obj compiler_IF.Tree
   %visible compiler_IF
   node: TopNode
      doPT:
            in mk: var Boolean
            out S: ref Text	    
            mark := mk
            lx := Text
            PT(0,false)	    
            mark := false
            S := lx   
      PT::
         mkBreak::
            @if lx.length > 0 :then -- no break or space if first line
                @if break :then
                    lx.newline
                    @for 1 :to pos :repeat
                         lx.put(' ')
                :else
                    inner(mkBreak)
         mkBreak0: mkBreak
                --skip
         mkBreak1: mkBreak
                -- skip
         --lx.put('(')
         --lx.append(I2S(pos))
         --lx.put(')')
         inner(PT)
      length:< 
         out V: var  integer
         V := 100 -- temporary hack!
         inner(length)
      label:<
         out lab: ref String
         inner(label)
      scanSons:
            current: ref Node
            current := son		   
            loop: do
               @if (current =/= none) :then
                  inner(scanSons)
                  current := current.next
                  @restart loop
      inner(Node)
   Decl: Node
      sig: ref Signature
      OG: ref ObjectGenerator
      pt::<
         inner(PT)
      setSigOG:
         in sigx: ref Signature
         in OGx: ref ObjectGenerator
         sig := sigx
         OG := OGx
      inner(Decl)
   SuperDataItem: Decl
      dum: var integer
      inner(SuperDataItem)
   Module: SuperDataItem
      pt::
        sig.PT(pos,break)
        lx.append(": obj ")
        OG.PT(pos,break)
      "Module:".print
      
   DataItem: SuperDataItem
      in isConst: var Boolean
      in isValue: var Boolean
      PT::
         sig.PT(pos,break)
         lx.append(": ")
         lx.append(label)
         lx.put(' ')	 
         OG.PT(pos,break)
      label::
         lab := "???"    
         switch (true)
            case(isValue && isConst)
                 lab := "val"
            case(isValue && isConst.not)
                 lab := "var"
            case(isValue.not && isConst)
                 lab := "obj"
            case(isValue.not && isConst.not)
                 lab := "ref"
      --"\n**** DataItem:new: ".print
      --sig.id.print
      --newline
   Signature: Node
      in id: ref String
      in args: ref Arguments
      PT::
         lx.append(id)
   Arguments: Node
      PT::
         "arguments:".print
   ObjectGenerator: Node
      in super: ref Invocation
      in IS: ref Items
      PT::
         ind: var integer
         @if (lx.length > 0) :then -- || (super.length > 0) :then
             super.PT(pos,break)
             ind := 3              	  
         @if IS.isEmpty.not :then
            mkBreak(pos + ind,true)
            block(pos + ind,100) -- length
               IS.PT(pos,true)
   Invocation: Node
      PT::
         scanSons
            current.PT(pos,break)
      length::
         V := 0
         scanSons
            _put('.')
            V := 100
   Items: Node
      isEmpty: var Boolean
      PT::
         block(pos,100)--, length
            scanSons
                current.pt(pos,break)
                mkBreak(pos,true)		

   Apl: Node
      ATd: ref Decl
      on: var integer
      pn: var integer
   Exp: Apl
      -- not correct
      args: ref Arguments
      
   ObjectInvocation:< Exp
      PT::<
         ptnId.PT(pos,break)
      ptnId : ref Name
   OI_Generator:
      in id: ref String
      in A: ref Arguments
      out OI: ref ObjectInvocation
      OI := ObjectInvocation
      OI.ptnId := Name
      OI.ptnId.T := id
      OI.args := A
      inner(OI_Generator)
   UnaryGen: OI_Generator
      -- 
   Lexem: Exp
      T: ref String
   Name: Lexem
      PT::
         lx.append(T)
	 
   