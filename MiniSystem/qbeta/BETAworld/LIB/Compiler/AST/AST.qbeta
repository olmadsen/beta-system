AST: obj compiler_IF.Tree
   %visible compiler_IF
   node: TopNode
      doPT:
            in mk: var Boolean
            out S: ref Text
            mark := mk
            lx := Text
            PT(0,false)
            mark := false
            S := lx   
      PT::
         mkBreak::
            if (lx.length > 0) :then -- no break or space if first line
                if (break) :then
                    lx.newline
                    for (1) :to (pos) :repeat
                         lx.put(' ')
                :else
                    inner(mkBreak)
         mkBreak0: mkBreak
                --skip
                put('?')
         mkBreak1(pos: var integer):break(break: var Boolean): mkBreak(pos,break)
                -- skip
         --lx.put('(')
         --lx.append(I2S(pos))
         --lx.put(')')
         inner(PT)
      length:< 
         out V: var  integer
         V := 100 -- temporary hack!
         inner(length)
      label:<
         out lab: ref String
         inner(label)
      scanSons:
            current: ref Node
            first: var Boolean
            current := son
            first := true
            loop: do
               if (current =/= none) :then
                  inner(scanSons)
                  current := current.next
                  first := false
                  restart(loop)
      inner(Node)
   Property(propId: ref Name):args(args: ref PropertyArgs):< Node
      -- problem with ,-arg and ref Name!=
      PT::
         lx.append(propId.T)
         lx.put(' ')
         args.PT(pos,break)
      length::
         V := 50
      label::
         lab := "Property"
   PropertyArgs:< node
      PT::
         i: var integer      
         scanSons
             i := i + 1
             if (i > 1) :then
                lx.put(',')
             current.PT(pos,break)
      length::
          V := 50
      label::
          lab := "PropertyArgs"
   Decl(sig: ref Signature:args):OG(OG: ref ObjectGenerator:items): Node
      setSig(s: ref Signature:args):
         sig := s
         inner(#Decl:OG)
   SuperDataItem(sig: ref Signature:args)\
                :OG(OG: ref ObjectGenerator:items): Decl(sig):OG(OG)
      inner(#SuperDataItem:OG)
   Module(sig: ref Signature:args)\
          :OG(OG: ref ObjectGenerator:items): SuperDataItem(sig):OG(OG)
      pt::
        sig.PT(pos,break)
        lx.append(": obj ")
        OG.PT(pos,break)
      "Module:".print
      
   DataItem(isConst: var Boolean):isValue(isValue: var Boolean)\
            :sig(sig: ref Signature:args)\
            :OG(OG: ref ObjectGenerator:items): SuperDataItem(sig):OG(OG)
      PT::
         sig.PT(pos,break)
         lx.append(": ")
         lx.append(label)
         lx.put(' ')
         OG.PT(pos,break)
      label::
         lab := "???"    
         switch (true)
            case(isValue && isConst)
                 lab := "val"
            case(isValue && isConst.not)
                 lab := "var"
            case(isValue.not && isConst)
                 lab := "obj"
            case(isValue.not && isConst.not)
                 lab := "ref"
      --"\n**** DataItem:new: ".print
      --sig.id.print
      --newline
   LabelDecl(sig: ref Signature:args):OG(OG: ref ObjectGenerator:Items): Decl(sig):OG(OG)
      -- if LabelDecl is declared virtual, pLabelDecl fails with no entry in VDT
      PT::
         sig.PT(pos,break)
         lx.append(": do ")
         OG.PT(pos,break)
   plainPtn: val 0
   virtualPtn: val 1
   furtherPtn: val 2
   finalPtn: val 3
   Pattern(sig: ref Signature:args):OG(OG: ref ObjectGenerator:Items):kind(kind: var integer): Decl(sig):OG(OG)
       PT::
          sig.PT(pos,break)
          switch(kind)
              case(plainPtn)
                 lx.append(": ")
              case(virtualPtn)
                 lx.append(":< ")
              case(furtherPtn)
                 lx.append("::< ")
              case(finalPtn)
                 lx.append(":: ")
          OG.PT(pos,break)
   PatternGen(sig: ref Signature:args):OG(OG: ref ObjectGenerator:Items):kind(kind: var integer):
      out ptn: ref Pattern:OG:kind
      ptn:= Pattern(sig):OG(OG):kind(kind)
      
   Signature(id: ref String):args(args: ref Arguments): Node
      PT::<
         lx.append(id)
         if (args =/= none) :then
            args.PT(pos,break)
   Arguments: Node
      PT::
         i: var integer 
         scanSons
            i := i + 1
            putSep(i)
            current.PT(pos,break)
         if (sTop > 0) :then
            lx.append(separators.@get i + 1)
      id: ref String
      isBinary: var Boolean
      separators: obj IndexedRef(25,#Object)
      sTop: var integer
      addSep(S: ref String):
         sTop := sTop + 1
         separators.@put S :at sTop
      putSep(i: var integer):
         S: ref String
         if (i <= sTop) :then 
            S := separators.@get i
            lx.append(S)
   ObjectGenerator(super: ref Invocation):items(IS: ref Items): Node
      PT::
         ind: var integer
         if (lx.length > 0) :then -- || (super.length > 0) :then
             super.PT(pos,break)
             ind := 3
         if (IS.isEmpty.not) :then
            mkBreak(pos + ind,true)
            block(pos + ind,100) -- length
               IS.PT(pos,true)
   Invocation: Node
      PT::
         scanSons
            E: ref Exp
            if(first.not):then
               E := current
               lx.append(E.dot)
            current.PT(pos,break)
      length::
         V := 0
         scanSons
            V := 100
   Items: Node
      isEmpty: var Boolean
      PT::
         block(pos,100)--, length
            scanSons
                current.pt(pos,break)
                mkBreak(pos,true)

   Apl: Node
      ATd: ref Decl:OG
      on: var integer
      pn: var integer
   Exp: Apl
      -- not correct
      dot:<
         out T: ref string
         T := "."
         inner(dot)
      args: ref Arguments
      
   ObjectInvocation:< Exp
      PT::<
         if (type =/= none) :then
            type.PT(pos,break)
         :else
            "type is none\n".print
            ptnId.PT(pos,break)
      dot::
         if (type =/= none) :then
            T := type.dot
      ptnId : ref Name
      type: ref InvType
      InvType: Node
         dot:<
            out T: ref String
            T := "."
            inner(dot)
      Unary: InvType
         PT::
            ptnId.PT(pos,break)
            args.PT(pos,break)
      Binary: InvType
         PT::
            ptnId.PT(pos,break)
            lx.put(' ')
            args.PT(pos,break)
            lx.put(' ')
         label::
            lab := "ObjectInvocation_Binary"
         dot::
             T := ""
      KeyWord: InvType
         PT::
            ptnId.PT(pos,break)
            args.PT(pos,break)
         label::
            lab := "ObjectInvocation_Keyword"
         dot::
            T := ""
   OI_Generator:
      in id: ref String
      in A: ref Arguments
      out OI: ref ObjectInvocation
      OI := ObjectInvocation
      OI.ptnId := Name(id)
      --OI.ptnId.T := id
      OI.args := A
      inner(OI_Generator)
   UnaryGen: OI_Generator
      OI.type := OI.Unary
   KeyWordGen: OI_Generator
      OI.type := OI.Keyword
   BinaryGen: OI_Generator
      OI.type := OI.Binary
   Lexem: Exp
      in T: ref String
   Name: Lexem
      PT::
         lx.append(T)
   Const: Lexem
       PT::
          lx.append(T)
   StringSy: Lexem
       PT::
          lx.put('"')       
          lx.append(T)
          lx.put('"')
