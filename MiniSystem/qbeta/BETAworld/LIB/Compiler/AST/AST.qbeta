AST: obj compiler_IF.Tree
   %visible compiler_IF
   Item: TopNode
      doPT:
            in mk: var Boolean
            out S: ref Text
            mark := mk
            lx := Text
            PT(0,false)
            mark := false
            S := lx   
      PT::
         mkBreak::
            if (lx.length > 0) :then -- no break or space if first line
                if (break) :then
                    lx.newline
                    for (1) :to (pos) :repeat
                        lx.put(' ')
                :else
                    inner(mkBreak)
         mkBreak0: mkBreak
            --skip
            put('?')
         mkBreak1(pos: var integer):break(break: var Boolean): mkBreak(pos,break)
            -- skip
         --lx.put('(')
         --lx.append(I2S(pos))
         --lx.put(')')
         inner(PT)
      length:< 
         out V: var  integer
         V := 100 -- temporary hack!
         inner(length)
      label:<
         out lab: ref String
         lab := "!?"
         inner(label)
      scanSons:
            current: ref Item
            first: var Boolean
            last: var Boolean
            current := son
            first := true
            loop: do
               if (current =/= none) :then
                  last := current.next == none
                  inner(scanSons)
                  current := current.next
                  first := false
                  restart(loop)
      noOfSons:
         out V: var integer
         scanSons
            V := V + 1
      isObjectInvocation:<
         out V: var Boolean
         inner(isObjectInvocation)
      inner(Item)
   Property(propId: ref Name):args(args: ref PropertyArgs):< Item
      -- problem with ,-arg and ref Name!=
      PT::
         lx.append(propId.T)
         lx.put(' ')
         args.PT(pos,break)
      length::
         V := 50
      label::
         lab := "Property"
   PropertyArgs:< Item
      PT::
         i: var integer      
         scanSons
             i := i + 1
             if (i > 1) :then
                lx.put(',')
             current.PT(pos,break)
      length::
          V := 50
      label::
          lab := "PropertyArgs"
   Decl(sig: ref Signature:args):OG(OG: ref ObjectGenerator:items): Item
      setSig(s: ref Signature:args):
         sig := s
         inner(#Decl:OG)
   SuperDataItem(sig: ref Signature:args)\
                :OG(OG: ref ObjectGenerator:items): Decl(sig):OG(OG)
      inner(#SuperDataItem:OG)
   Module(sig: ref Signature:args)\
          :OG(OG: ref ObjectGenerator:items): SuperDataItem(sig):OG(OG)
      pt::
        sig.PT(pos,break)
        lx.append(": obj ")
        OG.PT(pos,break)
      label::
         lab := "Module"      
      "Module:".print
      
      
   DataItem(isConst: var Boolean):isValue(isValue: var Boolean)\
            :sig(sig: ref Signature:args)\
            :OG(OG: ref ObjectGenerator:items): SuperDataItem(sig):OG(OG)
      PT::
         sig.PT(pos,break)
         lx.append(": ")
         lx.append(label)
         lx.put(' ')
         OG.PT(pos,break)
      label::
         lab := "???"    
         switch (true)
            case(isValue && isConst)
                 lab := "val"
            case(isValue && isConst.not)
                 lab := "var"
            case(isValue.not && isConst)
                 lab := "obj"
            case(isValue.not && isConst.not)
                 lab := "ref"
      --"\n**** DataItem:new: ".print
      --sig.id.print
      --newline
   LabelDecl(sig: ref Signature:args):OG(OG: ref ObjectGenerator:Items): Decl(sig):OG(OG)
      -- if LabelDecl is declared virtual, pLabelDecl fails with no entry in VDT
      PT::
         sig.PT(pos,break)
         lx.append(": do ")
         OG.PT(pos,break)
      label::
           lab := "do"       
   plainPtn: val 0
   virtualPtn: val 1
   furtherPtn: val 2
   finalPtn: val 3
   Pattern(sig: ref Signature:args):OG(OG: ref ObjectGenerator:Items):kind(kind: var integer): Decl(sig):OG(OG)
       PT::
          sig.PT(pos,break)
          switch(kind)
              case(plainPtn)
                 lx.append(": ")
              case(virtualPtn)
                 lx.append(":< ")
              case(furtherPtn)
                 lx.append("::< ")
              case(finalPtn)
                 lx.append(":: ")
          OG.PT(pos,break)
       label::
          lab := "Pattern"
   PatternGen(sig: ref Signature:args):OG(OG: ref ObjectGenerator:Items):kind(kind: var integer):
      out ptn: ref Pattern:OG:kind
      ptn:= Pattern(sig):OG(OG):kind(kind)
      
   Signature(id: ref String):args(args: ref Arguments): Item
      PT::<
         lx.append(id)
         if (args =/= none) :then
            args.PT(pos,break)
      label::
         lab := id      
   Arguments: Item
      PT::
         i: var integer
         scanSons
            ch: ref String
            i := i + 1
            putSep(i)
            ch := separators.get[i]
            --lx.append(current.label)
            if (ch =/= none ) :then
               if (ch =  "(") :then
                    put(':')
                    current.PT(pos,false)
               :else
                    current.PT(pos,break)	       
            :else
               current.PT(pos,break)
         if (sTop > 0) :then
            if (separators.get[i + 1] =/= none) :then
               lx.append(separators.get[i + 1])
            :else
               lx.append("?\}?")
      label::
          lab := "Arguments"
      id: ref String
      isBinary: var Boolean
      inBraces:
         out V: var Boolean
         S: ref String
         Sx: ref String	 
         if (sTop > 0) :then
            S := separators.get[sTop]
            Sx := "\}"
            V := S = "\}"
            --V := (S.get[S.length]) = "} " -- BUM BUM!    
      separators: obj IndexedRef(25,#Object)
      sTop: var integer
      addSep(S: ref String):
         sTop := sTop + 1
         separators.put(S):at[sTop]
      putSep(i: var integer):
         S: ref String
         if (i <= sTop) :then 
            S := separators.get[i]
            lx.append(S)
   ObjectGenerator(super: ref Invocation):items(IS: ref Items): Item
      PT::
         ind: var integer
         if (lx.length > 0) :then -- || (super.length > 0) :then
             super.PT(pos,break)
             ind := 3
         if (IS.isEmpty.not) :then
            mkBreak(pos + ind,true)
            block(pos + ind,100) -- length
               IS.PT(pos,true)
      label ::
         lab :=  "ObjectGenerator"       
   Invocation: Item
      PT::
         scanSons
            E: ref Exp
            if(first.not):then
               E := current
               lx.append(E.dot)
            current.PT(pos,break)
      label::
         lab :=  "Invocation"      
      length::
         V := 0
         scanSons
            V := 100
      isEmpty: var Boolean
   Invocations: Exp
      PT::
         scanSons
            E: ref Exp
            if(first.not):then
               E := current
               lx.append(E.dot)
            current.PT(pos,break)
      label::
         lab :=  "Invocations"      
      length::
         V := 0
         scanSons
            V := 100
	 
   Items: Item
      isEmpty: var Boolean
      PT::
         block(pos,100)--, length
            scanSons
                current.pt(pos,break)
                mkBreak(pos,true)
      label::
         lab := "Items"
   Assignment: Item
      PT::
         scanSons
            if (first.not) :then
               lx.append(" := ")
            current.PT(pos,break)
      label::
         lab := "Assignment"
   Apl: Item
      ATd: ref Decl:OG
      on: var integer
      pn: var integer
   Exp: Apl
      -- not correct
      dot:<
         out T: ref string
         T := "."
         inner(dot)
      args: ref Arguments
      isEmpty: var Boolean
   BinaryExp(left: ref Exp,symb: var String,right: ref Exp): Exp
      PT::
         left.PT(pos,break)
         lx.put(' ')
         lx.append(symb)
         lx.put(' ')
         right.PT(pos,break)
      label::
         lab := "BinaryExp"
   BracketedExp: Exp
      PT::
          lx.put('(')
          scanSons
             current.PT(pos,break)
             if (! last) :then
                lx.put(',')
          lx.put(')')
      label::
         lab := "BracketedExp"
   ObjectInvocation:< Exp
      PT::<
         if (type =/= none) :then
            type.PT(pos,break)
         :else
            "type is none\n".print
            ptnId.PT(pos,break)
      label::
         lab := "ObjectInvocation"      
      dot::
         if (type =/= none) :then
            T := type.dot
      ptnId : ref Name
      type: ref InvType
      InvType: Item
         dot:<
            out T: ref String
            T := "."
            inner(dot)
      Unary: InvType
         PT::
            ptnId.PT(pos,break)
            args.PT(pos,break)
         label::
            lab := "Unnary"	 
      Binary: InvType
         PT::
            lx.put(' ')
            ptnId.PT(pos,break)
            lx.put(' ')
            args.PT(pos,break)
            lx.put(' ')
         label::
            lab := "ObjectInvocation_Binary"
         dot::
             T := ""
      KeyWord: InvType
         PT::
            ptnId.PT(pos,break)
            args.PT(pos,break)
         label::
            lab := "ObjectInvocation_Keyword"
         dot::
            T := ""
      isObjectInvocation::
         V := True      
   OI_Generator:
      in id: ref String
      in A: ref Arguments
      out OI: ref ObjectInvocation
      OI := ObjectInvocation
      OI.ptnId := Name(id)
      --OI.ptnId.T := id
      OI.args := A
      inner(OI_Generator)
   UnaryGen: OI_Generator
      OI.type := OI.Unary
   KeyWordGen: OI_Generator
      OI.type := OI.Keyword
   BinaryGen: OI_Generator
      OI.type := OI.Binary
   Lexem: Exp
      in T: ref String
   Name: Lexem
      PT::
         lx.append(T)
      length::
         V := T.length
      label::
         lab := "Name:"  
   Const: Lexem
       PT::
          lx.append(T)
       length::
          V := T.length
       label::
          lab := "const:"  
   FloatConst:< Lexem
      PT::
         lx.append(T)
      length::
         V := T.length
      label::
         lab := "FloatLiteral:"      
   StringSy: Lexem
       PT::
          lx.put('"')       
          lx.append(T)
          lx.put('"')
       length::
          V := T.length
       label::
          lab := "String:"  
