AST: obj compiler_IF.Tree
   %visible compiler_IF
   node: TopNode
      doPT:
            in mk: var Boolean
            out S: ref Text	    
            mark := mk
            lx := Text
            PT(0,false)	    
            mark := false
            S := lx   
      PT::
         mkBreak::
            @if lx.length > 0 :then -- no break or space if first line
                @if break :then
                    lx.newline
                    @for 1 :to pos :repeat
                         lx.put(' ')
                :else
                    inner(mkBreak)
         mkBreak0: mkBreak
                --skip
                put('?')		
         mkBreak1(pos: var integer):break(break: var Boolean): mkBreak(pos,break)
                -- skip
         --lx.put('(')
         --lx.append(I2S(pos))
         --lx.put(')')
         inner(PT)
      length:< 
         out V: var  integer
         V := 100 -- temporary hack!
         inner(length)
      label:<
         out lab: ref String
         inner(label)
      scanSons:
            current: ref Node
            current := son		   
            loop: do
               @if (current =/= none) :then
                  inner(scanSons)
                  current := current.next
                  @restart loop
      inner(Node)
   Decl(sig: ref Signature:args):OG(OG: ref ObjectGenerator:items): Node
      setSig(s: ref Signature:args):
         sig := s
         inner(#Decl:OG)
   SuperDataItem(sig: ref Signature:args)\
                :OG(OG: ref ObjectGenerator:items): Decl(sig):OG(OG)
      inner(#SuperDataItem:OG)
   Module(sig: ref Signature:args)\
          :OG(OG: ref ObjectGenerator:items): SuperDataItem(sig):OG(OG)
      pt::
        sig.PT(pos,break)
        lx.append(": obj ")
        OG.PT(pos,break)
      "Module:".print
      
   DataItem(isConst: var Boolean):isValue(isValue: var Boolean)\
            :sig(sig: ref Signature:args):OG(OG: ref ObjectGenerator:items): SuperDataItem(sig):OG(OG)
      PT::
         sig.PT(pos,break)
         lx.append(": ")
         lx.append(label)
         lx.put(' ')	 
         OG.PT(pos,break)
      label::
         lab := "???"    
         switch (true)
            case(isValue && isConst)
                 lab := "val"
            case(isValue && isConst.not)
                 lab := "var"
            case(isValue.not && isConst)
                 lab := "obj"
            case(isValue.not && isConst.not)
                 lab := "ref"
      --"\n**** DataItem:new: ".print
      --sig.id.print
      --newline       
   Signature(id: ref String):args(args: ref Arguments): Node
      PT::<
         lx.append(id)
   Arguments: Node
      PT::
         "arguments:".print
   ObjectGenerator(super: ref Invocation):items(IS: ref Items): Node
      PT::
         ind: var integer
         @if (lx.length > 0) :then -- || (super.length > 0) :then
             super.PT(pos,break)
             ind := 3              	  
         @if IS.isEmpty.not :then
            mkBreak(pos + ind,true)
            block(pos + ind,100) -- length
               IS.PT(pos,true)
   Invocation: Node
      PT::
         scanSons
            current.PT(pos,break)
      length::
         V := 0
         scanSons
            _put('.')
            V := 100
   Items: Node
      isEmpty: var Boolean
      PT::
         block(pos,100)--, length
            scanSons
                current.pt(pos,break)
                mkBreak(pos,true)		

   Apl: Node
      ATd: ref Decl:OG
      on: var integer
      pn: var integer
   Exp: Apl
      -- not correct
      args: ref Arguments
      
   ObjectInvocation:< Exp
      PT::<
         ptnId.PT(pos,break)
      ptnId : ref Name
   OI_Generator:
      in id: ref String
      in A: ref Arguments
      out OI: ref ObjectInvocation
      OI := ObjectInvocation
      OI.ptnId := Name
      OI.ptnId.T := id
      OI.args := A
      inner(OI_Generator)
   UnaryGen: OI_Generator
      put('!')
   Lexem: Exp
      T: ref String
   Name: Lexem
      PT::
         lx.append(T)
