BasicSystem: obj
   %module Collections, LIB.StringLib,LIB.Collections.QueueLib
   %include Collections,LIB.StringLib
   %public
   Lock: 
      %globals
      %Public
      in id: ref String
      %private
      free_M: var integer
      init: 
         free_M := 0
      get: 
         loop: obj
            res: var integer
            i: var integer
            --disable
            res := free_M.cmpAndSwap(1)
            if (res = 1) :then 
               --enable
               --sleep(50)
               i := i + 1
               if (i > 10000) :then 
                  (id + " not free after 10000 attempts").print
                  i := 0
               restart(loop)
      free:
         free_M := 0

   BasicSystem:
      %public
      BasicProcess: GeneralProcess
         mkActive::<
            -- start and mkActive are identical and one may be eliminated
            status := p_status.ACTIVE
            SQS.insert(this(BasicProcess))
         %Public      
         start::<  -- need id as argument
            status := p_status.ACTIVE
            SQS.insert(this(BasicProcess))
            inner(start)
         isTerminated -> B: var Boolean:
            B := status = P_status.TERMINATED
         addWaiting::<
            --SQS.addWaiting
            status := P_status.WAITING
         dcrWaiting::<
            SQS.dcrWaiting
         display::<
             "\n---BP:---\n".print	 
         --(id + ":A:").print	 
         this(BasicProcess).suspend
         --(id + ":B:").print	 	 
         inner(BasicProcess)
         status := P_status.TERMINATED
      Scheduler: SuperScheduler
         thisScheduler::< Scheduler
         ProcessType::< BasicProcess
         %Public
         --active: ref BasicProcess
         %Private	 
         dummyB: var Boolean
         inScheduler: var Boolean
         P: ref BasicProcess
         (this(Scheduler)).suspend
         sch.add
         loop: do 
               inScheduler := 1
               active := SQS.removeNext
               if (active =/= none) :then 
                  active.status := P_status.ACTIVE
                  inScheduler := 0
                  active.attach(50)
                  inScheduler := 1
                  if (active.status = P_status.ACTIVE) :then
                     SQS.insert(active)
               if (SQS.isEmpty) :then
                  if (SQS.hasWaiting) :then
                     sleep(100)
                     restart(Loop)
                  sch.dcr
                  if (sch.running) :then
                     sleep(50)
                     sch.add
                     restart(loop)
               :else
                  restart(Loop)
      Core: SuperCore
         -- should be moved to BETA,
         -- but depends on Scheduler
         -- could perhaps just be Object?
         -- but for thisCore.main.active, active is defined in Scheduler
         -- perhaps a super scheduler should be defined in BETA.xbeta
         -- main: ref BasicProces, thus also BasicProcess in BETA
         -- or perhaps thisCore here?
         --%core 16
         %Public
         --main: ref Scheduler
         attach: 
            in M: ref Scheduler
            main := M
         %Private
         dummy: var integer
         go: 
            loopX: obj 
               if (main =/= none) :then 
                  main.call 
               :else 
                  sleep(100)
                  restart(loopX)
         (this(Core)).suspend
         --main:= none         
         dummy := 213
         go
      noOfCores: val 4
      cores: obj 
         C1: ref Core
         C2: ref Core
         C3: ref Core
         C4: ref Core
         -- should be array         
         init: 
            S: ref Scheduler
            C1 := Core
            fork(C1)
            C2 := Core
            fork(C2)
            C3 := Core
            fork(C3)
            C4 := Core
            fork(C4)
            S := Scheduler
            C1.attach(S)
            S := Scheduler
            C2.attach(S)
            S := Scheduler
            C3.attach(S)
            C4.attach(Scheduler)
      P_status: obj 
         %globals
         %Public	 
         ACTIVE: val 1
         WAITING: val 2
         TERMINATED: val 3
      ProcessQueue: LIB.Collections.QueueLib.Queue
         --%globals
         %Public
         displayx: 
            put('Q')
      sch: obj 
         L: obj Lock("Sch:lock")
         M: var integer
         %Public	 
         entry: 
            L.get
            inner(entry)
            L.free
         add: 
            entry
               M := M + 1
         dcr: 
            entry
               M := M - 1
         running: 
            out B: var Boolean
            entry
               B := M > 0
      SQS: obj 
         Q: obj ProcessQueue
         L: obj Lock("SQS:Lock:")
         V: var integer
         W: var integer
         %Public	 
         entry: 
            L.get
            V := V + 1
            if (V > 1) :then 
               put('V')
            inner(entry)
            V := V - 1
            L.free
         init: entry
            V := 1
            L.init
            L.id := "SQS"
            Q.idf := "SQS:"	    
         insert: entry
            in P: ref BasicProcess
            if (Q.has(P).not) :then
               Q.insert(P)
         removeNext: 
            out P: ref BasicProcess
            entry
               P := Q.removeNext
         remove: entry
            in P: ref BasicProcess
            Q.remove(P)
         isEmpty: 
            out B: var Boolean
            entry
               B := Q.isEmpty
         display: entry
            Q.display
         addWaiting: entry
            W := W + 1
         dcrWaiting: entry
            W := W - 1
         hasWaiting: 
            out B: var boolean
            entry
               B := W > 0
      coreLock: obj Lock("CoreLock")
      console: obj
         L: obj Lock("Console:lock")
         %public
         display: 
            L.get
            inner(display)
            L.free
         L.init
      keyboard: obj BasicProcess("Keyboard")
         B: obj Indexed(100,integer)
         next: var integer
         top: var integer
         echo: var Boolean
         %Public
         Kscan: 
            loopB: obj 
               if (_kbhit) :then 
                  top := top + 1
                  B.put(_iget):at[top]
               keyboard.suspend
               restart(loopB)
         get: 
            in caller: ref BasicProcess
            out ch: var char
            waitForChar: obj 
               if (next < top) :then 
                  next := next + 1
                  ch := B.get[next] 
               :else 
                  caller.suspend
                  restart(waitForChar)
         Kscan
      init: 
         SQS.init
      init
      inner(BasicSystem)
      cores.init
      