BasicSystem: =
   %include Containers, LIB.String
   BasicSystem:
       Lock:
           dummy: ?integer
           M: ?integer
           init:
              M := 0
           get: 
              res: ?integer
              loop: =
                  disable
                  res := 17
                  res := M.cmpAndSwap(1)
                  %if res = 1 %then%
                      enable
                      sleep(50)
                      %restart loop
           free:
               M := 0
               enable
       BasicProcess(id: ?String):
           status: ?integer
           start:< -- need id as argument
                status := p_status.ACTIVE
                inner
           (%this BasicProcess).suspend
           inner
           status := P_status.TERMINATED
       Scheduler: 
           active: ?BasicProcess
           inScheduler: ? Boolean
           P: ?BasicProcess
           do:
            loop: =
              inScheduler := 1
              active := SQS.removeNext
              %if active <> none %then%
                  active.status := P_status.ACTIVE
                  inScheduler := 0
                  active.attach(50)
                  inScheduler := 1
                  %if active.status = P_status.ACTIVE %then%
                      SQS.insert(active)
              %if SQS.isEmpty %then%
                  %if SQS.hasWaiting %then%
                      sleep(100)
                      %restart Loop
                  sch.dcr
                  %if sch.running %then%
                      sleep(50)
                      sch.add
                      %restart loop                     
              %else% 
                    %restart Loop
           (%this Scheduler).suspend
           sch.add
           do
       Core:
           [core[16]]
           main: ?Scheduler
           attach(M: ?Scheduler):
               main := M
           do: 
              loopX: =
                 %if main <> none %then%
                     main.resume 
                 %else%
                     sleep(100)
                     %restart loopX 
           (%this Core).suspend          
           do
       noOfCores: = 4
       cores: =
           C1: ?Core
           C2: ?Core
           C3: ?Core
           C4: ?Core
           -- should be array
           init:
               S: ?Scheduler
               C1 := Core
               fork(C1)
               C2 := Core
               fork(C2)
               C3 := Core
               fork(C3)
               C4 := Core
               fork(C4)
               S := Scheduler
               C1.attach(S)
               S := Scheduler
               C2.attach(S)
               S := Scheduler
               C3.attach(S)
               C4.attach(Scheduler)

       P_status: =
           ACTIVE: = 1
           WAITING: = 2
           TERMINATED: = 3
       ProcessQueue: LIB.Containers.mQueue.Queue
           display:
               put('Q')
       sch: =
           L : =Lock
           M: ?integer
           entry:
              L.get
              %inner entry
              L.free
           add:
              entry
                 M := M + 1
           dcr: 
              entry
                 M := M - 1
           running -> B: ?Boolean:
              entry
                 B := M > 0
       SQS: =
           Q: =ProcessQueue
           L: =Lock
           V: ?integer
           W: ?integer
           entry:
               L.get 
               V := V + 1
               %if V > 1 %then%
                     put('V')
               inner
               V := V - 1
               L.free
           init: entry
               V := 0
           insert(P: ?BasicProcess): entry
               Q.insert(P)
           removeNext -> P: ?BasicProcess: 
               entry
                  P := Q.removeNext
           remove(P: ?BasicProcess): entry
               Q.remove(P)
           isEmpty -> B: ?Boolean: 
               entry
                  B := Q.isEmpty
           display: entry
               Q.display
           addWaiting: entry
               W := W + 1
           dcrWaiting: entry
               W := W - 1
           hasWaiting -> B: ?boolean:
               entry
                  B := W > 0
       coreLock: = Lock
       console: =
          L: = Lock
          V: ?integer
          init:
             L.get
             L.init
             L.free
          display:
              L.get
              inner
              L.free
       keyBoardP:  BasicProcess
          B: = Indexed(100,integer)
          next: ?integer
          top: ?integer
          echo: ? Boolean
          Kscan:
             loopB: =
                %if _kbhit %then%
                    top := top + 1
                    B.%put _iget %at% top
                (%this keyBoardP).suspend
                %restart loopB
          get(caller: ?BasicProcess) -> ch: ?char:
               waitForChar: =  
                  %if next  < top %then%
                      next := next + 1
                      ch := B.%get next
                  %else%
                      caller.suspend
                      %restart waitForChar
          "\nIObuffer started\n".print
          Kscan
       --keyBoard: = keyBoardP
       init:  
          SQS.init
       init
       inner
       cores.init

