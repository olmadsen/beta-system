BasicSystem: obj
   %module Containers, LIB.StringLib,LIB.containers.QueueLib
   %include Containers,LIB.StringLib
   %public
   BasicSystem: 
      %public
      Lock: 
         %globals
         dummy: var integer
         bbb: var integer
         free_M: var integer
         %Public	 
         id: ref String
         init: 
            free_M := 0
         get: 
            res: var integer
            i: var integer
            loop: obj 
               --disable
               res := 17
               res := free_M.cmpAndSwap(1)
               @if res = 1 :then 
                  --enable
                  --sleep(50)
                  i := i + 1
                  @if i > 10000 :then 
                     id.print
                     i := 0
                  @restart loop
         free: 
            free_M := 0
         id := "Lock"
      BasicProcess:
         %Public      
         in id: ref String
         status: var integer
         start:<  -- need id as argument
            status := p_status.ACTIVE
            inner(start)
         (this(BasicProcess)).suspend
         inner(BasicProcess)
         status := P_status.TERMINATED
      Scheduler: 
         %Public
         active: ref BasicProcess
         %Private	 
         dummyB: var Boolean
         inScheduler: var Boolean
         P: ref BasicProcess
         go: 
            loop: obj 
               inScheduler := 1
               active := SQS.removeNext
               @if active =/= none :then 
                  active.status := P_status.ACTIVE
                  inScheduler := 0
                  active.attach(50)
                  inScheduler := 1
                  @if active.status = P_status.ACTIVE :then 
                     SQS.insert(active)
               @if SQS.isEmpty :then 
                  @if SQS.hasWaiting :then 
                     sleep(100)
                     @restart Loop
                  sch.dcr
                  @if sch.running :then 
                     sleep(50)
                     sch.add
                     @restart loop 
               :else 
                  @restart Loop
         (this(Scheduler)).suspend
         sch.add
         go
      thisCore:
         -- BasicSystem:: Core should be mved to here!
         %basic 17
         out C: ref core
         C := core
      Core:
         -- should be moved to BETA,
         -- but depends on Scheduler
         -- could perhaps just be Object?
         -- but for thisCore.main.active, active is defined in Scheduler
         -- perhaps a super scheduler should be defined in BETA.xbeta
         -- main: ref BasicProces, thus also BasicProcess in BETA
         -- or perhaps thisCore here?
         %core 16
         %Public
         main: ref Scheduler
         attach: 
            in M: ref Scheduler
            main := M
         %Private
         dummy: var integer
         go: 
            loopX: obj 
               @if main =/= none :then 
                  main.call 
               :else 
                  sleep(100)
                  @restart loopX
         (this(Core)).suspend
         --main:= none
         
         dummy := 213
         go
      noOfCores: val 4
      cores: obj 
         C1: ref Core
         C2: ref Core
         C3: ref Core
         C4: ref Core
         -- should be array
         
         init: 
            S: ref Scheduler
            C1 := Core
            fork(C1)
            C2 := Core
            fork(C2)
            C3 := Core
            fork(C3)
            C4 := Core
            fork(C4)
            S := Scheduler
            C1.attach(S)
            S := Scheduler
            C2.attach(S)
            S := Scheduler
            C3.attach(S)
            C4.attach(Scheduler)
      P_status: obj 
         %globals
         %Public	 
         ACTIVE: val 1
         WAITING: val 2
         TERMINATED: val 3
      ProcessQueue: LIB.Containers.QueueLib.Queue
         --%globals
         %Public
         displayx: 
            put('Q')
      sch: obj 
         L: obj Lock
         M: var integer
         %Public	 
         entry: 
            L.get
            inner(entry)
            L.free
         add: 
            entry
               M := M + 1
         dcr: 
            entry
               M := M - 1
         running: 
            out B: var Boolean
            entry
               B := M > 0
      SQS: obj 
         Q: obj ProcessQueue
         L: obj Lock
         V: var integer
         W: var integer
         %Public	 
         entry: 
            L.get
            V := V + 1
            @if V > 1 :then 
               put('V')
            inner(entry)
            V := V - 1
            L.free
         init: entry
            V := 1
            L.init
            L.id := "SQS"
         insert: entry
            in P: ref BasicProcess
            Q.insert(P)
         removeNext: 
            out P: ref BasicProcess
            entry
               P := Q.removeNext
         remove: entry
            in P: ref BasicProcess
            Q.remove(P)
         isEmpty: 
            out B: var Boolean
            entry
               B := Q.isEmpty
         display: entry
            Q.display
         addWaiting: entry
            W := W + 1
         dcrWaiting: entry
            W := W - 1
         hasWaiting: 
            out B: var boolean
            entry
               B := W > 0
      coreLock: obj Lock
      console: obj
         L: obj Lock
         %public
         display: 
            L.get
            inner(display)
            L.free
         L.init
      keyboard: obj BasicProcess("Keyboard")
         B: obj Indexed(100,integer)
         next: var integer
         top: var integer
         echo: var Boolean
         %Public	 
         Kscan: 
            loopB: obj 
               @if _kbhit :then 
                  top := top + 1
                  B.@put _iget :at top
               keyboard.suspend
               @restart loopB
         get: 
            in caller: ref BasicProcess
            out ch: var char
            waitForChar: obj 
               @if next < top :then 
                  next := next + 1
                  ch := B.@get next 
               :else 
                  caller.suspend
                  @restart waitForChar
         Kscan
      init: 
         SQS.init
      init
      inner(BasicSystem)
      cores.init
      "end-BasicSystem\n".print
      