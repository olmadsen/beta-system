SemaphoreLib: obj 
   -- Issues when setting status to WAITING in wait;
   -- preemptive suspend may happen before cooperative suspend after addWaiting
   -- we need to consider if this can be a problem!?
   -- if addWaiting and dcrWaiting are calling SQS.addWaiting/dcrWaiting,
   -- the code does not work!
   -- if no setting status = WAITING, the same process is inserted into SQS
   -- more than once - a test for that is made in SQS.insert.
   -- This may imply that a terminated object is executed from the beginning
   %visible QBETA
   Semaphore(cnt: var integer):
      -- Implementation of a counting semaphores
      -- cnt is the initial value of the semaphore
      -- requires: cnt > 0
      %globals
      M: obj Lock("M:Lock")
      Q: obj LIB.Containers.QueueLib.Queue
      %public
      wait: 
         theActive: ref GeneralProcess
         M.get
         cnt := cnt - 1
         if (cnt < 0) :then
            disable
            theActive := thisCore.main.active
            Q.insert(theActive)
            enable
            M.free
            theActive.addWaiting -- sets status = WAITING
            theActive.suspend
         :else
            M.free
      signal: 
         P: ref GeneralProcess
         M.get
         cnt := cnt + 1
         if (cnt <= 0) :then 
            disable
            P := Q.removeNext
            P.mkActive
            --P.dcrWaiting -- SQS.dcrWaiting
            enable
            M.free 
         :else
            M.free
      Q.idf := "Sem:"

