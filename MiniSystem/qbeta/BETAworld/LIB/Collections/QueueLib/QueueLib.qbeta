QueueLib: obj
   -- defines a first-in first-out queue
   %Public
   Queue: 
      %globals
      idf: ref LIB.StringLib.String
      idc: var integer
      noOfElm: var integer
      Element: 
         in elm: ref Object
         out res: ref Element
         id: var integer
         pred: ref Element
         succ: ref Element
         res := this(Element)
         idc := idc + 1
         id := idc
      head: ref Element
      last: ref Element
      %Public
      has:
         in elm: ref Object
         out B: var Boolean	 
         scan
            if (elm == current) :then
               --"Queue:has:elm\n".print
               B := true
               leave(has)
      scan:
         %Public      
         current: ref Object
         currentElement: ref Element
         currentElement := head
         loop: 
               if (currentElement =/= none) :then
                  current := currentElement.elm
                  inner(scan)
                  currentElement := currentElement.succ
                  restart(loop)
         loop
      scanFromLast:
         %Public            
         current: ref Object
         currentElement: ref Element
         currentElement := last
         go: 
            loop: obj 
               if (currentElement =/= none) :then 
                  current := currentElement.elm
                  inner(scanFromLast)
                  currentElement := currentElement.pred
                  restart(loop)
         go
      insert: 
         in elm: ref Object
         E: ref Element
         b: var BOOLEAN
         B := ELM =/= NONE
         --if (has(elm)) :then
         --    "insert:leave\n".print
         --    @leave insert
         if (B) :then
            E := Element(elm)
            noOfElm:= noOfElm + 1	    
            if (head == none) :then
               head := E
               last := head 
            :else 
               E.succ := head
               head.pred := E
               head := E
         --"insert:".print
         --idf.print
         --putint(noOfElm)
         --newline	 
      remove: 
         in elm: ref Object
         scan
            if (elm == current) :then
               noOfElm := noOfElm - 1	    
               if (currentElement.pred =/= none) :then 
                  currentElement.pred.succ := currentElement.succ
                  if (currentElement.succ =/= none) :then 
                     currentElement.succ.pred := currentElement.pred 
                  :else 
                     last := currentElement.pred 
               :else 
                  head := currentElement.succ
                  if (head =/= none) :then 
                     head.pred := none 
                  :else 
                     last := none
      removeNext:
         -- return last element in queue and remove it for queue      
         out elm: ref Object
         if (last =/= none) :then
            noOfElm := noOfElm - 1	    	 
            elm := last.elm
            last := last.pred
            if (last =/= none) :then 
               last.succ := none 
            :else 
               head := none
         --"removeNext:".print
         --idf.print
         --putint(noOfElm)
         --newline	 
      isEmpty: 
         out B: var Boolean
         B := head == none
      clear: 
         head := none
         last := none
      display:
            newline      
            if (head =/= none) :then
                ("head: " + stringLib.I2S(head.id) + ":").print
            if (last =/= none) :then
                ("last: " + stringLib.I2S(last.id) + ":").print
            "members:".print		
            scan
               putint(currentElement.id)
               put(',')
            newline