SimpleConcurrentProcesses: obj 
   %requires LIB.BasicSystem,LIB.Collections.QueueLib
   %Public
   System: LIB.BasicSystem.BasicSystem
      %Public
      Process: Basicprocess
         %globals #Process,immutable,SQS,console
         %interface entry	 
         %Public   
         start:: 
            SQS.insert(this(Process))
            inner(start)
         Q: obj LIB.Collections.QueueLib.Queue
         L: obj LIB.BasicSystem.Lock("L:lock")
         isStopping: var Boolean
         entry: 
            %arguments immutable,unique
            L.get
            Q.insert(this(entry))
            L.free
            (this(entry)).suspend
            inner(entry)
         pendingMethods: 
            out res: var Boolean
            res := Q.isEmpty.not
         exeNext: 
            E: ref entry
            Loop: obj 
               L.get
               if (Q.isEmpty) :then 
                  L.free
                  (this(Process)).suspend
                  if (isStopping = false) :then
                     sleep(100)		     
                     restart(Loop)
                  :else 
                     leave(Loop)
               E := Q.removeNext
               L.free
               E.call
               restart(loop)
         stop:< entry
            if (isStopping = false) :then 
               inner(stop)
               isStopping := true
         inner(Process)
         exeNext
         --console.display
         --   "Exit:".print	 
         --   id.print
         --   newline
      inner(System)