StringLib: obj
   %id "String module"
   %module LIB
   %public
   String: Value
      %id "String pattern"   
      %OSDvisibility disguised
      %basic 5
      --%immutable      
      %public
      length:
         out V: var integer
         V := get[0] -- actually an index error, accessing length
      @get:
         %basic 117 -- no globals[], since origin must be there for @get
         in get: var integer
         out ch: var char
      get[get: var integer]:
         %basic 117 -- no globals[], since origin must be there for get
         out ch: var char
      + : 
         in S: ref String 
         out V: ref String
         L: var integer
         L:= Length
         doplus: do
            e: var integer
            i: var integer
            T: obj Indexed(L + S.length,Integer)
            for(1):to(L):repeat
                e:= get[inx]
                T.put(e):at[inx]
            for(1):to(S.length):repeat 
                e := S.get[inx]
                i:= L + inx
                T.put(e):at[i]
            V := T.asString
         -- V: obj Indexed(Length + S.length)
         -- V := T[1:length] + S.T[1:S.length]
      asLowerCase:
         in T: ref String
         --.. primitive or ?
      scan:
         %Public
         current: var char
         for(1):to(length):repeat
              current := get[inx]
              inner(scan)
      print:
        gogo:
           "gogo\n".print
        for(1):to (length) :repeat
           put(get[inx])

      = ::
        --in Veq: ref String 
        --out beq: var boolean
        loop: do
           c1: var char
           c2: var char
           L: var integer
           L:= length
           if (L <> Veq.length) :then
               leave(loop)
           beq := true
           for (1):to(length):repeat
               c1 := get[inx]
               c2 := Veq.get[inx]
               if (c1 <> c2) :then
                   Beq := false
                   leave(loop)
      <> :
         in V: ref String 
         out B: var boolean
         B := this(String) == V
         B := B.not
      <= ::
        --in V: ref string
        --out B: var boolean
        loop: obj
           -- "Hello"  <= "World" since H <= W
           -- "Qweabc" <= "Qwevwxy" since a <= e
           -- "Qweayc" <= "Qwexby"
           -- "Qwe"    <= "Qwerty"
           -- "Qwerty" <= "Qwe" - false
           -- "" <= "qwerty" - true
           -- "qwerty" <= "" - false
           -- "" <= "" - true
           -- "" <= "Hello" - true	   
           matchEq:
              inx: var integer
              c1: var char
              c2: var char
              isEmpty: do
                  if (L1 = 0) :then
                      Beq := L1 <= L2		      
                      leave(matchEq)
                  if (L2 = 0) :then
                      Beq:= false
                      leave(matchEq)
              loop: do
                 inx := inx + 1
                 c1 := get[inx]
                 c2 := Veq.get[inx]
                 if (c1 = c2) :then
                     if (inx < L) :then
                        restart(loop)
              doit: do
                  if (c1 = c2) :then
                     -- we have inx = L
                     Beq := L1 <= L2
                     leave(matchEq)
                  :else
                      Beq := c1 < c2
                      leave(matchEq)

           L: var integer
           L1: var integer
           L2: var integer
           L1:= length
           -- min length of this and V
           L2:= Veq.length
           if (L1 < L2) :then
               L:= L1
           :else
               L:= L2
           matchEq
   C:
      in ch: var char
      out S: ref String
      D: obj Indexed(1,char)
      D.put(ch):at[1]
      S := D.asString
   I2S:
      %id "I2s"
      %globals
      in V: var integer
      out Si2s: ref String
      D: obj Indexed(20,char)
      D2: obj Indexed(20,char)
      L: var integer
      isNeg: var Boolean
      isNeg := V < 0
      if (isNeg) :then 
         V := 0 - V
         D.put('-'):at[1]
         L := 1
      loop: do 
         L := L + 1
         D.put('0' + V /% 10):at[L]
         V := V // 10
         if (V > 0) :then 
             restart(loop)
      for (1):to(L):repeat
         D2.put(D.get[L + 1 - inx]):at[inx]
      Si2s := D2.asString
   F2S:
      %id "F2S"
      %basic 145
      %globals 
      in V: var float
      out S: var String
      
      