Xarray: obj
   %include  String
   Dimension: Value
      in low: var integer
      in upp: var integer
      Length:
         out V: var integer
         V := (upp - low) + 1
      print:
        "Dimension:(".print
        putint(low)
        put(',')
        putint(upp)
        put(')')
      --print
   Range:
      in dims: ref indexed(1,#Dimension)
      put('R')
      putint(dims.length)
      put(';')
      @for 1 :to dims.length :do
          (dims.@get inx).print
   Array:
      -- A[1:3][1:4] =
      -- A[i][j] = (i - 1) * D2.length + j
      -- A[1][1] = R[1]
      -- A[1][2] = R[2]
      -- A[1][3] = R[3]
      -- A[1][4] = R[4]
      -- A[2][1] = R[5] = (2 - 1) * 4 + 1 = 5
      
      in D1: var Dimension(0,0)
      in D2: var Dimension(0,0)
      put(V: var float):at[ix1: var integer,ix2: var integer]:
         inx: var integer
         inx := ((ix1 - 1) * D2.length) + ix2
         R.@put V :at inx

      get[ix1: var integer,ix2: var integer]:
          out V: var float
          V := R.@get ((ix1 - 1) * D2.length) + ix2
      add[row1: var integer, row2: var integer]:
         @for 1 :to D2.length :do
              put(get[row1,inx] + get[row2,inx]):at[row1,inx]
      
      mult[row: var integer]:by(V: var integer):
         @for 1 :to D2.length :do
              put(get[row,inx] * V):at[row,inx]
      sort:
         @for 1 :to D1.length :do
              i: var integer
              i := inx
              @for i + 1 :to D1.length :do
                  j: var integer
                  j := inx
                  @if (get[i,i] < get[j,i]) :then
                      @for 1 :to D2.length :do
                           k: var integer
                           k := inx
                           put(get[i,k] + get[j,k]):at[i,k]
                           put(get[i,k] - get[j,k]):at[j,k]
                           put(get[i,k] - get[j,k]):at[i,k]
      Gauss:
         "Gauss:\n".print      
         @for 1 :to (D1.length - 1) :do
              i: var integer
              i := inx
              @for i + 1 :to D1.length :do
                  j: var integer
                  j := inx
                  f: var Float
                  x: var Float
                  x := get[j,i]		  
                  "A: ".print
                  putFloat(x)
                  " B: ".print
                  putFloat(get[i,i])                  
                  f := get[j,i]
                  f := f / get [i,i]	
                  " F: ".print
                  putFloat(f)
                  newline		  
                  @for 1 :to D2.length :do
                        k: var integer
                        k := inx
                        put(get[j,k] - (f * get[i,k])):at[j,k]
      printSeq:
         "print: ".print
         putint(R.length)
         newline
         @for 1 :to R.length :do
              putint(R.@get inx)
              put(' ')
      print:
         "Matrix:\n".print
         @for D1.low :to D1.upp :do
              ix: var integer
              ix := inx
              @for D2.low :to D2.upp :do
                   F:  var Float
                   F := get[ix,inx]		   
                   --F :=R.@get ((ix - 1) * D2.length) + inx
                   putFloat(F)
                   put(' ' )
              newline
      
      R: obj Indexed(D1.length * D2.length,#Float)   
      range: var integer
      range := D1.length * D2.length
      --R := Indexed(range,#Float)     
   A: obj Array(Dimension(1,3),Dimension(1,4))

   @for 1 :to 3 :do
      ix: var integer
      ix := inx
      @for 1 :to 4 :do
           F: var Float
           F := inx * inx + ix
           A.put(F):at[ix,inx]
   A.printSeq
   newline
   A.print
   newline
   --Range((1,10))
   A.mult[1]:by(2)
   A.print
   newline
   A.add[3,1]
   A.print
   A.sort
   A.print
   newline
   A.Gauss
   A.print
   newline
