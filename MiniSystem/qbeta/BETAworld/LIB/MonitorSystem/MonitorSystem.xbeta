MonitorSystem: obj
   %domain_boundary
   %module LIB.BasicSystem, LIB.BasicSystem.SemaphoreLib
   %public
   System: LIB.BasicSystem.basicSystem
      %public
      Semaphore_OLD: 
         %globals P_status,SQS
         cnt: var integer
         M: obj LIB.BasicSystem.Lock("OldSem:lock")
         Q: obj ProcessQueue
         %public
         init: 
            cnt := 1
            M.id := "Semaphore"
         wait: 
            theActive: ref BasicProcess
            M.get
            cnt := cnt - 1
            @if cnt < 0 :then 
               --thisCore.dummy := 118
               --thiscore.main.dummyB := true
               disable
               theActive := thisCore.main.active
               --theActive.display
               --theActive.addWaiting
               --SQS.addWaiting
               enable
               Q.insert(theActive) --thisCore.main.active)
               M.free
               thisCore.main.active.status := P_status.WAITING
               theActive.suspend 
            :else 
               M.free
         signal: 
            P: ref BasicProcess
            M.get
            cnt := cnt + 1
            @if cnt <= 0 :then 
               P := Q.removeNext
               --P.status := P_status.ACTIVE
               disable
               P.mkActive --SQS.insert(P)
               --P.dcrWaiting --SQS.dcrWaiting
               enable
               M.free 
            :else 
               M.free
      Process: BasicProcess
         %globals monitor,immutable,console
         -- we need to find out how to restrict Process to have no
         -- visible interface. Perhaps rethink the use of interface to
         -- define mena that only patterns in an interface are public
         -- alle other patterns (and data items) are private	 
         %public
         start:: 
            --P: ref Process
            --P := this(Process)
            ("starting: " + id + "\n").print
            --SQS.insert(P)
         inner(Process)
      Monitor: 
         %globals P_status,SQS, BasicSystem
         %interface entry
         mutex: obj BasicSystem.SemaphoreLib.Semaphore(1)
         _V: var integer
         %public
         init: 
            "Monitor:init\n".print
         entry: 
            %kind method
            %arguments immutable
            mutex.wait
            _V := _V + 1
            inner(entry)
            mutex.signal
         wait: 
            cond: var boolean
            loop: obj 
               inner(wait)
               @if cond = false :then 
                  mutex.signal
                  -- P_status.ACTIVE -> thisCore.main.active.status;
                  -- thisCore.main.active.suspend;
                  mutex.wait
                  @restart loop
         inner(Monitor)
      inner(System)