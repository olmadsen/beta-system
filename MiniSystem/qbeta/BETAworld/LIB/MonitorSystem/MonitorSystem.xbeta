MonitorSystem: obj
   %domain_boundary
   %public
   System: LIB.BasicSystem.basicSystem
      %public
      Semaphore: 
         %globals P_status,SQS
         cnt: var integer
         M: obj Lock
         Q: obj ProcessQueue
         %public
         init: 
            cnt := 1
            M.id := "Semaphore"
         wait: 
            theActive: ref BasicProcess
            M.get
            cnt := cnt - 1
            @if cnt < 0 :then 
               --thisCore.dummy := 118
               --thiscore.main.dummyB := true
               disable
               SQS.addWaiting
               enable
               Q.insert(thisCore.main.active)
               theActive := thisCore.main.active
               M.free
               thisCore.main.active.status := P_status.WAITING
               theActive.suspend 
            :else 
               M.free
         signal: 
            P: ref BasicProcess
            M.get
            cnt := cnt + 1
            @if cnt <= 0 :then 
               P := Q.removeNext
               P.status := P_status.ACTIVE
               disable
               SQS.insert(P)
               SQS.dcrWaiting
               enable
               M.free 
            :else 
               M.free
      Process: BasicProcess
         %globals SQS,monitor,immutable,console
         -- we need to find out how to restrict Process to have no
         -- visible interface. Perhaps rethink the use of interface to
         -- define mena that only patterns in an interface are public
         -- alle other patterns (and data items) are private	 
         %public
         start:: 
            P: ref Process
            P := @this Process
            ("starting: " + id + "\n").print

            
            --newline
            
            SQS.insert(P)
         inner
      Monitor: 
         %globals P_status,SQS
         %interface entry
         mutex: obj Semaphore
         _V: var integer
         %public
         init: 
            mutex.init
            "Monitor:init\n".print
         entry: 
            %kind method
            %arguments immutable
            mutex.wait
            _V := _V + 1
            inner
            mutex.signal
         wait: 
            cond: var boolean
            loop: obj 
               @inner wait
               @if cond = false :then 
                  mutex.signal
                  -- P_status.ACTIVE -> thisCore.main.active.status;
                  
                  -- thisCore.main.active.suspend;
                  
                  mutex.wait
                  @restart loop
         inner(Monitor)		  
      inner