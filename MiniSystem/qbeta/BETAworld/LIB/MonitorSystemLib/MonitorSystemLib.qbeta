MonitorSystemLib: obj
   %domain_boundary
   %visible LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib
   %module LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib
   %public
   MonitorSystem: LIB.BasicSystemLib.BasicSystem
      %public
      MonitorProcess: BasicProcess
         %globals Monitor,MonitorProcess(""),immutable,console
         -- we need to find out how to restrict Process to have no
         -- visible interface. Perhaps rethink the use of interface to
         -- define mena that only patterns in an interface are public
         -- alle other patterns (and data items) are private	 
         %public
         start:: 
            --P: ref Process
            --P := this(MonitorProcess)
            --("starting: " + id + "\n").print
            --SQS.insert(P)
         inner(MonitorProcess)
      class ExtendedMonitorProcess: MonitorProcess
         -- Extension of MonitorProcess with Monitor attributes
         -- If this works, it should be included in MonitorProcess
         %interface entry	 
         mutex: obj Semaphore(0)  -- initially closed
         isClosed: var boolean -- this(XMP) has terminated: no more entry calls
         entry:
            mutex.wait
            if (isClosed) :then
               console.display
                   "Entry not possible\n".print
                   leave(entry)        
            inner(entry)
            mutex.signal

         wait: 
            cond: var boolean
            loop: do 
               inner(wait)
               if (cond = false) :then 
                  mutex.signal
                  -- sleep?	       
                  mutex.wait
                  restart(loop)
         waitAndAccept(t: var integer):
            -- No entry-method is running, but some may be at mutex.wait
            mutex.signal -- signal OK here
            -- A Procces may enter and pass wait(not processRunning)
            sleep(t)
            -- Possible Process is executing an entry method
            mutex.wait   -- wait for possible running entry method
            -- in competion with Players

         -- initial: mutex is locked 
         -- mutex is locked
         -- no entry-method can enter
         inner(ExtendedMonitorProcess)
         isClosed := true	 
      Monitor: 
         %globals P_status,SQS, BasicSystemLib, Monitor, console, immutable, #MonitorProcess
         %interface entry
         mutex: obj BasicSystemLib.SemaphoreLib.Semaphore(1)
         _V: var integer
         %public
         init:< entry
            "Monitor:init\n".print
            inner(init)	    
         entry: 
            %kind method
            %arguments value, immutable
            mutex.wait
            _V := _V + 1
            inner(entry)
            mutex.signal
         wait: 
            cond: var boolean
            loop: obj 
               inner(wait)
               if (cond = false) :then 
                  mutex.signal
                  -- P_status.ACTIVE -> thisCore.main.active.status;
                  -- thisCore.main.active.suspend;
                  mutex.wait
                  restart(loop)
         inner(Monitor)
      inner(MonitorSystem)