MonitorSystemLib: obj
   %domain_boundary
   %module LIB.BasicSystemLib, LIB.BasicSystemLib.SemaphoreLib
   %public
   MonitorSystem: LIB.BasicSystemLib.BasicSystem
      %public
      Semaphore_OLD: 
         %globals P_status,SQS
         cnt: var integer
         M: obj LIB.BasicSystemLib.Lock("OldSem:lock")
         Q: obj ProcessQueue
         %public
         init:< 
            cnt := 1
            M.id := "Semaphore"
            inner(init)
         wait: 
            theActive: ref BasicProcess
            M.get
            cnt := cnt - 1
            if (cnt < 0) :then 
               --thisCore.dummy := 118
               --thiscore.main.dummyB := true
               disable
               theActive := thisCore.main.active
               --theActive.display
               --theActive.addWaiting
               --SQS.addWaiting
               enable
               Q.insert(theActive) --thisCore.main.active)
               M.free
               thisCore.main.active.status := P_status.WAITING
               theActive.suspend 
            :else 
               M.free
         signal: 
            P: ref BasicProcess
            M.get
            cnt := cnt + 1
            if (cnt <= 0) :then 
               P := Q.removeNext
               --P.status := P_status.ACTIVE
               disable
               P.mkActive --SQS.insert(P)
               --P.dcrWaiting --SQS.dcrWaiting
               enable
               M.free 
            :else 
               M.free
      MonitorProcess: BasicProcess
         %globals Monitor,MonitorProcess(""),immutable,console
         -- we need to find out how to restrict Process to have no
         -- visible interface. Perhaps rethink the use of interface to
         -- define mena that only patterns in an interface are public
         -- alle other patterns (and data items) are private	 
         %public
         start:: 
            --P: ref Process
            --P := this(MonitorProcess)
            --("starting: " + id + "\n").print
            --SQS.insert(P)
         inner(MonitorProcess)
      Monitor: 
         %globals P_status,SQS, BasicSystemLib, Monitor, console, immutable, #MonitorProcess
         %interface entry
         mutex: obj BasicSystemLib.SemaphoreLib.Semaphore(1)
         _V: var integer
         %public
         init:< entry
            "Monitor:init\n".print
            inner(init)	    
         entry: 
            %kind method
            %arguments value, immutable
            mutex.wait
            _V := _V + 1
            inner(entry)
            mutex.signal
         wait: 
            cond: var boolean
            loop: obj 
               inner(wait)
               if (cond = false) :then 
                  mutex.signal
                  -- P_status.ACTIVE -> thisCore.main.active.status;
                  -- thisCore.main.active.suspend;
                  mutex.wait
                  restart(loop)
         inner(Monitor)
      inner(MonitorSystem)