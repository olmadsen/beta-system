String: obj
   %public
   String:
      %OSDvisibility disguised
      %basic 5
      %immutable      
      %public
      length:
         out V: var integer
         V := @get 0 -- actually an index error, accessing length
      @get:
         %basic 117 -- no globals[], since origin must be there for @get
         in get: var integer
         out ch: var char

      + : 
         in S: ref String 
         out V: ref String
         L: var integer
         L:= Length
         
         doplus:
            e: var integer
            i: var integer
            T: obj Indexed(L + S.length,Integer)
            @for 1 :to L :do
                e:= @get inx
                T.@put e :at inx
            @for 1 :to S.length :do
                e := S.@get inx
                i:= L + inx
                T.@put e :at i
            V := T.asString
         doplus
         -- V: obj Indexed(Length + S.length)
         -- V := T[1:length] + S.T[1:S.length]
      asLowerCase:
         in T: ref String
         --.. primitive or ?
      scan:
         %Public
         current: var char
         @for 1 :to length :do
              current := @get inx
              @inner scan
      print:
        @for 1 :to length :do {put(@get inx)}

      = :
        in S: ref String 
        out B: var boolean
        loop: obj
           c1: var char
           c2: var char
           L: var integer
           L:= length
           @if L <> S.length :then
               -- length <> S.length does not work
               @leave loop
           B := true
           @for 1 :to length :do
               c1 := @get inx
               c2 := S.@get inx
               @if c1 <> c2 :then
                   B := false
                   @leave loop
      <> :
         in S: ref String 
         out B: var boolean
         -- does not work in BinTree
         B := (@this String = S)
         B := B.not
      <= :
        in S: ref string
        out B: var boolean
        loop: obj
           -- "Hello"  <= "World" since H <= W
           -- "Qweabc" <= "Qwevwxy" since a <= e
           -- "Qweayc" <= "Qwexby"
           -- "Qwe"    <= "Qwerty"
           -- "Qwerty" <= "Qwe" - false
           -- "" <= "qwerty" - true
           -- "qwerty" <= "" - false
           -- "" <= "" - true 
           matchEq:
              inx: var integer
              c1: var char
              c2: var char
              isEmpty: obj
                  @if L1 = 0 :then
                      B := L1 = L2
                      @leave matchEq
                  @if L2 = 0 :then
                      B:= true
                      @leave matchEq
              loop: obj
                 inx := inx + 1
                 c1 := @get inx
                 c2 := S.@get inx
                 @if c1 = c2 :then
                     @if inx < L :then @restart loop
              doit: obj
                  @if c1 = c2 :then
                     -- we have inx = L
                     B := L1 <= L2
                     @leave matchEq
                  :else
                      B := c1 < c2
                      @leave matchEq

           L: var integer
           L1: var integer
           L2: var integer
           L1:= length
           -- min length of this and S
           L2:= S.length
           @if L1 < L2 :then
               L:= L1
           :else
               L:= L2
           matchEq
   I2S: 
      %globals
      in V: var integer
      out S: ref Object
      D: obj Indexed(20,char)
      D2: obj Indexed(20,char)
      L: var integer
      isNeg: var Boolean
      isNeg := V < 0
      @if isNeg :then 
         V := 0 - V
         D.@put '-' :at 1
         L := 1
      doit: 
         loop: obj 
            L := L + 1
            D.@put ('0' + V /% 10) :at L
            V := V // 10
            @if V > 0 :then 
               @restart loop
         @for 1 :to L 
         :do 
            i: var integer
            D2.@put (D.@get (L + 1 - inx)) :at inx
      doIt
      T: ref LIB.string.String
      T := D2.asString
      S := T