ORIGIN 'mpsinterface';

--- mpsinterfacelib:attributes ---

getEnclosingAst:
  (* Returns the first enclosing ast of the syntactical category given by
   * symbol.
   * 
   * By default, the attempt to locate the enclosing ast stops if a
   * fragment is met. This default may be changed by further binding
   * followFragments to TrueObject. *)
  (# followFragments:< BooleanValue;
     a,af: ^AST.ast;
     symbol: @Integer;
  enter (a[],symbol)
  do 
     loop:
       (if a[]<>NONE then
           (if a.symbol=symbol then
               leave loop;
            else
               a.father->af[];
               (if af[]//NONE then
                   (if followFragments then a.frag[]->findSlot->a[]
                    else
                       NONE->a[];
                       leave loop;
                   if);
                else
                   af[]->a[];
               if);
               restart loop;
           if);
       if);
  exit a[]
  #);

findSlot:
  (* Return the SLOT bound to fragmentForm ff. *)
  (# ff: ^AST.fragmentForm;
     fg,fgf: ^AST.fragmentGroup;
     theSlot: ^AST.slotDesc;
  enter ff[]
  do (if ff.binding[]//NONE then
         ff.father->fg[];
         fg[]->fgf[];
         (* Setup origin chain. *)
         loop:
           (if fgf[]<>NONE then
               (if fgf.origin//NONE then
                   fgf[]->mySetupOrigin;
                   fgf.origin->fgf[];
                   restart loop;
               if)
           if);
         ff[]->fg.bind->ff.binding[]->theSlot[]
      else
         ff.binding[]->theSlot[];
     if);
  exit theSlot[]
  #);

lastInList:
  (* Returns the last non-optional element in l *)
  (# listType:< AST.list;
     l: ^listType;
     last: ^AST.ast;
  enter l[]
  do 
     l.newScan 
     (# 
     do (if current.kind<>AST.kinds.optional then
            current[]->last[]
        if)
     #);
  exit last[]   
  #);

nextbrother:
  (* Returns the next non-optional brother of a. *)
  (# a: ^AST.ast;
  enter a[]   
  do a.nextbrother->a[];
     loop:
       (if a[]<>NONE then
           (if a.kind<>AST.kinds.optional then
               leave loop
            else
               a.nextbrother->a[];
               restart loop;
           if);
       if);
  exit a[]
  #);
