ORIGIN '~beta/guienv/v1.6/guienv';

BODY 'private/obguienvaddsbody';
BODY 'private/obrubberbody';

--- windowLib:attributes ---
wriggle:
  (# pos: @Point;
  do bringToFront;
     position->pos;
     (-10,0)->pos.add;
     pos->position; TRUE->update;
     (for i:10 repeat
	  (if i mod 2 = 1 then
	      (20-(2*i),0)->pos.add;
	      pos->position; TRUE->update;
	   else
	      (-20+(2*i),0)->pos.add;
	      pos->position; TRUE->update;
	  if);
     for);
  #);

--- windowItemLib: attributes ---

(* RESIZERELATIVE
 * ==============
 *
 * Changes the frame of a child windowItem in response, and relative
 * to, a change in the frame of the father frame, as reported by
 * eventHandler.onFatherFrameChanged *)

resizeRelative:
  (# theEvent: ^theEventHandler.onFatherFrameChanged;
  enter theEvent[]
  do <<SLOT VEUresizeRelative:descriptor>>
  #);

onFatherFrameResizeRelative: action
  (# eventType:: theEventHandler.fatherFrameChanged;
  do theEvent[]->resizeRelative;
  #);

installResizeRelativeAction:
  (#
  do &onFatherFrameResizeRelative[]->appendAction;
  #);

itemPos:
  (* Returns the position of this windowItem in the coordinatsystem
   * of the surrounding window. *)
  (# pos: @Point;
  <<SLOT VEUitemPos:dopart>>
  exit pos
  #);

FrameDrawer:
  (* If UseRunningOutline is TRUE, FrameDrawer draws a
   * running outline around THIS(windowItem) until kill is called.
   * Otherwise a black outline is drawn and kept refreshed until kill
   * is called.
   *)
  (# <<SLOT FrameDrawerLib:attributes>>;
     kill:
       (# doupdate: @Boolean;
       enter doupdate
       <<SLOT FrameDrawerKill:dopart>>
       #);
     fdprivate: @<<SLOT FrameDrawerPrivate:descriptor>>;
     UseRunningOutline: @Boolean;
  enter UseRunningOutline
  <<SLOT FrameDrawerDo:dopart>>
  #);

mydrag:
  (* Differs from drag by drawing without clipping the children, and
   * by taking a start point from which mousemoves should be handled
   * relatively. Furthermore, the frame of this windowItem is not set,
   * but the resulting frame is returned. *)
  (# startpos: @Point;
     newFrame: @rectangle;
  enter startpos
  <<SLOT obrubbermydrag:dopart>>
  exit newFrame
  #);

--- canvasLib:attributes ---
getOutline:
  (* Lets the user define a default rectangle by dragging and resizing
   * an outline. When an outline has been defined, done is called.
   * When the rectangle is not being resized, it is presented with an
   * illusion of a running outline. 
   *)
  (# done:<
       (# result: @rectangle;
       enter result
       do INNER
       #);
     default: @rectangle;
  enter default
  do <<SLOT canvasGetOutlineBody:descriptor>>
  #);

defineRect:
  (* Used to resize window rectangles. *)
  (# theRect: @rectangle;
     followWhenOutside: @Boolean;
  enter (theRect,followWhenOutside)
  do <<SLOT DefineRectBody: Descriptor>>
  exit theRect
  #);

simpleDefineRect:
  (* Used to define a simple rectangle, starting in the point entered. *)
  (# p: @Point; theRect: @rectangle;
  enter p
  do <<SLOT SimpleDefineRectBody: Descriptor>>
  exit theRect
  #);

browserDrawRect:
  (* Draws (or clears) rectangle. *)
  (# theRect: @rectangle;
  enter theRect
  <<SLOT browserrubberdrawRect:dopart>>
  #);

--- lib:attributes ---

actionList: List
  (# element:: (# action: ##Object #);
     appendAction:
       (# new: ^element;
	  action: ##Object;
       enter action##
       do &element[]->new[];
	  action##->new.action##;
	  new[]->append;
       #);
  #);

actionedMenuItemAction:
  (# paramType:< Object;
     param: ^paramType;
     checked: @Boolean;
  enter param[]
  do INNER
  exit checked
  #);

actionedMenuItemOnStatus:
  (# paramType:< Object;
     param: ^paramType;
     value: @Boolean
  enter param[]
  do INNER
  exit value
  #);

--- menuLib:attributes ---

actionedMenuItem: menuItem
  (# onSelectAction: ##actionedMenuItemAction;
     onStatusAction: ##actionedMenuItemOnStatus;
     paramType:< Object;
     param: ^paramType;
     open::<
       (# itemname: ^Text;
       enter (onSelectAction##,onStatusAction##,param[],itemname[])
       do THIS(actionedMenuItem)[]->append;
	  itemname[]->name;
	  INNER;
       #);
     eventHandler::<
       (# onSelect::<
	    (#
	    do (if onSelectAction##<>NONE then
		   param[]->onSelectAction->checked
	       if);
	       INNER;
	    #);
	  onStatus::<
	    (#
	    do (if onStatusAction##<>NONE then
		   param[]->onStatusAction->value
	       if);
	       INNER;
	    #);
       #);
  #);
