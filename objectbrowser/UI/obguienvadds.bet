ORIGIN '~beta/guienv/v1.3.hml/guienv';

BODY 'private/obguienvaddsbody';
(*BODY 'private/canvasgroupbody';*)
BODY 'private/obrubberbody';

INCLUDE '../coroutinespawner';

--- guienvLib:attributes ---

getStripes:
  (* Returns a list of rasters that, when used in sequence to draw a frame,
   * gives an illusion of a running outline. *)
  (# stripes: [8] ^raster;
  <<SLOT graphicalEditorGetStripes: doPart>>
  exit stripes
  #);

bettermenu: menu
  (* Special menu type with interdependant check marks, some other 
   * extra features, and a few code saving patterns.
   * By Peter Andersen.
   *)
  (# item: menuitem
       (# enabled: @boolean;
          onSelect:< object;
          onStatus:< object;
          eventhandler::<
            (# onSelect::<
                 (# do THIS(item).onSelect; INNER #);
               onStatus::<
                 (# do THIS(item).onStatus; INNER; enabled->value #);
            #);
          new:
            (# n: ^text;
            enter n[]
            do true -> enabled; 
               open; 
               THIS(item)[] -> append;
               (if n[]<>NONE then n[]->name if);
               INNER;
               #);
          newkey: new(# k: @char enter k do k->key #);
       #);
     radioitem: item
       (# checkgroup: @integer
            (* The group of items THIS(item) is dependant on. default 1. *);
          open::< (# do 1 -> checkgroup; INNER; #);
          onSelect::< (# do THIS(radioitem)[] -> changechecked; INNER; #);
       #);
     toggleitem: item
       (# onSelect::< (# do not checked->checked; INNER; #)#);
     
     oldChecked: [3]^radioitem; (* Up to 3 independent groups of items *)
     changechecked:
       (# newitem: ^radioitem
       enter newitem[]
       do (if oldChecked[newitem.checkgroup][]<>newitem[] then
              (if oldChecked[newitem.checkgroup][]<>NONE then
                  false->oldChecked[newitem.checkgroup].checked;
              if);
              newitem[]->oldChecked[newitem.checkgroup][];
              true->newitem.checked;
          if)
       #);
     newseparator: 
       (# s: ^separator;
       do &separator[]->s[];
          s.open;
          s[] -> append;
       #);
     new:
       (# n: ^text;
          enter n[]
       do open; 
          (if n[]<>NONE then n[]->name if);
       #)
  #);   

--- windowLib:attributes ---
(* groupControl: Canvas
 *   (# <<SLOT groupControlLib:attributes>>;
 *      
 *      verticalStacking: @Boolean;
 *      {* Whether members should be stacked on top or beside each other.
 *       * Set it in INNER open before appending members. *}
 *      
 *      minsize: @Integer;
 *      {* The minimal accepted height of members. Set it in INNER open. *}
 *      
 *      panewidth: @Integer;
 *      {* The width of the separators separating members. Default i 2.
 *       * Set it in INNER open. *}
 *      
 *      open::<
 *        (# onGroupSizeComputed:< Object; {* Called when the size of this group
 *                                          * has been computed and set. The size
 *                                          * is computed to be large enough to
 *                                          * contain all members. *}
 *        do <<SLOT groupcontrolopen:descriptor>>
 *        #);
 *      
 *      appendMember:
 *        {* Should be called from open of the new member which should be called
 *         * from inside open of this groupControl. *}
 *        (# member: ^Canvas;
 *           lastmember: @Boolean;
 *        enter (member[],lastmember)
 *        <<SLOT groupcontrolappendMember:dopart>>
 *        #);
 *      
 *      gcprivate: @<<SLOT groupcontrolprivate:descriptor>>;
 *   #);
 * 
 *)
wriggle:
  (# pos: @Point;
  do bringToFront;
     position->pos;
     (-10,0)->pos.add;
     pos->position; TRUE->update;
     (for i:10 repeat
          (if i mod 2 = 1 then
              (20-(2*i),0)->pos.add;
              pos->position; TRUE->update;
           else
              (-20+(2*i),0)->pos.add;
              pos->position; TRUE->update;
          if); 
     for);
  #);

--- windowItemLib: attributes ---

(* RESIZERELATIVE
 * ==============
 * 
 * Changes the frame of a child windowItem in response, and relative 
 * to, a change in the frame of the father frame, as reported by
 * eventHandler.onFatherFrameChanged *)

resizeRelative: 
  (# theEvent: ^theEventHandler.onFatherFrameChanged;
  enter theEvent[]
  do <<SLOT VEUresizeRelative:descriptor>>
  #);

onFatherFrameResizeRelative: action
  (# eventType:: theEventHandler.fatherFrameChanged;
  do theEvent[]->resizeRelative;
  #);

installResizeRelativeAction:
  (# 
  do &onFatherFrameResizeRelative[]->appendAction;
  #);

itemPos:
  (* Returns the position of this windowItem in the coordinatsystem
   * of the surrounding window. *)
  (# pos: @Point;
  <<SLOT VEUitemPos:dopart>>
  exit pos   
  #);

FrameDrawer:
  (* If a coroutinespawner is installed, a FrameDrawer draws a
   * running outline around THIS(windowItem) until kill is called.
   * If no coroutinespawner is installed, or useCoroutineSpawnerIfPresent
   * is FALSE, a black outline is drawn and kept refreshed until kill 
   * is called. *)
  (# <<SLOT FrameDrawerLib:attributes>>;
     kill: 
       (# doupdate: @Boolean;
       enter doupdate
       <<SLOT FrameDrawerKill:dopart>>
       #);
     fdprivate: @<<SLOT FrameDrawerPrivate:descriptor>>;
     useCoroutineSpawnerIfPresent: @Boolean;
  enter useCoroutineSpawnerIfPresent
  <<SLOT FrameDrawerDo:dopart>>
  #);

mydrag: 
  (* Differs from drag by drawing without clipping the children, and
   * by taking a start point from which mousemoves should be handled
   * relatively. Furthermore, the frame of this windowItem is not set,
   * but the resulting frame is returned. *)
  (# startpos: @Point;
     newFrame: @rectangle;
  enter startpos
  <<SLOT obrubbermydrag:dopart>>
  exit newFrame
  #);

--- canvasLib:attributes ---
getOutline:
  (* Lets the user define a defalt rectangle by dragging and resizing
   * an outline. When an outline has been defined, done is called.
   * 
   * If a coroutinespawner is installed in the objectPool, it is used to
   * created an illusion of a running outline. *)
  (# done:< 
       (# result: @rectangle;
       enter result
       do INNER
       #);
     default: @rectangle;
  enter default
  do <<SLOT moveablegetOutline:descriptor>>
  #);

defineRect:
  (* Used to resize window rectangles. *)
  (# theRect: @rectangle; 
     followWhenOutside: @Boolean;
  enter (theRect,followWhenOutside)
  do <<SLOT DefineRectBody: Descriptor>>
  exit theRect
  #);

simpleDefineRect:
  (* Used to define a simple rectangle, starting in the point entered. *)
  (# p: @Point; theRect: @rectangle; 
  enter p
  do <<SLOT SimpleDefineRectBody: Descriptor>>
  exit theRect
  #);

browserDrawRect:
  (* Draws (or clears) rectangle. *)
  (# theRect: @rectangle;
  enter theRect
  <<SLOT browserrubberdrawRect:dopart>>
  #);

grabPointer: <<SLOT obGrabPointer:descriptor>>;
unGrabPointer: <<SLOT obUnGrabPointer: descriptor>>;

--- lib:attributes ---

actionList: List 
  (# element:: (# action: ##Object #);
     appendAction:
       (# new: ^element;
          action: ##Object;
       enter action##
       do &element[]->new[];
          action##->new.action##;
          new[]->append;
       #);
  #);

actionedMenuItemAction:
  (# paramType:< Object;
     param: ^paramType;
     checked: @Boolean;
  enter param[]
  do INNER
  exit checked
  #);

actionedMenuItemOnStatus:
  (# paramType:< Object;
     param: ^paramType;
     value: @Boolean
  enter param[]     
  do INNER 
  exit value
  #);

--- menuLib:attributes ---

actionedMenuItem: menuItem
  (# onSelectAction: ##actionedMenuItemAction;
     onStatusAction: ##actionedMenuItemOnStatus;
     paramType:< Object;
     param: ^paramType;
     open::<
       (# itemname: ^Text;
       enter (onSelectAction##,onStatusAction##,param[],itemname[])
       do THIS(actionedMenuItem)[]->append;
          itemname[]->name;
          INNER;
       #);
     eventHandler::<
       (# onSelect::<
            (# 
            do (if onSelectAction##<>NONE then 
                   param[]->onSelectAction->checked
               if);
               INNER;
            #);
          onStatus::<
            (# 
            do (if onStatusAction##<>NONE then
                   param[]->onStatusAction->value
               if);
               INNER;
            #);
       #);
  #);
