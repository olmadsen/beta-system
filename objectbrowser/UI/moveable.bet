ORIGIN '~beta/guienv/v1.2/guienv';

(* MOVEABLE (Created by Soren Brandt, 16/8-1994)
 * ========
 * 
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1994
 *       All rights reserved.
 *)

BODY 'private/moveablebody';
INCLUDE 'obrubber';
INCLUDE '~beta/guienv/v1.2/controls';
INCLUDE '~beta/guienv/v1.2/figureitems';
INCLUDE '../coroutinespawner';

--- windowLib: attributes ---

moveableList: list 
  (# element::< moveable;
     onInsert:<
       (# theMoveable: ^moveable;
       enter theMoveable[]
       do INNER
       #);
     onDelete:<
       (# theMoveable: ^moveable;
       enter theMoveable[]
       do INNER
       #);
  #); 
(* SINGULAR instance in objectPool. Use getmoveableList to get this instance.
 * New moveables are automatically inserted and removed again when closed.
 * A subpattern of moveableList may be inserted into objectPool, but this
 * should be done before the first moveable is created. 
 *
 * onInsert is called immediately before a new moveable is inserted into the
 * list.
 * 
 * onDelete is called immediately after a moveable has been deleted from the
 * list. *)

getmoveableList: objectPool.get
  (# type::< moveableList; init:: (# do obj.init #)#);

borderWidth: (# exit 2 #); 
(* Pixel width of moveable border. Fixed by guienv. *)

(* MOVEABLE
 * ========
 * 
 * Superpattern for objects to move around inside a canvas.
 * 
 * To specialize moveable, further bind the contentsType virtual. *)

moveable: Canvas
  (# <<SLOT moveableLib: attributes>>;
     
     title: 
       (* The string to be displayed in the header. It can be set in 
        * moveable.open, or at any later point in time. *)
       (# 
       enter (# t: ^Text enter t[] <<SLOT VEUmoveableTitleEnter:dopart>> #)
       exit  (# t: ^Text <<SLOT VEUmoveableTitleExit:dopart>> exit t[] #)
       #); 
     
     moveableIconify: @iconButton
       (# open:: (# do <<SLOT VEUmoveableIconifyOpen:descriptor>>#);
          dobindings: (# <<SLOT VEUmoveableIconifyBindings:dopart>>#);
          eventHandler::
            (# onMouseDown:: 
                 (# do <<SLOT VEUmoveableIconifyOnMouseDown:descriptor>>#);
               onBorderStyleChanged::
                 (# <<SLOT VEUmoveableIconifyOnBorderStyleChanged:dopart>>#);
               onMouseUp::
                 (# do <<SLOT VEUmoveableIconifyOnMouseUp:descriptor>>#);
            #)
       #);
     moveableHeader: @staticText
       (# open:: (# <<SLOT VEUmoveableHeaderOpen:dopart>> #);
          dobindings: (# do <<SLOT VEUmoveableHeaderBindings:descriptor>>#);
          eventHandler::
            (# onMouseDown::
                 (# do <<SLOT VEUmoveableHeaderOnMouseDown:descriptor>>#);
               onBorderVisibleChanged::
                 (# <<SLOT VEUmoveableHeaderOnBorderVisibleChanged:dopart>>#);
               onMouseUp::
                 (# <<SLOT VEUmoveableHeaderOnMouseUp:dopart>>#);
            #);
       #);
     
     onResized:< Object; (* Called by if the user has resized this moveable. *)
     
     contentsType:< Canvas
       (* Further bind contentsType in order to specialize moveables. *)
       (# dobindings:<
            (# 
            do true -> bindBottom -> bindRight -> bindTop -> bindLeft;
               INNER;
            #);
          open::<
            (# 
            do <<SLOT moveableContentsOpen:descriptor>>
            #);
       #);
     contents: @contentsType;
     
     newPreferredContentsSize:
       (* Call this to notify this movable that its contents would prefer
        * a new size. The moveable will react by resizing itself to the
        * new size plus the size needed for the headers. Since the contents 
        * are by default fully bound to the moveable, this should change the 
        * size of the contents to the preferred size.
        * If the moveable becomes too big to fit in the father canvas, the
        * size and position is adjusted. *)
       (# sz: @Point;
       enter sz
       <<SLOT newPrefContentsSize:dopart>>
       #);
     
     doUpdate:< Object;
     (* Called if it may be time to update this moveable. Iconified moveables
      * may decide to ignore or defer the update. *)
     
     icon:<
       (* Further bind to return the raster to be used as icon for 
        * this moveable *)
       (# theIcon: ^raster;
       do INNER
       exit theIcon[]
       #);
     iconified: @Boolean; (* TRUE iff this moveable is currently iconified. *)
     
     (* These virtuals are called immediately before this moveable is
      * iconified or deiconified. *)
     onIconify:< Object;
     onDeIconify:< Object;
     
     bw: @Integer; (* Width of border of this(moveable).  Set by open. *)
     hh: @Integer; (* Heigth of header. Set by open. *)
     
     open::< 
       (# defaultFrame: @rectangle;
       enter defaultFrame
       do <<SLOT VEUmoveableOpen:descriptor>> 
       #);
     
     wasClosed: @Boolean; (* TRUE iff close has been called. *)
     close::< (# <<SLOT moveableOnClose:dopart>> #);
     
     moveableMenu:< menu
       (# <<SLOT moveableMenuLib:attributes>>;
          (* Called immediately before the moveableMenu is popped up. *)
          open::< (# do <<SLOT moveableMenuOpen:descriptor>> #);
          
          (* Lists of actions to be performed when this menu is opened
           * or popped up: *)
          onOpen: @ActionList;
          onPopup: @ActionList;
       #);
     movMenu: @moveableMenu;
     
     moveableOnCloseAction: moveableMenuItemAction 
       (# 
       do close; INNER
       #);
     
     moveableIconifyAction:< moveableMenuItemAction
       (* Called whenever the iconify state of this moveable changes.
        * Switches the current iconify state and calls onIconify or
        * onDeiconify. *)
       (#
       <<SLOT moveableIconifyAction:dopart>>
       #);
     
     wriggle:< (# <<SLOT moveableWriggle:dopart>> #);
     
     inRect:< BooleanValue
       (* Returns TRUE iff this moveable is contained in the rectangle r. *)
       (# r: @rectangle;
       enter r
       <<SLOT moveableInRect:dopart>>
       #);
     
     SelectFrame:
       (* Draws a running outline around this moveable. The outline is
        * removed again by calling UnSelectFrame. If no coroutinespawner
        * is implemented, the outline drawn is simply a black border *)
       (# <<SLOT moveableSelectFrame:dopart>> #);
     UnSelectFrame:
       (# <<SLOT moveableUnSelectFrame:dopart>> #);
     FrameSelected: BooleanValue (# <<SLOT moveableFrameSelected:dopart>> #);
     
     resizeCursor:<
       (* The mouse curser when on top of the borders of this moveable.
        * Signals that the moveable may be resized. *)
       (# theCursor: ^cursor;
       do cursors.cross[]->theCursor[];
          INNER;
       exit theCursor[]
       #);
     
     eventHandler::<
       (# onMouseDown::< (# <<SLOT VEUmoveableOnMouseDown:dopart>> #);
       #);
     
     ensureFrame:
       (* Ensures that the frame entered is fully visible within this canvas,
        * and that at least the iconifyButton is visible. *)
       (# newFrame: @rectangle;
       enter newFrame
       do <<SLOT VEUmoveableEnsureFrame:descriptor>> 
       exit newFrame
       #);
     
     moveablePrivate: @<<SLOT VEUmoveablePrivate:descriptor>>;
  #);


getStripes:
  (# stripes: [8] ^raster;
  <<SLOT graphicalEditorGetStripes: doPart>>
  exit stripes
  #);

--- windowItemLib: attributes ---

(* RESIZERELATIVE
 * ==============
 * 
 * Changes the frame of a child windowItem in response, and relative 
 * to, a change in the frame of the father frame, as reported by
 * eventHandler.onFatherFrameChanged *)

resizeRelative: 
  (# action: ^theEventHandler.onFatherFrameChanged;
  enter action[]
  do <<SLOT VEUresizeRelative:descriptor>>
  #);

itemPos:
  (* Returns the position of this windowItem in the coordinatsystem
   * of the surrounding window. *)
  (# pos: @Point;
  <<SLOT VEUitemPos:dopart>>
  exit pos   
  #);

FrameDrawer:
  (* If a coroutinespawner is installed, a FrameDrawer draws a
   * running outline around THIS(windowItem) until kill is called.
   * If no coroutinespawner is installed, a black outline is drawn. *)
  (# <<SLOT FrameDrawerLib:attributes>>;
     kill: <<SLOT FrameDrawerKill:descriptor>>;
     fdprivate: @<<SLOT FrameDrawerPrivate:descriptor>>;
  <<SLOT FrameDrawerDo:dopart>>
  #);

--- canvasLib:attributes ---
getOutline:
  (* Lets the user define a defalt rectangle by dragging and resizing
   * an outline. When an outline has been defined, done is called.
   * 
   * If a coroutinespawner is installed in the objectPool, it is used to
   * created an illusion of a running outline. *)
  (# done:< 
       (# result: @rectangle;
       enter result
       do INNER
       #);
     default: @rectangle;
  enter default
  do <<SLOT moveablegetOutline:descriptor>>
  #);

--- lib:attributes ---

moveableMenuItemAction:
  (# paramType:< Object;
     param: ^paramType;
     checked: @Boolean;
  enter param[]
  do INNER
  exit checked
  #);

moveableMenuItemOnStatus:
  (# paramType:< Object;
     param: ^paramType;
     value: @Boolean
  enter param[]     
  do INNER 
  exit value
  #);

--- menuLib:attributes ---

moveableMenuItem: menuItem
  (# onSelectAction: ##moveableMenuItemAction;
     onStatusAction: ##moveableMenuItemOnStatus;
     paramType:< Object;
     param: ^paramType;
     open::<
       (# itemname: ^Text;
       enter (onSelectAction##,onStatusAction##,param[],itemname[])
       do THIS(moveableMenuItem)[]->append;
          itemname[]->name;
          INNER;
       #);
     eventHandler::<
       (# onSelect::<
            (# 
            do (if onSelectAction##<>NONE then 
                   param[]->onSelectAction->checked
               if);
               INNER;
            #);
          onStatus::<
            (# 
            do (if onStatusAction##<>NONE then
                   param[]->onStatusAction->value
               if);
               INNER;
            #);
       #);
  #);

actionList: List 
  (# element:: (# action: ##Object #);
     appendAction:
       (# new: ^element;
          action: ##Object;
       enter action##
       do &element[]->new[];
          action##->new.action##;
          new[]->append;
       #);
  #);
