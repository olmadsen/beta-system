ORIGIN '../objectview';

INCLUDE '../listmoveable';
INCLUDE '../../objectdb';
INCLUDE '../../options';
INCLUDE '../../attributevisitor';
INCLUDE '../../dumpvisitor';
INCLUDE '~beta/containers/v1.6/list';
INCLUDE '~beta/guienv/v1.6/utils/prompts';

--- objectViewDoUpdate:dopart ---
do (if iconified then
       TRUE->ovprivate.updateDeferred
    else
       writeObj
   if);
   
--- objectViewOnIconify:dopart ---
do 
   
   
--- objectViewOnDeIconify:dopart ---
do
   (if ovprivate.updateDeferred then
       writeObj; FALSE->ovprivate.updateDeferred;
   if)
       
--- objectViewLib: attributes ---

openInLine:
  (# father: ^complexAttribute;
     att: ^attribute;
     visibilityChanged: @Boolean;
  enter att[]
  do (if att.visibilityLevel <> ATT_VISIBLE then
         ATT_VISIBLE->att.setvisibility;
         TRUE->visibilityChanged;
     if);
         
     att.father[]->father[];
     loop:
       (if father[]<>NONE then
           (if father.visibilityLevel<>ATT_VISIBLE then
               ATT_VISIBLE->father.setvisibility;
               TRUE->visibilityChanged;
           if);
           father.father[]->father[];
           restart loop;
       if);
     (if visibilityChanged then writeObj if);
  #);

isVisible: 
  (# att: ^attribute;
     value: @Boolean;
  enter att[]
  do TRUE->value;
     loop:
       (if att[]<>NONE then
           (if att.visibilityLevel<>ATT_VISIBLE then 
               FALSE->value; leave loop; 
           if);
           att.father[]->att[];
           restart loop;
       if);
  exit value
  #);

openObjectView:
  (# bo: ^betaObject; separate: @Boolean;
     found: @Boolean;
     odb: ^objectDB;
  enter (bo[],separate)
  do
     (if not bo.isNone then
         (if separate then
             getobjectDB -> odb[];
             doscan: odb.scanObjects
               (# 
               do (if bo[]->current.bo.equal then
                      current.scanOwners
                      (# 
                      do 
                         (if bo[]->current.isRootObject then
                             TRUE -> found;
                             bo[]->current.doShowObject;
                         if);
                      #);
                      leave doscan;
                  if);
               #);
             (if not found then
                 (bo[],TRUE)->encl.newObjectView;
             if);
          else
             (if ovprivate.browsemode then
                 bo[]->ovprivate.browsestack.newRoot;
                 writeObj;
              else
                 (bo[],FALSE)->encl.newObjectView;
             if);
         if);
     if)
  #);

openPatternView:
  (# bp: ^betaPattern
  enter bp[]
  do (* ... *)
  #);

openRefRep:
  (# att: ^simpleRepetitionAttribute; (* RefRepAttribute. *)
     index: @Integer;
     separate: @Boolean;
     bo: [1]^betaObject;
  enter (att[],index,separate)
  do (att.offset,index,index)->att.father.bo.ReferenceRepAttr->bo;
     (bo[1][],separate) -> openObjectView;
  #);

openStatObjectRep:
  (# att: ^simpleRepetitionAttribute; (* RefRepAttribute. *)
     index: @Integer;
     separate: @Boolean;
     bo: [1]^betaObject;
  enter (att[],index,separate)
  do (att.offset,index,index)->att.father.bo.StatObjectRepAttr->bo;
     (bo[1][],separate) -> openObjectView;
  #);

openPatRefRep:
  (# att: ^simpleRepetitionAttribute; (* PatRefRepAttribute. *)
     index: @Integer;
     bp: [1]^betaPattern;
  enter (att[],index)
  do (att.offset,index,index)->att.father.bo.PatRefRepAttr->bp;
     bp[1][] -> openPatternView;
  #);

openStatRef:
  (# att: ^complexAttribute;
     separate: @Boolean;
  enter (att[],separate)
  do (att.bo[],separate)->openObjectView;
  #);

openPatRef:
  (# att: ^attribute; (* PatRefAttribute *)
  enter att[]
  #);

openDynRef:
  (# att: ^attribute; (* origin, dynamic or dynamic component reference !!*)
     separate: @Boolean;
  enter (att[],separate)
  do (att.offset->att.father.bo.ReferenceAttr,separate)
       ->openObjectView;
  #);

separatable: (* If true, a separate viewer may be opened on att. *)
  (# att: ^attribute; value: @Boolean;
  enter att[]
  do (if att.attType
      //DynRefAttribute//StatRefAttribute//DynCompRefAttribute
      //StatCompRefAttribute//CompRepAttribute
      //OriginAttribute//RefRepAttribute
      //PatRefRepAttribute//PatRefAttribute then
         TRUE -> value
      else
         FALSE -> value
     if);
  exit value
  #);

contractAttribute:
  (# att: ^attribute;
  enter att[]
  do
     ATT_CONTRACTED->att.setvisibility;
     writeObj;
  #);

hideAttribute:
  (# att: ^attribute
  enter att[]
  do
     ATT_INVISIBLE->att.setVisibility; 
     writeObj
  #);

computeLine:
  (* Compute the line number corresponding to attribute. *)
  (# att: ^attribute; 
     line: @Integer;
  enter att[]
  do (if att[]//root[] then
         0->line;
      else
         compute:
           (# foreachLine: @oneTypeVisitor
                (# onAll:: 
                     (# 
                     do line+1->line;
                        (if att[]//THIS(computeLine).att[] then
                          leave compute
                        if);
                     #);
                #);
           do (if root[]<>NONE then forEachLine[]->root.scanVisibleAttributes if);
         #);
     if)
  exit line
  #);
   
deregisterObjects:
  (* Deregister all objects in ra for which this objectview
   * is registered as owner. *)
  (# ra: ^rootAttribute;
     v: @attributeVisitor
       (# onComplex:
            (# att: ^complexAttribute;
            enter att[]
            do 
               findObj: ovprivate.odb.scanObjects
                 (# 
                 do (if current.bo[]->att.bo.equal then
                        current.scanOwners 
                        (# 
                        do (current[]=ovprivate.owner[])->delete 
                        #);
                        leave findObj;
                    if);
                 #);
            #);
          onStatRef:: (# do att[]->onComplex #);
          onStatCompRef:: (# do att[]->onComplex #);
       #);
  enter ra[]
  do v[]->ra.scanKnownComplexAttributes;
  #);

flipBrowseMode:
  (# 
  do (if ovprivate.browsemode then
         ovprivate.browsestack.doclear;
         FALSE -> ovprivate.browsemode;
      else
         TRUE -> ovprivate.browsemode;
     if);
  #)

--- ovprivate:descriptor ---
(# odb: ^objectDB; (* Database of betaObjects in this process. *)
   lc: @Integer;   (* Current number of lines in scrolllist *)
   
   updateDeferred: @Boolean; 
   (* TRUE iff doUpdate was called while iconified. *)
   
   isGarbage: @Boolean;
   curItem: @Integer; (* set to selection.first by onMouseDown. *)
   
   browsemode: @Boolean; 
   browsestack: @list 
     (# element::
          (# root: ^rootAttribute;
             isGarbage: @Boolean;
             curItem: @Integer;
             (* Number of attribute curItem to push this element on the 
              * browsestack. *)
          #);

        newRoot:
          (# bo: ^betaObject; new: ^element;
          enter bo[]
          do 
             (if root[]<>NONE then 
                 &element[]->new[];
                 root[]->new.root[];
                 FALSE->new.isGarbage;
                 curItem->new.curItem;
                 new[]->prepend;
             if);
             
             (if (bo[]<>NONE) and ((bo[]->bo.dumper.betaObjectObjectDescriptor)<>NONE) then
                 (bo[],getOptionDB) -> buildObjectRepresentation
                 (# rootAttributeType:: rootType;
                 #) -> root[];
                 (root[],FALSE)->encl.onObjectChange;
              else
                 (* Type of object unknown, probably due to old or missing
                  * fragment group. *)
                 NONE->root[];
                 (root[],FALSE)->encl.onObjectChange;
                 (bo[],FALSE)->encl.onLowLevelObjectChange;
            if);
             selection.clear;
          #);

        poproot:
          (# title: ^Text; dummy: @Boolean;
             prev: ^element;
          do (if root[]<>NONE then root[]->deregisterObjects if);
             (head->delete).elm[] -> prev[];
             
             prev.root[]->root[]; prev.isGarbage->isGarbage;
             (root[],isGarbage)->encl.onObjectChange;
             
             selection.clear;
             
             (if not isGarbage then 
                 writeObj;
                 (prev.curItem->curItem,FALSE)->selection.select;
                 selection.scrollIntoView;
              else
                 (* Clear the window: *)
                 numberOfItems->deleteFirst;
             if)
          #);
        
        doclear:
          (# 
          do scan 
             (# 
             do (if not current.isGarbage then
                    current.root[]->deregisterObjects 
                if)
             #);
             clear;
          #);
     #);
   
   
   owner: @objectOwner
     (# onObjectIsGarbage::
          (# found: @Boolean; att: ^attribute;
          do 
             (if browsemode then 
                 (* Find and mark all roots on the browse-stack that have
                  * become garbage: *)
                 browsestack.scan
                 (# 
                 do (if not current.isGarbage then
                        (bo[],current.root[])->hasObject
                          ->(current.isGarbage,att[]);
                    if);
                 #);
             if);
             
             (* Then check if the object currently on view has 
              * become garbage: *)
             
             (if not isGarbage then
                 (bo[],root[])->hasObject->(isGarbage,att[]);
                 (if isGarbage then
                     (root[],isGarbage)->encl.onObjectChange;
                 if);
             if);
          #);
        hasObject::
          (# foundAtt: ^attribute;
             useroot: ^rootType; (* Default is the current root. *)
          enter useroot[]
          do (if useroot[]=NONE then root[]->useroot[] if);
             dofind:
               (# v: @attributeVisitor
                    (# onComplex:
                         (# att: ^complexAttribute;
                         enter att[]
                         do (if bo[]->att.bo.equal then
                                att[]->foundAtt[];
                                leave dofind;
                            if);
                         #);
                       onStatRef:: (# do att[]->onComplex #);
                       onStatCompRef:: (# do att[]->onComplex #);
                    #);
               do v[]->useroot.scanKnownComplexAttributes;
               #);
             foundAtt[]<>NONE -> value;
          exit foundAtt[]   
          #);
        hasVisible::
          (# att: ^attribute; value: @Boolean;
          do (bo[],NONE)->hasObject->(value,att[]);
             (if value then att[]->isVisible->value if);
          exit att[]
          #);
        isRootObject:: (# do ((root[]<>NONE) and (bo[]->root.bo.equal))->value #);
        doShowObject::
          (# att: ^complexAttribute;
             line: @Integer;
             hasobj: @Boolean;
          do
             (bo[],NONE)->hasObject->(hasobj,att[]);
             (if hasobj then 
                 (* Make sure the attribute is visible: *)
                 att[]->openInLine;
                  
                 (* Select and deselect the lines composing object: *)
                 att[]->computeLine->line;
                 
                 (* Select the lines corresponding to att: *)
                 selection.clear;
                 (for i:att.lineCount repeat
                      (i+line-1,TRUE)->selection.select;
                 for);
                 
                 (if line>1 then
                     (* Ensure if possible that the first line displayed 
                      * is not highlighted: *) 
                     (line-1,TRUE)->selection.select;
                     selection.scrollIntoView;
                     line-1->selection.deselect;
                  else
                     selection.scrollIntoView;
                 if);
                 encl.onHighLight;
                 TRUE->THIS(objectView).update;
                 15->system.wait;
                 selection.clear;
                 (if line<>0 then (line,TRUE)->selection.select if);
                 TRUE->THIS(objectView).update;
             if);
          #);
     #)
#)
  
--- objectviewOpen:descriptor ---
(# ol: ^objectViewList;
do 
   'fastBrowseMode'->(getOptionDB).getBooleanOption
   (# found:: (# do value->ovprivate.browsemode #)#);
   getencloser;
   itemMenu.onOpen.init; itemMenu.onPopup.init;
   encl.getObject -> bo[];
   getObjectDB -> ovprivate.odb[];
   ovprivate.browsestack.init;
   bo[]->ovprivate.browsestack.newRoot;
   (if root[]<>NONE then
       numberOfItems -> ovprivate.lc;
       writeObj;
       INNER open;
       getObjectViewList->ol[];
       THIS(objectView)[]->ol.onInsert;
       THIS(objectView)[]->ol.append
   if);
#)

--- moveableObjectViewonObjectChange:descriptor ---
(# newtitle: ^Text;
   shortnames,numbernames,hideOrigins: @Boolean;
do
   getOptionDB->getPreferences->(shortnames,numbernames,hideOrigins);
   (if root[]<>NONE then
       root.bo[]->theBo[];
       ((shortnames,numbernames)->root.bo.description).copy->newtitle[];
       (if root.bo.isComponentObject then
           ' component'->newTitle.append;
       if);
    else 'OBJECT is NONE: '->newtitle[]
   if);
   
   (if isGarbage then
       'GARBAGE: ' -> newtitle.prepend;
       contents.list.disable;
    else 
       (if not contents.list.enabled then
           contents.list.enable;
       if);
   if);
   newTitle[]->THIS(moveableObjectView).title;
#)

--- moveableObjectViewonLowlewelObjectChange:descriptor ---
(# newtitle: ^Text;
   shortnames,numbernames,hideOrigins: @Boolean;
do
   getOptionDB->getPreferences->(shortnames,numbernames,hideOrigins);
   ((shortnames,numbernames)->bo.description).copy->newtitle[];
   (if bo.isComponentObject then
       ' component'->newTitle.append;
   if);
   
   (if isGarbage then
       'GARBAGE: ' -> newtitle.prepend;
       contents.list.disable;
    else 
       (if not contents.list.enabled then
           contents.list.enable;
       if);
   if);
   'LOW LEVEL VIEW: '->newtitle.prepend;
   newTitle[]->THIS(moveableObjectView).title;
   
   (* THIS IS A HACK!!! HANDLING OF LOW LEVEL VIEWS NEED MUCH MORE
    * CONSIDERATION. PROBABLY WE'll DIE IN A MOMENT DUE TO ROOT
    * BEING NONE!! *)
#)

--- ObjectViewClose:dopart ---
do (if itemmenu.imprivate.opened then itemMenu.close if);
   (if ovprivate.browsemode then ovprivate.browsestack.doclear if);
   ovprivate.owner[]->ovprivate.odb.removeObjectOwner;
   (# ol: ^objectViewList;
   do 
      getObjectViewList->ol[];
      THIS(objectView)[]->ol.at->ol.delete;
      THIS(objectView)[]->ol.onDelete;
   #);
   
--- objectViewOnComplexCreate:dopart ---
do (att.bo[],ovprivate.owner[])->ovprivate.odb.addObjectOwner

--- objectViewWriteObject:descriptor ---
(# dovisit: @dumpVisitor 
     (# forEachLine::  (# do (index,line[]) -> setText #)#);
   rootlc: @integer;
do (if not ovprivate.isGarbage then
       hide;
       (if root[]<>NONE then root.lineCount->rootlc if);
       (if ovprivate.lc <> rootlc then
           (if rootlc > ovprivate.lc then
               (rootlc-ovprivate.lc) -> prepend;
            else
               (1, ovprivate.lc-rootlc) -> delete
           if);
           rootlc -> ovprivate.lc;
       if);
       (if root[]<>NONE then
           root.options[]->dovisit.init;
           dovisit[]->root.scanVisibleAttributes;
       if);
       show;
   if);
#)

--- objectViewOnSelect:dopart ---
do item->ovprivate.curItem;
   
--- objectViewOnMouseDown:descriptor ---
(# 
do 
   (if not ovPrivate.isGarbage then
       
       (if buttonState 
        //1 then
           (if doubleClick then
               (# doOnClick: @attributeVisitor
                    (# onDynRef:: (# do (att[],FALSE)->openDynRef #);
                       onDynCompRef:: (# do (att[],FALSE)->openDynRef #);
                       onOriRef::(# do (att[],FALSE)->openDynRef #);
                       onComplex:
                         (# att: ^complexAttribute;
                         enter att[]
                         do (if att.visibilityLevel
                             //ATT_CONTRACTED then
                                (* Check whether this attribute is already on sight
                                 * in some other owner. If so, give some visual 
                                 * feedback according to this fact instead of opening
                                 * inline. *)
                                doscan: ovprivate.odb.scanObjects
                                  (# found: @Boolean;
                                  do (if att.bo[]->current.bo.equal then
                                         current.scanOwners
                                         (# 
                                         do (if current[]<>ovprivate.owner[] then
                                                (if att.bo[]->current.hasObject then
                                                    att.bo[]->current.doShowObject;
                                                    TRUE -> found;
                                                if);
                                            if);
                                         #);
                                         (if not found then att[]->openInline if);
                                         leave doscan;
                                     if);
                                  #);
                             //ATT_VISIBLE then
                                att[]->contractAttribute;
                            if);
                         #);
                       onStatRef:: (# do att[]->onComplex #);
                       onStatCompRef:: (# do att[]->onComplex #);
                       onPatRef:: (# do att[]->openPatRef #);
                       onRepRef::
                         (# 
                         do (if att.visibilityLevel
                             //ATT_CONTRACTED then att[]->openInLine;
                             //ATT_VISIBLE then att[]->contractAttribute;
                            if);
                         #);
                       onRepRefHiddenBefore::
                         (# 
                         #);
                       onRepRefHiddenAfter::
                         (# 
                         #);
                       onRepDynRef:: (# do (att[],index,FALSE)->openRefRep #);
                       onRepDynCompRef:: (# do (att[],index,FALSE)->openRefRep #);
                       onRepStatItemRef:: (# do (att[],index,FALSE)->openStatObjectRep #);
                       onRepStatCompRef:: (# do (att[],index,FALSE)->openStatObjectRep #);
                       onRepPatRef:: (# do (att[],index)->openPatRefRep #);
                    #);
                  line: @Integer;
               do
                  (if (selection.first->line) <> 0 then
                      (if root[]<>NONE then
                          (line,doOnClick[]) -> root.visitAttributeByNumber
                      if);
                  if);
               #);
           if)
           
        //3 then
           (# onVisit: @sevenTypeVisitor
                (# onSimple:: 
                     (# openSeparate: 
                          (# 
                          do (if att.attType
                              //DynRefAttribute
                              //DynCompRefAttribute
                              //originAttribute then
                                 (att[],TRUE)->openDynRef
                              //PatRefAttribute then
                                 att[]->openPatRef
                             if);
                          #);
                     do (if att[]->separatable then
                            (att[],openSeparate##)->popup;
                         else
                            (att[],NONE)->popup
                        if);
                     #);
                   onComplex:: 
                     (# openSeparate: (# do (att[],TRUE)->openStatRef #);
                     do (if att[]<>root[] then
                            (att[],openSeparate##)->popup
                         else
                            (att[],NONE)->popup
                        if)
                     #);
                   onPatRef:: 
                     (# openSeparate: (# do att[]->openPatRef #);
                     do (att[],openSeparate##)->popup
                     #);
                   onRepRef:: 
                     (# 
                     do (att[],NONE)->popup
                     #);
                   onRepRefElm::
                     (# openSeparate: (# do (att[],index,TRUE)->openRefRep #);
                     do (att[],openSeparate##)->popup
                     #);
                   onRepRefHiddenBefore:: (# #);
                   onRepRefHiddenAfter:: (# #);
                   
                   popup:
                     (# att: ^attribute;
                        openSeparate: ##Object;
                     enter (att[],openSeparate##)
                     do 
                        (1,localposition,THIS(objectView)[],att[],openSeparate##)
                          ->itemMenu.doPopup;
                     #);
                #);
           do (if root[]<>NONE then
                  (ovprivate.curItem,onVisit[]) -> root.visitAttributeByNumber
              if);
           #);
       if);
   if)
#)

--- movGetFather: dopart ---
do THIS(moveableObjectView).father[] -> father[];
   
--- openMoveableObjectView:descriptor ---
(# odb: ^objectDB;
   mov: ^moveableObjectView;
   found: @Boolean;
   defaultRect: @rectangle;
   dragOutlineOnOpen: @Boolean;
   f: ^Canvas;
   doopen:
     (# 
     do &MoveableObjectView[]->mov[];
        (getFather,defaultRect,bo[]) -> mov.open;
     #);
do 
   (if not force then
       getobjectDB -> odb[];
       doscan: odb.scanObjects
         (# 
         do (if bo[]->current.bo.equal then
                current.scanOwners
                (# 
                do (if bo[]->current.hasObject then
                       bo[]->current.doShowObject;
                       TRUE -> found;
                   if);
                #);
                leave doscan;
            if);
         #);
   if);
   
   (if not found then
       'DragOutLine'->(getOptionDB).getBooleanOption
       (# found:: (# do value->dragOutlineOnOpen #);
          notfound:: (# do true->dragOutlineOnOpen #);
       #);
       ((0,0),(200,100))->defaultRect;
       (if dragOutlineOnOpen then
           getFather->f[];
           
           defaultRect->f.getOutline
           (# done:: 
                (# 
                do result->defaultRect; 
                   doopen
                #)
           #);
           
           
           
        else
           doopen;
       if);
   if);
#)
   
--- menuLib: attributes ---

showItem: menuItem 
  (# doConTractAttribute:< (# att: ^attribute enter att[] do INNER #);
     doOpenInLine:< (# att: ^attribute enter att[] do INNER #);
     
     att: ^attribute;
     computed: @Boolean;
     
     open:: 
       (#
       do 'Show Attribute' -> name;
          showSub.open;
          showSub[] -> submenu;
       #);
     
     close:: (# do showSub.close #);
     
     eventHandler:: 
       (# onStatus:: 
            (# 
            do (if att[]<>NONE then
                   att.isComplex -> value
                else
                   FALSE->value;
               if);
            #);
          onSelect::
            (# 
            do 'showItem.onSelect called'->putline;
            #);
       #);
     
     prepare:
       (# 
       enter att[]
       do showSub.clear;
          false->computed;
          (*!!!showSub.compute;*)
       #);
     
     showSub: @menu
       (# eventHandler::
            (# onSelect:: 
                 (# 
                 do (if not computed then compute if);
                 #);
            #);
          attItem: menuItem 
            (# att: ^attribute;
               open::
                 (# 
                 do THIS(attItem)[]->append; att.attname[]->name; 
                 #);
               eventHandler::
                 (# onSelect::
                      (# 
                      do (if att.isComplex then
                             att[]->doContractAttribute;
                          else
                             att[]->doOpenInLine;
                         if);
                      #);
                 #);
            #);
          empty: menuItem 
            (# open::
                 (# 
                 do THIS(empty)[]->append;
                    'No Hidden Attributes'->name;
                 #);
               eventHandler:: (# onStatus:: (# do false -> value #)#)
            #);
          compute:
            (# visit: oneTypeVisitor
                 (# onAll::
                      (# ai: ^attItem;
                      do &attItem[]->ai[]; att[]->ai.att[]; ai.open; 
                         true->nonEmpty;
                      #);
                 #);
               nonEmpty: @Boolean;
               mi: ^menuItem;
               catt: ^complexAttribute;
            do (if att[]<>NONE then
                   (if att.isComplex then
                       &visit[]->(att[]->catt[]).scanInvisibleAttributes;
                   if);
               if);
               (if not nonEmpty then &empty[]->mi[]; mi.open if);
               TRUE->computed;
            #);
       #);
  #)

--- itemMenuAttributes: attributes ---
doPopup: 
  (# popupWith: @integer;
     popupAt: @point;
     popupIn: ^windowItem;
     att: ^attribute;
     openSeparateAtt: ##Object;
  enter (popupWith,popupAt,popupIn[],att[],openSeparateAtt##)
  do (if not imprivate.opened then open if);
     (att[],openSeparateAtt##)->(targetatt[],imprivate.openSeparateAtt##);
     (if att[]<>root[] then
         att[]->imprivate.theShowItem.prepare;
      else
         NONE->imprivate.theShowItem.prepare;
     if);
     onPopup.scan (# do current.action #);
     (popupWith,popupAt,popupIn[])->popup;
  #);

hideAction: actionedMenuItemAction
  (# 
  do (if hideOnStatus then targetatt[]->hideAttribute if);
  #);
hideOnStatus: actionedMenuItemOnStatus
  (# 
  do (targetatt[] <> root[])->value
  #);

changeAction: actionedMenuItemAction
  (# value,msg: @Text;
  do (if changeOnStatus then 
         (if targetatt.attType
          //CharAttribute then
             (# charprompt: @PromptForText
                  (# validate:: (# do usertext.length=1->value #);
                     ok::
                       (# 
                       do usertext.reset; 
                          (targetatt.offset,usertext.get)
                            ->targetatt.father.bo.SetCharAttr;
                          writeObj;
                       #);
                  #);
             do
                targetatt.offset->targetatt.father.bo.CharAttr->value.put;
                charprompt.open;
                
                'Changing char attribute '''->msg; 
                targetatt.attName[]->msg.append;
                ''''->msg.append;
                (THIS(Window)[],'Change Char Attribute',msg[],value[])
                  ->charprompt.popup;
                
                charprompt.close;
             #);
             
          //IntegerAttribute then
             (# intprompt: @PromptForInteger
                  (# ok::
                       (# 
                       do (targetatt.offset,userinteger)
                            ->targetatt.father.bo.SetIntegerAttr;
                          writeObj;
                       #);
                  #);
             do 
                targetatt.offset->targetatt.father.bo.IntegerAttr
                  ->value.putint;
                intprompt.open;
                
                'Changing integer attribute '''->msg; 
                targetatt.attName[]->msg.append;
                ''''->msg.append;
                (THIS(Window)[],'Change Integer Attribute',msg[],value[])
                  ->intprompt.popup;
                
                intprompt.close;
             #);
         if);
     if);
  #);
changeOnStatus: actionedMenuItemOnStatus
  (# 
  do (targetatt.attType=CharAttribute) or (targetatt.attType=IntegerAttribute)
       ->value;
  #);

openInlineAction: actionedMenuItemAction
  (# 
  do (if openInlineOnStatus then targetatt[]->openInline if);
  #);
openInlineOnStatus: actionedMenuItemOnStatus
  (# 
  do (targetatt[] <> root[]) and (targetatt.isComplex) 
     and (targetatt.visibilityLevel=ATT_CONTRACTED)->value
  #);

contractAction: actionedMenuItemAction
  (# 
  do (if contractOnStatus then targetatt[]->contractAttribute if);
  #);
contractOnStatus: actionedMenuItemOnStatus
  (# 
  do (targetatt[] <> root[]) and (targetatt.isComplex)
     and (targetatt.visibilityLevel=ATT_VISIBLE)->value;
  #);

openSeparateAction: actionedMenuItemAction
  (# 
  do (if openSeparateOnStatus then imPrivate.openSeparateAtt if);
  #);
openSeparateOnStatus: actionedMenuItemOnStatus
  (# 
  do (imPrivate.openSeparateAtt##<>NONE)->value;
  #);

itemMenuShowItem: showItem
  (# doConTractAttribute:: (# do att[]->contractAttribute #);
     doOpenInLine:: (# do att[]->openInLine #);
  #);

--- itemMenuOpen:descriptor ---
(# mi: ^actionedMenuItem;
do 
   &actionedMenuItem[]->mi[];
   (openSeparateAction##,openSeparateOnStatus##,NONE,'Open Separate')->mi.open;
   &actionedMenuItem[] -> mi[]; 
   (openInlineAction##,openInlineOnStatus##,NONE,'Open Inline')->mi.open;
   &actionedMenuItem[] -> mi[];
   (contractAction##,contractOnStatus##,NONE,'Contract Attribute')->mi.open;
   &actionedMenuItem[] -> mi[]; 
   (hideAction##,hideOnStatus##,NONE,'Hide Attribute')->mi.open; 
   &actionedMenuItem[] -> mi[];
   (changeAction##,changeOnStatus##,NONE,'Change Attribute')->mi.open;
      
   &itemMenuShowItem[]->imPrivate.theShowItem[]; 
   imPrivate.theShowItem.open; 
   imPrivate.theShowItem[]->append;
   
   onOpen.scan (# do current.action #);
   
   INNER open;
   
   TRUE->imprivate.opened;
#)

--- itemMenuClose:dopart ---
do imprivate.theShowItem.close
   
--- itemMenuPrivate:descriptor ---
(# openSeparateAtt: ##Object;
   theShowItem: ^itemMenuShowItem;
   opened: @Boolean;
#)

--- moveableObjectViewMenuLib: attributes ---

moveableMenuShowItem: showItem
  (# doConTractAttribute::
       (# 
       do att[]->contents.list.contractAttribute 
       #);
     doOpenInLine::
       (# 
       do att[]->contents.list.openInLine 
       #);
  #);

fastBrowseAction: actionedMenuItemAction
  (# 
  do contents.list.flipBrowseMode;
     contents.list.ovprivate.browsemode->checked;
  #);

gobackAction: actionedMenuItemAction
  (# 
  do (if gobackOnStatus then contents.list.ovprivate.browsestack.poproot if)
  #);
gobackOnStatus: actionedMenuItemOnStatus
  (# 
  do contents.list.ovprivate.browsemode 
     and not contents.list.ovprivate.browsestack.empty -> value;
  #);
 
prepareroot:
  (# 
  do contents.list.root[]->movmPrivate.theShowItem.prepare;
  #);   

--- moveableObjectViewMenuPrivate: descriptor ---
(# theShowItem: ^moveableMenuShowItem;
#)

--- moveableObjectViewMenuOpen: descriptor ---
(# mi: ^actionedMenuItem;
do 
   &moveableMenuShowItem[]->movmPrivate.theShowItem[]; 
   movmPrivate.theShowItem.open; 
   movmPrivate.theShowItem[]->append;
   
   prepareroot##->onPopup.appendAction;
   
   &actionedMenuItem[]->mi[];
   (fastBrowseAction##,NONE,NONE,'Fast Browse Mode')->mi.open;
   contents.list.ovprivate.browsemode->mi.checked;
      
   &actionedMenuItem[]->mi[];
   (gobackAction##,gobackOnStatus##,NONE,'Go Back')->mi.open;
   
   INNER open;
#)

--- moveableObjectViewMenuClose: dopart ---
do movmPrivate.theShowItem.close;
