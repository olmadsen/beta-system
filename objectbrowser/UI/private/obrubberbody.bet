ORIGIN '../obrubber';
INCLUDE '~beta/guienv/v1.2/graphics';

-- DefineRectBody: Descriptor --
(# 
do 
   graphics
   (# 
   do trackMouse
      (# wasOutside: @Boolean;
         dl,dr,dt,db,dtl,dbl,dtr,dbr,nearest: @Integer;
         h1,v1,h2,v2: @integer;
         corner: @Integer;
         chkPt: @point;
         theAbs: @abs;
         theMin: @min;
         theMax: @max;
         
         MousePress::
           (#
           do Patterns.gray[] -> Pen.stipple; 
              TransferModes.xorBlend[] -> Pen.mode;
              2 -> pen.size;
              theRect -> drawRect;
           #);
         
         MouseMove::
           (#
           do 
              (if curPt -> prevPt.isEqual then 
                  leave MouseMove 
              if);
              
              (if not (curPt -> theRect.containsPoint) then
                  true -> wasOutside;
              if);
              
              (if wasOutside then
                  theRect -> drawRect;
                  
                  (if corner //0 then
                      (curPt.h - theRect.left) -> theAbs -> dl;
                      (curPt.h - theRect.right) -> theAbs -> dr;
                      (curPt.v - theRect.top) -> theAbs -> dt;
                      (curPt.v - theRect.bottom) -> theAbs -> db;
                  
                      dl*dl+dt*dt -> dtl;
                      dl*dl+db*db -> dbl;
                      dr*dr+dt*dt -> dtr;
                      dr*dr+db*db -> dbr;
                  
                      dtl -> nearest;
                      (if dbl < nearest then dbl -> nearest if);
                      (if dtr < nearest then dtr -> nearest if);
                      (if dbr < nearest then dbr -> nearest if);
                      
                      (if nearest
                       //dtl then
                          (if dl < dt then curPt.h -> theRect.left;
                           else curPt.v -> theRect.top;
                          if);
                          curPt -> chkPt;
                          (if not (curPt -> theRect.containsPoint) then
                              (* Update the other and say we have a corner *)
                              (if dl < dt then curPt.v -> theRect.top;
                               else curPt.h -> theRect.left;
                              if);
                              1 -> corner;
                          if);
                       //dbl then
                          (if dl < db then curPt.h -> theRect.left;
                           else curPt.v -> theRect.bottom;
                          if);
                          (curPt.h,curPt.v-1) -> chkPt;
                          (if not (chkPt -> theRect.containsPoint) then
                              (* Update the other and say we have a corner *)
                              (if dl < db then curPt.v -> theRect.bottom;
                               else curPt.h -> theRect.left;
                              if);
                              2 -> corner;
                          if);
                       //dtr then
                          (if dr < dt then curPt.h -> theRect.right;
                           else curPt.v -> theRect.top;
                          if);
                          (curPt.h-1,curPt.v) -> chkPt;
                          (if not (chkPt -> theRect.containsPoint) then
                              (* Update the other and say we have a corner *)
                              (if dr < dt then curPt.v -> theRect.top;
                               else curPt.h -> theRect.right;
                              if);
                              3 -> corner;
                          if);
                       //dbr then
                          (if dr < db then curPt.h -> theRect.right;
                           else curPt.v -> theRect.bottom;
                          if);
                          (curPt.h-1,curPt.v-1) -> chkPt;
                          (if not (chkPt -> theRect.containsPoint) then
                              (* Update the other and say we have a corner *)
                              (if dr < db then curPt.v -> theRect.bottom;
                               else curPt.h -> theRect.right;
                              if);
                              4 -> corner;
                          if);
                      if);
                      
                   //1 then curPt.h->theRect.left; curPt.v->theRect.top;
                   //2 then curPt.h->theRect.left; curPt.v->theRect.bottom;
                   //3 then curPt.h->theRect.right; curPt.v->theRect.top;
                   //4 then curPt.h->theRect.right; curPt.v->theRect.bottom;
                  if);
                  (theRect.top, theRect.bottom) -> theMin -> h1;
                  (theRect.Left, theRect.Right) -> theMin -> v1;
                  (theRect.top, theRect.bottom) -> theMax -> h2;
                  (theRect.Left, theRect.Right) -> theMax -> v2;
                  (v1,h1,v2,h2) -> theRect.set;     
                  theRect -> drawRect;
              if);
           #);
         MouseRelease::
           (# 
           do theRect -> drawRect;
           #);
      #);
   #);
#)

-- SimpleDefineRectBody: Descriptor --
(#
do (p,p) -> theRect;
   graphics
   (# 
   do trackMouse
      (# MousePress::
           (#
           do Patterns.gray[] -> Pen.stipple; 
              TransferModes.xorBlend[] -> Pen.mode;
              theRect -> drawRect;
           #);
         MouseMove::
           (#
           do theRect -> drawRect;
              (h,v) -> theRect.BottomRight.Add;
              theRect -> drawRect;
           #);
         MouseRelease::
           (# h1,v1,h2,v2: @integer;
           do (theRect.top, theRect.bottom) -> min -> h1;
              (theRect.Left, theRect.Right) -> min -> v1;
              (theRect.top, theRect.bottom) -> max -> h2;
              (theRect.Left, theRect.Right) -> max -> v2;
              (v1,h1,v2,h2) -> theRect.set;
              theRect -> drawRect;
           #);
      #);
   #);
#)
   
--- browserrubberdrawRect:dopart ---
do graphics
   (# 
   do Patterns.gray[] -> Pen.stipple; 
      TransferModes.xorBlend[] -> Pen.mode;
      theRect -> drawRect;
   #);
