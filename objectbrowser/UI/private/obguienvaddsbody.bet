ORIGIN '../obguienvadds';

MDBODY mac     'obguienvadds_macbody'
       ppc     'obguienvadds_macbody'
       ppcmac  'obguienvadds_macbody'
       nti     'obguienvadds_ntibody'
       default 'obguienvadds_X11body';
INCLUDE '~beta/sysutils/v1.6/envstring';
INCLUDE '../icons';

INCLUDE '~beta/guienv/v1.6/utils/graphicsadds';
(* graphics.clipChildren *)

--- guienvlib:attributes ---
stripeslist:
  (# stripes: [8] ^pixmap;
  #);

-- graphicalEditorGetStripes: doPart --
do  (#
       sl: ^stripeslist;
    do 
       objectPool.get
       (# type:: stripeslist;
          init::
            (# loadRaster:
                 (# iconName: ^text;
                    bm: ^pixmap;
                 enter iconName[]
                 do &pixmap[] -> bm[];
                    iconName[] -> makeIconFileName -> bm.read;
                 exit bm[]
                 #);
            do
               ('stripes1')->loadRaster->obj.stripes[1][];
               ('stripes2')->loadRaster->obj.stripes[2][];
               ('stripes3')->loadRaster->obj.stripes[3][];
               ('stripes4')->loadRaster->obj.stripes[4][];
               ('stripes5')->loadRaster->obj.stripes[5][];
               ('stripes6')->loadRaster->obj.stripes[6][];
               ('stripes7')->loadRaster->obj.stripes[7][];
               ('stripes8')->loadRaster->obj.stripes[8][];
            #);
       #)->sl[];
       sl.stripes->stripes;
    #)
   
--- VEUresizeRelative:descriptor ---
(# tmpFrame: @rectangle;
   ofw,ofh,nfw,nfh: @Integer;
do
   theEvent.oldFrame.size->(ofw,ofh);
   (* OldFatherWidth, OldFatherHeight *)
   
   theEvent.newFrame.size->(nfw,nfh);
   (* NewFatherWidth, NewFatherHeight *)
   
   frame->tmpFrame;
   
   ((tmpFrame.left*nfw) div ofw)->tmpFrame.left;
   ((tmpFrame.top*nfh) div ofh)-> tmpFrame.top;
   
   ((tmpFrame.right*nfw) div ofw)->tmpFrame.right;
   ((tmpFrame.bottom*nfh) div ofh)->tmpFrame.bottom;
   
   INNER resizeRelative;
   
   tmpFrame->frame;
#)

--- VEUitemPos:dopart ---
do (# cur: ^windowItem;
   do THIS(windowItem)[]->cur[];
      loop:
        (if cur[]<>NONE then
            cur.position->pos.add;
            cur.father[]->cur[];
            restart loop;
        if);
   #);

--- FrameDrawerLib:attributes ---
drawOutline: graphics
  (# pat: ^pixmap;
     h,v: @Integer;
     overrideChildren:: (# do true -> value #);
     (* Draw on top of children of THIS(canvas) *)
  enter pat[]
  do pat[]->Pen.stipple; 
     3->pen.size;
     size->(h,v);
     ((0,0),(h-1,v-1))->drawRect;
  #);

stripeOutline:
  (# draw: @drawOutline; 
     pats: [8]^pixmap; 
     curpat: @Integer;
  do 1->curpat; getStripes->pats;
     loop:
       (# 
       do pats[curpat][]->draw;
          20->fdprivate.cs.sleep;
          (if fdprivate.killed then fdprivate.cs.kill if);
          (curpat mod 8)+1->curpat;
          restart loop
       #);
  #);

frameRefreshAction: action
  (# eventType:: theEventHandler.refresh;
  do patterns.black[]->drawOutline;
  #);

--- FrameDrawerKill:dopart ---
do TRUE->fdprivate.killed;
   (if fdprivate.fra[]<>NONE then
       fdprivate.fra[]->deleteAction;
   if);
   (if doupdate then update if)

--- FrameDrawerPrivate:descriptor ---
(# cs: ^coroutinespawner;
   fra: ^frameRefreshAction;
   killed: @Boolean;
#)

-- FrameDrawerDo:dopart ---
do 
   (if useCoroutineSpawnerIfPresent and 
       ((getCoroutineSpawner->fdprivate.cs[])<>NONE)
       then
       fdprivate.cs.spawn (# do stripeOutline #);
    else
       patterns.black[]->drawOutLine;
       (&frameRefreshAction[]->fdprivate.fra[])->appendAction;
   if);
   
--- moveablegetOutline:descriptor ---
(# mouseDownAction: action
     (# eventType:: theeventHandler.MouseDown;
        mpos: @Point; center: @Point;
        kvadrant: @Point; h1,v1,h2,v2: @integer;
        oldvalue: @rectangle;
     do 
        (if drawnFirst then
            TRUE->inAction;
            theEvent.localPosition->mpos;
            draw;
            
            default->oldvalue;
            
            (if mpos->default.containsPoint then
                (* Drag the rectangle while the mouse is still down. *)
                draw;
                trackMouse
                (# (*grabMouse:: (# do false->value #);*)
                   mouseMove::
                     (# pos: @Point;
                     do (if curPt->mpos.isEqual then leave mouseMove if);
                        draw;
                        curPt->pos;
                        mpos->pos.subtract;
                        pos->default.offset;
                        draw;
                        curPt->mpos;
                     #);
                #);
             else
                (* Move the nearest corner of the rectangle to the mouse. *)
                ((default.left+default.right) div 2,
                (default.top+default.bottom) div 2)->center;
                mpos->kvadrant; center->kvadrant.subtract;
                
                (* Determine nearest corner. *)
                (if TRUE
                 //(kvadrant.h>=0) and (kvadrant.v>=0) then
                    mpos->(default.right,default.bottom);
                 //(kvadrant.h>=0) and (kvadrant.v<=0) then
                    mpos->(default.right,default.top);
                 //(kvadrant.h<=0) and (kvadrant.v<=0) then
                    mpos->(default.left,default.top);
                 else
                    mpos->(default.left,default.bottom);
                if);
                
                (* Ensure that we did not make an empty or "negative"
                 * rectangle: *)
                (if default.isempty then oldvalue->default if);
                
                (* Drag an outline *)
                (default,FALSE)->defineRect->default;
                TRUE->definitionDone;
                THIS(mouseDownAction)[]->deleteaction;
                NONE->mouse.busyCursor;
                unGrabPointer;
                default->done;
            if);
            
            FALSE->inAction;
        if);
     #);
   
   cs: ^coroutineSpawner;
   definitionDone,drawnFirst,inAction: @Boolean;
   
   pats: [8]^pixmap; curpat: @Integer;
   
   draw: @graphics
     (# (* Draw on top of children of THIS(canvas) *)
	 	overrideChildren:: (# do true -> value #);
     do pats[curpat][]->Pen.stipple; 
        TransferModes.xorBlend->Pen.mode;
        2->pen.size;
        default->drawRect;
        TRUE->drawnFirst;
     #);
   
   stripeOutline:
     (# 
     do 1->curpat; getStripes->pats;
        loop:
          (# 
          do draw;
             loop: (# do 15->cs.sleep; (if inAction then restart loop if) #);
             (if definitionDone then cs.kill if);
             draw;
             (curpat mod 8)+1->curpat;
             restart loop
          #);
     #);
      
do getCoroutineSpawner->cs[];
   THIS(window).bringToFront;
   grabPointer;
   (if cs[]<>NONE then
       cs.spawn (# do stripeOutline #);
       &mouseDownAction[]->prependaction;
       cursors.cross[]->mouse.busyCursor;
    else
       1->curpat; getStripes->pats;
       draw;
       &mouseDownAction[]->prependaction;
       cursors.cross[]->mouse.busyCursor;
   if);
#)
