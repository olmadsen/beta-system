ORIGIN '../psobjdumper';
INCLUDE '../RepObjAdds';

--- psbetapatternisnoneDopart: dopart ---
do (loc[]=NONE)->value
   
--- psbetapatternequalDopart: dopart ---
do (other.odote[],other.oriOffset,other.oriOID)->equalPred->value;
   
--- pdbetapatternoriginDopart: dopart ---
do (oriOID,oriOffset,dumper[])->newPSObject->value[];
   
--- psbetapatternsetoriginDopart: dopart ---
do value.OID->oriOID; value.offset->oriOffset;
   
--- psbetapatternequalpredDopart: dopart ---
do false->value;
   (if oodote.od[]->odote.od.equal then
       (if ooriOffset=oriOffset then
           (ooriOID,oriOID)->equalOID->value;
       if);
   if);
   
--- psbetaobjectdescriptiontypeDopart: dopart ---
do (if (betaenvOID,OID)->equalOID then
       'BETAENV (not saved)'->shortname[]->fullname[]
         ->shortWithNumber[]->fullWithNumber[];
   if);
   
--- psbetaobjectgetodDopart: dopart ---
do
   doget:
     (if offset<>0 then
         (for i:odote.partCount repeat
              (if odote.parts[i]//offset then
                  odote.ods[i][]->od[];
                  leave doget;
              if);
         for);
         'getOD: part offset not found'->putText;
         offset->putInt; newline;
      else
         odote.od[]->od[];
     if);
   
--- psdumperinitDopart: dopart ---
do
   THIS(PSdumper)[]->odOffsets.init;
   (NONE,NONEOID,0,NONE,NONE,NONE)->NONEobject.init;
   (NONE,NONEOID,0,NONE,NONE,0,0)->NONEpattern.init;
   (NONE,betaenvOID,0,NONE,NONE,NONE)->betaenvObject.init;
   
   getGroupsInfoTable->groupsInfo[];
   getPSObjectDB->objects[];
   
--- psbetaobjectfindsimplelong:descriptor ---
(# 
do ((attoffset+offset) div 4)*4 ->attoffset;
   dofind:
     (for i: odote.simpleCount repeat
          (if odote.simpleVals[i] = attoffset then
              state.r[state.firstPos+i]->value;
              leave dofind;
          if);
     for);
#)

--- psbetaobjectputsimplelong:descriptor ---
(# 
do ((attoffset+offset) div 4)*4 ->attoffset;
   dofind:
     (for i: odote.simpleCount repeat
          (if odote.simpleVals[i] = attoffset then
              value->state.r[state.firstPos+i];
              leave dofind;
          if);
     for);
#)

--- psbetaobjectfindreferencestateinx:descriptor ---
(# 
do
   ((attoffset+offset) div 4)*4 ->attoffset;
   dofind:
     (for i: odote.dynCount repeat
          (if odote.dynRefs[i] = attoffset then
              state.firstPos+state.r[state.firstPos]+1->state.pos;
              (for j: i-1 repeat
                   (if (state.get->tmp) >= 0 then
                       state.pos+2->state.pos;
                    else
                       (if tmp
                        //ValRepPTValue then
                           state.get->low; state.get->high;
                           high-low+1+state.pos->state.pos;
                        //ByteRepPTValue then 
                           state.get->low; state.get->high;
                           ((high-low+4) div 4)+state.pos->state.pos;
                        //WordRepPTValue then
                           state.get->low; state.get->high;
                           ((high-low+2) div 2)+state.pos->state.pos;
                        //DoubleRepPTValue then
                           state.get->low; state.get->high;
                           ((high-low+8) div 8)+state.pos->state.pos;
                        //RefRepPTValue then
                           state.get->low; state.get->high;
                           (high-low+1)*3+state.pos->state.pos;
                        //StructurePTValue then
                           state.pos+5->state.pos;
                        else
                           'Unexpected offset value in serialization: '
                             ->putText;
                           tmp->putInt; 
                           newline;
                       if);
                   if);
              for);
              state.pos->value;
              leave dofind;
          if);
     for);
#)

--- psbetaobjectequalDopart: dopart ---
do ((OID,other.OID)->equalOID) and (other.offset=offset) -> value;
   
--- psbetaobjectisnoneDopart: dopart ---
do (OID,noneOID)->equalOID->value
   
--- psbetaobjectcharattrDopart: dopart ---
do offset->findSimpleLong->tmp;
   (offset mod 4)->tmp.%getByte->value;
   
--- psbetaobjectsetcharattrDopart: dopart ---
do offset->findSimpleLong->tmp;
   (value,offset mod 4)->tmp.%putByte;
   (offset,tmp)->putSimpleLong;
   TRUE->dirty;
   
--- psbetaobjectbooleanattrDopart: dopart ---
do offset->findSimpleLong->tmp;
   (offset mod 4)->tmp.%getByte->value;
   
--- psbetaobjectsetbooleanattrDopart: dopart ---
do offset->findSimpleLong->tmp;
   (value,offset mod 4)->tmp.%putByte;
   (offset,tmp)->putSimpleLong;
   TRUE->dirty;
   
--- psbetaobjectshortintattrDopart: dopart ---
do offset->findSimpleLong->tmp;
   (offset mod 4)->tmp.%getShort->value;
   
--- psbetaobjectsetshortintattrDopart: dopart ---
do offset->findSimpleLong->tmp;
   (value,(offset mod 4))->tmp.%putShort;
   (offset,tmp)->putSimpleLong; 
   TRUE->dirty;       
   
--- psbetaobjectintegerattrDopart: dopart ---
do offset->findSimpleLong->value;
   
--- psbetaobjectsetintegerattrDopart: dopart ---
do (offset,value)->putSimpleLong;
   TRUE->dirty;
   
--- psbetaobjectrealattrDopart: dopart ---
do (offset->findSimpleLong) %putLongAt (@@value);
   (offset+4->findSimpleLong) %putLongAt (@@value+4);
   
--- psbetaobjectsetrealattrDopart: dopart ---
do (offset,@@value->TOS'%adrGetLong')->putSimpleLong; 
   (offset+4,@@value+4->TOS'%adrGetLong')->putSimpleLong; 
   TRUE->dirty;
   
--- psbetaobjectreferenceattrDopart: dopart ---
do offset->findReferenceStateInx->state.pos;
   state.get->maskRefType->poffset;
   state.get->OID.a; state.get->OID.b;
   (OID,poffset,dumper[])->newPSObject->value[];
   
--- psbetaobjectsetreferenceattrDopart: dopart ---
do offset->findReferenceStateInx->state.pos;
   value.offset+REFTYPE_DYNAMIC->state.put;
   value.OID.a->state.put;
   value.OID.b->state.put;
   (if value.OID.a//OID.a//0 then else
       (OID,value.OID)->loc.crossRefs.onCrossLocRef;
   if);
   TRUE->dirty;
   
--- psbetaobjectoriginattrDopart: dopart ---
do offset->findReferenceStateInx->state.pos;
   state.get->maskRefType->poffset;
   state.get->OID.a; state.get->OID.b;
   (OID,poffset,dumper[])->newPSObject->value[];
   
--- psbetaobjectsetoriginattrDopart: dopart ---
do offset->findReferenceStateInx->state.pos;
   value.offset+REFTYPE_ORIGIN->state.put;
   value.OID.a->state.put;
   value.OID.b->state.put;
   (if value.OID.a//OID.a//0 then else
       (OID,value.OID)->loc.crossRefs.onCrossLocRef;
   if);
   TRUE->dirty;
   
--- psbetaobjectpartobjectDopart: dopart ---
do 
   (if offset < 0 then
       -offset->findReferenceStateInx->state.pos;
       state.get->maskRefType->poffset;
       state.get->OID.a; state.get->OID.b;
       (OID,poffset,dumper[])->newPSObject->value[];
    else
       (THIS(PSbetaObject).OID,THIS(PSbetaObject).offset+offset,dumper[])
         ->newPSObject->value[];
   if);
   
--- psbetaobjectsetpartobjectDopart: dopart ---
do 
   (if offset < 0 then
       -offset->findReferenceStateInx->state.pos;
       value.offset+REFTYPE_OFFLINE->state.put;
       value.OID.a->state.put;
       value.OID.b->state.put;
       (if value.OID.a//OID.a//0 then else
           (OID,value.OID)->loc.crossRefs.onCrossLocRef;
       if);
    else
       (* This is _very_ usefull for the schemaEvolution tool and it is 
        * believed to be sound as well. /anders
        * (failure,'psBetaObject.SetPartObject: Only offline allocated partobjects can be set')->stop;*)
       (if value.odote[] = odote[] then
           value.state[] -> state[];
        else
           (failure,'psBetaObject.SetPartObject: Trying to set a partobject that is not a part of this object.') -> stop;
       if);
   if);
   TRUE->dirty;
   
--- psbetaobjectrangeDopart: dopart ---
do (offset->findReferenceStateInx)+1->state.pos;
   state.get->low; state.get->high;
   
--- psbetaobjectsetrangeDopart: dopart ---
do offset->findReferenceStateInx->tmp->state.pos;
   state.get->reptype; state.get->oldlow; state.get->oldhigh;
   (if oldhigh<>high then
       (if reptype
        //ByteRepPTValue then
           (high-oldhigh+3) div 4->nlongs;
           tmp+3+((oldhigh+3) div 4)->nextpos;
        //WordRepPTValue then
           (((high-oldhigh)*2)+3) div 4->nlongs;
           tmp+3+((oldhigh*2+3) div 4)->nextpos;
        //ValRepPTValue then
           (high-oldhigh)->nlongs;
           tmp+3+oldhigh->nextpos;
        //DoubleRepPTValue then
           (high-oldhigh)*2->nlongs;
           tmp+3+oldhigh*2->nextpos;
        //RefRepPTValue then
           (high-oldhigh)*3->nlongs;
           tmp+3+oldhigh*3->nextpos;
        else
           (failure,'psBetaObject.SetRange: UNEXPECTED REPETITION TYPE')
             ->stop;
       if);
       (if nlongs>0 then
           (nextpos,nlongs)->state.insertSpace;
        else
           (nextpos+nlongs,nlongs)->state.removeSpace;
       if);
       tmp+2->state.pos;
       high->state.put;
   if);
   TRUE->dirty;
   
--- psbetaobjectcharrepattrDopart: dopart ---
do offset->findReferenceStateInx->tmp;
   to-from+1 -> value.new;
   (if from <> 0 then (* not empty *)
       (@@value[1],(@@state.r[tmp+3])+from-1,to-from+1)->memcpy;
   if);       
   
--- psbetaobjectsetcharrepattrDopart: dopart ---
do ((offset->findReferenceStateInx)->tmp)+1->state.pos;
   state.get->low; state.get->high;
   (if high = 0 then (* empty charRep *) else
       (if (low<=from) and (to<=high) then
           ((@@state.r[tmp+3])+from-1,@@value[1],to-from+1)->memcpy;
        else
           (failure,'psBetaObject.SetCharRepAttr: INDEX ERROR')
             ->stop;
       if);
   if);
   TRUE->dirty;
   
--- psbetaobjectbooleanrepattrDopart: dopart ---
do offset->findReferenceStateInx->tmp;
   to-from+1 -> value.new;
   (@@value[1],@@state.r[tmp+3]+from-1,to-from+1)->memcpy;
   
--- psbetaobjectsetbooleanrepattrDopart: dopart ---
do (offset->findReferenceStateInx->tmp)+1->state.pos;
   state.get->low; state.get->high;
   (if (low<=from) and (to<=high) then
       ((@@state.r[tmp+3])+from-1,@@value[1],to-from+1)->memcpy;
    else
       (failure,'psBetaObject.SetBooleanRepAttr: INDEX ERROR')
         ->stop;
   if);
   TRUE->dirty;
   
--- psbetaobjectshortintrepattrDopart: dopart ---
do offset->findReferenceStateInx->tmp;
   to-from+1 -> value.new;
   (@@value[1],@@state.r[tmp+3]+2*(from-1),2*(to-from+1))->memcpy;
   
--- psbetaobjectsetshortintrepattrDopart: dopart ---
do (offset->findReferenceStateInx->tmp)+1->state.pos;
   state.get->low; state.get->high;
   (if (low<=from) and (to<=high) then
       (@@state.r[tmp+3]+2*(from-1),@@value[1],2*(to-from+1))->memcpy;
    else
       (failure,'psBetaObject.SetShortIntRepAttr: INDEX ERROR')
         ->stop;
   if);
   TRUE->dirty;
   
--- psbetaobjectintegerrepattrDopart: dopart ---
do offset->findReferenceStateInx->tmp;
   to-from+1 -> value.new;
   (@@value[1],@@state.r[tmp+3]+4*(from-1),4*(to-from+1))->memcpy;
   
--- psbetaobjectsetintegerrepattrDopart: dopart ---
do (offset->findReferenceStateInx->tmp)+1->state.pos;
   state.get->low; state.get->high;
   (if (low<=from) and (to<=high) then
       (@@state.r[tmp+3]+4*(from-1),@@value[1],4*(to-from+1))->memcpy;
    else
       (failure,'psBetaObject.SetIntegerRepAttr: INDEX ERROR')
         ->stop;
   if);
   TRUE->dirty;
   
--- psbetaobjectrealrepattrDopart: dopart ---
do offset->findReferenceStateInx->tmp;
   to-from+1 -> value.new;
   (@@value[1],@@state.r[tmp+3]+8*(from-1),8*(to-from+1))->memcpy;
   
--- psbetaobjectsetrealrepattrDopart: dopart ---
do (offset->findReferenceStateInx->tmp)+1->state.pos;
   state.get->low; state.get->high;
   (if (low<=from) and (to<=high) then
       (@@state.r[tmp+3]+8*(from-1),@@value[1],8*(to-from+1))->memcpy;
    else
       (failure,'psBetaObject.SetRealRepAttr: INDEX ERROR')
         ->stop;
   if);
   TRUE->dirty;
   
--- psbetaobjectreferencerepattrDopart: dopart ---
do offset->findReferenceStateInx->tmp;
   to-from+1 -> value.new;
   tmp+3*from->state.pos;
   (for i:to-from+1 repeat
        state.get->maskRefType->poffset;
        state.get->OID.a; state.get->OID.b;
        (OID,poffset,dumper[])->newPSObject->value[i][];
   for);
   
--- psbetaobjectsetreferencerepattrDopart: dopart ---
do (offset->findReferenceStateInx->tmp)+1->state.pos;
   state.get->low; state.get->high;
   (if (low<=from) and (to<=high) then
       tmp+3+from-1->state.pos;
       (for i:to-from+1 repeat
            value[i].offset+REFTYPE_DYNAMIC->state.put;
            value[i].OID.a->state.put;
            value[i].OID.b->state.put;
            (if value[i].OID.a//OID.a//0 then else
                (OID,value[i].OID)->loc.crossRefs.onCrossLocRef;
            if);
       for);    
    else
       (failure,'psBetaObject.SetReferenceRepAttr: INDEX ERROR')
         ->stop;
   if);    
   TRUE->dirty;  
   
--- psbetaobjectpatrefrepattrDopart: dopart ---
do 'psBetaObject.PatRefRepAttr not implemented'->putLine;
   
--- psbetaobjectpatternattrDopart: dopart ---
do offset->findReferenceStateInx->state.pos;
   (if state.get = 0 then
       (0,0) -> (group,proto);
       0 -> poffset;
       state.get->OID.a; state.get->OID.b;
    else
       state.get->group; state.get->proto;
       state.get->maskRefType->poffset;
       state.get->OID.a; state.get->OID.b;
   if);
   (group,proto,OID,poffset,dumper[],loc[])->newPSPattern->value[];
       
--- psbetaobjectsetpatternattrDopart: dopart ---
do offset->findReferenceStateInx->tmp->state.pos;
   (if state.get//0 then
       (if not value.isNone then
           (tmp+3,3)->state.insertSpace;
       if)
    else
       (if value.isNone then
           (tmp,3)->state.removeSpace;
       if);
   if);
   tmp->state.pos;
   (if value.isNone then
       0->state.put; noneOID->(state.put,state.put);
    else
       StructurePTValue->state.put;
       value.group->state.put;
       value.proto->state.put;
       value.oriOffset+REFTYPE_ORIGIN->state.put;
       value.oriOID.a->state.put;
       value.oriOID.b->state.put;
       (if value.oriOID.a//OID.a//0 then else
           (OID,value.oriOID)->loc.crossRefs.onCrossLocRef;
       if);
   if);
   TRUE->dirty;
   
--- psobjdumpercreatepsobjectBody: descriptor ---
(# state: ^RepetitionObject;
   odote: ^odOffsetTableElement;
do      
   (* Initialize state. *)
   &RepetitionObject[]->state[]; state.init;
   
   od[]->pd.odOffsets.lookup->odote[];
   
   (* See ~beta/objectserver/v2.1/ObjectSerializer for a description of the
    * format of serialized objects. *)
   
   (* Initialize simple values: *)
   odote.simpleCount->state.put;
   (for odote.simpleCount repeat 0->state.put for);
   
   (* Initialize reference values: *)
   (for i: odote.dynCount repeat
        (if odote.dynRefTypes[i]
         //DynRefAttribute
         //DynCompRefAttribute then
            
            (* Dynamic references to other objects. Initialize to NONE. *)
            REFTYPE_DYNAMIC->state.put;
            noneOID->(state.put,state.put);
            
         //StatRefAttribute
         //StatCompRefAttribute then
            
            (* Offline static references to other objects. Initialize to NONE. *)
            REFTYPE_OFFLINE->state.put;
            noneOID->(state.put,state.put);
            
         //OriginAttribute then
            
            (* Origin reference. *)
            REFTYPE_ORIGIN->state.put;
            noneOID->(state.put,state.put);
            
         //PatRefAttribute then
            
            (* Pattern Reference. Initialize to NONE. *)
            REFTYPE_DYNAMIC->state.put;
            noneOID->(state.put,state.put);
            
         //PatRefRepAttribute then
            
            (* Repetition of pattern references. Format not described by 
             * ObjectSerializer.bet. Should probably be saved as a reference
             * repetition with each element saved as either a NONE 
             * reference or a Pattern Reference. *)
            
            'WARNING: Repetitions of pattern references not handled'
              ->putline;              
            
         //CharRepAttribute
         //BoolRepAttribute then
            
            ByteRepPTValue->state.put;
            1->state.put; (* lowrange *)
            0->state.put; (* highrange *)
            
         //ShortIntRepAttribute then
            
            WordRepPTValue->state.put;
            1->state.put; (* lowrange *)
            0->state.put; (* highrange *)
            
         //IntRepAttribute then
            
            ValRepPTValue->state.put;
            1->state.put; (* lowrange *)
            0->state.put; (* highrange *)
            
         //RealRepAttribute then
            
            DoubleRepPTValue->state.put;
            1->state.put; (* lowrange *)
            0->state.put; (* highrange *)
            
         //RefRepAttribute
         //CompRepAttribute then
            
            RefRepPTValue->state.put;
            1->state.put; (* lowrange *)
            0->state.put; (* highrange *)
            
        if);    
   for);
   
   (* Initialize new psBetaObject: *)
   
   &PSbetaObject[]->bo[];     
   (pd[],loc.nextOID,0,state[],odote[],loc[])->bo.init;
   (bo[],pd.PSobjectOwner[])->pd.objects.addObjectOwner;
   TRUE->bo.dirty;
#)

--- psobjdumpernewpsobjectBody: descriptor ---
(# 
   proto,group: @Integer;
   state: ^RepetitionObject;
   os: ^ObjectServer;
   loc: ^location;
   odote: ^odOffsetTableElement;
do 
   lookup:
     (if true
      //(OID,betaenvOID)->equalOID then
         pd.BetaEnvObject[]->bo[];
      //(OID,noneOID)->equalOID then
         pd.NONEobject[]->bo[];
      else
         (* Check if the object can be found in the objectDB: *)
         pd.objects.scanObjects
         (# 
         do 
            (if (current.bo.OID,OID)->equalOID then
                (if current.bo.offset=offset then
                    current.bo[]->bo[]; leave lookup;
                if);
            if);
         #);
     if);
   (if bo[]=NONE then
       getObjectServer->os[];
       &PSbetaObject[]->bo[];
       (OID.a,0) -> os.setLocation;
       os.lastLocation[]->loc[];
       OID->loc.locationObjects.findSer->(state[],proto,group);
       
       (proto,(group->loc.locationGroups.inxToElm).groupName[])
         ->pd.groupsInfo.protoGroupToOD
         ->pd.odOffsets.lookup
         ->odote[];
       (pd[],OID,offset,state[],odote[],loc[])->bo.init;
       (bo[],pd.PSobjectOwner[])->pd.objects.addObjectOwner;
   if);
   bo.touch;
#)

--- psobjdumpernewpspatternBody: descriptor ---
(# odote: ^odOffsetTableElement;
do 
   lookup:
     (if not ((oriOID,noneOID)->equalOID) then
         (proto,(group->loc.locationGroups.inxToElm).groupName[])
           ->pd.groupsInfo.protoGroupToOD
           ->pd.odOffsets.lookup
           ->odote[];
         (* Try to find the pattern in the objectDB: *)
         pd.objects.scanPatterns
         (# 
         do (if (odote[],oriOffset,oriOID)->current.bp.equalPred then
                current.bp[]->bp[]; leave lookup;
            if);
         #);
      else
         pd.NONEpattern[]->bp[];
     if);
   (if bp[]=NONE then
       &PSbetaPattern[]->bp[];
       (pd[],oriOID,oriOffset,odote[],loc[],group,proto)->bp.init;
       (bp[],pd.PSpatternOwner[])->pd.objects.addPatternOwner;
   if);
   bp.touch;
#)
