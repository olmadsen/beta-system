ORIGIN '../mpsinterface';
(* 
 * The OdOffsetTable corresponds to the ptOffsetTable 
 * (objectserver/v?.?/ptOffsetTable), but uses the ObjectDescriptor 
 * instead of the prototype address.
 * 
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-94
 *       All rights reserved.
 *)
INCLUDE '../objectdumper';
INCLUDE '~beta/containers/v1.4/hashTable';

--- mpsinterfacelib:attributes ---

(* ODOFFSETTABLE
 * =============
 * Used by psObjectDumper to map ObjectDescriptor offsets to offsets in
 * serializations. *)

ODoffsetTableElement:
  (# od: ^BETACFL.ObjectDescriptor; 
     (* The ObjectDescriptor described by this element. *)
     
     dynCount: @Integer;       (* Number of non-static references, including 
                                * origin references and static offline       
                                * references.                                *)
     dynRefs: [1]@Integer;     (* Byte offsets of dynamic references.        *)
     dynRefTypes: [1]@Integer; (* Types of dynamic references. values between
                                * DynRefAttribute and PatRefRepAttribute *)
     
     simpleCount: @Integer;   (* Number of simple value fields. *)
     simpleVals: [1]@Integer; (* Byte offsets of simple values. *)
     
     partCount: @Integer;  (* Number of static inlined partobjects.       *)
     parts: [1]@Integer;   (* Byte offsets of static inlined partobjects. *)
     ods: [1]^BETACFL.ObjectDescriptor; 
     (* ObjectDescriptors for inline parts. *)
  #);

odOffsetTable: HashTable
  (# element:: ODoffsetTableElement;
     hashfunction:: (# do e.od.index->value #);
     dumper: ^objectDumper;
     
     init:: (# enter dumper[] #);
     
     lookup:
       (* Looks up od in the table. If od is not found, the corresponding
        * element is calculated, inserted, and returned. *)
       (# od: ^BETACFL.ObjectDescriptor; 
          found: ^element;
       enter od[]
       do od.index -> findIndexed
          (# predicate:: (# do current.od[]->od.equal->value #);
             notfound:: (# do od[]->makeElement->found[]->insert #);
          do current[]->found[]
          #);
       exit found[]
       #);
     
     makeElement:
       (# ofs: [1]@Integer;
          (* ofs[i] contains the meaning of the i'th long within 
           * objects that are instances of od. The 1'st long is
           * the GC field as the prototype is not considered here.
           * Possible offsetTable values: *)
          
          staticPart: (# exit 10 #);
          gcInfo:     (# exit 20 #);
          simple:     (# exit 30 #);
          
          ods: @
            (* ods.table[i] contains the ObjectDescriptor of the i'th 
             * inlined static part object. *)
            (# table: [2]^BETACFL.ObjectDescriptor;
               count: @Integer;
               append: @
                 (# od: ^BETACFL.ObjectDescriptor;
                 enter od[]
                 do
                    count+1->count;
                    (if count>table.range then
                        table.range->table.extend;
                    if);
                    od[]-> table[count][];
                 #);
               
               reset: @(# do 0 -> count; 1 -> table.new #);
            #);
          
          fillOutOfs: 
            (# od: ^BETACFL.ObjectDescriptor; inx: @Integer;
            enter (od[],inx)
            do
               gcInfo -> ofs[inx+1]; 
               
               (* Fill out dynamic reference fields and call recursively
                * on static references (inlined objects): *)
               (od[],FALSE)->dumper.scanPattern
               (# forEachLine::
                    (# thisInx: @Integer;
                    do inx+(offset div 4)->thisInx;
                       (if attType
                        //CharAttribute//IntegerAttribute//ShortIntAttribute
                        //BooleanAttribute//RealAttribute then
                        else
                           (if attType
                            //OriginAttribute then
                               
                               (*REFTYPE_ORIGIN*)attType->ofs[thisInx];
                           
                            //StatRefAttribute
                            //StatCompRefAttribute then
                               (* REFTYPE_OFFLINE or inserted part object. *)
                               
                               (if offset < 0 then
                                   inx+((-offset) div 4)->thisInx;
                                   (*REFTYPE_OFFLINE*)attType->ofs[thisInx];
                                else
                                   attod[] -> ods.append;
                                   (attod[],thisInx)->fillOutOfs;
                                   staticPart->ofs[thisInx];
                               if);
                               
                            else
                               (*REFTYPE_DYNAMIC*)attType->ofs[thisInx];
                           if);
                       if);
                    #);  
               #);
            #);
          
          elm: ^element;
          od: ^BETACFL.ObjectDescriptor;
          odsize: @Integer;
          
       enter od[]
       do 
          &element[] -> elm[];
          od[] -> elm.od[];
          
          od.size div 4 -> odsize;
          (if ofs.range < odsize - 1 //true then
              (odsize - 1 - ofs.range) -> ofs.extend;
          if);
          (for i:odsize - 1 repeat simple -> ofs[i] for);
          (* ofs.range >= od.size - 1, as the proto field is ignored. *)
          
          (od[],0) -> fillOutOfs;
          (for i: odsize - 1 repeat
               (if ofs[i] //simple then
                   
                   elm.simpleCount+1->elm.simpleCount;
                   (if elm.simpleCount > elm.simpleVals.range //true then
                       elm.simpleVals.range -> elm.simpleVals.extend;
                   if);
                   i*4 -> elm.simpleVals[elm.simpleCount];
                   
                //staticPart then
                   
                   elm.partCount+1->elm.partCount;
                   (if elm.partCount > elm.parts.range //true then
                       elm.parts.range -> elm.parts.extend;
                   if);
                   i*4 -> elm.parts[elm.partCount];
                   
                //gcInfo then
                   
                   (* Ignore *)
                   
                else
                   (* //REFTYPE_DYNAMIC//REFTYPE_ORIGIN//REFTYPE_OFFLINE then *)
                   
                   elm.dynCount+1->elm.dynCount;
                   (if elm.dynCount > elm.dynRefs.range //true then
                       elm.dynRefs.range -> elm.dynRefs.extend;
                       elm.dynRefTypes.range -> elm.dynRefTypes.extend;
                   if);
                   i*4 -> elm.dynRefs[elm.dynCount];
                   ofs[i]->elm.dynRefTypes[elm.dynCount];
                   
               if); 
          for);
          (if elm.partCount<>0 then ods.table -> elm.ods if);
       exit elm[]
       #);
  #);
