ORIGIN '../mpsinterface';
INCLUDE '~beta/basiclib/v1.6/file';
INCLUDE '~beta/betaast/v5.2/donecheck';
INCLUDE '~beta/mps/v5.2/grammarinit';

-- mpsintGetUniqueGroupID:dopart--
do (# group_hash: ^text
   do (AST[],fg[])->getGroupIDProperty->group_hash[];
      (if group_hash[]<>NONE then
          group_hash.reset;
          group_hash.getint->groupNameHash; group_hash.get; (* '-'*)
          group_hash.getint->checkTime;
      if)
   #)
  
-- mpsinterfaceInitBody: DoPart --
do AST; ('~beta/grammars/beta/v2.5/beta','beta',screen[])
     ->BETACFL.betagrammarInit
     (#
        MPSerror::
          (# do (failure,msg[])->stop #);
        noParserAvailable:: 
          (# do (failure,msg[])->stop #)
     #); 
   fragmentGroupTable.init; 
   INNER ;   

-- ptToObjectDescriptorBody: DoPart --
do
   find: fg.fragmentList.scan
     (# 
     do
        (if current.type
         // AST.FormType then
            (if formIndex-1->formIndex
             // 0 then
                current.open->ff[]; astIndex->ff.indexToNode->a[]; leave find; 
            if)
        if);
        
     #);
     

-- getFragmentGroupBody: Descriptor --
(# e: ^element; fgf: ^AST.fragmentGroup; 
do
   &element[]->e[];
   groupName.copy->e.groupName[];
   find:
   e[]->hashFunction
     ->findIndexed
       (#
          predicate:: 
            (#  do current.groupName[]->groupName.equal->value #);
          notFound::< 
            (# de: @diskEntry; donecheckOk: @Boolean; 
            do
               groupName[]->onOpenGroup;
               groupName[]->AST.expandToFullPath->groupName[];
               (groupName[],screen[])
                 ->AST.top.open
                   (#
                      fragmentNotExisting:: 
                        (# 
                        do groupName[]->onGroupNotFound;
                           none->AST.theCatcher[]; leave find; 
                        #);
                      startingParsing:: 
                        (# 
                        do (if not (groupName[]->onOldGroup) then
                               none->AST.theCatcher[]; leave find; 
                           if);
                        #);
                      parseErrors:: 
                        (# 
                        do groupName[]->onParseErrors;
                           none->AST.theCatcher[]; leave find
                        #);
                      fatalParseError:: 
                        (# 
                        do errNo->onFatalParseError;
                           none->AST.theCatcher[]; leave find
                        #);
                      readAccessError:: 
                        (#
                        do 'Read access error:\n'->msg.prepend; msg[]->onOtherError;
                           none->AST.theCatcher[]; leave find
                        #);
                      grammarNotFound:: 
                        (#
                        do 'Grammar not found:\n'->msg.prepend; msg[]->onOtherError;
                           none->AST.theCatcher[]; leave find
                        #);
                      badFormat::
                        (#
                        do 'Bad AST format:\n'->msg.prepend; msg[]->onOtherError;
                           none->AST.theCatcher[]; leave find
                        #);
                      doubleFormDeclaration:: 
                        (# 
                        do 'Two forms are declared with the same name: \n'->msg.prepend;
                           msg[]->onOtherError;
                           none->AST.theCatcher[]; leave find
                        #);
                      otherFileError:: 
                        (#
                        do 'Other file error:\n'->msg.prepend; msg[]->onOtherError; 
                           none->AST.theCatcher[]; leave find
                        #);
                      writeAccessOnLstFileError:: 
                        (# 
                        do 'Access error on .lst file:'->msg.prepend;msg[]->onOtherError;
                           true->continue
                        #);
                      writeAccessError:: 
                        (# 
                        do 'No write access:\n'->msg.prepend; msg[]->onOtherError;
                           true->continue
                        #);
                   #)->e.fg[]->foundGroup[];
               checkcheck: foundGroup.prop.scanProp
                 (#
                    doProp:: 
                      (# 
                      do
                         (if ('donecheck'->prop.equalNCS) then
                             TRUE->doneCheckOk; leave checkcheck; 
                         if);
                         
                      #);
                    
                 #);
               (if not doneCheckOk then
                   (if not ((groupName[],foundGroup[])->onUncheckedGroup) then
                       none ->foundGroup[];
                       leave find;
                   if)
               if);
               foundGroup.diskFileName->de.path;
               (if not (de.exists and ((foundGroup[],de.modtime)->modtimeOk)) then
                   (if not (groupName[]->onNewGroup) then
                       none ->foundGroup[]; leave find
                   if)
               if);
               e[]->insert;
               (groupName[],e.fg[])->onOpenGroupDone;
               e.fg[]->fgf[];
               (* Setup origin chain. *)
               loop:
               (if fgf[] <> none then
                   (if fgf.origin = none then
                       fgf[]->mySetupOrigin; fgf.origin->fgf[]; restart loop; 
                   if)
               if);
               leave find;
               
            #);
          
       do current.fg[]->foundGroup[]; 
       #);
   
#)  

-- mpsintMySetupOrigin: DoPart --
do
   fg.prop.ScanProp
     (#
        doProp:: 
          (# 
          do
             prop.makelc;
             (if 'origin'->prop.equal then
                 ScanParameters
                   (#
                      doString:: 
                        (# t: ^Text; 
                        do
                           fg.fullName->AST.stripPathName->t[];
                           (if t[]
                            // none then
                               (s.copy,AST.thePathHandler.currentDirectory)
                                 ->AST.thePathHandler.convertFilePath
                                 ->fragmentGroupTable.getFragmentGroup
                                 ->fg.origin
                            else
                               (s.copy,t[])->AST.thePathHandler.convertFilePath
                                 ->fragmentGroupTable.getFragmentGroup
                                 ->fg.origin
                           if)
                        #)
                   #)
             if)
          #)
     #)  

