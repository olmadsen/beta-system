ORIGIN '../objectdb';
INCLUDE '~beta/containers/v1.4/list';

--- odbScanObjectOwners:dopart ---
do
   1 -> index;
   loop:
     (if index<=refcount then
         owners[index][]->current[];
         INNER;
         (if delete then
             NONE->owners[index][];
             owners[refcount][]->owners[index][];
             refcount-1->refcount;
             (if refcount=0 then
                 THIS(objectElement)[]
                   ->odbprivate.objectElms.at
                   ->odbprivate.objectElms.delete; 
             if);
          else
             index+1->index;
         if);
         restart loop;
     if);
   
--- odbScanPatternOwners:dopart ---
do
   1 -> index;
   loop:
     (if index<=refcount then
         owners[index][]->current[];
         INNER;
         (if delete then
             NONE->owners[index][];
             owners[refcount][]->owners[index][];
             refcount-1->refcount;
             (if refcount=0 then
                 THIS(patternElement)[]
                   ->odbprivate.patternElms.at
                   ->odbprivate.patternElms.delete; 
             if);
          else
             index+1->index;
         if);
         restart loop;
     if);
   
--- odbScanObjects:dopart ---
do
   odbprivate.objectElms.iterate
   (# 
   do current.elm[]->THIS(scanObjects).current[];
      (if deleteObject then
          current[]->odbprivate.objectElms.delete;
          FALSE->deleteObject;
      if);
      INNER scanObjects;
   #);
   
--- odbScanPatterns:dopart ---
do
   odbprivate.patternElms.iterate
   (# 
   do current.elm[]->THIS(scanPatterns).current[];
      (if deletePattern then
          current[]->odbprivate.patternElms.delete;
          FALSE->deletePattern;
      if);
      INNER scanPatterns;
   #);
   
   
--- odbAddObjectOwner:dopart ---
do
   add:
     (# new: ^objectElement;
     do
        odbprivate.objectElms.scan
        (#
        do (if current.bo[]->bo.equal then
               (if current.owners.range=current.refcount then
                   current.owners.range->current.owners.extend
               if);
               current.refcount+1->current.refcount;
               newOwner[]->current.owners[current.refcount][];
               leave add;
           if);
        #);
        
        (* First owner of this betaObject. *)
        &objectElement[]->new[];
        1->new.refcount;
        bo[]->new.bo[];
        newOwner[]->new.owners[1][];
        new[]->odbprivate.objectElms.append;
     #);
   
--- odbAddPatternOwner:dopart ---
do
   add:
     (# new: ^patternElement;
     do
        odbprivate.patternElms.scan
        (#
        do (if current.bp[]->bp.equal then
               (if current.owners.range=current.refcount then
                   current.owners.range->current.owners.extend
               if);
               current.refcount+1->current.refcount;
               newOwner[]->current.owners[current.refcount][];
               leave add;
           if);
        #);
        
        (* First owner of this betaPattern. *)
        &patternElement[]->new[];
        1->new.refcount;
        bp[]->new.bp[];
        newOwner[]->new.owners[1][];
        new[]->odbprivate.patternElms.append;
     #);
   
--- odbRemoveObjectOwner:dopart  --- 
do
   find: odbprivate.objectElms.scan
     (#
     do current.scanOwners
        (# 
        do (current[]=oldOwner[])->delete;
        #);
        leave find;
     #);
        
--- odbRemovePatternOwner:dopart ---
do
   find: odbprivate.patternElms.scan
     (#
     do current.scanOwners
        (# 
        do (current[]=oldOwner[])->delete;
        #);
        leave find;
     #);
   
--- odbInit:descriptor ---
(# 
do 
#)

--- odbClear:descriptor ---
(# 
do odbprivate.objectElms.clear;
   odbprivate.patternElms.clear;
#)


--- odbPrivate:descriptor ---
(# objectElms: @List (# element:: objectElement #);
   patternElms: @List (# element:: patternElement #);
#)

