ORIGIN '../groupsinfo';
LIB_ITEM 'objbrwgroupsinfo';
INCLUDE '~beta/basiclib/formatio';

--- groupsInfoProtoGroupToOD:dopart ---
do
   (if (groupName[]->find->elm[])<>NONE then
       (if proto+1 <= elm.last then 
           elm.ods[proto+1][]->od[];
           INNER;
       if);
   if);
    
--- groupsInfoODgroupToProto:dopart ---
do
   findProto:
     (if (groupName[]->find->elm[])<>NONE then
         (for i:elm.last repeat
              (if elm.ods[i][]->od.equal then
                  i-1->proto; leave findProto;
              if);
         for);
         'ERROR: ObjectDescriptor not found in %s'->putFormat
         (# do groupName[]->s #);
     if);
   
   
--- groupsinfohashfunction:dopart ---
do e.groupName[]->groupNameHash->value;
   
--- groupsInfoTableLib:attributes ---

groupNameHash:
  (# groupName: ^Text; value: @Integer;
  enter groupName[]
  do groupName.scanAll (# do ch+value->value #);
  exit value
  #);

find:
  (# groupName: ^Text; found: ^element;
  enter groupName[]
  do
     groupName[]->groupNameHash->findIndexed
     (# predicate:: 
          (# do current.groupName[]->groupName.equal->value #);
        notfound::
          (# 
          do groupName[]->newGroupsInfoElement->found[];
          #);
     do current[]->found[];
     #)  
  exit found[]
  #);

newGroupsInfoElement:
  (# fg: ^AST.fragmentGroup; 
     new: ^element;
     groupName: ^Text;
     
     scanFragment:
       (# exp: ^AST.expanded;
          firstInDescriptorForm: @Boolean;
          (* gram, inserted 1,2,5, copied from Checker/sematt.bet *)
          (* these should be moved to betaast frag
           * to ensure consistency (?) *)
          standardKind:  (# exit 1#); 
          constKind:     (# exit 2#); 
          CprocKind:     (# exit 3 #);
          generalKind:   (# exit 4 #);
          dataKind:      (# exit 5#);
          callBackKind:  (# exit 6#);
          externalVirtualKind: (# exit 7 #);
          comKind:       (# exit 8 #); 
          holderKind:    (# exit 9 #); 
          statekind:     (# exit 10 #);
       enter exp[]
       do
          (exp.symbol=BETA.DescriptorForm)->firstInDescriptorForm;
          BETA.ObjectDescriptor->exp.suffixWalkForProd
          (# scanCat:: BETACFL.ObjectDescriptor;
             createsPrototype: @Boolean;
             _kind: @integer;
          do current.kind -> _kind;
             (if ((0->_kind.%getByte))
             (* Above line tos_converted from: (if (current.kind -> tos'%getByte[0]') *)
                 
              //CprocKind then
                 
                 (* Current is an external declaration. No prototype is 
                  * generated UNLESS it is a callback procedure. *)
                 
                 (# (* Code in this descriptor was based on "cProcDecoder"
                     * from "sematt.bet" in the compiler, but rewritten
                     * to use the "betacfl" interface instead of the
                     * "index" interface. For maintainability, future 
                     * compilers should set a semantic attribute revealing
                     * whether an objectdescriptor generates a prototype. *)
                    
                    mp: ^BETACFL.MainPart; ap: ^BETACFL.ActionPart;
                    dp: ^BETACFL.DoPart; imps: ^BETACFL.Imperatives;
                    imp: ^BETACFL.Imp; ae: ^BETACFL.assignmentEvaluation; 
                    tr: ^BETACFL.Transaction; ad: ^BETACFL.attributeDenotation;
                    obd: ^BETACFL.objectDenotation;
                    a: ^AST.ast;
                    
                    curod: ^BETACFL.ObjectDescriptor;
                    
                    getExtKind:
                      (# a: ^AST.ast; na: ^BETACFL.NameApl; t: ^Text;
                         createsPrototype :@Boolean;
                      enter a[]
                      do 
                         (if a.symbol=BETA.NameApl then
                             (a[]->na[]).getText->t[];
                             (if true
                              //'CallC'->t.equalNCS
                              //'CallPascal'->t.equalNCS
                              //'Pascal'->t.equalNCS
                              //'CallStd'->t.equalNCS
                              //'PascalTrap'->t.equalNCS then
                                 FALSE->createsPrototype;
                              else
                                 TRUE->createsPrototype;
                             if)
                          else
                             FALSE->createsPrototype;
                         if);
                      exit createsProtoType
                      #);
                    
                 do current[]->curod[];
                    checkIfCallback:
                      (# 
                      do
                         (curod.getMainPart->mp[]).getActionPart->ap[];
                         ap.getDoPartOpt->a[];
                         (if a.kind<>AST.kinds.optional then
                             (a[]->dp[]).getImperatives->imps[];
                             L: imps.newScan (# do current[]->imp[]; leave L #);
                             (if imp[]<>NONE then
                                 (* imp is first imperative in dopart *)
                                 (if imp.symbol
                                  //BETA.assignmentEvaluation then
                                     (* 'xxx'->YY *)
                                     (imp[]->ae[]).getTransAction->tr[];
                                     (if tr.symbol=BETA.objectDenotation then
                                         (tr[]->obd[]).getAttributeDenotation->ad[];
                                         ad[]->getExtKind->createsProtoType;
                                     if);
                                  //BETA.objectDenotation then
                                     (imp[]->obd[]).getAttributeDenotation->ad[];
                                     ad[]->getExtKind->createsProtoType;
                                  else
                                     TRUE->createsProtoType;
                                 if);
                             if);
                         if);
                         (if not createsProtoType then
                             (* Check that the prefix is not a callback
                              * entry either. *)
                             curod.scanPrefix
                             (# 
                             do thisObjectDescription[]->curod[];
                                restart checkIfCallback;
                             #);
                         if);
                      #);
                    
                 #)
                 
              // comKind then TRUE->createsPrototype; 
              // holderKind then TRUE->createsPrototype;
              //generalKind then
                 
                 (if not (((13,1)->_kind.%getBits)) then
                 (* Above line tos_converted from: (if not (current.kind->TOS'%getBits[13,1]') then *)
                     (* Current is *not* an inserted item 
                      * of the inlined kind. *)
                     TRUE->createsPrototype;
                 if);
              // datakind then false->createsPrototype;
              // constkind then false->createsPrototype;
              // standardKind then false->createsPrototype;
              // stateKind then true->createsPrototype;
              else 
                 'unknown kind found'->screen.puttext;
                 (0->_kind.%getByte)->screen.putint;
                 (* Above line tos_converted from: current.kind -> tos'%getByte[0]'->screen.putint; *)
                 screen.newline
             if);
             
             (if createsPrototype then
                 current[]->new.append;
                 (if firstInDescriptorForm then
                     (if (current.getPrefixOpt).kind<>AST.kinds.optional then
                         (* In descriptor forms with prefixed descriptors, the
                          * prototype is put twice into the data segment 
                          * prototype table! Don't know why! *)
                         current[]->new.append;
                     if);
                 if);
             if);
             FALSE->firstInDescriptorForm->createsPrototype;
          #);
       #);
     
  enter groupName[]
  do 
     groupName[]->fragmentGroupTable.getFragmentGroup->fg[];
     (if fg[]=NONE then leave newGroupsInfoElement if);
     
     groupName[]->onScan;
     
     &element[]->new[];
     fg[]->new.fg[];
     groupName.copy->new.groupName[];
     new[]->insert;
     
     (* First run through the attributes fragments in the group. They
      * are for some reason emitted first in the prototype table. *)
     
     fg.fragmentList.scan
     (# ff: ^AST.fragmentForm; 
        exp: ^AST.expanded;
     do (if current.type=AST.FormType then
            current.open->ff[];
            ff.root[]->exp[];
            (if exp[]<>none then
                (if exp.symbol=BETA.AttributesForm then
                    exp[]->scanFragment;
                if);
             else
                'Error with: '->puttext;
                current.name[]->putline;
            if);
        if);
     #);
     
     (* Then run through the remaining fragments: *)
     
     fg.fragmentList.scan
     (# ff: ^AST.fragmentForm; 
        exp: ^AST.expanded;
     do (if current.type=AST.FormType then
            current.open->ff[];
            ff.root[]->exp[];
            (if exp[]<>none then
                (if exp.symbol<>BETA.AttributesForm then
                    exp[]->scanFragment;
                if);
             else
                'Error with: '->puttext;
                ff.print;
                fg.fullname->putline;
            if);   
        if);
     #);
     
     groupName[]->onScanDone;
     
  exit new[]   
  #);

