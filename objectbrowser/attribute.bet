ORIGIN '~beta/basiclib/v1.4/betaenv';
INCLUDE 'objectdumper';
INCLUDE 'options';

BODY 'private/attributebody';

--- lib:attributes ---

(*
 *                       attribute
 *                           |
 *      _____________________|____________________
 *     |                                          |
 * complexAttribute                      repetitionAttribute
 *     |                                          |
 *     |                                          |
 * rootAttribute                                  |
 *                                                |
 *                           _____________________|________
 *                          |                              |
 *                  simpleRepetitionAttribute   complexRepetitionAttribute
 * 
 *)

attribute:
  (# offset, attType: @Integer; 
     attName: ^Text;   (* Name of this attribute. *)
     staticQua: ^Text; (* Static qualification of this attribute. *)
     
     father: ^complexAttribute; 
     (* father points out the nearest surrounding object containing this 
      * attribute. *)
     
     isComplex: @Boolean; (* Iff TRUE, this is a complexAttribute. *)
     isRepetition: @Boolean; (* Iff TRUE, this is a repetitionAttribute *)
     
     lineCount: @Integer; 
     (* Number of lines needed for display of this attribute. The number
      * depends on visibilityLevel, as follows:
      *    ATT_VISIBLE: lineCount.
      *    ATT_CONTRACTED: 1.
      *    ATT_INVISIBLE: 0. *)
     
     <<SLOT attributeAttributes: attributes>>;
     
     setvisibility:<
       (* Use setvisibility to change the visibilityLevel. *)
       (# newlevel: @Integer;
       enter newlevel
       <<SLOT ODattributeSetVisibility:dopart>>
       #);
     
     visibilityLevel: @Integer;
     (* ATT_VISIBLE: fully visible.
      * ATT_CONTRACTED: Contracted. Only type of complex attribute shown.
      * ATT_INVISIBLE: invisible. *)
     
     (* PRIVATE: *)
     
     getVisibleAttribute:
       (# number: @Integer; v: ^attributeVisitor;
       enter (number,v[])
       do <<SLOT attributeGetVisibleAttribute:descriptor>>
       #); 

     getRoot: 
       (# att: ^attribute; 
          root: ^rootAttribute;
       do THIS(attribute)[]->att[];
          getIt: 
            (if att.father[] //NONE then
                att[]->root[];
             else
                att.father[]->att[];
                restart getIt;
            if);
       exit root[]
       #);
  #);

repetitionAttribute: attribute
  (# (* getrange updates low,high to the current range of the repetition. *)
     getrange: (# <<SLOT repetitionAttributeRange:dopart>> exit (low,high) #);
     low,high: @Integer; (* Only set through setrange. *)
     
     first,last: @Integer;
     (* If visibilityLevel is ATT_VISIBLE, first and last denotes the range
      * of the repetition to be shown. Linecount is adjusted to make space
      * for dots in the end and the beginning, according to hidden elements.
      * By default, first and last is set to the range of the repetition. *)
  #);

SimpleRepetitionAttribute: repetitionAttribute
  (# setvisibility:: (# <<SLOT ODsimplerepetitionSetVisibility:dopart>> #);
     <<SLOT simplerepetitionAttributes:attributes>>;
  #);

(* complexRepetitionAttribute: repetitionAttribute
 *   (#  ...
 *   #);
 *)

complexAttribute: attribute
  (# setvisibility:: (# <<SLOT ODcomplexSetVisibility:dopart>> #);

     bo: ^betaObject; (* The object corresponding to this complexAttribute. *)
     
     initialized: @Boolean; 
     (* If FALSE, the representation of sons of this complexAttribute has
      * been deferred. it will be built when the visibilityLevel of this
      * complexAttribute is changed to ATT_VISIBLE. *)
     
     sons: @ (* List of attributes in this complex object. *)
       (# <<SLOT complexAttributeSonsAtt: attributes>>;
          init: (# <<SLOT complexAttributeSonsInit:dopart>> #);
          scan:
            (# current: ^attribute;
            <<SLOT complexAttributeSonsScan:dopart>>
            #);
          sprivate: @<<SLOT complexAttributeSonsPrivate:descriptor>>;
       #);
     
     scanInvisibleAttributes:
       (# v: ^attributeVisitor;
       enter v[]
       <<SLOT scanInvisibleAttributes:dopart>>
       #);
  #);

rootAttribute: ComplexAttribute
  (* Used to represent the object shown in e.g. a window. *)
  (# 
     options: ^optionDB; (* Options guiding the look of this rootAttribute. *)
     type: ^Text; (* Dump of the pattern name corresponding to this root. *)
     shortnames: @Boolean;
     
     init: 
       (# 
       enter (bo[],options[])
       do <<SLOT rootAttributeInit:descriptor>> 
       #);
     
     scanVisibleAttributes:
       (* Calls corresponding method in v for each visible attribute in 
        * the tree. In addition touches each betaObject and betaPattern
        * seen, to ensure that they stay around (betaObject.touch). *)
       (# v: ^attributeVisitor;
       enter v[]
       do <<SLOT ODscanVisibleAttributes:descriptor>>
       #);
     
     visitAttributeByNumber:
       (* Calls method in v corresponding to visible attribute number as
        * seen by scanVisibleAttributes *)
       (# number: @Integer; v: ^attributeVisitor;
       enter (number,v[])
       do (number+1,v[])->getVisibleAttribute;
       #);
     
     scanKnownComplexAttributes:
       (* Calls v.onStatRef or v.onStatCompRef for each complex attribute
        * in this attribute tree for which a representation has been built. 
        * The complex attribute may not have been initialized yet, i.e. it 
        * may be the root of a subtree that hasn't yet been built. *)
       (# v: ^attributeVisitor;
       enter v[]
       do <<SLOT ODscanKnownComplexAttributes:descriptor>>
       #);
     
     onComplexCreate:<
       (* Called whenever a new complex attribute is created as part of
        * the tree rooted in this rootAttribute, including this complex
        * attribute itself. *)
       (# att: ^complexAttribute;
       enter att[]
       do INNER
       #);                             
  #);

buildObjectRepresentation:
  (* Builds an object representation the shape of a tree of complex
   * attributes in the nodes and simple attributes in the leaves.
   * All nested complex attributes are initially uninitialized, and
   * will lazily initialized on demand. The value of hideOrigins decides 
   * whether origins are visible or invisible. *)
  (# rootAttributeType:< rootAttribute;
     bo: ^betaObject; 
     options: ^optionDB;
     root: ^rootAttributeType;
  enter (bo[],options[])
  do <<SLOT ODbuildObjectRepresentation:descriptor>>
  exit root[]
  #);

attributeVisitor:
  (# nesting: @Integer; (* Set by caller of virtuals. *)
     onObjectAttribute: (* Prefix for attributes related to an object. *)
       (# bo: ^betaObject;
       enter bo[]
       do INNER
       #);
     onPatternAttribute: (* Prefix for attributes related to pattern. *)
       (# bp: ^betaPattern;
       enter bp[]
       do INNER
       #);
     onChar:< (* Simple char attribute *)
       (# ch: @Char; (* The current value. *)
          att: ^attribute; (* This attribute. *)
       enter (ch,att[])
       do INNER
       #);
     onShortInt:< (* Simple shortint attribute *)
       (# si: @ShortInt; (* The current value. *)
          att: ^attribute; (* This attribute. *)
       enter (si,att[])
       do INNER
       #);
     onInt:< (* Simple integer attribute *)
       (# i: @Integer; (* The current value. *)
          att: ^attribute; (* This attribute. *)
       enter (i,att[])
       do INNER
       #);
     onBool:< (* Simple boolean attribute *)
       (# b: @Boolean;
          att: ^attribute;
       enter (b,att[])
       do INNER
       #);
     onReal:< (* Simple real attribute *)
       (# r: @Real;
          att: ^attribute;
       enter (r,att[])
       do INNER
       #);
     onDynRef:< onObjectAttribute (* Simple dynamic reference attribute *)
       (# type: ^Text;
          att: ^attribute;
       enter (type[],att[])
       do INNER
       #);
     onOriRef:< onObjectAttribute (* Origin reference attribute *)
       (# type: ^Text;
          att: ^attribute;
       enter (type[],att[])
       do INNER
       #);
     onStatRef:< onObjectAttribute (* Static reference attribute *)
       (# type: ^Text;
          att: ^complexAttribute;
       enter (type[],att[])
       do INNER
       #);
     onPatRef:< onPatternAttribute (* Pattern reference attribute *)
       (# type: ^Text;
          att: ^attribute;
       enter (type[],att[])
       do INNER
       #);
     onDynCompRef:< onObjectAttribute (* Dynamic component reference attribute *)
       (# type: ^Text;
          att: ^attribute;
       enter (type[],att[])
       do INNER
       #);
     onStatCompRef:< onObjectAttribute (* Static component reference attribute *)
       (# type: ^Text;
          att: ^complexAttribute;
       enter (type[],att[])
       do INNER
       #);
     onRepRef:< (* Repetition attribute *)
       (# att: ^simplerepetitionAttribute
       enter att[]
       do INNER
       #);
     onRepRefHiddenBefore:< (* Called on the line representing hidden 
                             * repetition elements at the start of the 
                             * repetition*)
       (# att: ^repetitionAttribute
       enter att[]
       do INNER
       #);
     onRepRefHiddenAfter:< (* DO, but hidden elements at the end of the
                            * repetition. *)
       (# att: ^simpleRepetitionAttribute
       enter att[]
       do INNER
       #);
     onRepChar:< (* Char element in repetition *)
       (# ch: @Char;
          index: @Integer;
          att: ^simpleRepetitionAttribute;
       enter (ch,index,att[])
       do INNER
       #);
     onRepShortInt:< (* Shortint element in repetition. *)
       (# si: @ShortInt;
          index: @Integer;
          att: ^simpleRepetitionAttribute;
       enter (si,index,att[])
       do INNER
       #);
     onRepInt:< (* Integer element in repetition. *)
       (# i: @Integer;
          index: @Integer;
          att: ^simpleRepetitionAttribute;
       enter (i,index,att[])
       do INNER
       #);
     onRepBool:< (* Boolean element in repetition *)
       (# b: @Boolean;
          index: @Integer;
          att: ^simpleRepetitionAttribute;
       enter (b,index,att[])
       do INNER
       #);
     onRepReal:< (* Real element in repetition *)
       (# r: @Real;
          index: @Integer;
          att: ^simpleRepetitionAttribute;
       enter (r,index,att[])
       do INNER
       #);
     onRepDynRef:< onObjectAttribute (* Dynamic reference in repetition *)
       (# type: ^Text;
          index: @Integer;
          att: ^simpleRepetitionAttribute;
       enter (type[],index,att[])
       do INNER
       #);
     onRepDynCompRef:< onObjectAttribute (* Dynamic component reference in repetition *)
       (# type: ^Text;
          index: @Integer;
          att: ^simpleRepetitionAttribute;
       enter (type[],index,att[])
       do INNER
       #);
     onRepPatRef:< onPatternAttribute (* Dynamic pattern reference in repetition. *)
       (# type: ^Text;
          index: @Integer;
          att: ^simpleRepetitionAttribute;
       enter (type[],index,att[])
       do INNER
       #);
  do INNER
  #);

ATT_VISIBLE:       (# exit 1 #);
ATT_CONTRACTED:    (# exit 2 #);
ATT_INVISIBLE:     (# exit 3 #);

printVisibilityLevel:
  (# level: @Integer;
     s: ^stream;
  enter (level,s[])
  do (if level 
      //ATT_VISIBLE then 'ATT_VISIBLE'->s.putText;
      //ATT_CONTRACTED then 'ATT_CONTRACTED'->s.putText;
      //ATT_INVISIBLE then 'ATT_INVISIBLE'->s.putText;
     if);
  #);
