ORIGIN '~beta/basiclib/v1.4/betaenv';
BODY 'private/objectdumperbody';
INCLUDE 'options';

INCLUDE '~beta/mps/v5.0.1/astlevel';
INCLUDE '~beta/betaast/v5.0.1/betasematt';
INCLUDE '~beta/pretty/v5.0.1/astviewer';
INCLUDE '~beta/betaast/v5.0.1/gram';

--- lib:attributes ---

grammarVersion: (# exit '~beta/grammars/beta/v2.4/beta' #);

objectDumper:
  (# 
     <<SLOT ObjectDumperLib:attributes>>;
     
     (* AST, BETA, BETACFL
      * ==================
      * 
      * AST is the astInterface used by this objectDumper and is set on
      * initialization. AST should be initialized before objectDumper.init
      * is called. Likewise with BETACFL; *)
     
     AST: ^astInterface; (* From '~beta/mps/v4.9/astlevel'    *)
     BETACFL: ^AST.beta; (* From '~beta/betaast/v4.9/betacfl' *)
     BETA: @grammar;     (* From '~beta/betaast/v4.9/gram'    *)
     
     options: ^optionDB; (* From 'options'. Setup by init. *)
     
     
     nextObjectNumber: @IntegerValue (# do value+1->value #);
     resetNextObjectNumber: (# do 0->nextObjectNumber.value #);
     
     assignNumber:
       (# shortName,fullName: ^Text;
          number: @Integer;
       enter (shortName[],fullName[])
       do 
          nextObjectNumber->number;
          '~'->shortName.append;
          '~'->fullName.append;
          number->shortname.putint;
          number->fullname.putint;
       exit number
       #);
     
     now: @Integer;
     incTime: @(# do now+1->now #);
             
             
     
     (* BETAOBJECTTYPE
      * ==============
      * 
      * Further bind to type of betaObject handled by this objectDumper. *)
     
     betaObjectType:< betaObject;
     
     
     
     (* BETAPATTERNTYPE
      * ===============
      * 
      * Further bind to type of betaPattern handled by this objectDumper. *)
     
     betaPatternType:< betaPattern;
     
     
     
     (* BETAOBJECTOBJECTDESCRIPTOR
      * ==========================
      * 
      * Further bind to return ObjectDescriptor for the betaObject entered. *)
     
     betaObjectObjectDescriptor:<
       (# bo: ^betaObjectType;
          value: ^BETACFL.ObjectDescriptor;
       enter bo[]
       do INNER
       exit value[] 
       #);
     
     
     
     (* BETAPATTERNOBJECTDESCRIPTOR
      * ===========================
      * 
      * Further bind to return ObjectDescriptor for the betaPattern entered. *)
     betaPatternObjectDescriptor:<
       (# bp: ^betaPatternType;
          value: ^BETACFL.ObjectDescriptor;
       enter bp[]
       do INNER
       exit value[]
       #);
     
     
     
     (* DUMPASTPATH
      * ===========
      * 
      * Dumps a pathexpression describing the ast entered.
      * If short is TRUE, and there is more than two pattern names in
      * the full path-expression, only the last two pattern names will be
      * part of the expression returned. *)
     
     dumpAstPath:
       (# as: ^AST.ast; short: @Boolean;
          name: ^Text;
       enter (as[],short)
       <<SLOT ODdumpAstPath:dopart>>
       exit name[]
       #);
     
     
     (* SCANPATTERN
      * ===========
      * 
      * Scans the attributes of an object by executing forEachLine for each 
      * substance attribute in the dumped pattern.
      * 
      * If shortnames is TRUE, truncated pattern names (i.e. at most two 
      * patterns in path expression) are used when applicable.
      * 
      * attType is one of {Char,Integer,ShortInt,Boolean,Real,DynRef,
      * StatRef,OriginRef,PatRef}Attribute.
      * 
      * attName is the name of the attribute. For OriginAttribute, attName
      *     is the name of the pattern whose substance attributes are to 
      *     follow.
      * 
      * "statQua" is the statically known qualification of the attribute.
      *     For OriginAttribute, statQua is the statically known pattern 
      *     name of the enclosing pattern. If patterns in the prefix 
      *     chain share origins, forEachLine is called each time
      *     anyway. The user of dumpObject may use the offset value to
      *     check whether two origins are actually the same, if needed.
      * 
      * offset is the offset into the object of the attribute. If
      * attType is StatRefAttribute or StatCompRefAttribute, a negative
      * offset signals that the part object is offline allocated.
      *
      * attod is NONE unless attType is StatRefAttribute or 
      * StatCompRefAttribute, and if the attribute is inline allocated. In that
      * case, attod is the objectDescriptor corresponding to the inline 
      * allocated part object. *)
          
     scanPattern:
       (# bod: ^BETACFL.ObjectDescriptor;
          shortnames: @Boolean;
          forEachLine:<
            (# attType, offset: @Integer; attName, statQua: ^Text;
               attod: ^BETACFL.ObjectDescriptor;
            enter (attType,attName[],statQua[],offset,attod[])
            do INNER
            #);
          originDescription:<
            (# patname, description: ^Text;
            enter patname[]
            do patname.copy->description[];
               'ORIGIN of '->description.prepend;
               INNER;
            exit description[]
            #);
       enter (bod[],shortnames)
       do <<SLOT ODscanPattern:descriptor>>
       #);
     
     init:<
       (# 
       enter (AST[],BETACFL[])
       <<SLOT ODobjectDumperInit:dopart>>
       #);
     
     (* PRETTYPRINTER
      * ============= *)
     
     prettyPrinter:
       (# init: (# <<SLOT ODprettyPrintInit:dopart>> #);
          <<SLOT ODprettyPrintLib:attributes>>;
          (* private: *) pretty: ^AST.ASTViewer; inx: @Integer; 
          
          a: ^AST.ast; level: @Integer; pp: ^Text;
       enter (a[],level)
       <<SLOT ODprettyPrinter:dopart>>             
       exit pp[]
       #);
     
     odprivate: @<<SLOT ODobjectDumperPrivate:descriptor>>;
  do INNER
  #);

betaObject:
  (* Abstract superpattern for the representation of BETA objects
   * 
   * *value virtuals should be further bound to return the value at
   * the offset given as enter parameter. Offset values are relative
   * to the start of the object part of the object. If the object
   * represented is really a component, the further binding of betaObject
   * must handle this itself.
   *)
  (# betaPatternType:< betaPattern;
     betaObjectType:< betaObject; (* Type of THIS(betaObject) *)
     objectDumperType:< objectdumper;
     
     dumper: ^objectDumperType; (* enter parameter to init. *)
     
     timestamp: @Integer; (* Used by referees of this object to show their
                           * continued interest in this object. By touching
                           * the timestamp (updating it to the value of
                           * dumper.currentTime), they may signal that
                           * the  object should not be deleted from the 
                           * objectdb until dumper.currentTime has been 
                           * increased. *)
     touch: @(# do (if dumper[]<>NONE then dumper.now->timestamp if) #);
     
     number: @Integer; (* Serial number of this object. If the option
                        * "numberObjects" (see optionlist.bet) is TRUE,
                        * a serial number if assigned each new instance
                        * of betaObject when it's description is first
                        * queried. The number will then be part of the 
                        * description. *)
     
     description: @descriptionType;
     descriptionType:<
       (# shortName,fullName: ^Text;
          shortWithNumber,fullWithNumber: ^Text;
          short,numbered: @Boolean;
          value: ^Text;
       enter (short,numbered)
       do (if shortName[]//NONE then
              INNER;
              (if shortName[]//NONE then
                  (* Not overridden in specialization *)
                  (if isNone then
                      'NONE'->shortName[]->fullName[]
                        ->shortWithNumber[]->fullWithNumber[];
                   else
                      (# od: ^dumper.BETACFL.ObjectDescriptor;
                         bo: ^betaObject;
                      do 
                         (if isDopartObject then
                             dopartObjectOriOff->ReferenceAttr->bo[];
                             bo[]->dumper.betaObjectObjectDescriptor
                               ->od[];
                          else
                             THIS(betaObject)[]
                               ->dumper.betaObjectObjectDescriptor
                               ->od[];
                         if);
                         (if od[]<>NONE then
                             ((od[],TRUE)->dumper.dumpAstPath).copy
                               ->shortName[];
                             ((od[],FALSE)->dumper.dumpAstPath).copy
                               ->fullName[];
                          else
                             'UNKNOWN'->shortName[]->fullName[];
                         if);
                         (if isDopartObject then
                             'DOPART OBJECT. Origin is '->shortName.prepend;
                             'DOPART OBJECT. Origin is '->fullName.prepend;
                         if);
                         (shortName.copy->shortWithNumber[],
                         fullName.copy->fullWithNumber[])
                           ->dumper.assignNumber
                           ->number;
                      #);
                  if);
              if);
          if);
          (if numbered then
              (if short then 
                  shortWithNumber[]->value[]
               else 
                  fullWithNumber[]->value[]
              if);
           else
              (if short then 
                  shortName[]->value[]
               else 
                  fullName[]->value[]
              if);
          if);
       exit value[]
       #);
     
     init:<
       (# enter dumper[]
       do INNER
       #);
     
     IsNone:< BooleanValue;
     IsComponentObject:< BooleanValue;
     IsDopartObject:< BooleanValue;
     
     isGarbage:< BooleanValue;
     Equal:< BooleanValue
       (# other: ^betaObjectType;
       enter other[]
       do INNER
       #);
     CharAttr:<
       (# offset: @Integer; (* offset in bytes into object *)
          value: @Char;
       enter offset
       do INNER
       exit value
       #);
     SetCharAttr:<
       (# offset: @Integer; (* offset in bytes into object *)
          value: @Char;
       enter (offset,value)
       do INNER
       #);       
     BooleanAttr:<
       (# offset: @Integer; (* offset in bytes into object *)
          value: @Boolean;
       enter offset
       do INNER
       exit value
       #); 
     SetBooleanAttr:<
       (# offset: @Integer; (* offset in bytes into object *)
          value: @Boolean;
       enter (offset,value)
       do INNER
       #);
     ShortIntAttr:< 
       (# offset: @Integer;
          value: @ShortInt;
       enter offset
       do INNER
       exit value
       #);
     SetShortIntAttr:< 
       (# offset: @Integer;
          value: @ShortInt;
       enter (offset,value)
       do INNER
       #);
     IntegerAttr:<
       (# offset: @Integer;
          value: @Integer;
       enter offset
       do INNER
       exit value
       #);
     SetIntegerAttr:<
       (# offset: @Integer;
          value: @Integer;
       enter (offset,value)
       do INNER
       #);
     RealAttr:<
       (# offset: @Integer;
          value: @Real;
       enter offset
       do INNER
       exit value
       #);
     SetRealAttr:<
       (# offset: @Integer;
          value: @Real;
       enter (offset,value)
       do INNER
       #);
     ReferenceAttr:<
       (# offset: @Integer;
          value: ^betaObjectType;
       enter offset
       do INNER
       exit value[]
       #);
     SetReferenceAttr:<
       (# offset: @Integer;
          value: ^betaObjectType;
       enter (offset,value[])
       do INNER
       #);
     OriginAttr:<
       (# offset: @Integer;
          value: ^betaObjectType;
       enter offset
       do INNER
       exit value[]
       #);
     SetOriginAttr:<
       (# offset: @Integer;
          value: ^betaObjectType;
       enter (offset,value[])
       do INNER
       #);
     PatternAttr:<
       (# offset: @Integer;
          value: ^betaPatternType;
       enter offset
       do INNER
       exit value[]
       #);
     SetPatternAttr:<
       (# offset: @Integer;
          value: ^betaPatternType;
       enter (offset,value[])
       do INNER
       #);
     Range:<
       (# offset: @Integer;
          low,high: @Integer;
       enter offset   
       do INNER
       exit (low,high)
       #);
     SetRange:<
       (* Changes the range of repetition attribute at offset. If high is
        * larger than existing range, a number of entries is added at the
        * end. If high is less than existing range, a number of entries are
        * removed at the end. Thus, semantics correspond to those of
        * extend on a repetition. *)
       (# offset,high: @Integer;
       enter (offset,high)
       do INNER
       #);
     CharRepAttr:<
       (# offset: @Integer;  (* offset in bytes into object *)
          from,to: @Integer; (* Index range in repetition. *)
          value: [1]@Char;
       enter (offset,from,to)
       do INNER
       exit value
       #);
     SetCharRepAttr:<
       (# offset: @Integer;  (* offset in bytes into object *)
          from,to: @Integer; (* Index range in repetition. *)
          value: [1]@Char;
       enter (offset,from,to,value)
       do INNER
       #);
     BooleanRepAttr:<
       (# offset: @Integer; (* offset in bytes into object *)
          from,to: @Integer; (* Index range in repetition. *)
          value: [1]@Boolean;
       enter (offset,from,to)
       do INNER
       exit value
       #);
     SetBooleanRepAttr:<
       (# offset: @Integer; (* offset in bytes into object *)
          from,to: @Integer; (* Index range in repetition. *)
          value: [1]@Boolean;
       enter (offset,from,to,value)
       do INNER
       #);
     ShortIntRepAttr:< 
       (# offset: @Integer;
          from,to: @Integer;
          value: [1]@ShortInt;
       enter (offset,from,to)
       do INNER
       exit value
       #);
     SetShortIntRepAttr:< 
       (# offset: @Integer;
          from,to: @Integer;
          value: [1]@ShortInt;
       enter (offset,from,to,value)
       do INNER
       #);
     IntegerRepAttr:<
       (# offset: @Integer;
          from,to: @Integer;
          value: [1]@Integer;
       enter (offset,from,to)
       do INNER
       exit value
       #);
     SetIntegerRepAttr:<
       (# offset: @Integer;
          from,to: @Integer;
          value: [1]@Integer;
       enter (offset,from,to,value)
       do INNER
       #);
     RealRepAttr:<
       (# offset: @Integer;
          from,to: @Integer;
          value: [1]@Real;
       enter (offset,from,to)
       do INNER
       exit value
       #);
     SetRealRepAttr:<
       (# offset: @Integer;
          from,to: @Integer;
          value: [1]@Real;
       enter (offset,from,to,value)
       do INNER
       #);
     ReferenceRepAttr:<
       (# offset: @Integer;
          from,to: @Integer;
          value: [1]^betaObjectType;
       enter (offset,from,to)
       do INNER
       exit value
       #);
     SetReferenceRepAttr:<
       (# offset: @Integer;
          from,to: @Integer;
          value: [1]^betaObjectType;
       enter (offset,from,to,value)
       do INNER
       #);
     PatRefRepAttr:<
       (# offset: @Integer;
          from,to: @Integer;
          value: [1]^betaPatternType;
       enter (offset,from,to)
       do INNER
       exit value
       #);
     SetPatRefRepAttr:<
       (# offset: @Integer;
          from,to: @Integer;
          value: [1]^betaPatternType;
       enter (offset,from,to,value)
       do INNER
       #);
     PartObject:<
       (* A negative offset means that the part object requested is
        * offline allocated. In that case partObject should effectively
        * do the same as referenceValue. *)
       (# offset: @Integer;
          value: ^betaObjectType;
       enter offset
       do INNER
       exit value[]
       #);
     SetPartObject:<
       (* Only offline allocated part objects can be set, i.e. offset should be
        * negative. If not, a runtime error will occur. *)
       (# offset: @Integer;
          value: ^betaObjectType;
       enter (offset,value[])
       do INNER
       #);
  #);
          
BetaPattern:
  (* The description of a pattern variable value. *)
  (# betaObjectType:< betaObject;
     betaPatternType:< betaPattern; (* Type of THIS(betaPattern) *)
     objectDumperType:< objectdumper;
     
     dumper: ^objectDumperType;
     number: @Integer; (* Serial number of this pattern *)
     
     
     timestamp: @Integer;
     touch: @(# do (if dumper[]<>NONE then dumper.now->timestamp if) #);
     
     init:<
       (# enter dumper[]
       do INNER
       #);
     
     Equal:< BooleanValue
       (# other: ^betaPatternType;
       enter other[]
       do INNER
       #);
     isNone:< BooleanValue;
     origin:< 
       (# value: ^betaObjectType;
       do INNER
       exit value[]
       #);
     SetOrigin:<
       (# value: ^betaObjectType;
       enter value[]   
       do INNER
       #);
     
     description: @descriptionType;
     descriptionType:<
       (# shortName,fullName: ^Text;
          shortWithNumber,fullWithNumber: ^Text;
          short: @Boolean;
          numbered: @Boolean;
          value: ^Text;
       enter (short,numbered)
       do (if shortName[]//NONE then
              INNER;
              (if shortName[]//NONE then
                  (* Not overridden in specialization *)
                  (if isNone then
                      'NONE'->shortName[]->fullName[]
                        ->shortWithNumber[]->fullWithNumber[];
                   else
                      (# od: ^dumper.BETACFL.ObjectDescriptor;
                      do 
                         THIS(betaPattern)[]
                           ->dumper.betaPatternObjectDescriptor
                           ->od[];
                         ((od[],TRUE)->dumper.dumpAstPath).copy->shortName[];
                         ((od[],FALSE)->dumper.dumpAstPath).copy->fullName[];

                         (shortName.copy->shortWithNumber[],
                         fullName.copy->fullWithNumber[])
                           ->dumper.assignNumber
                           ->number;
                      #);
                  if);
              if);
          if);
          (if numbered then
              (if short then 
                  shortWithNumber[]->value[]
               else 
                  fullWithNumber[]->value[]
              if);
           else
              (if short then 
                  shortName[]->value[]
               else 
                  fullName[]->value[]
              if);
          if);
       exit value[]
       #);
  #);   

CharAttribute:        (# exit  -1 #);
IntegerAttribute:     (# exit  -2 #);
ShortIntAttribute:    (# exit  -3 #);
BooleanAttribute:     (# exit  -4 #);
RealAttribute:        (# exit  -5 #);

DynRefAttribute:      (# exit  -6 #);
StatRefAttribute:     (# exit  -7 #);
OriginAttribute:      (# exit  -8 #);
PatRefAttribute:      (# exit  -9 #);

DynCompRefAttribute:  (# exit -10 #);
StatCompRefAttribute: (# exit -11 #);

CharRepAttribute:     (# exit -12 #);
BoolRepAttribute:     (# exit -13 #);
ShortIntRepAttribute: (# exit -14 #);
IntRepAttribute:      (# exit -15 #);
RealRepAttribute:     (# exit -16 #);
RefRepAttribute:      (# exit -17 #);
CompRepAttribute:     (# exit -18 #);
PatRefRepAttribute:   (# exit -19 #);

dopartObjectOriOff:   (# exit 8 #);
