ORIGIN '~beta/basiclib/v1.5/betaenv';
BODY 'private/mpsinterfacebody';

INCLUDE '~beta/betaast/v5.1/betasematt';
INCLUDE '~beta/betaast/v5.1/gram';
INCLUDE '~beta/mps/v5.1/astlevel';
INCLUDE '~beta/containers/v1.5/hashTable';
INCLUDE '~beta/sysutils/v1.5/objinterface';

--- lib:attributes ---

mpsinterface: 
  (# 
     <<SLOT mpsinterfacelib: Attributes>>;
     
     AST: @astInterface;
     BETACFL: @AST.beta;
     BETA: @grammar; (* From '~beta/betaast/v4.9/gram'    *)
     
     astRefToAst:
       (* Exits the Ast.ast identified by:
        *    fg: Fragment group.
        *    formIndex: Form number in fragment group.
        *    astIndex: ast index in the form. *)
       (# astType:< AST.ast;
          fg: ^AST.fragmentGroup; formIndex,astIndex: @Integer;
          a: ^astType;
          (*private:*) ff: ^AST.fragmentForm;
       enter (fg[],formIndex,astIndex)
       <<SLOT ptToObjectDescriptorBody:dopart>>
       exit a[]
       #);
     
     mySetupOrigin:
       (* Used instead of fragment.setupOrigin to be able to catch
        * exceptions from top.open, and to ensure that onOpenGroup
        * is actually called when a group is opened. *)
       (# fg: ^AST.fragmentGroup;
       enter fg[]
       <<SLOT mpsintMySetupOrigin:dopart>>
       #);
     
     fragmentGroupTable: @HashTable
       (* Table of fragmentGroups that have already been opened. *)
       (#
          <<SLOT fragmentGroupTable: attributes>>;
          
          element::
            (# groupName: ^Text;
               fg: ^AST.fragmentGroup;
            #);
          
          hashFunction::
            (# 
            do e.groupName.scanAll (# do ch*26 + value -> value #)
            #);
          
          getFragmentGroup:
            (* If the requested group is not already in the table, 
             * it is opened and inserted into the table.
             *)
            (# groupName: ^Text;
               foundGroup: ^AST.fragmentGroup;
            enter groupName[]
            do <<SLOT getFragmentGroupBody: descriptor>>
            exit foundGroup[]
            #)
       #);
     
     modTimeOk:< BooleanValue
       (* Called to check whether the modification time on a newly
        * opened fragment group is ok for this application. If FALSE 
        * is returned, the onNewGroup exception is raised, and the
        * fragment group not used. *)
       (# fg: ^AST.fragmentGroup;
          modtime: @Integer;
       enter (fg[],modtime)
       do TRUE->value; INNER;
       #);
     
        
     onOpenGroup:< 
       (* Called when a fragmentgroup is about to be opened. *)
       (# groupName: ^Text;
       enter groupName[]
       do INNER
       #);
     onOpenGroupDone:<
       (* Called when a fragmentgroup has been opened. *)
       (# groupName: ^Text; fg: ^AST.fragmentGroup;
       enter (groupName[],fg[])
       do INNER
       #);
     
     onOldGroup:< Exception
       (* Called when a fragmentgroup needs to be parsed. 
        * If onOldGroup handles the exception (i.e. sets allowParsing to true)
        * then the fragmentgroup will be parsed *)
       (# groupName: ^Text; allowParsing: @boolean;
       enter groupName[]
       do INNER
       exit allowParsing
       #);
     onNewGroup:< Exception
       (* Called as a result of modtimeOk returning FALSE *)
       (# groupName: ^Text; allowNewGroup: @boolean;
       enter groupName[]
       do INNER
       exit allowNewGroup
       #);
     onGroupNotFound:< Exception
       (* Called when a fragmentgroup could not be found. *)
       (# groupName: ^Text;
       enter groupName[]
       do INNER
       #);
     onUncheckedGroup:< Exception
       (* Raised if an unchecked group was opened. *)
       (# groupName: ^Text; fg: ^AST.fragmentGroup; allowChecking: @boolean;
       enter (groupName[],fg[])
       do INNER
       exit allowChecking
       #);
     onFatalParseError:< Exception
       (# errNo: @integer
       enter errNo
       do INNER
       #);
     onParseErrors:< Exception
       (# groupName: ^text
       enter groupName[]
       do INNER
       #);
     onOtherError:< Exception
       (# errorText: ^text
       enter errorText[]
       do INNER
       #);
            
     init:< (# <<SLOT mpsinterfaceInitBody:dopart>> #);
  do INNER
  #);
