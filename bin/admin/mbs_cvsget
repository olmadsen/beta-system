#!/usr/local/bin/perl5 -s
#-*-Perl-*-

require "dirlist";

sub ProcessDirSpecial {
    my ($destpath) = @_;
    print "ProcessDirSpecial($destpath)\n" if ($verbose);
    if ($destpath =~ m#betarun/v\d+\.\d+/([^\/]+)\/?$#) {
	$machine=$1;
	if ("$machine" eq "GEN" ||
	    "$machine" eq "doc" || 
	    "$machine" eq "ppcmac" ) { return; }
	print "BETARUN: Setting up links/copies of Makefiles\n";
	chdir &path("$betalib/$destpath");
	if ($MACHINETYPE eq 'NTI') {
	    system "copy Makefile_nti Makefile";
	    #foreach $dir ('C', 'GC') {
		#chdir &path("$dir");
		#system "copy Makefile_nti Makefile";
		#system "copy xmakefile_nti xmakefile";
		#chdir $PARENTDIR;
	    #}
	} else {
	    system "ln -s Makefile-$machine Makefile" if (-e "Makefile-$machine");
	    foreach $dir ('C', 'GC', 'CRUN', 'NEWRUN') {
		chdir &path("$dir");
		system "ln -s Makefile-$machine Makefile" if (-e "Makefile-$machine");
		chdir $PARENTDIR;
	    }
	}
    } 
}

sub CvsGetLib {
    my ($destdir, $cvsmodule, $prefix, $tag) = @_;
    if (!defined $prefix || length($prefix) == 0) { 
	print "\tchdir $betalib\n" if ($verbose);
	chdir &path($betalib) if (!$simulate);
    } else {
	&SmartMkdir("$betalib/$prefix");
	print "\tchdir $betalib/$prefix\n" if ($verbose);
	if (!$simulate) {
	    chdir &path("$betalib/$prefix");
	}
    }

    $cvscmd  = "";
    $cvscmd .= "-Q " if (!$verbose);
    $cvscmd .= "get ";
    $cvscmd .= "-r $tag " if ($tag);
    $cvscmd .= $mergeFrom if ($mergeFrom); 
    $cvscmd .= "-d $destdir " if ($destdir);
    $cvscmd .= "$cvsmodule";

    print "\tcvs $cvscmd\n" if ($verbose);
    &cvs($cvscmd) if (!$simulate);
    exit(1) if ($?);
}

# Get all tags hashed by module:
sub CvsGetHistory {
    my ($line, $T, $date, $time, $zero, $user, $lib, $tag);
    print "Getting CVS history, please wait...";
    open(TAG, "cvs history -a -T|") || die "Unable to start cvs history: $!";
    foreach $line (<TAG>) {	 
	($T,$date,$time,$zero,$user,$lib,$tag) = split(' ', $line);
	if ($tag =~ /^\[([^\:\]]+)/) {
	    $tag = $1;
	}
	if (defined $TagList{$lib}) {
	    $TagList{$lib} .= $tag . ' ';
	} else {
	    $TagList{$lib} =  $tag . ' ';
	}
    }
    close(TAG);
    print "done.\n\n";
}


sub UserChooseTag {
    foreach $dir (@Dirs) {
	if ($CvsTags{$dir} =~ /^\%(\S+)/) {
	    next if ($1 eq 'IGNORE');
	    if ($1 eq 'NONCVS') {
		print "NonCVS: $dir, skipping\n" if ($verbose);
		next;
	    }
	    print "Unknown '%'-tag in CvsTag: \"$1\", skipping $dir\n";
	    next;
	}
	
	($cvsmodule, $DefaultTag) = split(/\@/,$CvsTags{$dir});

	print "\n\n" if (!$UseDefaults);
	print "===== $dir  ";

	if (-d &path("$betalib/$dir")) {
	    print "[exists, skipped]\n";
	    next;
	}

	if ($dir =~ m#^([^\/]+)\/([^\/]+)$#) {
	    $version = $2;
	} else {
	    undef $version;
	}

	($matchrel = $RELEASE_) =~ s/(\W)/\\$1/g;
	# FIXME: What is the version in tags for those without version???
	if (defined $version) {
	    ($version_ = $version) =~ s/\./\_/g; 
	    ($matchver = $version_) =~ s/(\W)/\\$1/g;
	    $matchtag = '^' . $matchrel . '([a-z])_' . $matchver;
	} else {
	    $matchtag = '^' . $matchrel . '([a-z])';
	}

	# print "$dir: $matchtag\n"; 
	# print $TagList{$cvsmodule}, "\n";

	$lastA = 'a';
	@Tags = (); @otherTags = ();
	if ($cvsmodule =~ /^([^\/\@]+)/) {
	    $mainmodule = $1;
	} else {
	    $mainmodule = $cvsmodule;
	}
	if (defined $TagList{$mainmodule}) {
	    foreach $tag (split(' ', $TagList{$mainmodule})) {
		if ($tag =~ /$matchtag/i) {
		    $atoz = $1;
		    #$subversion = $2;
		    if ($lastA lt $atoz) {
			@Tags = ();
			$lastA = $atoz;
		    }
		    push(@Tags, $tag);
		} else {
		    push(@otherTags, $tag);
		}
	    }
	} elsif ($DefaultTag ne 'HEAD') {
	    push(Tags, $DefaultTag);
	}
	$defaultChoice = -1;
	@Tags = sort(@Tags);
	@otherTags = sort(@otherTags);
	unshift(@Tags, "No tag, getting head-revision");
	push(@Tags, @otherTags);
	if ($DefaultTag eq 'HEAD') {
	    $defaultChoice = 0;
	} else {
	    for ($i = 0; $i < scalar @Tags; $i++) {
		if ($DefaultTag eq $Tags[$i]) {
		    $defaultChoice = $i;
		}
	    }
	    $defaultChoice = 0 if ((scalar @Tags) == 1);
	}

	if (0 <= $defaultChoice && $UseDefaults) {
	    if ($defaultChoice) {
		print "Tag: $Tags[$defaultChoice]\n";
	    } else {
		print "$Tags[$defaultChoice]\n";
	    }
	    $line = $defaultChoice;
	} else {
	    print "\n";
	    for ($i = 0; $i < scalar @Tags; $i++) {
		print "$i) $Tags[$i]\n";
	    }
	    $line = "";
	    while (length($line) < 1) {
		if ($defaultChoice != -1) {
		    print "Default is $Tags[$defaultChoice]: ";
		} else {
		    print "Choose: ";
		}

		$line = &GetAnswer();
		if (0 <= $defaultChoice && length($line)<1) {
		    $line = $defaultChoice;
		}
	    }
	}

	if ($dir =~ /^(.*)\/([^\/]+)/) {
	    $destdir = $2;
	    $prefix = $1;
	} else {
	    undef $prefix;
	    $destdir = $dir;
	}
	if ($line == 0) {
	    &CvsGetLib($destdir, $cvsmodule, $prefix);
	} else {
	    &CvsGetLib($destdir, $cvsmodule, $prefix, $Tags[$line]);
	}

	&ProcessDirSpecial($dir);
    }
}

# --- program:descriptor---   ;)

print <<EOF;
This script will cvs-checkout all the directories constituting "$RELEASE"
of the MBS.  It will place this in the directory "$betalib".

EOF

foreach (@ARGV) {
    if (/^\-\-(.*)$/) {
	$option=$1;
	if ($option eq 'verbose') {
	    $verbose = 1;
	} elsif ($option eq 'simulate') {
	    $simulate = 1;
	} elsif ($option eq 'usedefaults') {
	    $UseDefaults = 1;
	} elsif ($option eq 'help') {
	    $help = 1;
	} elsif ($option =~ /^mergefrom[\=\:](.+)/) {
	    $mergeFrom = "-j $1 ";
	} else {
	    print "mbs_cvsget: Unrecognized option: $_\n";
	    $help=2;
	}
    }
}

$help = 1 if ($h);
$UseDefaults = 1 if ($u);

if ($help) {
    print "Usage: mbs_cvsget [options]\n";
    print "-v    --verbose\n";
    print "-u    --usedefaults\n";
    print "-n    --simulate\n";
    print "-h    --help\n";
    print "\n";
    exit $help-1;
}

($RELEASE_ = $RELEASE) =~ s/\./\_/g;
chdir &path($betalib);		

if (!$UseDefaults) {
    &CvsGetHistory;
}
print "Checking out:\n";
&UserChooseTag;

1;
