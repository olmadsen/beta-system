#!/usr/local/bin/perl -s
#-*-Perl-*-

push(@INC, $ENV{'BETALIB'} . "/bin/admin");

sub usage
{
    print "Usage: mbs_cvsget [options]\n";
    print "         -v    --verbose\n";
    print "         -u    --usedefaults\n";
    print "         -n    --simulate\n";
    print "         -h    --help\n";
    print "       Do a cvs-checkout all the directories constituting BETALIB\n";
    exit $help-1;
}

if ($h) {
    &usage();
}

require "dirlist";

sub ProcessDirSpecial {
    my ($destpath) = @_;
    print "ProcessDirSpecial($destpath)\n" if ($verbose);
    if ($destpath =~ m#betarun/([^\/]+)\/?$#) {
	$machine=$1;
	if ("$machine" eq "GEN" ||
	    "$machine" eq "doc" || 
	    "$machine" eq "ppcmac" ) { return; }
	print "BETARUN: Setting up links/copies of Makefiles\n";
	chdir &path("$betalib/$destpath");
	if ($machine =~ /^nti\_(.*)/i) {
	    if ($1 eq "ms") {
		open (MF, ">Makefile") || die "$!";
		print MF "!include Makefile-nti_ms\n";
		close MF;
	    } elsif ($1 eq "gnu") {
		open (MF, ">Makefile") || die "$!";
		print MF "include Makefile-nti_gnu\n";
		close MF;
	    } else {
		print "Error: machinetype nti_$1 not recognized\n";
		exit(1);
	    }
	} else {
	    system "ln -s Makefile-$machine Makefile" if (-e "Makefile-$machine");
	    foreach $dir ('C', 'GC', 'CRUN', 'NEWRUN', 'P') {
		chdir &path($dir);
		system "ln -s Makefile-$machine Makefile" if (-e "Makefile-$machine");
		chdir $PARENTDIR;
	    }
	}
    } 
    # added by datpete Mon Jun  8 10:56:53 MET DST 1998 (suggested by eernst)
    if ($OS eq 'UNIX' && $destpath =~ m#emacs$#) {
	print "EMACS: byte compiling .el files\n";
	chdir &path("$betalib/$destpath");
	foreach $el ('beta-mode.el', 
		     'beta-utils.el',
		     'beta-fast-indent.el',
		     'beta-menu19.el', 
		     'beta-hilit19.el', 
		     'beta-hilit-lucid.el', 
		     'beta-font-lock.el', 
		     'run-mode.el') {
	    system "emacs -batch --eval '(byte-compile-file \"$el\")'" if (-e "$el");
	}
    } 
}

sub CvsGetLib {
    my ($destdir, $cvsmodule, $prefix, $tag) = @_;
#    if (($OS eq "UNIX") && (!-d "$ENV{'CVSROOT'}/$cvsmodule")) {
#	print "***** Repository $cvsmodule does not exist, skipping\n";
#	return;
#    }
    if (!defined $prefix || length($prefix) == 0) { 
	print "\tchdir $betalib\n" if ($verbose);
	chdir &path($betalib) if (!$simulate);
    } else {
	&SmartMkdir("$betalib/$prefix");
	print "\tchdir $betalib/$prefix\n" if ($verbose);
	if (!$simulate) {
	    chdir &path("$betalib/$prefix");
	}
    }

    $cvscmd  = "";
    $cvscmd .= "-Q " if (!$verbose);
    $cvscmd .= "-d $ENV{'CVSROOT'} " if defined($ENV{'CVSROOT'});
    $cvscmd .= "get ";
    $cvscmd .= "-r $tag " if ($tag);
    $cvscmd .= $mergeFrom if ($mergeFrom); 
    $cvscmd .= "-d $destdir " if ($destdir);
    $cvscmd .= "$cvsmodule";

    print "\tcvs $cvscmd\n" if ($verbose);
    &cvs($cvscmd);
    exit(1) if ($?);
}

# Get all tags hashed by module:
sub CvsGetHistory {
    my ($line, $T, $date, $time, $zero, $user, $lib, $tag);
    print "Getting CVS history, please wait...";
    open(TAG, "cvs history -a -T|") || die "Unable to start cvs history: $!";
    foreach $line (<TAG>) {	 
	($T,$date,$time,$zero,$user,$lib,$tag) = split(' ', $line);
	if ($tag =~ /^\[([^\:\]]+)/) {
	    $tag = $1;
	}
	if (defined $TagList{$lib}) {
	    $TagList{$lib} .= $tag . ' ';
	} else {
	    $TagList{$lib} =  $tag . ' ';
	}
    }
    close(TAG);
    print "done.\n\n";
}


sub UserChooseTag {
    foreach $dir (@Dirs) {
	if ($CvsTags{$dir} =~ /^\%(\S+)/) {
	    if ($1 eq 'IGNORE'){
		print "IGNORE: $dir, skipping\n" if ($verbose);
		next;
	    }
	    if ($1 eq 'NONCVS') {
		print "NonCVS: $dir, skipping\n" if ($verbose);
		next;
	    }
	    print "Unknown '%'-tag in CvsTag: \"$1\", skipping $dir\n";
	    next;
	}
	
	($cvsmodule, $DefaultTag) = split(/\@/,$CvsTags{$dir});

	print "\n\n" if (!$UseDefaults);

	if (-d &path("$betalib/$dir")) {
	    print "===== $dir  [exists, skipped]\n" unless($quiet);
	    next;
	}

	print "===== $dir  ";

	if ($dir =~ m#^([^\/]+)\/([^\/]+)$#) {
	    $version = $2;
	} else {
	    undef $version;
	}

	($matchrel = $RELEASE_) =~ s/(\W)/\\$1/g;
	# FIXME: What is the version in tags for those without version???
	if (defined $version) {
	    ($version_ = $version) =~ s/\./\_/g; 
	    ($matchver = $version_) =~ s/(\W)/\\$1/g;
	    $matchtag = '^' . $matchrel . '([a-z])_' . $matchver;
	} else {
	    $matchtag = '^' . $matchrel . '([a-z])';
	}

	# print "$dir: $matchtag\n"; 
	# print $TagList{$cvsmodule}, "\n";

	$lastA = 'a';
	@Tags = (); @otherTags = ();
	if ($cvsmodule =~ /^([^\/\@]+)/) {
	    $mainmodule = $1;
	} else {
	    $mainmodule = $cvsmodule;
	}
	if (defined $TagList{$mainmodule}) {
	    foreach $tag (split(' ', $TagList{$mainmodule})) {
		if ($tag =~ /$matchtag/i) {
		    $atoz = $1;
		    #$subversion = $2;
		    if ($lastA lt $atoz) {
			@Tags = ();
			$lastA = $atoz;
		    }
		    push(@Tags, $tag);
		} else {
		    push(@otherTags, $tag);
		}
	    }
	} elsif ($DefaultTag ne 'HEAD') {
	    push(Tags, $DefaultTag);
	}
	$defaultChoice = -1;
	@Tags = sort(@Tags);
	@otherTags = sort(@otherTags);
	unshift(@Tags, "No tag, getting head-revision");
	push(@Tags, @otherTags);
	if ($DefaultTag eq 'HEAD') {
	    $defaultChoice = 0;
	} else {
	    for ($i = 0; $i < scalar @Tags; $i++) {
		if ($DefaultTag eq $Tags[$i]) {
		    $defaultChoice = $i;
		}
	    }
	    $defaultChoice = 0 if ((scalar @Tags) == 1);
	}

	if (0 <= $defaultChoice && $UseDefaults) {
	    if ($defaultChoice) {
		print "Tag: $Tags[$defaultChoice]\n";
	    } else {
		print "$Tags[$defaultChoice]\n";
	    }
	    $line = $defaultChoice;
	} else {
	    print "\n";
	    for ($i = 0; $i < scalar @Tags; $i++) {
		print "$i) $Tags[$i]\n";
	    }
	    $line = "";
	    while (length($line) < 1) {
		if ($defaultChoice != -1) {
		    print "Default is $Tags[$defaultChoice]: ";
		} else {
		    print "Choose: ";
		}

		$line = &GetAnswer();
		if (0 <= $defaultChoice && length($line)<1) {
		    $line = $defaultChoice;
		}
	    }
	}

	if ($dir =~ /^(.*)\/([^\/]+)/) {
	    $destdir = $2;
	    $prefix = $1;
	} else {
	    undef $prefix;
	    $destdir = $dir;
	}
	if ($line == 0) {
	    &CvsGetLib($destdir, $cvsmodule, $prefix);
	} else {
	    &CvsGetLib($destdir, $cvsmodule, $prefix, $Tags[$line]);
	}

	&ProcessDirSpecial($dir);
    }
}

# --- program:descriptor---   ;)

if (!$quiet) {
    print <<EOF;
This script will cvs-checkout all the directories constituting "$RELEASE"
of the MBS.  It will place this in the directory "$betalib".

EOF
}

foreach (@ARGV) {
    if (/^\-\-(.*)$/) {
	$option=$1;
	if ($option eq 'verbose') {
	    $verbose = 1;
	} elsif ($option eq 'simulate') {
	    $simulate = 1;
	} elsif ($option eq 'usedefaults') {
	    $UseDefaults = 1;
	} elsif ($option eq 'help') {
	    $help = 1;
	} elsif ($option =~ /^mergefrom[\=\:](.+)/) {
	    $mergeFrom = "-j $1 ";
	} else {
	    print "mbs_cvsget: Unrecognized option: $_\n";
	    $help=2;
	}
    }
}

$help = 1 if ($h);
$UseDefaults = 1 if ($u);

if ($help){
    &usage();
}

($RELEASE_ = $RELEASE) =~ s/\./\_/g;
chdir &path($betalib);

if(!defined($ENV{"CVSROOT"}))
{
    open(ROOTFILE, "<bin/CVS/Root") || die("Couldn't find CVS Root: $!");
    $cvsroot = <ROOTFILE>;
    chop($cvsroot);
    $ENV{"CVSROOT"} = $cvsroot;
}

if (!$UseDefaults) {
    &CvsGetHistory;
}
print "Checking out:\n" unless ($quiet);
&UserChooseTag;

1;
