#!/usr/local/bin/perl

# (c) Copyright 2002 Mjølner Informatics
# Written by Erik Corry

# Utility for committing in betarun and compiler.
# You don't have to use this script if you don't want to.
# It has the function of:
#   Incrementing the version number in version.c or [compilerrcm]version.bet or changes.bet
#   Ensuring that version.c/[compilerrcm[version.bet/changes.bet is committed together
#       with other files
#   Ensuring that there is a line that says:
#        Betarun version number: 123
#      or
#        Compiler version number: 123
#      in the commit message.
#   If you are trying to commit as beta or root or administrator
#      then you also need a line that says:
#        Developer: beeblebrox
#      or whoever you are (use the -u option for this)
# If you have the CVS/Template file (you have this for new developments)
#    then you can just update the most minor version number in version.c
#    and then commit from the top level of betarun instead.
# See also the usage message (-help)


use Cwd;
use File::Copy;
use File::stat;

$minorupdate = 0;

# Get options

while (1) {
    #print "ARGV0 = '$ARGV[0]'\n";
    if ($ARGV[0] eq "+") {
	$minorupdate = 1;
	shift @ARGV;
    } elsif ($ARGV[0] eq "-") {
	$dontupdate = 1;
	shift @ARGV;
    } elsif ($ARGV[0] eq "-k") {
	$dontdeleteversion = 1;
	shift @ARGV;
    } elsif ($ARGV[0] eq "-m") {
	$message = $ARGV[1];
	shift @ARGV;
	shift @ARGV;
    } elsif ($ARGV[0] eq "-u") {
	$user = $ARGV[1];
	shift @ARGV;
	shift @ARGV;
    } elsif ($ARGV[0] eq "-n") {
	$donothing = 1;
	shift @ARGV;
    } elsif ($ARGV[0] eq "-d") {
	$nodiff = 1;
	shift @ARGV;
    } elsif ($ARGV[0] eq "--") {
	shift @ARGV;
        last;
    } elsif ($ARGV[0] =~ /^-/) {
        print STDERR "Usage: mbs_commit [options] [file [file ...]]\n";
        print STDERR "   -m \"message\"\n";
        print STDERR "   -u username_to_log\n";
        print STDERR "   -n    # Don't actually commit (do everything else!)\n";
        print STDERR "   -d    # Don't run diff to see changes\n";
        print STDERR "   -k    # Keep version.c or [compilerrcm]version.bet or changes.bet (don't delete it and get\n            the newest from the server\n";
        print STDERR "   +     # Don't increase version number, just add +\n";
        print STDERR "   -     # Don't increase version number at all\n";
        print STDERR "   --    # no more options\n";
        exit (2);
    } else {
	last;
    }
}

# If there is no parameter, then implicitly we mean the current directory.

$cwd = cwd;
$origcwd = $cwd;

$path = "";

print STDERR "CWD is '$cwd'\n";

# Find the top dir of betarun by looking for a dir where there is a file
# called version.c.  Also, since there is a version.c in the C subdir, we
# also check that there is no file called initialize.c
while ((! ( -f "version.c" || -f "initialize.c") ) && (! ( -f "compilerrcmversion.bet" || -f "version.bet" || -f "changes.bet"))) {
    # Remove trailing slash from dir name
    # unless the path is just /
    if ($cwd !~ /^([a-zA-Z]:)?[\\\/]$/) {
        $cwd =~ s/[\\\/]$//;
    }
    # Get last part of directory name
    if ($cwd =~ /([\\\/])([^\\\/]+)$/ox) {
        $cwd = $`;
        $lastpart = $2;
        $separator = $1;
        $path = $lastpart . $separator . $path;
        print STDERR "CDed up to $cwd\n";
        chdir("..");
    } else {
        print STDERR "Couldn't find version.c/[compilerrcm]version.bet/changes.bet starting from `$origcwd'\n";
        exit (1);
    }
}

if (-f "version.c") {
    $versionfile = "version.c";
} elsif (-f "changes.bet") {
    $versionfile = "changes.bet";
} elsif (-f "version.bet") {
    $versionfile = "version.bet";
} elsif (-f "compilerrcmversion.bet") {
    $versionfile = "compilerrcmversion.bet";
} else {
    die "Where did the version file suddenly go";
}

if ($ENV{'TERM'} eq 'cygwin'){
    if ($ENV{'PERLIO'} ne 'perlio'){
	print "mbs_commit: Environment variable PERLIO must be set to value \"perlio\"\n";
	print "            BEFORE calling mbs_commit - otherwise newline handling is broken\n";
	print "Do this in your bash shell:\n";
	print "   export PERLIO=perlio\n";
	exit(0);
    }
    #$dontdeleteversion = 1;
    #$nodiff = 1;
    #print "Not deleting $versionfile: perl 5.6 in cygwin messes up newlines.\n";
}

# Remove trailing slash from path
# unless the path is just /
if ($path !~ /^([a-zA-Z]:)?[\\\/]$/) {
    $path =~ s/[\\\/]$//;
}


# If we are updating version.c then open a new file for the new version.c

if (!$dontupdate && !$donothing) {
    open(NEWVERSION, ">new$versionfile") || die "Can't open the file new$versionfile for writing\n";
    binmode NEWVERSION; # fix newline handling on PC
}

# Delete version.c and get a fresh version.c from CVS.  Means we always
# increment by only one, even if a previous mbs_commit failed, and also
# avoids not-up-to-date errors on version.c

if (!$dontdeleteversion && !$donothing) {
    move($versionfile, "old$versionfile");

    print STDERR "Getting newest $versionfile with cvs\n";
    if (system("cvs up $versionfile")) {
	print STDERR "Couldn't get $versionfile from CVS server\n";
	move("old$versionfile", "$versionfile") || print STDERR "Failed to restore $versionfile!\n";
	exit(2);
    } else {
	unlink("old$versionfile") || die "Couldn't delete old$versionfile\n";
    }
}

open(VERSION, "$versionfile") || die "Can't open the file $versionfile\n";
binmode VERSION; # fix newline handling on PC

# Increment the version number in version.c

while (defined($line = <VERSION>)) {
    if ($line =~ /(BETARUN VERSION \d+.\d+\()(\d+)(\+*)(\))/ ||
        $line =~ /(do ')(\d+)(\+*)(' -> value)/) {
        if ($minorupdate) {
	    $line = "$`$1$2$3+$4$'";
            $version = "$2$3+";
        } elsif (!$dontupdate) {
	    $line = "$`$1" . ($2 + 1) . "$4$'";
            $version = $2 + 1;
        } else {
	    $version = $2;
        }
	$foundversionline = 1;
    }
    if (!$dontupdate && !$donothing) {
	print NEWVERSION $line || die "Errors with new$versionfile\n";
    }
}

if (!$foundversionline) {
    print "Couldn't find version line in $versionfile\n";
    exit (2);
}

close (VERSION);

if (!$dontupdate && !$donothing) {
    close (NEWVERSION) || die "Errors with new$versionfile\n";
    move("new$versionfile", "$versionfile") || die "Couldn't move new$versionfile over $versionfile\n";
}

if (!$donothing) {
    open(MESSAGE, ">message.txt") || die "Couldn't open message.txt for writing\n";
}

if (!$donothing) {
    if (open(CHANGES, "CHANGES.txt")) {
	while (defined($line = <CHANGES>)) {
	    print MESSAGE $line;
	    $readlinesfromchanges = 1;
	}
	close(CHANGES);
    } 

    if (defined($message)) {
	print MESSAGE "$message\n";
    } elsif (!$readlinesfromchanges) {
	print MESSAGE "\n";
    }

    # If there is a CVS/Template file then use it.  Otherwise just make one
    # up that is near enough the official one

    if (-f "CVS/Template") {
	open(TEMPLATE, "CVS/Template") || die "Couldn't open CVS/Template for reading\n";
	while (defined ($line = <TEMPLATE>)) {
	    if ($line =~ /(Betarun|Compiler) version number:/) {
		$line = "$`$& $version$'";
	    } elsif ($line =~ /Developer:/ && defined($user)) {
		$line = "$& $user$'";
	    }
	    print MESSAGE $line;
	}
    } else {
	if (defined($user)) {
	    print MESSAGE "Developer: $user\n";
	}
	if ($versionfile eq "version.c") {
	    print MESSAGE "Betarun version number: $version\n";
	} else {
	    print MESSAGE "Compiler version number: $version\n";
	}
    }
}

# We run a diff and put the result in the editor file so the user
# can see what has changed.  This is preceeded with CVS: so that it
# doesn't end up in the actual commit message.

if (!defined($message) && !$nodiff && !$donothing) {
    print STDERR "Getting differences with cvs\n";

    if (defined($ARGV[0])) {
        $cmd = "cvs diff -uN $versionfile " . join(" ", map {&gluename($_)} @ARGV);
    } elsif($path ne "") {
        $cmd = "cvs diff -uN $versionfile $path";
    } else {
        $cmd = "cvs diff -uN";
    }
    if (open(DIFFS, "$cmd|")) {
        while (defined($line = <DIFFS>)) {
            if ($line =~ /^Index: (.*)\r?\n/) {
                # Some versions of cvs don't give the right name
                # in the +++ and --- lines for deleted and added
                # files, but the right name is in the Index: line
                $fullfilename = $1;
            }
            if ($line =~ /^--- ([^\t]+)\t/) {
                $oldfile = $1;
            }
            if ($line =~ /^\+\+\+ ([^\t]+)\t/) {
                my $filename = $1;
                if ($filename eq "/dev/null") {
                    push @removedfiles, $fullfilename;
                } else {
                    if ($oldfile eq "/dev/null") {
                        push @addedfiles, $fullfilename;
                    } else {
                        push @changedfiles, $filename if ($filename ne "version.c");
                    }
                }
            }
            print MESSAGE "CVS: $line";
        }
        close(DIFFS);
        if ($#changedfiles != -1) {
	    print MESSAGE "Changed files:\n";
	    foreach $changedfile (@changedfiles) {
		print MESSAGE "    $changedfile\n";
	    }
        }
        if ($#removedfiles != -1) {
	    print MESSAGE "Removed files:\n";
	    foreach $changedfile (@removedfiles) {
		print MESSAGE "    $changedfile\n";
	    }
        }
        if ($#addedfiles != -1) {
	    print MESSAGE "Added   files:\n";
	    foreach $changedfile (@addedfiles) {
		print MESSAGE "    $changedfile\n";
	    }
        }
    }
}

if (!$donothing) {
    close(MESSAGE) || die ("Couldn't write message.txt\n");
}

# Call the user's editor.  Should we be looking at the EDITOR variable
# on Windows too?  Perhaps.

if (!defined($message) && !$donothing) {
    if (($^O =~ /win/i) && ($^O !~ /darwin/i) && ($ENV{'TERM'} ne 'cygwin')) {
	$editor = "notepad"; 
    } else {
        if (defined($ENV{"VISUAL"})) {
            $editor = $ENV{"VISUAL"};
        } elsif (defined($ENV{"EDITOR"})) {
            $editor = $ENV{"EDITOR"};
        } else {
            # $editor = "ed";  I'm not that evil :-)
            # $editor = "vi";
	    $editor = "emacs";
        }
    }
    $oldsb = stat("message.txt") || die "message.txt disappeared";
    $return = system("$editor message.txt");
    if ($return) {
        print STDERR "Editor '$editor' failed!\n";
        exit (2);
    }
    $sb = stat("message.txt") || die "message.txt disappeared";
    if ($sb->mtime <= $oldsb->mtime) {
        print "**************************************************\n";
        print "***                                            ***\n";
        print "*** Message file unchanged - abandoning commit ***\n";
        print "***                                            ***\n";
        print "**************************************************\n";
	exit(2);
    }
}

if (!$donothing) {

    # We need to remove the CVS: lines, since the cvs client doesn't do
    # this itself if we invoke it with the -F option.
    open(NEWMESSAGE, ">newmessage.txt") || die "Couldn't open newmessage.txt for writing\n";
    open(MESSAGE, "message.txt") || die "Couldn't open message.txt\n";
    while (defined($line =<MESSAGE>)) {
	next if ($line =~ /^CVS:/);
	if ($line =~ /version number:/){
	    print NEWMESSAGE $line;
	} else {
	    # print with indentation
	    print NEWMESSAGE "    $line";
	}
    }
    print NEWMESSAGE "-------------------------------------------------------------------------\n";
    close(NEWMESSAGE) || die "Error closing newmessage.txt";
    close(MESSAGE) || die "Error closing message.txt";
    move("newmessage.txt", "message.txt") || die "Couldn't overwrite message.txt with newmessage.txt\n";
}

# Actually commit

if (defined($ARGV[0])) {
    @args = ("cvs", "commit", "-F", "message.txt", "$versionfile", map {&gluename($_)} @ARGV);
} elsif ($path ne "") {
    @args = ("cvs", "commit", "-F", "message.txt", "$versionfile", "$path");
} else {
    @args = ("cvs", "commit", "-F", "message.txt");
}

if ($donothing) {
    print STDERR join(" ", @args, "\n");
} else {
    print STDERR "Committing:\n";
    if (!system @args) {
        if (-f "CHANGES.txt") {
            unlink("CHANGES.txt") || print STDERR "Couldn't delete CHANGES.txt file\n";
            open(CHANGES, ">CHANGES.txt") || print STDERR "Couldn't make new empty CHANGES.txt file\n";
            close(CHANGES);
        }
    } else {
        die "cvs command returned an error status\n";
    }
}


sub
gluename
{
    my($name) = @_;
    if ($path ne ""){
	$name = $path . '/' . $name;
    }
    # Get rid of bla/bla/./bla
    if ($^O =~ /(?<!dar)win/i) {
	$name =~ s/([\\\/])\.[\\\/]/$1/g;
	$name =~ s/[\\\/]\.$//g;
    } else {
	$name =~ s#/\./#/#g;
	$name =~ s#/\.$##g;
    }
    return $name;
}
