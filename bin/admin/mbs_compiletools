#!/usr/local/bin/perl5 -s
#-*-Perl-*-

push(@INC, $ENV{'BETALIB'} . "/bin/admin");

use File::Copy;

if ($h){
    print "Usage: mbs_compiletools [-h][-u]\n";
    print "          -h   Print this help\n";
    print "          -v   Verbose output\n";
    print "          -n   No effects - only print what would be done\n";
    print "          -u   Use defaults - ask no questions\n";
    print "          -D   Do NOT strip debug info\n";
    print "          -b   Use boot compiler for compiling\n";
    print "       Compiles all tools and install them in BETALIB/bin\n";
    exit 0;
}

$UseDefaults = 1 if ($u);
$DontStrip = 1 if ($D);
$betaopts = "-qwl " . $ENV{'BETAOPTS'};
$origbetaopts = $betaopts;
$bootcompiler = 1 if ($b);

$savebackups = 0; # Doesn't really work, as SGI ovcerwrites the SO files...

require "env.perl";

$ENV{'BETART'} = "";

# Now in use!
# Defaults:
$MoveSOfiles = 0;
$InApplicationDir = 0;
$ApplicationDir   = "$betalib/bin/$objdir";  
# Machinespecific parameters:
if ($OS eq "WIN") {
    $InApplicationDir = 1;
    $ApplicationDir   = "$betalib/bin/nti_$MIASDK";  
} elsif ($OS eq "UNIX") {
    $InApplicationDir = 1;
    $ApplicationDir   = "$betalib/bin/$objdir";  
    $MoveSOfiles = 1;
    if ($objdir eq 'hpux9pa' && !$ENV{'TMPDIR'}) {
	$ENV{'TMPDIR'} = '/usr/tmp';
    }
}

# To compile only specific tools, specify the fragmentnames as arguments
# Example:
#            mbs_compiletools sif frigg freja
# -will compile only those tools, without further questions...
#
#---------- don't change below (except maybe after "main:") -------

sub mybeta {
    if ($bootcompiler){
	&bootbeta(@_);
    } else {
	&beta(@_);
    }
}

sub matchInList {
    local($name, @list) = @_;
    foreach $m (@list) {
	if ($name =~ /$m/){
	    if (("$name" eq "rungen") && ("$m" eq "gen")){
		# exception: don't compile rungen for "mbs_compiletools gen"
		print "mbs_compiletools gen: not compiling rungen\n";
	    } else {
		return 1;
	    }
	}
    }
    return 0;
}

sub MoveExecutable {
    local($name, $newname, $inCodeDir) = @_;
    if ($MACHINETYPE =~ /^nti/i) {
	$name .= ".exe";
	$newname .= ".exe";
    }
    if (!-e $name) {
	print "Compilation failed, old executable untouched\n";
    } elsif ($InApplicationDir) {
	if (!-d $ApplicationDir) {
	    &SmartMkdir($ApplicationDir);
	}
	$dst = "$ApplicationDir/$newname";
	print "Moving $name to $dst\n";
	if (-e "$dst" && $savebackups) {
	    if (!rename ("$dst", "$dst.old")) {
		unlink "$dst.old";
		rename ("$dst", "$dst.old");
	    }
	}
	if (-e "$dst") {
	    unlink "$dst";
	}
	if (!rename ("$name", "$dst")) { 
	    print "cannot move $name to $objdir\n"; 
	    return; 
	}
	if ($MoveSOfiles) {
	    for ($num = 1;; $num++) {
		$so = "$name$num.so";
		last if (!-e "$ApplicationDir/$so");
		unlink "$ApplicationDir/$so";
	    }
	    for ($num = 1;; $num++) {
		$so = "$name$num.so";
		last if (!-e "$objdir/$so");
		print "Moving $so to $ApplicationDir/$so\n";
		rename ("$objdir/$so", "$ApplicationDir/$so");
	    }
	}
    } elsif ($inCodeDir) {
	print "Moving $name to $objdir/$newname\n";
	unlink "$objdir/$newname" if (-e "$objdir/$newname");
	if (!rename ("$name", "$objdir/$newname")) {
	    print "cannot move $name to $objdir/$newname\n"; 
	    return; 
	}
    }
}

sub CompileExbobs 
{
    local ($dir, $fragment, $name, $inCodeDir) = @_;
    return if ($#DoOnly >=0 && !matchInList("exbobs", @DoOnly));
    if ($ask eq "y"){
	print "\n***** Build $name in $betalib/$dir (y/n/q)? ";
	$answer = &GetAnswer();
	if ($answer eq "q") { exit(0); }
	if ($answer eq "n") { return; }
    } else {
	print "\n***** Building $name in $betalib/$dir *****\n";
    }
    if (!chdir(&path("$betalib/$dir"))) { print "unable to chdir to $betalib/$dir\n"; return; }
    if ($MACHINETYPE =~ /^nti_gnu/i) {
	print "C compiling\n";
	$ccmd = "gcc -O2 -I. -o ${fragment}.exe $fragment.c p2c\\p2clib.c";
        print "$ccmd\n";
        system($ccmd);
    }
    elsif ($MACHINETYPE =~ /^nti_ms/i) {
	print "C compiling\n";
	if ($ENV{'TERM'} eq 'cygwin'){
	    $p2clib = "p2c/p2clib.c";
	} else {
	    $p2clib = "p2c\\p2clib.c";
	}
	$ccmd="cl /Fe${fragment}.exe $fragment.c $p2clib /nologo /w /I. /O2 /Zd /DWIN32 /DNTI /D${MACHINETYPE} /Zp4";
	print "$ccmd\n";
	system($ccmd);
    }
    else {
	if ($MACHINETYPE =~ /^sgi/i) {
	    $CC = 'cc -32';
	} elsif ($MACHINETYPE =~ /^macosx/i) {
	    $CC = 'cc';
	} else {
	    $CC = 'gcc';
	}
	print "C compiling\n";
	$ccmd="$CC -I. -O2 -o ${fragment} $fragment.c p2c/p2clib.c";
	print "$ccmd\n";
	system($ccmd);
	unlink "p2clib.o" if (-f "p2clib.o");
	unlink "${fragment}.o" if (-f "${fragment}.o");
    }

    &MoveExecutable($fragment, $name, $inCodeDir);
}

sub CompileAppl 
{
    local ($dir, $fragment, $name, $inCodeDir) = @_;
    local ($tempname);
    return if ($#DoOnly >=0 && !matchInList($fragment, @DoOnly));
    if ($ask eq "y"){
	print "\n***** Build $name in $betalib/$dir (y/n/q)? ";
	$answer = &GetAnswer();
	if ($answer eq "q") { exit(0); }
	if ($answer eq "n") { return; }
    } else {
	print "\n***** Building $name in $betalib/$dir *****\n";
    }
    if (!chdir(&path("$betalib/$dir"))) { print "unable to chdir to $betalib/$dir\n"; return; }
    if (-d &path($objdir)){
	if (!opendir (DIR, $objdir)){ print "Unable to readdir $dir/$objdir: $!"; return }
	foreach (readdir(DIR)) {
	    unlink($_) if (/\.gso$/);
	}
    }
    if ($MACHINETYPE  =~ /^nti/i) {
	# "beta -o name" will lowercase "name"
	print "bootbeta $betaopts $fragment\n" if ($bootcompiler);
	print "beta $betaopts $fragment\n" unless ($bootcompiler);
	&mybeta("$betaopts $fragment");
	exit(1) if ($?);
	if ($fragment ne $name){
	    print "Moving $fragment.exe to $name.exe\n";
	    unlink "$name.exe" if (-e "$name.exe");
	    if (!rename ("$fragment.exe", "$name.exe")){ 
		print "cannot rename $fragment.exe to $name.exe\n"; 
		return; 
	    }
	}
	$tempname = "$name";
    } else {
	# Temporary name used so that this script may be run in parallel.
	$tempname = $name;
	$tempname = $MACHINETYPE . "_" . $name if ($name !~ /^$MACHINETYPE/);
	print "beta $betaopts -o $tempname $fragment\n" unless ($bootcompiler);
	print "bootbeta $betaopts -o $tempname $fragment\n" if ($bootcompiler);
	&mybeta("$betaopts -o $tempname $fragment");
	exit(1) if ($?);
    }
    
    &MoveExecutable($tempname, $name, $inCodeDir);
}

sub MakeRunGen()
{
    chdir("$betalib/betarun/GEN/GRAMMAR") || die "Where is the BETALIB/betarun/GEN/GRAMMAR directory?";
    $grammarname = "runtime";
    do "$betalib/boot/grammars/bootdogram.pl";

    chdir("$betalib/betarun/GEN/gas") || die "Where is the BETALIB/betarun/GEN/gas directory?";
    system("$betalib/boot/bin/$objdir/beta -qwlp --betarun $betalib/boot/bin/$objdir/betarun$BETARUNSUFFIX rungen") &&
        die("Failed to compile rungen (the RUN compiler)");
    if (! -d "$betalib/bin/$objdir") {
	mkdir("$betalib/bin/$objdir", 0777) || die "Couldn't make the directory for exe files ($betalib/bin/$objdir)\n";
    }
    copy("rungen$EXESUFFIX", "$betalib/bin/$objdir/rungen$EXESUFFIX") || die "Couldn't move rungen$EXESUFFIX over to $betalib/bin/$objdir/rungen$EXESUFFIX";
    chmod 0755, "$betalib/bin/$objdir/rungen$EXESUFFIX";
}

sub MakeBetarun
{
    local ($dir) = $objdir;

    print "\n***** Making betarun in $betalib/betarun/$dir *****\n";
    system "mbs_make";
}
	    
sub CompileFile {
    local ($dir, $fragment) = @_;
    return if ($#DoOnly >=0 && !matchInList($fragment, @DoOnly));
    if (!chdir(&path("$betalib/$dir"))) { print "unable to chdir to $betalib/$dir\n"; return; }
    print "BETA $betaopts -p --nolink $fragment\n";
    &mybeta("$betaopts -p --nolink $fragment");
}


sub CompileCompiler
{
    local ($dir, $fragment, $name, $inCodeDir) = @_;
    local ($tempname);
    print "\n***** Building $name in $betalib/$dir *****\n";
    if (!chdir(&path("$betalib/$dir"))) { print "unable to chdir to $betalib/$dir\n"; return; }
    if ($MACHINETYPE  =~ /^nti/i) {
	# "bootbeta -o name" will lowercase "name"
	print "bootbeta $betaopts $fragment\n" if ($bootcompiler);
	print "beta $betaopts $fragment\n" unless ($bootcompiler);
	&mybeta("$betaopts $fragment");
	exit(1) if ($?);
	if ($fragment ne $name){
	    print "Moving $fragment.exe to $name.exe\n";
	    unlink "$name.exe" if (-e "$name.exe");
	    if (!rename ("$fragment.exe", "$name.exe")){ 
		print "cannot rename $fragment.exe to $name.exe\n"; 
		return; 
	    }
	}
	$tempname = "$name";
    } else {
	# Temporary name used so that this script may be run in parallel.
	$tempname = $name;
	$tempname = $MACHINETYPE . "_" . $name if ($name !~ /^$MACHINETYPE/);
	print "bootbeta $betaopts -o $tempname $fragment\n" if ($bootcompiler);
	print "beta $betaopts -o $tempname $fragment\n" unless ($bootcompiler);
	&mybeta("$betaopts -o $tempname $fragment");
	if ($?) {
           print "warning: beta failed with error $?\n";
	   #exit(1) ;
        }
    }
    &MoveExecutable($tempname, $name, $inCodeDir);
}
	    
sub CompileFile {
    local ($dir, $fragment) = @_;
    return if ($#DoOnly >=0 && !matchInList($fragment, @DoOnly));
    if (!chdir(&path("$betalib/$dir"))) { print "unable to chdir to $betalib/$dir\n"; return; }
    print "BETA $betaopts -p --nolink $fragment\n";
    &mybeta("$betaopts -p --nolink $fragment");
}

sub SetWindowsBetalinkOptions {
    if ($MACHINETYPE  =~ /^nti/i) {
	# link as windows application, ie. without a console-window.
	# Note!  You cannot see the linkermessages,etc. then...
	$betaopts = $origbetaopts . ' -s 71';
    }
}
    
sub SetNormalBetalinkOptions {
    if ($MACHINETYPE  =~ /^nti/i){
	$betaopts = $origbetaopts;
    }
}

################# main: ###########################

open(STDERR, ">&STDOUT") || die "Can't dup stdout";
select(STDERR); $| = 1;       # make unbuffered
select(STDOUT); $| = 1;       # make unbuffered

print "$0 STARTED\n";
&PrintDate;

if ( !$DontStrip && ("$MACHINETYPE" ne "SGI") ){
#    print "Stripping of executable temporarily disabled\n";
# Disabled, as we want to be able to debug the tools for now... --mg
# No! On now, we're building for export!
    $betaopts .= " -d"; # link with betarun.o and strip  
}
if ($#ARGV>-1) { @DoOnly = @ARGV; }

print "\nCompiling tools in $betalib with options \"$betaopts\"\n";
print "USING BOOT COMPILER\n" if ($bootcompiler);

if (($MACHINETYPE =~ /^nti/i) && ($MIASDK eq "ms")){
    print "NTI: setting ASM_VERSION to 6\n";
    $ENV{'ASM_VERSION'}="6";
}

# Default config:
$rmast=0; $rmcode=0; $buildcompiler = 0; $makebetarun=0; $ask='n';

$buildcompiler = 1 if (matchInList("compiler", @DoOnly));
$makebetarun = 1 if (matchInList("betarun", @DoOnly));
$makerungen = 1 if (matchInList("rungen", @DoOnly));

if (!defined @DoOnly && !$UseDefaults) {
    print "\n***** Build a new compiler (y/n/q)? ";
    $answer = &GetAnswer();
    if ($answer eq "q") { exit(0); }
    if ($answer eq "y") { 
	$buildcompiler = 1;
	print "Do you want to REMOVE ALL ast-files\n";
	print "when the compiler has been created (y/n/q)? ";
	$answer = &GetAnswer();
	if ($answer eq "q") { exit(0); }
	if ($answer eq "y") { 
	    $rmast=1;
	} else {
	    print "Do you want to REMOVE ALL object-files for this machinetype ($objdir)\n";
	    print "when the compiler has been created (y/n/q)? ";
	    $answer = &GetAnswer();
	    if ($answer eq "q") { exit(0); }
	    if ($answer eq "y") { 
		$rmcode=1;
	    }
	}		        
    }
    print "\n***** Rebuild betarun (y/n/q)? ";
    $answer = &GetAnswer();
    if ($answer eq "q") { exit(0); }
    if ($answer eq "y") { 
	$makebetarun= 1;
    }

    print "\nAsk for each remaining tool (y/n/q)? ";
    $ask = &GetAnswer();
    if ($ask eq "q"){ exit(0); }
    if ($ask ne "n"){ $ask="y"; }
}

if ($buildcompiler) {
    $oldask = $ask; $ask = 'n';
    &CompileCompiler("compiler", "beta", "beta", 1);
    $ask = $oldask;
    if ($rmast) {
	$FromAnotherScript += 1;
	require "mbs_rmast";
	$FromAnotherScript -= 1;
    }
    if ($rmcode) {
	$FromAnotherScript += 1;
	require "mbs_rmcode";
	$FromAnotherScript -= 1;
    }
}

if ($makerungen) {
    &MakeRunGen();
}
if ($makebetarun) {
    &MakeBetarun();
}

&CompileAppl("bobs", "parse", "parse", 1);
&CompileAppl("bobsgen", "tabc", "tabc", 1);
# exbobs: MACHINETYPE prefix maintained to avoid having to change UNIX makefile
if ($MACHINETYPE !~ /^nti/i){
    # No need to add yet another exbobs source file in CVS - Solaris can use
    # the Linux version!
    if ($MACHINETYPE =~ /x86sol/i) {
	    &CompileExbobs("bobsgen", "LINUXexbobs", "exbobs", 1);
    } else {
	    &CompileExbobs("bobsgen", "${MACHINETYPE}exbobs", "exbobs", 1);
    }
} else {
    &CompileExbobs("bobsgen", "NTIexbobs", "exbobs", 1);
}
&CompileAppl("meta", "gen", "gen", 1);
&CompileAppl("prettygen", "makepretty", "makepretty", 1);
&CompileAppl("prettygen", "morepretty", "morepretty", 1);
&CompileAppl("pretty", "pp", "pp", 1);
&CompileAppl("utils/dogram", "dogram", "dogram", 1);
&CompileAppl("utils/dogram", "bobsit", "bobsit", 1);
&CompileAppl("utils/dogram", "generator", "generator", 1);
&CompileAppl("compiler", "nbeta", "nbeta", 1);
&CompileAppl("compiler", "jbeta", "jbeta", 1);
if ($MACHINETYPE =~ /^nti/i) {
    &CompileAppl("utils/betacc", "betacc", "betacc", 1);
}
&CompileAppl("utils/betafs", "betafs", "betafs", 1);
&CompileAppl("utils/betatar", "betatar", "betatar", 1);
&CompileAppl("utils/betawc", "betawc", "betawc", 1);
#&CompileAppl("objectbrowser/psbrowser", "psbrowser", "psbrowser", 1);
&CompileAppl("comlib/idl2beta", "bidl", "bidl", 1);
&CompileAppl("distribution", "ensembleDeamon", "startensemble", 1);
&CompileAppl("mjolnertool", "mjolner", "mjolner", 1);
&SetWindowsBetalinkOptions;
&CompileAppl("mjolnertool", "mjolnerdoit", "mjolnerdoit", 1);
&SetNormalBetalinkOptions;
&CompileFile("freja", "associations");

print "\n";
&PrintDate;
print "$0 COMPLETE\n";
