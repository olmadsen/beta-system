#! perl

use File::DosGlob;

# Takes the list of files.z to be included as args. 
# Configure:

# Where do I find InstallShield:
$InstallShieldDir = "d:\\installshield";  

# Disk sizes, modify if installShield outgrows the current reserved room.
$Minimum          =   70;                # Minimum size of chunks (in kb)
$FirstSize        =  500;                # Size of first disk. (in kb)
$RestSize         = 1380;                # Size of rest of disks. (in kb)

# The name of the template for "setup.rul". Try to leave this untouched.
$RuleTemplate     = "setup.rul.template";

##############################################################
# Impl, do not touch.
##############################################################

sub mayrm {
    foreach $file (@_) {
	unlink $file if -e $file;
    }
}

sub SmartRmDir {
    my ($path) = @_;
    if ($ENV{'COMSPEC'} =~ /4nt/i) {
	system "$ENV{'COMSPEC'} /C del /S /Q /X /Y $path";
    } elsif ($ENV{'COMSPEC'} =~ /cmd/i) {
	
    } else {
	
    }
}

sub Usage {
    print "autogenerate-installshield. Usage:\n";
    print "Normally, just say:\n\n";
    print "autogenerate-installshield ms *.cmd      or maybe\n\n";
    print "autogenerate-installshield -u ms *.cmd\n\n";
    print "Which packs a complete system for nti_ms\n";
    print "If in doubt, check Quality pages!\n";
    exit 1;
}

$UseDefaults = 1 if ($u);   # perl -s does this to options...

&Usage if ($#ARGV <= 0);
$MIASDK = shift @ARGV;
if ($MIASDK !~ /^(ms|gnu|bor)$/) {
    &Usage;
}

$ENV{'MIASDK'} = $MIASDK; # Export to other programs, if any should need it.
$| = 1;   # Flush all read/writes
$betalib = $ENV{'BETALIB'};
$CWD = `cd`; chop $CWD;
$log = "beta_${MIASDK}.lst";
$RoomLeftOnCurDisk = $FirstSize;
$SPLIT ="$InstallShieldDir\\program\\split.exe";
$LastDisk = 0;
$CurDisk = 1;
$AutoRuleText = "szSDK = \"$MIASDK\";\n"; 
# Export MIASDK so that it can get the path right in the start-menu shortcuts.


foreach $f (@ARGV) {
    foreach $file (&File::DosGlob::doglob(1,$f)) {
	if ($file =~ /^(.*)\.cmd$/i) {
	    push(@FileList, $1);
	} elsif ($file eq "-u") {
	    $UseDefaults = 1;
	    print "Using auto-chosen defaults!\n";
	} else {
	    print "Unable to handle argument '$file'.\n";
	    exit 1;
	}
    }
}

# Check existance of some cricial files:
if (!-e $SPLIT) {
    print "Unable to find split.exe in '$SPLIT'\n";
    exit 1;
}

$prgs = "$InstallShieldDir\\program";
if ($ENV{'PATH'} !~ /$prgs/i) {
    $ENV{'PATH'} = "$prgs;" . $ENV{'PATH'};
}

mkdir("zfiles",0777) if (!-d "zfiles");

if (-e "zfiles/$RuleTemplate") {
    print "There is a previously packed 'zfiles' in the zfiles-directory.\n";
    print "Should I use this, and skip the rebuilding of the Z-files?\n";
    print "(y/n)? ";
    if ($UseDefaults) {
	$UseLastBuild = 'y';
	print "Choosing yes\n";
    } else {
	$UseLastBuild = <STDIN>; chop $UseLastBuild;
	$UseLastBuild='' if ($UseLastBuild ne 'y');
    }
} else {
    print "No previous build.  Building from scratch.\n";
    sleep(3);
}
if ($UseLastBuild) {
    print "Do you want to be asked for each CMD file?(y/n)";
    if ($UseDefaults) {
	$AskForEach = '';
	print "Choosing no\n";
    } else {
	$AskForEach = <STDIN>; chop $AskForEach;
	$AskForEach = '' if ($AskForEach ne 'y');
    }
}


if (-d "datafiles") {
    print "\n\nWARNING!!! the directory 'datafiles' exists allready!\n";
    print "Enter 'yes' to delete datafiles and all it contents! :\n";
    if ($UseDefaults) {
	$ans = 'yes';
	print "Choosing yes\n";
    } else {
	$ans = <STDIN>; chop $ans;
    }
    if ($ans ne 'yes') {
	print "Quitting\n";
	exit 1;
    }
    print "\n\nDELETING DATAFILES!!!\n\n";
    SmartRmDir('datafiles');
    print "done.\n\n\n";
}

mkdir('datafiles',0755) if (!-d 'datafiles');

if ($UseLastBuild) {
    system "copy zfiles\\$RuleTemplate .";
    print "You may now re-edit\n\t'$CWD\\$RuleTemplate'\n\n";
} else {
    system "copy $betalib\\bin\\admin\\setup.rul.template $RuleTemplate";
    print "\n\nYou may now start editing\n\t'$CWD\\$RuleTemplate'\n\n";
}

open (LST, ">setup.lst") || die "Unable to create setup.lst: $!";

foreach $file (@FileList) {
    open (CMD, "<$file.cmd") || die "Unable to read $file: $!";
    $nam = <CMD>;
    close CMD;
    chop $nam;
#    if (8 < length($file)) {
#	$nam = substr($file, 0, 8);
#    } else {
#	$nam = $file;
#    }

    $CopyLast = 0;
    if ($UseLastBuild && -e "zfiles/$nam.z" 
	&& (-M "zfiles/$nam.z" < -M "$file.cmd")) {
	if ($AskForEach) {
	    print "Reuse $nam(y/n)? ";
	    $CopyLast = <STDIN>; chop $CopyLast;
	    $CopyLast = 0 if ($CopyLast ne 'y');
	} else {
	    $CopyLast = 1;
	}
    }
    if ($CopyLast) {
	print "------Reusing $nam.z\n";
    } else {
	print "\n------Packing $nam:\n";
	open (LOG, ">zfiles/$nam.lst");
	print LOG "------Packing $nam:\n";
	close(LOG);
	unlink "$betalib/$nam.z" if (-e "$betalib/$nam.z");
	for ($i=0; $i < 10; $i++) {
	    &mayrm("$betalib/$nam.00$i",
		   "$betalib/$nam.01$i",
		   "$betalib/$nam.02$i");
	}
	open (IN, "<$file.cmd") || die "unable to read $file.cmd: $!";
	$quale = <IN>;
	chdir $betalib;
	foreach $line (<IN>) {
	    chop $line;
	    next if ($line =~ /^$/);
	    $line =~ s/%MIASDK%/$ENV{'MIASDK'}/gi;
	    if ($line =~ /^icomp/i) {
		print "$line\n";
		system ("$InstallShieldDir\\program\\$line >>$CWD\\zfiles\\$nam.lst");
	    } elsif ($line =~ /(^(del|ren|copy))|encrypt.exe/) {
		print "$line\n";
		system($line);
	    } elsif ($line =~ /^cd\s+(.*)$/) {	
		$newpath=$1;
		$newpath =~ s/\%([^\%]+)\%/\$ENV\{\'$1\'\}/ig;
		$newpath =~ s#\\#/#g;
		$newpath = eval("\"$newpath\"\;");
		print "cd $newpath\n";
		chdir $newpath;
	    } else {
		print "\nERROR:Unable to parse \"$line\"\n\n";
	    }
	}
	close(IN);
	chdir $CWD;
	unlink "zfiles/$nam.z" if (-e "zfiles/$nam.z");
	rename("$betalib/$nam.z", "zfiles/$nam.z") || die "file $nam.z: $!";
    }
    open (LOG, ">>datafiles/$log") || die "datafiles/$log: $!";
    open (LOG2, "<zfiles/$nam.lst") || die "zfiles/$nam.lst: $!";
    while(<LOG2>) {
	print LOG $_;
    }
    close(LOG);
    close(LOG2);
}

print "Packing done, now splitting\n";

chdir 'datafiles' || die "Unable to chdir(datafiles): $!";

$ByteSize = 0;
$FileCount = 0;
foreach $basefile (@FileList) {
    open (CMD, "<../$basefile.cmd") || die "Unable to read $file: $!";
    $file = <CMD>;
    close CMD;
    chop $file;
#    if (8 < length($basefile)) {
#	$file = substr($basefile, 0, 8);
#    } else {
#	$file = $basefile;
#    }
    $file .= ".z";
    if (!-e "../zfiles/$file") {
	print "Unable to read file '$file'.\n";
	exit 1;
    }
    if ($file =~ /^(.*\/)?([^\/]+).z$/i) {
	$path = ($1 || ".");
	$base = $2;
	chop $path if ($path =~ /\/$/);	# remove trailing slash.
	if ($RoomLeftOnCurDisk < $Minimum) {
	    $CurDisk++;
	    $RoomLeftOnCurDisk = $RestSize;
	}
	print "Splitting $file ...";
	$cmd = "$SPLIT ..\\zfiles\\$file -F$RestSize -d1\@$RoomLeftOnCurDisk -h >>$log";
	# print "$cmd\n";
	system $cmd;
	opendir (DIR, $path);
	$lastfound = 0;
	foreach (readdir DIR) {
	    if (/$base\.(\d+)/) {
		if ($lastfound < $1) {
		    $lastfound = $1;
		    $lastused = int(((-s $_) + 1023) / 1024);
		}
	    }
	}
	if ($lastfound == 1) {
	    $RoomLeftOnCurDisk -= $lastused;
	} elsif ($lastfound > 1) {
	    $RoomLeftOnCurDisk = $RestSize - $lastused;
	} else {
	    print "Unable to find any split files.\n";
	    exit 1;
	}
	$startdisk = $CurDisk;
	for ($i = 1; $i <= $lastfound; $i++) {
	    $dirname = "disk$CurDisk";
	    if (!-d $dirname) {
		mkdir($dirname,0777);
		open (TMP, ">$dirname/disk$CurDisk.id");
		close TMP;
	    }		    
	    rename "$path/$base.$i", "$dirname/$base.$i";
	    if ($CurDisk != $LastDisk) {
		$LastDisk = $CurDisk;
		print LST "$CurDisk;\n" ;
	    }
	    print LST "..\\zfiles\\$base.z\n";
	    $CurDisk++;
	}
	$CurDisk--;

	print "\t (On disk $startdisk..$CurDisk, last used ";
	print $RestSize - $RoomLeftOnCurDisk;
	print " kb.)\n";
	
	if ($base =~ /^doc/) { # Doc is handled specifically by the template.
	    # Hmm. Should signal to template, that doc is available.
	    # For now, this is just asumed by the template... 
	} else {
	    $AutoRuleText .= "             CompressGet(\"$base.z\", \"*.*\", ";
	    $AutoRuleText .= "INCLUDE_SUBDIR );\n";
	}

	open (ICOMP, "$InstallShieldDir\\program\\icomp.exe -l ..\\zfiles\\$base.z |");
	$count = 0; $orgsize = 0;
	foreach $line (<ICOMP>) {
	    if ($line =~ /(\d+)\s+(\d+)\s+(\d+)/) {
		$orgsize=$1; 
		#$compsize=$2; 
		$count=$3;
	    }
	}
	close ICOMP;
	if ($count) {
	    $ByteSize += $orgsize;
	    $FileCount += $count;
	} else {
	    print "Unable to parse output from icomp.\n";
	}
    } else {
	print "Skipping $file\n";
    }
}

close LST;

print "\n";

system "$InstallShieldDir\\program\\packlist.exe ..\\setup.lst >>$log";
rename "setup.pkg", "disk1/setup.pkg";
system "copy %BETALIB%\\README.txt disk1 >>$log";
foreach $file ("setup.exe", "uninst.exe", "_isres.dll", "_setup.dll", "_setup.lib", "_inst32i.ex_") {
    system "copy $InstallShieldDir\\program\\$file disk1 >>$log";
}

if (!$UseLastBuild) {
    print "\n\nI have calculated the following sizes of the installation:\n";
    print "(Normally, choose the 2048-value as Minimum Required, and\n";
    print "mention the others in the installation-notes. You cannot\n";
    print " install, if there is less than the Min.Req available.)\n\n";
    print  "ClusterSize   Maximal Need\n";
    foreach $c (0,512,1024,2048,4096,8192,16384,32768) {
	printf "%9d     %9d\n", $c, ($ByteSize + $c * $FileCount);
    }
    if (!$UseDefaults) {
	print "\n\nPlease edit '$CWD\\$RuleTemplate' NOW.\n";
	print "Then press enter to continue:\n";
	$a = <STDIN>;
    }
}

open (TMP, "../$RuleTemplate") || die "Unable to read $RuleTemplate: $!\n";
open (RUL, ">disk1/setup.rul");
$found = 0;
foreach (<TMP>) {
    chop;
    if ($_ eq '/*---BETA-AUTOSPLIT-INSERT-HERE-MAGIC-KEY---*/') {
	print "Found Autoinsertkey in Rule-template, inserting filelist\n";
	print RUL $AutoRuleText;
	
	$found = 1;
    } else {
	print RUL "$_\n";
    }
}
close RUL;
close TMP;
if ($found) {
    system("$InstallShieldDir\\program\\compile.exe disk1\\setup.rul >>$log");
    &mayrm("zfiles/setup.rul");
    rename "disk1/setup.rul", "../zfiles/setup.rul";
    print "done\n";
} else {
    print "FATAL: did not find Autoinsert-magic key in Rule-template\n";
    exit 1;
}

chdir $CWD;
# Clean up:
system "copy $RuleTemplate zfiles\\$RuleTemplate";
unlink "$RuleTemplate";
unlink "setup.lst";

print "\nNow the ready-to-ship disks should reside in datafiles/diskXX.\n";
print "BUT please check the output from the programs in datafiles/$log\n";
print "\nZIPPING disks as beta_$ENV{'MIASDK'}.zip (For mjolner distribution)\n\n";

chdir "datafiles";
system "zip -r beta_$ENV{'MIASDK'} disk*";
chdir $CWD;

print "\nDone.\n";
print "For CDROM/floppydisks, use datafiles/diskXX.\n";
print "For FTP distribution, use datafiles/beta_$ENV{'MIASDK'}.zip\n";
print "BUT please check the output from the programs in datafiles/$log\n";
