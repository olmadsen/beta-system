#! perl


# Takes the list of files.z to be included as args. 
# Configure:

# Where do I find InstallShield:
$InstallShieldDir = "d:\\installshield";  

# Disk sizes, modify if installShield outgrows the current reserved room.
$Minimum          =   30;                # Minimum size of chunks (in kb)
$FirstSize        =  500;                # Size of first disk. (in kb)
$RestSize         = 1380;                # Size of rest of disks. (in kb)

# The name of the template for "setup.rul". Try to leave this untouched.
$RuleTemplate     = "setup.rul.template";

##############################################################

$| = 1;   # Flush all read/writes

$betalib = $ENV{'BETALIB'};
$CWD = `cd`; chop $CWD;
$log = "beta_$ENV{'SDK'}.lst";
$RoomLeftOnCurDisk = $FirstSize;
$SPLIT ="$InstallShieldDir\\program\\split.exe";
$LastDisk = 0;
$CurDisk = 1;
$AutoRuleText = "";

sub mayrm {
    foreach $file (@_) {
	unlink $file if -e $file;
    }
}

if ($#ARGV == -1) {
    print "autogenerate-installshield: Give me *.cmd files as argument!\n";
    exit 1;
}

foreach $file (@ARGV) {
    if ($file =~ /^(.*)\.cmd$/i) {
	push(@FileList, $1);
    } else {
	print "Unable to handle argument '$file'.\n";
	exit 1;
    }
}

# Check existance of some cricial files:
if (!-e $SPLIT) {
    print "Unable to find split.exe in '$SPLIT'\n";
    exit 1;
}

$prgs = "$InstallShieldDir\\program";
if ($ENV{'PATH'} !~ /$prgs/i) {
    $ENV{'PATH'} = "$prgs;" . $ENV{'PATH'};
}

mkdir("zfiles",0777) if (!-d "zfiles");

if (-e "zfiles/$RuleTemplate") {
    print "There is a previously packed 'zfiles' in the zfiles-directory.\n";
    print "Should I use this, and skip the rebuilding of the Z-files?\n";
    print "(y/n)? ";
    $UseLastBuild = <STDIN>; chop $UseLastBuild;
    $UseLastBuild='' if ($UseLastBuild ne 'y');
} else {
    print "No previous build.  Building from scratch.\n";
    sleep(3);
}
if ($UseLastBuild) {
    print "Do you want to be asked for each CMD file?(y/n)";
    $AskForEach = <STDIN>; chop $AskForEach;
    $AskForEach = '' if ($AskForEach ne 'y');
}


if (-d "datafiles") {
    print "\n\nWARNING!!! the directory 'datafiles' exists allready!\n";
    print "Enter 'yes' to delete datafiles and all it contents! :\n";
    $ans = <STDIN>; chop $ans;
    if ($ans ne 'yes') {
	print "Quitting\n";
	exit 1;
    }
    print "\n\nDELETING DATAFILES!!!\n\n";
    system "rm -rf datafiles";
    print "done.\n\n\n";
}

mkdir('datafiles',0755) if (!-d 'datafiles');

if ($UseLastBuild) {
    system "copy /Q zfiles\\$RuleTemplate .";
    print "You may now re-edit\n\t'$CWD\\$RuleTemplate'\n\n";
} else {
    system "copy /Q $betalib\\bin\\admin\\setup.rul.template $RuleTemplate";
    print "\n\nYou may now start editing\n\t'$CWD\\$RuleTemplate'\n\n";
}

open (LST, ">setup.lst") || die "Unable to create setup.lst: $!";

foreach $file (@FileList) {
    if (8 < length($file)) {
	$nam = substr($file, 0, 8);
    } else {
	$nam = $file;
    }
    $CopyLast = 0;
    if ($UseLastBuild && -e "zfiles/$nam.z" 
	&& (-M "zfiles/$nam.z" < -M "$file.cmd")) {
	if ($AskForEach) {
	    print "Reuse $nam(y/n)? ";
	    $CopyLast = <STDIN>; chop $CopyLast;
	    $CopyLast = 0 if ($CopyLast ne 'y');
	} else {
	    $CopyLast = 1;
	}
    }
    if ($CopyLast) {
	print "------Reusing $nam.z\n";
    } else {
	print "\n------Packing $nam:\n";
	open (LOG, ">zfiles/$nam.lst");
	print LOG "------Packing $nam:\n";
	close(LOG);
	unlink "$betalib/$nam.z" if (-e "$betalib/$nam.z");
	open (IN, "<$file.cmd") || die "$!";
	chdir $betalib;
	foreach $line (<IN>) {
	    chop $line;
	    next if ($line =~ /^$/);
	    if ($line =~ /^icomp/i) {
		print "$line\n";
		system ("$InstallShieldDir\\program\\$line >>$CWD\\zfiles\\$nam.lst");
	    } elsif ($line =~ /^(del|ren|copy)/) {
		print "$line\n";
		system($line);
	    } elsif ($line =~ /^cd\s+(.*)$/) {	
		$newpath=$1;
		$newpath =~ s/\%([^\%]+)\%/\$ENV\{\'$1\'\}/ig;
		$newpath =~ s#\\#/#g;
		$newpath = eval("\"$newpath\"\;");
		print "cd $newpath\n";
		chdir $newpath;
	    } else {
		print "\nERROR:Unable to parse \"$line\"\n\n";
	    }
	}
	close(IN);
	chdir $CWD;
	rename("$betalib/$nam.z", "zfiles/$nam.z") || die "$!";
    }
    open (LOG, ">>datafiles/$log") || die "$!";
    open (LOG2, "<zfiles/$nam.lst") || die "$!";
    while(<LOG2>) {
	print LOG $_;
    }
    close(LOG);
    close(LOG2);
}

chdir 'datafiles' || die "Unable to chdir(datafiles): $!";

$ByteSize = 0;
$FileCount = 0;
foreach $basefile (@FileList) {
    if (8 < length($basefile)) {
	$file = substr($basefile, 0, 8);
    } else {
	$file = $basefile;
    }
    $file .= ".z";
    if (!-e "../zfiles/$file") {
	print "Unable to read file '$file'.\n";
	exit 1;
    }
    if ($file =~ /^(.*\/)?([^\/]+).z$/i) {
	$path = ($1 || ".");
	$base = $2;
	chop $path if ($path =~ /\/$/);	# remove trailing slash.
	if ($RoomLeftOnCurDisk < $Minimum) {
	    $CurDisk++;
	    $RoomLeftOnCurDisk = $RestSize;
	}
	print "Splitting $file...";
	system "$SPLIT ..\\zfiles\\$file -F$RestSize -d1\@$RoomLeftOnCurDisk -h >>$log";
	opendir (DIR, $path);
	$lastfound = 0;
	foreach (readdir DIR) {
	    if (/$base\.(\d+)/) {
		if ($lastfound < $1) {
		    $lastfound = $1;
		    $lastused = int(((-s $_) + 1023) / 1024);
		}
	    }
	}
	if ($lastfound == 1) {
	    $RoomLeftOnCurDisk -= $lastused;
	} elsif ($lastfound > 1) {
	    $RoomLeftOnCurDisk = $RestSize - $lastused;
	} else {
	    print "Unable to find any split files.\n";
	    exit 1;
	}
	$startdisk = $CurDisk;
	for ($i = 1; $i <= $lastfound; $i++) {
	    $dirname = "disk$CurDisk";
	    if (!-d $dirname) {
		mkdir($dirname,0777);
		open (TMP, ">$dirname/disk$CurDisk.id");
		close TMP;
	    }		    
	    rename "$path/$base.$i", "$dirname/$base.$i";
	    if ($CurDisk != $LastDisk) {
		$LastDisk = $CurDisk;
		print LST "$CurDisk;\n" ;
	    }
	    print LST "..\\zfiles\\$base.z\n";
	    $CurDisk++;
	}
	$CurDisk--;

	print "\t (On disk $startdisk..$CurDisk, last used ";
	print $RestSize - $RoomLeftOnCurDisk;
	print " kb.)\n";
	
	$AutoRuleText .= "             CompressGet( \"$base.z\", \"*.*\", INCLUDE_SUBDIR );\n";

	open (ICOMP, "$InstallShieldDir\\program\\icomp.exe -l ..\\zfiles\\$base.z |");
	$count = 0; $orgsize = 0;
	foreach $line (<ICOMP>) {
	    if ($line =~ /(\d+)\s+(\d+)\s+(\d+)/) {
		$orgsize=$1; 
		#$compsize=$2; 
		$count=$3;
	    }
	}
	close ICOMP;
	if ($count) {
	    $ByteSize += $orgsize;
	    $FileCount += $count;
	} else {
	    print "Unable to parse output from icomp.\n";
	}
    } else {
	print "Skipping $file\n";
    }
}

close LST;

print "\n";

system "$InstallShieldDir\\program\\packlist.exe ..\\setup.lst >>$log";
rename "setup.pkg", "disk1/setup.pkg";
system "copy /Q %BETALIB\\README.txt disk1 >>$log";
foreach $file ("setup.exe", "uninst.exe", "_isres.dll", "_setup.dll", "_setup.lib", "_inst32i.ex_") {
    system "copy /Q $InstallShieldDir\\program\\$file disk1 >>$log";
}

if (!$UseLastBuild) {
    print "\n\nI have calculated the following sizes of the installation:\n";
    print "(Normally, choose the 2048-value as Minimum Required, and\n";
    print "mention the others in the installation-notes. You cannot\n";
    print " install, if there is less than the Min.Req available.)\n\n";
    print  "ClusterSize   Maximal Need\n";
    foreach $c (0,512,1024,2048,4096,8192,16384,32768) {
	printf "%9d     %9d\n", $c, ($ByteSize + $c * $FileCount);
    }
    print "\n\nPlease edit '$CWD\\$RuleTemplate' NOW.\n";
    print "Then press enter to continue:\n";
    $a = <STDIN>;
}

open (TMP, "../$RuleTemplate") || die "Unable to read $RuleTemplate: $!\n";
open (RUL, ">disk1/setup.rul");
$found = 0;
foreach (<TMP>) {
    chop;
    if ($_ eq '/*---BETA-AUTOSPLIT-INSERT-HERE-MAGIC-KEY---*/') {
	print "Found Autoinsertkey in Rule-template, inserting filelist\n";
	print RUL $AutoRuleText;
	$found = 1;
    } else {
	print RUL "$_\n";
    }
}
close RUL;
close TMP;
if ($found) {
    system("$InstallShieldDir\\program\\compile.exe disk1\\setup.rul >>$log");
    unlink "disk1/setup.rul";
    print "done\n";
} else {
    print "FATAL: did not find Autoinsert-magic key in Rule-template\n";
    exit 1;
}

chdir $CWD;
# Clean up:
system "copy $RuleTemplate zfiles\\$RuleTemplate";
unlink "$RuleTemplate";
unlink "setup.lst";

print "\nNow the ready-to-ship disks should reside in datafiles/diskXX.\n";
print "BUT please check the output from the programs in datafiles/$log\n";
print "\nZIPPING disks as beta_$ENV{'SDK'}.zip (For mjolner distribution)\n\n";

chdir "datafiles";
system "zip -r beta_$ENV{'SDK'} disk*";
chdir $CWD;

print "\nDone.\n";
print "For CDROM/floppydisks, use datafiles/diskXX.\n";
print "For FTP distribution, use datafiles/beta_$ENV{'SDK'}.zip\n";
print "BUT please check the output from the programs in datafiles/$log\n";
