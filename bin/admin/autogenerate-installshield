#! perl


# Takes the list of files.z to be included as args. 
# Configure:

# Where do I find InstallShield:
$InstallShieldDir = "d:\\stirling\\installshield";  

# Disk sizes, modify if installShield outgrows the current reserved room.
$Minimum          =   30;                # Minimum size of chunks (in kb)
$FirstSize        =  600;                # Size of first disk. (in kb)
$RestSize         = 1380;                # Size of rest of disks. (in kb)

# The name of the template for "setup.rul". Try to leave this untouched.
$RuleTemplate     = "setup.rul.template";

$| = 1;   # Flush all read/writes

$betalib = $ENV{'BETALIB'};
$CWD = `cd`; chop $CWD;
$log = "beta_$ENV{'SDK'}.lst";
##############################################################

$SPLIT ="$InstallShieldDir\\program\\split.exe";
$LastUsed = $RestSize - $FirstSize;
$LastDisk = 0;
$CurDisk = 1;
$AutoRuleText = "";

if ($#ARGV == -1) {
    print "autogenerate-installshield: Give me *.cmd files as argument!\n";
    exit 1;
}

foreach $file (@ARGV) {
    if ($file =~ /^(.*)\.cmd$/i) {
	push(@FileList, $1);
    } else {
	print "Unable to handle argument '$file'.\n";
	exit 1;
    }
}

# Check existance of some cricial files:
if (!-e $SPLIT) {
    print "Unable to find split.exe in '$SPLIT'\n";
    exit 1;
}

$prgs = "$InstallShieldDir\\program";
if ($ENV{'PATH'} !~ /$prgs/i) {
    $ENV{'PATH'} = "$prgs;" . $ENV{'PATH'};
}

mkdir('datafiles',0755) if (!-d 'datafiles');

unlink 'setup.lst' if (-e 'setup.lst');
if (-d "disk1" || -d "disk2" || -d "disk3" || -d "disk4" || -d "disk5") {
    print "\n\nWARNING!!! the directory 'disk?' exists allready!\n";
    print "Enter 'yes' to delete disk* from current dir! :\n";
    $ans = <STDIN>; chop $ans;
    if ($ans ne 'yes') {
	print "Quitting\n";
	exit 1;
    }
    print "\n\nDELETING ALL DISK? AND DISK?? DIRECTORIES AND FILES!!!\n\n";
    system "rm -rf disk? disk??";
    print "done.\n\n\n";
}

open (LST, ">setup.lst") || die "Unable to create setup.lst: $!";

system "copy /Q $betalib\\bin\\admin\\setup.rul.template $RuleTemplate";
print "\n\nYou may now start editing\n\t'$CWD\\$RuleTemplate'\n\n";

foreach $file (@FileList) {
    print "\n------Packing $file:\n";
    open (LOG, ">>datafiles/$log");
    print LOG "\n------Packing $file:\n";
    close(LOG);
    unlink "$betalib/$file.z" if (-e "$betalib/$file.z");
    open (IN, "<$file.cmd") || die "$!";
    chdir $betalib;
    foreach $line (<IN>) {
	chop $line;
	if ($line =~ /^icomp/i) {
	    print "$line\n";
	    system ("$InstallShieldDir\\program\\$line >>$CWD\\datafiles\\$log");
	} elsif ($line =~ /^(del|ren|copy)/) {
	    print "$line\n";
	    system($line);
	} elsif ($line =~ /^cd\s+(.*)$/) {	
	    $newpath=$1;
	    $newpath =~ s/\%([^\%]+)\%/\$ENV\{\'$1\'\}/ig;
	    $newpath =~ s#\\#/#g;
	    $newpath = eval("\"$newpath\"\;");
	    print "cd $newpath\n";
	    chdir $newpath;
	} else {
	    print "SKIPPING: $line\n";
	}
    }
    close(IN);
    chdir $CWD;
    if (8 < length($file)) {
	$nam = substr($file, 0, 8);
    } else {
	$nam = $file;
    }
    rename("$betalib/$nam.z", "datafiles/$nam.z") || die "$!";
}

chdir 'datafiles' || die "Unable to chdir(datafiles): $!";

$ByteSize = 0;
$FileCount = 0;
foreach $basefile (@FileList) {
    if (8 < length($basefile)) {
	$file = substr($basefile, 0, 8);
    } else {
	$file = $basefile;
    }
    $file .= ".z";
    if (!-e $file) {
	print "Unable to read file '$file'.\n";
	exit 1;
    }
    if ($file =~ /^(.*\/)?([^\/]+).z$/i) {
	$path = ($1 || ".");
	$base = $2;
	chop $path if ($path =~ /\/$/);	# remove trailing slash.
	$first = $RestSize - $LastUsed;
	if ($first < $Minimum) {
	    $CurDisk++;
	    $first = $RestSize;
	}
	print "Splitting $file...";
	system "$SPLIT $file -F$RestSize -d1\@$first -h >>$log";
	opendir (DIR, $path);
	$lastfound = 0;
	foreach (readdir DIR) {
	    if (/$base\.(\d+)/) {
		if ($lastfound < $1) {
		    $lastfound = $1;
		    $lastused = int(((-s $_) + 1023) / 1024);
		}
	    }
	}
	if ($lastfound == 1) {
	    $LastUsed -= $lastused;
	} elsif ($lastfound > 1) {
	    $LastUsed = $lastused;
	} else {
	    print "Unable to find any split files.\n";
	    exit 1;
	}
	$startdisk = $CurDisk;
	for ($i = 1; $i <= $lastfound; $i++) {
	    $dirname = "disk$CurDisk";
	    if (!-d $dirname) {
		mkdir($dirname,0777);
		open (TMP, ">$dirname/disk$CurDisk.id");
		close TMP;
	    }		    
	    rename "$path/$base.$i", "$dirname/$base.$i";
	    if ($CurDisk != $LastDisk) {
		$LastDisk = $CurDisk;
		print LST "$CurDisk;\n" ;
	    }
	    print LST "$path\\$base.z\n";
	    $CurDisk++;
	}
	$CurDisk--;

	print "\t (On disk $startdisk..$CurDisk, last used $lastused kb.)\n";
	
	$AutoRuleText .= "             CompressGet( \"$base.z\", \"*.*\", INCLUDE_SUBDIR );\n";

	open (ICOMP, "$InstallShieldDir\\program\\icomp.exe -l $base.z |");
	$count = 0; $orgsize = 0;
	foreach $line (<ICOMP>) {
	    if ($line =~ /(\d+)\s+(\d+)\s+(\d+)/) {
		$orgsize=$1; 
		#$compsize=$2; 
		$count=$3;
	    }
	}
	close ICOMP;
	if ($count) {
	    $ByteSize += $orgsize;
	    $FileCount += $count;
	} else {
	    print "Unable to parse output from icomp.\n";
	}
    } else {
	print "Skipping $file\n";
    }
}

close LST;

print "\n";

system "$InstallShieldDir\\program\\packlist.exe ..\\setup.lst >>$log";
rename "setup.pkg", "disk1/setup.pkg";
foreach $file ("setup.exe", "uninst.exe", "_isres.dll", "_setup.dll", "_setup.lib", "_inst32i.ex_") {
    system "copy /Q $InstallShieldDir\\program\\$file disk1 >>$log";
}

print "\n\nI have calculated the following sizes of the installation:\n";
print "(Normally, choose the 2048-value as Minimum Required, and mention\n";
print "the others in the installation-notes. You cannot install, if there\n";
print "is less than the Min.Req available.)\n\n";
print  "ClusterSize   Maximal Need\n";
foreach $c (0,512,1024,2048,4096,8192,16384,32768) {
    printf "%9d     %9d\n", $c, ($ByteSize + $c * $FileCount);
    }
print "\n\nPlease edit '$CWD\\$RuleTemplate' NOW.\n";
print "Then press enter to continue:\n";
$a = <STDIN>;

open (TMP, "../$RuleTemplate") || die "Unable to read $RuleTemplate: $!\n";
open (RUL, ">disk1/setup.rul");
$found = 0;
foreach (<TMP>) {
    chop;
    if ($_ eq '/*---BETA-AUTOSPLIT-INSERT-HERE-MAGIC-KEY---*/') {
	print "Found Autoinsertkey in Rule-template, inserting filelist\n";
	print RUL $AutoRuleText;
	$found = 1;
    } else {
	print RUL "$_\n";
    }
}
close RUL;
close TMP;
if ($found) {
    system("$InstallShieldDir\\program\\compile.exe disk1\\setup.rule >>$log");
    unlink "disk1/setup.rul";
    print "done\n";
} else {
    print "FATAL: did not find Autoinsert-magic key in Rule-template\n";
    exit 1;
}

print "\nZIPPING beta_$ENV{'SDK'}.zip\n";
system "zip -r beta_$ENV{'SDK'} disk*";

chdir $CWD;
# Clean up:
unlink "setup.lst";
unlink "$RuleTemplate";
foreach $basefile (@FileList) {
    if (8 < length($basefile)) {
	$file = substr($basefile, 0, 8);
    } else {
	$file = $basefile;
    }
    unlink "datafiles/$file.z"
}
print "\nNow the ready-to-ship disks should reside in datafiles/diskXX.\n";
print "BUT please check the output from the programs in datafiles/$log\n";
