#!/usr/local/bin/perl -s
#-*-Perl-*-

push(@INC, $ENV{'BETALIB'} . "/bin/admin");

require "env.perl";

local $skipfile  = "$betalib/bin/admin/mbs_export_skiplist.txt";
local @skipfiles;
local @skipdirs;
local $src       = 0;
local $dest      = 0;
local $debug     = 0;
local $numfiles  = 0;
local $numdirs   = 0;

### -------------- main -----------------
$help        = 1 if defined($h);
$skipzip     = 1 if defined($Z);
$traceskip   = 1 if defined($s);
$debug       = 1 if defined($d);
$usedefaults = 1 if defined($u);

$verbose   = 1 if ($debug);
$traceskip = 1 if ($verbose);

$skipzip = 1 if ($simulate);

if (($help) || ($#ARGV>0)) {
    &usage;
}
if ($#ARGV==-1){
    if ($usedefaults){
	$src = $betalib;
    } else {
	print "Enter directory with BETA track to pack:\n(default is \"$betalib\"): ";
	$src = <STDIN>;
	chomp $src;
	$src = $betalib if ($src eq "");
    }
} else {
    $src = $ARGV[0];
}
if (! -d $src){
    print "Error: No such directory: $src\n";
    &usage;
}

# append current date to destination dir
my ($sec,$min,$hour,$date,$month,$year,$day,$yday,$isdst) = localtime(time);
$dest = sprintf("$src-%02d-%02d-%02d", 1900+$year, $month+1, $date);

if (-d $dest){
    print "Removing existing $dest\n";
    &SmartRmDir($dest) unless ($simulate);;
}

&read_skipfile();

print "Copying $src to $dest\n";

&copydir($src, $dest);
print "\n";

&delete_skipfiles();

print "Opening $dest.lst for writing" if ($debug);
open LST, ">$dest.lst" || die "Cannot open $dest.lst for writing: $!\n";
foreach $d (&GetDirsRecursively($dest)){
    print LST "$d/\n";
    foreach $f (&GetFilesInDir($d)){
	print LST "$f\n";
    }
}
close LST;

print "Copied $numfiles files in $numdirs directories\n\n";

&packzip();

1;

### --------------- helper functions --------------

use File::Path;
use File::Copy;
use File::Find;

sub usage {
    print "Usage: mbs_export [options] [directory]\n";
    print "          -h   Print this help\n";
    print "          -s   Inform of files skipped\n";
    print "          -v   Verbose output, implies -s\n";
    print "          -d   debug: very verbose output, implies -v\n";
    print "          -Z   Skip zipping\n";
    print "          -u   Use defaults: pack $betalib if no arguments given\n";
    print "          -n   No effects - only print what would be done\n";
    print "       Pack full track from existing booted [directory]\n       (default $betalib).\n";
    exit 1;
}

sub read_skipfile(){
    if ( -f $skipfile){
	print "Parsing $skipfile ...\n" if ($verbose);
	open SKIP, $skipfile || die "Cannot open skip file $skipfile: $!\n";
	while (<SKIP>){
	    chomp;
	    s%\s*\#.*$%%; # skip comment part of lines
	    next if (/^\s*$/); # skip blank lines
	    my $skippattern = $_;
	    foreach $g (glob("$src/$skippattern")){
		if ( -d $g ){
		    &prompt("Ignoring directory", $g) if ($debug);
		    push @skipdirs, $g; 
		} else {
		    $g = substr $g, length($src)+1;  # remove src/ prefix
		    &prompt("Ignoring file", "$src/$g") if ($debug);
		    push @skipfiles, $g;
		}
	    }
	}
	close SKIP;
    }
}

sub delete_skipfiles(){
    print "Removing files that should have been skipped from $dest ...\n" if ($traceskip);
    foreach $f (@skipfiles){
	&prompt("Deleting", "$dest/$g") if ($traceskip);
	$numfiles--;
	unlink "$dest/$f" unless ($simulate);
    }
}

sub packzip(){
    if (-f $dest.zip){
	print "Removing existing $dest.zip\n";
	unlink "$dest.zip" unless ($skipzip);
    }
    print "Zipping. This may take a while...\n";
    system ("zip -q -r $dest.zip $dest") unless ($skipzip); 
    print "\nPackage ready at $dest.zip\n\n";
}

sub copyfiles ($srcbase, $filespec, $destdir){
    my ($srcbase, $filespec, $destdir) = @_;
    foreach $g (glob("$srcbase/$filespec")){
	my ($path) = "$g";
	# skip various files:
	if ($path =~ m%(~$|\.lst$|\.pdb$|\.sln$|\.duo$|\.suo$|\.dln$|/TODO$|/CVS\b|/test/|/test$)%){
	    &prompt("Skipping (built-in rule)", $path) if ($traceskip);
	    next;
	}
	$path = substr $path, length($srcbase)+1;  # remove srcbase/ prefix
	$path = "$destdir/$path";
	if (-d $g){
	    &copydir($g, $path);
	} else {
	    $path =~ s%/[^/]*$%%;                  # delete trailing file component
	    &prompt("Copy file", $g)         if ($verbose);
	    &prompt("  to directory", $path) if ($verbose);
	    if (! -d "$path"){
		if ($simulate){
		    if ($verbose){
			&prompt("Making directory", $path) unless($reporteddirs{"$path"}==1);
			$reporteddirs{"$path"} = 1;
		    }
		} else {
		    &prompt("Making directory", $path) if ($verbose);
		    &mkpath($path, 0, 0755) unless ($simulate);
		}
	    }
	    $numfiles++;
	    copy($g, "$path") unless ($simulate);
	}
    }
}

sub copydir($srcbase, $destbase){
    my ($srcbase, $destbase) = @_;
    foreach $d (@skipdirs){
	if ($srcbase eq $d){
	    &prompt("Skipping directory", $d) if ($traceskip);
	    return;
	}
    }
    if (-d "$srcbase/CVS"){
	# CVS controlled source: test it's part of beta_project
	if (-f "$srcbase/CVS/Entries"){
	    open REPOSITORY, "$srcbase/CVS/Repository" 
		|| print "warning: cannot open \"$srcbase/CVS/Repository\" for reading: $!\n";
	    my $repository = <REPOSITORY>;
	    close REPOSITORY;
	    chomp $repository;
	    if ($repository !~ m%^beta_project/%){
		&prompt("Skipping non-beta directory", $srcbase) if ($traceskip);
		return;
	    }
	}
    }
    &prompt("Copy directory", $srcbase)  if ($verbose);
    &prompt("  to directory", $destbase) if ($verbose);
    $numdirs++;
    &copyfiles($srcbase, "*", $destbase);
}

sub prompt(){
    local ($prompt, $msg) = @_;
    printf "%-24s: %s\n", $prompt, $msg;
}
