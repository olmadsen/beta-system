#!/usr/local/bin/perl -s

sub usage()
{
    print "usage:\n";
    print "tos_convert [-h][-r][-n][-d] files/directories\n";
    print "  -h  print this help\n";
    print "  -r  recurse into subdirectories\n";
    print "  -q  quiet mode\n";
    print "  -d  debug mode\n";
    print "  -n  simulate: do nothing\n";
}

push(@INC, $ENV{'BETALIB'} . "/bin/admin");
require "utils.perl";

&usage()      if (defined($h)); 

my ($recurse, $simulate, $verbose, $debug);
$verbose  = 1;

$recurse  = 1 if (defined($r));
$simulate = 1 if (defined($n));
$verbose  = 0 if (defined($q));
$debug    = 1 if (defined($d));

$verbose  = 1 if ($debug);
$simulate = 1 if ($debug);

foreach $f (@ARGV){
    if ( -d $f ){
	tos_convert_directory($f);
    } elsif ( -f $f ){
	tos_convert($f);
    } else {
	print "\"$f\" is not a regular file/directory\n" if ($debug);
    }
}

local $substitution = 0;

sub replace(){
    my ($line) = @_;

    # ignore pure comment lines (like, e.g. the ones generated by this script)
    return $line if ($line =~ /^\s*\(\*.*\*\)\s*$/);

    chomp $line;
    my $orig = $line;
    my $orig_substitution = $substitution;

    ##### Byte

    # replace "@@X->TOS'%adrGetByte[n]'" with n -> X.%getByte
    if ($line =~ /\@\@(\w+)\s*->\s*tos\s*\'\%adrGetByte\[([^\]]+)\]\'/i){
	$substitution++;
	$line = $` . "($2->$1.%getByte)" . $';
    }


    ##### Short

    # replace "X->TOS'%getShort[shortNo]'" with "(shortNo->X.%getShort)"
    if ($line =~ /(\w+)\s*->\s*tos\s*\'\%getShort\[([^\]]+)\]\'/i){
	$substitution++;
	$line = $` . "($2->$1.%getShort)" . $';
    }

    # replace "R[expression]->TOS'%getShort[shortNo]'" with "(shortNo->R[expression].%getShort)"
    if ($line =~ /([\w\.]+\[[^\]]+\])\s*->\s*tos\s*\'\%getShort\[([^\]]+)\]\'/i){
	$substitution++;
	$line = $` . "($2->$1.%getShort)" . $';
    }

    #### Long

    # replace "@@X->TOS'%adrGetLong[n]'" with n -> X.%getLong
    if ($line =~ /\@\@([\w\.]+)\s*->\s*tos\s*\'\%adrGetLong\[([^\]]+)\]\'/i){
	$substitution++;
	$line = $` . "($2->$1.%getLong)" . $';
    }

    # replace "@@X->TOS'%adrGetLong'" with 0 -> X.%getLong
    if ($line =~ /\@\@([\w\.]+)\s*->\s*tos\s*\'\%adrGetLong\'/i){
	$substitution++;
	$line = $` . "(0->$1.%getLong)" . $';
    }

    # replace "addr+off->TOS'%adrGetLong'" with "%getLongAt(addr+off)";
    if ($line =~ /([\w\.]+)\s*\+\s*(\d+)\s*->\s*tos\s*\'\%adrGetLong\'/i){
	$substitution++;
	$line = $` . "(%getLongAt($1+$2))" . $';
    }

    # replace "addr->TOS'%adrGetLong'" with "%getLongAt(addr)";
    if ($line =~ /([\w\.]+)\s*->\s*tos\s*\'\%adrGetLong\'/i){
	$substitution++;
	$line = $` . "(%getLongAt($1))" . $';
    }

    #### Bits

    # replace "->TOS'%ShiftLeft[n]'" with " %sll n"
    if ($line =~ /\s*->\s*tos\s*\'\%shiftleft\[([^\]]+)\]\'/i){
	$substitution++;
	$line = $` . " %sll $1" . $';
    }

    # replace "X->TOS'%getSignedBits[bitNo,noOfBits]'" with "X; ((bitNo,noOfBits)->X.%getSignedBits)"
    if ($line =~ /(\w+)\s*->\s*tos\s*\'\%getSignedBits\[([^\]]+\s*,\s*[^\]]+)\]\'/i){
	$substitution++;
	$line = $` . "$1; (($2)->$1.%getSignedBits)" . $';
    }

    # replace "(x,y)->TOS'%or'" with "x %Bor y"
    if ($line =~ /\(\s*([\w\.]+)\s*,\s*([\w\.]+)\s*\)\s*->\s*tos\s*\'\%or\'/i){
	$substitution++;
	$line = $` . "$1 %Bor $2" . $';
    }

    # replace "(x,y)->TOS'%and'" with "x %Band y"
    if ($line =~ /\(\s*([\w\.]+)\s*,\s*([\w\.]+)\s*\)\s*->\s*tos\s*\'\%and\'/i){
	$substitution++;
	$line = $` . "$1 %Band $2" . $';
    }


    $line .= "\n";

    if ($substitution > $orig_substitution){
	# Add comment decribing change
	$orig =~ s/^(\s*)//; # delete leading whitespace in original line
	my $orig_indent = $&;
	$orig =~ s/\(\*.*\*\)//; # delete comments in original line
	$orig =~ s/(\s*)$//; # delete trailing whitespace in original line
	$line .= $orig_indent . "(* Above line tos_converted from: $orig *)\n";
    }

    return $line;
}

sub tos_convert()
{
    my ($file) = @_;
    my $line;
    my @lines;
    $substitution = 0;
    return if ($file !~ /\.bet$/);
    print "Converting \"$f\"\n" if ($verbose);
    open BETA, "$file" || die "Cannot open $file for reading: $!\n";
    while (<BETA>){
	push @lines, &replace($_);
    }
    close BETA;
    if ($substitution){
	print "  *** $substitution changes.\n" if ($verbose);
	open BETA, ">$file" || die "Cannot open $file for writing: $!\n";
	print BETA join "", @lines;
	close BETA;
    } else {
	print "  (No changes).\n" if ($debug);
    }
	
    
}

sub tos_convert_directory()
{
    my ($dir) = @_;
    my (@files);
    if ($recurse){
	@files = &GetFilesInDirs(&GetDirsRecursively($dir));
    } else {
	@files = &GetFilesInDir($dir);
    }
    foreach $f (@files){
	&tos_convert($f);
    }
}
