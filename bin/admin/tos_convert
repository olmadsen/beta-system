#!/usr/local/bin/perl -s
use Text::Tabs;

sub usage()
{
    print "usage:\n";
    print "tos_convert [-h][-r][-n][-d] files/directories\n";
    print "  -h  print this help\n";
    print "  -r  recurse into subdirectories\n";
    print "  -i  interactive mode (ask before replacing)\n";
    print "  -q  quiet mode\n";
    print "  -d  debug mode\n";
    print "  -n  simulate: do nothing\n";
}

push(@INC, $ENV{'BETALIB'} . "/bin/admin");
require "env.perl";

&usage()      if (defined($h)); 

my ($recurse, $simulate, $verbose, $debug);
$verbose  = 1;

$recurse     = 1 if (defined($r));
$simulate    = 1 if (defined($n));
$verbose     = 0 if (defined($q));
$debug       = 1 if (defined($d));
$interactive = 1 if (defined($i));

$verbose  = 1 if ($debug);
$simulate = 1 if ($debug);

foreach $f (@ARGV){
    if ( -d $f ){
	tos_convert_directory($f);
    } elsif ( -f $f ){
	tos_convert($f);
    } else {
	print "\"$f\" is not a regular file/directory\n" if ($debug);
    }
}

local $substitution = 0;

sub replace(){
    my ($line) = @_;

    # ignore pure comment lines (like, e.g. the ones generated by this script)
    return $line if ($line =~ /^\s*\(\*.*\*\)\s*$/);

    chomp $line;
    my $orig = $line;
    my $orig_substitution = $substitution;

    ##### Byte

    # replace "X->TOS'%getByte[byteNo]'" with "(byteNo->X.%getByte)"
    if ($line =~ /([\w\.]+)\s*->\s*tos\s*\'\%getByte\[([^\]]+)\]\'/i){
	$replace = "($2->$1.%getByte)";
	$line = &ask_replace($`, $&, $', $replace);
    }

    # replace "R[expression]->TOS'%getByte[byteNo]'" with "(byteNo->R[expression].%getByte)"
    if ($line =~ /([\w\.]+\[[^\]]+\])\s*->\s*tos\s*\'\%getByte\[([^\]]+)\]\'/i){
	$replace =  "($2->$1.%getByte)";
	$line = &ask_replace($`, $&, $', $replace);
    }

    # replace "@@X->TOS'%adrGetByte[n]'" with n -> X.%getByte
    if ($line =~ /\@\@(\w+)\s*->\s*tos\s*\'\%adrGetByte\[([^\]]+)\]\'/i){
	$replace = "($2->$1.%getByte)";
	$line = &ask_replace($`, $&, $', $replace);
    }


    ##### Short

    # replace "X->TOS'%getShort[shortNo]'" with "(shortNo->X.%getShort)"
    if ($line =~ /([\w\.]+)\s*->\s*tos\s*\'\%getShort\[([^\]]+)\]\'/i){
	$replace = "($2->$1.%getShort)";
	$line = &ask_replace($`, $&, $', $replace);
    }

    # replace "R[expression]->TOS'%getShort[shortNo]'" with "(shortNo->R[expression].%getShort)"
    if ($line =~ /([\w\.]+\[[^\]]+\])\s*->\s*tos\s*\'\%getShort\[([^\]]+)\]\'/i){
	$replace = "($2->$1.%getShort)";
	$line = &ask_replace($`, $&, $', $replace);
    }

    #### Long

    # replace "@@X->TOS'%adrGetLong[n]'" with n -> X.%getLong
    if ($line =~ /\@\@([\w\.]+)\s*->\s*tos\s*\'\%adrGetLong\[([^\]]+)\]\'/i){
	$replace = "($2->$1.%getLong)";
	$line = &ask_replace($`, $&, $', $replace);
    }

    # replace "@@X->TOS'%adrGetLong'" with 0 -> X.%getLong
    if ($line =~ /\@\@([\w\.]+)\s*->\s*tos\s*\'\%adrGetLong\'/i){
	$replace = "(0->$1.%getLong)";
	$line = &ask_replace($`, $&, $', $replace);
    }

    # replace "@@X+off->TOS'%adrGetLong'" with "%getLongAt(addr+off)";
    if ($line =~ /(\@\@[\w\.]+)\s*\+\s*(\d+)\s*->\s*tos\s*\'\%adrGetLong\'/i){
	$replace = "(%getLongAt($1+$2))";
	$line = &ask_replace($`, $&, $', $replace);
    }

    # replace "addr+off->TOS'%adrGetLong'" with "%getLongAt(addr+off)";
    if ($line =~ /([\w\.]+)\s*\+\s*(\d+)\s*->\s*tos\s*\'\%adrGetLong\'/i){
	$replace = "(%getLongAt($1+$2))";
	$line = &ask_replace($`, $&, $', $replace);
    }

    # replace "addr->TOS'%adrGetLong'" with "%getLongAt(addr)";
    if ($line =~ /([\w\.]+)\s*->\s*tos\s*\'\%adrGetLong\'/i){
	$replace = "(%getLongAt($1))";
	$line = &ask_replace($`, $&, $', $replace);
    }

    #### Bits

    # replace "->TOS'%ShiftLeft[n]'" with " %sll n"
    if ($line =~ /\s*->\s*tos\s*\'\%shiftleft\[([^\]]+)\]\'/i){
	$replace = " %sll $1";
	$line = &ask_replace($`, $&, $', $replace);
    }

    # replace "X->TOS'%getSignedBits[bitNo,noOfBits]'" with "X; ((bitNo,noOfBits)->X.%getSignedBits)"
    if ($line =~ /(\w+)\s*->\s*tos\s*\'\%getSignedBits\[([^\]]+\s*,\s*[^\]]+)\]\'/i){
	$replace = "$1; (($2)->$1.%getSignedBits)";
	$line = &ask_replace($`, $&, $', $replace);
    }

    # replace "(x,y)->TOS'%or'" with "x %Bor y"
    if ($line =~ /\(\s*([\w\.]+)\s*,\s*([\w\.]+)\s*\)\s*->\s*tos\s*\'\%or\'/i){
	$replace = "$1 %Bor $2";
	$line = &ask_replace($`, $&, $', $replace);
    }

    # replace "(x,y)->TOS'%and'" with "x %Band y"
    if ($line =~ /\(\s*([\w\.]+)\s*,\s*([\w\.]+)\s*\)\s*->\s*tos\s*\'\%and\'/i){
	$replace = "$1 %Band $2";
	$line = &ask_replace($`, $&, $', $replace);
    }


    $line .= "\n";

    if ($substitution > $orig_substitution){
	# Add comment decribing change
	$orig =~ s/^(\s*)//; # delete leading whitespace in original line
	my $orig_indent = $&;
	$orig =~ s/\(\*.*\*\)//; # delete comments in original line
	$orig =~ s/(\s*)$//; # delete trailing whitespace in original line
	$line .= $orig_indent . "(* Above line tos_converted from: $orig *)\n";
    }

    return $line;
}

sub ask_replace(){
    my ($before, $match, $after, $replace) = @_;
    my $oldline = $before . $match . $after;
    my $newline = $before . $replace . $after;

    return $oldline if ($quit);
    if ($interactive){
	my $indent = length(expand($before));
	my $oldlen = length(expand($before . $match)) - $indent;
	my $newlen = length(expand($before . $replace)) - $indent;
	print "\n";
	print "-" x 10 . " Replace this original code: " . "-" x 10 . "\n\n";
	print $oldline . "\n";
	print " " x $indent . "^" x $oldlen . "\n\n";
	print "-" x 10 . " with this new code: " . "-" x 10 . "\n\n";
	print $newline . "\n";
	print " " x $indent . "^" x $newlen . "\n\n";
      get_answer: 
	{
	    print "-" x 10 . " Answer: (y/n/a/q/?) ";
	    my $answer = &GetAnswer();
	    if      ($answer eq "n"){
		return $oldline;
	    } elsif ($answer eq "y"){
		# fall through
	    } elsif ($answer eq "q"){
		$quit = 1;
		return $oldline;
	    } elsif ($answer eq "a"){
		$interactive = 0;
		# fall through
	    } elsif ($answer eq "?"){
		print "Possible answers:\n";
		print "  y  - accept this replacement, ask for subsequent replacements\n";
		print "  n  - reject this replacement, ask for subsequent replacements\n";
		print "  a  - accept this and all subsequent replacements\n";
		print "  q  - quit: ignore this and subsequent replacements\n";
		print "  ?  - print this help\n";
		redo get_answer;
	    }
	}
    } 
    $substitution++;
    return $newline;
}

sub tos_convert()
{
    my ($file) = @_;
    my $line;
    my @lines;
    $substitution = 0;
    return if ($file !~ /\.bet$/);
    print "Converting \"$f\"\n" if ($verbose);
    open BETA, "$file" || die "Cannot open $file for reading: $!\n";
    while (<BETA>){
	push @lines, &replace($_);
    }
    close BETA;
    if ($substitution){
	print "  *** $substitution changes.\n" if ($verbose);
	open BETA, ">$file" || die "Cannot open $file for writing: $!\n";
	print BETA join "", @lines;
	close BETA;
    } else {
	print "  (No changes).\n" if ($debug);
    }
	
    
}

sub tos_convert_directory()
{
    my ($dir) = @_;
    my (@files);
    if ($recurse){
	@files = &GetFilesInDirs(&GetDirsRecursively($dir));
    } else {
	@files = &GetFilesInDir($dir);
    }
    foreach $f (@files){
	&tos_convert($f);
    }
}
