ORIGIN 'generator';
INCLUDE '~beta/containers/v1.6/hashTable'
--- makebobs: descriptor ---
(# sc: ^mg.synCat;
   m1,m2,m3,m4,m5: @char;
   t: @text;
   caseSensitive: @boolean;
   dashKeywords: @boolean;
   terms: @terminalScanner;
   sonno: @integer;
   terminalScanner: hashTable
     (# element::< text;
        hashFunction::< 
          (# 
          do 0->value;
             e.scanAll(# do (ch->ascii.lowcase) + 10 * value->value 
          #)#);
        equal::< (# do left[]->right.equalNCS->value #);
        insertValue: 
          (# t: ^text 
          enter t[] 
          do t[]->hashFunction->findIndexed
             (# predicate::(#do current[]->t.equalNCS->value #);
                notFound::(#do t[]->insert #)
             #)
          #)
     #);
   collectTerminals: 
     (# charcount: [128]@char;
        termscan: 
          (# term: ^mg.term;
             cons: ^mg.constructor;
             cl: ^mg.ConsElemList;
             node: ^ast;
             exp: ^expanded;
          do pl.newscan
             (#
             do (if current.symbol
                 // mg.listOne//mg.listZero then
	            current.getson3->node[];
	            (if node.symbol=mg.term then
	                node[]->term[]; term.getText->terms.insertValue; 
	            if);
                 // mg.constructor then
	            current[]->cons[];
	            cons.getConsElemList->cl[];
	            cl.scan
	            (#
                    do (if current.symbol=mg.term then
	                   current[]->term[]; term.getText->terms.insertValue; 
             if) #) if) #)
          #);
        checklegality: 
          (# c: @char;
          enter c
          do l:(if charcount[c]<>0 then
                   ('!','/')
                     -> forTo(# do (if charcount[inx]=0 then inx->c; leave l if) #);
                   ('{','~')
                     -> forTo(# do (if charcount[inx]=0 then inx->c; leave l if) #);
                   (failure,'Makebobs did not find a free meta-symbol!')->&stop;
               if);
	     -1->charcount[c];
          exit c
          #);
        
        i: @integer;
        optSpec: ^mg.optionSpecification;
        str: ^string;
        s:  ^text; 
        EOSchar: @char; 
        t: @text
     do '='->m1;
        '|'->m2;
        '<'->m3;
        ';'->m4;
        '"'->m5;
        terms.init;
        (* first add the string character *)
        (if ('stringchar'->root.optionSet->optSpec[]) = none then
            ''''->terms.insertValue;
         else
            (optSpec[],'stringChar',mg.optionString)->root.checkOption->str[];
            str.getText->s[]; 
            (* some grammars have stringChar = ''' ';
             * remove possible blanks
             *)
            t.clear;
            s.scanAll(#do (if ch > ' ' then ch->t.put if)#);
            (if t.length <> 1 then
                '\n**** Illegal stringChar: '->putText; s[]->putLine;
                '\t It must be a single char!'->putLine
            if);
            t.copy->terms.insertValue;
        if);
        (if ('combegin'->root.optionSet->optSpec[])=none then
            '(*'->terms.insertValue;
         else
              (optSpec[],'comBegin',mg.optionString)->root.checkOption->str[];
              str.getText->terms.insertValue;
        if);
       (for i:127 repeat 0->charcount[i] for);
        termscan;
        terms.scan
        (# 
        do current.scanAll
           (# do ch->ascii.lowCase->ch; charcount[ch] + 1->charcount[ch] 
        #) #);
            (*
        m2->checklegality->m2;
        m3->checklegality->m3;
        m4->checklegality->m4;
        -1->charcount['+']->charcount['?']->charcount[':']->charcount['^']
          ->charcount['%']->charCount['0']->charCount['1']->charCount['2']
          ->charcount['3']->charCount['4']->charCount['5']->charCount['6']
          ->charcount['7']->charCount['8']->charCount['9'];
        (* that was some charvalues we cannot use as M1 * )
         m1->checklegality->m1;
         *)
        'METASYMBOLS  M1='->bobsFile.puttext; m1->bobsFile.put;
        ' M2='->bobsFile.puttext; m2->bobsFile.put;
        ' M3='->bobsFile.puttext; m3->bobsFile.put;
        ' M4='->bobsFile.puttext; m4->bobsFile.put;
        ' M5='->bobsFile.puttext; m5->bobsFile.put;
        bobsFile.newline;
        0->i;
        '<<'->emitTerm;
        ('EOSchar','-')->root.getOptionString->t;
        (if t.length=1 then
            1->t.inxGet->EOSchar
         else 'Grammar property EOSchar: "'->putText;
            t[]->puttext; '" must be a single character'->putText;
            (failure,'generator stops')->&stop
        if);
            m5->bobsFile.put;
            EOSchar->bobsFile.put; EOSchar->bobsFile.put;
            m5->bobsFile.put; ' '->bobsFile.put;
            '_EMPTY_'->emitTerm;
            '_NAME_'->emitTerm;
            '_KONST_'->emitTerm;
            '_STRING_'->emitTerm;
            '_ERROR_' -> emitTerm;
        bobsFile.newLine;
        terms.scan
        (#
        do (if ((i+1->i) mod 6)=0 then bobsFile.newline; if);
           (if caseSensitive then
               current[]->emitTerm;
            else current[]->toSmall->emitTerm
           if)
        #);
        endbobsline;
        #);
   emitTerm: 
      (# term: ^text
      enter term[]
      do m5->bobsFile.put;
         term.scanAll(#do ch->bobsFile.put;
                         (if ch = m5 then m5->bobsFile.put
                      if)#);
         m5->bobsFile.put;
         ' '->bobsFile.put
      #);
   endbobsline: (# do m4->bobsFile.put; bobsFile.newline; #);
   writebobsnonterm:
     (# n: ^text;
     enter n[]
     do m3->bobsFile.put;
        n.makeLC;
        n[]->bobsFile.puttext;
        m3->bobsFile.put;
        ' '->bobsFile.put;
     #);
   writebobsmarkednonterm: 
     (# n: ^text;
     enter n[]
     do m3->bobsFile.put;
        n.makeLC; n[]->bobsFile.puttext;
        'MARKED'->bobsFile.puttext;
        m3->bobsFile.put;
        ' '->bobsFile.put;
     #);
   writebobsSyncat:
     (# sc: ^mg.syncat
     enter sc[]
     do sc.getSynText->writebobsnonterm
     #);
   writebobsterm: 
     (# t: ^mg.Term; s: ^text
     enter t[] 
     do m5->bobsFile.put;
        (if caseSensitive then t.getText->s[]
         else t.getText->tosmall->s[]
        if);
        s.scanAll(#do ch->bobsFile.put;
                     (if ch = m5 then ch->bobsFile.put
                  if)#);
        m5->bobsFile.put
     #);
   labelit: 
     (# l: ^text;
        i: @integer;
     enter(l[],i)
     do (if l.t[l.pos]=' ' then l.pos - 1->l.pos; if);
        (* that was to remove a space if it was inserted, because a string 
         cannot have length 1 *)
        l[]->bobsFile.putText;
        '.'->bobsFile.put;
        i->bobsFile.putInt;
        m1->bobsFile.put;
        ' '->bobsFile.put;
     #);
   writeleftside:
     (# ls: ^mg.leftside;
     enter ls[]
     do ls.getSyndeclText->writebobsnonterm; 
        m1->bobsFile.put;
        ' '->bobsFile.put;
     #);
   writemarkedleftside:
     (# ls: ^mg.leftside;
     enter ls[]
     do ls.getSynDeclText->writebobsmarkednonterm; 
        m1->bobsFile.put;
        ' '->bobsFile.put;
     #);
   writebobsalternation:
     (#
     do bobsFile.newline;
        '              '->bobsFile.puttext;
        m2->bobsFile.put; 
        ' '->bobsFile.put; 
     #);
   bobsalternation:
     (# al: ^mg.Alternation;
        sl: ^mg.syncatList;
        no: @integer;
     enter (al[],no)
     do al.getLeftside->writeLeftside;
        al.getSyncatList->sl[];
        sl.newscan(# do 
                     (if currentSonNo<>1 then writebobsalternation if);
                     ('?',no)->labelit; 
                     current[]->writebobssynCat;
                  #);
        endbobsline;
     #);
   bobsConstructor:
     (# co: ^mg.Constructor; 
        cl: ^mg.ConsElemList;
        no: @integer;
     enter (co[],no) 
     do co.leftSide->writeLeftSide;
        ((co.GetSynDeclText),no)->labelit;
        co.getConsElemList->cl[];
        cl.newscan
        (# tsc: ^mg.TaggedSyn;
           sn: ^mg.SynName;
           s: ^String;
        do (if current.symbol
            // mg.Term then current[]->writeBobsTerm; 
            // mg.TaggedSyn then 
               current[]->tsc[]; tsc.getSynText->writebobsnonterm;
            // mg.Syncat then
               current[]->writebobsSyncat;
            // mg.errorSpec then
               m5->bobsFile.put;
               '_ERROR_'->bobsfile.putText;
               m5->bobsFile.put;
           if);
           ' '->bobsFile.put;
        #);
        endbobsline;  
     #);
   BobsListOne:
     (# li: ^mg.listOne; 
        ls: ^mg.LeftSide;
        no: @integer;
        snText,SdText: ^text;
        t: ^ast;
        knd: @integer;
        sc: ^mg.synCat;
     enter(li[],no) 
     do li.getLeftSide->ls[]->writeLeftSide;
        ((ls.getSynDeclText->sdText[]),no)->labelit;
        li.GetSynCat->sc[];
        sc.getSynText->sntext[]->writebobsnonterm;
        writebobsalternation;
        ('+',no)->labelit;
        sdText[]->writebobsnonterm;
        li.getTermOp->t[];
        (if t.symbol=mg.term then t[]->writebobsterm if);
        snText[]->writebobsnonterm;
        endbobsline;
     #);
   BobsListZero:
     (# li: ^mg.listZero; 
        ls: ^mg.LeftSide;
        t : ^ast;
        no: @integer;
        snText,sdText: ^text;
        knd: @integer;
     enter (li[],no) 
     do li.GetLeftSide->ls[]->writeLeftSide;
        ('?',0)->labelit; (* OLM: 28/1/97:
                            * The 0 (zero) in the enter-part should perhaps 
                            * be  'no'. Otherwise the pretty printer may
                            * have a problem with PP of list zero nonterminals.
			    * OLM: 16/06/97: correction done!
			    * OLM: 17/06/97: reversed:-( it MUST be a zero here
			    *      since astParser uses the zero to avoid creating 
			    *      an extra node for the optional production
			    *      generating a listOne - a listZero is an optional
			    *      generating a listOne 
                            *)
        ls.getSynDeclText->sdText[]->writebobsmarkednonterm;
        writebobsalternation;
        (sdtext[],no)->labelit;
        m5->bobsFile.put;
        '_EMPTY_'->bobsFile.putText;
        m5->bobsFile.put;
        endbobsline;
        ls[]->writeMarkedLeftSide;
        (sdtext[],no)->labelit;
        li.getSyncat->sc[];
        sc.getSynText->snText[]->writebobsnonterm;
        writebobsalternation;
        ('*',no)->labelit;
        sdText[]->writebobsmarkednonterm;
        li.getTermOp->t[];
        (if t.symbol=mg.term then t[]->writebobsterm if);
        snText[]->writebobsnonterm;
        endbobsline;
     #);
   bobsOptional: 
     (# op: ^mg.Opt;
        no: @integer
     enter (op[],no)
     do op.GetLeftSide->writeLeftSide;
        ('_EMPTY_',no)->labelit;
        m5->bobsFile.put;
        '_EMPTY_'->bobsFile.putText;
        m5->bobsFile.put;
        writebobsalternation;
        ('?',optional)->labelit;
        op.getSyncat->sc[];
        sc.getSynText->writebobsnonterm;
        endbobsline;
     #);
   bobsDummy:
     (# dm: ^mg.dummy;
     enter dm[]
     do dm.GetLeftSide->writeLeftSide;
        ('?',0)->labelit;
        dm.getSyncat->writebobsSynCat;
        endbobsline;
     #);
   writegoalsymbol:
     (# prod:^mg.prod
     do 'GOALSYMBOL = '->BobsFile.putText;
        1->pl.get->prod[];
        prod.GetSynDeclText->tosmall->bobsFile.putText;
        endbobsline;
        prod.leftside->writeLeftSide;
        ('_ERROR_',-1)->labelit;
        m5->bobsFile.put;
        '_ERROR_'->bobsFile.putText;
        m5->bobsFile.put;
        endbobsline;
     #);
   writeLexem: 
     (# optSpec: ^mg.optionSpecification;
        t,labelText,bobsprod: @text;
        no: @integer;
     enter (t,no,labeltext,bobsProd)
     do (if (t->root.optionSet->optSpec[])=none then
            t[]->writebobsnonterm; 
            m1->bobsFile.put;
            ' '->bobsFile.put;
            (labelText[],no)->labelit;
            m5->bobsFile.put;
            bobsProd[]->bobsFile.putText;
            m5->bobsFile.put;
            endbobsline;
        if);
     #);
   genComment:
     (# optSpec: ^mg.optionSpecification;
        str: ^string;
     do 'COMMENT = '->bobsFile.putText;
        m5->bobsFile.put;
        (if (('combegin'->root.optionSet->optSpec[])=none) then
            '(*'->bobsfile.putText;
         else
            (optSpec[],'comBegin',mg.optionString)->root.checkOption->str[];
            str.getText->bobsfile.putText;
        if);
        m5->bobsFile.put;
        ' '->bobsfile.put; m4->bobsfile.put; ' '->bobsfile.put;
        m5->bobsFile.put;
        (if (('comend'->root.optionSet->optSpec[])=none) then
            '*)'->bobsfile.putText;
         else
            (optSpec[],'comEnd',mg.optionString)->root.checkOption->str[];
            str.getText->bobsfile.putText;
        if);
        m5->bobsFile.put;
        endBobsLine;
     #);
   genStringCh:
     (# optSpec: ^mg.optionSpecification;
        str: ^string;
     do 'STRINGCH = '->bobsFile.putText;
        (if ('stringchar'->root.optionSet->optSpec[])=none then
            ''''->bobsfile.put;
         else
            (optSpec[],'stringChar',mg.optionString)->root.checkOption->str[];
            str.getText->bobsfile.putText;
        if);
        endBobsLine;
     #);
   genOption:
     (# optSpec: ^mg.optionSpecification;
        str: ^string;
     do 'OPTIONS('->bobsFile.putText;
        (if ('bobsoptions'->root.optionSet->optSpec[])=none then
            (if dashKeywords then '5,'->bobsfile.puttext if);
            '32,34,59'->bobsfile.putText;
         else
            (optSpec[],'bobsoptions',mg.optionString)->root.checkOption->str[];
            str.getText->bobsfile.putText;
        if); 
        ')'->bobsfile.put;
        bobsFile.newLine;
     #)
do ('caseSensitive','false')->root.getOptionName->t;
   'true'->t.equalNCS->caseSensitive;
   ('dashKeywords','false')->root.getOptionName->t;
   'true'->t.equalNCS->dashKeywords;
   genOption;
   collectterminals;
   genStringCh;
   genComment;
   writegoalsymbol;
   ('nameappl',nameAppl,'^','_NAME_')->writeLexem;
   ('namedecl',nameDecl,':','_NAME_')->writeLexem;
   ('const'   ,const,'%','_KONST_')->writeLexem;
   ('string'  ,string,'''','_STRING_')->writeLexem;
   pl.scan
   (# do
      (if current.symbol
       // mg.Alternation then (current[],currentSonNo)->bobsAlternation;
       // mg.Constructor then (current[],currentSonNo)->bobsConstructor;
       // mg.ListOne then (current[],currentSonNo)->bobsListOne;
       // mg.ListZero then (current[],currentSonNo)->bobsListZero;
       // mg.Opt then (current[],currentSonNo)->bobsOptional;
       // mg.Dummy then current[]->bobsDummy;
      if);
   #);
   m4->bobsFile.put; m4->bobsFile.put; bobsFile.newline;
#)
