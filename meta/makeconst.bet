ORIGIN '~beta/mps/v5.2/astlevel';
INCLUDE '~beta/mps/v5.2/metagrammarcfl'; 
INCLUDE '~beta/mps/v5.2/metagramsematt';
--- PROGRAM: descriptor ---
astInterface
(# mg: @metagrammar;
   generateConst:
     (# ff: ^fragmentForm; 
        s: ^stream;
        root: ^mg.Agrammar;
        pl: ^mg.productionlist
     enter (ff[],s[])
     do 'ORIGIN ''~beta/basiclib/v1.6/betaenv''' -> s.putText;
        s.newLine;
        '--- ' -> s.putText; s.newLine;
        'Lib: attributes' -> s.putText; s.newLine;
        ' ---' -> s.putText; s.newLine;
        'grammar: ' -> s.putText; s.newLine;
        '(#' -> s.putText; s.newLine;
        '  unExpanded: (# exit -1 #); ' -> s.putText; s.newLine;
        '  dummy: (# exit -123872634 #); ' -> s.putText; s.newLine;
        '  empty: (# exit' -> s.putText; optional -> s.putInt; ' #); ' -> s.putText;
        s.newLine;
        ff.root[] -> root[];
        root.getProductionList -> pl[];
        s.newLine;
        pl.newScan
          (# 
          do '  ' -> s.putText;
             current.getSynDeclText -> s.putText;
             ': (# exit ' -> s.putText;
             currentSonNo -> s.putInt;
             ' #);' -> s.putText;
             s.newLine;
          #);
        '#)' -> s.putText; s.newLine;
     #);
   group,fg: ^fragmentGroup;
   fullNameOfGrammar, t: ^text;
   grammars: ^fragment;
   frag: ^fragmentForm;
   fil: @file;
do mg.init;
   '~beta/grammars/metagram/v4.4/metagrammar-parser' -> t[];
   parserFileExtension->t.append;
   t[] -> expandToFullPath-> mg.parser.initialize;
   screen.newLine;
   'Grammar ?' -> screen.putText;
   (keyBoard.getAtom -> expandToFullPath -> fullNameOfGrammar[],screen[])
     -> top.topgroup.open -> group[];
   'Opening: "' -> screen.putText;
   fullNameOfGrammar[] -> screen.putText;
   '" ' -> screen.putText; screen.newLine;
   (if group[]=none then (normal,'Grammar not found') -> stop if);
   ('meta',screen[]) -> group.open -> grammars[];
   (if grammars[]=none then (normal,'meta not found') -> &stop if);
   'gram.new' -> fil.name;
   fil.openWrite;
   (if grammars.type=grouptype then 
       grammars[] -> fg[];
       fg.fragmentList.scan
       (# 
       do current.f[] -> frag[];
          (if frag.grammar[]=mg[] then (frag[],fil[]) -> generateConst if);
       #);
   if);
   fil.close;
   group.close;
#)
