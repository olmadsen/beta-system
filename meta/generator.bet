ORIGIN '~beta/mps/astlevel';
BODY 'checker' 'makebobs' 'makepat';
INCLUDE '~beta/mps/metagrammarcfl'; 
INCLUDE '~beta/mps/metagramsematt'; 
INCLUDE '~beta/basiclib/file'; 
--- astInterfaceLib: attributes ---
make_traverse: (# exit true #);
generator: 
  (# mg: @metagrammar;
     root: ^mg.Agrammar;
     pl: ^mg.productionlist;
     optList: ^mg.optionList;
     attlist: ^mg.AttribList;
     gn: ^mg.grammarName;
     nd: ^nameDecl;
     ok: @Boolean;
     cflFile,traverseFile,traverseBodyFile,BobsFile,grammarFile: @File
       (# <<SLOT MetaFileLib: attributes>>;
          patbegin:
            (# name, comment: ^text;
            enter (name[], comment[])
            do indent;
               name[] -> puttext;
               ': ' -> puttext;
               (if comment[]<>NONE then
                   commentbegin;
                   comment[] -> puttext;
                   commentend;
               if);
               newline;
               2 -> indent.inc;
               indent;
               '(\# ' -> puttext;
               3 -> indent.inc
            #);
          patend:
            (# 
            do 3 -> indent.dec;
               indent;
               '#\);' -> putline;
               2 -> indent.dec;
            #);
          CommentBegin: 
            (# 
            do '(\* ' -> puttext;
            #);
          CommentEnd:
            (# 
            do ' *\)' -> puttext;
            #);
          Indent: @
            (# indentlevel: @integer;
               debug: (# exit false #);
               get:
                 (# exit indentlevel #);
               set:
                 (# i: @integer;
                 enter i
                 do i -> indentlevel;
                    (if debug then
                        commentbegin;
                        '='->put;
                        indentlevel->putint;
                        commentend;
                    if)
                 #);
               inc: 
                 (# i: @integer;
                 enter i
                 do indentlevel+i -> indentlevel;
                    (if debug then
                        commentbegin;
                        '+'->put;
                        i->putint;
                        '='->put;
                        indentlevel->putint;
                        commentend;
                    if)
                 #);
               dec:
                 (# i: @integer
                 enter i
                 do indentlevel-i -> indentlevel;
                    (if debug then
                        commentbegin;
                        '-'->put;
                        i->putint;
                        '='->put;
                        indentlevel->putint;
                        commentend;
                    if)
                 #);
            do (for i:indentlevel repeat ' '->put for);
            #);
       #);
     cflFileName,traverseFileName,traverseBodyFileName,BobsFileName: ^Text;
     checker: <<SLOT checker: descriptor>>;
     makepatterns: <<SLOT makepatterns: descriptor>>; 
     makebobs: <<SLOT makebobs: descriptor>>; 
     toSmall: (# n: ^text enter n[] do n.makeLC exit n[] #);
     grammars: ^fragment;
     frag: ^fragmentForm;
     fullNameOfGrammar: ^text;
     generateFragment: 
       (# frag: ^fragmentForm
       enter frag[]
       do frag.root[] -> root[];
          root.getProductionList -> pl[];
          (# op: ^ast;
             opPart: ^mg.optionPart;
          do root.getOptionOp -> op[];
             (if op.symbol=mg.optionPart then 
                 op[] -> opPart[];
                 opPart.getOptionList -> optList[];
              else none -> optList[]
             if);
          #);
          (# as: ^ast;
             attributePart: ^mg.attributePart;
          do root.getAttributeOp -> as[];
             (if as.symbol=mg.AttributePart then
                 as[] -> attributePart[]; attributePart.getson1 -> attlist[]
              else none -> attlist[];
             if);
          #);
          (if frag.modificationStatus=0 then
              checker
          if);
          (if cflFileName.length<>0 then 
              'Generating patterns:' -> putline;
              makepatterns; 
          if);
          newline;
          (if BobsFileName.length<>0 then
              'Generating bobsinput:' -> putline;
              bobsFile.OpenWrite;
              makebobs;
              BobsFile.Close;
          if);
          'done.' -> putline;
          1 -> frag.modificationStatus;
          frag.markAsChanged;
          frag.close;
       #);
     checkForm: 
       (# f: ^fragmentForm
       enter f[]
       do (if f.grammar[]=mg[] then 
              (if f.modificationStatus=0 then
                  'Generating file for fragment:\n  ' -> screen.putText;
                  f.fullName -> screen.putText;
                  screen.newLine;
                  (if f.root[]=none then 'f.root is none'->putline if);
                  f[] -> generateFragment
               else 
                  f.fullName -> screen.putText;
                  ' has been checked.' -> screen.putLine;
              if);
              fullNameOfGrammar[] -> expandToFullPath -> fullNameOfGrammar[];
              'cfl.bet' -> (fullNameOfGrammar.copy).append -> cflFileName[] 
                -> cflFile.name;
              '-parser.bobs' -> (fullNameOfGrammar.copy).append -> bobsFileName[]
                -> bobsFile.name;
          if)
       #);
     checkGroup: 
       (# g: ^fragmentGroup
       enter g[]
       do g.fragmentList.scan
          (# 
          do current.open;
             (if current.f.type
              // groupType then current.f[] -> checkGroup
              // formType then 
                 'cfl.bet' -> (fullNameOfGrammar.copy).append 
                   -> cflFileName[] -> cflFile.name;
                 (if make_traverse then
                     'traverse.bet' -> (fullNameOfGrammar.copy).append 
                       -> traverseFileName[] -> traverseFile.name;
                     'traversebody.bet' -> (fullNameOfGrammar.copy).append 
                       -> traverseBodyFileName[] -> traverseBodyFile.name;
                 if);
                 '-parser.bobs' -> (current.name.copy).append 
                   -> bobsFileName[] -> bobsFile.name;
                 current.f[] -> checkForm;
             if);
          #);
          g.markAsChanged;
       #);
     g,metaGroup: ^fragmentGroup;
     bg,bgm: ^fragmentGroup;
     grammarWithPath,fullGrammarPath,fullMetaGrammarPath,T: ^Text;
     argposn: @integer;
     ARG: ^text;
     metaGramPlace: ^text;
     generateVisitor: @boolean (* OLM: 03/04/2003 - addedgeneration
                        * of visitor pattern to makepat
                        *)
  do 2 -> argposn;
     '~beta/grammars/metagram/metagrammar' -> metaGramPlace[];
     'Generator using Yggdrasil ' -> screen.putText;
     YggdrasilVersion -> screen.putText;
     (* Fetch name of grammar to be processed *)
     
     L: (if argposn <= NoOfArguments then
            argposn -> arguments -> ARG[];
            (if true
             // '-metagram' -> ARG.equal then
                argposn + 1 -> arguments -> metaGramPlace[];
                argposn + 2 -> argposn;
                restart L
             // '-visitor' -> ARG.equal then
                true -> generateVisitor;
                argposn + 1 -> argposn;
                restart L
            if)
        if);
     true -> generateVisitor; (* OBS! We always assume that Visitor
                               * interface is generated
                               *)
     (if NoOfArguments >= argposn then
         argposn -> arguments -> fullNameOfGrammar[]
      else
         screen.newLine;
         'Grammar? ' -> screen.putText;
         keyBoard.getAtom -> fullNameOfGrammar[];
     if);
     astlevelInit;
     (* set possible mps switches *)
     (for i: noOfArguments-argposn repeat
          i+argposn->arguments->T[]; 0->T.setPos;
          (T.getint,true)->trace.set
     for);
     (* initialize metagrammar *)
     mg.init;
     mg[] -> grammarTable.meta[];
     metaGramPlace[]
       -> grammarWithPath[]
       -> expandToFullPath
       -> fullMetaGrammarPath[];
     (* initialize parse tables for metagrammar *)
     '-parser' -> fullMetaGrammarPath.append;
     parserFileExtension -> fullMetaGrammarPath.append;
     fullMetaGrammarPath[] -> mg.parser.initialize;
     (* test if the grammar to be processed is the metagrammar *)
     fullNameOfGrammar[]->expandToFullPath->fullGrammarPath[];
     (* Does this work?  Does it even do anything? -EC *)
     (if fullGrammarPath[]->fullMetaGrammarPath.equal then
         '\n\nOBS! Grammar is the Mjolner BETA metagrammar!\n'->puttext;
         'A metagrammar bootstrap will be attempted!\n'->puttext
     if);
     (* Open '~beta/grammars/metagram/v4.4/metagrammar-meta'.
      * 
      * This open implies that the file/group:
      *  	'~beta/grammars/metagram/v4.4/metagrammar'
      * will be opened implicitly. This will succeed if either
      *  	'~beta/grammars/metagram/v4.4/metagrammar.text'
      * or
      *  	'~beta/grammars/metagram/v4.4/metagrammar.group'
      * exists. 
      * The metagrammar.text file should e.g. have the following contents:
      * 	[[-- ]]
      *)
     (grammarWithPath[],screen[])->&top.open->bg[];
     (if bg[]=none then
         '\n\nCould not open: '->screen.putText;
         grammarWithPath[]->putline;
         (failure,'')->stop;
     if);
     ('meta',screen[])->&bg.open->g[];
     (if g[]=none then
         '\n\nCould not open: '->screen.putText;
         '-meta'->(grammarWithPath.copy).append->screen.putLine;
         '\nFull path:\n\t'->puttext;
         fullMetaGrammarPath[]->putline;
         (failure,'')->stop;
     if);
     (* Open form 'metagrammar' in the metagrammar.
      * The fragment form in a metagrammar must be called 'metagrammar.
      * I.e. a metagrammar has the following structure:
      * --- metagrammar : Agrammar : metagrammar ---
      * Grammar metagrammar :
      *  ...
      *)
     ('metagrammar',screen[]) -> g.open -> mg.grammarAst[];
     (if mg.grammarAst[]=none then
         'No grammarAst for '->screen.putText;
         grammarWithPath[]->screen.putLine;
         (failure,'')->stop;
     if);
     (* Open the grammar to be processed *)
     newFragmentGroup->g[];
     fullNameOfGrammar[]->expandtofullpath->g.name;
     top.topGroup[] -> g.father;
     ('meta',screen[]) -> g.open -> grammars[];
     (if grammars[]=none then
         g.fullName -> screen.putText;
         '-meta.gram does not exist' -> screen.putText;
         (failure,'generator stops') -> &stop;
     if);
     screen.newLine;
     (if grammars.type
      // groupType then grammars[] ->checkGroup
      // formType then 
         grammars[] -> frag[];
         (if frag.grammar[]=mg[] then 
             fullNameOfGrammar[] -> expandToFullPath -> fullNameOfGrammar[];
             '-meta.pat' -> (fullNameOfGrammar.copy).append -> cflFileName[]
               -> cflFile.name;
             '-parser.bobs' -> (fullNameOfGrammar.copy).append -> bobsFileName[]
               -> bobsFile.name;
             frag[] -> generateFragment;
         if);
     if);
     g.markAsChanged;
  #)
