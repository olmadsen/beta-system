ORIGIN 'generator';
--- makepatterns: descriptor ---
(# debugPattern: (# exit false #);
   DoCheckForReservedWord: (# exit true #);
   debug:
     (#
     do (if debugpattern then 
            INNER;
            screen.newLine
        if)
     #);
   
   isBasicType:
     (# str: ^Text;
        result: @boolean;
     enter str[]
     do (if true
         //'integer' -> str.equalNCS
         //'boolean' -> str.equalNCS
         //'int32u' -> str.equalNCS
         //'int32' -> str.equalNCS
         //'int16u' -> str.equalNCS
         //'int16' -> str.equalNCS
         //'int8u' -> str.equalNCS
         //'int8' -> str.equalNCS
         //'char' -> str.equalNCS then
            true -> result;
        if);
     exit result
     #);    
   CheckForReservedWord:
     (# word: ^text;
     enter word[]
     do (if true
         // 'enter'->word.equalNCS
         // 'exit'->word.equalNCS
         // 'do'->word.equalNCS
         // 'for'->word.equalNCS
         // 'repeat'->word.equalNCS
         // 'if'->word.equalNCS
         // 'restart'->word.equalNCS
         // 'inner'->word.equalNCS
         // 'suspend'->word.equalNCS
         // 'code'->word.equalNCS
         // 'then'->word.equalNCS
         // 'else'->word.equalNCS
         // 'tos'->word.equalNCS
         // 'this'->word.equalNCS
         // 'or'->word.equalNCS
         // 'xor'->word.equalNCS
         // 'div'->word.equalNCS
         // 'mod'->word.equalNCS
         // 'and'->word.equalNCS
         // 'not'->word.equalNCS
         // 'none'->word.equalNCS
            then
            '*** Warning: In nonterminal <' -> puttext;
            word[] -> puttext;
            '>:' -> putline;
            '    \'' -> puttext; (word.copy).makeLC -> puttext; 
            '\' is a reserved BETA word.' -> putline;
            '    The generated CFL file may not compile correctly.' -> putline;
            leave CheckForReservedWord;
        if);
        (if true
         // 'integer'->word.equalNCS
         // 'shortInt'->word.equalNCS
         // 'char'->word.equalNCS
         // 'boolean'->word.equalNCS
         // 'false'->word.equalNCS
         // 'true'->word.equalNCS
         // 'real'->word.equalNCS
         // 'int8'->word.equalNCS
         // 'int8u'->word.equalNCS
         // 'int16'->word.equalNCS
         // 'int16u'->word.equalNCS
         // 'int32'->word.equalNCS
         // 'int32u'->word.equalNCS
         // 'int64'->word.equalNCS
         // 'int64u'->word.equalNCS
         // 'wchar'->word.equalNCS
         // 'COM'->word.equalNCS
         // 'Holder'->word.equalNCS     
            then
            '*** Warning: In nonterminal <' -> puttext;
            word[] -> puttext;
            '>:' -> putline;
            '    \'' -> puttext; (word.copy).makeLC -> puttext; 
            '\' is a predefined BETAENV pattern.' -> putline;
            '    The generated CFL file may not compile correctly.' -> putline;
            leave CheckForReservedWord;
        if);
     #);
   generatePatterns:  
     (# writeTraverseSlotBody:
          (# name: ^text;
          enter name[]
          do '<<SLOT ' -> traversefile.puttext;
             name[] -> traversefile.puttext;
             '_body: DoPart>>' -> traversefile.putline;
             '\n-- ' -> traversebodyfile.puttext;
             name[] -> traversebodyfile.puttext;
             '_body: DoPart --' -> traversebodyfile.putline;
          #);
        writeOption:
          (# optionName,defaultText: @text;
             lex: ^lexemText;
             optSpec: ^mg.optionSpecification;
          enter (optionName,defaultText)
          do (if (optionName -> root.optionSet -> optSpec[])=none then
                 defaultText[] -> cflFile.putText;
              else
                 (optSpec[],optionName,mg.optionName)->root.checkOption->lex[];
                 lex.getText -> cflFile.putText;
             if);
          #);
        writeSuper:
          (# ls: ^mg.LeftSide;
             found: @boolean;
             super: @integer;
             p: ^mg.prod;
          enter ls[]
          do debug
             (# 
             do 'write super. LS =' -> screen.putText;
	        ls.dump
             #);
             ls.superValue -> super;
             debug
             (# 
             do 'super =' -> screen.putText;
	        super -> screen.putInt;
             #);
             (if super>=0 then
                 super -> pl.get -> p[];
	         p.getSynDeclText -> cflFile.putText;
              else
                 'cons' -> cflFile.puttext;
             if); 
          #);
        writeSlot:
          (# pr: ^mg.prod; nl: @boolean
          enter(pr[],nl)
          do (if pr.getson1 -> attributesSet then
                 (if nl then cflFile.indent; if);
                 '<<SLOT ' -> cflFile.putText;
                 pr.getSynDeclText -> cflFile.putText;
                 'Attributes:attributes>>; ' -> cflFile.puttext;
                 (if nl then cflFile.newline; if)
             if); 
          #);
        writeAccept:
          (# n: ^text
          enter n[]
          do cflFile.indent;
             'astVisitor:: treeLevelVisitor;\n' -> cflFile.puttext;
             cflFile.indent;
             'accept::< (\# do this('-> cflFile.puttext;
             n[] -> cflFile.puttext;
             ')[] -> V.visit_'-> cflFile.puttext;
             n[] -> cflFile.puttext;
             ' #\);' -> cflFile.puttext;
             cflFile.newline;
          #);
        writeLabel:
          (# prodno: @integer; nl: @boolean
          enter(prodno,nl)
          do 3 -> cflFile.indent.inc; (* dont understanf nl *)
             (if nl then cflFile.indent; if);
             'label: (\# exit ' -> cflFile.puttext;
             prodno -> cflFile.putint;
             ' #\);\n' -> cflFile.puttext;
             3 -> cflFile.indent.dec;
          #);
        writeexit: 
          (# prodno: @integer; nl: @boolean
          enter(prodno,nl)
          do (if nl then cflFile.indent; if);
             'exit ' -> cflFile.putText;
             prodno -> cflFile.putInt;
             (if nl then 
                 cflFile.newline; cflFile.indent;
              else 
                 ' ' -> cflFile.put 
             if);
             '#\);' -> cflFile.putText;
          #);
        writeAttributes:
          (# name: ^Text;
             write:
               (# decls: ^metagrammar.DeclList;
               enter decls[]
               do decls.newscan
                  (# 
                  do cflFile.indent;
                     current.dclText -> cflfile.puttext;
                     (if (current.aplText -> isBasicType) then
                         ': @' -> cflfile.puttext;
                         current.aplText -> cflfile.puttext;
                      else
                         ': ^' -> cflFile.puttext;
                         current.aplText -> cflFile.puttext;
                     if);
                     
                     ';' -> cflFile.puttext;
                     cflFile.newline;
                  #);
                  
                  cflfile.indent;
                  'pack::<' -> cflfile.puttext;
                  cflfile.newline;
                  2 -> cflfile.indent.inc;
                  cflfile.indent;
                  '(#' -> cflfile.puttext;
                      cflfile.newline;
                      cflfile.indent;
                      'do ' -> cflfile.puttext;
                      3 -> cflfile.indent.inc;
                      
                      decls.newscan
                      (# 
                         nl: @boolean;
                      do (if nl then
                             cflfile.newline;
                             cflFile.indent;
                         if);
                         current.dclText -> cflfile.puttext;
                         (if current.aplText -> isBasicType then
                             ' -> putValue' -> cflfile.puttext;
                          else
                             '[] -> putAstRef' -> cflFile.puttext;
                         if);
                         
                         ';' -> cflFile.puttext;
                         true -> nl;
                      #);
                      cflfile.newline;
                      cflFile.indent;
                      'INNER;' -> cflFile.puttext;
                      3 -> cflFile.indent.dec;
                      cflFile.newline;
                      cflFile.indent;
                      '#);' -> cflFile.puttext;
                  2 -> cflFile.indent.dec;
                  cflfile.newline;
                  
                  cflfile.indent;
                  'unPack::<' -> cflfile.puttext;
                  cflfile.newline;
                  2 -> cflfile.indent.inc;
                  cflfile.indent;
                  '(#' -> cflfile.puttext;
                      cflfile.newline;
                      cflfile.indent;
                      'do ' -> cflfile.puttext;
                      3 -> cflfile.indent.inc;
                      
                      decls.newscan
                      (# nl: @boolean;
                      do (if nl then
                             cflfile.newline;
                             cflFile.indent;
                         if);
                         
                         (if current.aplText -> isBasicType then
                             'getValue -> ' -> cflfile.puttext;
                             current.dclText -> cflfile.puttext;
                          else
                             'getAstRef -> ' -> cflFile.puttext;
                             current.dclText -> cflfile.puttext;
                             '[]' -> cflfile.puttext;
                         if);
                         
                         ';' -> cflFile.puttext;
                         true -> nl;
                      #);
                      cflfile.newline;
                      cflFile.indent;
                      'INNER;' -> cflFile.puttext;
                      3 -> cflFile.indent.dec;
                      cflFile.newline;
                      cflFile.indent;
                      '#);' -> cflFile.puttext;
                  2 -> cflFile.indent.dec;
                  cflfile.newline;
               #);
          enter name[]
          do (if attlist[] <> NONE then
                 attlist.newscan
                 (# complex: ^metagrammar.ComplexAttrib;
                    theSynCat: ^metagrammar.SynCat;
                    theSynName: ^metagrammar.SynName;
                    theNameAppl: ^NameAppl;
                 do (if current.symbol = mg.ComplexAttrib then
                        current[] -> complex[];
                        complex.getSynCat -> theSynCat[];
                        theSynCat.getSynName -> theSynName[];
                        theSynName.getNameAppl -> theNameAppl[];
                        (if theNameAppl.getText -> name.equalNcs then
                            complex.getDeclList -> write;
                        if);
                    if);
                 #);
             if);
          #);
        writeexitThis: 
          (# name: ^text; nl: @boolean
          enter(name[],nl)
          do (if nl then cflFile.indent; if);
             'exit this(' -> cflFile.putText;
             name[]-> cflFile.puttext;
             ')[]' -> cflFile.putText;
             (if nl then 
                 cflFile.newline; cflFile.indent;
              else 
                 ' ' -> cflFile.put 
             if);
             '#\);' -> cflFile.putText;
          #);
        generateAlternation:  
          (# al: ^mg.alternation;
             name: ^text;
             initial: @char;
             generateAlternatives:
               (# alternatives: ^mg.syncatlist;
               enter alternatives[]
               do (if make_traverse then
                      alternatives.newscan
                      (# sc: ^mg.syncat;
                         sn: ^mg.synname;
                         n: ^text;
                         pr: ^mg.prod;
                      do current[] -> sc[];
                         sc.getsynname -> sn[];
                         sn.dclRefProd -> pr[];
                         (if pr.symbol=mg.alternation then
                             traversebodyfile.indent;
                             '   (\* sub-alternation <'
                               -> traversebodyfile.puttext;
                             sc.getsyntext -> traversebodyfile.puttext;
                             '>: *\)' -> traversebodyfile.putline;
                             (# al: ^mg.alternation;
                             do pr[] -> al[];
                                al.getsyncatlist -> generateAlternatives;
                             #);
                             traversebodyfile.indent;
                             '   (\* End sub-alternation <'
                               -> traversebodyfile.puttext;
                             sc.getsyntext -> traversebodyfile.puttext;
                             '> *\)' -> traversebodyfile.putline;
                             
                          else
                             traversebodyfile.indent;
                             '// ' -> traversebodyfile.puttext;
                             fullNameOfGrammar[] -> traversebodyfile.puttext;
                             '.' -> traversebodyfile.put;
                             current[] -> sc[];
                             sc.getsyntext -> n[] -> traversebodyfile.puttext;
                             ' then' -> traversebodyfile.putline;
                             3 -> traversebodyfile.indent.inc;
                             traversebodyfile.indent;
                             initial -> traversebodyfile.put;
                             '[] -> do_' -> traversebodyfile.puttext;
                             n[] -> traversebodyfile.puttext;
                             ';' -> traversebodyfile.putline;
                             3 -> traversebodyfile.indent.dec;
                         if);
                      #);
                  if)
               #);
          enter al[]
          do debug(# do 'begin generate alternation' -> screen.putText #);
             al[] -> printLeftSide->name[]; 
             al.getLeftSide -> writeSuper;
             cflFile.newline;
             2 -> cflFile.indent.inc;
             cflFile.indent;
             '(\# ' -> cflFile.putText;
             cflFile.newline;
             3 -> cflFile.indent.inc;
             name[] -> writeAttributes;
             3 -> cflFile.indent.dec;
             cflFile.indent;
             (al[],false) -> writeSlot;
             '\#);' -> cflFile.puttext;
             2 -> cflFile.indent.dec;
             (if make_traverse then
                 ('do_' -> (name.copy).prepend, 'alternation') 
                   -> traversefile.patbegin;
                 1 -> name.inxget -> initial -> traversefile.put;
                 ': ^' -> traversefile.puttext;
                 fullNameOfGrammar[] -> traversefile.puttext;
                 '.' -> traversefile.put;
                 name[] -> traversefile.putline;
                 3 -> traversefile.indent.dec;
                 traversefile.indent;
                 'enter '->traversefile.puttext;
                 initial -> traversefile.put;
                 '[]' -> traversefile.putline;
                 traversefile.indent;
                 'do_' -> (name.copy).prepend -> writeTraverseSlotBody;
                 3 -> traversefile.indent.inc;
                 traversefile.patend;
                 
                 'do (\if '->traversebodyfile.puttext;
                 initial -> traversebodyfile.put;
                 '.symbol' -> traversebodyfile.putline;
                 3+1 -> traversebodyfile.indent.inc;
                 al.getsyncatlist -> generateAlternatives;
                 traversebodyfile.indent;
                 'if\);' -> traversebodyfile.putline;
                 3+1 -> traversebodyfile.indent.dec;
                 
             if);
             debug(# do 'end generate alternation' -> screen.putText #);
          #);
        generateOptional:
          (# o: ^mg.Opt;
             sc: ^mg.SynCat;
             name, syn: ^text;
          enter o[]
          do (if make_traverse then
                 (o.getSynCat->sc[]).getSynText -> syn[];
                 o.getSynDeclText -> name[];
                 ('do_' -> (name.copy).prepend, 'optional') 
                   -> traversefile.patbegin;
                 'a: ^astinterface.ast;' -> traversefile.putline;
                 3 -> traversefile.indent.dec;
                 traversefile.indent;
                 'enter a[]'->traversefile.putline;
                 traversefile.indent;
                 'do_' -> (name.copy).prepend -> writeTraverseSlotBody;
                 3 -> traversefile.indent.inc;
                 traversefile.patend;

                 'do (\if a.kind<>ast.kinds.optional then'
                   -> traversebodyfile.putline;
                 3+4 -> traversebodyfile.indent.inc;
                 traversebodyfile.indent;
                 'a[] -> do_' -> traversebodyfile.puttext;
                 syn[] -> traversebodyfile.puttext;
                 ';' -> traversebodyfile.putline;
                 4 -> traversebodyfile.indent.dec;
                 traversebodyfile.indent;
                 'if\);' -> traversebodyfile.putline;
                 3 -> traversebodyfile.indent.dec;
             if);
          #);
        generateConstructor:  
          (# c: ^mg.constructor;
             clist: ^mg.consElemList;
             idx: @integer;
             name: ^text;
             initial: @char;
             first_done, traverse_first_done: @boolean;
             check_first:
               (#
               do (if first_done then
                      cflFile.indent;
                   else
                      true -> first_done;
                  if);
               #);
          enter c[]
          do c[] -> printLeftside -> name[];
             (if make_traverse then
                 false->traverse_first_done;
                 ('do_' -> (name.copy).prepend, 'cons') 
                   -> traversefile.patbegin;
                 1 -> name.inxget -> initial -> traversefile.put;
                 ': ^' -> traversefile.puttext;
                 fullNameOfGrammar[] -> traversefile.puttext;
                 '.' -> traversefile.put;
                 name[] -> traversefile.putline;
                 3 -> traversefile.indent.dec;
                 traversefile.indent;
                 'enter '->traversefile.puttext;
                 initial -> traversefile.put;
                 '[]' -> traversefile.putline;
                 traversefile.indent;
                 'do_' -> (name.copy).prepend -> writeTraverseSlotBody;
                 3 -> traversefile.indent.inc;
                 traversefile.patend;
             if);
             c.getLeftSide -> writesuper;
             0 -> idx;
             cflFile.newline;
             2 -> cflFile.indent.inc;
             cflFile.indent;
             '(\# ' -> cflFile.puttext; 
             3 -> cflFile.indent.inc;
             c.getConsElemList -> clist[];
             false -> first_done;
             clist.newScan
               (# ts: ^mg.TaggedSyn;
                  sc: ^mg.synCat;
                  n : ^text;
                  tn: ^mg.TagName;
                  sn: ^mg.SynName;
               do (if current.symbol
                   // mg.TaggedSyn then 
                      idx+1 -> idx;
                      current[] -> ts[];
                      check_first;
                      'get' -> cflFile.puttext;
                      ts.getTagText -> n[] -> cflFile.puttext;
                      ': getson' -> cflFile.puttext;
                      idx -> cflFile.putInt;
                      '(\# #\);' -> cflFile.putline;
                      cflFile.indent;
                      'put' -> cflFile.puttext;
                      n[] -> cflFile.puttext;
                      ': putson' -> cflFile.puttext;
                      idx -> cflFile.putInt;
                      '(\# #\);\n' -> cflFile.puttext;
                      (if make_traverse then
                          (if traverse_first_done then
                              traversebodyfile.indent;
                           else
                              'do ' -> traversebodyfile.puttext;
                              3 -> traversebodyfile.indent.inc;
                              true -> traverse_first_done;
                          if);
                          initial -> traversebodyfile.put;
                          '.get' -> traversebodyfile.puttext;
                          n[] -> traversebodyfile.puttext;
                          ' -> do_' -> traversebodyfile.puttext;
                          ts.getSynText -> traversebodyfile.puttext;
                          ';' -> traversebodyfile.putline;
                      if);
                   // mg.Syncat then
                      current[] -> sc[];
                      idx+1 -> idx;
                      check_first;
                      'get' -> cflFile.puttext;
                      sc.getSynText -> n[] -> cflFile.puttext;
                      ': getson' -> cflFile.puttext;
                      idx -> cflFile.putInt;
                      '(\# #\);' -> cflFile.putline;
                      cflFile.indent;
                      'put' -> cflFile.puttext;
                      n[] -> cflFile.puttext;
                      ': putson' -> cflFile.puttext;
                      idx -> cflFile.putInt;
                      '(\# #\);\n' -> cflFile.puttext; 
                      (if make_traverse then
                          (if traverse_first_done then
                              traversebodyfile.indent;
                           else
                              'do ' -> traversebodyfile.puttext;
                              3 -> traversebodyfile.indent.inc;
                              true->traverse_first_done;
                          if);
                          initial -> traversebodyfile.put;
                          '.get' -> traversebodyfile.puttext;
                          n[] -> traversebodyfile.puttext;
                          ' -> do_' -> traversebodyfile.puttext;
                          n[] -> traversebodyfile.puttext;
                          ';' -> traversebodyfile.putline;
                      if);
                  if);
               #);
             (if generateVisitor then  name[] -> writeAccept if);
             (if true then
                 name[] -> writeAttributes;
             if);
             (c[],first_done) -> writeSlot;
             3 -> cflFile.indent.dec;
             (if false then
                 (prodIdx,true) -> writeLabel
             if);
             
             
             (if false then
                 (* generate exit this(cat)[] *)
                 (name[],first_done) -> writeexitthis
              else
                 (prodIdx,first_done) -> writeexit;
             if);
             2 -> cflFile.indent.dec;
             (if make_traverse then
                 (if traverse_first_done then 
                     3 -> traversebodyfile.indent.dec;
                  else
                     'do ' -> traversebodyfile.putline;
                 if);
             if);
          #);
        printLeftSide:  
          (# pr: ^mg.prod;
             ls: ^mg.LeftSide;
             sn: ^mg.SynDeclName;
             n: ^text;
          enter pr[]
          do cflFile.indent;
             pr.getSynDeclText -> n[] -> cflFile.putText;
             ': ' -> cflFile.putText;
          exit n[]
          #);
        generateList:  
          (# l: ^mg.lst;
             sc: ^mg.synCat;
	     prod: ^mg.prod;
	     sn: ^mg.synName;
             name, syn: ^text;
             initial: @char;
          enter l[]
          do l[] -> printLeftSide -> name[];
             'list' -> cflFile.putline;
             2 -> cflFile.indent.inc;
             cflFile.indent;
             '(\# soncat::< ' -> cflFile.puttext;
             l.getSon2 -> sc[];
	     sc.getSynName -> sn[];
	     l: (#
	        do sn.dclRefProd
                     (# predefined::<
                          (# 
                          do 'lexem' -> syn[] -> cflFile.putText;
                             ';' -> cflFile.putline;
                             leave l;
                          #)
                     #) -> prod[];
                   (if prod.symbol=mg.opt then
                       prod.getSon2 -> sc[];
                   if);
                   sc.getSynText -> syn[] -> cflFile.putText;
                   ';' -> cflFile.putline; (* a slot may later be generated *)
                #);
             (l[],true) -> writeSlot;
             (if false then
                 (prodIdx,true) -> writeLabel
             if);

             (if false then (* see cons *)
                 (name[],true) -> writeexitthis                 
              else
                 (prodIdx,true)-> writeexit
             if);
             2 -> cflFile.indent.dec;
             (if make_traverse then 
                 ('do_' -> (name.copy).prepend, 'list') 
                   -> traversefile.patbegin;
                 1 -> name.inxget -> initial -> traversefile.put;
                 ': ^' -> traversefile.puttext;
                 fullNameOfGrammar[] -> traversefile.puttext;
                 '.' -> traversefile.put;
                 name[] -> traversefile.putline;
                 3 -> traversefile.indent.dec;
                 traversefile.indent;
                 'enter '->traversefile.puttext;
                 initial -> traversefile.put;
                 '[]' -> traversefile.putline;
                 traversefile.indent;
                 'do_' -> (name.copy).prepend -> writeTraverseSlotBody;
                 3 -> traversefile.indent.inc;
                 traversefile.patend;

                 'do '->traversebodyfile.puttext;
                 initial -> traversebodyfile.put;
                 '.newscan' -> traversebodyfile.putline;
                 3 -> traversebodyfile.indent.inc;
                 traversebodyfile.indent;
                 '(\#' -> traversebodyfile.putline;
                 traversebodyfile.indent;
                 'do current[] -> do_' -> traversebodyfile.puttext;
                 syn[] -> traversebodyfile.puttext;
                 ';' -> traversebodyfile.putline;
                 traversebodyfile.indent;
                 '#\);' -> traversebodyfile.putline;
                 3 -> traversebodyfile.indent.dec;
             if);
          #);
        attributesSet: 
          (# ls: ^mg.LeftSide;
             extra: @integer;
             att: ^mg.Attrib;
             n: ^text;
             extraSet: @boolean;
          enter ls[]
          do false -> extraSet;
             ls.getSynDeclText -> n[];
             (if attlist[]<>none then
                 l: attlist.newscan
                   (# sc: ^mg.synCat;
                      simple: ^metagrammar.SimpleAttrib;
                   do (if current.symbol
                       //mg.SimpleAttrib then
                          current[] -> simple[];
                          simple.getSynCat -> sc[];
                          (if sc.getSynText -> n.equalNCS then
                              true -> extraSet; leave l
                          if);
                      if);
                   #);
             if);
          exit extraSet
          #);
        generateGrammarName:
          (# t: @text
          do cflFile.newline;
             cflFile.indent;
             'grammarIdentification::<' -> cflFile.putline;
             cflFile.indent;
             '  (\# do \'' -> cflFile.putText;
             gnNameDecl.getText -> cflFile.putText;
             '\' -> theGrammarName #\);' -> cflFile.putline;
             cflFile.indent;
             'version::<' -> cflFile.putline;
             cflfile.indent;
             '  (\# do ' -> cflFile.putText;
             ('version',undefinedVersion) -> root.getOptionValue -> cflFile.putInt;
             ' -> value #\);' -> cflFile.putLine;
             cflfile.indent;
             'suffix::<' -> cflfile.putline;
             cflFile.indent;
             '  (\# do \'' -> cflFile.putText;
             ('suffix','.text') -> root.getOptionString -> t;
             t[] -> cflFile.putText;
             '\' -> theSuffix #\);' -> cflFile.putLine;
             cflfile.indent;
             'maxproductions::<' -> cflfile.putline;
             cflfile.indent;
             '  (\# do ' -> cflFile.putText;
             pl.noOfSons -> cflFile.putInt;
             ' -> value #\);' -> cflFile.putLine;
             (if ('substanceSlot' -> root.optionSet)<>none then
                 (('substanceSlot','cflAtt') -> root.getOptionName) -> t;
                 cflfile.indent;
                 t[]-> cflFile.putText;
                 ': @<<SLOT ' -> cflFile.putText;
                 t[] -> cflFile.putText;
                 ': descriptor>>;\n' -> cflFile.putLine;
             if);
          #);
   generateVisitorInterface:
     (# genConsVisitor:
          (# C: ^mg.constructor;
             n: ^text;
          enter C[]
          do cflFile.indent;
             C.getSynDeclText -> n[];
             'visit_' -> cflFile.puttext;
             n[] -> cflFile.puttext;
             ':<\n' -> cflFile.puttext;
             2 -> cflFile.indent.inc;
             cflFile.indent;
             '(\# N: ^' -> cflFile.puttext;
             catName[] -> cflFile.puttext;
             '.'->cflFile.put;
             n[] -> cflFile.puttext;
             cflFile.newline;
             cflFile.indent;
             'enter N[]' -> cflFile.puttext;
             cflFile.newline;
             cflFile.indent;
             'do INNER' -> cflFile.puttext;
             cflFile.newline;
             cflFile.indent;
             '#\);' -> cflFile.putline;
             2 -> cflFile.indent.dec;
          #);
     do cflFile.newline;
        cflFile.indent;
        'treeLevelVisitor:: ' -> cflFile.puttext;
        2 -> cflFile.indent.inc;
        cflFile.newline;
        cflFile.indent;
        '(\# ' -> cflFile.puttext;
        cflFile.newline;
        3 -> cflFile.indent.inc;
        pl.scan
        (#
        do (if current.symbol
            // mg.Alternation then
            // mg.Constructor then 
               current[] -> genConsVisitor;
            // mg.Opt then                
            // mg.ListOne
            // mg.ListZero then                
           if);
        #);
        3 -> cflFile.indent.dec;
        cflFile.indent;
        '#\);' ->  cflFile.puttext;
        2 -> cflFile.indent.dec;
        cflFile.newline;        
     #);
        generateInit:
          (#  
          do debug(# do 'generating init' -> screen.putText; #);
             cflFile.newline;
             cflfile.indent;
             'init::<' -> cflfile.putline;
             cflfile.indent;
             '  (\# <<SLOT InitBody:dopart>> #\);' 
               -> cflFile.putLine;
          #);
        generateInitBody:
          (# compExtra: 
               (# ls: ^mg.LeftSide;
                  extra: @integer;
                  sc: ^mg.synCat;
                  NoAtt: ^mg.NoOfAttributes;
                  n: ^text;
                  c: ^Const;
               enter ls[]
               do ls.getSynDeclText -> tosmall -> n[];
                  0 -> extra;
                  (if attlist[]<>none then
                      l: attlist.newscan
                        (# simple: ^metagrammar.SimpleAttrib;
                        do (if current.symbol
                            //mg.SimpleAttrib then
                               current[] -> simple[];
                               simple.getSyncat -> sc[];
                               (if sc.getSynText -> n.equalNCS then
                                   simple.getNoOfAttributes -> NoAtt[];
                                   NoAtt.getConst -> c[];
                                   c.getValue -> Extra;
                                   leave l
                               if);
                           if);
                        #);
                  if);
               exit extra
               #);
             genProd:
               (# prodNo,type,extra,sons: @integer;
               enter (prodNo,type,sons,extra)
               do '   ' -> cflFile.putText;
                  type -> cflFile.putInt;
                  ' -> kindArray[' -> cflFile.putText;
                  prodNo -> cflFile.putInt;
                  ']; ' -> cflFile.putText;
                  2 * ((extra+1) div 2) -> cflFile.putInt;
                  ' -> roomArray[' -> cflFile.putText;
                  prodNo -> cflFile.putInt;
                  ']; ' -> cflFile.putText;
                  sons -> cflFile.putInt;
                  ' -> sonArray[' -> cflFile.putText;
                  prodNo -> cflFile.putInt;
                  ']; ' -> cflFile.putText;
                  cflFile.newLine;
               #);
             genRefGen:
               (# prodNo: @integer;
                  AstCatName: ^text;
               enter (prodNo,astCatName[])
               do '   ' -> cflFile.putText;
                  astCatName[] -> cflFile.putText;
                  '## -> genRefArray[' -> cflFile.putText;
                  prodNo -> cflFile.putInt;
                  ']##;\n' -> cflFile.putText;
               #);
          do debug(# do 'generating init body' -> screen.putText; #);
             '--InitBody:dopart--\ndo\n' -> cflFile.putText;
             pl.newscan
               (# co: ^mg.Constructor;
                  clist: ^mg.ConsElemList;
                  NuOfSCSons: @integer;
               do (if current.symbol
                   //mg.opt then  
                      (currentSonNo,kinds.optional,0,1) -> genProd;
                      (currentSonNo,'Optional') -> genRefGen
                   //mg.alternation then 
                      (currentSonNo,kinds.UnExpanded,0,1) -> genProd;
                      (currentSonNo,'unExpanded') -> genRefGen
                   //mg.constructor then
                      current[] -> co[];
                      co.getConsElemList -> clist[];
                      0 -> NuOfSCSons;
                      clist.scan
                      (# 
                      do (if current.symbol<>mg.term then
                             NuOfSCSons + 1 -> NuOfSCSons 
                         if) 
                      #);
                      (currentSonNo, kinds.interior, NuOfSCSons, current.LeftSide -> compExtra) 
                        -> genProd;
                      (currentSonNo, current.getSynDeclText) -> genRefGen
                   //mg.ListOne//mg.ListZero then
                      (currentSonNo, kinds.interior, 0, current.leftSide -> compExtra) -> genProd; 
                      (currentSonNo, current.getSynDeclText) -> genRefGen
                  if);
               #);
          #);
        genHeadForm:
          (# formNo: @integer;
             originName,catName,subName,grammarpath: ^text;
          enter (formNo,originName[],catName[],subName[])
          do 0 -> cflFile.indent.set;
             'ORIGIN \'' -> cflFile.putText;
             originName[] -> cflFile.putText;
             '\'' -> cflFile.put;
             (if false (*generateVisitor*) then
                 '\n--lib: attributes--\n' -> cflFile.putText;
                 'cflLevel: astinterface\n' -> cflFile.puttext;
                 2 -> cflFile.indent.inc;
                 cflFile.indent;
                 '(\# ' -> cflFile.puttext;
                 '<<SLOT cfllevelLib:attributes>>;' -> cflFile.putline;
                 3 -> cflFile.indent.inc;
                 cflFile.indent;
              else
                 '\n--astInterfaceLib: attributes--\n\n' -> cflFile.putText;
             if);
             catName[] -> cflFile.putText;
             ': ' -> cflFile.puttext; 
             subName[] -> cflFile.putText;
             cflFile.newline;
             2 -> cflFile.indent.inc;
             cflFile.indent;
             '(\# <<SLOT ' -> cflFile.puttext;
             catName[] -> cflFile.puttext;
             'Attributes:attributes>>;' -> cflFile.putline;
             3 -> cflFile.indent.inc;
             (if make_traverse then
                 (if formNo=1 then
                     0 -> traversefile.indent.set;
                     'ORIGIN \'' -> traversefile.putText;
                     'cfl' -> (fullNameOfGrammar.copy).append 
                       -> traversefile.puttext;
                     '\';' -> traversefile.putline;
                     'BODY \'' -> traversefile.putText;
                     'traversebody' -> (fullNameOfGrammar.copy).append 
                       -> traversefile.puttext;
                     '\';' -> traversefile.putline;
                     traversefile.newline;
                     '(\* Skeleton file for traversal of ASTs based on\n'
                     ' \* grammar \'' -> traversefile.puttext;
                     fullNameOfGrammar[] -> traversefile.puttext;
                     '\'.\n' -> traversefile.puttext;
                     ' \* Take a copy of this file and fill out the do-parts.\n'
                     ' \* Do NOT edit this file directly as it will be overwritten\n'
                     ' \* when the grammar is processed again.\n'
                     ' \*\)\n' -> traversefile.puttext;
                     '--LIB: attributes--\n\n' 
                       -> traverseFile.putText;
                     ('_traverse' -> (fullNameOfGrammar.copy).append, none)
                       -> traversefile.patbegin;
                     'ast: @astInterface (* An instance of the AST interface *);' 
                       -> traversefile.putline;
                     traversefile.indent;
                     fullNameOfGrammar[] -> traversefile.puttext;
                     ': @ast.' -> traversefile.puttext;
                     fullNameOfGrammar[] -> traversefile.puttext;
                     ';\n\n' -> traversefile.puttext;
                     
                     0 -> traversebodyfile.indent.set;
                     'ORIGIN \'' -> traversebodyfile.putText;
                     'traverse' -> (fullNameOfGrammar.copy).append 
                       -> traversebodyfile.puttext;
                     '\';' -> traversebodyfile.putline;
                     traversebodyfile.newline;
                     '--LIB: attributes--\n\n' 
                       -> traversebodyfile.putText;
                     fullNameOfGrammar.copy
                       -> expandToFullPath
                       -> grammarpath[];
                     (grammarpath[],'~beta') -> thePathHandler.localpath 
                       -> grammarpath[];
                     'GrammarPath: (\# exit \'' -> traversebodyfile.puttext;
                     grammarpath[] -> traversebodyfile.puttext;
                     '\' #\);' -> traversebodyfile.putline;
                     'BobsTab:     (\# exit \'' -> traversebodyfile.puttext;
                     grammarpath[] -> traversebodyfile.puttext;
                     '-parser.btab' -> traversebodyfile.puttext;
                     '\' #\);' -> traversebodyfile.putline;
                     traversebodyfile.indent;
                     
                 if);
             if);
          #);
        genTailForm:
          (# postFormName: @text;
             formNo: @integer;
             suffix: @text;
             traverse_first_done: @boolean;
             optionstring: @text;
             check_indent:
               (# 
               do (if make_traverse then
                      (if traverse_first_done then
                          traversebodyfile.indent;
                       else
                          true -> traverse_first_done;
                      if);
                  if);
               #);
             generatePredefined:
               (# name: ^text;
                  initial: @char;
                  genvalue: @boolean;
               enter (name[], genvalue)
               do (if make_traverse then
                      (name,'used')->root.getOptionName
                        -> optionstring;
                      (if 'unused' -> optionstring.equalNCS then
                          traversefile.indent;
                          traversefile.commentbegin;
                          'do_' -> traversefile.puttext;
                          name[] -> traversefile.puttext;
                          ': Lexem <' -> traversefile.puttext;
                          name[] -> traversefile.puttext;
                          '> is unused' -> traversefile.puttext;
                          traversefile.commentend;
                          traversefile.newline;
                      else
                          ('do_'->(name.copy).prepend, 'lexem') 
                            -> traversefile.patbegin;
                          1 -> name.inxget -> initial -> traversefile.put;
                          ': ^astinterface.' -> traversefile.puttext;
                          name[] -> traversefile.puttext;
                          ';' ->traversefile.putline;
                          traversefile.indent;
                          'getText: (\# exit ' -> traversefile.puttext;
                          initial -> traversefile.put;
                          '.getText #\);' -> traversefile.putline;
                          (if genvalue then
                              traversefile.indent;
                              'getValue: (\# exit ' ->traversefile.puttext;
                              initial -> traversefile.put;
                              '.getValue #\);' ->traversefile.putline;
                          if);
                          3 -> traversefile.indent.dec;
                          traversefile.indent;
                          'enter ' -> traversefile.puttext;
                          initial -> traversefile.put;
                          '[] ' -> traversefile.putline;
                          traversefile.indent;
                          'do INNER;' -> traversefile.putline;
                          3 -> traversefile.indent.inc;                 
                          traversefile.patend;
                      if);
                  if);
               #);
          enter (formNo,postFormName)
          do debug(# do 'genTailForm' -> screen.putText #);
             (if make_traverse then
                 (if formNo=NoOfFiles then
                     traversefile.newline;
                     (* Generate pats for nameDecl, nameAppl, const, string *)
                     ('nameDecl',false) -> generatePredefined;
                     ('nameAppl',false) -> generatePredefined;
                     ('const',true) -> generatePredefined;
                     ('string',false) -> generatePredefined;
                     
                     ('init', 'Initialization of astLevel and parser') 
                       -> traversefile.patbegin;
                     traversefile.newline;
                     3 -> traversefile.indent.dec;
                     traversefile.indent;
                     '_init' -> (fullNameOfGrammar.copy).append
                       -> writeTraverseSlotBody;
                     3 -> traversefile.indent.inc;
                     traversefile.patend;
                     
                     'do ast.astLevelInit;' 
                       -> traversebodyfile.putline; 
                     3 -> traversebodyfile.indent.inc;
                     traversebodyfile.indent;
                     '(* Alternative to using findGrammar: *)' 
                       -> traversebodyfile.putline; traversebodyfile.indent;
                     '(\'' -> traversebodyfile.puttext;
                     fullNameOfGrammar[] -> traversebodyfile.puttext;
                     '\', \'' -> traversebodyfile.puttext;
                     ('suffix',fullNameOfGrammar) -> root.getOptionString 
                       -> suffix;
                     suffix[] -> traversebodyfile.puttext;
                     '\', GrammarPath->ast.expandToFullPath)' 
                       -> traversebodyfile.putline;
                     traversebodyfile.indent;
                     '  -> ast.registergrammar;' -> traversebodyfile.putline;
                     traversebodyfile.indent;
                     fullNameOfGrammar[] -> traversebodyfile.puttext;
                     '.init; ' -> traversebodyfile.putline;
                     traversebodyfile.indent;
                     'BobsTab -> ast.expandToFullPath -> '
                       -> traversebodyfile.puttext;
                     fullNameOfGrammar[] -> traversebodyfile.puttext;
                     '.parser.initialize' -> traversebodyfile.putline;
                     traversebodyfile.indent;
                     '(\# ' -> traversebodyfile.puttext;
                     3 -> traversebodyfile.indent.inc;
                     ('dashKeywords','false')->root.getOptionName
                       -> optionstring;
                     (if 'true' -> optionstring.equalNCS then
                         check_indent;
                         'dashNames::(\# do true->value #\);' 
                           -> traversebodyfile.putline;
                     if);
                     ('caseSensitive','false')->root.getOptionName
                       -> optionstring;
                     (if 'true' -> optionstring.equalNCS then
                         check_indent;
                         'caseSensitive::(\# do true->value #\);' 
                           -> traversebodyfile.putline;
                     if);
                     ('EOLasComEnd','false')->root.getOptionName
                       -> optionstring;
                     (if 'true' -> optionstring.equalNCS then
                         check_indent;
                         'EOLasComEnd::(\# do true->value #\);' 
                           -> traversebodyfile.putline;
                     if);
                     ('splitString','false')->root.getOptionName
                       -> optionstring;
                     (if 'true' -> optionstring.equalNCS then
                         check_indent;
                         'SplitString::(\# do true->value #\);' 
                           -> traversebodyfile.putline;
                     if);
                     (* FIXME: set the other boolean virtuals too:
                      *  isEOS
                      *  longLexems
                      *)
                     3 -> traversebodyfile.indent.dec;
                     (if traverse_first_done then
                         traversebodyfile.indent;
                     if);
                     traversebodyfile.patend;
                     
                     traversefile.patend;
                 if);
             if);
          #);
        openForm:
          (# originName, str: @text; t: ^Text;
          do formNo + 1 -> formNo;
             (if formNo = noOfFiles (* the last file *) then
                 cflFileName -> str; 
                 str[]-> cflFile.Name
              else
                 gnNameDecl.getText -> formName[];
                 formNo -> formName.putInt;
                 '.bet' 
                   -> (formName.copy).append
                   -> cflFile.name;
             if);
             (if formNo = 1 then
                 '~beta/newmps/astlevel' -> originName;
              else 
                 lastCatName -> originName;
             if);
             (if formNo=NoOfFiles then
                 gnNameDecl.getText -> t[]; t -> catName;
              else
                 gnNameDecl.gettext -> t[]; t -> catName;
                 formNo -> catName.putInt;
             if);
             cflFile.openWrite;
             'Generating ' -> screen.putText; 
             cflFile.name -> screen.putText;
             (if make_grammarfile then
                 grammarFile.openWrite;
                 'ORIGIN \'~beta/basiclib/betaenv\';' -> grammarFile.putline;
                 '-- Lib: attributes --' -> grammarFile.putline;
                 'grammar:' -> grammarFile.putline;
                 '(#' -> grammarFile.putline;
                     '   unExpanded: (# exit -1 #);' -> grammarFile.putline;
                     '   dummy: (# exit -123872634 #);' -> grammarFile.putline;
                     '   empty: (# exit -2 #);' -> grammarFile.putline;
                     grammarFile.newline;
                 pl.newscan
                 (# count: @integer;
                    
                 do count + 1 -> count;
                    '   ' -> grammarFile.puttext;
                    current.getSynDeclText -> grammarFile.puttext;
                    ': (# exit ' -> grammarFile.puttext;
                          count -> grammarFile.putint;
                          ' #);' -> grammarFile.puttext;
                    grammarFile.newline;
                 #);
                     '#)' -> grammarFile.putline;
                 grammarFile.close;
             if);
             (if make_traverse then
                 (if formNo = 1 then
                     traverseFile.openWrite;
                     traverseBodyFile.openWrite;
                     ' and '-> screen.puttext; 
                     traversefilename[] -> screen.puttext;
                     '+'->screen.put;
                     traversebodyfilename[] -> screen.puttext;
                  else
                     traverseFile.openAppend;
                     traverseBodyFile.openAppend;
                     ' and continuing traverse files.'-> screen.puttext; 
                 if)
             if);
             screen.newLine;
             (formNo,originName[],catName[],lastCatName[]) -> genHeadForm;
             catName -> lastCatName;
          #);
        closeAndReOpen:
          (#
          do 'close-and-reopen' -> putline;
             debug(# do 'close and reopen' -> screen.putText; #);
             3 -> cflFile.indent.dec;
             cflFile.indent;
             '#\);' -> cflFile.putText; cflFile.newLine;
             2 -> cflFile.indent.dec;
             gnNameDecl.gettext -> formName[];
             formNo + 1 -> formName.putInt;
             'FORM' -> formName.append;
             (formNo,formName) -> genTailForm;
             cflFile.close;
             (if make_traverse then
                 traverseFile.close;
             if);
             openForm;
          #);
        g: ^mg.Agrammar; 
        gn: ^mg.grammarName;
        gnNameDecl: ^NameDecl;
        applicationProg: @text;
        prodIdx: @integer;
        formName: ^Text;
        catName,lastCatName: @text;
        formNo: @integer;
        prodNumbersPerFile: @integer;
      enter g[]
      do debug(# do 'makepat started ' -> screen.putText #);
         ('subof','TreeLevel') -> root.getOptionName -> lastCatName;
         0 -> formNo;
         g.getGrammarName -> gn[];
         gn.getNameDecl -> gnNameDecl[];
         debug(# do 'going to open form' -> screen.putText #);
         OpenForm;
         debug(# do 'form opened' -> screen.putText #);
         (pl.noOfSons + 40) div NoOfFiles -> prodNumbersPerFile;
                 (* debug(# do 'generating alternations' -> screen.putText #);
                  *          pl.scan
                  *            (#
                  *            do (if current.symbol=mg.Alternation then
                  *                   current[] -> generateAlternation; cflFile.newLine
                  *               if);
                  *               debug(# do current.index -> screen.putInt; '       ' -> screen.putText  #);
                  *            #);
                  *          debug(# do 'finished alternation' -> screen.putText; #);
                  *          
                  *)
   0 -> prodidx;
         pl.scan
           (# pr: ^mg.prod
           do (if ((prodIdx + 1 -> prodIdx) mod prodNumbersPerFile)=0 then
                  CloseAndReOpen;
              if);
              debug
              (# do current.symbol -> screen.putInt; ' = ' -> screen.putText;
                 current.index -> screen.putInt; 
              #);
              (if DoCheckForReservedWord then
                  (current[]->pr[]).getSynDeclText -> CheckForReservedWord;
              if);
              (if current.symbol
               // mg.Alternation then
                  current[] -> generateAlternation; 
                  cflFile.newLine
               // mg.Constructor then 
                  current[] -> generateConstructor; 
                  cflFile.newLine
               // mg.Opt then 
                  current[] -> generateOptional;
               // mg.ListOne
               // mg.ListZero then 
                  current[] -> generateList; 
                  cflFile.newLine
              if);
           #);
         generateGrammarName;
         generateInit;
         (if formNo < NoOfFiles then
             CloseAndReOpen
         if);
   
         (if generateVisitor then 
             generateVisitorInterface;   
             3 -> cflFile.indent.dec;
             cflFile.indent;
             '#\);\n ' -> cflFile.putText;        
         if);
   
         applicationProg.clear;
         gnNameDecl.gettext -> applicationProg.append;
         'prog' -> applicationProg.append;
   
         ('postname',applicationProg) -> root.getOptionName -> applicationProg;
         (NoOfFiles,applicationProg) -> genTailForm;
         debug(# do cflFile.name -> screen.putText; ' closed' -> screen.putText #);
         generateInitBody;
         cflFile.close;
      #);
      NoOfFiles: @integer;
do ('splitonfiles',1) -> root.getOptionValue -> NoOfFiles;
   (if make_traverse then
       (if NoOfFiles>1 then
           'Notice: traverse files will not be split.' -> screen.putline;
       if)
   if);
   root[] -> generatePatterns;
#)
