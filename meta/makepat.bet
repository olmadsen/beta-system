ORIGIN 'generator';
--- makepatterns: descriptor ---
(# debugPattern: (# exit false #);
   debug:
     (#
     do (if debugpattern then 
            INNER;
            screen.newLine
        if)
     #);
   generatePatterns:  
     (# writeTraverseSlotBody:
          (# name: ^text;
          enter name[]
          do '<<SLOT ' -> traversefile.puttext;
             name[] -> traversefile.puttext;
             '_body: DoPart>>' -> traversefile.putline;
             '\n-- ' -> traversebodyfile.puttext;
             name[] -> traversebodyfile.puttext;
             '_body: DoPart --' -> traversebodyfile.putline;
          #);
        writeOption:
          (# optionName,defaultText: @text;
             lex: ^lexemText;
             optSpec: ^mg.optionSpecification;
          enter (optionName,defaultText)
          do (if (optionName -> root.optionSet -> optSpec[])=none then
                 defaultText[] -> genFile.putText;
              else
                 (optSpec[],optionName,mg.optionName)->root.checkOption->lex[];
                 lex.getText -> genFile.putText;
             if);
          #);
        writeSuper:
          (# ls: ^mg.LeftSide;
             found: @boolean;
             super: @integer;
             p: ^mg.prod;
          enter ls[]
          do debug
             (# 
             do 'write super. LS =' -> screen.putText;
	        ls.dump
             #);
             ls.superValue -> super;
             debug
             (# 
             do 'super =' -> screen.putText;
	        super -> screen.putInt;
             #);
             (if super>=0 then
                 super -> pl.get -> p[];
	         p.getSynDeclText -> genFile.putText;
              else
                 'cons' -> genFile.puttext;
             if); 
          #);
        writeSlot:
          (# pr: ^mg.prod; nl: @boolean
          enter(pr[],nl)
          do (if pr.getson1 -> attributesSet then
                 '<<SLOT ' -> genFile.putText;
                 pr.getSynDeclText -> genFile.putText;
                 'Attributes:attributes>> ' -> genFile.puttext;
                 (if nl then genFile.newline if)
             if); 
          #);
        writeexit: 
          (# prodno: @integer; nl: @boolean
          enter(prodno,nl)
          do 'exit ' -> genFile.putText;
             prodno -> genFile.putInt;
             (if nl then genFile.newline else ' ' -> genFile.put if);
             '#\);' -> genFile.putText;
          #);
        generateAlternation:  
          (# al: ^mg.alternation;
             name: ^text;
             initial: @char;
             generateAlternatives:
               (# alternatives: ^mg.syncatlist;
               enter alternatives[]
               do (if make_traverse then
                      alternatives.newscan
                      (# sc: ^mg.syncat;
                         sn: ^mg.synname;
                         n: ^text;
                         pr: ^mg.prod;
                      do current[] -> sc[];
                         sc.getsynname -> sn[];
                         sn.dclRefProd -> pr[];
                         (if pr.symbol=mg.alternation then
                             traversebodyfile.indent;
                             '(\* sub-alternation: *\)' 
                               -> traversebodyfile.putline;
                             (# al: ^mg.alternation;
                             do pr[] -> al[];
                                al.getsyncatlist -> generateAlternatives;
                             #);
                             traversebodyfile.indent;
                             '(\* end sub-alternation. *\)' 
                               -> traversebodyfile.putline;
                          else
                             traversebodyfile.indent;
                             '// ' -> traversebodyfile.puttext;
                             fullNameOfGrammar[] -> traversebodyfile.puttext;
                             '.' -> traversebodyfile.put;
                             current[] -> sc[];
                             sc.getsyntext -> n[] -> traversebodyfile.puttext;
                             ' then' -> traversebodyfile.putline;
                             3 -> traversebodyfile.indent.inc;
                             traversebodyfile.indent;
                             initial -> traversebodyfile.put;
                             '[] -> do_' -> traversebodyfile.puttext;
                             n[] -> traversebodyfile.puttext;
                             ';' -> traversebodyfile.putline;
                             3 -> traversebodyfile.indent.dec;
                         if);
                      #);
                  if)
               #);
          enter al[]
          do debug(# do 'begin generate alternation' -> screen.putText #);
             al[] -> printLeftSide->name[]; 
             al.getLeftSide -> writeSuper;
             '(# ' -> genFile.putText;
             (al[],false) -> writeSlot;
                 '#);' -> genFile.puttext;
             (if make_traverse then
                 ('do_' -> (name.copy).prepend, 'alternation') 
                   -> traversefile.patbegin;
                 1 -> name.inxget -> initial -> traversefile.put;
                 ': ^' -> traversefile.puttext;
                 fullNameOfGrammar[] -> traversefile.puttext;
                 '.' -> traversefile.put;
                 name[] -> traversefile.putline;
                 3 -> traversefile.indent.dec;
                 traversefile.indent;
                 'enter '->traversefile.puttext;
                 initial -> traversefile.put;
                 '[]' -> traversefile.putline;
                 traversefile.indent;
                 'do_' -> (name.copy).prepend -> writeTraverseSlotBody;
                 3 -> traversefile.indent.inc;
                 traversefile.patend;
                 
                 'do (\if '->traversebodyfile.puttext;
                 initial -> traversebodyfile.put;
                 '.symbol' -> traversebodyfile.putline;
                 3+1 -> traversebodyfile.indent.inc;
                 al.getsyncatlist -> generateAlternatives;
                 traversebodyfile.indent;
                 'if\);' -> traversebodyfile.putline;
                 3+1 -> traversebodyfile.indent.dec;
                 
             if);
             debug(# do 'end generate alternation' -> screen.putText #);
          #);
        generateOptional:
          (# o: ^mg.Opt;
             sc: ^mg.SynCat;
             name, syn: ^text;
          enter o[]
          do (if make_traverse then
                 (o.getSynCat->sc[]).getSynText -> syn[];
                 o.getSynDeclText -> name[];
                 ('do_' -> (name.copy).prepend, 'optional') 
                   -> traversefile.patbegin;
                 'a: ^astinterface.ast;' -> traversefile.putline;
                 3 -> traversefile.indent.dec;
                 traversefile.indent;
                 'enter a[]'->traversefile.putline;
                 traversefile.indent;
                 'do_' -> (name.copy).prepend -> writeTraverseSlotBody;
                 3 -> traversefile.indent.inc;
                 traversefile.patend;

                 'do (\if a.kind<>ast.kinds.optional then'
                   -> traversebodyfile.putline;
                 3+4 -> traversebodyfile.indent.inc;
                 traversebodyfile.indent;
                 'a[] -> do_' -> traversebodyfile.puttext;
                 syn[] -> traversebodyfile.puttext;
                 ';' -> traversebodyfile.putline;
                 4 -> traversebodyfile.indent.dec;
                 traversebodyfile.indent;
                 'if\);' -> traversebodyfile.putline;
                 3 -> traversebodyfile.indent.dec;
             if);
          #);
        generateConstructor:  
          (# c: ^mg.constructor;
             clist: ^mg.consElemList;
             idx: @integer;
             name: ^text;
             initial: @char;
             first_done: @boolean;
          enter c[]
          do c[] -> printLeftside -> name[];
             (if make_traverse then
                 false->first_done;
                 ('do_' -> (name.copy).prepend, 'cons') 
                   -> traversefile.patbegin;
                 1 -> name.inxget -> initial -> traversefile.put;
                 ': ^' -> traversefile.puttext;
                 fullNameOfGrammar[] -> traversefile.puttext;
                 '.' -> traversefile.put;
                 name[] -> traversefile.putline;
                 3 -> traversefile.indent.dec;
                 traversefile.indent;
                 'enter '->traversefile.puttext;
                 initial -> traversefile.put;
                 '[]' -> traversefile.putline;
                 traversefile.indent;
                 'do_' -> (name.copy).prepend -> writeTraverseSlotBody;
                 3 -> traversefile.indent.inc;
                 traversefile.patend;
             if);
             c.getLeftSide -> writesuper;
             0 -> idx;
             genFile.newline;
             '(\#' -> genFile.puttext; 
             c.getConsElemList -> clist[];
             clist.newScan
               (# ts: ^mg.TaggedSyn;
                  sc: ^mg.synCat;
                  n : ^text;
                  tn: ^mg.TagName;
                  sn: ^mg.SynName;
               do (if current.symbol
                   //mg.TaggedSyn then 
                      idx+1 -> idx;
                      current[] -> ts[];
                      ' get' -> genFile.puttext;
                      ts.getTagText -> n[] -> genFile.puttext;
                      ': getson' -> genFile.puttext;
                      idx -> genFile.putInt;
                      '(##);\n put' -> genFile.puttext;
                      n[] -> genFile.puttext;
                      ': putson' -> genFile.puttext;
                      idx -> genFile.putInt;
                      '(##);\n' -> genFile.puttext;
                      (if make_traverse then
                          (if first_done then
                              traversebodyfile.indent;
                           else
                              'do ' -> traversebodyfile.puttext;
                              3 -> traversebodyfile.indent.inc;
                              true -> first_done;
                          if);
                          initial -> traversebodyfile.put;
                          '.get' -> traversebodyfile.puttext;
                          n[] -> traversebodyfile.puttext;
                          ' -> do_' -> traversebodyfile.puttext;
                          ts.getSynText -> traversebodyfile.puttext;
                          ';' -> traversebodyfile.putline;
                      if);
                   //mg.Syncat then
                      current[] -> sc[];
                      idx+1 -> idx;
                      ' get' -> genFile.puttext;
                      sc.getSynText -> n[] -> genFile.puttext;
                      ': getson' -> genFile.puttext;
                      idx -> genFile.putInt;
                      '(##);\n put' -> genFile.puttext; 
                      n[] -> genFile.puttext;
                      ': putson' -> genFile.puttext;
                      idx -> genFile.putInt;
                      '(##);\n' -> genFile.puttext; 
                      (if make_traverse then
                          (if first_done then
                              traversebodyfile.indent;
                           else
                              'do ' -> traversebodyfile.puttext;
                              3 -> traversebodyfile.indent.inc;
                              true->first_done;
                          if);
                          initial -> traversebodyfile.put;
                          '.get' -> traversebodyfile.puttext;
                          n[] -> traversebodyfile.puttext;
                          ' -> do_' -> traversebodyfile.puttext;
                          n[] -> traversebodyfile.puttext;
                          ';' -> traversebodyfile.putline;
                      if);
                  if);
               #);
             (c[],true) -> writeSlot;
             (prodIdx,true) -> writeexit;
             (if make_traverse then
                 (if first_done then 
                     3 -> traversebodyfile.indent.dec;
                  else
                     'do ' -> traversebodyfile.putline;
                 if);
             if);
          #);
        printLeftSide:  
          (# pr: ^mg.prod;
             ls: ^mg.LeftSide;
             sn: ^mg.SynDeclName;
             n: ^text;
          enter pr[]
          do pr.getSynDeclText -> n[] -> genFile.putText;
             ': ' -> genFile.putText;
          exit n[]
          #);
        generateList:  
          (# l: ^mg.lst;
             sc: ^mg.synCat;
	     prod: ^mg.prod;
	     sn: ^mg.synName;
             name, syn: ^text;
             initial: @char;
          enter l[]
          do l[] -> printLeftSide -> name[];
             'list(\# soncat::< ' -> genFile.puttext;
             l.getSon2 -> sc[];
	     sc.getSynName -> sn[];
	     l: (#
	        do sn.dclRefProd
                     (# predefined::<
                          (# 
                          do 'lexem' -> syn[] -> genFile.putText;
                             ' ' -> genFile.put;
                             leave l;
                          #)
                     #) -> prod[];
                   (if prod.symbol=mg.opt then
                       prod.getSon2 -> sc[];
                   if);
                   sc.getSynText -> syn[] -> genFile.putText;
                   ';' -> genFile.put; (* a slot may later be generated *)
                   ' ' -> genFile.put;
                #);
             (l[],false) -> writeSlot;
             (prodIdx,false)-> writeexit;
             (if make_traverse then 
                 ('do_' -> (name.copy).prepend, 'list') 
                   -> traversefile.patbegin;
                 1 -> name.inxget -> initial -> traversefile.put;
                 ': ^' -> traversefile.puttext;
                 fullNameOfGrammar[] -> traversefile.puttext;
                 '.' -> traversefile.put;
                 name[] -> traversefile.putline;
                 3 -> traversefile.indent.dec;
                 traversefile.indent;
                 'enter '->traversefile.puttext;
                 initial -> traversefile.put;
                 '[]' -> traversefile.putline;
                 traversefile.indent;
                 'do_' -> (name.copy).prepend -> writeTraverseSlotBody;
                 3 -> traversefile.indent.inc;
                 traversefile.patend;

                 'do '->traversebodyfile.puttext;
                 initial -> traversebodyfile.put;
                 '.newscan' -> traversebodyfile.putline;
                 3 -> traversebodyfile.indent.inc;
                 traversebodyfile.indent;
                 '(\#' -> traversebodyfile.putline;
                 traversebodyfile.indent;
                 'do current[] -> do_' -> traversebodyfile.puttext;
                 syn[] -> traversebodyfile.puttext;
                 ';' -> traversebodyfile.putline;
                 traversebodyfile.indent;
                 '#\);' -> traversebodyfile.putline;
                 3 -> traversebodyfile.indent.dec;
             if);
          #);
        attributesSet: 
          (# ls: ^mg.LeftSide;
             extra: @integer;
             att: ^mg.Attrib;
             n: ^text;
             extraSet: @boolean;
          enter ls[]
          do false -> extraSet;
             ls.getSynDeclText -> n[];
             (if attlist[]<>none then
                 l: attlist.newscan
                      (# sc: ^mg.synCat
                      do current.getSynCat -> sc[];
                         (if sc.getSynText -> n.equalNCS then
                             true -> extraSet; leave l
                         if);
                      #);
             if);
          exit extraSet
          #);
        generateGrammarName:
          (# t: @text
          do '  grammarIdentification::< (# do \'' -> genFile.putText;
             gnNameDecl.getText -> genFile.putText;
             '\' -> theGrammarName #);\n\n' -> genFile.putText;
             '  version::< (# do ' -> genFile.putText;
             ('version',undefinedVersion) -> root.getOptionValue -> genFile.putInt;
             ' -> value #);\n\n' -> genFile.putText;
             '  suffix::< (# do \'' -> genFile.putText;
             ('suffix','.text') -> root.getOptionString -> t;
             t[] -> genFile.putText;
             '\' -> theSuffix #);\n\n' -> genFile.putText;
             '  maxproductions::< (# do ' -> genFile.putText;
             pl.noOfSons -> genFile.putInt;
             ' -> value #);\n ' -> genFile.putLine; 
             (if ('substanceSlot' -> root.optionSet)<>none then
                 (('substanceSlot','cflAtt') -> root.getOptionName) -> t;
                 t[]-> genFile.putText;
                 ': @<<SLOT ' -> genFile.putText;
                 t[] -> genFile.putText;
                 ': descriptor>>;\n\n' -> genFile.putText;
             if);
          #);
        generateInit:
          (# compExtra: 
               (# ls: ^mg.LeftSide;
                  extra: @integer;
                  sc: ^mg.synCat;
                  NoAtt: ^mg.NoOfAttributes;
                  n: ^text;
                  c: ^Const;
               enter ls[]
               do ls.getSynDeclText -> tosmall -> n[];
                  0 -> extra;
                  (if attlist[]<>none then
                      l: attlist.newscan
                        (# 
                        do current.getSyncat -> sc[];
                           (if sc.getSynText -> n.equalNCS then
                               current.getNoOfAttributes -> NoAtt[];
                               NoAtt.getConst -> c[];
                               c.getValue -> Extra;
                               leave l
                           if);
                        #);
                  if);
               exit extra
               #);
             genProd:
               (# prodNo,type,extra,sons: @integer;
               enter (prodNo,type,sons,extra)
               do '    ' -> genFile.putText;
                  type -> genFile.putInt;
                  ' -> kindArray[' -> genFile.putText;
                  prodNo -> genFile.putInt;
                  ']; ' -> genFile.putText;
                  2 * ((extra+1) div 2) -> genFile.putInt;
                  ' -> roomArray[' -> genFile.putText;
                  prodNo -> genFile.putInt;
                  ']; ' -> genFile.putText;
                  sons -> genFile.putInt;
                  ' -> sonArray[' -> genFile.putText;
                  prodNo -> genFile.putInt;
                  ']; ' -> genFile.putText;
                  genFile.newLine;
               #);
             genRefGen:
               (# prodNo: @integer;
                  AstCatName: ^text;
               enter (prodNo,astCatName[])
               do '    &referenceGenerator(# do &' -> genFile.putText;
                  astCatName[] -> genFile.putText;
                  '[] -> as[] #)[] -> genRefArray[' -> genFile.putText;
                  prodNo -> genFile.putInt;
                  '][];\n' -> genFile.putText;
               #);
          do debug(# do 'generating init' -> screen.putText; #);
             '  init::<\n(#\ndo\n  &(# do \n' -> genFile.putText;
             pl.newscan
               (# co: ^mg.Constructor;
                  clist: ^mg.ConsElemList;
                  NuOfSCSons: @integer;
               do
                  (if (currentSonNo mod 20)=0 then
                  '  #);\n  &(# do\n' -> genFile.putText;
                   if);
                  (if current.symbol
                   //mg.opt then  
                      (currentSonNo,kinds.optional,0,1) -> genProd;
                      (currentSonNo,'Optional') -> genRefGen
                   //mg.alternation then 
                      (currentSonNo,kinds.UnExpanded,0,1) -> genProd;
                      (currentSonNo,'unExpanded') -> genRefGen
                   //mg.constructor then
                      current[] -> co[];
                      co.getConsElemList -> clist[];
                      0 -> NuOfSCSons;
                      clist.scan
                      (# 
                      do (if current.symbol<>mg.term then
                             NuOfSCSons + 1 -> NuOfSCSons 
                         if) 
                      #);
                      (currentSonNo, kinds.interior, NuOfSCSons, current.LeftSide -> compExtra) 
                        -> genProd;
                      (currentSonNo, current.getSynDeclText) -> genRefGen
                   //mg.ListOne//mg.ListZero then
                      (currentSonNo, kinds.interior, 0, current.leftSide -> compExtra) -> genProd; 
                      (currentSonNo, current.getSynDeclText) -> genRefGen
                  if);
               #);
             '  #)\n#);\n' -> genFile.puttext
          #);
        genHeadForm:
          (# formNo: @integer;
             originName,catName,subName: ^text;
          enter (formNo,originName[],catName[],subName[])
          do 'ORIGIN \'' -> genfile.putText;
             originName[] -> genFile.putText;
             '\'' -> genfile.put;
             '\n--- astInterfaceLib: attributes---\n\n' -> genFile.putText;
             catName[] -> genFile.putText;
             ':  ' -> genFile.puttext; 
             subName[] -> genFile.putText;
             genFile.newline;
             '(\# <<SLOT ' -> genFile.puttext;
             catName[] -> genFile.puttext;
             'Attributes:attributes>>;' -> genFile.putline;
             (if make_traverse then
                 (if formNo=1 then
                     0 -> traversefile.indent.set;
                     'ORIGIN \'' -> traversebodyfile.putText;
                     'traverse' -> (fullNameOfGrammar.copy).append 
                       -> traversebodyfile.puttext;
                     '\';' -> traversebodyfile.putline;
                     traversebodyfile.newline;
                     'ORIGIN \'' -> traversefile.putText;
                     'cfl' -> (fullNameOfGrammar.copy).append 
                       -> traversefile.puttext;
                     '\';' -> traversefile.putline;
                     'BODY \'' -> traversefile.putText;
                     'traversebody' -> (fullNameOfGrammar.copy).append 
                       -> traversefile.puttext;
                     '\';' -> traversefile.putline;
                     traversefile.newline;
                     '(\* Skeleton file for traversal of ASTs based on\n'
                     ' \* grammar \'' -> traversefile.puttext;
                     fullNameOfGrammar[] -> traversefile.puttext;
                     '\'.\n' -> traversefile.puttext;
                     ' \* Take a copy of this file and fill out the do-parts.\n'
                     ' \* Do NOT edit this file directly as it will be overwritten\n'
                     ' \* when the grammar is processed again.\n'
                     ' \*\)\n' -> traversefile.puttext;
                     '--- LIB: attributes---\n\n' 
                       -> traverseFile.putText;
                     ('_traverse' -> (fullNameOfGrammar.copy).append, none)
                       -> traversefile.patbegin;
                     'BobsTab: (\# exit \'~beta/.../' 
                       -> traversefile.puttext;
                     fullNameOfGrammar[] -> traversefile.puttext;
                     '-parser.btab\' #\);\n' -> traversefile.putline;
                     traversefile.indent;
                     'GrammarPath: (\# exit \'~beta/.../' 
                       -> traversefile.puttext;
                     fullNameOfGrammar[] -> traversefile.puttext;
                     '\' #\);\n' -> traversefile.putline;
                     traversefile.indent;
                     'ast: @astInterface (* An instance of the AST interface *);' 
                       -> traversefile.putline;
                     traversefile.indent;
                     fullNameOfGrammar[] -> traversefile.puttext;
                     ': @ast.' -> traversefile.puttext;
                     fullNameOfGrammar[] -> traversefile.puttext;
                     ';\n\n' -> traversefile.puttext;
                 if);
             if);
          #);
        genTailForm:
          (# postFormName: @text;
             formNo: @integer;
             suffix: @text;
             first_done: @boolean;
             optionstring: @text;
             check_indent:
               (# 
               do (if make_traverse then
                      (if first_done then
                          traversefile.newline;
                          traversefile.indent;
                       else
                          true -> first_done;
                      if);
                  if);
               #);
             generatePredefined:
               (# name: ^text;
                  initial: @char;
                  genvalue: @boolean;
               enter (name[], genvalue)
               do (if make_traverse then
                      (name,'used')->root.getOptionName
                        -> optionstring;
                      (if 'unused' -> optionstring.equalNCS then
                          traversefile.indent;
                          traversefile.commentbegin;
                          'do_' -> traversefile.puttext;
                          name[] -> traversefile.puttext;
                          ': Lexem <' -> traversefile.puttext;
                          name[] -> traversefile.puttext;
                          '> is unused' -> traversefile.puttext;
                          traversefile.commentend;
                          traversefile.newline;
                      else
                          ('do_'->(name.copy).prepend, 'lexem') 
                            -> traversefile.patbegin;
                          1 -> name.inxget -> initial -> traversefile.put;
                          ': ^astinterface.' -> traversefile.puttext;
                          name[] -> traversefile.puttext;
                          ';' ->traversefile.putline;
                          traversefile.indent;
                          'getText: (\# exit ' -> traversefile.puttext;
                          initial -> traversefile.put;
                          '.getText #\);' -> traversefile.putline;
                          (if genvalue then
                              traversefile.indent;
                              'getValue: (\# exit ' ->traversefile.puttext;
                              initial -> traversefile.put;
                              '.getValue #\);' ->traversefile.putline;
                          if);
                          3 -> traversefile.indent.dec;
                          traversefile.indent;
                          'enter ' -> traversefile.puttext;
                          initial -> traversefile.put;
                          '[] ' -> traversefile.putline;
                          traversefile.indent;
                          'do INNER;' -> traversefile.putline;
                          3 -> traversefile.indent.inc;                 
                          traversefile.patend;
                      if);
                  if);
               #);
          enter (formNo,postFormName)
          do debug(# do 'genTailForm' -> screen.putText #);
             (if make_traverse then
                 (if formNo=NoOfFiles then
                     traversefile.newline;
                     (* Generate pats for nameDecl, nameAppl, const, string *)
                     ('nameDecl',false) -> generatePredefined;
                     ('nameAppl',false) -> generatePredefined;
                     ('const',true) -> generatePredefined;
                     ('string',false) -> generatePredefined;
                     
                     ('init', 'Initialization of astLevel and parser') 
                       -> traversefile.patbegin;
                     traversefile.newline;
                     3 -> traversefile.indent.dec;
                     traversefile.indent;
                     '_init' -> (fullNameOfGrammar.copy).append
                       -> writeTraverseSlotBody;
                     3 -> traversefile.indent.inc;
                     traversefile.patend;
                     
                     'do ast.astLevelInit;' 
                       -> traversebodyfile.putline; 
                     3 -> traversebodyfile.indent.inc;
                     traversebodyfile.indent;
                     '(* Alternative to using findGrammar: *)' 
                       -> traversebodyfile.putline; traversebodyfile.indent;
                     '(\'' -> traversebodyfile.puttext;
                     fullNameOfGrammar[] -> traversebodyfile.puttext;
                     '\', \'' -> traversebodyfile.puttext;
                     ('suffix',fullNameOfGrammar) -> root.getOptionString 
                       -> suffix;
                     suffix[] -> traversebodyfile.puttext;
                     '\', GrammarPath->ast.expandToFullPath)' 
                       -> traversebodyfile.putline;
                     traversebodyfile.indent;
                     '  -> ast.registergrammar;' -> traversebodyfile.putline;
                     traversebodyfile.indent;
                     fullNameOfGrammar[] -> traversebodyfile.puttext;
                     '.init; ' -> traversebodyfile.putline;
                     traversebodyfile.indent;
                     'BobsTab -> ast.expandToFullPath -> '
                       -> traversebodyfile.puttext;
                     fullNameOfGrammar[] -> traversebodyfile.puttext;
                     '.parser.initialize' -> traversebodyfile.putline;
                     traversebodyfile.indent;
                     '(\# ' -> traversebodyfile.puttext;
                     ('dashKeywords','false')->root.getOptionName
                       -> optionstring;
                     (if 'true' -> optionstring.equalNCS then
                         check_indent;
                         'dashNames::(\# do true->value #\);' 
                           -> traversebodyfile.putline;
                     if);
                     ('caseSensitive','false')->root.getOptionName
                       -> optionstring;
                     (if 'true' -> optionstring.equalNCS then
                         check_indent;
                         'caseSensitive::(\# do true->value #\);' 
                           -> traversebodyfile.putline;
                     if);
                     (* FIXME: set the other boolean virtuals too *)
                     (if first_done then
                         traversebodyfile.indent;
                     if);
                     traversebodyfile.patend;
                     
                     traversefile.patend;
                 if);
             if);
          #);
        openForm:
          (# originName, str: @text; t: ^Text;
          do formNo + 1 -> formNo;
             (if formNo = noOfFiles (* the last file *) then
                 genFileName -> str; 
                 str[]-> genFile.Name
              else
                 gnNameDecl.getText -> formName[];
                 formNo -> formName.putInt;
                 '.bet' 
                   -> (formName.copy).append
                   -> genFile.name;
             if);
             (if formNo = 1 then
                 '~beta/mps/astlevel' -> originName;
              else 
                 lastCatName -> originName;
             if);
             (if formNo=NoOfFiles then
                 gnNameDecl.getText -> t[]; t -> catName;
              else
                 gnNameDecl.gettext -> t[]; t -> catName;
                 formNo -> catName.putInt;
             if);
             genFile.openWrite;
             'Generating ' -> screen.putText; 
             genFile.name -> screen.putText; 
             (if make_traverse then
                 (if formNo = 1 then
                     traverseFile.openWrite;
                     traverseBodyFile.openWrite;
                     ' and '-> screen.puttext; 
                     traversefilename[] -> screen.puttext;
                     '+'->screen.put;
                     traversebodyfilename[] -> screen.puttext;
                  else
                     traverseFile.openAppend;
                     traverseBodyFile.openAppend;
                     ' and continuing traverse files.'-> screen.puttext; 
                 if)
             if);
             screen.newLine;
             (formNo,originName[],catName[],lastCatName[]) -> genHeadForm;
             catName -> lastCatName;
          #);
        closeAndReOpen:
          (#
          do debug(# do 'close and reopen' -> screen.putText; #);
             '#\);' -> genFile.putText; genFile.newLine;
             gnNameDecl.gettext -> formName[];
             formNo + 1 -> formName.putInt;
             'FORM' -> formName.append;
             (formNo,formName) -> genTailForm;
             genFile.close;
             (if make_traverse then
                 traverseFile.close;
             if);
             openForm;
          #);
        g: ^mg.Agrammar; 
        gn: ^mg.grammarName;
        gnNameDecl: ^NameDecl;
        applicationProg: @text;
        prodIdx: @integer;
        formName: ^Text;
        catName,lastCatName: @text;
        formNo: @integer;
        prodNumbersPerFile: @integer;
      enter g[]
      do debug(# do 'makepat started ' -> screen.putText #);
         ('subof','TreeLevel') -> root.getOptionName -> lastCatName;
         0 -> formNo;
         g.getGrammarName -> gn[];
         gn.getNameDecl -> gnNameDecl[];
         debug(# do 'going to open form' -> screen.putText #);
         OpenForm;
         debug(# do 'form opened' -> screen.putText #);
         (pl.noOfSons + 40) div NoOfFiles -> prodNumbersPerFile;
         debug(# do 'generating alternations' -> screen.putText #);
         pl.scan
           (#
           do (if current.symbol=mg.Alternation then
                  current[] -> generateAlternation; genFile.newLine
              if);
              debug(# do current.index -> screen.putInt; '       ' -> screen.putText  #);
           #);
         debug(# do 'finished alternation' -> screen.putText; #);
         0 -> prodidx;
         pl.scan
           (#
           do (if ((prodIdx + 1 -> prodIdx) mod prodNumbersPerFile)=0 then
                  CloseAndReOpen;
              if);
              debug(# do current.symbol -> screen.putInt; ' = ' -> screen.putText;
                      current.index -> screen.putInt; #);
              (if current.symbol
               //mg.Constructor then current[] -> generateConstructor; genFile.newLine
               //mg.Opt then current[] -> generateOptional;
               //mg.ListOne
               //mg.ListZero then current[] -> generateList; genFile.newLine
              if);
           #);
         generateGrammarName;
         generateInit;
         (if formNo<NoOfFiles then
             CloseAndReOpen
         if);
         '#\); ' -> genFile.putText; genFile.newLine;
         applicationProg.clear;
         gnNameDecl.gettext -> applicationProg.append;
         'prog' -> applicationProg.append;
         ('postname',applicationProg) -> root.getOptionName -> applicationProg;
         (NoOfFiles,applicationProg) -> genTailForm;
         debug(# do genfile.name -> screen.putText; ' closed' -> screen.putText #);
         genFile.close;
       #);
   NoOfFiles: @integer;
do ('splitonfiles',1) -> root.getOptionValue -> NoOfFiles;
   (if make_traverse then
       (if NoOfFiles>1 then
           'Notice: traverse files will not be split.' -> screen.putline;
       if)
   if);
   root[] -> generatePatterns;
#)
