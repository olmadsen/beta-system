ORIGIN 'generator';
--- makepatterns: descriptor ---
(# debugPattern: (# exit false #);
   debug:
     (#
     do (if debugpattern then 
            INNER;
            screen.newLine
        if)
     #);
   generatePatterns:  
     (# writeOption:
          (# optionName,defaultText: @text;
             lex: ^lexemText;
             optSpec: ^mg.optionSpecification;
          enter (optionName,defaultText)
          do (if (optionName -> root.optionSet -> optSpec[])=none then
                 defaultText[] -> genFile.putText;
              else
                 (optSpec[],optionName,mg.optionName)->root.checkOption->lex[];
                 lex.getText -> genFile.putText;
             if);
          #);
        writeSuper:
          (# ls: ^mg.LeftSide;
             found: @boolean;
             super: @integer;
             p: ^mg.prod;
          enter ls[]
          do debug
             (# 
             do 'write super. LS =' -> screen.putText;
	        ls.dump
             #);
             ls.superValue -> super;
             debug
             (# 
             do 'super =' -> screen.putText;
	        super -> screen.putInt;
             #);
             (if super>=0 then
                 super -> pl.get -> p[];
	         p.getSynDeclText -> genFile.putText;
              else
                 'cons' -> genFile.puttext;
             if); 
          #);
        writeSlot:
          (# pr: ^mg.prod; nl: @boolean
          enter(pr[],nl)
          do (if pr.getson1 -> attributesSet then
                 '<<SLOT ' -> genFile.putText;
                 pr.getSynDeclText -> genFile.putText;
                 'Attributes:attributes>> ' -> genFile.puttext;
                 (if nl then genFile.newline if)
             if); 
          #);
        writeexit: 
          (# prodno: @integer; nl: @boolean
          enter(prodno,nl)
          do 'exit ' -> genFile.putText;
             prodno -> genFile.putInt;
             (if nl then genFile.newline else ' ' -> genFile.put if);
             '#);' -> genFile.putText;
          #);
        generateAlternation:  
          (# al: ^mg.alternation;
          enter al[]
          do debug(# do 'begin generate alternation' -> screen.putText #);
             al[] -> printLeftSide; 
             al.getLeftSide -> writeSuper;
             '(# ' -> genFile.putText;
             (al[],false) -> writeSlot;
             '#);' -> genFile.puttext;
             debug(# do 'end generate alternation' -> screen.putText #);
          #);
        generateConstructor:  
          (# c: ^mg.constructor;
             clist: ^mg.consElemList;
             idx: @integer;
          enter c[]
          do c[] -> printLeftside;
             c.getLeftSide -> writesuper;
             0 -> idx;
             genFile.newline;
             '(#' -> genFile.puttext; 
             c.getConsElemList -> clist[];
             clist.newScan
               (# ts: ^mg.TaggedSyn;
                  sc: ^mg.synCat;
                  n : ^text;
                  tn: ^mg.TagName;
                  sn: ^mg.SynName;
               do (if current.symbol
                   //mg.TaggedSyn then 
                      idx+1 -> idx;
                      current[] -> ts[];
                      ' get' -> genFile.puttext;
                      ts.getTagText -> n[] -> genFile.puttext;
                      ': getson' -> genFile.puttext;
                      idx -> genFile.putInt;
                      '(##);\n put' -> genFile.puttext;
                      n[] -> genFile.puttext;
                      ': putson' -> genFile.puttext;
                      idx -> genFile.putInt;
                      '(##);\n' -> genFile.puttext;
                   //mg.Syncat then
                      current[] -> sc[];
                      idx+1 -> idx;
                      ' get' -> genFile.puttext;
                      sc.getSynText -> n[] -> genFile.puttext;
                      ': getson' -> genFile.puttext;
                      idx -> genFile.putInt;
                      '(##);\n put' -> genFile.puttext; 
                      n[] -> genFile.puttext;
                      ': putson' -> genFile.puttext;
                      idx -> genFile.putInt;
                      '(##);\n' -> genFile.puttext; 
                  if);
               #);
             (c[],true) -> writeSlot;
             (prodIdx,true) -> writeexit;
          #);
        printLeftSide:  
          (# pr: ^mg.prod;
             ls: ^mg.LeftSide;
             sn: ^mg.SynDeclName;
          enter pr[]
          do pr.getSynDeclText -> genFile.putText;
             ': ' -> genFile.putText;
          #);
        generateList:  
          (# l: ^mg.lst;
             sc: ^mg.synCat;
	     prod: ^mg.prod;
	     sn: ^mg.synName
          enter l[]
          do l[] -> printLeftSide;
             'list(# soncat::< ' -> genFile.puttext;
             l.getSon2 -> sc[];
	     sc.getSynName -> sn[];
	     l: (#
	        do sn.dclRefProd
                     (# predefined::<
                          (# do 'lexem ' -> genFile.putText; leave l #)
                     #) -> prod[];
                   (if prod.symbol=mg.opt then
                       prod.getSon2 -> sc[]
                   if);
                   sc.getSynText -> genFile.putText;
                   ';' -> genFile.put; (* a slot may later be generated *)
                   ' ' -> genFile.put;
                #);
             (l[],false) -> writeSlot;
             (prodIdx,false)-> writeexit;
          #);
        attributesSet: 
          (# ls: ^mg.LeftSide;
             extra: @integer;
             att: ^mg.Attrib;
             n: ^text;
             extraSet: @boolean;
          enter ls[]
          do false -> extraSet;
             ls.getSynDeclText -> n[];
             (if attlist[]<>none then
                 l: attlist.newscan
                      (# sc: ^mg.synCat
                      do current.getSynCat -> sc[];
                         (if sc.getSynText -> n.equalNCS then
                             true -> extraSet; leave l
                         if);
                      #);
             if);
          exit extraSet
          #);
        generateGrammarName:
          (# t: @text
          do '  grammarIdentification::< (# do ''' -> genFile.putText;
             gnNameDecl.getText -> genFile.putText;
             ''' -> theGrammarName #);\n\n' -> genFile.putText;
             '  version::< (# do ' -> genFile.putText;
             ('version',undefinedVersion) -> root.getOptionValue -> genFile.putInt;
             ' -> value #);\n\n' -> genFile.putText;
             '  suffix::< (# do ''' -> genFile.putText;
             ('suffix','.text') -> root.getOptionString -> t;
             t[] -> genFile.putText;
             ''' -> theSuffix #);\n\n' -> genFile.putText;
             '  maxproductions::< (# do ' -> genFile.putText;
             pl.noOfSons -> genFile.putInt;
             ' -> value #);\n ' -> genFile.putLine; 
             (if ('substanceSlot' -> root.optionSet)<>none then
                 (('substanceSlot','cflAtt') -> root.getOptionName) -> t;
                 t[]-> genFile.putText;
                 ': @<<SLOT ' -> genFile.putText;
                 t[] -> genFile.putText;
                 ': descriptor>>;\n\n' -> genFile.putText;
             if);
          #);
        generateInit:
          (# compExtra: 
               (# ls: ^mg.LeftSide;
                  extra: @integer;
                  sc: ^mg.synCat;
                  NoAtt: ^mg.NoOfAttributes;
                  n: ^text;
                  c: ^Const;
               enter ls[]
               do ls.getSynDeclText -> tosmall -> n[];
                  0 -> extra;
                  (if attlist[]<>none then
                      l: attlist.newscan
                        (# 
                        do current.getSyncat -> sc[];
                           (if sc.getSynText -> n.equalNCS then
                               current.getNoOfAttributes -> NoAtt[];
                               NoAtt.getConst -> c[];
                               c.getValue -> Extra;
                               leave l
                           if);
                        #);
                  if);
               exit extra
               #);
             genProd:
               (# prodNo,type,extra,sons: @integer;
               enter (prodNo,type,sons,extra)
               do '    ' -> genFile.putText;
                  type -> genFile.putInt;
                  ' -> kindArray[' -> genFile.putText;
                  prodNo -> genFile.putInt;
                  ']; ' -> genFile.putText;
                  2 * ((extra+1) div 2) -> genFile.putInt;
                  ' -> roomArray[' -> genFile.putText;
                  prodNo -> genFile.putInt;
                  ']; ' -> genFile.putText;
                  sons -> genFile.putInt;
                  ' -> sonArray[' -> genFile.putText;
                  prodNo -> genFile.putInt;
                  ']; ' -> genFile.putText;
                  genFile.newLine;
               #);
             genRefGen:
               (# prodNo: @integer;
                  AstCatName: ^text;
               enter (prodNo,astCatName[])
               do '    &referenceGenerator(# do &' -> genFile.putText;
                  astCatName[] -> genFile.putText;
                  '[] -> as[] #)[] -> genRefArray[' -> genFile.putText;
                  prodNo -> genFile.putInt;
                  '][];\n' -> genFile.putText;
               #);
          do debug(# do 'generating init' -> screen.putText; #);
             '  init::<\n(#\ndo\n  &(# do \n' -> genFile.putText;
             pl.newscan
               (# co: ^mg.Constructor;
                  clist: ^mg.ConsElemList;
                  NuOfSCSons: @integer;
               do
                  (if (currentSonNo mod 20)=0 then
                  '  #);\n  &(# do\n' -> genFile.putText;
                   if);
                  (if current.symbol
                   //mg.opt then  
                      (currentSonNo,kinds.optional,0,1) -> genProd;
                      (currentSonNo,'Optional') -> genRefGen
                   //mg.alternation then 
                      (currentSonNo,kinds.UnExpanded,0,1) -> genProd;
                      (currentSonNo,'unExpanded') -> genRefGen
                   //mg.constructor then
                      current[] -> co[];
                      co.getConsElemList -> clist[];
                      0 -> NuOfSCSons;
                      clist.scan
                      (# 
                      do (if current.symbol<>mg.term then
                             NuOfSCSons + 1 -> NuOfSCSons 
                         if) 
                      #);
                      (currentSonNo, kinds.interior, NuOfSCSons, current.LeftSide -> compExtra) 
                        -> genProd;
                      (currentSonNo, current.getSynDeclText) -> genRefGen
                   //mg.ListOne//mg.ListZero then
                      (currentSonNo, kinds.interior, 0, current.leftSide -> compExtra) -> genProd; 
                      (currentSonNo, current.getSynDeclText) -> genRefGen
                  if);
               #);
             '  #)\n#);\n' -> genFile.puttext
          #);
        genHeadForm:
          (# formNo: @integer;
             originName,catName,subName: ^text;
          enter (formNo,originName[],catName[],subName[])
          do 'ORIGIN ''' -> genfile.putText;
             originName[] -> genFile.putText;
             '''' -> genfile.put;
             '\n--- astInterfaceLib: attributes---\n\n' -> genFile.putText;
             catName[] -> genFile.putText;
             ':  ' -> genFile.puttext; 
             subName[] -> genFile.putText;
             genFile.newline;
             '(# <<SLOT ' -> genFile.puttext;
                 catName[] -> genFile.puttext;
                 'Attributes:attributes>>;' -> genFile.putline;
          #);
        genTailForm:
          (# postFormName: @text;
             formNo: @integer;
          enter (formNo,postFormName)
          do debug(# do 'genTailForm' -> screen.putText #);
          #);
        openForm:
          (# originName, str: @text; t: ^Text;
          do formNo + 1 -> formNo;
             (if formNo = noOfFiles (* the last file *) then
                 genFileName -> str; str[]-> genFile.Name
              else
                 gnNameDecl.getText -> formName[];
                 formNo + '0' -> formName.put;
                 (# t: ^text; 
                 do formName.copy -> t[];
                    '.bet' -> t.append;
                    t[] -> genFile.Name;
                 #);                 
             if);
             (if formNo = 1 then
                 '~beta/mps/' -> originName;
                 ('astversion',yggdrasilVersion) 
                   -> root.getOptionString 
                   -> str; 
                 str[]-> originName.append;
                 '/astlevel' -> originName.append;
              else 
                 (*gnNameDecl.getText -> formName[];
                 formNo + '0' -> formName.put;
                 (# t: ^text; 
                 do formName.copy -> t[];
                    '.bet' -> t.append;
                    t[] -> genFile.Name;
                  #);*)
                 lastCatName -> originName;
             if);
             (if formNo=NoOfFiles then
                 gnNameDecl.getText -> t[]; t -> catName;
              else
                 gnNameDecl.gettext -> t[]; t ->  catName;
                 formNo + '0' -> catName.put;
             if);
             genFile.openWrite;
             'Generating ' -> screen.putText; genFile.name -> screen.putText;
             screen.newLine;
             (formNo,originName[],catName[],lastCatName[]) -> genHeadForm;
             catName -> lastCatName;
          #);
        closeAndReOpen:
          (#
          do debug(# do 'close and reopen' -> screen.putText; #);
             '#);' -> genFile.putText; genFile.newLine;
             gnNameDecl.gettext -> formName[];
             formNo + '0' + 1 -> formName.put;
             'FORM' -> formName.append;
             (formNo,formName) -> genTailForm;
             genFile.close;
             openForm;
          #);
        g: ^mg.Agrammar; 
        gn: ^mg.grammarName;
        gnNameDecl: ^NameDecl;
        applicationProg: @text;
        prodIdx: @integer;
        formName: ^Text;
        catName,lastCatName: @text;
        formNo: @integer;
        prodNumbersPerFile: @integer;
      enter g[]
      do debug(# do 'makepat started ' -> screen.putText #);
         ('subof','TreeLevel') -> root.getOptionName -> lastCatName;
         0 -> formNo;
         g.getGrammarName -> gn[];
         gn.getNameDecl -> gnNameDecl[];
         debug(# do 'going to open form' -> screen.putText #);
         OpenForm;
         debug(# do 'form opened' -> screen.putText #);
         (pl.noOfSons + 40) div NoOfFiles -> prodNumbersPerFile;
         debug(# do 'generating alternations' -> screen.putText #);
         pl.scan
           (#
           do (if current.symbol=mg.Alternation then
                  current[] -> generateAlternation; genFile.newLine
              if);
              debug(# do current.index -> screen.putInt; '       ' -> screen.putText  #);
           #);
         debug(# do 'finished alternation' -> screen.putText; #);
         0 -> prodidx;
         pl.scan
           (#
           do (if ((prodIdx + 1 -> prodIdx) mod prodNumbersPerFile)=0 then
                  CloseAndReOpen;
              if);
              debug(# do current.symbol -> screen.putInt; ' = ' -> screen.putText;
                      current.index -> screen.putInt; #);
              (if current.symbol
               //mg.Constructor then current[] -> generateConstructor; genFile.newLine
               //mg.ListOne
               //mg.ListZero then current[] -> generateList; genFile.newLine
              if);
           #);
         generateGrammarName;
         generateInit;
         (if formNo<NoOfFiles then
             CloseAndReOpen
         if);
         '#); ' -> genFile.putText; genFile.newLine;
         applicationProg.clear;
         gnNameDecl.gettext -> applicationProg.append;
         'prog' -> applicationProg.append;
         ('postname',applicationProg) -> root.getOptionName -> applicationProg;
         (NoOfFiles,applicationProg) -> genTailForm;
         debug(# do genfile.name -> screen.putText; ' closed' -> screen.putText #);
         genFile.close;
       #);
   NoOfFiles: @integer;
do ('splitonfiles',1) -> root.getOptionValue -> NoOfFiles;
   root[] -> generatePatterns;
#)
