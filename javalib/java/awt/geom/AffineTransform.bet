ORIGIN '_AffineTransform';
INCLUDE '~beta/javalib/java/awt/_Shape';
INCLUDE '~beta/javalib/java/lang/_String';
INCLUDE '~beta/javalib/java/awt/geom/_Point2D';
--LIB: attributes--

(* Java AffineTransform class members.
 * See _AffineTransform.bet for class declaration.
 * See http://java.sun.com/j2se/1.4.2/docs/api/java/awt/geom/AffineTransform.html
 *)
AffineTransform: _AffineTransform
  (#
     (* Public/protected fields *)

     TYPE_IDENTITY: (# exit 0 #);
     TYPE_TRANSLATION: (# exit 1 #);
     TYPE_UNIFORM_SCALE: (# exit 2 #);
     TYPE_GENERAL_SCALE: (# exit 4 #);
     TYPE_MASK_SCALE: (# exit 6 #);
     TYPE_FLIP: (# exit 64 #);
     TYPE_QUADRANT_ROTATION: (# exit 8 #);
     TYPE_GENERAL_ROTATION: (# exit 16 #);
     TYPE_MASK_ROTATION: (# exit 24 #);
     TYPE_GENERAL_TRANSFORM: (# exit 32 #);

     (* Public/protected constructors *)

     _init_D_D_D_D_D_D: cons (* constructor *)
       (# result: ^AffineTransform;
          arg1: @real;
          arg2: @real;
          arg3: @real;
          arg4: @real;
          arg5: @real;
          arg6: @real;
       enter (arg1, arg2, arg3, arg4, arg5, arg6)
       exit result[]
       #);
     _init_ArrayOfD: cons (* constructor *)
       (# result: ^AffineTransform;
          arg1: [0]@real;
       enter (arg1[])
       exit result[]
       #);
     _init_ArrayOfF: cons (* constructor *)
       (# result: ^AffineTransform;
          arg1: [0]@real32;
       enter (arg1[])
       exit result[]
       #);
     _init_AffineTransform: cons (* constructor *)
       (# result: ^AffineTransform;
          arg1: ^AffineTransform;
       enter (arg1[])
       exit result[]
       #);
     _init: cons (* constructor *)
       (# result: ^AffineTransform;
       exit result[]
       #);
     _init_F_F_F_F_F_F: cons (* constructor *)
       (# result: ^AffineTransform;
          arg1: @real32;
          arg2: @real32;
          arg3: @real32;
          arg4: @real32;
          arg5: @real32;
          arg6: @real32;
       enter (arg1, arg2, arg3, arg4, arg5, arg6)
       exit result[]
       #);

     (* Public/protected methods *)

     hashCode: proc
       (# result: @int32;
       exit result
       #);
     clone: proc
       (# result: ^Object;
       exit result[]
       #);
     equals: proc
       (# result: @boolean;
          arg1: ^Object;
       enter (arg1[])
       exit result
       #);
     toString: proc
       (# result: ^_String;
       exit result[]
       #);
     transform_ArrayOfF_I_ArrayOfD_I_I: proc (* transform *)
       (# 
          arg1: [0]@real32;
          arg2: @int32;
          arg3: [0]@real;
          arg4: @int32;
          arg5: @int32;
       enter (arg1[], arg2, arg3[], arg4, arg5)
       do 'transform' -> procname;
       #);
     transform_ArrayOfF_I_ArrayOfF_I_I: proc (* transform *)
       (# 
          arg1: [0]@real32;
          arg2: @int32;
          arg3: [0]@real32;
          arg4: @int32;
          arg5: @int32;
       enter (arg1[], arg2, arg3[], arg4, arg5)
       do 'transform' -> procname;
       #);
     transform_ArrayOfD_I_ArrayOfF_I_I: proc (* transform *)
       (# 
          arg1: [0]@real;
          arg2: @int32;
          arg3: [0]@real32;
          arg4: @int32;
          arg5: @int32;
       enter (arg1[], arg2, arg3[], arg4, arg5)
       do 'transform' -> procname;
       #);
     transform_ArrayOfD_I_ArrayOfD_I_I: proc (* transform *)
       (# 
          arg1: [0]@real;
          arg2: @int32;
          arg3: [0]@real;
          arg4: @int32;
          arg5: @int32;
       enter (arg1[], arg2, arg3[], arg4, arg5)
       do 'transform' -> procname;
       #);
     transform_ArrayOfPoint2D_I_ArrayOfPoint2D_I_I: proc (* transform *)
       (# 
          arg1: [0]^_Point2D;
          arg2: @int32;
          arg3: [0]^_Point2D;
          arg4: @int32;
          arg5: @int32;
       enter (arg1[], arg2, arg3[], arg4, arg5)
       do 'transform' -> procname;
       #);
     transform_Point2D_Point2D: proc (* transform *)
       (# result: ^_Point2D;
          arg1: ^_Point2D;
          arg2: ^_Point2D;
       enter (arg1[], arg2[])
       do 'transform' -> procname;
       exit result[]
       #);
     getType: proc
       (# result: @int32;
       exit result
       #);
     translate: proc
       (# 
          arg1: @real;
          arg2: @real;
       enter (arg1, arg2)
       #);
     concatenate: proc
       (# 
          arg1: ^AffineTransform;
       enter (arg1[])
       #);
     createInverse: proc
       (# result: ^AffineTransform;
       exit result[]
       #);
     createTransformedShape: proc
       (# result: ^_Shape;
          arg1: ^_Shape;
       enter (arg1[])
       exit result[]
       #);
     deltaTransform_Point2D_Point2D: proc (* deltaTransform *)
       (# result: ^_Point2D;
          arg1: ^_Point2D;
          arg2: ^_Point2D;
       enter (arg1[], arg2[])
       do 'deltaTransform' -> procname;
       exit result[]
       #);
     deltaTransform_ArrayOfD_I_ArrayOfD_I_I: proc (* deltaTransform *)
       (# 
          arg1: [0]@real;
          arg2: @int32;
          arg3: [0]@real;
          arg4: @int32;
          arg5: @int32;
       enter (arg1[], arg2, arg3[], arg4, arg5)
       do 'deltaTransform' -> procname;
       #);
     getDeterminant: proc
       (# result: @real;
       exit result
       #);
     getMatrix: proc
       (# 
          arg1: [0]@real;
       enter (arg1[])
       #);
     getRotateInstance_D_D_D: static_proc (* getRotateInstance *)
       (# result: ^AffineTransform;
          arg1: @real;
          arg2: @real;
          arg3: @real;
       enter (arg1, arg2, arg3)
       do 'getRotateInstance' -> procname;
       exit result[]
       #);
     getRotateInstance_D: static_proc (* getRotateInstance *)
       (# result: ^AffineTransform;
          arg1: @real;
       enter (arg1)
       do 'getRotateInstance' -> procname;
       exit result[]
       #);
     getScaleInstance: static_proc
       (# result: ^AffineTransform;
          arg1: @real;
          arg2: @real;
       enter (arg1, arg2)
       exit result[]
       #);
     getScaleX: proc
       (# result: @real;
       exit result
       #);
     getScaleY: proc
       (# result: @real;
       exit result
       #);
     getShearInstance: static_proc
       (# result: ^AffineTransform;
          arg1: @real;
          arg2: @real;
       enter (arg1, arg2)
       exit result[]
       #);
     getShearX: proc
       (# result: @real;
       exit result
       #);
     getShearY: proc
       (# result: @real;
       exit result
       #);
     getTranslateInstance: static_proc
       (# result: ^AffineTransform;
          arg1: @real;
          arg2: @real;
       enter (arg1, arg2)
       exit result[]
       #);
     getTranslateX: proc
       (# result: @real;
       exit result
       #);
     getTranslateY: proc
       (# result: @real;
       exit result
       #);
     inverseTransform_ArrayOfD_I_ArrayOfD_I_I: proc (* inverseTransform *)
       (# 
          arg1: [0]@real;
          arg2: @int32;
          arg3: [0]@real;
          arg4: @int32;
          arg5: @int32;
       enter (arg1[], arg2, arg3[], arg4, arg5)
       do 'inverseTransform' -> procname;
       #);
     inverseTransform_Point2D_Point2D: proc (* inverseTransform *)
       (# result: ^_Point2D;
          arg1: ^_Point2D;
          arg2: ^_Point2D;
       enter (arg1[], arg2[])
       do 'inverseTransform' -> procname;
       exit result[]
       #);
     isIdentity: proc
       (# result: @boolean;
       exit result
       #);
     preConcatenate: proc
       (# 
          arg1: ^AffineTransform;
       enter (arg1[])
       #);
     rotate_D_D_D: proc (* rotate *)
       (# 
          arg1: @real;
          arg2: @real;
          arg3: @real;
       enter (arg1, arg2, arg3)
       do 'rotate' -> procname;
       #);
     rotate_D: proc (* rotate *)
       (# 
          arg1: @real;
       enter (arg1)
       do 'rotate' -> procname;
       #);
     scale: proc
       (# 
          arg1: @real;
          arg2: @real;
       enter (arg1, arg2)
       #);
     setToIdentity: proc
       (# 
       #);
     setToRotation_D: proc (* setToRotation *)
       (# 
          arg1: @real;
       enter (arg1)
       do 'setToRotation' -> procname;
       #);
     setToRotation_D_D_D: proc (* setToRotation *)
       (# 
          arg1: @real;
          arg2: @real;
          arg3: @real;
       enter (arg1, arg2, arg3)
       do 'setToRotation' -> procname;
       #);
     setToScale: proc
       (# 
          arg1: @real;
          arg2: @real;
       enter (arg1, arg2)
       #);
     setToShear: proc
       (# 
          arg1: @real;
          arg2: @real;
       enter (arg1, arg2)
       #);
     setToTranslation: proc
       (# 
          arg1: @real;
          arg2: @real;
       enter (arg1, arg2)
       #);
     setTransform_AffineTransform: proc (* setTransform *)
       (# 
          arg1: ^AffineTransform;
       enter (arg1[])
       do 'setTransform' -> procname;
       #);
     setTransform_D_D_D_D_D_D: proc (* setTransform *)
       (# 
          arg1: @real;
          arg2: @real;
          arg3: @real;
          arg4: @real;
          arg5: @real;
          arg6: @real;
       enter (arg1, arg2, arg3, arg4, arg5, arg6)
       do 'setTransform' -> procname;
       #);
     shear: proc
       (# 
          arg1: @real;
          arg2: @real;
       enter (arg1, arg2)
       #);
  do 'java/awt/geom/AffineTransform' -> className;
     INNER;
  #);

