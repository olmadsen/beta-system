ORIGIN '_BufferedImage';
INCLUDE '~beta/javalib/java/awt/_Rectangle';
INCLUDE '~beta/javalib/java/awt/image/_ImageProducer';
INCLUDE '~beta/javalib/java/awt/image/_TileObserver';
INCLUDE '~beta/javalib/java/awt/image/_WritableRaster';
INCLUDE '~beta/javalib/java/awt/image/_Raster';
INCLUDE '~beta/javalib/java/awt/image/_IndexColorModel';
INCLUDE '~beta/javalib/java/awt/_Graphics2D';
INCLUDE '~beta/javalib/java/awt/_Point';
INCLUDE '~beta/javalib/java/awt/image/_ColorModel';
INCLUDE '~beta/javalib/java/awt/_Graphics';
INCLUDE '~beta/javalib/java/awt/image/_SampleModel';
INCLUDE '~beta/javalib/java/util/_Vector';
INCLUDE '~beta/javalib/java/util/_Hashtable';
INCLUDE '~beta/javalib/java/lang/_String';
INCLUDE '~beta/javalib/java/awt/image/_ImageObserver';
INCLUDE '~beta/javalib/java/awt/_Image';
--LIB: attributes--

(* Java BufferedImage class members.
 * See _BufferedImage.bet for class declaration.
 * See http://java.sun.com/j2se/1.4.2/docs/api/java/awt/image/BufferedImage.html
 *)
BufferedImage: _BufferedImage
  (#
     (* Public/protected fields *)

     (* STATIC: *)
     TYPE_CUSTOM: @int32;
     (* STATIC: *)
     TYPE_INT_RGB: @int32;
     (* STATIC: *)
     TYPE_INT_ARGB: @int32;
     (* STATIC: *)
     TYPE_INT_ARGB_PRE: @int32;
     (* STATIC: *)
     TYPE_INT_BGR: @int32;
     (* STATIC: *)
     TYPE_3BYTE_BGR: @int32;
     (* STATIC: *)
     TYPE_4BYTE_ABGR: @int32;
     (* STATIC: *)
     TYPE_4BYTE_ABGR_PRE: @int32;
     (* STATIC: *)
     TYPE_USHORT_565_RGB: @int32;
     (* STATIC: *)
     TYPE_USHORT_555_RGB: @int32;
     (* STATIC: *)
     TYPE_BYTE_GRAY: @int32;
     (* STATIC: *)
     TYPE_USHORT_GRAY: @int32;
     (* STATIC: *)
     TYPE_BYTE_BINARY: @int32;
     (* STATIC: *)
     TYPE_BYTE_INDEXED: @int32;

     (* Public/protected constructors *)

     _init_ColorModel_WritableRaster_Z_Hashtable: cons (* constructor *)
       (# result: ^BufferedImage;
          arg1: ^_ColorModel;
          arg2: ^_WritableRaster;
          arg3: @boolean;
          arg4: ^_Hashtable;
       enter (arg1[], arg2[], arg3, arg4[])
       exit result[]
       #);
     _init_I_I_I_IndexColorModel: cons (* constructor *)
       (# result: ^BufferedImage;
          arg1: @int32;
          arg2: @int32;
          arg3: @int32;
          arg4: ^_IndexColorModel;
       enter (arg1, arg2, arg3, arg4[])
       exit result[]
       #);
     _init_I_I_I: cons (* constructor *)
       (# result: ^BufferedImage;
          arg1: @int32;
          arg2: @int32;
          arg3: @int32;
       enter (arg1, arg2, arg3)
       exit result[]
       #);

     (* Public/protected methods *)

     getProperty_String_ImageObserver: proc (* getProperty *)
       (# result: ^Object;
          arg1: ^_String;
          arg2: ^_ImageObserver;
       enter (arg1[], arg2[])
       do 'getProperty' -> procname;
       exit result[]
       #);
     getProperty_String: proc (* getProperty *)
       (# result: ^Object;
          arg1: ^_String;
       enter (arg1[])
       do 'getProperty' -> procname;
       exit result[]
       #);
     toString: proc
       (# result: ^_String;
       exit result[]
       #);
     flush: proc
       (# 
       #);
     getType: proc
       (# result: @int32;
       exit result
       #);
     getColorModel: proc
       (# result: ^_ColorModel;
       exit result[]
       #);
     getGraphics: proc
       (# result: ^_Graphics;
       exit result[]
       #);
     getHeight: proc (* getHeight *)
       (# result: @int32;
       do 'getHeight' -> procname;
       exit result
       #);
     getHeight_ImageObserver: proc (* getHeight *)
       (# result: @int32;
          arg1: ^_ImageObserver;
       enter (arg1[])
       do 'getHeight' -> procname;
       exit result
       #);
     getWidth: proc (* getWidth *)
       (# result: @int32;
       do 'getWidth' -> procname;
       exit result
       #);
     getWidth_ImageObserver: proc (* getWidth *)
       (# result: @int32;
          arg1: ^_ImageObserver;
       enter (arg1[])
       do 'getWidth' -> procname;
       exit result
       #);
     createGraphics: proc
       (# result: ^_Graphics2D;
       exit result[]
       #);
     getSource: proc
       (# result: ^_ImageProducer;
       exit result[]
       #);
     coerceData: proc
       (# 
          arg1: @boolean;
       enter (arg1)
       #);
     getAlphaRaster: proc
       (# result: ^_WritableRaster;
       exit result[]
       #);
     getRGB_I_I: proc (* getRGB *)
       (# result: @int32;
          arg1: @int32;
          arg2: @int32;
       enter (arg1, arg2)
       do 'getRGB' -> procname;
       exit result
       #);
     getRGB_I_I_I_I_ArrayOfI_I_I: proc (* getRGB *)
       (# result: [0]@int32;
          arg1: @int32;
          arg2: @int32;
          arg3: @int32;
          arg4: @int32;
          arg5: [0]@int32;
          arg6: @int32;
          arg7: @int32;
       enter (arg1, arg2, arg3, arg4, arg5[], arg6, arg7)
       do 'getRGB' -> procname;
       exit result[]
       #);
     isAlphaPremultiplied: proc
       (# result: @boolean;
       exit result
       #);
     getMinX: proc
       (# result: @int32;
       exit result
       #);
     getMinY: proc
       (# result: @int32;
       exit result
       #);
     getSampleModel: proc
       (# result: ^_SampleModel;
       exit result[]
       #);
     getRaster: proc
       (# result: ^_WritableRaster;
       exit result[]
       #);
     addTileObserver: proc
       (# 
          arg1: ^_TileObserver;
       enter (arg1[])
       #);
     copyData: proc
       (# result: ^_WritableRaster;
          arg1: ^_WritableRaster;
       enter (arg1[])
       exit result[]
       #);
     getData_Rectangle: proc (* getData *)
       (# result: ^_Raster;
          arg1: ^_Rectangle;
       enter (arg1[])
       do 'getData' -> procname;
       exit result[]
       #);
     getData: proc (* getData *)
       (# result: ^_Raster;
       do 'getData' -> procname;
       exit result[]
       #);
     getMinTileX: proc
       (# result: @int32;
       exit result
       #);
     getMinTileY: proc
       (# result: @int32;
       exit result
       #);
     getNumXTiles: proc
       (# result: @int32;
       exit result
       #);
     getNumYTiles: proc
       (# result: @int32;
       exit result
       #);
     getPropertyNames: proc
       (# result: [0]^_String;
       exit result[]
       #);
     getSources: proc
       (# result: ^_Vector;
       exit result[]
       #);
     getSubimage: proc
       (# result: ^BufferedImage;
          arg1: @int32;
          arg2: @int32;
          arg3: @int32;
          arg4: @int32;
       enter (arg1, arg2, arg3, arg4)
       exit result[]
       #);
     getTile: proc
       (# result: ^_Raster;
          arg1: @int32;
          arg2: @int32;
       enter (arg1, arg2)
       exit result[]
       #);
     getTileGridXOffset: proc
       (# result: @int32;
       exit result
       #);
     getTileGridYOffset: proc
       (# result: @int32;
       exit result
       #);
     getTileHeight: proc
       (# result: @int32;
       exit result
       #);
     getTileWidth: proc
       (# result: @int32;
       exit result
       #);
     getWritableTile: proc
       (# result: ^_WritableRaster;
          arg1: @int32;
          arg2: @int32;
       enter (arg1, arg2)
       exit result[]
       #);
     getWritableTileIndices: proc
       (# result: [0]^_Point;
       exit result[]
       #);
     hasTileWriters: proc
       (# result: @boolean;
       exit result
       #);
     isTileWritable: proc
       (# result: @boolean;
          arg1: @int32;
          arg2: @int32;
       enter (arg1, arg2)
       exit result
       #);
     releaseWritableTile: proc
       (# 
          arg1: @int32;
          arg2: @int32;
       enter (arg1, arg2)
       #);
     removeTileObserver: proc
       (# 
          arg1: ^_TileObserver;
       enter (arg1[])
       #);
     setData: proc
       (# 
          arg1: ^_Raster;
       enter (arg1[])
       #);
     setRGB_I_I_I: proc (* setRGB *)
       (# 
          arg1: @int32;
          arg2: @int32;
          arg3: @int32;
       enter (arg1, arg2, arg3)
       do 'setRGB' -> procname;
       #);
     setRGB_I_I_I_I_ArrayOfI_I_I: proc (* setRGB *)
       (# 
          arg1: @int32;
          arg2: @int32;
          arg3: @int32;
          arg4: @int32;
          arg5: [0]@int32;
          arg6: @int32;
          arg7: @int32;
       enter (arg1, arg2, arg3, arg4, arg5[], arg6, arg7)
       do 'setRGB' -> procname;
       #);
  do 'java/awt/image/BufferedImage' -> className;
     INNER;
  #);

