ORIGIN '_String';
INCLUDE '~beta/javalib/java/lang/_StringBuffer';
INCLUDE '~beta/javalib/java/lang/_CharSequence';
INCLUDE '~beta/javalib/java/util/_Locale';
INCLUDE '~beta/javalib/java/util/_Comparator';
--LIB: attributes--

(* Java String class members.
 * See _String for class declaration.
 * See http://java.sun.com/j2se/1.4.2/docs/api/java/lang/String.html
 *)
String: _String
  (#
     (* Public/protected fields *)

     (* STATIC: *)
     CASE_INSENSITIVE_ORDER: ^_Comparator;

     (* Public/protected constructors *)

     _init: cons (* constructor *)
       (# result: ^String;
       exit result[]
       #);
     _init_String: cons (* constructor *)
       (# result: ^String;
          arg1: ^String;
       enter (arg1[])
       exit result[]
       #);
     _init_ArrayOfB_I_I_String: cons (* constructor *)
       (# result: ^String;
          arg1: [0]@int8;
          arg2: @int32;
          arg3: @int32;
          arg4: ^String;
       enter (arg1[], arg2, arg3, arg4[])
       exit result[]
       #);
     _init_ArrayOfB_String: cons (* constructor *)
       (# result: ^String;
          arg1: [0]@int8;
          arg2: ^String;
       enter (arg1[], arg2[])
       exit result[]
       #);
     _init_StringBuffer: cons (* constructor *)
       (# result: ^String;
          arg1: ^_StringBuffer;
       enter (arg1[])
       exit result[]
       #);
     _init_ArrayOfC_I_I: cons (* constructor *)
       (# result: ^String;
          arg1: [0]@char;
          arg2: @int32;
          arg3: @int32;
       enter (arg1[], arg2, arg3)
       exit result[]
       #);
     _init_ArrayOfC: cons (* constructor *)
       (# result: ^String;
          arg1: [0]@char;
       enter (arg1[])
       exit result[]
       #);
     _init_ArrayOfB_I_I_I: cons (* constructor *)
       (# result: ^String;
          arg1: [0]@int8;
          arg2: @int32;
          arg3: @int32;
          arg4: @int32;
       enter (arg1[], arg2, arg3, arg4)
       exit result[]
       #);
     _init_ArrayOfB_I_I: cons (* constructor *)
       (# result: ^String;
          arg1: [0]@int8;
          arg2: @int32;
          arg3: @int32;
       enter (arg1[], arg2, arg3)
       exit result[]
       #);
     _init_ArrayOfB: cons (* constructor *)
       (# result: ^String;
          arg1: [0]@int8;
       enter (arg1[])
       exit result[]
       #);
     _init_ArrayOfB_I: cons (* constructor *)
       (# result: ^String;
          arg1: [0]@int8;
          arg2: @int32;
       enter (arg1[], arg2)
       exit result[]
       #);

     (* Public/protected methods *)

     hashCode: proc
       (# result: @int32;
       exit result
       #);
     compareTo_String: proc (* compareTo *)
       (# result: @int32;
          arg1: ^String;
       enter (arg1[])
       do 'compareTo' -> procname;
       exit result
       #);
     compareTo_Object: proc (* compareTo *)
       (# result: @int32;
          arg1: ^Object;
       enter (arg1[])
       do 'compareTo' -> procname;
       exit result
       #);
     equals: proc
       (# result: @boolean;
          arg1: ^Object;
       enter (arg1[])
       exit result
       #);
     toString: proc
       (# result: ^String;
       exit result[]
       #);
     charAt: proc
       (# result: @char;
          arg1: @int32;
       enter (arg1)
       exit result
       #);
     compareToIgnoreCase: proc
       (# result: @int32;
          arg1: ^String;
       enter (arg1[])
       exit result
       #);
     concat: proc
       (# result: ^String;
          arg1: ^String;
       enter (arg1[])
       exit result[]
       #);
     contentEquals: proc
       (# result: @boolean;
          arg1: ^_StringBuffer;
       enter (arg1[])
       exit result
       #);
     copyValueOf_ArrayOfC: static_proc (* copyValueOf *)
       (# result: ^String;
          arg1: [0]@char;
       enter (arg1[])
       do 'copyValueOf' -> procname;
       exit result[]
       #);
     copyValueOf_ArrayOfC_I_I: static_proc (* copyValueOf *)
       (# result: ^String;
          arg1: [0]@char;
          arg2: @int32;
          arg3: @int32;
       enter (arg1[], arg2, arg3)
       do 'copyValueOf' -> procname;
       exit result[]
       #);
     endsWith: proc
       (# result: @boolean;
          arg1: ^String;
       enter (arg1[])
       exit result
       #);
     equalsIgnoreCase: proc
       (# result: @boolean;
          arg1: ^String;
       enter (arg1[])
       exit result
       #);
     getBytes_I_I_ArrayOfB_I: proc (* getBytes *)
       (# 
          arg1: @int32;
          arg2: @int32;
          arg3: [0]@int8;
          arg4: @int32;
       enter (arg1, arg2, arg3[], arg4)
       do 'getBytes' -> procname;
       #);
     getBytes_String: proc (* getBytes *)
       (# result: [0]@int8;
          arg1: ^String;
       enter (arg1[])
       do 'getBytes' -> procname;
       exit result[]
       #);
     getBytes: proc (* getBytes *)
       (# result: [0]@int8;
       do 'getBytes' -> procname;
       exit result[]
       #);
     getChars: proc
       (# 
          arg1: @int32;
          arg2: @int32;
          arg3: [0]@char;
          arg4: @int32;
       enter (arg1, arg2, arg3[], arg4)
       #);
     indexOf_I_I: proc (* indexOf *)
       (# result: @int32;
          arg1: @int32;
          arg2: @int32;
       enter (arg1, arg2)
       do 'indexOf' -> procname;
       exit result
       #);
     indexOf_String: proc (* indexOf *)
       (# result: @int32;
          arg1: ^String;
       enter (arg1[])
       do 'indexOf' -> procname;
       exit result
       #);
     indexOf_I: proc (* indexOf *)
       (# result: @int32;
          arg1: @int32;
       enter (arg1)
       do 'indexOf' -> procname;
       exit result
       #);
     indexOf_String_I: proc (* indexOf *)
       (# result: @int32;
          arg1: ^String;
          arg2: @int32;
       enter (arg1[], arg2)
       do 'indexOf' -> procname;
       exit result
       #);
     intern: proc
       (# result: ^String;
       exit result[]
       #);
     lastIndexOf_String: proc (* lastIndexOf *)
       (# result: @int32;
          arg1: ^String;
       enter (arg1[])
       do 'lastIndexOf' -> procname;
       exit result
       #);
     lastIndexOf_I: proc (* lastIndexOf *)
       (# result: @int32;
          arg1: @int32;
       enter (arg1)
       do 'lastIndexOf' -> procname;
       exit result
       #);
     lastIndexOf_String_I: proc (* lastIndexOf *)
       (# result: @int32;
          arg1: ^String;
          arg2: @int32;
       enter (arg1[], arg2)
       do 'lastIndexOf' -> procname;
       exit result
       #);
     lastIndexOf_I_I: proc (* lastIndexOf *)
       (# result: @int32;
          arg1: @int32;
          arg2: @int32;
       enter (arg1, arg2)
       do 'lastIndexOf' -> procname;
       exit result
       #);
     length: proc
       (# result: @int32;
       exit result
       #);
     matches: proc
       (# result: @boolean;
          arg1: ^String;
       enter (arg1[])
       exit result
       #);
     regionMatches_I_String_I_I: proc (* regionMatches *)
       (# result: @boolean;
          arg1: @int32;
          arg2: ^String;
          arg3: @int32;
          arg4: @int32;
       enter (arg1, arg2[], arg3, arg4)
       do 'regionMatches' -> procname;
       exit result
       #);
     regionMatches_Z_I_String_I_I: proc (* regionMatches *)
       (# result: @boolean;
          arg1: @boolean;
          arg2: @int32;
          arg3: ^String;
          arg4: @int32;
          arg5: @int32;
       enter (arg1, arg2, arg3[], arg4, arg5)
       do 'regionMatches' -> procname;
       exit result
       #);
     replace: proc
       (# result: ^String;
          arg1: @char;
          arg2: @char;
       enter (arg1, arg2)
       exit result[]
       #);
     replaceAll: proc
       (# result: ^String;
          arg1: ^String;
          arg2: ^String;
       enter (arg1[], arg2[])
       exit result[]
       #);
     replaceFirst: proc
       (# result: ^String;
          arg1: ^String;
          arg2: ^String;
       enter (arg1[], arg2[])
       exit result[]
       #);
     split_String_I: proc (* split *)
       (# result: [0]^String;
          arg1: ^String;
          arg2: @int32;
       enter (arg1[], arg2)
       do 'split' -> procname;
       exit result[]
       #);
     split_String: proc (* split *)
       (# result: [0]^String;
          arg1: ^String;
       enter (arg1[])
       do 'split' -> procname;
       exit result[]
       #);
     startsWith_String: proc (* startsWith *)
       (# result: @boolean;
          arg1: ^String;
       enter (arg1[])
       do 'startsWith' -> procname;
       exit result
       #);
     startsWith_String_I: proc (* startsWith *)
       (# result: @boolean;
          arg1: ^String;
          arg2: @int32;
       enter (arg1[], arg2)
       do 'startsWith' -> procname;
       exit result
       #);
     subSequence: proc
       (# result: ^_CharSequence;
          arg1: @int32;
          arg2: @int32;
       enter (arg1, arg2)
       exit result[]
       #);
     substring_I: proc (* substring *)
       (# result: ^String;
          arg1: @int32;
       enter (arg1)
       do 'substring' -> procname;
       exit result[]
       #);
     substring_I_I: proc (* substring *)
       (# result: ^String;
          arg1: @int32;
          arg2: @int32;
       enter (arg1, arg2)
       do 'substring' -> procname;
       exit result[]
       #);
     toCharArray: proc
       (# result: [0]@char;
       exit result[]
       #);
     toLowerCase_Locale: proc (* toLowerCase *)
       (# result: ^String;
          arg1: ^_Locale;
       enter (arg1[])
       do 'toLowerCase' -> procname;
       exit result[]
       #);
     toLowerCase: proc (* toLowerCase *)
       (# result: ^String;
       do 'toLowerCase' -> procname;
       exit result[]
       #);
     toUpperCase_Locale: proc (* toUpperCase *)
       (# result: ^String;
          arg1: ^_Locale;
       enter (arg1[])
       do 'toUpperCase' -> procname;
       exit result[]
       #);
     toUpperCase: proc (* toUpperCase *)
       (# result: ^String;
       do 'toUpperCase' -> procname;
       exit result[]
       #);
     trim: proc
       (# result: ^String;
       exit result[]
       #);
     valueOf_ArrayOfC_I_I: static_proc (* valueOf *)
       (# result: ^String;
          arg1: [0]@char;
          arg2: @int32;
          arg3: @int32;
       enter (arg1[], arg2, arg3)
       do 'valueOf' -> procname;
       exit result[]
       #);
     valueOf_J: static_proc (* valueOf *)
       (# result: ^String;
          arg1: @int64;
       enter (arg1)
       do 'valueOf' -> procname;
       exit result[]
       #);
     valueOf_Object: static_proc (* valueOf *)
       (# result: ^String;
          arg1: ^Object;
       enter (arg1[])
       do 'valueOf' -> procname;
       exit result[]
       #);
     valueOf_Z: static_proc (* valueOf *)
       (# result: ^String;
          arg1: @boolean;
       enter (arg1)
       do 'valueOf' -> procname;
       exit result[]
       #);
     valueOf_I: static_proc (* valueOf *)
       (# result: ^String;
          arg1: @int32;
       enter (arg1)
       do 'valueOf' -> procname;
       exit result[]
       #);
     valueOf_ArrayOfC: static_proc (* valueOf *)
       (# result: ^String;
          arg1: [0]@char;
       enter (arg1[])
       do 'valueOf' -> procname;
       exit result[]
       #);
     valueOf_C: static_proc (* valueOf *)
       (# result: ^String;
          arg1: @char;
       enter (arg1)
       do 'valueOf' -> procname;
       exit result[]
       #);
     valueOf_D: static_proc (* valueOf *)
       (# result: ^String;
          arg1: @real;
       enter (arg1)
       do 'valueOf' -> procname;
       exit result[]
       #);
     valueOf_F: static_proc (* valueOf *)
       (# result: ^String;
          arg1: @real32;
       enter (arg1)
       do 'valueOf' -> procname;
       exit result[]
       #);

     (* Inner classes *)

  do 'java/lang/String' -> className;
     INNER;
  #);

