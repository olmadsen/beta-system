ORIGIN '~beta/basiclib/external';


BUILD
macosx  '$$/FSpCompat.o' 'external/FSpCompat.c' '$CC -D$$ -c -o $0 $1'
default ':$$/FSpCompat.obj' ':external/FSpCompat.c' 'mrc -proto strict -shared_lib_export on -o $0 $1';

BUILD 
macosx '$$/FullPath.o' 'external/FullPath.c' '$CC -D$$ -c -o $0 $1'
default ':$$/FullPath.obj' ':external/FullPath.c' 'mrc -proto strict -shared_lib_export on -o $0 $1';
BODY 'private/texteditbody';

BUILD
macosx  '$$/directory.o' 'private/external/directory.c' '$CC -D$$ -c -o $0 $1'
default ':$$/directory.obj' ':private:external/directory.c' 'mrc -shared_lib_export on -proto strict -o $0 $1';





-- CStructLib: Attributes --

(*
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-96
 *       All rights reserved.
 *
 ****** Patterns for external interface *****
 * 
 * In CStructLib, the operations on a cStruct are defined.
 * The pattern ExternalRecord is an interface to e.g. CStruct objects
 * allocated from C or other external languages.
 *)
(* idx=1 *)
GetByte: 
  (# byteoffset: @integer 
  enter byteoffset 
  do byteoffset->CHK 
  exit byteoffset -> R.%getByte
  (* Above line tos_converted from: exit (R,byteoffset)->TOS'%inxGetByte' *)
  #);
PutByte: 
  (# val,byteoffset: @integer
  enter(byteoffset,val) 
  do byteoffset->CHK; (val, byteoffset) -> R.%putByte
  (* Above line tos_converted from: do byteoffset->CHK; (R,byteoffset,val) ->TOS'%inxPutByte' *)
  #);
GetShort: 
  (# byteoffset: @integer
  enter byteoffset do byteoffset->CHK exit ((byteoffset) div 2) -> R.%getShort
  (* Above line tos_converted from: enter byteoffset do byteoffset->CHK exit (R,byteoffset)->TOS'%inxGetShort' *)
  #);
PutShort: 
  (# val,byteoffset: @integer
  enter(byteoffset,val) 
  do byteoffset->CHK; (val, (byteoffset) div 2) -> R.%putShort
  (* Above line tos_converted from: do byteoffset->CHK; (R,byteoffset,val) ->TOS'%inxPutShort' *)
  #);
GetSignedShort: 
  (# byteoffset: @integer
  enter byteoffset 
  exit %getSignedShortAt(@@R[1]+byteoffset)
  #);
GetLong: 
  (# byteoffset: @integer
  enter byteoffset
  do byteoffset->CHK
  exit ((byteoffset) div 4) -> R.%getLong
  (* Above line tos_converted from: exit (R,byteoffset)->TOS'%inxGetLong' *)
  #);
PutLong: 
  (# val,byteoffset: @integer
  enter(byteoffset,val)
  do byteoffset->CHK;
     (val, (byteoffset) div 4) -> R.%putLong
     (* Above line tos_converted from: (R,byteoffset,val) ->TOS'%inxPutLong' *)
  #);
Byte: (* Used for declaring CStruct fields *)
  (# p: @pos; pos:< IntegerObject; val: @integer;
     set: @(# 
           enter val 
           do (val, p) -> R.%putByte 
           (* Above line tos_converted from: do (R,p,val)->TOS'%inxPutByte' *)
           #);
  enter set
  exit p -> R.%getByte
  (* Above line tos_converted from: exit (R,p)->TOS'%inxGetByte' *)
  #);
Short: (* Used for declaring CStruct fields *)
  (# p: @pos; pos:< IntegerObject; val: @integer;
     set: @(# 
           enter val 
           do (val, (p) div 2) -> R.%putShort 
           (* Above line tos_converted from: do (R,p,val)->TOS'%inxPutShort' *)
           #);
  enter set
  exit ((p) div 2) -> R.%getShort
  (* Above line tos_converted from: exit (R,p)->TOS'%inxGetShort' *)
  #);
SignedShort: 
  (# p: @pos; pos:< IntegerObject; val: @integer;
     set: @(# 
           enter val 
           do (val, (p) div 2) -> R.%putShort
           (* Above line tos_converted from: do (R,p,val)->TOS'%inxPutShort' *)
           #);
  enter set
  exit %getSignedShortAt(@@R[1]+p)
  #);
Long: (* Used for declaring CStruct fields *)
  (# p: @pos; pos:< IntegerObject; val: @integer;
     set: @(# 
           enter val 
           do (val, (p) div 4) -> R.%putLong 
           (* Above line tos_converted from: do (R,p,val)->TOS'%inxPutLong' *)
           #);
  enter set
  exit ((p) div 4) -> R.%getLong
  (* Above line tos_converted from: exit (R,p)->TOS'%inxGetLong' *)
  #);



-- Lib: Attributes --
NewControl: External
  (# theWindow,refCon,controlHandle: @Integer;
     boundsRect: ^QRect;
     title: [1] @Char;
     visible: @Boolean;
     value,min,max,prodId: @ShortInt;
     
  enter (theWindow,boundsRect[],title,visible,value,min,max,prodId,refCon)
  do '$A954'->PascalTrap; 
  exit controlHandle
  #);
NIL: (# exit 0 #);
Short2Int:
  (# int: @Integer; 
  enter int
  do (int,0)->int.%putShort; 
  (* Above line tos_converted from: do (@@int,int)->tos'%putShort[0]'; *)
     (0->int.%getSignedShort)->int
     (* Above line tos_converted from: @@int->tos'%adrGetSignedShort'->int *)
  exit int
  #);
getqd: (* returns startaddress of global variables *) External
  (# theqd: @Integer;  exit theqd #);
LongInt: CStruct
  (# ByteSize::< (# do 4->Value;  #);
     loWord: Short (# Pos::< (# do 2->Value;  #);  #);
     hiWord: Short (# Pos::< (# do 0->Value;  #);  #);
     
  enter R[1]
  exit R[1]
  #);
CharRef: CStruct
  (# ByteSize::< (# do 2->Value;  #)
  enter (# val: @Integer;  enter val do (0,val)->putByte;  #)
  exit 0->getByte
  #);
ShortRef: CStruct
  (# ByteSize::< (# do 2->Value;  #)
  enter (# val: @Integer;  enter val do (0,val)->putShort;  #)
  exit 0->getShort
  #);
ByteRef: CStruct
  (# ByteSize::< (# do 1->Value;  #)
  enter (# val: @Integer;  enter val do (0,val)->putByte;  #)
  exit 0->getByte
  #);
  
QRect: Data
	(# top: @int16;
	   left: @int16;
	   bottom: @int16;
	   right: @int16;
	#);
MacRect: Com
	(# r: @QRect;
	enter ((r.left, r.top), (r.right, r.bottom))
	exit ((r.left, r.top), (r.right, r.bottom))
	#);
QPoint: Data
	(# v: @int16;
	   h: @int16;
	#);	
MacPoint: COM
  (# p: @QPoint;
     v:
	   (#
	   enter p.v
	   exit p.v
	   #);
	 h:
	    (#
		enter p.h
		exit p.h
		#);
     SetPoint: (# enter (p.h, p.v) #);
     GetPoint: (# exit (p.h, p.v) #);
       
     Set:
	 	(# value: @int32u;
		enter value
		do value %band 0xFFFF -> p.h;
		   value %srl 16 -> p.v;
		#);
  enter Set
  exit (p.v %sll 16) %bor p.h
  #);
PascalString: CStruct
	(# ByteSize::< (# do 256->Value; INNER ;  #);
		Length: (# exit 0->GetByte #);
		SetText: 
			(# t: ^Text;  enter t[] 
			do (if t.lgth <= 255 then
					(if t.lgth > 0 then
						(0,t.lgth)->PutByte; (@@ t.T[1],@@ R[1]+1,t.lgth)->BlockMove; 
					else
						(0, 0) -> PutByte;
					if);
				else
					Exception
						(# 
						do 'length of a PascalString\ncannot exceed 255\n'->msg.Append; 
						#);       
				if);     
			#);
		GetText:
			(# t: ^Text;
				len: @Integer; 
			do &Text[]->t[];
   			Length->len;
				(if len > 0 then 
					 len->t.T.New; 
					 len->t.lgth->t.pos; 
					 (@@ R[1]+1,@@ t.T[1],len)->BlockMove;  
				if)
			exit t[]
			#);
	
	enter SetText
	exit GetText
	#);
  
  
ToolboxRecord: ExternalRecord
	(* super-pattern for describing record-structures 
	 *	allocated by the toolbox
	 *)
	(# initFromHandle:
			(# h: @integer;
			enter h
			do (%getLongAt(h)) -> ptr;
			(* Above line tos_converted from: do h -> TOS'%adrGetLong' -> ptr; *)
			#);
		Rect: DoubleLong
			(# val: @Integer;
				Top: @
                             (# set: @(# 
                                      enter val 
                                      do (val) %putShortAt(ptr+p+2*0);
                                      (* Above line tos_converted from: do (ptr+p,val)->TOS'%putShort[0]'; *)
                                      #)
					enter set
					exit (%getSignedShortAt(ptr+p))
					(* Above line tos_converted from: exit ptr+p->TOS'%adrGetSignedShort' *)
					#);
				Left: @
                             (# set: @(# 
                                      enter val 
                                      do (val) %putShortAt(ptr+p+2+2*0); 
                                      (* Above line tos_converted from: do (ptr+p+2,val)->TOS'%putShort[0]'; *)
                                      #)
					enter set
					exit ((%getSignedShortAt(ptr+p+2)))
					(* Above line tos_converted from: exit (ptr+p+2)->TOS'%adrGetSignedShort' *)
					#);
				Bottom: @
                             (# set: @(# 
                                      enter val 
                                      do (val) %putShortAt(ptr+p+4+2*0);
                                      (* Above line tos_converted from: do (ptr+p+4,val)->TOS'%putShort[0]'; *)
                                      #)
					enter set
					exit ((%getSignedShortAt(ptr+p+4)))
					(* Above line tos_converted from: exit (ptr+p+4)->TOS'%adrGetSignedShort' *)
					#);
				Right: @
                             (# set: @(# 
                                      enter val 
                                      do (val) %putShortAt(ptr+p+6+2*0);
                                      (* Above line tos_converted from: do (ptr+p+6,val)->TOS'%putShort[0]'; *)
                                      #)
					enter set
					exit ((%getSignedShortAt(ptr+p+6)))
					(* Above line tos_converted from: exit (ptr+p+6)->TOS'%adrGetSignedShort' *)
					#);
				TopLeft: @
                             (# set: @(# 
                                      enter val 
                                      do (val) %putLongAt(ptr+p);
                                      (* Above line tos_converted from: do (ptr+p,val)->TOS'%putLong'; *)
                                      #) 
					enter set
					exit (%getLongAt(ptr+p)) 
					(* Above line tos_converted from: exit ptr+p->TOS'%adrGetLong' *)
					#);
				BottomRight:
                             (# set: @(# 
                                      enter val 
                                      do (val) %putLongAt(ptr+p+4); 
                                      (* Above line tos_converted from: do (ptr+p+4,val)->TOS'%putLong'; *)
                                      #)
					enter  set
					exit ((%getLongAt(ptr+p+4))) 
					(* Above line tos_converted from: exit (ptr+p+4)->TOS'%adrGetLong' *)
					#);
			#);
		PString:
			(# p: @pos; pos:< IntegerValue;
				
                           length: @(# 
                                    exit (%getByteAt(ptr+p)) 
                                    (* Above line tos_converted from: exit ptr+p->TOS'%adrGetByte' *)
                                    #);
				setText: @
					(*
					 * This operation can cause a garbage collection.
					 *)
					(# t: ^Text;  enter t[] 
					do (if t[] <> NONE then
							(if t.lgth <= 255 then
									(if t.lgth > 0 then
										(t.lgth) %putByteAt(ptr+p+0);
										(* Above line tos_converted from: (ptr+p, t.lgth)->TOS'%putByte[0]'; *)
									 	(@@t.T[1], ptr+p+1, t.lgth)->BlockMove;
									else
										(0) %putByteAt(ptr+p+0);
										(* Above line tos_converted from: (ptr+p, 0)->TOS'%putByte[0]'; *)
									if);
							else
								Exception
									(# 
									do 'length of a PascalString\ncannot exceed 255\n'->msg.Append; 
									#);       
							if);
						else
							(0) %putByteAt(ptr+p+0);
							(* Above line tos_converted from: (ptr+p, 0)->TOS'%putByte[0]'; *)
						if);
					#);
				getText: @
					(*
					 * This operation can cause a garbage collection.
					 *)
					(# t: ^Text;
						len: @Integer; 
					do &text[] -> t[];
						length -> len;
						(if len > 0 then 
							len->t.T.New; len->t.lgth->t.pos; (ptr+p+1, @@t.T[1], len)->BlockMove;
						if)
					exit t[]
					#);
			 
			enter setText
			exit getText
			#);
	#);

GlobVars:
  (# qd: @Integer;
     (* startAddress of global variables *)
     thePortAddress: @Integer;
     (* last address of global variables = address of thePort *)
     thePort: (# exit (%getLongAt(thePortAddress)) #);
     (* Above line tos_converted from: thePort: (# exit thePortAddress->tos'%adrGetLong' #); *)
     (* offsets found in MAC revealed, Volume 1, p541 *)
     whiteAddress: (# exit thePortAddress-8 #);
     BlackAddress: (# exit thePortAddress-16 #);
     GrayAddress: (# exit thePortAddress-24 #);
     ltGrayAddress: (# exit thePortAddress-32 #);
     dkGrayAddress: (# exit thePortAddress-40 #);
     ArrowAddress: (# exit thePortAddress-108 #);
     ScreenBitsAddress: (# exit thePortAddress-122 #);
     RandSeedAddress: (# exit thePortAddress-126 #);
     screenBitsBoundsBR:
       (# bottom,right: @Integer; 
       do
          %getShortAt(thePortAddress-122+10)->bottom;
          (* Above line tos_converted from: thePortAddress-122+10->tos'%adrGetShort'->bottom; *)
          %getShortAt(thePortAddress-122+12)->right
          (* Above line tos_converted from: thePortAddress-122+12->tos'%adrGetShort'->right *)
       exit (right,bottom)
       #);
     init:
       (# do (* getqd->qd; qd+202->thePortAddress;*) (* initgraf now done in betaenvbody *)  #);
     
  #);
initToolbox: (# g: ^GlobVars;  enter g[] do g.init; INNER ;  #);
ToResType: (*	Converts a text to the the ResType equivalent. *)
	(# theText: [4] @Char; theResType: @Integer;
		const3: (# exit 16777216 #);
		const2: (# exit 65536 #);
		const1: (# exit 256 #);
	enter theText
	do theText[1]*const3->theResType;
		(theText[2]*const2)+theResType->theResType;
		(theText[3]*const1)+theResType->theResType;
		theText[4]+theResType->theResType;
	exit theResType
	#);
FromResType: (*	Reverse of ToResType. *)
	(# theResType: @Integer; theText: [4] @Char;
		const3: (# exit 16777216 #);
   	const2: (# exit 65536 #);
   	const1: (# exit 256 #);
	enter theResType
	do theResType div const3->theText[1];
   	theResType mod const3->theResType;
   	theResType div const2->theText[2];
   	theResType mod const2->theResType;
   	theResType div const1->theText[3];
   	theResType mod const1->theText[4];
	exit theText
	#);
PToC:
(* Converts a char-repetition, where the length is the first 
 *	byte to a repetition of that length.
 *)
  (# p: [1] @Char
  enter p
  exit (# c: [p[1]] @Char do (for i: p[1] repeat p[i+1]->c[i];  for);  exit c #)
  #);
CToP: (* Reverse of PToC. *)
  (# c: [1] @Char
  enter c
  exit
    (# p: [c.range+1] @Char
    do (for i: c.range repeat c[i]->p[i+1];  for); c.range->p[1]; 
    exit p
    #)
  #);
currentEntVersion: (# exit 2 #);
  




(*** 23 jan 98, henryml:
 *** Apple has introduced new naming conventions for constants.
 *** Therefore the new names are added here.
 ***)

kControlUsesOwningWindowsFontVariant: (# exit 1 %sll 3 #);


pushButProc: (# exit 0 #);
checkBoxProc: (# exit 1 #);
radioButProc: (# exit 2 #);
useWFont: (# exit 8 #);
inButton: (# exit 10 #);
inCheckBox: (# exit 11 #);
scrollBarProc: (# exit 16 #);
inUpButton: (# exit 20 #);
indownButton: (# exit 21 #);
inPageUp: (# exit 22 #);
inPagedown: (# exit 23 #);
inThumb: (# exit 129 #);
popupMenuProc: (# exit 1008 #);
(* 1008 = 63*16 *)
popupTitleLeftJust: (# exit 0 #);
popupTitleCenterJust: (# exit 1 #);
popupTitleRightJust: (# exit 255 #);
popupTitleBold: (# exit 256 #);
popupTitleItalic: (# exit 512 #);
popupTitleUnderline: (# exit 1024 #);
popupTitleOutline: (# exit 2048 #);
popupTitleShadow: (# exit 4096 #);
popupTitleCondense: (# exit 8192 #);
popupTitleExtend: (# exit 16384 #);
popupTitleNoStyle: (# exit 32768 #);
popupFixedWidth: (# exit 1 #);
popupUseAddResMenu: (# exit 4 #);
(* constraints for dragGrayRgn call *)
noAxis: (# exit 0 #);
hAxisOnly: (# exit 1 #);
vAxisOnly: (# exit 2 #);
drawCnt: (# exit 0 #);
drawCntl: (# exit 0 #);
testCntl: (# exit 1 #);
calcCRgns: (# exit 2 #);
initCntl: (# exit 3 #);
dispCntl: (# exit 4 #);
posCntl: (# exit 5 #);
thumbCntl: (# exit 6 #);
dragCntl: (# exit 7 #);
autoTrack: (# exit 8 #);
cFrameColor: (# exit 0 #);
cBodyColor: (# exit 1 #);
cTextColor: (# exit 2 #);
cThumbColor: (# exit 3 #);
controlRecord: ToolboxRecord
  (# nextControl: Long (# Pos::< (# do 0->Value;  #);  #);
     contrlOwner: Long (# Pos::< (# do 4->Value;  #);  #);
     contrlRect: Rect (# Pos::< (# do 8->Value;  #);  #);
     contrlVis: Byte (# Pos::< (# do 16->Value;  #);  #);
     contrlHilite: Byte (# Pos::< (# do 17->Value;  #);  #);
     contrlValue: Short (# Pos::< (# do 18->Value;  #);  #);
     contrlMin: Short (# Pos::< (# do 20->Value;  #);  #);
     contrlMax: Short (# Pos::< (# do 22->Value;  #);  #);
     contrlDefProc: Long (# Pos::< (# do 24->Value;  #);  #);
     contrlData: Long (# Pos::< (# do 28->Value;  #);  #);
     contrlAction: Long (# Pos::< (# do 32->Value;  #);  #);
     contrlRfCon: Long (# Pos::< (# do 36->Value;  #);  #);
     
  #);
controlTemplate: ToolboxRecord
  (# bounds: Rect (# Pos::< (# do 0->Value;  #);  #);
     value: Short (# Pos::< (# do 8->Value;  #);  #);
     visible: Short (# Pos::< (# do 10->Value;  #);  #);
     max: Short (# Pos::< (# do 12->Value;  #);  #);
     min: Short (# Pos::< (# do 14->Value;  #);  #);
     procID: Short (# Pos::< (# do 16->Value;  #);  #);
     refCon: Long (# Pos::< (# do 18->Value;  #);  #);
     nLength: (# exit 22->getByte #);
     getText:
       (# t: [nLength] @Char; 
       do (for i: nLength repeat (i+22)->getByte->t[i];  for); 
       exit t
       #);
     
  #);

SetControlTitle: External
  (# controlHandle: @Integer; title: [1] @Char
  enter (controlHandle,title)
  do '$A95F'->PascalTrap; 
  #);
GetControlTitle: External
  (# theControl: @Integer; title: ^PascalString; 
  enter (theControl,title[])
  do '$A95E'->PascalTrap; 
  #);
GetNewControl: External
  (# controlId: @ShortInt; theWindow,controlHandle: @Integer; 
  enter (controlId,theWindow)
  do '$A9BE'->PascalTrap; 
  exit controlHandle
  #);
DisposeControl: External
  (# controlHandle: @Integer;  enter controlHandle do '$A955'->PascalTrap;  #);
KillControls: External (# theWindow: @Integer;  enter theWindow do '$A956'->PascalTrap;  #);
HideControl: External
  (# controlHandle: @Integer;  enter controlHandle do '$A958'->PascalTrap;  #);
ShowControl: External
  (# controlHandle: @Integer;  enter controlHandle do '$A957'->PascalTrap;  #);
DrawControls: External (# theWindow: @Integer;  enter theWindow do '$A969'->PascalTrap;  #);
Draw1Control: External
  (# controlHandle: @Integer;  enter controlHandle do '$A96D'->PascalTrap;  #);
HiliteControl: External
  (# c: @Integer; hstat: @ShortInt;  enter (c,hStat) do '$A95D'->PascalTrap;  #);
UpdateControls: External
  (# theWindow,updateRgn: @Integer;  enter (theWindow,updateRgn) do '$A953'->PascalTrap;  #);
MoveControl: External
  (# controlHandle: @Integer; h,v: @ShortInt; 
  enter (controlHandle,h,v)
  do '$A959'->PascalTrap; 
  #);
SizeControl: External
  (# controlHandle: @Integer; w,h: @ShortInt; 
  enter (controlHandle,w,h)
  do '$A95C'->PascalTrap; 
  #);
SetControlValue: External
  (# controlHandle: @Integer; v: @ShortInt; 
  enter (controlHandle,v)
  do '$A963'->PascalTrap; 
  #);
GetControlValue: External
  (# controlHandle: @Integer; v: @ShortInt; 
  enter controlHandle
  do '$A960'->PascalTrap; 
  exit v
  #);
SetControlMinimum: External
  (# controlHandle: @Integer; v: @ShortInt; 
  enter (controlHandle,v)
  do '$A964'->PascalTrap; 
  #);
GetControlMinimum: External
  (# controlHandle: @Integer; v: @ShortInt; 
  enter controlHandle
  do '$A961'->PascalTrap; 
  exit v
  #);
SetControlMaximum: External
  (# controlHandle: @Integer; v: @ShortInt; 
  enter (controlHandle,v)
  do '$A965'->PascalTrap; 
  #);
GetControlMaximum: External
  (# controlHandle: @Integer; v: @ShortInt; 
  enter controlHandle
  do '$A962'->PascalTrap; 
  exit v
  #);
SetControlReference: External
  (# controlHandle,v: @Integer;  enter (controlHandle,v) do '$A95B'->PascalTrap;  #);
GetControlReference: External
  (# controlHandle,v: @Integer;  enter controlHandle do '$A95A'->PascalTrap;  exit v #);
SetControlAction: External
  (# controlHandle,v: @Integer;  enter (controlHandle,v) do '$A96B'->PascalTrap;  #);
GetControlAction: External
  (# controlHandle,v: @Integer;  enter controlHandle do '$A96A'->PascalTrap;  exit v #);
DragControl: External
  (# controlHandle,startPt: @Integer; limitRect,slopRect: ^QRect; axis: @ShortInt; 
  enter (controlHandle,startPt,limitRect[],slopRect[],axis)
  do '$A967'->PascalTrap; 
  #);
TestControl: External
  (# controlHandle,thePt: @Integer; result: @ShortInt; 
  enter (controlHandle,thePt)
  do '$A966'->PascalTrap; 
  exit result
  #);
TrackControl: External
  (# controlHandle,thePt,actionProc: @Integer; result: @ShortInt; 
  enter (controlHandle,thePt,actionProc)
  do '$A968'->PascalTrap; 
  exit result
  #);
FindControl: External
  (# thePt,theWindow: @Integer; theControl: ^LongInt; result: @ShortInt; 
  enter (thePt,theWindow,theControl[])
  do '$A96C'->PascalTrap; 
  exit result
  #);
SetControlColor: External
  (# controlHandle,v: @Integer;  enter (controlHandle,v) do '$AA43'->PascalTrap;  #);
GetControlColor: External
  (# controlHandle: @Integer; v: @ShortInt; 
  enter (controlHandle)
  do '$A809'->PascalTrap; 
  exit v
  #);
GetAuxiliaryControlRecord: External
  (# controlHandle: @Integer; acHndl: ^LongInt; result: @Boolean; 
  enter (controlHandle,acHndl[])
  do '$AA44'->PascalTrap; 
  exit result
  #);
GetControlVariant: External
  (# controlHandle: @Integer; v: @ShortInt; 
  enter controlHandle
  do '$A809'->PascalTrap; 
  exit v
  #);
  

Debugger: External (* Enter MacsBug *) (# do '$A9FF'->PascalTrap;  #);
DebugStr: External (* Enter MacsBug with str as reason *)
  (# str: [1] @Char;  enter str do '$ABFF'->PascalTrap;  #);

OpenDeskAcc: External
  (# theAcc: [1] @Char; result: @ShortInt; 
  enter theAcc
  do '$A9B6'->pascalTrap; 
  exit result
  #);
CloseDeskAcc: External (# refNum: @ShortInt;  enter refNum do '$A9B7'->pascalTrap;  #);
SystemEdit: External
  (# editCmd: @ShortInt; result: @Boolean; 
  enter editCmd
  do '$A9C2'->pascalTrap; 
  exit result
  #);
SystemClick: External
  (# theEvent: ^EventRecord; theWindow: @Integer; 
  enter (theEvent[],theWindow)
  do '$A9B3'->pascalTrap; 
  #);
SystemTask: External (# do '$A9B4'->pascalTrap;  #);
SystemMenu: External (# menuResult: @Integer;  do '$A9B5'->pascalTrap;  #);
SystemEvent: External (# theEvent: ^EventRecord;  do '$A9B2'->pascalTrap;  #);
  

(* Toolbox event *)
everyEvent: (# exit - 1 #);
NullEvent: (# exit 0 #);
mousedown: (# exit 1 #);
mouseUp: (# exit 2 #);
keydown: (# exit 3 #);
keyUp: (# exit 4 #);
autoKey: (# exit 5 #);
updateEvt: (# exit 6 #);
diskEvt: (# exit 7 #);
activateEvt: (# exit 8 #);
networkEvt: (# exit 10 #);
driverEvt: (# exit 11 #);
app1Evt: (# exit 12 #);
app2Evt: (# exit 13 #);
app3Evt: (# exit 14 #);
app4Evt: (# exit 15 #);
osEvt: (# exit 15 #);
kHighLevelEvent: (# exit 23 #);

cmdKeyMask: (# exit 256 #);
shiftKeyMask: (# exit 512 #);
capsLockMask: (# exit 1024 #);
optionKeyMask: (# exit 2048 #);
controlKeyMask: (# exit 4096 #);

resumeMask: (# exit 1 #);
clipboardMask: (# exit 2 #);

activateMask: (# exit 1 #);
buttonMask: (# exit 128 #);

EventRecord: Data
	(#  what: @int16;
		 message_hi: @int16u;
		 message_lo: @int16u;
		 when_hi: @int16u;
		 when_lo: @int16u;
		 where_v: @int16;
		 where_h: @int16;
		 modifiers: @int16u;
	#);
	


EventInterface: COM
	(# event: @EventRecord;
		what:
			(# exit event.what #);
		message:
			(# exit (event.message_hi %sll 16) %bor event.message_lo #);
		keyCode:
			(# exit event.message_lo %srl 8 #);
		charCode:
			(# exit (event.message_lo %band 0xFF) #);
		when:
			(# exit (event.when_hi %sll 16) %bor event.when_lo #);
		where:
			(# exit (event.where_v %sll 16) %bor event.where_h #);
		wherePT: (# exit (event.where_h, event.where_v) #);
		modifiers:
			(# exit event.modifiers #);
		app4Selector:
			(# exit (event.message_hi %srl 8) #);
		childDiedStatus:
			(# exit (event.message_hi %band 0xFF) #);
			
		resume:
			(# exit (event.message_lo %band resumeMask) = resumeMask #);
		scrapDataHasChanged:
			(# exit (event.message_lo %band clipBoardMask) = clipBoardMask #);
		
		activeFlag: (# exit (event.modifiers %band activateMask) = activateMask #);
		btnState: (# exit (event.modifiers %band buttonMask) = buttonMask #);
		
		cmdKey: (# exit (event.modifiers %band cmdKeyMask) = cmdKeyMask #);
		shiftKey: (# exit (event.modifiers %band shiftKeyMask) = shiftKeyMask #);
		alphaLock: (# exit (event.modifiers %band capsLockMask) = capsLockMask #);
		optionKey: (# exit (event.modifiers %band optionKeyMask) = optionKeyMask #);
		controlKey: (# exit (event.modifiers %band controlKeyMask) = controlKeyMask #);
	#);
  
  
KeyMap: CStruct (# byteSize::< (# do 16->Value;  #);  #);
GetNextEvent: External
  (# eventMask: @ShortInt; theEvent: ^EventRecord; result: @Boolean; 
  enter (eventMask,theEvent[])
  do '$A970'->PascalTrap; 
  exit result
  #);
WaitNextEvent: External
  (# eventMask: @int16; theEvent: ^EventRecord; sleep,mouseRgn: @Integer; result: @Boolean; 
  enter (eventMask,theEvent[],sleep,mouseRgn)
  do '$A860'->PascalTrap; 
  exit result
  #);
EventAvail: External
  (# eventMask: @ShortInt; theEvent: ^EventRecord; result: @Boolean; 
  enter (eventMask,theEvent[])
  do '$A971'->PascalTrap; 
  #);
GetMouse: External (# mouseLoc: ^QPoint enter mouseLoc[] do '$A972'->PascalTrap;  #);
Button: External (# res: @Boolean;  do '$A974'->PascalTrap;  exit res #);
StillDown: External (# res: @Boolean;  do '$A973'->PascalTrap;  exit res #);
WaitMouseUp: External (# res: @Boolean;  do '$A977'->PascalTrap;  exit res #);
GetKeys: External (# theKeys: ^KeyMap enter theKeys do '$A976'->PascalTrap;  #);
TickCount: External (# value: @Integer do '$A975'->PascalTrap;  exit value #);
GetDblTime: External (# value: @Integer do '{$2EB8,$02F0}'->PascalTrap;  exit value #);
GetCaretTime: External (# value: @Integer do '{$2EB8,$02F4}'->PascalTrap;  exit value #);
(* OS event *)
FlushEvents: External
  (# whichMask,stopMask: @ShortInt; 
  enter (whichMask,stopMask)
  do '{$201F,$A032}'->PascalTrap; 
  #);
GetEvQHdr: External (# QHdrPtr: @Integer;  do CallPascal;  exit QHdrPtr #);
GetOSEvent: External
  (# mask: @ShortInt; theEvent: ^EventRecord; result: @Boolean; 
  enter (mask,theEvent[])
  do CallPascal; 
  exit result
  #);
OSEventAvail: External
  (# mask: @ShortInt; theEvent: ^EventRecord; result: @Boolean; 
  enter (mask,theEvent[])
  do CallPascal; 
  exit result
  #);
PostEvent: External
  (# eventNum: @ShortInt; eventMsg: @Integer; OSErr: @ShortInt; 
  enter (eventNum,eventMsg)
  do CallPascal; 
  exit OSErr
  #);
PPostEvent: External
  (# eventNum: @ShortInt; eventMsg,ptr: @Integer; OSErr: @ShortInt
  enter (eventNum,eventMsg,ptr)
  do CallPascal; 
  exit OSErr
  #);
SetEventMask: External
  (# theMask: @ShortInt;  enter theMask do '{$31DF,$0144}'->PascalTrap;  #);
  

btnctrl: (# exit 0 #);
chkctrl: (# exit 1 #);
radctrl: (# exit 2 #);
resctrl: (# exit 3 #);
ctrlItem: (# exit 4 #);
statText: (# exit 8 #);
editText: (# exit 16 #);
iconItem: (# exit 32 #);
picItem: (# exit 64 #);
itemDisable: (# exit 128 #);
userItem: (# exit 0 #);
ok: (# exit 1 #);
cancel: (# exit 2 #);
stopIcon: (# exit 0 #);
noteIcon: (# exit 1 #);
cautionIcon: (# exit 2 #);
AlertTemplate: ToolboxRecord
  (# boundsRect: Rect (# pos::< (# do 0->value #) #);
     itemsID: signedShort (# pos::< (# do 8->value #) #);
     (* Stagelist is not declared *)
     
  #);
DialogTemplate: ToolboxRecord
  (# boundsRect: Rect (# pos::< (# do 0->value #) #);
     procID: Short (# pos::< (# do 8->value #) #);
     visible: Short (# pos::< (# do 10->value #) #);
     filler1: Short (# pos::< (# do 12->value #) #);
     goAwayFlag: Short (# pos::< (# do 14->value #) #);
     filler2: Short (# pos::< (# do 16->value #) #);
     refCon: long (# pos::< (# do 18->value #) #);
     itemsID: signedShort (# pos::< (# do 22->value #) #);
     nLength: (# exit 24->getByte #);
     getText:
       (# t: [nLength] @Char; 
       do (for i: nLength repeat (i+24)->getByte->t[i];  for); 
       exit t
       #);
     
  #);
InitDialogs: External
  (# resumeProcPtr: @Integer;  enter resumeProcPtr do '$A97B'->pascalTrap;  #);
ErrorSound: External
  (# soundProcPtr: @Integer;  enter soundProcPtr do '$A98C'->pascalTrap;  #);
NewDialog: External
  (# wStorage: @Integer;
     rect: ^QRect;
     title: [1] @Char;
     visible: @Boolean;
     procId: @ShortInt;
     behind: @Integer;
     goAwayFlag: @Boolean;
     refCon,itmLstHndl,dialogPtr: @Integer;
     
  enter (wStorage,rect[],title,visible,procId,behind,goAwayFlag,refCon,itmLstHndl)
  do '$A97D'->pascalTrap; 
  exit dialogPtr
  #);
GetNewDialog: External
  (# dialogId: @ShortInt; dStorage,behind,dialogPtr: @Integer; 
  enter (dialogId,dStorage,behind)
  do '$A97C'->pascalTrap; 
  exit dialogPtr
  #);
CloseDialog: External (# dialogPtr: @Integer enter dialogPtr do '$A982'->pascalTrap;  #);
DisposDialog: External (# dialogPtr: @Integer enter dialogPtr do '$A983'->pascalTrap;  #);
CouldDialog: External (# dialogPtr: @Integer enter dialogPtr do '$A979'->pascalTrap;  #);
FreeDialog: External (# dialogPtr: @Integer enter dialogPtr do '$A97A'->pascalTrap;  #);
ParamText: External
  (# param0,param1,param2,param3: [1] @Char
  enter (param0,param1,param2,param3)
  do '$A98B'->pascalTrap; 
  #);
ModalDialog: External
  (# filterProcPtr: @Integer; itemHit: ^ShortRef
  enter (filterProcPtr,itemHit[])
  do '$A991'->pascalTrap; 
  #);
IsDialogEvent: External
  (# e: ^eventRecord; theResult: @Boolean
  enter e[]
  do '$A97F'->pascalTrap; 
  exit theResult
  #);
DialogSelect: External
  (# e: ^eventRecord; dialogPtr: ^longInt; itemHit: ^ShortRef; theResult: @Boolean; 
  enter (e[],dialogPtr[],itemHit[])
  do '$A980'->pascalTrap; 
  exit theResult
  #);
DrawDialog: External (# dialogPtr: @Integer;  enter dialogPtr do '$A981'->pascalTrap;  #);
UpdtDialog: External
  (# dialogPtr,updateRgn: @Integer;  enter (dialogPtr,updateRgn) do '$A978'->pascalTrap;  #);
Alert: External
  (# alertId,theResult: @ShortInt; modalFilterProc: @Integer; 
  enter (alertId,modalFilterProc)
  do '$A985'->pascalTrap; 
  exit theResult
  #);
StopAlert: External
  (# alertId,theResult: @ShortInt; modalFilterProc: @Integer; 
  enter (alertId,modalFilterProc)
  do '$A986'->pascalTrap; 
  exit theResult
  #);
NoteAlert: External
  (# alertId,theResult: @ShortInt; modalFilterProc: @Integer; 
  enter (alertId,modalFilterProc)
  do '$A987'->pascalTrap; 
  exit theResult
  #);
CautionAlert: External
  (# alertId,theResult: @ShortInt; modalFilterProc: @Integer; 
  enter (alertId,modalFilterProc)
  do '$A988'->pascalTrap; 
  exit theResult
  #);
(* couldAlert and free Alert no longer implemented in system 7 - pjs 26/7 1994
 CouldAlert: External (# alertId: @ShortInt; enter alertId do '$A989' -> pascalTrap; #);
 FreeAlert: External (# alertId: @ShortInt; enter alertId do '$A98A' -> pascalTrap; #);*/
 *)
GetDItem: External
  (# theDialog: @Integer; itemNo: @ShortInt; itemType: ^ShortRef; item: ^longInt; box: ^QRect
  enter (theDialog,itemNo,itemType[],item[],box[])
  do '$A98D'->pascalTrap; 
  #);
SetDItem: External
  (# theDialog: @Integer; itemNo,itemType: @ShortInt; item: @Integer; rect: ^QRect
  enter (theDialog,itemNo,itemType,item,rect[])
  do '$A98E'->pascalTrap; 
  #);
HideDItem: External
  (# theDialog: @Integer; itemNo: @ShortInt; 
  enter (theDialog,itemNo)
  do '$A827'->pascalTrap; 
  #);
ShowDItem: External
  (# theDialog: @Integer; itemNo: @ShortInt; 
  enter (theDialog,itemNo)
  do '$A828'->pascalTrap; 
  #);
SelIText: External
  (# theDialog,itemNo: @Integer; startSel,endSel: @ShortInt
  enter (theDialog,itemNo,startSel,endSel)
  do '$A97E'->pascalTrap; 
  #);
GetIText: External
  (# item: @Integer; textPtr: ^PascalString
  enter (item,textPtr[])
  do '$A990'->pascalTrap; 
  #);
SetIText: External
  (# item: @Integer; text: [1] @Char enter (item,text) do '$A98F'->pascalTrap;  #);
FindDItem: External
  (# theDialog,thePt: @Integer; result: @ShortInt
  enter (theDialog,thePt)
  do '$A984'->pascalTrap; 
  exit result
  #);
NewCDialog: External
  (# wStorage: @Integer;
     rect: ^QRect;
     title: [1] @Char;
     visible: @Boolean;
     procId: @ShortInt;
     behind: @Integer;
     goAwayFlag: @Boolean;
     refCon,itmLstHndl,dialogPtr: @Integer
  enter (wStorage,rect[],title,visible,procId,behind,goAwayFlag,refCon,itmLstHndl)
  do '$AA4B'->pascalTrap; 
  exit dialogPtr
  #);
GetAlrtStage: External
  (# theResult: @ShortInt;  do '{ $3EB8 , $0A9A }'->pascalTrap;  exit theResult #);
ResetAlrtStage: External (# do '{ $4278 , $0A9A }'->pascalTrap;  #);
DlgCopy: External (# theDialog: @Integer;  enter theDialog do 'DLGCOPY'->callPascal;  #);
DlgCut: External (# theDialog: @Integer;  enter theDialog do 'DLGCUT'->callPascal;  #);
DlgDelete: External (# theDialog: @Integer;  enter theDialog do 'DLGDELETE'->callPascal;  #);
DlgPaste: External (# theDialog: @Integer;  enter theDialog do 'DLGPASTE'->callPascal;  #);
SetDAFont: External (# fontNum: @ShortInt;  enter fontNum do 'SETDAFONT'->callPascal;  #);
  



smSystemScript: (# exit -1 #);

FInfo: CStruct
  (# ByteSize::< (# do 16->value #);
     fdType: Long (# Pos::< (# do 0->value #) #);
     fdCreator: Long (# Pos::< (# do 4->value #) #);
     fdFlags: Short (# Pos::< (# do 8->value #) #);
     fdLocation: Long (# Pos::< (# do 10->value #) #);
     fdFldr: Short (# Pos::< (# do 14->value #) #);
     Type:
       (# theType: [4] @Char; 
       enter (# enter theType do theType->ToResType->fdType;  #)
       exit (# do fdType->FromResType->theType;  exit theType #)
       #);
     Creator:
       (# theCreator: [4] @Char; 
       enter (# enter theCreator do theCreator->ToResType->fdCreator;  #)
       exit (# do fdCreator->FromResType->theCreator;  exit theCreator #)
       #);
     
  #);
FSSpec: CStruct
  (# ByteSize::< (# do 70->value;  #);
     vRefNum: Short (# Pos::< (# do 0->value;  #);  #);
     parID: Long (# Pos::< (# do 2->value;  #);  #);
     name:
       (# nameStart: (# exit 6 #);
          set:
            (# itsName: ^Text; 
            enter itsName[]
            do (if (itsName[] <> NONE) AND (itsName.lgth > 0) then
				   (nameStart,itsName.lgth)->putByte;
				   (@@ itsName.T[1],@@ R[2]+3,itsName.lgth)->blockmove;
				else
					(nameStart,0)->putByte;
				if);
               
            #);
          get:
            (# itsName: ^Text; len: @Integer; 
            do
               &Text[]->itsName[];
               nameStart->getByte->len;
			   (if len > 0 then
			   	  len ->itsName.T.new;
				   (@@ R[2]+3,@@ itsName.T[1],len)->blockmove;
				   itsName.T.range->itsName.lgth->itsName.pos;
				if);
               
            exit itsName[]
            #);
          
       enter set
       exit get
       #);
     
  #);


GetFInfo: external
  (# fileName: [1] @Char; vRefNum: @ShortInt; fndrInfo: ^FInfo; OSErr: @ShortInt; 
  enter (fileName,vRefNum,fndrInfo[])
  do callpascal
  exit OSErr
  #);
SetFInfo: external
  (# fileName: [1] @Char; vRefNum: @ShortInt; fndrInfo: ^FInfo; OSErr: @ShortInt; 
  enter (fileName,vRefNum,fndrInfo[])
  do callpascal
  exit OSErr
  #);
Create: External
  (# fileName: [1] @Char; vRefNum: @ShortInt; Creator,Type: @Integer; OSErr: @ShortInt; 
  enter (fileName,vRefNum,Creator,Type)
  do callpascal
  exit OSErr
  #);
DirCreate: External
  (# vRefNum: @ShortInt;
     parentDirID: @Integer;
     directoryName: [1] @Char;
     createdDirID: ^LongInt;
     error: @Integer;
     
  enter (vRefNum,parentDirID,directoryName,createdDirID[])
  do (*'DIRCREATE'->*) callpascal
  exit error
  #);
FSDelete: External
  (# fileName: [1] @Char; vRefNum: @ShortInt; error: @Integer; 
  enter (fileName,vRefNum)
  do callpascal
  exit error
  #);
FSWrite: External
	(# refNum: @shortInt;
	   count: ^longInt;
	   buffPtr: @integer;
	   error: @shortInt;
	enter (refNum, count[], buffPtr)
	exit error
	#);
FSRead: External
	(# refNum: @shortInt;
	   count: ^longInt;
	   buffPtr: @integer;
	   error: @shortInt;
	enter (refNum, count[], buffPtr)
	exit error
	#);
FSClose: External
	(# refNum: @shortInt;
	   error: @shortInt;
	enter refNum
	exit error
	#);
SetEOF: External
	(# refnum: @shortint;
	   eof: @integer;
	   error: @shortInt;
	enter (refNum, eof)
	exit error
	#);
GetEOF: External
	(# refnum: @shortInt;
		eof: ^longInt;
		error: @shortint;
	enter (refNum, eof[])
	exit error
	#);

FSMakeFSSpec: external
  (# vRefNum: @ShortInt;
     dirID: @Integer;
     filename: [1] @Char;
     spec: ^FSSpec;
     result: @ShortInt;
     
  enter (vRefNum,dirID,filename,spec[])
  do '{$303C,$0001,$AA52}'->pascalTrap; 
  exit result
  #);
FSpExchangeFiles: External
  (# source,dest: ^FSSpec; result: @ShortInt; 
  enter (source[],dest[])
  do '{$303C,$000F,$AA52}'->pascalTrap
  exit result
  #);
FSpOpenDF: External
  (# spec: ^FSSpec; permission: @Char; refNum: ^ShortRef; result: @ShortInt; 
  enter (spec[],permission,refNum[])
  do '{$303C,$0002,$AA52}'->pascalTrap
  exit result
  #);
FSpOpenRF: External
  (# spec: ^FSSpec; permission: @Char; refNum: ^ShortRef; result: @ShortInt; 
  enter (spec[],permission,refNum[])
  do '{$303C,$0003,$AA52}'->pascalTrap
  exit result
  #);
FSpCreate: external
  (# spec: ^FSSpec; creator,fileType: @Integer; scriptTag: @ShortInt; result: @ShortInt; 
  enter (spec[],creator,fileType,scriptTag)
  do '{$303C,$0004,$AA52}'->pascalTrap
  exit result
  #);
FSpDirCreate: external
  (# spec: ^FSSpec; scriptTag: @ShortInt; createdDirID: ^LongInt; result: @ShortInt; 
  enter (spec[],scriptTag,createdDirID[])
  do '{$303C,$0005,$AA52}'->pascalTrap
  exit result
  #);
FSpDelete: external
  (# spec: ^FSSpec; result: @ShortInt; 
  enter spec[]
  do '{$303C,$0006,$AA52}'->pascalTrap
  exit result
  #);
FSpGetFInfo: external
  (# spec: ^FSSpec; fndrInfo: ^FInfo; OSErr: @ShortInt; 
  enter (spec[],fndrInfo[])
  do '{$303C,$0007,$AA52}'->pascalTrap
  exit OSErr
  #);
FSpSetFInfo: external
  (# spec: ^FSSpec; fndrInfo: ^FInfo; OSErr: @ShortInt; 
  enter (spec[],fndrInfo[])
  do '{$303C,$0008,$AA52}'->pascalTrap
  exit OSErr
  #);
FSpSetFLock: external
  (# spec: ^FSSpec; result: @ShortInt; 
  enter spec[]
  do '{$303C,$0009,$AA52}'->pascalTrap
  exit result
  #);
FSpRstFLock: external
  (# spec: ^FSSpec; result: @ShortInt; 
  enter spec[]
  do '{$303C,$000A,$AA52}'->pascalTrap
  exit result
  #);
FSpRename: external
  (# spec: ^FSSpec; newName: [1] @Char; result: @ShortInt; 
  enter (spec[],newName)
  do '{$303C,$000B,$AA52}'->pascalTrap
  exit result
  #);
HCreate: external
  (# vRefNum: @shortInt;
     dirID: @integer;
     fileName: [1] @Char;
     creator,fileType: @Integer;
     result: @ShortInt;
     
  enter (vRefNum,dirID,fileName,creator,fileType)
  do (*'HCREATE'->*) callpascal
  exit result
  #);
HDelete: external
  (# vRefNum: ^ShortRef; dirID: ^LongInt; fileName: [1] @Char; result: @ShortInt; 
  enter (vRefNum,dirID,fileName)
  do (*'HDELETE'->*) callpascal
  exit result
  #);
HGetVol: external
  (# volName: ^PascalString; vRefNum: ^ShortRef; dirID: ^LongInt; result: @ShortInt; 
  enter (volName[],vRefNum[],dirID[])
  do callpascal
  exit result
  #);
fseek: External
  (# macStream,p,mode,status: @Integer;  enter (macStream,p,mode) do CallC exit status #);
ftell: External (# macStream,pos: @Integer;  enter macStream do CallC exit pos #);
fread: External
  (# addr,size,n,macStream: @Integer;
     (* n is no of elems. to read. *)
     n1: @Integer;
     (* The number of elements successfully read. *)
     
  enter (addr,size,n,macStream)
  do CallC
  exit n1
  #);
fwrite: External
  (# addr,size,n,macStream: @Integer;
     (* n is no of elems. to write. *)
     n1: @Integer;
     (* The number of elements successfully written. *)
     
  enter (addr,size,n,macStream)
  do CallC
  exit n1
  #);
fflush: External (# macStream,status: @Integer;  enter macStream do CallC exit status #);
fclose: External (# macStream,status: @Integer;  enter macStream do CallC exit status #);
fputc: External
  (# macStream: @Integer; ch: @Integer; status: @Integer; 
  enter (ch,macStream)
  do CallC
  exit status
  #);
fputs: External
  (# macStream: @Integer; T: @Integer; status: @Integer; 
  enter (T,macStream)
  do CallC
  exit status
  #);
fgetc: External (# macStream: @Integer; ch: @Integer;  enter macStream do CallC exit ch #);
  

NewHandle: External
  (# byteCount,theHandle: @Integer;  enter byteCount do CallPascal;  exit theHandle #);
GetHandleSize: External (# h,Size: @Integer;  enter h do CallPascal;  exit size #);
HLock: External (# h: @Integer;  enter h do CallPascal;  #);
HUnlock: External (# h: @Integer;  enter h do CallPascal;  #);
HPurge: External (# h: @Integer;  enter h do CallPascal;  #);
HNoPurge: External (# h: @Integer;  enter h do CallPascal;  #);
MoveHHi: External (# h: @Integer;  enter h do (*'MOVEHHI'->*) CallPascal;  #);
DisposeHandle: External (# h: @Integer;  enter h do '$A023'->PascalTrap #);
EmptyHandle: External (# h: @Integer;  enter h do CallPascal;  #);
HSetRBit: External (# h: @Integer;  enter h do CallPascal;  #);
HClrRBit: External (# h: @Integer;  enter h do CallPascal;  #);
ReallocateHandle: External (# h,newSize: @Integer;  enter (h,newSize) do CallPascal;  #);
NenEmptyHandle: External (# theHandle: @Integer;  do CallPascal;  exit theHandle #);
NewPtr: External
  (# byteCount,thePtr: @Integer;  enter byteCount do CallPascal;  exit thePtr #);
DisposePtr: External (# ptr: @Integer;  enter ptr do '$A01F'->PascalTrap;  #);
MemError: External (# result: @ShortInt;  do '{$3EB8,$0220}'->PascalTrap;  exit result #);
ApplicZone: External (# THz: @Integer;  do '{$2EB8,$02AA}'->PascalTrap;  exit THz #);
BlockMove: External
  (# srcPtr,dstPtr,byteCount: @Integer; 
  enter (srcPtr,dstPtr,byteCount)
  do (*'BLOCKMOVE'->*) callpascal; 
  #);
CompactMem: External (# cbNeeded: @Integer;  enter cbNeeded do callpascal;  #);
FreeMem: External (# free: @Integer;  do callpascal;  exit free #);
GetApplLimit: External (# Ptr: @Integer;  do '{$2EB8,$0130}'->PascalTrap;  exit Ptr #);
GetPtrSize: External (# p,size: @Integer;  enter p do callpascal;  exit size #);
GetZone: External (# THz: @Integer;  do callpascal;  exit THz #);
GZSaveHnd: External
  (# GZSaveHnd: @Integer;  do '{$2EB8,$0328}'->PascalTrap;  exit GZSaveHnd #);
HandleZone: External (# h,THz: @Integer;  enter h do callpascal;  exit THz #);
(*
 HGetState: External (# do CallPascal; #);
 HSetState: External (# do CallPascal; #);
 *)
MaxApplZone: External (# do '$A063'->PascalTrap;  #);
MaxBlock: External (# max: @Integer;  do CallPascal;  exit max #);
MaxMem: External
  (# grow: ^LongInt; Size: @Integer;  enter grow[] do callpascal;  exit Size #);
MFFreeMem: External (# free: @Integer;  do '{$3F3C,$0018,$A88F}'->PascalTrap;  exit free #);
MFMaxMem: External
  (# grow: ^LongInt; Size: @Integer; 
  enter grow[]
  do '{$3F3C,$0015,$A88F}'->PascalTrap; 
  exit Size
  #);
MFTempDisposHandle: External
  (# h: @Integer; resultCode: ^CStruct; 
  enter (h,resultCode[])
  do '{$3F3C,$0020,$A88F}'->PascalTrap; 
  #);
MFTempHLock: External
  (# h: @Integer; resultCode: ^CStruct; 
  enter (h,resultCode[])
  do '{$3F3C,$001E,$A88F}'->PascalTrap; 
  #);
MFTempHUnlock: External
  (# h: @Integer; resultCode: ^CStruct; 
  enter (h,resultCode[])
  do '{$3F3C,$001F,$A88F}'->PascalTrap; 
  #);
MFTempNewHandle: External
  (# size,h: @Integer; resultCode: ^CStruct
  enter (size,resultCode[])
  do '{$3F3C,$001D,$A88F}'->PascalTrap; 
  exit h
  #);
MFTopMem: External
  (# MFTopMem: @Integer;  do '{$3F3C,$0016,$A88F}'->PascalTrap;  exit MFTopMem #);
MoreMasters: External (# do '$A036'->PascalTrap;  #);
NewHandleClear: External (# byteCount,h: @Integer;  enter byteCount do callpascal;  exit h #);
NewHandleSys: External (# byteCount,h: @Integer;  enter byteCount do callpascal;  exit h #);
NewHandleSysClear: External
  (# byteCount,h: @Integer;  enter byteCount do callpascal;  exit h #);
NewPtrClear: External (# byteCount,ptr: @Integer;  enter byteCount do callpascal;  exit ptr #);
NewPtrSys: External (# byteCount,ptr: @Integer;  enter byteCount do callpascal;  exit ptr #);
NewPtrSysClear: External
  (# byteCount,ptr: @Integer;  enter byteCount do callpascal;  exit ptr #);
PtrZone: External (# ptr,THz: @Integer;  enter ptr do callpascal;  exit THz #);
PurgeMem: External (# cbNeeded: @Integer;  enter cbNeeded do callpascal;  #);
PurgeSpace: External (# total,contig: ^LongInt;  enter (total[],contig[]) do callpascal;  #);
RecoverHandle: External (# ptr,hndl: @Integer;  enter ptr do callpascal;  exit hndl #);
ResrvMem: External (# cbNeeded: @Integer;  enter cbNeeded do callpascal;  #);
SetApplBase: External (# startPtr: @Integer;  enter startPtr do callpascal;  #);
SetApplLimit: External (# zoneLimit: @Integer;  enter zoneLimit do callpascal;  #);
GrowZoneProc: External
  (# cbNeeded,result: @Integer; 
  enter cbNeeded
  do PascalExternalEntry; INNER ; 
  exit result
  #);
SetGrowZone: External
  (# growZone: ##GrowZoneProc;  enter growZone## do '{$205F,$A04B}'->CallPascal;  #);
SetHandleSize: External
  (# h,newSize: @Integer;  enter (h,newSize) do (*'SETHANDLESIZE'->*) callpascal;  #);
SetPtrSize: External (# ptr,newSize: @Integer;  enter (ptr,newSize) do callpascal;  #);
SetZone: External (# THz: @Integer;  enter THz do callpascal;  #);
StackSpace: External (# space: @Integer;  do callpascal;  exit space #);
StripAddress: External
  (# theAddress,Ptr: @Integer;  enter theAddress do callpascal;  exit Ptr #);
SystemZone: External (# THz: @Integer;  enter THz do '{$2EB8,$02A6}'->PascalTrap;  #);
TopMem: External (# ptr: @Integer;  do '{$2EB8,$0108}'->PascalTrap;  exit ptr #);
  

FMetricRec: CStruct
  (# byteSize::< (# do 20->Value;  #);
     ascent: Long (# Pos::< (# do 0->Value;  #);  #);
     descent: Long (# Pos::< (# do 4->Value;  #);  #);
     leading: Long (# Pos::< (# do 8->Value;  #);  #);
     widMax: Long (# Pos::< (# do 12->Value;  #);  #);
     wTabHandle: Long (# Pos::< (# do 16->Value;  #);  #);
     
  #);
Initfonts: External (# do '$A8FE'->PascalTrap;  #);
GetFontName: External
  (# familyId: @ShortInt; theName: ^PascalString; 
  enter (familyId,theName[])
  do '$A8FF'->PascalTrap; 
  #);
GetFNum: External
  (# familyId: ^ShortRef; theName: [1] @Char; 
  enter (theName,familyId[])
  do '$A900'->PascalTrap; 
  #);
RealFont: External
  (# fontNum,size: @ShortInt; result: @Boolean; 
  enter (fontNum,size)
  do '$A902'->PascalTrap; 
  exit result
  #);
SetFontLock: External (# lockFlag: @Boolean;  enter lockFlag do '$A903'->PascalTrap;  #);
SetFScaleDisable: External
  (# FScaleDisable: @Boolean;  enter FScaleDisable do '$A834'->PascalTrap;  #);
FractEnable:
  (# val: @integer; 
  enter (# 
        enter val do (val) %putByteAt(3060+0); 
        (* Above line tos_converted from: enter val do (3060,val)->tos'%putByte[0]'; *)
        #)
  exit (# 
       do (%getByteAt(3060))->val 
       (* Above line tos_converted from: do 3060->tos'%adrGetByte'->val *)
       exit val
       #)
  #);
FMSwapFont: External
  (# FMOutPtr: @integer; fInput: ^CStruct; 
  enter fInput[]
  do '$A901'->PascalTrap; 
  exit FMOutPtr
  #);
FontMetrics: External (# theMetrics: ^CStruct;  enter theMetrics[] do '$A835'->PascalTrap;  #);
  

(*
 * Interface to the morefiles package from apple.
 *
 * NOTE: Not all routines are interfaced.
 *)
 

							   
FSpGetFullPath: External
	(# spec: ^FSSpec;
		fullPathLength: ^shortRef;
		fullPath: ^longInt; (* Pointer to a handle that will be allocated by FSpGetFullPath *)
		err: @integer;
	enter (spec[], fullPathLength[], fullPath[])
	do callPascal;
	exit err
	#);
	

convertToFullPath:
	(# spec: ^FSSpec;
		path: ^text;
		
		pathHandle: @longInt;
		length: @shortRef;
		lgth: @integer;
		err: @integer;
	enter spec[]
	do (spec[], length[], pathHandle[]) -> FSpGetFullPath -> err;
		(if (err = 0) then
			&text[] -> path[];
			length -> path.T.new;
			length -> lgth;
			((%getLongAt(pathHandle)), @@path.T[1], lgth) -> BlockMove;
			(* Above line tos_converted from: (pathHandle -> TOS'%adrGetLong', @@path.T[1], lgth) -> BlockMove; *)
			length -> path.lgth -> path.pos;
			pathHandle -> DisposeHandle;
		if);
	exit path[]
	#);

Text2ResType:
  (# const3: (# exit 16777216 #);
     const2: (# exit 65536 #);
     const1: (# exit 256 #);
     newtxt: ^text;
     result: @Integer;
     
  enter newtxt[]
  do
     (if newtxt[] = none then (failureTrace,'Text2ResType: text is NONE')->stop;  if);
     newtxt.T[4]+(newtxt.T[3]*const1)+(newtxt.T[2]*const2)+(newtxt.T[1]*const3)->result;
     
  exit result
  #);
ResType2Text:
  (# const3: (# exit 16777216 #);
     const2: (# exit 65536 #);
     const1: (# exit 256 #);
     value: @Integer;
     t: ^Text;
     
  enter value
  do
     &Text[]->t[];
     value div const3->t.put;
     value mod const3->value;
     value div const2->t.put;
     value mod const2->value;
     value div const1->t.put;
     value mod const1->t.put;
     
  exit t[]
  #);
InitResources: External (# do '$A995'->PascalTrap;  #);
RsrcZoneInit: External (# do '$A996'->PascalTrap;  #);
CloseResFile: External (# refNum: @ShortInt;  enter refNum do '$A99A'->PascalTrap;  #);
ResError: External (# resError: @ShortInt;  do '$A9AF'->PascalTrap;  exit resError #);
CurResFile: External (# result: @ShortInt;  do '$A994'->PascalTrap;  exit result #);
HomeResFile: External
  (# theHandle: @Integer; result: @ShortInt; 
  enter theHandle
  do '$A9A4'->PascalTrap; 
  exit result
  #);
CreateResFile: External (# filename: [1] @Char enter filename do '$A9B1'->PascalTrap;  #);
OpenResFile: External
  (# filename: [1] @Char; result: @ShortInt; 
  enter filename
  do '$A997'->PascalTrap; 
  exit result
  #);
UseResFile: External (# refNum: @ShortInt;  enter refNum do '$A998'->PascalTrap;  #);
CountTypes: External (# result: @ShortInt;  do '$A99E'->PascalTrap;  exit result #);
Count1Types: External (# result: @ShortInt;  do '$A81C'->PascalTrap;  exit result #);
GetIndType: External
  (# theType: ^LongInt; index: @ShortInt; 
  enter (theType[],index)
  do '$A99F'->PascalTrap; 
  #);
Get1IndType: External
  (# theType: ^LongInt; index: @ShortInt; 
  enter (theType[],index)
  do '$A80F'->PascalTrap; 
  #);
SetResLoad: External (# load: @Boolean;  enter load do '$A99B'->PascalTrap;  #);
CountResources: External
  (# theHandle: @Integer; result: @ShortInt; 
  enter theHandle
  do '$A99C'->PascalTrap; 
  exit result
  #);
Count1Resources: External
  (# theHandle: @Integer; result: @ShortInt; 
  enter theHandle
  do '$A80D'->PascalTrap; 
  exit result
  #);
GetIndResource: External
  (# theType,result: @Integer; index: @ShortInt; 
  enter (theType,index)
  do '$A99D'->PascalTrap; 
  exit result
  #);
Get1IndResource: External
  (# theType,result: @Integer; index: @ShortInt; 
  enter (theType,index)
  do '$A80E'->PascalTrap; 
  exit result
  #);
GetResource: External
  (# theType,result: @Integer; index: @ShortInt; 
  enter (theType,index)
  do '$A9A0'->PascalTrap; 
  exit result
  #);
Get1Resource: External
  (# theType,result: @Integer; index: @ShortInt; 
  enter (theType,index)
  do '$A81F'->PascalTrap; 
  exit result
  #);
GetNamedResource: External
  (# theType,result: @Integer; name: [1] @Char; 
  enter (theType,name)
  do '$A9A1'->PascalTrap; 
  exit result
  #);
Get1NamedResource: External
  (# theType,result: @Integer; name: [1] @Char; 
  enter (theType,name)
  do '$A820'->PascalTrap; 
  exit result
  #);
LoadResource: External (# handle: @Integer;  enter handle do '$A9A2'->PascalTrap;  #);
ReleaseResource: External (# handle: @Integer;  enter handle do '$A9A3'->PascalTrap;  #);
DetachResource: External (# handle: @Integer;  enter handle do '$A992'->PascalTrap;  #);
UniqueID: External
  (# theHandle: @Integer; result: @ShortInt; 
  enter theHandle
  do '$A9C1'->PascalTrap; 
  exit result
  #);
Unique1Id: External
  (# theHandle: @Integer; result: @ShortInt; 
  enter theHandle
  do '$A810'->PascalTrap; 
  exit result
  #);
GetResAttrs: External
  (# theHandle: @Integer; result: @ShortInt; 
  enter theHandle
  do '$A9A6'->PascalTrap; 
  exit result
  #);
GetResInfo: External
  (# handle: @Integer; theId: ^ShortRef; theType: ^LongInt; name: ^PascalString; 
  enter (handle,theId[],theType[],name[])
  do '$A9A8'->PascalTrap; 
  #);
SetResInfo: External
  (# handle: @Integer; theId: @ShortInt; name: [1] @Char
  enter (handle,theId,name)
  do '$A9A9'->PascalTrap; 
  #);
AddResource: External
  (# handle,theType: @Integer; theId: @ShortInt; name: [1] @Char
  enter (handle,theType,theId,name)
  do '$A9AB'->PascalTrap; 
  #);
SizeResource: External
  (# theHandle,result: @Integer;  enter theHandle do '$A9A5'->PascalTrap;  exit result #);
MaxSizeRsrc: External
  (# theHandle,result: @Integer;  enter theHandle do '$A821'->PascalTrap;  exit result #);
RsrcMapEntry: External
  (# theHandle,result: @Integer;  enter theHandle do '$A9C5'->PascalTrap;  exit result #);
SetResAttrs: External
  (# handle: @Integer; index: @ShortInt;  enter (handle,index) do '$A9A7'->PascalTrap;  #);
ChangedResource: External (# handle: @Integer;  enter handle do '$A9AA'->PascalTrap;  #);
RemoveResource: External (# handle: @Integer;  enter handle do '$A9AD'->PascalTrap;  #);
UpdateResFile: External (# refNum: @ShortInt;  enter refNum do '$A999'->PascalTrap;  #);
WriteResource: External (# handle: @Integer;  enter handle do '$A9B0'->PascalTrap;  #);
SetResPurge: External (# install: @Boolean;  enter install do '$A993'->PascalTrap;  #);
GetResFileAttrs: External
  (# refNum,result: @ShortInt;  enter refNum do '$A9F6'->PascalTrap;  exit result #);
SetResFileAttrs: External
  (# refNum,attrs: @ShortInt;  enter (refNum,attrs) do '$A9F7'->PascalTrap;  #);
OpenRfPerm: External
  (# fileName: [1] @Char; vRefNum,permission,result: @ShortInt; 
  enter (fileName,vRefNum,permission)
  do '$A9C4'->PascalTrap; 
  exit result
  #);
RGetResource: External
  (# theType,result: @Integer; theId: @ShortInt; 
  enter (theType,theId)
  do '$A80C'->PascalTrap; 
  exit result
  #);
HOpenResFile: External
  (# fileName: [1] @Char; dirId: @Integer; permission,vRefNum,result: @ShortInt; 
  enter (vRefNum,dirId,fileName,permission)
  do pascal
  exit result
  #);
HCreateResFile: External
  (# fileName: [1] @Char; dirId: @Integer; vRefNum: @ShortInt; 
  enter (vRefNum,dirId,fileName)
  do pascal
  #);
  
 FSpOpenResFile: External
   (# spec: ^FSSpec;
      perm: @char;
	  refnum: @int16;
	enter (spec[], perm)
	exit refnum
	#);
	
FSpCreateResFile: External
   (# spec: ^FSSpec;
      creator, fileType: @int32u;
	  script: @int16;
   enter (spec[], creator, fileType, script)
   #);

ScrapStuff: ToolboxRecord
  (# scrapSize: long (# Pos::< (# do 0->Value;  #);  #);
     scrapHandle: long (# Pos::< (# do 4->Value;  #);  #);
     scrapCount: short (# Pos::< (# do 8->Value;  #);  #);
     scrapState: short (# Pos::< (# do 10->Value;  #);  #);
     scrapName: long (# Pos::< (# do 12->Value;  #);  #);
     
  #);
InfoScrap: External (# res: @Integer;  do '$A9F9'->PascalTrap;  exit res #);
UnloadScrap: External (# res: @Integer;  do '$A9FA'->PascalTrap;  exit res #);
LoadScrap: External (# res: @Integer;  do '$A9FB'->PascalTrap;  exit res #);
ZeroScrap: External (# res: @Integer;  do '$A9FC'->PascalTrap;  exit res #);
GetScrap: External
  (# hDest,theType,res: @Integer; offSet: ^longInt; 
  enter (hDest,theType,offSet[])
  do '$A9FD'->PascalTrap; 
  exit res
  #);
PutScrap: External
  (# length,resType,source,res: @Integer; 
  enter (length,resType,source)
  do '$A9FE'->PascalTrap; 
  exit res
  #);
  

GetScrapAsText:
	(#	length: @integer;
		offset: @longInt;
		resType: @integer;;
		textHndl: @integer;
		address: @integer;
		txt: ^text;
		type: [4] @char;
	enter type
	do type -> toResType -> resType;
		0 -> NewHandle -> textHndl;
		(textHndl, resType, offset[]) -> GetScrap -> length;
		&text[] -> txt[];
		(if length > 0 then
			length -> txt.extend;
			(%getLongAt(textHndl)) -> address;
			(* Above line tos_converted from: textHndl -> TOS'%adrGetLong' -> address; *)
			(address,@@txt.T[1],length) -> BlockMove;
			length -> txt.lgth -> txt.pos;
		if);
		textHndl -> DisposeHandle;
	exit txt[]
	#);
		
PutTextScrap:
	(# data: ^text;
		type: [4] @char;
		resType: @integer;
		ignore: @integer;
	enter (data[], type)
	do type -> toResType -> resType;
		(if data.lgth > 0 then
			(data.lgth, resType, @@data.T[1]) -> PutScrap -> ignore;
		if);
	#);

TERec: Data
	(# destRect: @QRect;
	   viewRect: @QRect;
	   selRect: @QRect;
	   lineHeight: @int16;
	   fontAscent: @int16;
	   selPoint: @QPoint;
	   selStart: @int16;
	   selEnd: @int16;
	   active: @int16;
	   wordBreak_hi: @int16u;
	   wordBreak_lo: @int16u;
	   clikLoop_hi: @int16u;
	   clikLoop_lo: @int16u;
	   clickTime_hi: @int16u;
	   clickTime_lo: @int16u;
	   clickLoc: @int16;
	   caretTime: @int32;
	   caretState: @int16;
	   just: @int16;
	   teLength: @int16;
	   hText_hi: @int16u;
	   hText_lo: @int16u;
	   hDispatchRec_hi: @int16u;
	   hDispatchRec_lo: @int16u;
	   clikStuff: @int16;
	   crOnly: @int16;
	   txFont: @int16;
	   txFace: @int16;
	   txMode: @int16;
	   txSize: @int16;
	   inPort_hi: @int16;
	   inPort_lo: @int16;
	   highHook_hi: @int16;
	   highHook_lo: @int16;
	   caretHook_hi: @int16;
	   caretHook_lo: @int16;
	   nLines: @int16;
	#);
	
	
derefTEHandle:
	(# handle: @integer;
	   te: ^TERec;
	enter handle
	do (%getLongAt handle) %putLongAt @@te;
	exit te[]
	#);
	
LockHandle:
	(# handle: @int32;
	   ptr: ^Data;
	enter handle
	do handle -> HLock;
	   (%getLongAt handle) %putLongAt @@ptr;
	exit ptr[]
	#);
UnLockHandle:
	(# handle: @int32;
	enter handle
	do handle -> HUnLock;
	#);
TEPtr: ToolboxRecord
  (# destRect: Rect (# Pos::< (# do 0->Value;  #);  #);
     viewRect: Rect (# Pos::< (# do 8->Value;  #);  #);
     lineHeight: Short (# Pos::< (# do 24->Value;  #);  #);
     fontAscent: Short (# Pos::< (# do 26->Value;  #);  #);
     selStart: Short (# Pos::< (# do 32->Value;  #);  #);
     selEnd: Short (# Pos::< (# do 34->Value;  #);  #);
     wordBreak: Long (# Pos::< (# do 38->Value;  #);  #);
     clikLoop: Long (# Pos::< (# do 42->Value;  #);  #);
     just: Short (# Pos::< (# do 58->Value;  #);  #);
     teLength: Short (# Pos::< (# do 60->Value;  #);  #);
     hText: Long (# Pos::< (# do 62->Value;  #);  #);
     crOnly: Short (# Pos::< (# do 72->Value;  #);  #);
     txFont: Short (# Pos::< (# do 74->Value;  #);  #);
     txFace: Short (# Pos::< (# do 76->Value;  #);  #);
     txMode: Short (# Pos::< (# do 78->Value;  #);  #);
     txSize: Short (# Pos::< (# do 80->Value;  #);  #);
     inPort: Long (# Pos::< (# do 82->Value;  #);  #);
     highHook: Long (# Pos::< (# do 86->Value;  #);  #);
     caretHook: Long (# Pos::< (# do 90->Value;  #);  #);
     nLines: Short (# Pos::< (# do 94->Value;  #);  #);
     lineStart: (# lineNo: @Integer;  enter lineNo exit 96+lineNo*2->getShort #);
     
  #);
TextStyleRec: cstruct
  (# byteSize::< (# do 12->value #);
     tsFont: 		Short 	(# Pos::< (# do 0->Value;  #);  #);
     tsFace: 		Byte 	(# Pos::< (# do 2->Value;  #);  #);
     tsSize: 		Short 	(# Pos::< (# do 4->Value;  #);  #);
     tsColor_red: 	Short 	(# Pos::< (# do 6->Value;  #);  #);
	 tsColor_green: Short 	(# Pos::< (# do 8->Value;  #);  #);
	 tsColor_blue: 	Short 	(# Pos::< (# do 10->Value;  #);  #);
  #);
TEInit: External (# do '$A9CC'->PascalTrap;  #);
TENew: External
  (# destRect,viewRect: ^QRect; theHandle: @Integer; 
  enter (destRect[],viewRect[])
  do '$A9D2'->PascalTrap; 
  exit theHandle
  #);
TEDispose: External (# theHandle: @Integer;  enter theHandle do '$A9CD'->PascalTrap;  #);
TESetText: External
  (# text,length,hTe: @Integer;  enter (text,length,hTe) do '$A9CF'->PascalTrap;  #);
TEGetText: External
  (# thetext,hTe: @Integer;  enter hTe do '$A9CB'->PascalTrap;  exit theText #);
TEIdle: External (# hTe: @Integer;  enter hTe do '$A9DA'->PascalTrap;  #);
TESetSelect: External
  (# selStart,selEnd,hTe: @Integer;  enter (selStart,selEnd,hTe) do '$A9D1'->PascalTrap;  #);
TEActivate: External (# hTe: @Integer;  enter hTe do '$A9D8'->PascalTrap;  #);
TEDeactivate: External (# hTe: @Integer;  enter hTe do '$A9D9'->PascalTrap;  #);
TEKey: External
  (# key: @ShortInt; hTe: @Integer;  enter (key,hTe) do '$A9DC'->PascalTrap;  #);
TECut: External (# hTe: @Integer;  enter hTe do '$A9D6'->PascalTrap;  #);
TECopy: External (# hTe: @Integer;  enter hTe do '$A9D5'->PascalTrap;  #);
TEPaste: External (# hTe: @Integer;  enter hTe do '$A9DB'->PascalTrap;  #);
TEDelete: External (# hTe: @Integer;  enter hTe do '$A9D7'->PascalTrap;  #);
TEInsert: External
  (# text,length,hTe: @Integer;  enter (text,length,hTe) do '$A9DE'->PascalTrap;  #);
TESetJust: External
  (# hTe: @Integer; just: @ShortInt;  enter (just,hTe) do '$A9DF'->PascalTrap;  #);
TEUpdate: External
  (# hTe: @Integer; rUpdate: ^QRect;  enter (rUpdate[],hTe) do '$A9D3'->PascalTrap;  #);
TETextBox: External
  (# text,length: @Integer; box: ^QRect; just: @ShortInt; 
  enter (text,length,box[],just)
  do '$A9CE'->PascalTrap; 
  #);
TEScroll: External
  (# dh,dv: @ShortInt; hTe: @Integer;  enter (dh,dv,hTe) do '$A9DD'->PascalTrap;  #);
TESelView: External (# hTe: @Integer;  enter hTe do '$A811'->PascalTrap;  #);
TEPinScroll: External
  (# dh,dv: @ShortInt; hTe: @Integer;  enter (dh,dv,hTe) do '$A812'->PascalTrap;  #);
TEAutoView: External
  (# fAuto: @Boolean; hTe: @Integer;  enter (fAuto,hTe) do '$A813'->PascalTrap;  #);
TEScrapHandle: External (# hndl: @Integer;  do '{$2EB8,$0AB4}'->PascalTrap;  exit hndl #);
TECalText: External (# hndl: @Integer;  enter hndl do '$A9D0'->PascalTrap;  #);
TEGetOffset: External
  (# pt,hndl: @Integer; res: @ShortInt;  enter (pt,hndl) do '$A83C'->PascalTrap;  exit res #);
TEGetPoint:
  (# offset: @ShortInt; hndl: @Integer; p: @MacPoint; 
  enter (offset,hndl)
  do <<SLOT TEGetPoint:Descriptor>>; 
  exit p[]
  #);
TEClick: External
  (# pt,hte: @Integer; fExtend: @Boolean; 
  enter (pt,fExtend,hTe)
  do '$A9D4'->PascalTrap; 
  #);
TEStyleNew: External
  (# d,v: ^QRect; TEHandle: @Integer; 
  enter (d[],v[])
  do '$A83E'->PascalTrap; 
  exit TEHandle
  #);
SetStyleHandle: External
  (# stylhndl,tehndl: @Integer; 
  enter (stylhndl,tehndl)
  do '{$3F3C,$0005,$A83D}'->PascalTrap; 
  #);
GetStyleHandle: External
  (# stylhndl,tehndl: @Integer; 
  enter tehndl
  do '{$3F3C,$0004,$A83D}'->PascalTrap; 
  exit stylhndl
  #);
TEGetScrapLen: External
  (# i: @Integer;  do callpascal;  exit i #);
TESetScrapLen: External
  (# i: @Integer;  enter i do callpascal;  #);
TEFromScrap: External
  (# res: @ShortInt;  do callpascal;  exit res #);
TEToScrap: External
  (# res: @ShortInt;  do callpascal;  exit res #);
TENumStyles: External
  (# rangeStart,rangeEnd,hTE,num: @Integer; 
  enter (rangeStart,rangeEnd,hTE)
  do '{$3F3C,$000D,$A83D}'->PascalTrap; 
  exit num
  #);
TEReplaceStyle: External
  (# mode: @ShortInt;
     oldStyle,newStyle: ^TextStyleRec;
     redraw: @Boolean;
     hTE: @Integer;
     
  enter (mode,oldStyle[],newStyle[],redraw,hTE)
  do '{$3F3C,$0002,$A83D}'->PascalTrap; 
  #);
TEStyleInsert: External
  (# buf,len,hST,hTE: @Integer; 
  enter (buf,len,hST,hTE)
  do '{$3F3C,$0007,$A83D}'->PascalTrap; 
  #);
TEGetStyleScrapHandle: External
  (# hTE,hST: @Integer; 
  enter hTE
  do '{$3F3C,$0006,$A83D}'->PascalTrap; 
  exit hST
  #);
TESetStyleScrapHandle: External
  (# rangeStart,rangeEnd,newStyles,hTE: @Integer; redraw: @Boolean; 
  enter (rangeStart,rangeEnd,newStyles,redraw,hTE)
  do '{$3F3C,$000B,$A83D}'->PascalTrap; 
  #);
TEContinuousStyle: External
  (# mode: ^ShortRef;
     aStyle: ^TextStyleRec;
     hTE: @Integer;
     isContinous: @Boolean;
     
  enter (mode[],aStyle[],hTE)
  do '{$3F3C,$000A,$A83D}'->PascalTrap; 
  exit isContinous
  #);
TEGetHeight: External
  (# endLine,startLine,hTE,height: @Integer; 
  enter (endLine,startLine,hTE)
  do '{$3F3C,$0009,$A83D}'->PascalTrap; 
  exit height
  #);
TESetStyle: External
  (# mode: @ShortInt;
     newStyle: ^TextStyleRec;
     redraw: @Boolean;
     hTE: @Integer;
     
  enter (mode,newStyle[],redraw,hTE)
  do '{$3F3C,$0001,$A83D}'->PascalTrap; 
  #);
TEFeatureFlag: External
  (# feature,action,before: @ShortInt; hTE: @Integer; 
  enter (feature,action,hTE)
  do '{$3F3C,$000E,$A83D}'->PascalTrap; 
  exit before
  #);
TEGetStyle: External
  (# offset: @ShortInt;
     theStyle: ^TextStyleRec;
     lineHeight,fontAscent: ^ShortRef;
     hTE: @Integer;
     
  enter (offset,theStyle[],lineHeight[],fontAscent[],hTE)
  do '{$3F3C,$0003,$A83D}'->PascalTrap; 
  #);
TEStylePaste: External
  (# hTE: @Integer; 
  enter hTE
  do '{$3F3C,$0000,$A83D}'->PascalTrap; 
  #);
  
teFlushDefault: (# exit 0 #); 			(* flush according to the line direction *)
teCenter: (# exit 1 #);					(* center justify (word alignment) *)
teFlushRight: (# exit -1 #);			(* flush right for all scripts *)
teFlushLeft: (# exit -2 #);				(* flush left for all scripts *)


doFont: (# exit 1 #);
doFace: (# exit 2 #);
doSize: (# exit 4 #);
doColor: (# exit 8 #);
doAll: (# exit 15 #);
addSize: (# exit 16 #);

TESetStyleHandle: External 
	(# stylhndl,tehndl: @Integer;
	enter (stylhndl,tehndl)
	do '{$3F3C,$0005,$A83D}' -> PascalTrap;
	#);
TEGetStyleHandle: External 
	(# stylhndl,tehndl: @Integer;
	enter tehndl
	do '{$3F3C,$0004,$A83D}' -> PascalTrap;
	exit stylhndl
	#);
TEUseStyleScrap: External 
	(#	rangeStart,rangeEnd,newStyles,hTE: @Integer;
		redraw: @Boolean;
	enter (rangeStart,rangeEnd,newStyles,redraw,hTE)
	do '{$3F3C,$000B,$A83D}' -> PascalTrap;
	#);

TextEditInsert:
	(# data: ^text;
		teHandle: @integer;
	enter (data[], teHandle)
	do (if data.lgth > 0 then
			(@@data.T[1], data.lgth, teHandle) -> TEInsert;
		if);
	#);
TextEditSetText:
	(# data: ^text;
		teHandle: @integer;
	enter (data[], teHandle)
	do (if data.lgth > 0 then
			(@@data.T[1], data.lgth, teHandle) -> TESetText;
		else
			(0, 0, teHandle) -> TESetText;
		if);
	#);

MakeText:
	(# data: ^text;
		h: @integer;
		p: @integer;
		size: @integer;
	enter h
	do &text[] -> data[];
		h -> GetHandleSize -> size;
		(if size > 0 then
			size -> data.extend;
			(%getLongAt(h)) -> p;
			(* Above line tos_converted from: h -> TOS'%adrGetLong' -> p; *)
			(p, @@data.T[1], size) -> BlockMove;
			size -> data.lgth -> data.pos;
		if);
	exit data[]
	#);
	
TextEditGetText:
	(# data: ^text;
		teHandle: @integer;
	enter teHandle
	do teHandle -> TEGetText -> MakeText -> data[];
	exit data[]
	#);

TextBox:
	(# t: ^text;
		box: ^QRect;
		align: @shortInt;
	enter (t[], box[], align)
	do (if t.lgth > 0 then
			(@@t.T[1], t.lgth, box[], align) -> TETExtBox;
		if);
	#);

(* Apple Event descriptor types *)
typeBoolean: (* 'bool' *) (# exit 1651470188 #);
(* Boolean value *)
typeChar: (* 'TEXT' *) (# exit 1413830740 #);
(* unterminated string *)
typeSMInt: (* 'shor' *) (# exit 1936224114 #);
(* 16-bit Integer *)
typeInteger: (* 'long' *) (# exit 1819242087 #);
(* 32-bit Integer *)
typeSMFloat: (* 'sing' *) (# exit 1936289383 #);
(* SANE single *)
typeFloat: (* 'doub' *) (# exit 1685026146 #);
(* SANE double *)
typeLongInteger: (* 'long' *) (# exit 1819242087 #);
(* 32-bit Integer *)
typeShortInteger: (* 'shor' *) (# exit 1936224114 #);
(* 16-bit Integer *)
typeLongFloat: (* 'doub' *) (# exit 1685026146 #);
(* SANE double *)
typeShortFloat: (* 'sing' *) (# exit 1936289383 #);
(* SANE single *)
typeExtended: (* 'exte' *) (# exit 1702392933 #);
(* SANE extended *)
typeComp: (* 'comp' *) (# exit 1668246896 #);
(* SANE comp *)
typeMagnitude: (* 'magn' *) (# exit 1835100014 #);
(* unsigned 32-bit Integer *)
typeAEList: (* 'list' *) (# exit 1818850164 #);
(* list of descriptor records *)
typeAERecord: (* 'reco' *) (# exit 1919247215 #);
(* list of keyword-specified
 *	descriptor records
 *)
typeAppleEvent: (* 'aevt' *) (# exit 1685026146 #);
(* Apple Event record *)
typeTrue: (* 'true' *) (# exit 1953658213 #);
(* TRUE Boolean value *)
typeFalse: (* 'fals' *) (# exit 1717660787 #);
(* FALSE Boolean value *)
typeAlias: (* 'alis' *) (# exit 1634494835 #);
(* alias record *)
typeEnumerated: (* 'enum' *) (# exit 1701737837 #);
(* enumerated data *)
typeType: (* 'type' *) (# exit 1954115685 #);
(* Four-character code for event
 * class or event ID
 *)
typeAppParameters: (* 'appa' *) (# exit 1634758753 #);
(* Process Manager launch parameters *)
typeProperty: (* 'prop' *) (# exit 1886547824 #);
(* Apple Event property *)
typeFSS: (* 'fss ' *) (# exit 1718842144 #);
(* file system specification *)
typeKeyword: (* 'keyw' *) (# exit 1801812343 #);
(* Apple Event keyword *)
typeSectionH: (* 'sect' *) (# exit 1936024436 #);
(* handle to a section record *)
typeWildCard: (* '****' *) (# exit 707406378 #);
(* matches any type *)
typeApplSignature: (* 'sign' *) (# exit 1936287598 #);
(* application signature *)
typeSessionID: (* 'ssid' *) (# exit 1936943460 #);
(* session ID *)
typeTargetID: (* 'targ' *) (# exit 1952543335 #);
(* target ID record *)
typeProcessSerialNumber: (* 'psn ' *) (# exit 1886613024 #);
(* process serial number *)
typeNull: (* 'null' *) (# exit 1853189228 #);
(* NULL or nonexistent data *)
(* keywords for Apple Event parameters *)
keyDirectObject: (* '----' *) (# exit 757935405 #);
(* direct parameter *)
keyErrorNumber: (* 'errn' *) (# exit 1701999214 #);
(* error number parameter *)
keyErrorString: (* 'errs' *) (# exit 1701999219 #);
(* error string parameter *)
keyProcessSerialNumber: (* 'psn ' *) (# exit 1886613024 #);
(* process serial number param *)
(* keywords for Apple Event attributes *)
keyTransactionIDAttr: (* 'tran' *) (# exit 1953653102 #);
(* transaction ID *)
keyReturnIDAttr: (* 'rtid' *) (# exit 1920231780 #);
(* return ID *)
keyEventClassAttr: (* 'evcl' *) (# exit 1702257516 #);
(* event class *)
keyEventIDAttr: (* 'evid' *) (# exit 1702259044 #);
(* event ID *)
keyAddressAttr: (* 'addr' *) (# exit 1633969266 #);
(* target application *)
keyOptionalKeywordAttr: (* 'optk' *) (# exit 1869640811 #);
(* list of optional parameters for the 
 *	Apple Event
 *)
keyTimeoutAttr: (* 'timo' *) (# exit 1953066351 #);
(* number of ticks the client will wait *)
keyInteractLevelAttr: (* 'inte' *) (# exit 1768846437 #);
(* settings to allow Apple Event Manager to
 *	bring server to foreground
 *)
keyEventSourceAttr: (* 'esrc' *) (# exit 1702064739 #);
(* source application *)
keyMissedKeywordAttr: (* 'miss' *) (# exit 1835627379 #);
(* first required parameter remaining in 
 *	an Apple Event 
 *)
(* keywords for special handlers *)
keyPreDispatch: (* 'phac' *) (# exit 1885888867 #);
(* PreHandler Accessor Call *)
(* event class *)
kCoreEventClass: (* 'aevt' *) (# exit 1634039412 #);
kAEMiscStandards: (*'misc' *) (# exit 0x6d697363  #);
(* event class for required Apple Events *)
(* event class for core Apple Events *)
kAEFinderEvents: (* 'FNDR' *) (# exit 1179534418 #);
(* events accepted by the Finder *)
kSectionEventMsgClass: (* 'sect' *) (# exit 1936024436 #);
(* events sent by the Edition Manager *)
(* event IDs *)
kAEOpenApplication: (* 'oapp' *) (# exit 1868656752 #);
(* event ID for Open Application event *)
kAEOpenDocuments: (* 'odoc' *) (# exit 1868853091 #);
(* event ID for Open Documents event *)
kAEPrintDocuments: (* 'pdoc' *) (# exit 1885630307 #);
(* event ID for Print Documents event *)
kAEQuitApplication: (* 'quit' *) (# exit 1903520116 #);
(* event ID for Quit Application event *)
kAEAnswer: (* 'ansr' *) (# exit 1634628466 #);
(* event ID for Apple Event replies *)
kAEApplicationDied: (* 'obit' *) (# exit 1868720500 #);
(* event ID for Application Died event *)
(* Constants for setting the sendMode parameter of AESend and for the 
 *	keyInteractLevelAttr attribute 
 *)
kAEDoScript:  (* 'dosc' *) (# exit 0x646f7363 #);
kAENoReply: (# exit 1 #);
(* client doesn't want reply *)
kAEQueueReply: (# exit 2 #);
(* client wants server to reply in event queue *)
kAEWaitReply: (# exit 3 #);
(* client wants a reply and will give up processor *)
kAENeverInteract: (# exit 16 #);
(* server application should not interact with user 
 *	for this Apple Event
 *)
kAECanInteract: (# exit 32 #);
(* server may interact with user for this Apple Event 
 *	to supply information
 *)
kAEAlwaysInteract: (# exit 48 #);
(* server may interact with user for this Apple Event
 *	even if no information is required 
 *)
kAECanSwitchLayer: (# exit 64 #);
(* server should come directly to foreground when 
 *	appropriate
 *)
kAEDontReconnect: (# exit 128 #);
(* don't reconnect if there is a PPC sessClosedErr *)
kAEWantReceipt: (# exit 512 #);
(* client wants return receipt *)
(* constants for the sendPriority parameter of AESend *)
kAENormalPriority: (# exit 0 #);
(* put event at the back of event queue *)
kAEHighPriority: (# exit 1 #);
(* put event at the front of the event queue *)
(* constant for the returnID parameter of AECreateAppleEvent *)
kAutoGenerateReturnID: (# exit - 1 #);
(* tells Apple Event Manager to generate a unique
 *	return ID 
 *)
(* constant for transaction IDs *)
kAnyTransactionID: (# exit 0 #);
(* the Apple Event is not part of a transaction *)
(* constants for timeout durations *)
kAEDefaultTimeout: (# exit - 1 #);
(* use default timeout value *)
kNoTimeOut: (# exit - 2 #);
(* never time out *)
(* constants for the dispatcher parameter of AEResumeTheCurrentEvent *)
kAENoDispatch: (# exit 0 #);
(* don't redispatch the Apple Event *)
kAEUseStandardDispatch: (# exit - 1 #);
(* redispatch the Apple Event by using its
 *	entry in the Apple Event dispatchtable
 *)
AEDesc: CStruct
  (# ByteSize::< (# do 8->Value;  #);
     descriptorType: Long (# Pos::< (# do 0->Value;  #);  #);
     dataHandle: Long (# Pos::< (# do 4->Value;  #);  #);
     
  #);
AEAddressDesc: AEDesc (# #);
AEDescList: AEDesc (# #);
AERecord: AEDescList (# #);
AppleEvent: AERecord (# #);
AEKeyDesc: CStruct
  (# ByteSize::< (# do 12->Value;  #);
     descKey: Long (# Pos::< (# do 0->Value;  #);  #);
     descContent: @
       (# descriptorType: Long (# Pos::< (# do 4->Value;  #);  #);
          dataHandle: Long (# Pos::< (# do 8->Value;  #);  #);
          
       #);
     
  #);
kAEInteractWithSelf: (# exit 1 #);
kAEInteractWithLocal: (# exit 2 #);
kAEInteractWithAll: (# exit 4 #);
kAEUnknownSource: (# exit 1 #);
kAEDirectCall: (# exit 2 #);
kAESameProcess: (# exit 4 #);
kAELocalProcess: (# exit 8 #);
kAERemoteProcess: (# exit 16 #);
kAEDataArray: (# exit 1 #);
kAEPackedArray: (# exit 2 #);
kAEHandleArray: (# exit 4 #);
kAEDescArray: (# exit 8 #);
kAEKeyDescArray: (# exit 16 #);
errAECoercionFail: (# exit - 1700 #);
errAEDescNotFound: (# exit - 1701 #);
errAECorruptData: (# exit - 1702 #);
errAEWrongDataType: (# exit - 1703 #);
errAENotAEDesc: (# exit - 1704 #);
errAEBadListItem: (# exit - 1705 #);
errAENewerVersion: (# exit - 1706 #);
errAENotAppleEvent: (# exit - 1707 #);
errAEEventNotHandled: (# exit - 1708 #);
errAEReplyNotValid: (# exit - 1709 #);
errAEUnknownSendMode: (# exit - 1710 #);
errAEWaitCanceled: (# exit - 1711 #);
errAETimeout: (# exit - 1712 #);
errAENoUserInteraction: (# exit - 1713 #);
errAENotASpecialFunction: (# exit - 1714 #);
errAEParamMissed: (# exit - 1715 #);
errAEUnknownAddressType: (# exit - 1716 #);
errAEHandlerNotFound: (# exit - 1717 #);
errAEReplyNotArrived: (# exit - 1718 #);
errAEIllegalIndex: (# exit - 1719 #);

AppleEventHandler: External
	(# theAppleEvent, reply: @Integer;
		refcon: @integer;
		err: @integer;
	enter (theAppleEvent, reply, refcon)
	do pascalExternalEntry;
	   INNER;
	exit err
	#);
	
AECoerceDesc: External
  (# theAEDesc,result: ^AEDesc; toType: @Integer; OSErr: @ShortInt; 
  enter (theAEDesc[],toType,result[])
  do '{$303C,$0603,$A816}'->PascalTrap; 
  exit OSErr
  #);
AECoercePtr: External
  (# typeCode,dataPtr,dataSize,toType: @Integer; result: ^AEDesc; OSErr: @ShortInt; 
  enter (typeCode,dataPtr,dataSize,toType,result[])
  do '{$303C,$0A02,$A816}'->PascalTrap; 
  exit OSErr
  #);
AECountItems: External
  (# theAEDescList: ^AEDescList; theCount: ^LongInt; OSErr: @ShortInt; 
  enter (theAEDescList[],theCount[])
  do '{$303C,$0407,$A816}'->PascalTrap; 
  exit OSErr
  #);
AECreateAppleEvent: External
  (# theAEEventClass,theAEEventID,transactionID: @Integer;
     target: ^AEAddressDesc;
     result: ^AppleEvent;
     returnID,OSErr: @ShortInt;
     
  enter (theAEEventClass,theAEEventID,target[],returnID,transactionID,result[])
  do '{$303C,$0B14,$A816}'->PascalTrap; 
  exit OSErr
  #);
AECreateDesc: External
  (# typeCode,dataPtr,dataSize: @Integer; result: ^AEDesc; OSErr: @ShortInt; 
  enter (typeCode,dataPtr,dataSize,result[])
  do '{$303C,$0825,$A816}'->PascalTrap; 
  exit OSErr
  #);
AECreateList: External
  (# factoringPtr,factoredSize: @Integer;
     isRecord: @Boolean;
     resultList: ^AEDescList;
     OSErr: @ShortInt;
     
  enter (factoringPtr,factoredSize,isRecord,resultList[])
  do '{$303C,$0706,$A816}'->PascalTrap; 
  exit OSErr
  #);
AEDeleteItem: External
  (# theAEDescList: ^AEDescList; index: @Integer; OSErr: @ShortInt; 
  enter (theAEDescList[],index)
  do '{$303C,$040E,$A816}'->PascalTrap; 
  exit OSErr
  #);
AEDeleteKeyDesc: External
  (# theAERecord: ^AERecord; theAEKeyword: @Integer; OSErr: @ShortInt; 
  enter (theAERecord[],theAEKeyword)
  do '{$303C,$0413,$A816}'->PascalTrap; 
  exit OSErr
  #);
AEDeleteParam: External
  (# theAppleEvent: ^AppleEvent; theAEKeyword: @Integer; OSErr: @ShortInt; 
  enter (theAppleEvent[],theAEKeyword)
  do '{$303C,$0413,$A816}'->PascalTrap; 
  exit OSErr
  #);
AEDisposeDesc: External
  (# theAEDesc: ^AEDesc; OSErr: @ShortInt; 
  enter theAEDesc[]
  do '{$303C,$0204,$A816}'->PascalTrap; 
  exit OSErr
  #);
AEDuplicateDesc: External
  (# theAEDesc,result: ^AEDesc; OSErr: @ShortInt; 
  enter (theAEDesc[],result[])
  do '{$303C,$0405,$A816}'->PascalTrap; 
  exit OSErr
  #);
AEGetArray: External
  (# theAEDescList: ^AEDescList;
     arrayPtr,maximumSize: @Integer;
     itemType,itemSize,itemCount: ^LongInt;
     AEArrayType,OSErr: @ShortInt;
     
  enter (theAEDescList[],AEArrayType,arrayPtr,maximumSize,itemType[],itemSize[],itemCount[])
  do '{$303C,$0D0C,$A816}'->PascalTrap; 
  exit OSErr
  #);
AEGetAttributePtr: External
  (# theAppleEvent: ^AppleEvent;
     theAEKeyword,desiredType,dataPtr,maximumSize: @Integer;
     typeCode,actualSize: ^LongInt;
     OSErr: @ShortInt;
     
  enter (theAppleEvent[],theAEKeyword,desiredType,typeCode[],dataPtr,maximumSize,actualSize[])
  do '{$303C,$0E15,$A816}'->PascalTrap; 
  exit OSErr
  #);
AEGetAttributeDesc: External
  (# theAppleEvent: ^AppleEvent;
     theAEKeyword,desiredType: @Integer;
     result: ^AEDesc;
     OSErr: @ShortInt;
     
  enter (theAppleEvent[],theAEKeyword,desiredType,result[])
  do '{$303C,$0826,$A816}'->PascalTrap; 
  exit OSErr
  #);
AEGetCoercionHandler: External
  (# fromType,toType: @Integer;
     handler,handlerRefcon: ^LongInt;
     fromTypeIsDesc: ^ShortRef;
     isSysHandler: @Boolean;
     OSErr: @ShortInt;
     
  enter (fromType,toType,handler[],handlerRefcon[],fromTypeIsDesc[],isSysHandler)
  do '{$303C,$0B24,$A816}'->PascalTrap; 
  exit OSErr
  #);
AEGetEventHandler: External
  (# theAEEventClass,theAEEventID: @Integer;
     handler,handlerRefcon: ^LongInt;
     isSysHandler: @Boolean;
     OSErr: @ShortInt;
     
  enter (theAEEventClass,theAEEventID,handler[],handlerRefcon[],isSysHandler)
  do '{$303C,$0921,$A816}'->PascalTrap; 
  exit OSErr
  #);
AEGetInteractionAllowed: External
  (# level: ^ByteRef; OSErr: @ShortInt; 
  enter level[]
  do '{$303C,$021D,$A816}'->PascalTrap; 
  exit OSErr
  #);
AEGetKeyDesc: External
  (# theAERecord: ^AERecord;
     theAEKeyword,desiredType: @Integer;
     result: ^AEDesc;
     OSErr: @ShortInt;
     
  enter (theAERecord[],theAEKeyword,desiredType,result[])
  do '{$303C,$0812,$A816}'->PascalTrap; 
  exit OSErr
  #);
AEGetKeyPtr: External
  (# theAERecord: ^AERecord;
     theAEKeyword,desiredType,dataPtr,maximumSize: @Integer;
     typeCode,actualSize: ^LongInt;
     OSErr: @ShortInt;
     
  enter (theAERecord[],theAEKeyword,desiredType,typeCode[],dataPtr,maximumSize,actualSize[])
  do '{$303C,$0E11,$A816}'->PascalTrap; 
  exit OSErr
  #);
AEGetNthDesc: External
  (# theAEDescList: ^AEDescList;
     index,desiredType: @Integer;
     theAEKeyword: ^LongInt;
     result: ^AEDesc;
     OSErr: @ShortInt;
     
  enter (theAEDescList[],index,desiredType,theAEKeyword[],result[])
  do '{$303C,$0A0B,$A816}'->PascalTrap; 
  exit OSErr
  #);
AEGetNthPtr: External
  (# theAEDescList: ^AEDescList;
     index,desiredType,dataPtr,maximumSize: @Integer;
     theAEKeyword,typeCode,actualSize: ^LongInt;
     OSErr: @ShortInt;
     
  enter
  (theAEDescList[],index,desiredType,theAEKeyword[],typeCode[],dataPtr,maximumSize,actualSize[])
  do '{$303C,$100A,$A816}'->PascalTrap; 
  exit OSErr
  #);
AEGetParamDesc: External
  (# theAppleEvent: ^AppleEvent;
     theAEKeyword,desiredType: @Integer;
     result: ^AEDesc;
     OSErr: @ShortInt;
     
  enter (theAppleEvent[],theAEKeyword,desiredType,result[])
  do '{$303C,$0812,$A816}'->PascalTrap; 
  exit OSErr
  #);
AEGetParamPtr: External
  (# theAppleEvent: ^AppleEvent;
     theAEKeyword,desiredType,dataPtr,maximumSize: @Integer;
     typeCode,actualSize: ^LongInt;
     OSErr: @ShortInt;
     
  enter (theAppleEvent[],theAEKeyword,desiredType,typeCode[],dataPtr,maximumSize,actualSize[])
  do '{$303C,$0E11,$A816}'->PascalTrap; 
  exit OSErr
  #);
AEGetSpecialHandler: External
  (# functionClass: @Integer; handler: ^LongInt; isSysHandler: @Boolean; OSErr: @ShortInt; 
  enter (functionClass, handler[], isSysHandler)
  do '{$303C,$052D,$A816}'->PascalTrap; 
  exit OSErr
  #);
AEGetTheCurrentEvent: External
  (# theAppleEvent: ^AppleEvent; OSErr: @ShortInt; 
  enter theAppleEvent[]
  do '{$303C,$021A,$A816}'->PascalTrap; 
  exit OSErr
  #);
AEInstallCoercionHandler: External
  (# fromType,toType,handlerRefcon: @Integer;
     handler: ##External;
     fromTypeIsDesc,isSysHandler: @Boolean;
     OSErr: @ShortInt;
     
  enter (fromType,toType,handler##,handlerRefcon,fromTypeIsDesc,isSysHandler)
  do '{$303C,$0A22,$A816}'->PascalTrap; 
  exit OSErr
  #);
AEInstallEventHandler: External
  (# theAEEventClass,theAEEventID,handlerRefcon: @Integer;
     handler: ##AppleEventHandler;
     isSysHandler: @Boolean;
     OSErr: @ShortInt;
     
  enter (theAEEventClass,theAEEventID,handler##,handlerRefcon,isSysHandler)
  do '{$303C,$091F,$A816}'->PascalTrap; 
  exit OSErr
  #);
AEInstallSpecialHandler: External
  (# functionClass: @Integer; handler: ##AppleEventHandler; isSysHandler: @Boolean; OSErr: @ShortInt; 
  enter (functionClass,handler##,isSysHandler)
  do '{$303C,$0500,$A816}'->PascalTrap; 
  exit OSErr
  #);
AEInteractWithUser: External
  (# timeOutInTicks,nmReqPtr: @Integer; idleProc: ##External; OSErr: @ShortInt; 
  enter (timeOutInTicks,nmReqPtr,idleProc##)
  do '{$303C,$061C,$A816}'->PascalTrap; 
  exit OSErr
  #);
AEProcessAppleEvent: External
  (# theEventRecord: ^EventRecord; OSErr: @ShortInt; 
  enter theEventRecord[]
  do '{$303C,$021B,$A816}'->PascalTrap; 
  exit OSErr
  #);
AEPutArray: External
  (# theAEDescList: ^AEDescList;
     arrayPtr,itemType,itemSize,itemCount: @Integer;
     arrayType,OSErr: @ShortInt;
     
  enter (theAEDescList[],arrayType,arrayPtr,itemType,itemSize,itemCount)
  do '{$303C,$0B0D,$A816}'->PascalTrap; 
  exit OSErr
  #);
AEPutAttributeDesc: External
  (# theAppleEvent: ^AppleEvent; theAEKeyword: @Integer; theAEDesc: ^AEDesc; OSErr: @ShortInt; 
  enter (theAppleEvent[],theAEKeyword,theAEDesc[])
  do '{$303C,$0627,$A816}'->PascalTrap; 
  exit OSErr
  #);
AEPutAttributePtr: External
  (# theAppleEvent: ^AppleEvent;
     theAEKeyword,typeCode,dataPtr,dataSize: @Integer;
     OSErr: @ShortInt;
     
  enter (theAppleEvent[],theAEKeyword,typeCode,dataPtr,dataSize)
  do '{$303C,$0A16,$A816}'->PascalTrap; 
  exit OSErr
  #);
AEPutDesc: External
  (# theAEDescList: ^AEDescList; index: @Integer; theAEDesc: ^AEDesc; OSErr: @ShortInt; 
  enter (theAEDescList[],index,theAEDesc[])
  do '{$303C,$0609,$A816}'->PascalTrap; 
  exit OSErr
  #);
AEPutParamDesc: External
  (# theAppleEvent: ^AppleEvent; theAEKeyword: @Integer; theAEDesc: ^AEDesc; OSErr: @ShortInt; 
  enter (theAppleEvent[],theAEKeyword,theAEDesc[])
  do '{$303C,$0610,$A816}'->PascalTrap; 
  exit OSErr
  #);
AEPutParamPtr: External
  (# theAppleEvent: ^AppleEvent;
     theAEKeyword,typeCode,dataPtr,dataSize: @Integer;
     OSErr: @ShortInt;
     
  enter (theAppleEvent[],theAEKeyword,typeCode,dataPtr,dataSize)
  do '{$303C,$0A0F,$A816}'->PascalTrap; 
  exit OSErr
  #);
AEPutPtr: External
  (# theAEDescList: ^AEDescList; index,typeCode,dataPtr,dataSize: @Integer; OSErr: @ShortInt; 
  enter (theAEDescList[],index,typeCode,dataPtr,dataSize)
  do '{$303C,$0A08,$A816}'->PascalTrap; 
  exit OSErr
  #);
AERemoveCoercionHandler: External
  (# fromType,toType: @Integer; handler: ##External; isSysHandler: @Boolean; OSErr: @ShortInt; 
  enter (fromType,toType,handler##,isSysHandler)
  do '{$303C,$0723,$A816}'->PascalTrap; 
  exit OSErr
  #);
AERemoveEventHandler: External
  (# theAEEventClass,theAEEventID: @Integer;
     handler: ##External;
     isSysHandler: @Boolean;
     OSErr: @ShortInt;
     
  enter (theAEEventClass,theAEEventID,handler##,isSysHandler)
  do '{$303C,$0720,$A816}'->PascalTrap; 
  exit OSErr
  #);
AERemoveSpecialHandler: External
  (# functionClass: @Integer; handler: ##External; isSysHandler: @Boolean; OSErr: @ShortInt; 
  enter (functionClass,handler##,isSysHandler)
  do '{$303C,$0501,$A816}'->PascalTrap; 
  exit OSErr
  #);
AEResetTimer: External
  (# reply: ^AppleEvent; OSErr: @ShortInt; 
  enter reply[]
  do '{$303C,$0219,$A816}'->PascalTrap; 
  exit OSErr
  #);
AEResumeTheCurrentEvent: External
  (# theAppleEvent,reply: ^AppleEvent;
     dispatcher: ##External;
     handlerRefcon: @Integer;
     OSErr: @ShortInt;
     
  enter (theAppleEvent[],reply[],dispatcher##,handlerRefcon)
  do '{$303C,$0818,$A816}'->PascalTrap; 
  exit OSErr
  #);
AESend: External
  (# theAppleEvent,reply: ^AppleEvent;
     sendMode,timeOutInTicks: @Integer;
     idleProc,filterProc: @integer;
     sendPriority,OSErr: @ShortInt;
     
  enter (theAppleEvent[],reply[],sendMode,sendPriority,timeOutInTicks,idleProc,filterProc)
  do '{$303C,$0D17,$A816}'->PascalTrap; 
  exit OSErr
  #);
AESetInteractionAllowed: External
  (# level: @Char; (* unsigned char *) OSErr: @ShortInt; 
  enter level
  do '{$303C,$011E,$A816}'->PascalTrap; 
  exit OSErr
  #);
AESetTheCurrentEvent: External
  (# theAppleEvent: ^AppleEvent; OSErr: @ShortInt; 
  enter theAppleEvent[]
  do '{$303C,$022C,$A816}'->PascalTrap; 
  exit OSErr
  #);
AESizeOfAttribute: External
  (# theAppleEvent: ^AppleEvent;
     theAEKeyword: @Integer;
     typeCode,dataSize: ^LongInt;
     OSErr: @ShortInt;
     
  enter (theAppleEvent[],theAEKeyword,typeCode[],dataSize[])
  do '{$303C,$0828,$A816}'->PascalTrap; 
  exit OSErr
  #);
AESizeOfKeyDesc: External
  (# theAERecord: ^AERecord;
     theAEKeyword: @Integer;
     typeCode,dataSize: ^LongInt;
     OSErr: @ShortInt;
     
  enter (theAERecord[],theAEKeyword,typeCode[],dataSize[])
  do '{$303C,$0829,$A816}'->PascalTrap; 
  exit OSErr
  #);
AESizeOfNthItem: External
  (# theAEDescList: ^AEDescList;
     index: @Integer;
     typeCode,dataSize: ^LongInt;
     OSErr: @ShortInt;
     
  enter (theAEDescList[],index,typeCode[],dataSize[])
  do '{$303C,$082A,$A816}'->PascalTrap; 
  exit OSErr
  #);
AESizeOfParam: External
  (# theAppleEvent: ^AppleEvent;
     theAEKeyword: @Integer;
     typeCode,dataSize: ^LongInt;
     OSErr: @ShortInt;
     
  enter (theAppleEvent[],theAEKeyword,typeCode[],dataSize[])
  do '{$303C,$0829,$A816}'->PascalTrap; 
  exit OSErr
  #);
AESuspendTheCurrentEvent: External
  (# theAppleEvent: ^AppleEvent; OSErr: @ShortInt; 
  enter theAppleEvent[]
  do '{$303C,$022B,$A816}'->PascalTrap; 
  exit OSErr
  #);
  

documentProc: (# exit 0 #);
dBoxProc: (# exit 1 #);
plainDBox: (# exit 2 #);
altDBoxProc: (# exit 3 #);
noGrowdocProc: (# exit 4 #);
zoomdocProc: (# exit 8 #);
rdocProc: (# exit 16 #);

inDesk: (# exit 0 #);
inMenuBar: (# exit 1 #);
inSysWindow: (# exit 2 #);
inContent: (# exit 3 #);
inDrag: (# exit 4 #);
inGrow: (# exit 5 #);
inGoAway: (# exit 6 #);
inZoomIn: (# exit 7 #);
inZoomOut: (# exit 8 #);

WindowTemplate: ToolboxRecord
  (# bounds: Rect (# Pos::< (# do 0->Value;  #);  #);
     procID: SignedShort (# Pos::< (# do 8->Value;  #);  #);
     visible: Short (# Pos::< (# do 10->Value;  #);  #);
     hasClose: Short (# Pos::< (# do 12->Value;  #);  #);
     refCon: Long (# Pos::< (# do 14->Value;  #);  #);
     nLength: (# exit 18->getByte #);
     getText:
       (# t: [nLength] @Char; 
       do (for i: nLength repeat (i+18)->getByte->t[i] for)
       exit t
       #);
     
  #);
WStateDataPtr: ToolBoxRecord
  (# userState: Rect (# Pos::< (# do 0->Value;  #);  #);
     (* user state *)
     stdState: Rect (# Pos::< (# do 8->Value;  #);  #);
     (* standard state *)
     
  #);
windowPtr: grafPortPtr
  (# windowKind: SignedShort (# Pos::< (# do 108->Value;  #);  #);
     visible: Byte (# Pos::< (# do 110->Value;  #);  #);
     hilited: Byte (# Pos::< (# do 111->Value;  #);  #);
     goAwayFlag: Byte (# Pos::< (# do 112->Value;  #);  #);
     spareFlag: Byte (# Pos::< (# do 113->Value;  #);  #);
     strucRgn: Long (# Pos::< (# do 114->Value;  #);  #);
     contRgn: Long (# Pos::< (# do 118->Value;  #);  #);
     updateRgn: Long (# Pos::< (# do 122->Value;  #);  #);
     windowDefProc: Long (# Pos::< (# do 126->Value;  #);  #);
     dataHandle: Long (# Pos::< (# do 130->Value;  #);  #);
     titleHandle: Long (# Pos::< (# do 134->Value;  #);  #);
     titleWidth: Short (# Pos::< (# do 138->Value;  #);  #);
     controlList: Long (# Pos::< (# do 140->Value;  #);  #);
     nextWindow: Long (# Pos::< (# do 144->Value;  #);  #);
     windowPic: Long (# Pos::< (# do 148->Value;  #);  #);
     refCon: Long (# Pos::< (# do 152->Value;  #);  #);
     
  #);

InvalWindowRgn: external
  (# windowptr: @int32u;
     rgn: @int32u;
     status: @integer;
  enter (windowptr, rgn)
  do callPascal;
  exit status
  #);
InvalWindowRect: external
  (# windowptr: @int32u;
     bounds: ^QRect;
     status: @integer;
  enter (windowptr, bounds[])
  do callPascal;
  exit status
  #);

GetWindowPort: external
  (# window: @integer;
     port: @integer;
  enter window
  do callPascal
  exit port
  #);

InitWindows: External (# do '$A912'->PascalTrap;  #);
GetWMgrPort: External
  (# wPortAddress: @Integer;  enter wPortAddress do '$A910'->PascalTrap;  #);
NewWindow: External
  (# wStorage,behind,refCon,result: @int32;
     boundsRect: ^QRect;
     title: [1] @Char;
     visible,goAwayFlag: @Boolean;
     procId: @int16;
     
  enter (wStorage,boundsRect[],title,visible,procId,behind,goAwayFlag,refCon)
  do '$A913'->PascalTrap; 
  exit result
  #);
GetNewWindow: External
  (# windowId: @ShortInt; wStorage,behind,result: @Integer; 
  enter (windowId,wStorage,behind)
  do '$A9BD'->PascalTrap; 
  exit result
  #);
CloseWindow: External (# theWindow: @Integer;  enter theWindow do '$A92D'->PascalTrap;  #);
DisposeWindow: External (# theWindow: @Integer;  enter theWindow do '$A914'->PascalTrap;  #);
SetWTitle: External
  (# theWindow: @Integer; theTitle: [1] @Char
  enter (theWindow,theTitle)
  do '$A91A'->PascalTrap; 
  #);
GetWTitle: External
  (# theWindow: @Integer; title: ^pascalString; 
  enter (theWindow,title[])
  do '$A919'->PascalTrap; 
  #);
SelectWindow: External (# theWindow: @Integer;  enter theWindow do '$A91F'->PascalTrap;  #);
HideWindow: External (# theWindow: @Integer;  enter theWindow do '$A916'->PascalTrap;  #);
ShowWindow: External (# theWindow: @Integer;  enter theWindow do '$A915'->PascalTrap;  #);
ShowHide: External
  (# theWindow: @Integer; showFlag: @Boolean; 
  enter (theWindow,showFlag)
  do '$A908'->PascalTrap; 
  #);
HiliteWindow: External
  (# theWindow: @Integer; fHilite: @Boolean; 
  enter (theWindow,fHilite)
  do '$A91C'->PascalTrap; 
  #);
BringToFront: External (# theWindow: @Integer;  enter theWindow do '$A920'->PascalTrap;  #);
SendBehind: External
  (# theWindow,behindWindow: @Integer; 
  enter (theWindow,behindWindow)
  do '$A921'->PascalTrap; 
  #);
FrontWindow: External (# theWindow: @Integer;  do '$A924'->PascalTrap;  exit theWindow #);
DrawGrowIcon: External (# theWindow: @Integer;  enter theWindow do '$A904'->PascalTrap;  #);
MoveWindow: External
  (# theWindow: @Integer; hGlobal,vGlobal: @ShortInt; front: @Boolean; 
  enter (theWindow,hGlobal,vGlobal,front)
  do '$A91B'->PascalTrap; 
  #);
SizeWindow: External
  (# theWindow: @Integer; w,h: @ShortInt; fUpdate: @Boolean; 
  enter (theWindow,w,h,fUpdate)
  do '$A91D'->PascalTrap; 
  #);
ZoomWindow: External
  (# theWindow: @Integer; partCode: @ShortInt; front: @Boolean; 
  enter (theWindow,partCode,front)
  do '$A83A'->PascalTrap; 
  #);
InvalRect: External (# badRect: ^QRect enter badRect[] do '$A928'->PascalTrap;  #);
InvalRgn: External (# badRgn: @Integer;  enter badRgn do '$A927'->PascalTrap;  #);
ValidRect: External (# goodRect: ^QRect enter goodRect[] do '$A92A'->PascalTrap;  #);
ValidRgn: External (# goodRgn: @Integer;  enter goodRgn do '$A929'->PascalTrap;  #);
BeginUpdate: External (# theWindow: @Integer;  enter theWindow do '$A922'->PascalTrap;  #);
EndUpdate: External (# theWindow: @Integer;  enter theWindow do '$A923'->PascalTrap;  #);
SetWRefCon: External
  (# theWindow,data: @Integer;  enter (theWindow,data) do '$A918'->PascalTrap;  #);
GetWRefCon: External
  (# theWindow,data: @Integer;  enter theWindow do '$A917'->PascalTrap;  exit data #);
SetWindowPic: External
  (# theWindow,pic: @Integer;  enter (theWindow,pic) do '$A92E'->PascalTrap;  #);
GetWindowPic: External
  (# theWindow,pic: @Integer;  enter theWindow do '$A92F'->PascalTrap;  exit pic #);
CheckUpdate: External (# e: ^eventRecord enter e[] do '$A911'->PascalTrap;  #);
ClipAbove: External (# theWindow: @Integer;  enter theWindow do '$A90B'->PascalTrap;  #);
SaveOld: External (# theWindow: @Integer;  enter theWindow do '$A90E'->PascalTrap;  #);
DrawNew: External
  (# theWindow: @Integer; update: @Boolean; 
  enter (theWindow,update)
  do '$A90F'->PascalTrap; 
  #);
PaintOne: External
  (# theWindow,clobberedRgn: @Integer; 
  enter (theWindow,clobberedRgn)
  do '$A90C'->PascalTrap; 
  #);
PaintBehind: External
  (# theWindow,clobberedRgn: @Integer; 
  enter (theWindow,clobberedRgn)
  do '$A90D'->PascalTrap; 
  #);
CalcVis: External (# theWindow: @Integer;  enter theWindow do '$A909'->PascalTrap;  #);
CalcVisBehind: External
  (# theWindow,clobberedRgn: @Integer; 
  enter (theWindow,clobberedRgn)
  do '$A90A'->PascalTrap; 
  #);
GrowWindow: External
  (# theWindow,startPt,result: @Integer; bBox: ^QRect; 
  enter (theWindow,startPt,bBox[])
  do '$A92B'->PascalTrap; 
  exit result
  #);
FindWindow: External
  (# thePoint: @Integer; whichWindow: @int32; result: @ShortInt; 
  enter (thePoint,whichWindow)
  do '$A92C'->PascalTrap; 
  exit result
  #);
TrackGoAway: External
  (# theWindow,startPt: @Integer; result: @Boolean; 
  enter (theWindow,startPt)
  do '$A91E'->PascalTrap; 
  exit result
  #);
PinRect: External
  (# rect: ^QRect; macPoint: @Integer;  enter (rect[],macPoint) do '$A94E'->PascalTrap;  #);
DragGrayRgn: External
  (# theRgn,startPt,dragGrayRgnProcPtr,result: @Integer;
     boundsRect,slopRect: ^QRect;
     axis: @ShortInt;
     
  enter (theRgn,startPt,boundsRect[],slopRect[],axis,dragGrayRgnProcPtr)
  do '$A905'->PascalTrap; 
  exit result
  #);
TrackBox: External
  (# theWindow,thePt: @Integer; partCode: @ShortInt; result: @Boolean; 
  enter (theWindow,thePt,partCode)
  do '$A83B'->PascalTrap; 
  exit result
  #);
GetCWMgrPort: External
  (# wPortAddress: @Integer;  enter wPortAddress do '$AA48'->PascalTrap;  #);
SetWinColor: External
  (# theWindow,newColorTable: @Integer; 
  enter (theWindow,newColorTable)
  do '$AA41'->PascalTrap; 
  #);
GetAuxWin: External
  (# theWindow: @Integer; auxWinHandl: ^LongInt; 
  enter (theWindow,auxWinHandl[])
  do '$AA42'->PascalTrap; 
  #);
SetDeskCPat: External (# deskPixPat: @Integer;  enter deskPixPat do '$AA47'->PascalTrap;  #);
NewCWindow: External
  (# wStorage,behind,refCon,result: @int32;
     boundsRect: ^QRect;
     title: [1] @Char;
     visible,goAwayFlag: @Boolean;
     procId: @int16;
     
  enter (wStorage,boundsRect[],title,visible,procId,behind,goAwayFlag,refCon)
  do '$AA45'->PascalTrap; 
  exit result
  #);
GetNewCWindow: External
  (# windowId: @ShortInt; wStorage,behind,result: @Integer; 
  enter (windowId,wStorage,behind)
  do '$AA46'->PascalTrap; 
  exit result
  #);
DragWindow: External
  (# theWindow,startPt: @Integer; result: @Boolean; rect: ^QRect
  enter (theWindow,startPt,rect[])
  do '$A925'->PascalTrap; 
  #);
GetWVariant: External
  (# theWindow: @Integer; result: @ShortInt; 
  enter theWindow
  do '$A80A'->PascalTrap; 
  exit result
  #);
GetGrayRgn: External (# rgn: @Integer;  do '{$2EB8,$09EE}'->PascalTrap;  exit rgn #);
  

CreateObjSpecifier: External
  (# desiredClass,keyForm: @Integer;
     theContainer,keyData,objSpecifier: ^AEDesc;
     disposeInputs: @Boolean;
     OSErr: @ShortInt;
     
  enter (desiredClass,theContainer[],keyForm,keyData[],disposeInputs,objSpecifier[])
  do CallPascal; 
  exit OSErr
  #);
  

(************************
 *    Gestalt error codes
 ************************)
gestaltUnknownErr: (# exit - 5550 #);
(* value returned if Gestalt doesn't know the answer *)
gestaltUndefSelectorErr: (# exit - 5551 #);
(* undefined selector was passed to Gestalt *)
gestaltDupSelectorErr: (# exit - 5552 #);
(* tried to add an entry that already existed *)
gestaltLocationErr: (# exit - 5553 #);
(* gestalt function ptr wasn't in sysheap *)
(**************************
 *    Environment Selectors
 **************************)
gestaltVersion: (# exit 'vers' #);
(* gestalt version *)
gestaltAddressingModeAttr: (# exit 'addr' #);
(* addressing mode attributes *)
gestalt32BitAddressing: (# exit 0 #);
(* using 32-bit addressing mode *)
gestalt32BitSysZone: (# exit 1 #);
(* 32-bit compatible system zone *)
gestalt32BitCapable: (# exit 2 #);
(* Machine is 32-bit capable *)
gestaltAliasMgrAttr: (# exit 'alis' #);
(* Alias Mgr Attributes *)
gestaltAliasMgrPresent: (# exit 0 #);
(* True if the Alias Mgr is present *)
gestaltAliasMgrSupportsRemoteAppletalk: (# exit 1 #);
(* True if the Alias Mgr knows about Remote Appletalk *)
gestaltAppleTalkVersion: (# exit 'atlk' #);
(* appletalk version *)
gestaltAUXVersion: (# exit 'a/ux' #);
(*a/ux version, if present *)
gestaltConnMgrAttr: (# exit 'conn' #);
(* connection mgr attributes *)
gestaltConnMgrPresent: (# exit 0 #);
gestaltConnMgrCMSearchFix: (# exit 1 #);
(* Fix to CMAddSearch?  *)
gestaltConnMgrErrorString: (# exit 2 #);
(* has CMGetErrorString() *)
gestaltConnMgrMultiAsyncIO: (# exit 3 #);
(* CMNewIOPB, CMDisposeIOPB, CMPBRead, CMPBWrite, CMPBIOKill *)
gestaltCRMAttr: (# exit 'crm ' #);
(* comm resource mgr attributes *)
gestaltCRMPresent: (# exit 0 #);
gestaltCRMPersistentFix: (# exit 1 #);
(* fix for persistent tools *)
gestaltCRMToolRsrcCalls: (# exit 2 #);
(* has CRMGetToolResource/ReleaseToolResource *)
gestaltCTBVersion: (# exit 'ctbv' #);
(* CommToolbox version *)
gestaltDBAccessMgrAttr: (# exit 'dbac' #);
(* Database Access Mgr attributes *)
gestaltDBAccessMgrPresent: (# exit 0 #);
(* True if Database Access Mgr present *)
gestaltDITLExtAttr: (# exit 'ditl' #);
(* AppenDITL, etc. calls from CTB *)
gestaltDITLExtPresent: (# exit 0 #);
(* True if calls are present *)
gestaltEasyAccessAttr: (# exit 'easy' #);
(* Easy Access attributes *)
gestaltEasyAccessOff: (# exit 0 #);
(* if Easy Access present, but off (no icon) *)
gestaltEasyAccessOn: (# exit 1 #);
(* if Easy Access "On" *)
gestaltEasyAccessSticky: (# exit 2 #);
(* if Easy Access "Sticky" *)
gestaltEasyAccessLocked: (# exit 3 #);
(* if Easy Access "Locked" *)
gestaltEditionMgrAttr: (# exit 'edtn' #);
(* Edition Mgr attributes *)
gestaltEditionMgrPresent: (# exit 0 #);
(* True if Edition Mgr present *)
gestaltAppleEventsAttr: (# exit 'evnt' #);
(* Apple Events attributes *)
gestaltAppleEventsPresent: (# exit 0 #);
(* True if Apple Events present *)
gestaltFindFolderAttr: (# exit 'fold' #);
(* Folder Mgr attributes *)
gestaltFindFolderPresent: (# exit 0 #);
(* True if Folder Mgr present *)
gestaltFontMgrAttr: (# exit 'font' #);
(* Font Mgr attributes *)
gestaltOutlineFonts: (# exit 0 #);
(* True if Outline Fonts supported *)
gestaltFPUType: (# exit 'fpu ' #);
(* fpu type *)
gestaltNoFPU: (# exit 0 #);
(* no FPU *)
gestalt68881: (# exit 1 #);
(* 68881 FPU *)
gestalt68882: (# exit 2 #);
(* 68882 FPU *)
gestalt68040FPU: (# exit 3 #);
(* 68040 built-in FPU *)
gestaltFSAttr: (# exit 'fs  ' #);
(* file system attributes *)
gestaltFullExtFSDispatching: (# exit 0 #);
(* has really cool new HFSDispatch dispatcher *)
gestaltHasFSSpecCalls: (# exit 1 #);
(* has FSSpec calls *)
gestaltHasFileSystemManager: (# exit 2 #);
(* has a file system manager *)
gestaltFXfrMgrAttr: (# exit 'fxfr' #);
(* file transfer manager attributes *)
gestaltFXfrMgrPresent: (# exit 0 #);
gestaltFXfrMgrMultiFile: (# exit 1 #);
(* supports FTSend and FTReceive *)
gestaltFXfrMgrErrorString: (# exit 2 #);
(* supports FTGetErrorString *)
gestaltHardwareAttr: (# exit 'hdwr' #);
(* hardware attributes *)
gestaltHasVIA1: (# exit 0 #);
(* VIA1 exists *)
gestaltHasVIA2: (# exit 1 #);
(* VIA2 exists *)
gestaltHasASC: (# exit 3 #);
(* Apple Sound Chip exists *)
gestaltHasSCC: (# exit 4 #);
(* SCC exists *)
gestaltHasSCSI: (# exit 7 #);
(* SCSI exists *)
gestaltHasSoftPowerOff: (# exit 19 #);
(* Capable of software power off *)
gestaltHasSCSI961: (# exit 21 #);
(* 53C96 SCSI controller on internal bus *)
gestaltHasSCSI962: (# exit 22 #);
(* 53C96 SCSI controller on external bus *)
gestaltHasUniversalROM: (# exit 24 #);
(* Do we have a Universal ROM?*)
gestaltHelpMgrAttr: (# exit 'help' #);
(* Help Mgr Attributes *)
gestaltHelpMgrPresent: (# exit 0 #);
(* true if help mgr is present *)
gestaltKeyboardType: (# exit 'kbd ' #);
(* keyboard type *)
gestaltMacKbd: (# exit 1 #);
gestaltMacAndPad: (# exit 2 #);
gestaltMacPlusKbd: (# exit 3 #);
gestaltExtADBKbd: (# exit 4 #);
gestaltStdADBKbd: (# exit 5 #);
gestaltPrtblADBKbd: (# exit 6 #);
gestaltPrtblISOKbd: (# exit 7 #);
gestaltStdISOADBKbd: (# exit 8 #);
gestaltExtISOADBKbd: (# exit 9 #);
gestaltADBKbdII: (# exit 10 #);
gestaltADBISOKbdII: (# exit 11 #);
gestaltPwrBookADBKbd: (# exit 12 #);
gestaltPwrBookISOADBKbd: (# exit 13 #);
gestaltLowMemorySize: (# exit 'lmem' #);
(* size of low memory area *)
gestaltLogicalRAMSize: (# exit 'lram' #);
(* logical ram size *)
gestaltMiscAttr: (# exit 'misc' #);
(* miscellaneous attributes *)
gestaltScrollingThrottle: (# exit 0 #);
(* true if scrolling throttle on *)
gestaltSquareMenuBar: (# exit 2 #);
(* true if menu bar is square *)
gestaltMMUType: (# exit 'mmu ' #);
(* mmu type *)
gestaltNoMMU: (# exit 0 #);
(* no MMU *)
gestaltAMU: (# exit 1 #);
(* address management unit *)
gestalt68851: (# exit 2 #);
(* 68851 PMMU *)
gestalt68030MMU: (# exit 3 #);
(* 68030 built-in MMU *)
gestalt68040MMU: (# exit 4 #);
(* 68040 built-in MMU *)
gestaltStdNBPAttr: (# exit 'nlup' #);
(* standard nbp attributes *)
gestaltStdNBPPresent: (# exit 0 #);
gestaltNotificationMgrAttr: (# exit 'nmgr' #);
(* notification manager attributes *)
gestaltNotificationPresent: (# exit 0 #);
(* notification manager exists *)
gestaltNuBusConnectors: (# exit 'sltc' #);
(* bitmap of NuBus connectors*)
gestaltOSAttr: (# exit 'os  ' #);
(* o/s attributes *)
gestaltSysZoneGrowable: (# exit 0 #);
(* system heap is growable *)
gestaltLaunchCanReturn: (# exit 1 #);
(* can return from launch *)
gestaltLaunchFullFileSpec: (# exit 2 #);
(* can launch from full file spec *)
gestaltLaunchControl: (# exit 3 #);
(* launch control support available *)
gestaltTempMemSupport: (# exit 4 #);
(* temp memory support *)
gestaltRealTempMemory: (# exit 5 #);
(* temp memory handles are real *)
gestaltTempMemTracked: (# exit 6 #);
(* temporary memory handles are tracked *)
gestaltIPCSupport: (# exit 7 #);
(* IPC support is present *)
gestaltSysDebuggerSupport: (# exit 8 #);
(* system debugger support is present *)
gestaltOSTable: (# exit 'ostt' #);
(*  OS trap table base  *)
gestaltToolboxTable: (# exit 'tbtt' #);
(*  OS trap table base  *)
gestaltExtToolboxTable: (# exit 'xttt' #);
(* Extended Toolbox trap table base *)
gestaltLogicalPageSize: (# exit 'pgsz' #);
(* logical page size *)
gestaltPowerMgrAttr: (# exit 'powr' #);
(* power manager attributes *)
gestaltPMgrExists: (# exit 0 #);
gestaltPMgrCPUIdle: (# exit 1 #);
gestaltPMgrSCC: (# exit 2 #);
gestaltPMgrSound: (# exit 3 #);
gestaltPPCToolboxAttr: (# exit 'ppc ' #);
(* PPC toolbox attributes *)
(*
 * PPC will return the combination of following bit fields.
 * e.g. gestaltPPCSupportsRealTime +gestaltPPCSupportsIncoming + gestaltPPCSupportsOutGoing
 * indicates PPC is cuurently is only supports real time delivery
 * and both incoming and outgoing network sessions are allowed.
 * By default local real time delivery is supported as long as PPCInit has been called.
 *)
gestaltPPCToolboxPresent: (# exit 0 #);
(* PPC Toolbox is present  Requires PPCInit to be called *)
gestaltPPCSupportsRealTime: (# exit 4096 #);
(* PPC Supports real-time delivery *)
gestaltPPCSupportsIncoming: (# exit 1 #);
(* PPC will deny incoming network requests *)
gestaltPPCSupportsOutGoing: (# exit 2 #);
(* PPC will deny outgoing network requests *)
gestaltProcessorType: (# exit 'proc' #);
(* processor type *)
gestalt68000: (# exit 1 #);
gestalt68010: (# exit 2 #);
gestalt68020: (# exit 3 #);
gestalt68030: (# exit 4 #);
gestalt68040: (# exit 5 #);
gestaltParityAttr: (# exit 'prty' #);
(* parity attributes *)
gestaltHasParityCapability: (# exit 0 #);
(* has ability to check parity *)
gestaltParityEnabled: (# exit 1 #);
(* parity checking enabled *)
gestaltQuickdrawVersion: (# exit 'qd  ' #);
(* quickdraw version *)
gestaltOriginalQD: (# exit 0 #);
(* original 1-bit QD *)
gestalt8BitQD: (# exit 256 #);
(* 8-bit color QD *)
gestalt32BitQD: (# exit 512 #);
(* 32-bit color QD *)
gestalt32BitQD11: (# exit 528 #);
(* 32-bit color QDv1.1 *)
gestalt32BitQD12: (# exit 544 #);
(* 32-bit color QDv1.2 *)
gestalt32BitQD13: (# exit 560 #);
(* 32-bit color QDv1.3 *)
gestaltQuickdrawFeatures: (# exit 'qdrw' #);
(* quickdraw features *)
gestaltHasColor: (# exit 0 #);
(* color quickdraw present *)
gestaltHasDeepGWorlds: (# exit 1 #);
(* GWorlds can be deeper than 1-bit *)
gestaltHasDirectPixMaps: (# exit 2 #);
(* PixMaps can be direct (16 or 32 bit) *)
gestaltHasGrayishTextOr: (# exit 3 #);
(* supports text mode grayishTextOr *)
gestaltPhysicalRAMSize: (# exit 'ram ' #);
(* physical RAM size *)
gestaltPopupAttr: (# exit 'pop!' #);
(* popup cdef attributes *)
gestaltPopupPresent: (# exit 0 #);
gestaltResourceMgrAttr: (# exit 'rsrc' #);
(* Resource Mgr attributes *)
gestaltPartialRsrcs: (# exit 0 #);
(* True if partial resources exist *)
gestaltScriptMgrVersion: (# exit 'scri' #);
(* Script Manager version number <08/05/89 pke> *)
gestaltScriptCount: (# exit 'scr#' #);
(* number of active script systems <08/05/89 pke> *)
gestaltSerialAttr: (# exit 'ser ' #);
(* Serial attributes *)
gestaltHasGPIaToDCDa: (# exit 0 #);
(* GPIa connected to DCDa*)
gestaltHasGPIaToRTxCa: (# exit 1 #);
(* GPIa connected to RTxCa clock input*)
gestaltHasGPIbToDCDb: (# exit 2 #);
(* GPIb connected to DCDb *)
gestaltSoundAttr: (# exit 'snd ' #);
(* sound attributes *)
gestaltStereoCapability: (# exit 0 #);
(* sound hardware has stereo capability *)
gestaltStereoMixing: (# exit 1 #);
(* stereo mixing on external speaker *)
gestaltSoundIOMgrPresent: (# exit 3 #);
(* The Sound I/O Manager is present *)
gestaltBuiltInSoundInput: (# exit 4 #);
(* built-in Sound Input hardware is present *)
gestaltHasSoundInputDevice: (# exit 5 #);
(* Sound Input device available *)
gestaltStandardFileAttr: (# exit 'stdf' #);
(* Standard File attributes *)
gestaltStandardFile58: (# exit 0 #);
(* True if selectors 5-8 (StandardPutFile-CustomGetFile) are supported *)
gestaltTextEditVersion: (# exit 'te  ' #);
(* TextEdit version number <08/05/89 pke> *)
gestaltTE1: (# exit 1 #);
(* TextEdit in MacIIci ROM <8Aug89smb> *)
gestaltTE2: (# exit 2 #);
(* TextEdit with 6.0.4 Script Systems on MacIIci (Script bug fixes for MacIIci) <8Aug89smb> *)
gestaltTE3: (# exit 3 #);
(* TextEdit with 6.0.4 Script Systems all but MacIIci <8Aug89smb> *)
gestaltTE4: (# exit 4 #);
(* TextEdit in System 7.0 *)
gestaltTE5: (# exit 5 #);
(* TextWidthHook available in TextEdit *)
gestaltTermMgrAttr: (# exit 'term' #);
(* terminal mgr attributes *)
gestaltTermMgrPresent: (# exit 0 #);
gestaltTermMgrErrorString: (# exit 2 #);
gestaltTimeMgrVersion: (# exit 'tmgr' #);
(* time mgr version *)
gestaltStandardTimeMgr: (# exit 1 #);
(* standard time mgr is present *)
gestaltRevisedTimeMgr: (# exit 2 #);
(* revised time mgr is present *)
gestaltExtendedTimeMgr: (# exit 3 #);
(* extended time mgr is present *)
gestaltVMAttr: (# exit 'vm  ' #);
(* virtual memory attributes *)
gestaltVMPresent: (# exit 0 #);
(* true if virtual memory is present *)
(*************************
 *    Info-only selectors
 ************************)
gestaltMachineType: (# exit 'mach' #);
(* machine type *)
kMachineNameStrID: (# exit - 16395 #);
gestaltClassic: (# exit 1 #);
gestaltMacXL: (# exit 2 #);
gestaltMac512KE: (# exit 3 #);
gestaltMacPlus: (# exit 4 #);
gestaltMacSE: (# exit 5 #);
gestaltMacII: (# exit 6 #);
gestaltMacIIx: (# exit 7 #);
gestaltMacIIcx: (# exit 8 #);
gestaltMacSE030: (# exit 9 #);
gestaltPortable: (# exit 10 #);
gestaltMacIIci: (# exit 11 #);
gestaltMacIIfx: (# exit 13 #);
gestaltMacClassic: (# exit 17 #);
gestaltMacIIsi: (# exit 18 #);
gestaltMacLC: (# exit 19 #);
gestaltQuadra900: (# exit 20 #);
gestaltPowerBook170: (# exit 21 #);
gestaltQuadra700: (# exit 22 #);
gestaltClassicII: (# exit 23 #);
gestaltPowerBook100: (# exit 24 #);
gestaltPowerBook140: (# exit 25 #);
gestaltMachineIcon: (# exit 'micn' #);
(* machine icon *)
gestaltROMSize: (# exit 'rom ' #);
(* rom size *)
gestaltROMVersion: (# exit 'romv' #);
(* rom version *)
gestaltSystemVersion: (# exit 'sysv' #);
(* system version*)
Gestalt: External
  (# selector: @Integer; response: ^LongInt; OSErr: @ShortInt; 
  enter (selector,response[])
  do (*'GESTALT'->*) CallPascal
  exit OSErr
  #);
  

Cell: macPoint (# #);
LNoRect: (# exit 8 #);
LNoExtend: (# exit 16 #);
LNoDisjoint: (# exit 32 #);
LextendDrag: (# exit 64 #);
LOnlyOne: (# exit - 128 #);
LNoHilte: (# exit 2 #);
LUseSense: (# exit 4 #);
LDoHAutoScroll: (# exit 1 #);
LDoVAutoScroll: (# exit 2 #);
listRec: ToolboxRecord
  (# rView: Rect (# Pos::< (# do 0->Value;  #);  #);
     port: Long (# Pos::< (# do 8->Value;  #);  #);
     indent: Long (# Pos::< (# do 12->Value;  #);  #);
     CellSize: Long (# Pos::< (# do 16->Value;  #);  #);
     visible: Rect (# Pos::< (# do 20->Value;  #);  #);
     vScroll: Long (# Pos::< (# do 28->Value;  #);  #);
     hScroll: Long (# Pos::< (# do 32->Value;  #);  #);
     selFlags: Byte (# Pos::< (# do 36->Value;  #);  #);
     lActive: Byte (# Pos::< (# do 37->Value;  #);  #);
     lReserved: Byte (# Pos::< (# do 38->Value;  #);  #);
     listFlags: Byte (# Pos::< (# do 39->Value;  #);  #);
     clikTime: Long (# Pos::< (# do 40->Value;  #);  #);
     clikLoc: Long (# Pos::< (# do 44->Value;  #);  #);
     mouseLoc: Long (# Pos::< (# do 48->Value;  #);  #);
     lClikLoop: Long (# Pos::< (# do 52->Value;  #);  #);
     lastClick: Long (# Pos::< (# do 56->Value;  #);  #);
     refCon: Long (# Pos::< (# do 60->Value;  #);  #);
     listDefProc: Long (# Pos::< (# do 64->Value;  #);  #);
     userHandle: Long (# Pos::< (# do 68->Value;  #);  #);
     dataBounds: Rect (# Pos::< (# do 72->Value;  #);  #);
     Cells: Long (# Pos::< (# do 80->Value;  #);  #);
     maxIndex: Short (# Pos::< (# do 84->Value;  #);  #);
     CellArray: Long (# Pos::< (# do 86->Value;  #);  #);
     
  #);
  
GetCell:
	(# theCell: @integer;
		listHandle: @integer;
		data: ^text;
		count: @shortRef;
	enter (theCell, listHandle)
	do &text[] -> data[];
		1024 -> data.extend;
		1024 -> count;
		(@@data.T[1],count[],theCell,listHandle) -> LGetCell;
   	count -> data.lgth -> data.pos;
	exit data[]
	#);
SetCell:
	(# theCell: @integer;
		listHandle: @integer;
		data: ^text;
	enter (theCell, data[], listHandle)
	do (if (data[] <> NONE) AND (data.lgth > 0) then
			(@@data.T[1], data.lgth, theCell, listHandle) -> LSetCell;
		else
			(0, 0, theCell, listHandle) -> LSetCell;
		if);
	#);


LAddColumn: External
  (# count,colNum,result: @ShortInt; lHandle: @Integer; 
  enter (count,colNum,lHandle)
  do '{$3F3C,$0004,$A9E7}'->PascalTrap; 
  exit result
  #);
LAddRow: External
  (# count,rowNum,result: @ShortInt; lHandle: @Integer; 
  enter (count,rowNum,lHandle)
  do '{$3F3C,$0008,$A9E7}'->PascalTrap; 
  exit result
  #);
LAddToCell: External
  (# dataPtr,theCell,lHandle: @Integer; dataLen: @ShortInt; 
  enter (dataPtr,dataLen,theCell,lHandle)
  do '{$3F3C,$000C,$A9E7}'->PascalTrap; 
  #);
LAutoScroll: External
  (# lHandle: @Integer;  enter lHandle do '{$3F3C,$0010,$A9E7}'->PascalTrap;  #);
LCellSize: External
  (# cSize,lHandle: @Integer;  enter (cSize,lHandle) do '{$3F3C,$0014,$A9E7}'->PascalTrap;  #);
LClick: External
  (# pt,lHandle: @Integer; modifiers: @ShortInt; result: @Boolean; 
  enter (pt,modifiers,lHandle)
  do '{$3F3C,$0018,$A9E7}'->PascalTrap; 
  exit result
  #);
LClrCell: External
  (# theCell,lHandle: @Integer; 
  enter (theCell,lHandle)
  do '{$3F3C,$001C,$A9E7}'->PascalTrap; 
  #);
LDelColumn: External
  (# count,colNum: @ShortInt; LHandle: @Integer; 
  enter (count,colNum,LHandle)
  do '{$3F3C,$0020,$A9E7}'->PascalTrap; 
  #);
LDelRow: External
  (# count,rowNum: @ShortInt; LHandle: @Integer; 
  enter (count,rowNum,LHandle)
  do '{$3F3C,$0024,$A9E7}'->PascalTrap; 
  #);
LDisPose: External
  (# lHandle: @Integer;  enter lHandle do '{$3F3C,$0028,$A9E7}'->PascalTrap;  #);
LSetDrawingMode: External
  (# drawIt: @Boolean; lHandle: @Integer; 
  enter (drawIt,lHandle)
  do '{$3F3C,$002C,$A9E7}'->PascalTrap; 
  #);
LDraw: External
  (# theCell,lHandle: @Integer; 
  enter (theCell,lHandle)
  do '{$3F3C,$0030,$A9E7}'->PascalTrap; 
  #);
LFind: External
  (# offset,len: ^longInt; theCell,lHandle: @Integer; 
  enter (offset[],len[],theCell,lHandle)
  do '{$3F3C,$0034,$A9E7}'->PascalTrap; 
  #);
LGetCell: External
  (# dataPtr,theCell,lHandle: @Integer; dataLen: ^CStruct; 
  enter (dataPtr,dataLen[],theCell,lHandle)
  do '{$3F3C,$0038,$A9E7}'->PascalTrap; 
  #);
LGetSelect: External
  (# next,result: @Boolean; theCell: ^QPoint; lHandle: @Integer; 
  enter (next,theCell[],lHandle)
  do '{$3F3C,$003C,$A9E7}'->PascalTrap; 
  exit result
  #);
LLastClick: External
  (# lHandle,Cell: @Integer; 
  enter lHandle
  do '{$3F3C,$0040,$A9E7}'->PascalTrap; 
  exit Cell
  #);
LNew: External
  (# rView,dataBounds: ^QRect;
     cSize,theWindow,listhandle: @Integer;
     theProc: @ShortInt;
     drawIt,hasGrow,scroolH,scrollV: @Boolean;
     
  enter (rView[],dataBounds[],cSize,theProc,theWindow,drawIt,hasGrow,scroolH,scrollV)
  do '{$3F3C,$0044,$A9E7}'->PascalTrap; 
  exit listhandle
  #);
LNextCell: External
  (# hNext,vNext,result: @Boolean; theCell: ^QPoint; lHandle: @Integer; 
  enter (hnext,vNext,theCell[],lHandle)
  do '{$3F3C,$0048,$A9E7}'->PascalTrap; 
  exit result
  #);
LRect: External
  (# CellRect: ^QRect; theCell,lHandle: @Integer; 
  enter (CellRect[],theCell,lHandle)
  do '{$3F3C,$004C,$A9E7}'->PascalTrap; 
  #);
LScroll: External
  (# dCols,dRows: @ShortInt; lHandle: @Integer; 
  enter (dCols,dRows,lHandle)
  do '{$3F3C,$0050,$A9E7}'->PascalTrap; 
  #);
LSearch: External
  (# dataPtr,searchProc,lHandle: @Integer; dataLen: @ShortInt; theCell: ^QPoint; result: @Boolean
  enter (dataPtr,dataLen,searchProc,theCell[],lHandle)
  do '{$3F3C,$0054,$A9E7}'->PascalTrap; 
  exit result
  #);
LSetCell: External
  (# dataPtr,theCell,lHandle: @Integer; dataLen: @ShortInt; 
  enter (dataPtr,dataLen,theCell,lHandle)
  do '{$3F3C,$0058,$A9E7}'->PascalTrap; 
  #);
LSetSelect: External
  (# setIt: @Boolean; theCell,lHandle: @Integer; 
  enter (setIt,theCell,lHandle)
  do '{$3F3C,$005C,$A9E7}'->PascalTrap; 
  #);
LSize: External
  (# listWidth,listHeight: @ShortInt; lHandle: @Integer; 
  enter (listWidth,listHeight,lHandle)
  do '{$3F3C,$0060,$A9E7}'->PascalTrap; 
  #);
LUpdate: External
  (# theRgn,lHandle: @Integer; 
  enter (theRgn,lHandle)
  do '{$3F3C,$0064,$A9E7}'->PascalTrap; 
  #);
LActivate: External
  (# act: @Boolean; lHandle: @Integer; 
  enter (act,lHandle)
  do '{$4267,$A9E7}'->PascalTrap; 
  #);

getwd: External (# addr: @Integer; pathName: [1] @Char enter addr exit pathname #);
getCurrentDir:
  (# Chars: [400] @Char; cwd: ^Text; 
  do &Text[]->cwd[]; @@ Chars[1]->getwd->pToC->cwd; 
  exit cwd[]
  #);
PathNameFromDirID: External
  (# DirID,vRefNum,s: @Integer; p: [1] @Char;  enter (DirID,vRefNum,s) exit p #);
PathNameFromWD: External
  (# vRefNum,stringArrayAddress: @Integer; p: [1] @Char; 
  enter (vRefNum,stringArrayAddress)
  exit p
  #);
  


MenuPtr: ToolboxRecord
  (# (* Offsets taken from Inside Macintosh I-366 *)
     menuID: Short (# pos::< (# do 0->value #) #);
     menuWidth: Short (# pos::< (# do 2->value #) #);
     menuHeight: Short (# pos::< (# do 4->value #) #);
     menuProc: Long (# pos::< (# do 6->value #) #);
     enableFlags: Long (# pos::< (# do 10->value #) #);
     titleLen: byte (# pos::< (# do 14->value #) #);
     getTitle:
       (# t: [titleLen] @Char; 
       do (for i: titleLen repeat (i+14)->getByte->t[i] for)
       exit t
       #);
     itemBase: (# exit 15+titleLen #);
     
  #);
InitMenus: External (# do '$A930'->PascalTrap;  #);
NewMenu: External
  (# menuId: @ShortInt; menuTitle: [1] @Char; menuHandle: @Integer; 
  enter (menuId,menuTitle)
  do '$A931'->PascalTrap; 
  exit menuHandle
  #);
GetMenu: External
  (# resourceId: @ShortInt; menuHandle: @Integer; 
  enter resourceId
  do '$A9BF'->PascalTrap; 
  exit menuHandle
  #);
DisposeMenu: External (# menuHandle: @Integer;  enter menuHandle do '$A932'->PascalTrap;  #);
AppendMenu: External
  (# menuHandle: @Integer; str255: [1] @Char
  enter (menuHandle,str255)
  do '$A933'->PascalTrap; 
  #);
AppendResMenu: External
  (# menuHandle,theType: @Integer;  enter (menuHandle,theType) do '$A94D'->PascalTrap;  #);
InsertResMenu: External
  (# menuHandle,theType: @Integer; afterItem: @ShortInt; 
  enter (menuHandle,theType,afterItem)
  do '$A951'->PascalTrap; 
  #);
InsertMenu: External
  (# menuHandle: @Integer; beforeId: @ShortInt; 
  enter (menuHandle,beforeId)
  do '$A935'->PascalTrap; 
  #);
DrawMenuBar: External (# do '$A937'->PascalTrap;  #);
InvalMenuBar: External (# do CallPascal  #);
DeleteMenu: External (# menuID: @ShortInt;  enter menuId do '$A936'->PascalTrap;  #);
ClearMenuBar: External (# do '$A934'->PascalTrap;  #);
GetNewMBar: External
  (# menuBarId: @ShortInt; theHandle: @Integer; 
  enter menuBarId
  do '$A9C0'->PascalTrap; 
  exit theHandle
  #);
GetMenuBar: External (# theHandle: @Integer;  do '$A93B'->PascalTrap;  exit theHandle #);
SetMenuBar: External (# menuList: @Integer;  enter menuList do '$A93C'->PascalTrap;  #);
InsertMenuItem: External
  (# theHandle: @Integer; itemString: [1] @Char; afterItem: @ShortInt; 
  enter (theHandle,itemString,afterItem)
  do '$A826'->PascalTrap; 
  #);
DeleteMenuItem: External
  (# theHandle: @Integer; Item: @ShortInt; 
  enter (theHandle,item)
  do '$A952'->PascalTrap; 
  #);
MenuSelect: External
  (# startPt,result: @Integer;  enter startPt do '$A93D'->PascalTrap;  exit result #);
MenuKey: External
  (# ch: @ShortInt; result: @Integer;  enter ch do '$A93E'->PascalTrap;  exit result #);
HiliteMenu: External (# menuId: @ShortInt;  enter menuId do '$A938'->PascalTrap;  #);
SetMenuItemText: External
  (# theMenu: @Integer; item: @ShortInt; ItemString: [1] @Char
  enter (theMenu,item,itemString)
  do '$A947'->PascalTrap; 
  #);
GetMenuItemText: External
  (# theMenu: @Integer; item: @ShortInt; ItemString: ^PascalString
  enter (theMenu,item,itemString[])
  do '$A946'->PascalTrap; 
  #);
EnableItem: External
  (# theMenu: @Integer; item: @ShortInt;  enter (theMenu,item) do '$A939'->PascalTrap;  #);
DisableItem: External
  (# theMenu: @Integer; item: @ShortInt;  enter (theMenu,item) do '$A93A'->PascalTrap;  #);
CheckItem: External
  (# theMenu: @Integer; item: @ShortInt; checked: @boolean
  enter (theMenu,item,checked)
  do '$A945'->PascalTrap; 
  #);
SetItemMark: External
  (# theMenu: @Integer; item: @ShortInt; markChar: @ShortInt; 
  enter (theMenu,item,markChar)
  do '$A944'->PascalTrap; 
  #);
GetItemMark: External
  (# theMenu: @Integer; item: @ShortInt; markChar: ^ShortRef; 
  enter (theMenu,item,markChar[])
  do '$A943'->PascalTrap; 
  #);
SetItemIcon: External
  (# theMenu: @Integer; item,icon: @ShortInt; 
  enter (theMenu,item,icon)
  do '$A940'->PascalTrap; 
  #);
GetItemIcon: External
  (# theMenu: @Integer; item,icon: ^ShortRef; 
  enter (theMenu,item,icon[])
  do '$A93F'->PascalTrap; 
  #);
SetItemStyle: External
  (# theMenu: @Integer; item,style: @ShortInt; 
  enter (theMenu,item,style)
  do '$A942'->PascalTrap; 
  #);
GetItemStyle: External
  (# theMenu: @Integer; item: @ShortInt; style: ^ShortRef; 
  enter (theMenu,item,style[])
  do '$A941'->PascalTrap; 
  #);
CalcMenuSize: External (# menuHandle: @Integer;  enter menuHandle do '$A948'->PascalTrap;  #);
CountMItems: External
  (# menuHandle: @Integer; number: @ShortInt; 
  enter menuHandle
  do '$A950'->PascalTrap; 
  exit number
  #);
GetMenuHandle: External
  (# menuId: @ShortInt; menuHandle: @Integer; 
  enter menuId
  do '$A949'->PascalTrap; 
  exit menuHandle
  #);
FlashMenuBar: External (# menuId: @ShortInt;  enter menuId do '$A94C'->PascalTrap;  #);
SetMenuFlash: External (# count: @ShortInt;  enter count do '$A94A'->PascalTrap;  #);
InitProcMenu: External (# mbResId: @ShortInt;  enter mbResId do '$A408'->PascalTrap;  #);
DelMCEntries: External
  (# menuId,menuItem: @ShortInt;  enter (menuId,menuItem) do '$AA60'->PascalTrap;  #);
GetMcInfo: External
  (# mcTableHandle: @Integer;  do '$AA61'->PascalTrap;  exit mcTableHandle #);
SetMcInfo: External
  (# mcTableHandle: @Integer;  enter mcTableHandle do '$AA62'->PascalTrap;  #);
DispMcInfo: External
  (# mcTableHandle: @Integer;  enter mcTableHandle do '$AA63'->PascalTrap;  #);
GetMCEntry: External
  (# menuId,menuItem: @ShortInt; mcEntryPtr: @Integer; 
  enter (menuId,menuItem)
  do '$AA64'->PascalTrap; 
  exit mcEntryPtr
  #);
SetMCEntries: External
  (# numEntries: @ShortInt; mcEntryPtr: @Integer; 
  enter (numEntries,mcEntryPtr)
  do '$AA65'->PascalTrap; 
  #);
MenuChoice: External (# result: @Integer;  do '$AA66'->PascalTrap;  exit result #);
GetItemCmd: External
  (# theMenu: @Integer; item: @ShortInt; cmdChar: ^ShortRef; 
  enter (theMenu,item,cmdChar[])
  do '$A84E'->PascalTrap; 
  #);
SetItemCmd: External
  (# theMenu: @Integer; item,cmdChar: @ShortInt; 
  enter (theMenu,item,cmdChar)
  do '$A84F'->PascalTrap; 
  #);
PopUpMenuSelect: External
  (# theMenu,result: @Integer; top,left,popupItem: @ShortInt; 
  enter (theMenu,top,left,popUpItem)
  do '$A80B'->PascalTrap; 
  exit result
  #);
InvalidMenuBar: External (# do '$A81D'->PascalTrap;  #);
  

EvQElPtr: ToolboxRecord
  (# qLink: Long (# Pos::< (# do 0->Value;  #);  #);
     qType: Short (# Pos::< (# do 4->Value;  #);  #);
     evtQWhat: Short (# Pos::< (# do 6->Value;  #);  #);
     evtQMessage: Long (# Pos::< (# do 8->Value;  #);  #);
     evtQWhen: Long (# Pos::< (# do 12->Value;  #);  #);
     evtQWhere: Long (# Pos::< (# do 16->Value;  #);  #);
     evtQModifiers: Short (# Pos::< (# do 20->Value;  #);  #);
     
  #);
QHdrPtr: ToolboxRecord
  (# qFlags: Short (# Pos::< (# do 0->Value;  #);  #);
     qHead: Long (# Pos::< (# do 2->Value;  #);  #);
     qTail: Long (# Pos::< (# do 6->Value;  #);  #);
     
  #);
SysEnvRec: ToolboxRecord
  (# environsVersion: Short (# Pos::< (# do 0->Value;  #);  #);
     machineType: Short (# Pos::< (# do 2->Value;  #);  #);
     systemVersion: Short (# Pos::< (# do 4->Value;  #);  #);
     system: Byte (# Pos::< (# do 4->Value;  #);  #);
     Version: Byte (# Pos::< (# do 5->Value;  #);  #);
     processor: Short (# Pos::< (# do 6->Value;  #);  #);
     hasFPU: Byte (# Pos::< (# do 8->Value;  #);  #);
     hasColorQD: Byte (# Pos::< (# do 9->Value;  #);  #);
     keyBoardType: Short (# Pos::< (# do 10->Value;  #);  #);
     atDrvrVersNum: Short (# Pos::< (# do 12->Value;  #);  #);
     sysVRefNum: Short (# Pos::< (# do 14->Value;  #);  #);
     envMachUnknown: (# exit 0 #);
     env512KE: (# exit 1 #);
     envMacPlus: (# exit 2 #);
     envSE: (# exit 3 #);
     envMacII: (# exit 4 #);
     envMacIIx: (# exit 5 #);
     envMacIIcx: (# exit 6 #);
     envSE30: (# exit 7 #);
     envPortable: (# exit 8 #);
     envMACIIci: (# exit 9 #);
     envCPUUnknown: (# exit 0 #);
     env68000: (# exit 1 #);
     env68010: (# exit 2 #);
     env68020: (# exit 3 #);
     env68030: (# exit 4 #);
     envUnknownKbd: (# exit 0 #);
     envMacKbd: (# exit 1 #);
     envMacAndPad: (# exit 2 #);
     envMacPlusKbd: (# exit 3 #);
     envAExtendKbd: (# exit 4 #);
     envStandADBKbd: (# exit 5 #);
     envPortADBKbd: (# exit 6 #);
     envPortISOADBKbd: (# exit 7 #);
     envStdISOADBKbd: (# exit 8 #);
     envExtISOADBKbd: (# exit 9 #);
     
  #);
DateTimeRec: CStruct
  (# ByteSize::< (# do 14->Value;  #);
     Year: Short (# Pos::< (# do 0->Value;  #);  #);
     Month: Short (# Pos::< (# do 2->Value;  #);  #);
     Day: Short (# Pos::< (# do 4->Value;  #);  #);
     Hour: Short (# Pos::< (# do 6->Value;  #);  #);
     Minute: Short (# Pos::< (# do 8->Value;  #);  #);
     Second: Short (# Pos::< (# do 10->Value;  #);  #);
     DayOfWeek: Short (# Pos::< (# do 12->Value;  #);  #);
     
  #);
(* in script *)
GetEnvirons: External
  (# verb: @ShortInt; result: @Integer; 
  enter verb
  do '{$2F3C,$8402,$0008,$A8B5}'->PascalTrap; 
  exit result
  #);
GetScript: External
  (# script,verb: @ShortInt; result: @Integer; 
  enter (script,verb)
  do '{$2F3C,$8404,$000C,$A8B5}'->PascalTrap
  exit result
  #);
SysEnvirons: External
  (# OSErr,versionRequsted: @ShortInt; theWorld: @Integer; 
  enter (versionRequsted,theWorld)
  do pascal
  exit OSErr
  #);
SysBeep: External (# duration: @ShortInt enter duration do '$A9C8'->PascalTrap #);
Date2Secs: External (# d: ^DateTimeRec; s: ^LongInt;  enter (d[],s[]) do CallPascal;  #);
DTInstall: External
  (# dtTaskPtr: @Integer; OSErr: @ShortInt;  enter dtTaskPtr do CallPascal;  exit OSErr #);
EqualString: External
  (# str1,str2: [1] @Char; caseSens,diacSens: @ShortInt; result: @Boolean; 
  enter (str1,str2,caseSens,diacSens)
  do CallPascal; 
  exit result
  #);
GetDateTime: External (# secs: ^LongInt;  enter secs[] do CallPascal;  #);
GetTime: External (# d: ^DateTimeRec;  enter d[] do CallPascal;  #);
HandToHand: External
  (# theHandle: ^LongInt; newHand: @Integer; 
  enter theHandle[]
  do CallPascal; 
  exit newHand
  #);
NGetTrapAddress: External
  (# trapNum,trapType: @ShortInt;  enter (trapNum,trapType) do CallPascal;  #);
PtrToHand: External
  (# srcPtr,size: @Integer; dstHndl: ^LongInt; OSErr: @ShortInt; 
  enter (srcPtr,dstHndl[],size)
  do CallPascal; 
  exit OSErr
  #);
RelString: External
  (# str1,str2: [1] @Char; caseSens,diacSens,result: @ShortInt; 
  enter (str1,str2,caseSens,diacSens)
  do CallPascal; 
  exit result
  #);
SecondsToDate: External (# s: @Integer; d: ^DateTimeRec;  enter (s,d[]) do CallPascal;  #);
SetDateTime: External
  (# time: @Integer; OSErr: @ShortInt;  enter time do CallPascal;  exit OSErr #);
SetUpA5: External (# do '{$2F0D,$2A78,$0904}'->PascalTrap;  #);
SwapMMUMode: External (# mode: ^CStruct enter mode[] do CallPascal;  #);
UprString: External
  (# theString: ^PascalString; diacSens: @Boolean; 
  enter (theString[],diacSens)
  do CallPascal; 
  #);
Delay: External
  (# numTicks: @Integer; finalTicks: ^LongInt; 
  enter (numTicks,finalTicks[])
  do CallPascal; 
  #);
Enqueue: External (# qElement,qHeader: @Integer;  enter (qElement,qHeader) do CallPascal;  #);
FlushDataCache: External (# do CallPascal;  #);
(* 
 GetMMUMode: External (# do CallPascal; #);
 *)
GetTrapAddress: External
  (# trapNum: @ShortInt; address: @Integer;  enter trapNum do CallPascal;  exit address #);
InitUtil: External (# err: @ShortInt;  do '{$A03F,$3E80}'->PascalTrap;  exit err #);
NSetTrapAddress: External
  (# trapAddr: @Integer; trapNum,tTyp: @ShortInt; 
  enter (trapAddr,trapNum,tTyp)
  do CallPascal; 
  #);
PtrToXHand: External
  (# srcPtr,dstHndl,size: @Integer; err: @ShortInt; 
  enter (srcPtr,dstHndl,size)
  do CallPascal; 
  exit err
  #);
RestartMac: External (# do 'Restart'->CallPascal;  #);
SetA5: External
  (# newA5,oldA5: @Integer;  enter newA5 do '{$2F4D,$0004,$2A5F}'->PascalTrap;  exit oldA5 #);
SetTime: External (# d: ^DateTimeRec;  enter d[] do CallPascal;  #);
SwapDataCache: External
  (# cacheEnable,result: @Boolean;  enter cacheEnable do CallPascal;  exit result #);
WriteParam: External (# err: @ShortInt;  do CallPascal;  exit err #);
Dequeue: External
  (# qElement,qHeader: @Integer; err: @ShortInt; 
  enter (qElement,qHeader)
  do CallPascal; 
  exit err
  #);
Environs: External (# rom,machine: ^CStruct;  enter (rom[],machine[]) do CallPascal;  #);
FlushInstructionCache: External (# do CallPascal;  #);
GetSysPPtr: External (# SysPPtr: @Integer;  do CallPascal;  exit SysPPtr #);
HandAndHand: External
  (# aHndl,bHndl: @Integer; err: @ShortInt;  enter (aHndl,bHndl) do CallPascal;  exit err #);
KeyTrans: External
  (# transData,result: @Integer; keycode: @ShortInt; state: ^LongInt; 
  enter (transData,keycode,state[])
  do '$A9C3'->PascalTrap; 
  exit result
  #);
PtrAndHand: External
  (# pntr,hndl,size: @Integer; err: @ShortInt; 
  enter (pntr,hndl,size)
  do CallPascal; 
  exit err
  #);
ReadDateTime: External
  (# time: ^LongInt; err: @ShortInt; 
  enter time[]
  do 'READDATETIME'->CallPascal; 
  exit err
  #);
RestoreA5: External (# do '$2A5F'->PascalTrap;  #);
SetCurrentA5: External (# old: @Integer;  do '{$2E8D,$2A78,$0904}'->PascalTrap;  exit old #);
SetTrapAddress: External
  (# trapAddr: @Integer; trapNum: @ShortInt;  enter (trapAddr,trapNum) do CallPascal;  #);
SwapInstructionCache: External
  (# cacheEnable,result: @Boolean;  enter cacheEnable do CallPascal;  exit result #);
  

PPCPortPtr: ToolboxRecord (# nameScript: Short (# Pos::< (# do 0->Value;  #);  #);  #);
PPCDataPtr: ToolboxRecord
  (# qLink: Long (# Pos::< (# do 0->Value;  #);  #);
     csCode: Short (# Pos::< (# do 4->Value;  #);  #);
     intUse: Short (# Pos::< (# do 6->Value;  #);  #);
     intUsePtr: Long (# Pos::< (# do 8->Value;  #);  #);
     ioCompletion: Long (# Pos::< (# do 12->Value;  #);  #);
     ioResult: Short (# Pos::< (# do 16->Value;  #);  #);
     reserved: (# (* Noget som fylder 20 byte *)  #);
     
  #);
IPCListPortsPBPtr: PPCDataPtr
  (# startIndex: Short (# Pos::< (# do 40->Value;  #);  #);
     requestCount: Short (# Pos::< (# do 42->Value;  #);  #);
     actualCount: Short (# Pos::< (# do 44->Value;  #);  #);
     portName: Long (# Pos::< (# do 46->Value;  #);  #);
     locationName: Long (# Pos::< (# do 50->Value;  #);  #);
     bufferPtr: Long (# Pos::< (# do 54->Value;  #);  #);
     
  #);
LocationNamePtr: ToolboxRecord
  (# locationKindSelector: Short (# Pos::< (# do 0->Value;  #);  #);  #);
PortInfoPtr: ToolboxRecord
  (# filler1: Byte (# Pos::< (# do 0->Value;  #);  #);
     authRequired: Byte (# Pos::< (# do 1->Value;  #);  #);
     name: @ (# nameScript: Short (# Pos::< (# do 2->Value;  #);  #);  #);
     
  #);
PPCAcceptPBPtr: PPCDataPtr
  (# sessRefNum: Long (# Pos::< (# do 40->Value;  #);  #);  #);
PPCClosePBPtr: PPCDataPtr (* OK *)
  (# portRefNum: Short (# Pos::< (# do 38->Value;  #);  #);  #);
PPCEndPBPtr: PPCDataPtr (* OK *)
  (# sessRefNum: Long (# Pos::< (# do 40->Value;  #);  #);  #);
PPCInformPBPtr: PPCDataPtr (* OK *)
  (# portRefNum: Short (# Pos::< (# do 38->Value;  #);  #);
     sessRefNum: Long (# Pos::< (# do 40->Value;  #);  #);
     serviceType: Byte (# Pos::< (# do 44->Value;  #);  #);
     autoAccept: Byte (# Pos::< (# do 45->Value;  #);  #);
     portName: Long (# Pos::< (# do 46->Value;  #);  #);
     locationName: Long (# Pos::< (# do 50->Value;  #);  #);
     userName: Long (# Pos::< (# do 54->Value;  #);  #);
     userData: Long (# Pos::< (# do 58->Value;  #);  #);
     requestType: Byte (# Pos::< (# do 62->Value;  #);  #);
     
  #);
PPCOpenPBPtr: PPCDataPtr (* OK *)
  (# portRefNum: Short (# Pos::< (# do 38->Value;  #);  #);
     filler1: (# (* Fylder 4 byte *)  #);
     serviceType: Byte (# Pos::< (# do 42->Value;  #);  #);
     resFlag: Byte (# Pos::< (# do 43->Value #) #);
     portName: Long (# Pos::< (# do 44->Value;  #);  #);
     locationName: Long (# Pos::< (# do 48->Value;  #);  #);
     networkVisible: Short (# Pos::< (# do 52->Value;  #);  #);
     nbpRegistered: Short (# Pos::< (# do 54->Value;  #);  #);
     
  #);
PPCReadPBPtr: PPCDataPtr (* OK *)
  (# sessRefNum: Long (# Pos::< (# do 40->Value;  #);  #);
     bufferLength: Long (# Pos::< (# do 44->Value;  #);  #);
     actualLength: Long (# Pos::< (# do 48->Value;  #);  #);
     bufferPtr: Long (# Pos::< (# do 52->Value;  #);  #);
     more: Byte (# Pos::< (# do 56->Value;  #);  #);
     filler2: Byte (# Pos::< (# do 57->Value;  #);  #);
     userData: Long (# Pos::< (# do 58->Value;  #);  #);
     blockCreator: Long (# Pos::< (# do 62->Value;  #);  #);
     blockType: Long (# Pos::< (# do 66->Value;  #);  #);
     
  #);
PPCRejectPBPtr: PPCDataPtr
  (# sessRefNum: Long (# Pos::< (# do 40->Value;  #);  #);
     filler2: Short (# Pos::< (# do 44->Value;  #);  #);
     filler3: Long (# Pos::< (# do 46->Value;  #);  #);
     filler4: Long (# Pos::< (# do 50->Value;  #);  #);
     rejectInfo: Long (# Pos::< (# do 54->Value;  #);  #);
     
  #);
PPCStartPBPtr: PPCDataPtr
  (# portRefNum: Short (# Pos::< (# do 38->Value;  #);  #);
     sessRefNum: Long (# Pos::< (# do 40->Value;  #);  #);
     serviceType: Byte (# Pos::< (# do 44->Value;  #);  #);
     resFlag: Byte (# Pos::< (# do 45->Value;  #);  #);
     portName: Long (# Pos::< (# do 46->Value;  #);  #);
     locationName: Long (# Pos::< (# do 50->Value;  #);  #);
     rejectInfo: Long (# Pos::< (# do 54->Value;  #);  #);
     userData: Long (# Pos::< (# do 58->Value;  #);  #);
     userRefNum: Long (# Pos::< (# do 62->Value;  #);  #);
     
  #);
PPCWritePBPtr: PPCDataPtr
  (# filler1: Short (# Pos::< (# do 38->Value;  #);  #);
     sessRefNum: Long (# Pos::< (# do 40->Value;  #);  #);
     bufferLength: Long (# Pos::< (# do 44->Value;  #);  #);
     actualLength: Long (# Pos::< (# do 48->Value;  #);  #);
     bufferPtr: Long (# Pos::< (# do 52->Value;  #);  #);
     more: Byte (# Pos::< (# do 56->Value;  #);  #);
     filler2: Byte (# Pos::< (# do 57->Value;  #);  #);
     userData: Long (# Pos::< (# do 58->Value;  #);  #);
     blockCreator: Long (# Pos::< (# do 62->Value;  #);  #);
     blockType: Long (# Pos::< (# do 66->Value;  #);  #);
     
  #);
PortInfoRec: CStruct (# byteSize::< (# do 74->Value #);  #);
TargetID: CStruct (# byteSize::< (# do 252->Value #);  #);
DeleteUserIdentity: External
  (# userRef: @ShortInt; OSErr: @ShortInt;  enter userRef do CallPascal;  exit OSErr #);
GetDefaultUser: External
  (# userRef: ^CStruct; userName: ^PascalString; OSErr: @ShortInt; 
  enter (userRef[],userName[])
  do CallPascal; 
  exit OSErr
  #);
IPCListPorts: External
  (# PB: @Integer; async: @Boolean; OSErr: @ShortInt; 
  enter (PB,async)
  do CallPascal; 
  exit OSErr
  #);
PPCBrowser: External
  (# prompt,applListLabel: [1] @Char;
     defaultSpecified: @Boolean;
     theLocNameP: @Integer;
     (* Pointer to some weird record. *)
     thePortInfo: @Integer;
     portFilter: @Integer;
     (* ## External *)
     OSErr: @ShortInt;
     
  enter (prompt,applListLabel,defaultSpecified,theLocNameP,thePortInfo,portFilter)
  do '{$303C,$0B00,$A82B}'->PascalTrap; 
  exit OSErr
  #);
PPCClose: External
  (# PB: @Integer; async: @Boolean; OSErr: @ShortInt
  enter (PB,async)
  do CallPascal; 
  exit OSErr
  #);
PPCEnd: External
  (# PB: @Integer; async: @Boolean; OSErr: @ShortInt; 
  enter (PB,async)
  do CallPascal; 
  exit OSErr
  #);
PPCInform: External
  (# PB: @Integer; async: @Boolean; OSErr: @ShortInt; 
  enter (PB,async)
  do CallPascal; 
  exit OSErr
  #);
PPCInit: External (# OSErr: @ShortInt do CallPascal;  exit OSErr #);
PPCOpen: External
  (# PB: @Integer; async: @Boolean; OSErr: @ShortInt; 
  enter (PB,async)
  do CallPascal; 
  exit OSerr
  #);
PPCRead: External
  (# PB: @Integer; async: @Boolean; OSErr: @ShortInt; 
  enter (PB,async)
  do CallPascal; 
  exit OSerr
  #);
PPCReject: External
  (# PB: @Integer; async: @Boolean; OSErr: @ShortInt; 
  enter (PB,async)
  do CallPascal; 
  exit OSerr
  #);
PPCStart: External
  (# PB: @Integer; async: @Boolean; OSErr: @ShortInt; 
  enter (PB,async)
  do CallPascal; 
  exit OSerr
  #);
PPCWrite: External
  (# PB: @Integer; async: @Boolean; OSErr: @ShortInt; 
  enter (PB,async)
  do CallPascal; 
  exit OSerr
  #);
PromptForUserIdentity: External
  (# userRef (* Unsigned Short *) ,guestSelected (* ShortRef *) : ^CStruct;
     userName,prompt: @Integer;
     allowGuest: @Boolean;
     OSerr: @ShortInt;
     
  enter (userRef[],userName,guestSelected[],allowGuest,prompt)
  do CallPascal; 
  exit OSerr
  #);
StartSecureSession: External
  (# startPB,userName,prompt: @Integer;
     UseDefault,allowGuest: @Boolean;
     guestSelected: ^CStruct;
     OSErr: @ShortInt;
     
  enter (startPB,userName,UseDefault,allowGuest,guestSelected[],prompt)
  do CallPascal; 
  exit OSErr
  #);
  

TPPrPort: GrafPortPtr
  (# (* QDProcs struc *)
     textProc: Long (# Pos::< (# do 108->Value;  #);  #);
     lineProc: Long (# Pos::< (# do 112->Value;  #);  #);
     rectProc: Long (# Pos::< (# do 116->Value;  #);  #);
     rRectProc: Long (# Pos::< (# do 120->Value;  #);  #);
     ovalProc: Long (# Pos::< (# do 124->Value;  #);  #);
     arcProc: Long (# Pos::< (# do 128->Value;  #);  #);
     polyProc: Long (# Pos::< (# do 132->Value;  #);  #);
     rgnProc: Long (# Pos::< (# do 136->Value;  #);  #);
     bitsProc: Long (# Pos::< (# do 140->Value;  #);  #);
     commentProc: Long (# Pos::< (# do 144->Value;  #);  #);
     txMeasProc: Long (# Pos::< (# do 148->Value;  #);  #);
     getPicProc: Long (# Pos::< (# do 152->Value;  #);  #);
     putPicProc: Long (# Pos::< (# do 156->Value;  #);  #);
     (* Private *)
     lGParam1: Long (# Pos::< (# do 160->Value;  #);  #);
     lGParam2: Long (# Pos::< (# do 164->Value;  #);  #);
     lGParam3: Long (# Pos::< (# do 168->Value;  #);  #);
     lGParam4: Long (# Pos::< (# do 172->Value;  #);  #);
     fOurPtr: Byte (# Pos::< (# do 176->Value;  #);  #);
     fOurBits: Byte (# Pos::< (# do 177->Value;  #);  #);
     
  #);
PrOpen: External (# do CallPascal;  #);
PrClose: External (# do CallPascal;  #);
PrError: External (# err: @ShortInt;  do CallPascal;  exit err #);
PrintDefault: External (# hPrint: @Integer;  enter hPrint do CallPascal;  #);
PrValidate: External
  (# hPrint: @Integer; isValid: @Boolean;  enter hPrint do CallPascal;  exit isValid #);
PrStlDialog: External
  (# hPrint: @Integer; Confirmed: @Boolean;  enter hPrint do CallPascal;  exit Confirmed #);
PrJobDialog: External
  (# hPrint: @Integer; Confirmed: @Boolean;  enter hPrint do CallPascal;  exit Confirmed #);
PrOpenDoc: External
  (# hPrint: @Integer; pPrPort: @Integer; pIOBuf: @Integer; TPPrPort: @Integer; 
  enter (hPrint,pPrPort,pIOBuf)
  do CallPascal; 
  exit TPPrPort
  #);
PrCloseDoc: External (# TPPrPort: @Integer;  enter TPPrPort do CallPascal;  #);
PrOpenPage: External
  (# pPrPort: @Integer; pPageFrame: ^QRect; 
  enter (pPrPort,pPageFrame[])
  do CallPascal; 
  #);
PrClosePage: External (# pPrPort: @Integer;  enter pPrPort do CallPascal;  #);
  

kNoProcess: (# exit 0 #);
kSystemProcess: (# exit 1 #);
kCurrentProcess: (# exit 2 #);
ProcessSerialNumber: CStruct
  (# ByteSize::< (# do 8->Value;  #);
     highLongOfPSN: Long (# Pos::< (# do 0->Value;  #);  #);
     lowLongOfPSN: Long (# Pos::< (# do 4->Value;  #);  #);
     
  #);
ProcessInfoRec: CStruct
  (# ByteSize::< (# do 60->Value;  #);
     processInfoLength: Long (# Pos::< (# do 0->Value;  #);  #);
     processName: Long (# Pos::< (# do 4->Value;  #);  #);
     processNumberHi: Long (# Pos::< (# do 8->Value;  #);  #);
     processNumberLo: Long (# Pos::< (# do 12->Value;  #);  #);
     processType: Long (# Pos::< (# do 16->Value;  #);  #);
     processSignature: Long (# Pos::< (# do 20->Value;  #);  #);
     processMode: Long (# Pos::< (# do 24->Value;  #);  #);
     processLocation: Long (# Pos::< (# do 28->Value;  #);  #);
     processSize: Long (# Pos::< (# do 32->Value;  #);  #);
     processFreeMem: Long (# Pos::< (# do 36->Value;  #);  #);
     processLauncherHi: Long (# Pos::< (# do 40->Value;  #);  #);
     processLauncherLo: Long (# Pos::< (# do 44->Value;  #);  #);
     processLaunchDate: Long (# Pos::< (# do 48->Value;  #);  #);
     processActiveTime: Long (# Pos::< (# do 52->Value;  #);  #);
     processAppSpec: Long (# Pos::< (# do 56->Value;  #);  #);
     
  #);
GetCurrentProcess: External
  (# PSN: ^ProcessSerialNumber; OSErr: @ShortInt
  enter PSN[]
  do '{0$3F3C,0$0037,0$A88F}'->PascalTrap; 
  exit OSErr
  #);
GetNextProcess: External
  (# PSN: ^ProcessSerialNumber; OSErr: @ShortInt
  enter PSN[]
  do '{0$3F3C,0$0038,0$A88F}'->PascalTrap; 
  exit OSErr
  #);
GetProcessInformation: External
  (# PSN: ^ProcessSerialNumber; info: ^ProcessInfoRec; OSErr: @ShortInt
  enter (PSN[],info[])
  do '{0$3F3C,0$003A,0$A88F}'->PascalTrap; 
  exit OSErr
  #);
SameProcess: External
  (# PSN1,PSN2: ^ProcessSerialNumber; result: ^ShortRef; OSErr: @ShortInt
  enter (PSN1[],PSN2[],result[])
  do '{0$3F3C,0$003D,0$A88F}'->PascalTrap; 
  exit OSErr
  #);
GetFrontProcess: External
  (# PSN: ^ProcessSerialNumber; OSErr: @ShortInt
  enter PSN[]
  do '{0$70FF,0$2F00,0$3F3C,0$0039,0$A88F}'->PascalTrap; 
  exit OSErr
  #);
SetFrontProcess: External
  (# PSN: ^ProcessSerialNumber; OSErr: @ShortInt
  enter PSN[]
  do '{0$3F3C,0$003B,0$A88F}'->PascalTrap; 
  exit OSErr
  #);
WakeUpProcess: External
  (# PSN: ^ProcessSerialNumber; OSErr: @ShortInt
  enter PSN[]
  do '{0$3F3C,0$003C,0$A88F}'->PascalTrap; 
  exit OSErr
  #);
  

pixPurge: (# exit 1 #);
noNewDevice: (# exit 2 #);
useMFTemp: (# exit 4 #);
keepLocal: (# exit 8 #);
GWorldFlags4: (# exit 16 #);
GWorldFlags5: (# exit 32 #);
pixelsPurgeable: (# exit 64 #);
pixelsLocked: (# exit 128 #);
GWorldFlags8: (# exit 256 #);
GWorldFlags9: (# exit 512 #);
GWorldFlags10: (# exit 1024 #);
GWorldFlags11: (# exit 2048 #);
GWorldFlags12: (# exit 4096 #);
GWorldFlags13: (# exit 8192 #);
GWorldFlags14: (# exit 16384 #);
GWorldFlags15: (# exit 32768 #);
mapPix: (# exit 65536 #);
newDepth: (# exit 131072 #);
alignPix: (# exit 262144 #);
newRowBytes: (# exit 524288 #);
reallocPix: (# exit 1048576 #);
GWorldFlags21: (# exit 2097152 #);
GWorldFlags22: (# exit 4194304 #);
GWorldFlags23: (# exit 8388608 #);
GWorldFlags24: (# exit 16777216 #);
GWorldFlags25: (# exit 33554432 #);
GWorldFlags26: (# exit 67108864 #);
GWorldFlags27: (# exit 134217782 #);
clipPix: (# exit 268435456 #);
stretchPix: (# exit 536870912 #);
ditherPix: (# exit 1073741824 #);
(* gwFlagErr: (# exit 2147483648 #); *)
GWorldFlags:
  (# value: @Integer; set: (# n: @Integer;  enter n do n+value->value;  #); 
  exit value
  #);
(* 
 GWorldPtr: IntegerObject(# #); {CGrafPtr} 
 *)
cDepthErr: (# exit - 157 #);
(* invalid pixel depth *)
AllowPurgePixels: External
  (# pm: @Integer;  enter pm do '{$203C,$0004,$000B,$AB1D}'->PascalTrap;  #);
CTabChanged: External
  (# ctab: @Integer;  enter ctab do '{$203C,$0004,$0007,$AB1D}'->PascalTrap;  #);
DisposeGWorld: External
  (# offscreenGWorld: @Integer; 
  enter offscreenGWorld
  do '{$203C,$0004,$0004,$AB1D}'->PascalTrap; 
  #);
DisposeScreenBuffer: External
  (# offscreenPixMap: @Integer; 
  enter offscreenPixMap
  do '{$203C,$0004,$0011,$AB1D}'->PascalTrap; 
  #);
GDeviceChanged: External
  (# gdh: @Integer;  enter gdh do '{$203C,$0004,$000A,$AB1D}'->PascalTrap;  #);
GetGWorld: External
  (# thePort,gdh: ^LongInt; 
  enter (thePort[],gdh[])
  do '{$203C,$0008,$0005,$AB1D}'->PascalTrap; 
  #);
GetGWorldDevice: External
  (# offscreenGWorld,gdhandel: @Integer; 
  enter offscreenGWorld
  do '{$203C,$0004,$0012,$AB1D}'->PascalTrap; 
  exit gdhandel
  #);
GetGWorldPixMap: External
  (# offscreenGWorld,pmhandel: @Integer; 
  enter offscreenGWorld
  do '{$203C,$0004,$0017,$AB1D}'->PascalTrap; 
  exit pmhandel
  #);
GetPixBaseAddr: External
  (# pm,pixBaseAddr: @Integer; 
  enter pm
  do '{$203C,$0004,$000F,$AB1D}'->PascalTrap; 
  exit pixBaseAddr
  #);
GetPixelsState: External
  (# pm,gwf: @Integer;  enter pm do '{$203C,$0004,$000D,$AB1D}'->PascalTrap;  exit gwf #);
LockPixels: External
  (# pm: @Integer; isLocked: @Boolean; 
  enter pm
  do '{$203C,$0004,$0001,$AB1D}'->PascalTrap; 
  exit isLocked
  #);
NewGWorld: External
  (# offscreenGWorld: ^LongInt;
     PixelDepth: @ShortInt;
     boundsRect: ^QRect;
     cTable,aGDevice,flags: @Integer;
     result: @ShortInt;
     
  enter (offscreenGWorld[],PixelDepth,boundsRect[],cTable,aGDevice,flags)
  do '{$203C,$0016,$0000,$AB1D}'->PascalTrap; 
  exit result
  #);
NewScreenBuffer: External
  (# globalRect: ^QRect;
     (* VAR Rect *)
     purgeable: @Boolean;
     gdh,offscreenPixMap: ^LongInt;
     result: @ShortInt;
     (* QDErr *)
     
  enter (globalRect[],purgeable,gdh[],offscreenPixMap[])
  do '{$203C,$000E,$0010,$AB1D}'->PascalTrap; 
  exit result
  #);
NewTempScreenBuffer: External
  (# globalRect: ^QRect;
     purgeable: @Boolean;
     gdh,offscreenPixMap: ^LongInt;
     result: @ShortInt;
     
  enter (globalREct[],purgeable,gdh[],offscreenPixMap[])
  do '{$203C,$000E,$0015,$AB1D}'->PascalTrap; 
  exit result
  #);
NoPurgePixels: External
  (# pm: @Integer; (* PixMapHandle *) 
  enter pm
  do '{$203C,$0004,$000C,$AB1D}'->PascalTrap; 
  #);
OffscreenVersion: External
  (# result: @Integer; (* OUTPUT LongInt *) 
  do '{$203C,$0000,$0014,$AB1D}'->PascalTrap; 
  exit result
  #);
Pixmap32Bit: External
  (# offscreenPixMap: @Integer; (* PixMapHandle *) result: @Boolean; 
  enter offscreenPixMap
  do '{$203C,$0004,$0016,$AB1D}'->PascalTrap; 
  exit result
  #);
PixPatChanged: External
  (# ppat: @Integer; (* PixPatHandle  *) 
  enter ppat
  do '{$203C,$0004,$0008,$AB1D}'->PascalTrap; 
  #);
PortChanged: External
  (# thePort: @Integer;  enter thePort do '{$203C,$0004,$0009,$AB1D}'->PascalTrap;  #);
QDDone: External
  (# thePort: @Integer; result: @Boolean; 
  enter thePort
  do '{$203C,$0004,$0013,$AB1D}'->PascalTrap; 
  exit result
  #);
SetGWorld: External
  (# thePort,gdh: @Integer; 
  enter (thePort,gdh)
  do '{$203C,$0008,$0006,$AB1D}'->PascalTrap; 
  #);
SetPixelsState: External
  (# pm,state: @Integer;  enter (pm,state) do '{$203C,$0008,$000E,$AB1D}'->PascalTrap;  #);
UnlockPixels: External
  (# pm: @Integer; (* PixMapHandle *) 
  enter pm
  do '{$203C,$0004,$0002,$AB1D}'->PascalTrap; 
  #);
UpdateGWorld: External
  (# offscreenGWorld: ^LongInt;
     pixelDepth: @ShortInt;
     boundsRect: ^QRect;
     cTable,aGDevice,flags,resflags: @Integer;
     
  enter (offscreenGWorld[],pixelDepth,boundsRect[],cTable,aGDevice,flags)
  do '{$203C,$0016,$0003,$AB1D}'->PascalTrap; 
  exit resflags
  #);
getDev: External (# theDev: @Integer;  do '$AA32'->PascalTrap exit theDev #);
  
blackColor: (# exit 33 #);
whiteColor: (# exit 30 #);
redColor: (# exit 205 #);
greenColor: (# exit 341 #);
blueColor: (# exit 409 #);
cyanColor: (# exit 273 #);
magentaColor: (# exit 137 #);
yellowColor: (# exit 69 #);


RegionRecord: ToolboxRecord
  (# rgnSize: Short (# Pos::< (# do 0->Value;  #);  #);
     rgnBBox: Rect (# Pos::< (# do 2->Value;  #);  #);
  #);
macBitMap: CStruct
  (# ByteSize::< (# do 14->Value;  #);
     baseAddr: Long (# Pos::< (# do 0->Value;  #);  #);
     rowBytes: Short (# Pos::< (# do 4->Value;  #);  #);
     topLeft: Long (# Pos::< (# do 6->Value;  #);  #);
     botRight: Long (# Pos::< (# do 10->Value;  #);  #);
     bounds: (# enter (topLeft,botRight) exit (topLeft,botRight) #);
     
  #);


asGrafPort: 
	(# ptr: @int32u;
	   port: ^GrafPort;
	enter ptr
	do (ptr) %putLongAt (@@port);
	exit port[]
	#);

GrafPort: Data
	(# device: @int16;
	   portPixMap_hi: @int16u;
	   portPixMap_lo: @int16u;
	   portVersion: @int16;
	   grafVars: @int32u;
	   chExtra: @int16;
	   pnLocHFrac: @int16;
	   portRect_top: @int16;
	   portRect_left: @int16;
	   portRect_bottom: @int16;
	   portRect_right: @int16;
	   visRgn: @int32u;
	   clipRgn: @int32u;
	   bkPixPat: @int32u;
	   rgbFgColor_red: @int16u;
	   rgbFgColor_green: @int16u;
	   rgbFgColor_blue: @int16u;
	   rgbBkColor_red: @int16u;
	   rgbBkColor_green: @int16u;
	   rgbBkColor_blue: @int16u;
	   pnLoc_v: @int16;
	   pnLoc_h: @int16;
	   pnSize_v: @int16;
	   pnSize_h: @int16;
	   pnMode: @int16;
	   pnPixPat_hi: @int16u;
	   pnPixPat_lo: @int16u;
	   fillPixPat_hi: @int16u;
	   fillPixPat_lo: @int16u;
	   pnVis: @int16;
	   txFont: @int16;
	   txFace: @int16;
	   txMode: @int16;
	   txSize: @int16;
	   spExtra: @int32;
	   fgColor: @int32;
	   bgColor: @int32;
	   colrBit: @int16;
	   patStretch: @int16;
	   picSave: @int32u;
	   rgnSave: @int32u;
	   polySave: @int32u;
	   grafProcs: @int32u;
	#);
	
grafPortPtr: ToolboxRecord
  (# device: Short (# Pos::< (# do 0->Value;  #);  #);
     baseAddr: Long (# Pos::< (# do 2->Value;  #);  #);
     rowBytes: Short (# Pos::< (# do 6->Value;  #);  #);
     bounds: Rect (# Pos::< (# do 8->Value;  #);  #);
     portBitsAddr: Long (# Pos::< (# do 2->Value;  #);  #);
     portBitsBoundsTL: (# exit (8->getShort,10->getShort) #);
     PortRect: Rect (# Pos::< (# do 16->Value;  #);  #);
     PortRectTL: (# exit (# exit (16->getShort,18->getShort) #) #);
     visRgn: Long (# Pos::< (# do 24->Value;  #);  #);
     clipRgn: Long (# Pos::< (# do 28->Value;  #);  #);
     bkPatAdr: Long (# Pos::< (# do 32->Value;  #);  #);
     fillPatAdr: Long (# Pos::< (# do 40->Value;  #);  #);
     pnLoc: Long (# Pos::< (# do 48->Value;  #);  #);
     pnSize: Long (# Pos::< (# do 52->Value;  #);  #);
     pnMode: Short (# Pos::< (# do 56->Value;  #);  #);
     pnPatAdr: Long (# Pos::< (# do 58->Value;  #);  #);
     pnVis: Short (# Pos::< (# do 66->Value;  #);  #);
     txFont: Short (# Pos::< (# do 68->Value;  #);  #);
     txFace: Short (# Pos::< (# do 70->Value;  #);  #);
     txMode: Short (# Pos::< (# do 72->Value;  #);  #);
     txSize: Short (# Pos::< (# do 74->Value;  #);  #);
     spExtra: Long (# Pos::< (# do 76->Value;  #);  #);
     fgColor: Long (# Pos::< (# do 80->Value;  #);  #);
     bkColor: Long (# Pos::< (# do 84->Value;  #);  #);
     colrBit: Short (# Pos::< (# do 88->Value;  #);  #);
     patStretch: Short (# Pos::< (# do 90->Value;  #);  #);
     picSave: Long (# Pos::< (# do 92->Value;  #);  #);
     rgnSave: Long (# Pos::< (# do 96->Value;  #);  #);
     polySave: Long (# Pos::< (# do 100->Value;  #);  #);
     
  #);

grafPortRecord: grafPortPtr
	(# portRectangle: @
			(#
				top: @integerValue
					(#
					do (%getSignedShortAt(ptr+16)) -> value;
					(* Above line tos_converted from: do ptr + 16 -> TOS'%adrGetSignedShort' -> value; *)
					#);
				left: @integerValue
					(#
					do (%getSignedShortAt(ptr+18)) -> value;
					(* Above line tos_converted from: do ptr + 18 -> TOS'%adrGetSignedShort' -> value; *)
					#);
				bottom: @integerValue
					(#
					do (%getSignedShortAt(ptr+20)) -> value;
					(* Above line tos_converted from: do ptr + 20 -> TOS'%adrGetSignedShort' -> value; *)
					#);
				right: @integerValue
					(#
					do (%getSignedShortAt(ptr+22)) -> value;
					(* Above line tos_converted from: do ptr + 22 -> TOS'%adrGetSignedShort' -> value; *)
					#);
			exit ((left,top),(right,bottom))
			#);
	#);
 srcCopy: (# exit 0 #);
 srcOr: (# exit 1 #);
 srcXor: (# exit 2 #);
 srcBic: (# exit 3 #);
 notSrcCopy: (# exit 4 #);
 notSrcOr: (# exit 5 #);
 notSrcXor: (# exit 6 #);
 notSrcBic: (# exit 7 #);
 patCopy: (# exit 8 #);
 patOr: (# exit 9 #);
 patXor: (# exit 10 #);
 patBic: (# exit 11 #);
 notPatCopy: (# exit 12 #);
 notPatOr: (# exit 13 #);
 notPatXor: (# exit 14 #);
 notPatBic: (# exit 15 #);
 
 




PicturePtr: ToolboxRecord
  (# picSize: Short (# Pos::< (# do 0->Value;  #);  #);
     picBounds: Rect (# Pos::< (# do 2->Value;  #);  #);
     
  #);
polygonPtr: ToolboxRecord
  (# polySize: Short (# Pos::< (# do 0->Value;  #);  #);
  	  polyBBox: Rect (# Pos::< (# do 2->Value;  #);  #);
	  
  	  top: Short (# pos:: (# do 2 -> value #) #);
  	  left: Short (# pos:: (# do 4 -> value #) #);
  	  bottom: Short (# pos:: (# do 6 -> value #) #);
  	  right: Short (# pos:: (# do 8 -> value #) #);
     
     bounds: (# exit ((left, top), (right, bottom)) #);
  #);
penState: CStruct
  (# ByteSize::< (# do 18->Value;  #);
     pnLoc: Long (# Pos::< (# do 0->Value;  #);  #);
     pnSize: Long (# Pos::< (# do 4->Value;  #);  #);
     pnMode: Short (# Pos::< (# do 8->Value;  #);  #);
     
  #);
FontInfo: CStruct
  (# ByteSize::< (# do 8->Value;  #);
     ascent: Short (# Pos::< (# do 0->Value;  #);  #);
     descent: Short (# Pos::< (# do 2->Value;  #);  #);
     widMax: Short (# Pos::< (# do 4->Value;  #);  #);
     leading: Short (# Pos::< (# do 6->Value;  #);  #);
     
  #);
RGBColor: CStruct
  (# ByteSize::< (# do 6->Value;  #);
     red: Short (# Pos::< (# do 0->Value;  #);  #);
     green: Short (# Pos::< (# do 2->Value;  #);  #);
     blue: Short (# Pos::< (# do 4->Value;  #);  #);
     
  #);
GDevicePtr: ToolboxRecord
  (# gdRefNum: Short (# Pos::< (# do 0->Value;  #);  #);
     (* driver's unit number *)
     gdID: Short (# Pos::< (# do 2->Value;  #);  #);
     (* client ID for search procs *)
     gdType: Short (# Pos::< (# do 4->Value;  #);  #);
     (* fixed/CLUT/diRect *)
     gdITable: Long (# Pos::< (# do 6->Value;  #);  #);
     (* Handle to inverse lookup table *)
     gdResPref: Short (# Pos::< (# do 10->Value;  #);  #);
     (* preferred resolution of GDITable *)
     gdSearchProc: Long (# Pos::< (# do 12->Value;  #);  #);
     (* search proc list head *)
     gdCompProc: Long (# Pos::< (# do 16->Value;  #);  #);
     (* complement proc list *)
     gdFlags: Short (# Pos::< (# do 20->Value;  #);  #);
     (* grafDevice flags word *)
     gdPMap: Long (# Pos::< (# do 22->Value;  #);  #);
     (* describing pixMap *)
     gdRefCon: Long (# Pos::< (# do 26->Value;  #);  #);
     (* reference Value *)
     gdNextGD: Long (# Pos::< (# do 30->Value;  #);  #);
     (* GDHandle Handle of next gDevice *)
     gdRect: Rect (# Pos::< (# do 34->Value;  #);  #);
     (* device's bounds in global coordinates *)
     gdMode: Long (# Pos::< (# do 42->Value;  #);  #);
     (* device's current mode *)
     gdCCBytes: Short (# Pos::< (# do 46->Value;  #);  #);
     (* depth of expanded cursor data *)
     gdCCDepth: Short (# Pos::< (# do 48->Value;  #);  #);
     (* depth of expanded cursor data *)
     gdCCXData: Long (# Pos::< (# do 50->Value;  #);  #);
     (* Handle to cursor's expanded data *)
     gdCCXMask: Long (# Pos::< (# do 54->Value;  #);  #);
     (* Handle to cursor's expanded mask *)
     gdReserved: Long (# Pos::< (# do 58->Value;  #);  #);
     (* future use. MUST BE 0 *)
     
  #);
ColorSpec: CStruct
  (# ByteSize::< (# do 8->Value;  #);
     Value: Short (# Pos::< (# do 0->Value;  #);  #);
     rgb: CStruct
       (# ByteSize::< (# do 6->Value;  #);
          red: Short (# Pos::< (# do 2->Value;  #);  #);
          green: Short (# Pos::< (# do 4->Value;  #);  #);
          blue: Short (# Pos::< (# do 6->Value;  #);  #);
          
       enter (red,green,blue)
       exit (red,green,blue)
       #);
     
  #);
ColorTable: CStruct
  (# ByteSize::< (# do 8->Value;  #);
     ctSeed: Long (# Pos::< (# do 0->Value;  #);  #);
     ctFlags: Short (# Pos::< (# do 4->Value;  #);  #);
     ctSize: Short (# Pos::< (# do 6->Value;  #);  #);
     (*  ctTabel: cSpecArray *)
     
  #);
CGrafPortPtr: ToolboxRecord
  (# device: Short (# Pos::< (# do 0->Value;  #);  #);
     portPixMapAdr: Long (# Pos::< (# do 2->Value;  #);  #);
     portVersion: Short (# Pos::< (# do 6->Value;  #);  #);
     grafVarsAdr: Long (# Pos::< (# do 8->Value;  #);  #);
     chExtra: Short (# Pos::< (# do 12->Value;  #);  #);
     pnLocHFrac: Short (# Pos::< (# do 14->Value;  #);  #);
     PortRect: Rect (# Pos::< (# do 16->Value;  #);  #);
     visRgn: Long (# Pos::< (# do 24->Value;  #);  #);
     clipRgn: Long (# Pos::< (# do 28->Value;  #);  #);
     bkPixPatAdr: Long (# Pos::< (# do 32->Value;  #);  #);
     rgbFgColor:
       (# red: Short (# Pos::< (# do 36->Value;  #);  #);
          green: Short (# Pos::< (# do 38->Value;  #);  #);
          blue: Short (# Pos::< (# do 40->Value;  #);  #);
          
       enter (red,green,blue)
       exit (red,green,blue)
       #);
     rgbBgColor:
       (# red: Short (# Pos::< (# do 42->Value;  #);  #);
          green: Short (# Pos::< (# do 44->Value;  #);  #);
          blue: Short (# Pos::< (# do 46->Value;  #);  #);
          
       enter (red,green,blue)
       exit (red,green,blue)
       #);
     pnLoc: Long (# Pos::< (# do 48->Value;  #);  #);
     pnSize: Long (# Pos::< (# do 52->Value;  #);  #);
     pnMode: Short (# Pos::< (# do 56->Value;  #);  #);
     pnPixPatAdr: Long (# Pos::< (# do 58->Value;  #);  #);
     filPixPatAdr: Long (# Pos::< (# do 62->Value;  #);  #);
     pnVis: Short (# Pos::< (# do 66->Value;  #);  #);
     txFont: Short (# Pos::< (# do 68->Value;  #);  #);
     txFace: Short (# Pos::< (# do 70->Value;  #);  #);
     txMode: Short (# Pos::< (# do 72->Value;  #);  #);
     txSize: Short (# Pos::< (# do 74->Value;  #);  #);
     spExtra: Long (# Pos::< (# do 76->Value;  #);  #);
     fgColor: Long (# Pos::< (# do 80->Value;  #);  #);
     bkColor: Long (# Pos::< (# do 84->Value;  #);  #);
     colrBit: Short (# Pos::< (# do 88->Value;  #);  #);
     patStretch: Short (# Pos::< (# do 90->Value;  #);  #);
     picSave: Long (# Pos::< (# do 92->Value;  #);  #);
     rgnSave: Long (# Pos::< (# do 96->Value;  #);  #);
     polySave: Long (# Pos::< (# do 100->Value;  #);  #);
     
  #);
GrafVars: CStruct
  (# ByteSize::< (# do 26->Value;  #);
     rgbOpColor:
       (# red: Short (# Pos::< (# do 0->Value;  #);  #);
          green: Short (# Pos::< (# do 2->Value;  #);  #);
          blue: Short (# Pos::< (# do 4->Value;  #);  #);
          
       enter (red,green,blue)
       exit (red,green,blue)
       #);
     rgbHiliteColor:
       (# red: Short (# Pos::< (# do 6->Value;  #);  #);
          green: Short (# Pos::< (# do 8->Value;  #);  #);
          blue: Short (# Pos::< (# do 10->Value;  #);  #);
          
       enter (red,green,blue)
       exit (red,green,blue)
       #);
     pmFgColor: Long (# Pos::< (# do 12->Value;  #);  #);
     pmFgIndex: Short (# Pos::< (# do 16->Value;  #);  #);
     pmBkColor: Long (# Pos::< (# do 18->Value;  #);  #);
     pmBkIndex: Short (# Pos::< (# do 22->Value;  #);  #);
     pmFlags: Short (# Pos::< (# do 24->Value;  #);  #);
     
  #);
PixMapPtr: ToolboxRecord
  (# baseAddr: Long (# Pos::< (# do 0->Value;  #);  #);
     rowBytes: Short (# Pos::< (# do 4->Value;  #);  #);
     bounds: Rect (# Pos::< (# do 6->Value;  #);  #);
     pmVersion: Short (# Pos::< (# do 14->Value;  #);  #);
     packType: Short (# Pos::< (# do 16->Value;  #);  #);
     packSize: Long (# Pos::< (# do 18->Value;  #);  #);
     hRes: Long (# Pos::< (# do 22->Value;  #);  #);
     vRes: Long (# Pos::< (# do 26->Value;  #);  #);
     pixelType: Short (# Pos::< (# do 30->Value;  #);  #);
     pixelSize: Short (# Pos::< (# do 32->Value;  #);  #);
     cmpCount: Short (# Pos::< (# do 34->Value;  #);  #);
     cmpSize: Short (# Pos::< (# do 36->Value;  #);  #);
     planeBytes: Long (# Pos::< (# do 38->Value;  #);  #);
     pmTable: Long (# Pos::< (# do 42->Value;  #);  #);
     pmReserved: Long (# Pos::< (# do 46->Value;  #);  #);
     
  #);
PixPatPtr: ToolboxRecord
  (# patType: Short (# Pos::< (# do 0->Value;  #);  #);
     patMap: Long (# Pos::< (# do 2->Value;  #);  #);
     patData: Long (# Pos::< (# do 6->Value;  #);  #);
     patXData: Long (# Pos::< (# do 10->Value;  #);  #);
     patXValid: Short (# Pos::< (# do 14->Value;  #);  #);
     patXMap: Long (# Pos::< (# do 18->Value;  #);  #);
     pat1Data: DoubleLong (# Pos::< (# do 22->Value;  #);  #);
     
  #);
CCrsr: ToolboxRecord
  (# crsrType: Short (# Pos::< (# do 0->Value;  #);  #);
     crsrMap: Long (# Pos::< (# do 2->Value;  #);  #);
     crsrData: Long (# Pos::< (# do 6->Value;  #);  #);
     crsrXData: Long (# Pos::< (# do 10->Value;  #);  #);
     crsrXValid: Short (# Pos::< (# do 14->Value;  #);  #);
     crsrXHandle: Long (# Pos::< (# do 16->Value;  #);  #);
     crsr1Data: Short (# Pos::< (# do 20->Value;  #);  #);
     crsrMask: Short (# Pos::< (# do 22->Value;  #);  #);
     crsrHotSpot: Long (# Pos::< (# do 24->Value;  #);  #);
     crsrXTable: Long (# Pos::< (# do 28->Value;  #);  #);
     crsrID: Long (# Pos::< (# do 32->Value;  #);  #);
     
  #);
CIcon: ToolboxRecord
  (# iconPMap:
       (# baseAddr: Long (# Pos::< (# do 0->Value;  #);  #);
          rowBytes: Short (# Pos::< (# do 4->Value;  #);  #);
          bounds: Rect (# Pos::< (# do 6->Value;  #);  #);
          pmVersion: Short (# Pos::< (# do 14->Value;  #);  #);
          packType: Short (# Pos::< (# do 16->Value;  #);  #);
          packSize: Long (# Pos::< (# do 18->Value;  #);  #);
          hRes: Long (# Pos::< (# do 22->Value;  #);  #);
          vRes: Long (# Pos::< (# do 26->Value;  #);  #);
          pixelType: Short (# Pos::< (# do 30->Value;  #);  #);
          pixelSize: Short (# Pos::< (# do 32->Value;  #);  #);
          cmpCount: Short (# Pos::< (# do 34->Value;  #);  #);
          cmpSize: Short (# Pos::< (# do 36->Value;  #);  #);
          planeBytes: Long (# Pos::< (# do 38->Value;  #);  #);
          pmTable: Long (# Pos::< (# do 42->Value;  #);  #);
          pmReserved: Long (# Pos::< (# do 46->Value;  #);  #);
          
       #);
     iconMask:
       (# baseAddr: Long (# Pos::< (# do 50->Value;  #);  #);
          rowBytes: Short (# Pos::< (# do 54->Value;  #);  #);
          bounds: Long (# Pos::< (# do 56->Value;  #);  #);
          
       #);
     iconBMap:
       (# baseAddr: Long (# Pos::< (# do 60->Value;  #);  #);
          rowBytes: Short (# Pos::< (# do 64->Value;  #);  #);
          bounds: Long (# Pos::< (# do 66->Value;  #);  #);
          
       #);
     iconData: Long (# Pos::< (# do 70->Value;  #);  #);
     (* iconMaskData: ARRAY [0..0] OF Integer; {icons mask and BitMap data} *)
     
  #);
MatchRec: CStruct
  (# ByteSize::< (# do 10->Value;  #);
     red: Short (# Pos::< (# do 0->Value;  #);  #);
     green: Short (# Pos::< (# do 2->Value;  #);  #);
     blue: Short (# Pos::< (# do 4->Value;  #);  #);
     matchData: Long (# Pos::< (# do 6->Value;  #);  #);
     
  #);
Initgraf: External (# thePort: @Integer;  enter thePort do '$A86E'->PascalTrap;  #);
OpenPort: External (# thePort: @Integer;  enter thePort do '$A86F'->PascalTrap;  #);
InitPort: External (# thePort: @Integer;  enter thePort do '$A86D'->PascalTrap;  #);
ClosePort: External (# thePort: @Integer;  enter thePort do '$A87D'->PascalTrap;  #);
SetPort: External (# thePort: @Integer;  enter thePort do '$A873'->PascalTrap;  #);
GetPort: External (# thePort: ^LongInt;  enter thePort[] do '$A874'->PascalTrap;  #);
GrafDevice: External (# device: @ShortInt;  enter device do '$A872'->PascalTrap;  #);
SetPortBits: External (# portBits: @Integer;  enter portBits do '$A875'->PascalTrap;  #);
PortSize: External
  (# width,height: @ShortInt;  enter (width,height) do '$A876'->PascalTrap;  #);
MovePortTo: External (# l,t: @ShortInt;  enter (l,t) do '$A877'->PascalTrap;  #);
SetOrigin: External (# dh,dv: @ShortInt;  enter (dh,dv) do '$A878'->PascalTrap;  #);
SetClip: External (# rgn: @Integer;  enter rgn do '$A879'->PascalTrap;  #);
GetClip: External (# rgn: @Integer;  enter rgn do '$A87A'->PascalTrap;  #);
ClipRect: External (# r: ^QRect enter r[] do '$A87B'->PascalTrap;  #);
BackPat: External (# pat: @Integer;  enter pat do '$A87C'->PascalTrap;  #);
InitCursor: External (# do '$A850'->PascalTrap;  #);
SetCursor: External (# cursor: @Integer;  enter cursor do '$A851'->PascalTrap;  #);
HideCursor: External (# do '$A852'->PascalTrap;  #);
ShowCursor: External (# do '$A853'->PascalTrap;  #);
ObscureCursor: External (# do '$A856'->PascalTrap;  #);
HidePen: External (# do '$A896'->PascalTrap;  #);
ShowPen: External (# do '$A897'->PascalTrap;  #);
GetPen: External (# p: ^QPoint enter p[] do '$A89A'->PascalTrap;  #);
GetPenState: External (# pstate: ^PenState;  enter pstate[] do '$A898'->PascalTrap;  #);
SetPenState: External (# pstate: ^PenState;  enter pstate[] do '$A899'->PascalTrap;  #);
PenSize: External
  (# width,height: @ShortInt;  enter (width,height) do '$A89B'->PascalTrap;  #);
PenMode: External (# p: @ShortInt;  enter p do '$A89C'->PascalTrap;  #);
PenPat: External (# patAddr: @Integer;  enter patAddr do '$A89D'->PascalTrap;  #);
PenNormal: External (# do '$A89E'->PascalTrap;  #);
MoveTo: External (# h,v: @ShortInt;  enter (h,v) do '$A893'->PascalTrap;  #);
Move: External (# dh,dv: @ShortInt;  enter (dh,dv) do '$A894'->PascalTrap;  #);
LineTo: External (# h,v: @ShortInt;  enter (h,v) do '$A891'->PascalTrap;  #);
Line: External (# dh,dv: @ShortInt;  enter (dh,dv) do '$A892'->PascalTrap;  #);
TextFont: External (# font: @ShortInt;  enter font do '$A887'->PascalTrap;  #);
TextFace: External (# face: @ShortInt;  enter face do '$A888'->PascalTrap;  #);
TextMode: External (# mode: @ShortInt;  enter mode do '$A889'->PascalTrap;  #);
TextSize: External (# size: @ShortInt;  enter size do '$A88A'->PascalTrap;  #);
DrawChar: External (# ch: @ShortInt;  enter ch do '$A883'->PascalTrap;  #);
DrawString: External (# s: [1] @char enter s do '$A884'->PascalTrap;  #);
DrawText: External
  (# ptr: @Integer; firstByte,byteCount: @ShortInt; 
  enter (ptr,firstByte,byteCount)
  do '$A885'->PascalTrap; 
  #);
CharWidth: External (# ch,result: @ShortInt;  enter ch do '$A88D'->PascalTrap;  exit result #);
TextWidth: External
  (# ptr: @Integer; firstByte,byteCount,result: @ShortInt; 
  enter (ptr,firstByte,byteCount)
  do '$A886'->PascalTrap; 
  exit result
  #);
StringWidth: External
  (# s: [1] @Char; result: @ShortInt;  enter s do '$A88C'->PascalTrap;  exit result #);
MeasureText: External
  (# ptr,charLocs: @Integer; Count: @ShortInt; 
  enter (count,ptr,charLocs)
  do '$A837'->PascalTrap; 
  #);
GetFontInfo: External (# info: ^fontInfo;  enter info[] do '$A88B'->PascalTrap;  #);
ForeColor: External (# color: @Integer;  enter color do '$A862'->PascalTrap;  #);
BackColor: External (# color: @Integer;  enter color do '$A863'->PascalTrap;  #);
ColorBit: External (# whichBit: @ShortInt;  enter whichBit do '$A864'->PascalTrap;  #);
SetRect: External
  (# Rect: ^QRect; l,t,r,b: @ShortInt;  enter (Rect[],l,t,r,b) do '$A8A7'->PascalTrap;  #);
OffsetRect: External
  (# r: ^QRect; dh,dv: @ShortInt;  enter (r[],dh,dv) do '$A8A8'->PascalTrap;  #);
InsetRect: External
  (# r: ^QRect; dh,dv: @ShortInt;  enter (r[],dh,dv) do '$A8A9'->PascalTrap;  #);
SectRect: External
  (# src1,src2,dest: ^QRect; result: @Boolean
  enter (src1[],src2[],dest[])
  do '$A8AA'->PascalTrap; 
  exit result
  #);
UnionRect: External
  (# src1,src2,dest: ^QRect enter (src1[],src2[],dest[]) do '$A8AB'->PascalTrap;  #);
EqualRect: External
  (# r1,r2: ^QRect; result: @Boolean
  enter (r1[],r2[])
  do '$A8A6'->PascalTrap; 
  exit result
  #);
EmptyRect: External
  (# r: ^QRect; result: @Boolean enter r[] do '$A8AE'->PascalTrap;  exit result #);
FrameRect: External (# r: ^QRect enter r[] do '$A8A1'->PascalTrap;  #);
PaintRect: External (# r: ^QRect enter r[] do '$A8A2'->PascalTrap;  #);
EraseRect: External (# r: ^QRect enter r[] do '$A8A3'->PascalTrap;  #);
InvertRect: External (# r: ^QRect enter r[] do '$A8A4'->PascalTrap;  #);
FillRect: External
  (# r: ^QRect; patAdr: @Integer;  enter (r[],patAdr) do '$A8A5'->PascalTrap;  #);
FrameOval: External (# r: ^QRect enter r[] do '$A8B7'->PascalTrap;  #);
PaintOval: External (# r: ^QRect enter r[] do '$A8B8'->PascalTrap;  #);
EraseOval: External (# r: ^QRect enter r[] do '$A8B9'->PascalTrap;  #);
InvertOval: External (# r: ^QRect enter r[] do '$A8BA'->PascalTrap;  #);
FillOval: External
  (# r: ^QRect; patAdr: @Integer;  enter (r[],patAdr) do '$A8BB'->PascalTrap;  #);
FrameRoundRect: External
  (# r: ^QRect; ow,oh: @ShortInt;  enter (r[],ow,oh) do '$A8B0'->PascalTrap;  #);
PaintRoundRect: External
  (# r: ^QRect; ow,oh: @ShortInt;  enter (r[],ow,oh) do '$A8B1'->PascalTrap;  #);
EraseRoundRect: External
  (# r: ^QRect; ow,oh: @ShortInt;  enter (r[],ow,oh) do '$A8B2'->PascalTrap;  #);
InvertRoundRect: External
  (# r: ^QRect; ow,oh: @ShortInt;  enter (r[],ow,oh) do '$A8B3'->PascalTrap;  #);
FillRoundRect: External
  (# r: ^QRect; patAdr: @Integer; ow,oh: @ShortInt; 
  enter (r[],ow,oh,patAdr)
  do '$A8B4'->PascalTrap; 
  #);
FrameArc: External
  (# r: ^QRect; ow,oh: @ShortInt;  enter (r[],ow,oh) do '$A8BE'->PascalTrap;  #);
PaintArc: External
  (# r: ^QRect; ow,oh: @ShortInt;  enter (r[],ow,oh) do '$A8BF'->PascalTrap;  #);
EraseArc: External
  (# r: ^QRect; ow,oh: @ShortInt;  enter (r[],ow,oh) do '$A8C0'->PascalTrap;  #);
InvertArc: External
  (# r: ^QRect; ow,oh: @ShortInt;  enter (r[],ow,oh) do '$A8C1'->PascalTrap;  #);
FillArc: External
  (# r: ^QRect; patAdr: @Integer; ow,oh: @ShortInt; 
  enter (r[],ow,oh,patAdr)
  do '$A8C2'->PascalTrap; 
  #);
NewRgn: External (# theHandle: @Integer;  do '$A8D8'->PascalTrap;  exit theHandle #);
OpenRgn: External (# do '$A8DA'->PascalTrap;  #);
CloseRgn: External (# theHandle: @Integer;  enter theHandle do '$A8DB'->PascalTrap;  #);
DisposeRgn: External (# theHandle: @Integer;  enter theHandle do '$A8D9'->PascalTrap;  #);
CopyRgn: External (# s,d: @Integer;  enter (s,d) do '$A8DC'->PascalTrap;  #);
SetEmptyRgn: External (# theHandle: @Integer;  enter theHandle do '$A8DD'->PascalTrap;  #);
SetRectRgn: External
  (# theHandle: @Integer; l,t,r,b: @ShortInt; 
  enter (theHandle,l,t,r,b)
  do '$A8DE'->PascalTrap; 
  #);
RectRgn: External
  (# theHandle: @Integer; r: ^QRect enter (theHandle,r[]) do '$A8DF'->PascalTrap;  #);
OffsetRgn: External
  (# theHandle: @Integer; dh,dv: @ShortInt; 
  enter (theHandle,dh,dv)
  do '$A8E0'->PascalTrap; 
  #);
InsetRgn: External
  (# theHandle: @Integer; dh,dv: @ShortInt; 
  enter (theHandle,dh,dv)
  do '$A8E1'->PascalTrap; 
  #);
SectRgn: External
  (# rgna,rgnb,rgnd: @Integer;  enter (rgna,rgnb,rgnd) do '$A8E4'->PascalTrap;  #);
UnionRgn: External
  (# rgna,rgnb,rgnd: @Integer;  enter (rgna,rgnb,rgnd) do '$A8E5'->PascalTrap;  #);
DiffRgn: External
  (# rgna,rgnb,rgnd: @Integer;  enter (rgna,rgnb,rgnd) do '$A8E6'->PascalTrap;  #);
XorRgn: External
  (# rgna,rgnb,rgnd: @Integer;  enter (rgna,rgnb,rgnd) do '$A8E7'->PascalTrap;  #);
RectInRgn: External
  (# r: ^QRect; rgn: @Integer; result: @Boolean
  enter (r[],rgn)
  do '$A8E9'->PascalTrap; 
  exit result
  #);
EqualRgn: External
  (# rgna,rgnB: @Integer; result: @Boolean
  enter (rgnA,rgnB)
  do '$A8E3'->PascalTrap; 
  exit result
  #);
EmptyRgn: External
  (# rgn: @Integer; result: @Boolean enter rgn do '$A8E2'->PascalTrap;  exit result #);
FrameRgn: External (# theHandle: @Integer;  enter theHandle do '$A8D2'->PascalTrap;  #);
PaintRgn: External (# theHandle: @Integer;  enter theHandle do '$A8D3'->PascalTrap;  #);
EraseRgn: External (# theHandle: @Integer;  enter theHandle do '$A8D4'->PascalTrap;  #);
InvertRgn: External (# theHandle: @Integer;  enter theHandle do '$A8D5'->PascalTrap;  #);
FillRgn: External
  (# theHandle,patAddr: @Integer;  enter (theHandle,patAddr) do '$A8D6'->PascalTrap;  #);
ScrollRect: External
  (# r: ^QRect; dh,dv: @ShortInt; updateRgn: @Integer; 
  enter (r[],dh,dv,updateRgn)
  do '$A8EF'->PascalTrap; 
  #);
CopyBits: External
  (# scrBitsAddr,dstBitsAddr,maskRgn: @Integer; srcRect,destRect: ^QRect; mode: @ShortInt; 
  enter (scrBitsAddr,dstBitsAddr,srcRect[],destRect[],mode,maskRgn)
  do '$A8EC'->PascalTrap; 
  #);
SeedFill: External
  (# srcptr,dstPtr: @Integer; srcR,dstR,height,words,seedH,seedW: @ShortInt; 
  enter (srcPtr,dstPtr,srcR,dstR,height,words,seedH,seedW)
  do '$A839'->PascalTrap; 
  #);
CalcMask: External
  (# srcptr,dstPtr: @Integer; srcR,dstR,height,words: @ShortInt; 
  enter (srcPtr,dstPtr,srcR,dstR,height,words)
  do '$A838'->PascalTrap; 
  #);
CopyMask: External
  (# scrBitsAddr,maskBitsAddr,dstBitsAddr: @Integer; srcRect,maskRect,destRect: ^QRect; 
  enter (scrBitsAddr,maskBitsAddr,dstBitsAddr,srcRect[],maskRect[],destRect[])
  do '$A817'->PascalTrap; 
  #);
OpenPicture: External
  (# picFrame: ^QRect; picHandle: @Integer; 
  enter picFrame[]
  do '$A8F3'->PascalTrap; 
  exit picHandle
  #);
PicComment: External
  (# kind,dataSize: @ShortInt; data: @Integer; 
  enter (kind,dataSize,data)
  do '$A8F2'->PascalTrap; 
  #);
ClosePicture: External (# do '$A8F4'->PascalTrap;  #);
DrawPicture: External
  (# pic: @Integer; dstRect: ^QRect enter (pic,dstRect[]) do '$A8F6'->PascalTrap;  #);
KillPicture: External (# pic: @Integer;  enter pic do '$A8F6'->PascalTrap;  #);
OpenPoly: External (# polyHandle: @Integer;  do '$A8CB'->PascalTrap;  exit polyHandle #);
ClosePoly: External (# do '$A8CC'->PascalTrap;  #);
KillPoly: External (# polyHandle: @Integer;  enter polyHandle do '$A8CD'->PascalTrap;  #);
OffsetPoly: External
  (# polyHandle: @Integer; dh,dv: @ShortInt; 
  enter (polyHandle,dh,dv)
  do '$A8CE'->PascalTrap; 
  #);
FramePoly: External (# polyHandle: @Integer;  enter polyHandle do '$A8C6'->PascalTrap;  #);
PaintPoly: External (# polyHandle: @Integer;  enter polyHandle do '$A8C7'->PascalTrap;  #);
ErasePoly: External (# polyHandle: @Integer;  enter polyHandle do '$A8C8'->PascalTrap;  #);
InvertPoly: External (# polyHandle: @Integer;  enter polyHandle do '$A8C9'->PascalTrap;  #);
FillPoly: External
  (# polyHandle: @Integer; patAdr: @Integer; 
  enter (polyHandle,patAdr)
  do '$A8CA'->PascalTrap; 
  #);
SetPt: External (# p: ^QPoint; h,v: @ShortInt;  enter (p[],h,v) do '$A880'->PascalTrap;  #);
LocalToGlobal: External (# p: ^QPoint enter p[] do '$A870'->PascalTrap;  #);
GlobalToLocal: External (# p: ^QPoint enter p[] do '$A871'->PascalTrap;  #);
Random: External (# result: @ShortInt;  do '$A861'->PascalTrap;  exit result #);
StuffHex: External
  (# thingPtr: @Integer; s: [1] @char enter (thingPtr,s) do '$A866'->PascalTrap;  #);
GetPixel: External
  (# h,v,result: @ShortInt;  enter (h,v) do '$A865'->PascalTrap;  exit result #);
ScalePt: External
  (# p: ^QPoint; srcRect,dstRect: ^QRect
  enter (p[],srcRect[],dstRect[])
  do '$A8F8'->PascalTrap; 
  #);
MapPt: External
  (# p: ^QPoint; srcRect,dstRect: ^QRect
  enter (p[],srcRect[],dstRect[])
  do '$A8F9'->PascalTrap; 
  #);
MapRect: External
  (# r: ^QRect; srcRect,dstRect: ^QRect
  enter (r[],srcRect[],dstRect[])
  do '$A8FA'->PascalTrap; 
  #);
MapRgn: External
  (# r: @Integer; srcRect,dstRect: ^QRect
  enter (r,srcRect[],dstRect[])
  do '$A8FB'->PascalTrap; 
  #);
MapPoly: External
  (# p: @Integer; srcRect,dstRect: ^QRect
  enter (p,srcRect[],dstRect[])
  do '$A8FC'->PascalTrap; 
  #);
Addpt: External
  (# src: @Integer; dst: ^QPoint enter (src,dst[]) do '$A87E'->PascalTrap;  #);
Subpt: External
  (# src: @Integer; dst: ^QPoint enter (src,dst[]) do '$A87F'->PascalTrap;  #);
EqualPt: External
  (# pt1,pt2: @Integer; result: @Boolean
  enter (pt1,pt2)
  do '$A881'->PascalTrap; 
  exit result
  #);
PtInRect: External
  (# pt1: @Integer; r: ^QRect; result: @Boolean
  enter (pt1,r[])
  do '$A8AD'->PascalTrap; 
  exit result
  #);
Pt2Rect: External
  (# pt1,pt2: @Integer; r: ^QRect enter (pt1,pt2,r[]) do '$A8AC'->PascalTrap;  #);
PtToAngle: External
  (# pt1: @Integer; r: ^QRect; angle: ^CStruct
  enter (r[],pt1,angle[])
  do '$A8C3'->PascalTrap; 
  #);
PtInRgn: External
  (# pt1: @Integer; r: @Integer; result: @Boolean
  enter (pt1,r)
  do '$A8E8'->PascalTrap; 
  exit result
  #);
QDError: External (# result: @ShortInt;  do '$AA40'->PascalTrap;  exit result #);
GetForeColor: External (# c: ^RGBColor enter c[] do '$AA19'->PascalTrap;  #);
GetBackColor: External (# c: ^RGBColor enter c[] do '$AA1A'->PascalTrap;  #);
(*  Color quickdraw and stuff  *)
OpenCPort: External (# thePort: @Integer;  enter thePort do '$AA00'->PascalTrap;  #);
initCPort: External (# thePort: @Integer;  enter thePort do '$AA01'->PascalTrap;  #);
closeCPort: External (# thePort: @Integer;  enter thePort do '$AA02'->PascalTrap;  #);
RGBForeColor: External (# c: ^RGBColor enter c[] do '$AA14'->PascalTrap;  #);
RGBBackColor: External (# c: ^RGBColor enter c[] do '$AA15'->PascalTrap;  #);
SetCPixel: External
  (# h,v: @ShortInt; c: ^RGBColor enter (h,v,c[]) do '$AA16'->PascalTrap;  #);
GetCPixel: External
  (# h,v: @ShortInt; c: ^RGBColor enter (h,v,c[]) do '$AA17'->PascalTrap;  #);
AllocCursor: External (# do '$AA1D'->PascalTrap;  #);
BackPixPat: External (# pp: @Integer;  enter pp do '$AA0B'->PascalTrap;  #);
Color2Index: External
  (# myColor: ^RGBColor; result: @Integer; 
  enter myColor[]
  do '$AA33'->PascalTrap; 
  exit result
  #);
DisPosCTable: External (# cTable: @Integer;  enter cTable do '$AA24'->PascalTrap;  #);
DisPosPixMap: External (# pm: @Integer;  enter pm do '$AA04'->PascalTrap;  #);
FillCArc: External
  (# r: ^QRect; startAngle,arcAngle: @ShortInt; pp: @Integer; 
  enter (r[],startAngle,arcAngle,pp)
  do '$AA11'->PascalTrap; 
  #);
FillCRect: External (# r: ^QRect; pp: @Integer;  enter (r[],pp) do '$AA0E'->PascalTrap;  #);
GetCTSeed: External (# seed: @Integer;  do '$AA28'->PascalTrap;  exit seed #);
GetPixPat: External
  (# patID: @ShortInt; pp: @Integer;  enter patID do '$AA0C'->PascalTrap;  exit pp #);
NewPixMap: External (# pp: @Integer;  do '$AA03'->PascalTrap;  exit pp #);
ProtectEntry: External
  (# index: @ShortInt; protect: @Boolean;  enter (index,protect) do '$AA3D'->PascalTrap;  #);
SetCCursor: External (# cCrsr: @Integer;  enter cCrsr do '$AA1C'->PascalTrap;  #);
SpaceExtra: External (# extra: @Integer;  enter extra do '$A88E'->PascalTrap;  #);
BitMapToRegion: External
  (# rgn: @Integer; bMap: @Integer; error: @Integer; 
  enter (rgn,bMap)
  do '$A8D7'->PascalTrap; 
  exit error
  #);
CharExtra: External (# extra: @Integer;  enter extra do '$AA23'->PascalTrap;  #);
CopyPixMap: External
  (# srcPM,dstPM: @Integer;  enter (srcPM,dstPM) do '$AA05'->PascalTrap;  #);
DisPosCCursor: External (# cCrsr: @Integer;  enter cCrsr do '$AA26'->PascalTrap;  #);
DisPosPixPat: External (# pp: @Integer;  enter pp do '$AA08'->PascalTrap;  #);
FillCOval: External (# pp: @Integer; r: ^QRect;  enter (r[],pp) do '$AA0F'->PascalTrap;  #);
FillCRgn: External (# rgn,pp: @Integer;  enter (rgn,pp) do '$AA12'->PascalTrap;  #);
GetCCursor: External
  (# crsrID: @ShortInt; CCrsrHandle: @Integer; 
  enter crsrID
  do '$AA1B'->PascalTrap; 
  exit CCrsrHandle
  #);
GetDeviceList: External (# GDHandle: @Integer;  do '$AA29'->PascalTrap;  exit GDHandle #);
GetGDevice: External (# GDHandle: @Integer;  do '$AA32'->PascalTrap;  exit GDHandle #);
GetMaxDevice: External
  (# globalRect: ^QRect; GDHandle: @Integer; 
  enter globalRect[]
  do '$AA27'->PascalTrap; 
  exit GDHandle
  #);
HiliteColor: External (# color: ^RGBColor;  enter color[] do '$AA22'->PascalTrap;  #);
MakeITable: External
  (# cTabH,iTabH: @Integer; res: @ShortInt; 
  enter (cTabH,iTabH,res)
  do '$AA39'->PascalTrap; 
  #);
NewPixPat: External (# PixPatHandle: @Integer;  do '$AA07'->PascalTrap;  exit PixPatHandle #);
OpColor: External (# color: ^RGBColor;  enter color[] do '$AA21'->PascalTrap;  #);
PenPixPat: External (# PixPatHandle: @Integer;  enter PixPatHandle do '$AA0A'->PascalTrap;  #);
PlotCIcon: External
  (# mr: ^QRect; icon: @Integer;  enter (mr[],icon) do '$AA1F'->PascalTrap;  #);
RealColor: External
  (# color: ^RGBColor; result: @Boolean; 
  enter color[]
  do '$AA36'->PascalTrap; 
  exit result
  #);
ReserveEntry: External
  (# index: @ShortInt; reserve: @Boolean;  enter (index,reserve) do '$AA3E'->PascalTrap;  #);
SeedCFill: External
  (# srcBits,dstBits,matchProc,matchData: @Integer;
     srcRect,dstRect: ^QRect;
     seedH,seedV: @ShortInt;
     
  enter (srcBits,dstBits,srcRect[],dstRect[],matchProc,matchData)
  do '$AA50'->PascalTrap; 
  #);
SetClientID: External (# id: @Integer;  enter id do '$AA3C'->PascalTrap;  #);
SetEntries: External
  (# start,count: @ShortInt; aTable: @Integer; 
  enter (start,count,aTable)
  do '$AA3F'->PascalTrap; 
  #);
SetPortPix: External
  (# PixMapHandle: @Integer;  enter PixMapHandle do '$AA06'->PascalTrap;  #);
CalcCMask: External
  (# srcBits,dstBits,matchProc,matchData: @Integer;
     srcRect,dstRect: ^QRect;
     seedRGB: ^RGBColor;
     
  enter (srcBits,dstBits,srcRect[],dstRect[],seedRGB[],matchProc,matchData)
  do '$AA4F'->PascalTrap; 
  #);
CopyPixPat: External
  (# srcPP,dstPP: @Integer;  enter (srcPP,dstPP) do '$AA09'->PascalTrap;  #);
DisPosCIcon: External (# theIcon: @Integer;  enter theIcon do '$AA25'->PascalTrap;  #);
DisPosGDevice: External (# GDHandle: @Integer;  enter GDHandle do '$AA30'->PascalTrap;  #);
FillCPoly: External
  (# poly,PixPatHandle: @Integer;  enter (poly,PixPatHandle) do '$AA13'->PascalTrap;  #);
FillCRoundRect: External
  (# mr: ^QRect; ovalWidth,ovalHeight: @ShortInt; PixPatHandle: @Integer; 
  enter (mr[],ovalWidth,ovalHeight,PixPatHandle)
  do '$AA10'->PascalTrap; 
  #);
GetCIcon: External
  (# iconID: @ShortInt; CIconHandle: @Integer; 
  enter iconID
  do '$AA1E'->PascalTrap; 
  exit CIconHandle
  #);
GetCTable: External
  (# ctID: @ShortInt; CTabHandle: @Integer; 
  enter ctID
  do '$AA18'->PascalTrap; 
  exit CTabHandle
  #);
GetMainDevice: External (# GDHandle: @Integer;  do '$AA2A'->PascalTrap;  exit GDHandle #);
GetNextDevice: External
  (# curDevice,nextDevice: @Integer; 
  enter curDevice
  do '$AA2B'->PascalTrap; 
  exit nextDevice
  #);
GetSubTable: External
  (# myColors,targetTbl: @Integer; iTabRes: @ShortInt; 
  enter (myColors,iTabRes,targetTbl)
  do '$AA37'->PascalTrap; 
  #);
Index2Color: External
  (# index: @Integer; aColor: ^RGBColor;  enter (index,aColor[]) do '$AA34'->PascalTrap;  #);
InitGDevice: External
  (# qdRefNum: @ShortInt; mode,gdh: @Integer; 
  enter (qdRefNum,mode,gdh)
  do '$AA2E'->PascalTrap; 
  #);
MakeRGBPat: External
  (# ppxPatHandle: @Integer; myColor: ^RGBColor; 
  enter (ppxPatHandle,myColor[])
  do '$AA0D'->PascalTrap; 
  #);
NewGDevice: External
  (# refNum: @ShortInt; mode: @Integer;  enter (refNum,mode) do '$AA2F'->PascalTrap;  #);
RestoreEntries: External
  (# srcTable,dstTable: @Integer; selection: ^CStruct; 
  enter (srcTable,dstTable,selection[])
  do '$AA4A'->PascalTrap; 
  #);
SaveEntries: External
  (# srcTable,resultTable: @Integer; selection: ^CStruct; 
  enter (srcTable,resultTable,selection[])
  do '$AA49'->PascalTrap; 
  #);
SetDeviceAttribute: External
  (# gdh: @Integer; attribute: @ShortInt; Value: @Boolean; 
  enter (gdh,attribute,Value)
  do '$AA2D'->PascalTrap; 
  #);
SetGDevice: External (# gd: @Integer;  enter gd do '$AA31'->PascalTrap;  #);
TestDeviceAttribute: External
  (# gdh: @Integer; attribute: @ShortInt; flag: @Boolean; 
  enter (gdh,attribute)
  do '$AA2C'->PascalTrap; 
  exit flag
  #);
  
GetTextWidth:
	(# data: ^text;
		width: @integer;
	enter data[]
	do (if data.lgth > 0 then
			(@@data.T[1], 0, data.lgth) -> TextWidth -> width;
		else
			0 -> width;
		if);
	exit width
	#);
DrawBetaText:
	(# data: ^text;
	enter data[]
	do (if data.lgth > 0 then
			(@@data.T[1], 0, data.lgth) -> DrawText;
		if);
	#);

AppFile: CStruct
  (# vRefNum: @ (# exit 0->GetShort #);
     fType: @ (# exit 2->GetLong #);
     versNum: @ (# exit 6->GetShort #);
     length: (# exit 8->GetByte #);
     fName:
       (# Rep: [length] @Char; 
       do (for inx: Rep.range repeat inx+8->GetByte->Rep[inx];  for)
       exit rep
       #);
     
  #);
AppOpen: (# exit 0 #);
AppPrint: (# exit 1 #);
ClrAppFiles: External (# index: @ShortInt;  enter index do callPascal;  #);
ExitToShell: External (# do '$A9F4'->pascalTrap;  #);
GetAppParms: External
  (# apName: ^PascalString; apRefNum: ^ShortRef; apParam: ^LongInt; 
  enter (apName[],apRefNum[],apParam[])
  do '$A9F5'->pascalTrap; 
  #);
UnloadSeg: External (# routineAddr: @Integer;  enter routineAddr do '$A9F1'->pascalTrap;  #);
CountAppFiles: External
  (# message,Count: ^ShortRef;  enter (message[],Count[]) do CallPascal;  #);
GetAppFiles: External
  (# index: @ShortInt; theFile: ^Appfile;  enter (index,theFile[]) do CallPascal;  #);
  
synthCodeRsrc: (# exit 'snth' #);
soundListRsrc: (# exit 'snd ' #);
NumVersion: CStruct (# ByteSize::< (# do 4->Value;  #);  #);
Comp3to1: External
  (# inBuffer,outBuffer,Cnt,inState,outState: @Integer; 
  enter (inBuffer,outBuffer,Cnt,inState,outState)
  do '$A800'->PascalTrap; 
  #);
Comp6to1: External
  (# inBuffer,outBuffer,Cnt,inState,outState: @Integer; 
  enter (inBuffer,outBuffer,Cnt,inState,outState)
  do '$A800'->PascalTrap; 
  #);
Exp1to3: External
  (# inBuffer,outBuffer,Cnt,inState,outState,numChannels,whichChannel: @Integer; 
  do '$A800'->PascalTrap; 
  #);
Exp1to6: External
  (# inBuffer,outBuffer,Cnt,inState,outState,numChannels,whichChannel: @Integer; 
  do '$A800'->PascalTrap; 
  #);
GetSoundVol: External (# level: ^CStruct enter level[] do CallPascal;  #);
MACEVersion: External (# ver: @Integer;  do '$A800'->PascalTrap;  exit ver #);
SetSoundVol: External (# level: @ShortInt;  enter level do CallPascal;  #);
SndAddModifier: External
  (# chan,modifier,init: @Integer; id,err: @ShortInt; 
  enter (chan,modifier,id,init)
  do '$A802'->PascalTrap; 
  exit err
  #);
SndChannelStatus: External
  (# theChannel,theStatus: @Integer; theLength,err: @ShortInt; 
  enter (theChannel,theLength,theStatus)
  do '$A800'->PascalTrap; 
  exit err
  #);
SndControl: External
  (# id,err: @ShortInt; cmd: ^CStruct;  enter (id,cmd[]) do '$A806'->PascalTrap;  exit err #);
SndDisposeChannel: External
  (# chan: @Integer; quietNow: @Boolean; err: @ShortInt; 
  enter (chan,quietNow)
  do '$A801'->PascalTrap; 
  exit err
  #);
SnddoCommand: External
  (# chan: @Integer; cmd: ^CStruct; noWait: @Boolean; err: @ShortInt; 
  enter (chan,cmd[],noWait)
  do '$A803'->PascalTrap; 
  exit err
  #);
SnddoImmediate: External
  (# chan: @Integer; cmd: ^CStruct; err: @ShortInt; 
  enter (chan,cmd[])
  do '$A804'->PascalTrap; 
  exit err
  #);
SndPlay: External
  (# sndHdl,SndChannelPtr: @Integer; async: @Boolean; result: @ShortInt
  enter (sndHdl,sndChannelPtr,aSync)
  do '$A805'->PascalTrap; 
  exit result
  #);
SndNewChannel: External
  (# chan,init,userRoutine: @Integer; synth,result: @ShortInt; 
  enter (chan,synth,init,userRoutine)
  do '$A807'->PascalTrap; 
  exit result
  #);
SndGetSysBeepState: External
  (# sysBeepState: ^ShortRef; 
  enter sysBeepState[]
  do '{$203C,$0018,$0008,$A800}'->PascalTrap; 
  #);
SndSetSysBeepState: External
  (# sysBeepState: @ShortInt; 
  enter sysBeepState
  do '{$203C,$001C,$0008,$A800}'->PascalTrap; 
  #);
SndManagerStatus: External
  (# theStatus: @Integer; theLength,result: @ShortInt; 
  enter (theStatus,theLength)
  do '{$203C,$0014,$0008,$A800}'->PascalTrap; 
  exit result
  #);
SndStartFilePlay: External
  (# chan,bufferSize,theBuffer,theSelection,theCompletion: @Integer;
     fRefNum,resNum,result: @ShortInt;
     async: @Boolean;
     
  enter (chan,fRefNum,resNum,bufferSize,theBuffer,theSelection,theCompletion,async)
  do '{$203C,$0D00,$0008,$A800}'->PascalTrap; 
  exit result
  #);
SndStopFilePlay: External
  (# chan: @Integer; result: @ShortInt; async: @Boolean; 
  enter (chan,async)
  do '{$203C,$0308,$0008,$A800}'->PascalTrap; 
  exit result
  #);
SndPauseFilePlay: External
  (# chan: @Integer; result: @ShortInt; 
  enter chan
  do '{$203C,$0204,$0008,$A800}'->PascalTrap; 
  exit result
  #);
SndPlaydoubleBuffer: External
  (# chan,theParams: @Integer; result: @ShortInt; 
  enter (chan,theParams)
  do '{$203C,$0020,$0008,$A800}'->PascalTrap; 
  exit result
  #);
SndSoundManagerVersion: External
  (# theVersion: ^NumVersion do '{$203C,$000C,$0008,$A800}'->PascalTrap;  exit theVersion[] #);
StartSound: External (# synthRec,numBytes,completionRtn: @Integer;  do CallPascal;  #);
StopSound: External (# do CallPascal;  #);
Sounddone: External (# done: @Boolean do CallPascal;  exit done #);
(*
 SndGetBufferStufferLoad: External
 (# channelFeatures,result: @ShortIntl
 do CallPascal;
 #);
 SndGetMixerLoad: External (# do CallPascal; #);
 *)
  

(* resource IDs and item offsets of pre-7.0 dialogs *)
putDlgID: (# exit - 3999 #);
putSave: (# exit 1 #);
putCancel: (# exit 2 #);
putEject: (# exit 5 #);
putDrive: (# exit 6 #);
putName: (# exit 7 #);
getDlgID: (# exit - 4000 #);
getOpen: (# exit 1 #);
getCancel: (# exit 3 #);
getEject: (# exit 5 #);
getDrive: (# exit 6 #);
getNmList: (# exit 7 #);
getScroll: (# exit 8 #);
(* resource IDs and item offsets of 7.0 dialogs *)
sfPutDialogID: (# exit - 6043 #);
sfGetDialogID: (# exit - 6042 #);
sfItemOpenButton: (# exit 1 #);
sfItemCancelButton: (# exit 2 #);
sfItemBalloonHelp: (# exit 3 #);
sfItemVolumeUser: (# exit 4 #);
sfItemEjectButton: (# exit 5 #);
sfItemDesktopButton: (# exit 6 #);
sfItemFileListUser: (# exit 7 #);
sfItemPopUpMenuUser: (# exit 8 #);
sfItemDividerLinePict: (# exit 9 #);
sfItemFileNameTextEdit: (# exit 10 #);
sfItemPromptStaticText: (# exit 11 #);
sfItemNewFolderUser: (# exit 12 #);
(* pseudo-item hits for use in DlgHook *)
sfHookFirstCall: (# exit - 1 #);
sfHookCharOffset: (# exit 4096 #);
sfHookNullEvent: (# exit 100 #);
sfHookRebuildList: (# exit 101 #);
sfHookFolderPopUp: (# exit 102 #);
sfHookOpenFolder: (# exit 103 #);
(* the following are only in system 7.0+ *)
sfHookOpenAlias: (# exit 104 #);
sfHookGoToDesktop: (# exit 105 #);
sfHookGoToAliasTarget: (# exit 106 #);
sfHookGoToParent: (# exit 107 #);
sfHookGoToNextDrive: (# exit 108 #);
sfHookGoToPrevDrive: (# exit 109 #);
sfHookChangeSelection: (# exit 110 #);
sfHookSetActiveOffset: (# exit 200 #);
sfHookLastCall: (# exit - 2 #);
(* the refcon field of the dialog record during a
 modalfilter or dialoghook contains one of the following *)
sfMainDialogRefCon: (# exit 'stdf' #);
sfNewFolderDialogRefCon: (# exit 'nfdr' #);
sfReplaceDialogRefCon: (# exit 'rplc' #);
sfStatWarnDialogRefCon: (# exit 'stat' #);
sfLockWarnDialogRefCon: (# exit 'lock' #);
sfErrorDialogRefCon: (# exit 'err ' #);
SFReply: CStruct (* Pre sys 7 *)
  (# ByteSize::< (# do 80->Value #);
     good: Byte (# Pos::< (# do 0->Value;  #);  #);
     copy: Byte (# Pos::< (# do 1->Value;  #);  #);
     ftype: Long (# Pos::< (# do 2->Value;  #);  #);
     vRefNum: Short (# Pos::< (# do 6->Value;  #);  #);
     version: Short (# Pos::< (# do 8->Value;  #);  #);
     fname:
       (# name: @Text; length: @Integer
       do
          10 -> R.%getByte->length;
          (* Above line tos_converted from: (R,10)->tos'%inxGetByte'->length; *)
            (# t: [length] @Char
            do (for i: length repeat 
                    10+i -> R.%getByte->t[i]
                    (* Above line tos_converted from: (R,10+i)->tos'%inxGetByte'->t[i] *)
               for); 
               t->name; 
            #);
          
       exit name
       #);
     directoryName: (* converts vRefNum to a full pathName *)
       (# a: [200] @Integer; d: [1] @Char; VolRef: @Integer; 
       do vRefNum->VolRef; (VolRef,@@ a[1])->pathNameFromWD->pToC->d; 
       exit d
       #);
     
  #);
SFTypeList: CStruct
  (# ByteSize::< (# do 16->Value; INNER ;  #);
     setType: (# typeNo,what: @Integer enter (typeNo,what) do what->R[typeNo] #);
     
  #);
StandardFileReply: CStruct (* Sys 7 *)
  (# ByteSize::< (# do 88->Value #);
     sfGood: Byte (# Pos::< (# do 0->Value;  #);  #);
     sfReplacing: Byte (# Pos::< (# do 1->Value;  #);  #);
     sfType: Long (# Pos::< (# do 2->Value;  #);  #);
     specVRefNum: signedShort (# Pos::< (# do 6->Value;  #);  #);
     specParId: Long (# Pos::< (# do 8->Value;  #);  #);
     nameStart: (# exit 12 #);
     getSpecName:
       (# name: ^Text; length,cur,last: @Integer; 
       do
          &Text[]->name[];
          name.clear;
          nameStart->getByte->length;
          (if length < 1
           // true then length->putInt; ' Length!'->putLine; exception (* ugly *)
          if);
          nameStart+1->cur;
          nameStart+length->last;
          aLoop: cycle
            (# do cur->getByte->name.put; (if cur // last then leave aLoop;  if); cur+1->cur; 
            #);
          
       exit name[]
       #);
     directoryName: (* converts ParID to a full pathName *)
       (# a: [200] @Integer; t: ^Text; ID,volRef: @Integer; 
       do
          specVRefNum->volRef;
          specParId->ID;
          &Text[]->t[];
          (ID,volRef,@@ a[1])->pathNameFromDirID->pToC->t;
          
       exit t[]
       #);
     (* no need for a putSpecName, since FSMakeFSSpec is always used for this. *)
     sfScript: Short (# Pos::< (# do 76->Value;  #);  #);
     sfFlags: Short (# Pos::< (# do 78->Value;  #);  #);
     sfIsFolder: Byte (# Pos::< (# do 80->Value;  #);  #);
     sfIsVolume: Byte (# Pos::< (# do 81->Value;  #);  #);
     sfReserved1: Long (# Pos::< (# do 82->Value;  #);  #);
     sfReserved2: Short (# Pos::< (# do 86->Value;  #);  #);
     
  #);
SFGetfile: External
  (# where,fileFilter,dlgHook: @Integer;
     prompt: [1] @Char;
     numTypes: @ShortInt;
     typeList: ^SFTypeList;
     reply: ^SFReply;
     
  enter (where,prompt,fileFilter,numTypes,typeList[],dlghook,reply[])
  do '{$3F3C,$0002,$A9EA} '->PascalTrap; 
  #);
SFPGetfile: External
  (# where,fileFilter,dlgHook,filterProc: @Integer;
     prompt: [1] @Char;
     numTypes,dlgId: @ShortInt;
     typeList: ^SFTypeList;
     reply: ^SFReply;
     
  enter (where,prompt,fileFilter,numTypes,typeList[],dlghook,reply[],dlgId,filterProc)
  do '{$3F3C,$0004,$A9EA} '->PascalTrap; 
  #);
SFPutfile: External
  (# where,dlgHook: @Integer; prompt,origName: [1] @Char; reply: ^SFReply; 
  enter (where,prompt,origName,dlghook,reply[])
  do '{$3F3C,$0001,$A9EA} '->PascalTrap; 
  #);
SFPPutfile: External
  (# where,dlgHook,filterProc: @Integer;
     prompt,origName: [1] @Char;
     reply: ^SFReply;
     dlgId: @ShortInt;
     
  enter (where,prompt,origName,dlghook,reply[],dlgId,filterProc)
  do '{$3F3C,$0003,$A9EA} '->PascalTrap; 
  #);
CustomGetFile: External
  (# fileFilter,where,activateProc,callBackPtr: @Integer;
     numTypes,dlgID: @ShortInt;
     typeList: ^SFTypeList;
     reply: ^CStruct;
     
  enter (fileFilter,numTypes,typeList[],reply[],dlgID,where,activateProc,callBackPtr)
  do '{$3F3C,$0008,$A9EA}'->PascalTrap; 
  #);
CustomPutFile: External
  (# promp,defaultName: [1] @Char;
     reply: ^CStruct;
     dlgID: @ShortInt;
     where,dlgHook,filterProc,activeList,activateProc,callBackPtr: @Integer;
     
  enter
  (promp,defaultName,reply[],dlgID,where,dlgHook,filterProc,activeList,activateProc,callBackPtr)
  do '{$3F3C,$0007,$A9EA}'->PascalTrap; 
  #);
StandardGetFile: External
  (# fileFilter: @Integer; numTypes: @ShortInt; typeList: ^SFTypeList; reply: ^CStruct; 
  enter (fileFilter,numTypes,typeList[],reply[])
  do '{$3F3C,$0006,$A9EA}'->PascalTrap; 
  #);
StandardPutFile: External
  (# promp,defaultName: [1] @Char; reply: ^CStruct; 
  enter (promp,defaultName,reply[])
  do '{$3F3C,$0005,$A9EA}'->PascalTrap; 
  #);
  

sysPatListID: (# exit 0 #);
iBeamCursor: (# exit 1 #);
crossCursor: (# exit 2 #);
plusCursor: (# exit 3 #);
watchCursor: (# exit 4 #);
GetPicture: External
  (# picID: @ShortInt; handle: @Integer;  enter picID do '$A9BC'->PascalTrap;  exit handle #);
BitTst: External
  (# bytePtr,bitNum: @Integer; result: @Boolean; 
  enter (bytePtr,bitNum)
  do '$A85D'->PascalTrap; 
  exit result
  #);
BitSet: External
  (# bytePtr,bitNum: @Integer;  enter (bytePtr,bitNum) do '$A85E'->PascalTrap;  #);
BitClr: External
  (# bytePtr,bitNum: @Integer;  enter (bytePtr,bitNum) do '$A85F'->PascalTrap;  #);
BitAnd: External
  (# value1,value2,result: @Integer; 
  enter (value1,value2)
  do '$A858'->PascalTrap; 
  exit result
  #);
BitOr: External
  (# value1,value2,result: @Integer; 
  enter (value1,value2)
  do '$A85B'->PascalTrap; 
  exit result
  #);
BitXor: External
  (# value1,value2,result: @Integer; 
  enter (value1,value2)
  do '$A859'->PascalTrap; 
  exit result
  #);
BitNot: External
  (# value,result: @Integer;  enter value do '$A85A'->PascalTrap;  exit result #);
BitShift: External
  (# value,result: @Integer; count: @ShortInt; 
  enter (value,count)
  do '$A85C'->PascalTrap; 
  exit result
  #);
HiWord: External
  (# x: @Integer; result: @ShortInt enter x do '$A86A'->PascalTrap;  exit result #);
LoWord: External
  (# x: @Integer; result: @ShortInt;  enter x do '$A86B'->PascalTrap;  exit result #);
GetIcon: External
  (# iconID: @ShortInt; hndl: @Integer;  enter iconId do '$A9BB'->PascalTrap;  exit hndl #);
PlotIcon: External
  (# theRect: ^QRect; theIcon: @Integer; 
  enter (theRect[],theIcon)
  do '$A94B'->PascalTrap; 
  #);
GetPattern: External
  (# patID: @ShortInt; hndl: @Integer;  enter patId do '$A9B8'->PascalTrap;  exit hndl #);
GetCursor: External
  (# cursorID: @ShortInt; hndl: @Integer; 
  enter cursorId
  do '$A9B9'->PascalTrap; 
  exit hndl
  #);
GetString: External
  (# stringID: @ShortInt; stringhndl: @Integer; 
  enter stringId
  do '$A9BA'->PascalTrap; 
  exit stringhndl
  #);
NewString: External
  (# theString: [1] @Char; stringhndl: @Integer; 
  enter theString
  do '$A906'->PascalTrap; 
  exit stringhndl
  #);
ScreenRes: External
  (# screenHres,screenVres: ^shortRef;  enter (screenHRes[],screenVRes[]) do callpascal #);
GetIinPattern: External
  (# thePat: ^LongInt; patListID,index: @ShortInt; 
  enter (thePat[],patListId,index)
  do callpascal
  #);
AngleFromSlope: External
  (# slope: @Integer; angle: @ShortInt;  enter slope do '$A8C4'->PascalTrap;  exit angle #);
DeltaPoint: External
  (# ptA,ptB,result: @Integer;  enter (ptA,ptB) do '$A94F'->PascalTrap;  exit result #);
Munger: External
  (# h,offset,ptr1,len1,ptr2,len2,result: @Integer; 
  enter (h,offset,ptr1,len1,ptr2,len2)
  do '$A9E0'->PascalTrap; 
  exit result
  #);
PackBits: External
  (# srcPtr,dstPtr: ^LongInt; srcBytes: @ShortInt; 
  enter (srcPtr[],dstPtr[],srcBytes)
  do '$A8CF'->PascalTrap; 
  #);
SetString: External
  (# theString: @Integer; strNew: [1] @Char; 
  enter (theString,strNew)
  do '$A907'->PascalTrap; 
  #);
ShieldCursor: External
  (# shieldRect: ^QRect; offsetPt: @Integer; 
  enter (shieldRect[],offsetPt)
  do '$A855'->PascalTrap; 
  #);
SlopeFromAngle: External
  (# angle: @ShortInt; slope: @Integer;  enter angle do '$A8BC'->PascalTrap;  exit slope #);
UnpackBits: External
  (# srcPtr,dstPtr: ^LongInt; srcBytes: @ShortInt; 
  enter (srcPtr[],dstPtr[],srcBytes)
  do '$A8D0'->PascalTrap; 
  #);
GetIndPattern: external
  (# thePat: @Integer; patListID,index: @shortInt enter (thePat,patListId,index) do pascal #);
  

(*
 * Not complete
 *)
 
 
truncEnd: 		(# exit 0 #);
truncMiddle: 	(# exit 0x4000 #);

Truncated: 		(# exit 1 #);
NotTruncated: 	(# exit 0 #);
TruncErr: 		(# exit -1 #);
resNotFound: 	(# exit -192 #);


TruncString: External
	(# width: @shortint;
		string: ^PascalString;
		truncWhere: @shortInt;
		err: @shortInt;
	enter (width, string[], truncWhere)
	do '{$2F3C, $8208, $FFE0, $A8B5}' -> pascalTrap;
	exit err
	#);



formName: (# exit 1851878757 #);
formAbsolutePosition: (# exit 1768842360 #);
formPropertyID: (# exit 1886547824 #);
typeObjectSpecifier: (# exit 1868720672 #);
AEObjectInit: External (# OSErr: @ShortInt;  do CallPascal;  exit OSErr #);
  

kAEClose: (* 'clos' *) (# exit 1668050803 #);
kAECoreSuite: (* 'core' *) (# exit 1668248165 #);
kAEGetData: (* 'getd' *) (# exit 1734702180 #);
kAESetData: (* 'setd' *) (# exit 1936028772 #);
keyAEResult: (* '----' *) (# exit 757935405 #);
keyAEData: (* 'data' *) (# exit 1684108385 #);
keyAERequestedType: (* 'rtyp' *) (# exit 1920235888 #);
cDocument: (* 'docu' *) (# exit 1685021557 #);
cCell: (* 'ccel' *) (# exit 1667458412 #);
cProperty: (* 'prop' *) (# exit 1886547824 #);
pFormula: (* 'pfor' *) (# exit 1885761394 #);
pSelection: (* 'sele' *) (# exit 1936026725 #);
pName: (* 'pnam' *) (# exit 1886282093 #);
pIsModified: (* 'imod' *) (# exit 1768779620 #);
pProtection: (* 'ppro' *) (# exit 1886417519 #);
pFont: (* 'font' *) (# exit 1718578804 #);
pColor: (* 'colr' *) (# exit 1668246642 #);
pTextStyles: (* 'txst' *) (# exit 1954050932 #);
typeRGBColor: (* 'RGB ' *) (# exit 1380401696 #);
typeTextStyles: (* 'tsty' *) (# exit 1953723513 #);
typeBWPattern: (* 'bwpt' *) (# exit 1651994740 #);
  


NewAliasMinimalFromFullPath: external
	(#	fullPathLength: @shortInt;
		fullPath: @integer;
		zoneName: [1] @char;
		serverName: [1] @char;
		alias: ^longInt;
		error: @shortInt;
	enter (fullPathLength, fullPath, zoneName, serverName, alias[])
	do '{$7009,$A823}' -> pascalTrap;
	exit error
	#);


(**)
(* Appearance Manager constants, etc.												*)
(**)


																(* Appearance Trap Number *)
_AppearanceDispatch: (# exit 0xAA74 #);


(* Gestalt selector and values for the Appearance Manager *)


gestaltAppearanceAttr: (# exit 0x61707072 #);
gestaltAppearanceExists: (# exit 0 #);
gestaltAppearanceCompatMode: (# exit 1 #);


(* Appearance Manager Error Codes *)


appearanceBadBrushIndexErr: (# exit 0 #);						(* pattern index invalid *)
appearanceProcessRegisteredErr: (# exit -30561 #);
appearanceProcessNotRegisteredErr: (# exit -30562 #);
appearanceBadTextColorIndexErr: (# exit -30563 #);




kThemeActiveDialogBackgroundBrush: (# exit 1 #);						(* Dialogs *)
kThemeInactiveDialogBackgroundBrush: (# exit 2 #);					(* Dialogs *)
kThemeActiveAlertBackgroundBrush: (# exit 3 #);
kThemeInactiveAlertBackgroundBrush: (# exit 4 #);
kThemeActiveModelessDialogBackgroundBrush: (# exit 5 #);
kThemeInactiveModelessDialogBackgroundBrush: (# exit 6 #);
kThemeActiveUtilityWindowBackgroundBrush: (# exit 7 #);				(* Miscellaneous *)
kThemeInactiveUtilityWindowBackgroundBrush: (# exit 8 #);				(* Miscellaneous *)
kThemeListViewSortColumnBackgroundBrush: (# exit 9 #);				(* Finder *)
kThemeListViewBackgroundBrush: (# exit 10 #);
kThemeIconLabelBackgroundBrush: (# exit 11 #);
kThemeListViewSeparatorBrush: (# exit 12 #);
kThemeChasingArrowsBrush: (# exit 13 #);
kThemeDragHiliteBrush: (# exit 14 #);
kThemeDocumentWindowBackgroundBrush: (# exit 15 #);
kThemeFinderWindowBackgroundBrush: (# exit 16 #);


(* typedef SInt16 							ThemeBrush;*)


kThemeActiveDialogTextColor: (# exit 1 #);							(* Dialogs *)
kThemeInactiveDialogTextColor: (# exit 2 #);
kThemeActiveAlertTextColor: (# exit 3 #);
kThemeInactiveAlertTextColor: (# exit 4 #);
kThemeActiveModelessDialogTextColor: (# exit 5 #);
kThemeInactiveModelessDialogTextColor: (# exit 6 #);
kThemeActiveWindowHeaderTextColor: (# exit 7 #);						(* Primitives *)
kThemeInactiveWindowHeaderTextColor: (# exit 8 #);
kThemeActivePlacardTextColor: (# exit 9 #);							(* Primitives *)
kThemeInactivePlacardTextColor: (# exit 10 #);
kThemePressedPlacardTextColor: (# exit 11 #);
kThemeActivePushButtonTextColor: (# exit 12 #);						(* Primitives *)
kThemeInactivePushButtonTextColor: (# exit 13 #);
kThemePressedPushButtonTextColor: (# exit 14 #);
kThemeActiveBevelButtonTextColor: (# exit 15 #);						(* Primitives *)
kThemeInactiveBevelButtonTextColor: (# exit 16 #);
kThemePressedBevelButtonTextColor: (# exit 17 #);
kThemeActivePopupButtonTextColor: (# exit 18 #);						(* Primitives *)
kThemeInactivePopupButtonTextColor: (# exit 19 #);
kThemePressedPopupButtonTextColor: (# exit 20 #);
kThemeIconLabelTextColor: (# exit 21 #);							(* Finder *)
kThemeListViewTextColor: (# exit 22 #);


(* typedef SInt16 							ThemeTextColor;*)
(* States to draw primitives: disabled, active, and pressed (hilited) *)


kThemeStateDisabled: (# exit 0 #);
kThemeStateActive: (# exit 1 #);
kThemeStatePressed: (# exit 2 #);


(* typedef UInt32 							ThemeDrawState;*)
(**)
(* Window Manager constants, etc.													*)
(**)


																(* Resource IDs for new window defprocs *)
kWindowDocumentDefProcResID: (# exit 64 #);
kWindowDialogDefProcResID: (# exit 65 #);
kWindowUtilityDefProcResID: (# exit 66 #);
kWindowUtilitySideTitleDefProcResID: (# exit 67 #);




																(* Proc IDs for theme-savvy windows *)
kWindowDocumentProc: (# exit 1024 #);
kWindowGrowDocumentProc: (# exit 1025 #);
kWindowHorizZoomDocumentProc: (# exit 1026 #);
kWindowHorizZoomGrowDocumentProc: (# exit 1027 #);
kWindowVertZoomDocumentProc: (# exit 1028 #);
kWindowVertZoomGrowDocumentProc: (# exit 1029 #);
kWindowFullZoomDocumentProc: (# exit 1030 #);
kWindowFullZoomGrowDocumentProc: (# exit 1031 #);




																(* Proc IDs for theme-savvy dialogs *)
kWindowPlainDialogProc: (# exit 1040 #);
kWindowShadowDialogProc: (# exit 1041 #);
kWindowModalDialogProc: (# exit 1042 #);
kWindowMovableModalDialogProc: (# exit 1043 #);
kWindowAlertProc: (# exit 1044 #);
kWindowMovableAlertProc: (# exit 1045 #);




																(* Proc IDs for top title bar theme-savvy floating windows *)
kWindowFloatProc: (# exit 1057 #);
kWindowFloatGrowProc: (# exit 1059 #);
kWindowFloatHorizZoomProc: (# exit 1061 #);
kWindowFloatHorizZoomGrowProc: (# exit 1063 #);
kWindowFloatVertZoomProc: (# exit 1065 #);
kWindowFloatVertZoomGrowProc: (# exit 1067 #);
kWindowFloatFullZoomProc: (# exit 1069 #);
kWindowFloatFullZoomGrowProc: (# exit 1071 #);




																(* Proc IDs for side title bar theme-savvy floating windows *)
kWindowFloatSideProc: (# exit 1073 #);
kWindowFloatSideGrowProc: (# exit 1075 #);
kWindowFloatSideHorizZoomProc: (# exit 1077 #);
kWindowFloatSideHorizZoomGrowProc: (# exit 1079 #);
kWindowFloatSideVertZoomProc: (# exit 1081 #);
kWindowFloatSideVertZoomGrowProc: (# exit 1083 #);
kWindowFloatSideFullZoomProc: (# exit 1085 #);
kWindowFloatSideFullZoomGrowProc: (# exit 1087 #);




																(* Region values to pass into GetWindowRegion *)
kWindowTitleBarRgn: (# exit 0 #);
kWindowTitleTextRgn: (# exit 1 #);
kWindowCloseBoxRgn: (# exit 2 #);
kWindowZoomBoxRgn: (# exit 3 #);
kWindowDragRgn: (# exit 5 #);
kWindowGrowRgn: (# exit 6 #);
kWindowCollapseBoxRgn: (# exit 7 #);
kWindowStructureRgn: (# exit 32 #);
kWindowContentRgn: (# exit 33 #);


(* typedef UInt16 							WindowRegionCode;*)


																(* Window Features returned by GetWindowFeatures *)
																
kWindowCanGrow: (# exit (1 %sll 0) #);
kWindowCanZoom: (# exit (1 %sll 1) #);
kWindowCanCollapse: (# exit (1 %sll 2) #);
kWindowIsModal: (# exit (1 %sll 3) #);
kWindowCanGetWindowRegion: (# exit (1 %sll 4) #);
kWindowIsAlert: (# exit (1 %sll 5) #);
kWindowHasTitleBar: (# exit (1 %sll 6) #);




																(* New window messages *)
kWindowMsgGetFeatures: (# exit 7 #);
kWindowMsgGetRegion: (# exit 8 #);




																(* New Window part codes *)
inCollapseBox: (# exit 11 #);




																(* Window Definition hit test result codes ("WindowPart")*)
wInCollapseBox: (# exit 9 #);


(* Window positioning constants *)


kWindowDefaultPosition: (# exit 0x0000 #);
kWindowCenterMainScreen: (# exit 0x280A #);
kWindowAlertPositionMainScreen: (# exit 0x300A #);
kWindowStaggerMainScreen: (# exit 0x380A #);
kWindowCenterParentWindow: (# exit 0xA80A #);
kWindowAlertPositionParentWindow: (# exit 0xB00A #);
kWindowStaggerParentWindow: (# exit 0xB80A #);
kWindowCenterParentWindowScreen: (# exit 0x680A #);
kWindowAlertPositionParentWindowScreen: (# exit 0x700A #);
kWindowStaggerParentWindowScreen: (# exit 0x780A #);


(* GetWindowRegionRec - used for WDEF calls with kWindowMsgGetRegion *)
(*
struct GetWindowRegionRec {
	RgnHandle 						winRgn;
	WindowRegionCode 				regionCode;
};
*)

(* typedef struct GetWindowRegionRec GetWindowRegionRec;

typedef GetWindowRegionRec *			GetWindowRegionPtr;
*)
(**)
(* Dialog Manager constants, etc.													*)
(**)


																(* Alert types to pass into StandardAlert *)
kAlertStopAlert: (# exit 0 #);
kAlertNoteAlert: (# exit 1 #);
kAlertCautionAlert: (# exit 2 #);
kAlertPlainAlert: (# exit 3 #);


(* typedef SInt16 							AlertType;*)


kAlertDefaultOKText: (# exit -1 #);							(* "OK"*)
kAlertDefaultCancelText: (# exit -1 #);							(* "Cancel"*)
kAlertDefaultOtherText: (# exit -1 #);					(* "Don't Save"*)


(* StandardAlert alert button numbers *)


kAlertStdAlertOKButton: (# exit 1 #);
kAlertStdAlertCancelButton: (# exit 2 #);
kAlertStdAlertOtherButton: (# exit 3 #);
kAlertStdAlertHelpButton: (# exit 4 #);




																(* Dialog Flags for use in NewFeaturesDialog or dlgx resource *)
kDialogFlagsUseThemeBackground: (# exit (1 %sll 0) #);
kDialogFlagsUseControlHierarchy: (# exit (1 %sll 1) #);
kDialogFlagsHandleMovableModal: (# exit (1 %sll 2) #);
kDialogFlagsUseThemeControls: (# exit (1 %sll 3) #);




																(* Alert Flags for use in alrx resource *)
kAlertFlagsUseThemeBackground: (# exit (1 %sll 0) #);
kAlertFlagsUseControlHierarchy: (# exit (1 %sll 1) #);
kAlertFlagsAlertIsMovable: (# exit (1 %sll 2) #);
kAlertFlagsUseThemeControls: (# exit (1 %sll 3) #);


(* For dftb resource *)


kDialogFontNoFontStyle: (# exit 0 #);
kDialogFontUseFontMask: (# exit 0x0001 #);
kDialogFontUseFaceMask: (# exit 0x0002 #);
kDialogFontUseSizeMask: (# exit 0x0004 #);
kDialogFontUseForeColorMask: (# exit 0x0008 #);
kDialogFontUseBackColorMask: (# exit 0x0010 #);
kDialogFontUseModeMask: (# exit 0x0020 #);
kDialogFontUseJustMask: (# exit 0x0040 #);
kDialogFontUseAllMask: (# exit 0x00FF #);
kDialogFontAddFontSizeMask: (# exit 0x0100 #);
kDialogFontUseFontMaskMask: (# exit 0x0200 #);


(*
struct AlertStdAlertParamRec {
	Boolean 						movable;					(* Make alert movable modal *}
	Boolean 						helpButton;					(* Is there a help button? *}
	ModalFilterUPP 					filterProc;					(* Event filter *}
	StringPtr 						defaultText;				(* Text for button in OK position *}
	StringPtr 						cancelText;					(* Text for button in cancel position *}
	StringPtr 						otherText;					(* Text for button in left position *}
	SInt16 							defaultButton;				(* Which button behaves as the default *}
	SInt16 							cancelButton;				(* Which one behaves as cancel (can be 0) *}
	UInt16 							position;					(* Position (kWindowDefaultPosition in this case *}
																(* equals kWindowAlertPositionParentWindowScreen) *}
};
*)

(* typedef struct AlertStdAlertParamRec AlertStdAlertParamRec; *)

(*typedef AlertStdAlertParamRec *			AlertStdAlertParamPtr;*)

(**)
(* Control Manager constants, etc.													*)
(**)


_ControlDispatch: (# exit 0xAA73 #);




																(* resource types for new controls *)
kControlTabListResType: (# exit 0x74616223 #);		(* used for tab control only*)
kControlListDescResType: (# exit 0x6C646573 #);		(* used for list box control only*)




																(* new part codes for new controls *)
kControlEditTextPart: (# exit 5 #);
kControlPicturePart: (# exit 6 #);
kControlIconPart: (# exit 7 #);
kControlClockPart: (# exit 8 #);
kControlListBoxPart: (# exit 24 #);
kControlListBoxDoubleClickPart: (# exit 25 #);




kControlSupportsNewMessages: (# exit 0x206F6B20 #);		(* CDEF should return as result of kControlMsgTestNewMsgSupport*)


(* focusing part codes *)


kControlFocusNoPart: (# exit 0 #);							(* tells control to clear its focus*)
kControlFocusNextPart: (# exit -1 #);							(* tells control to focus on the next part*)
kControlFocusPrevPart: (# exit -2 #);					(* tells control to focus on the previous part*)


(*typedef SInt16 							ControlFocusPart;*)
(* Key Filter result codes 															*)
(*																					*)
(* Certain controls can have a keyfilter attached to them. The filter proc should	*)
(* return one of the two constants below. If kKeyFilterBlockKey is returned, the	*)
(* key is blocked and never makes it to the control. If kKeyFilterPassKey is		*)
(* returned, the control receives the keystroke.									*)


kControlKeyFilterBlockKey: (# exit 0 #);
kControlKeyFilterPassKey: (# exit 1 #);


(* typedef SInt16 							ControlKeyFilterResult; *)
(**)
(* 	SPECIAL FONT USAGE NOTES: You can specify the font to use for many control types.
	The constants below are meta-font numbers which you can use to set a particular
	control's font usage. There are essentially two modes you can use: 1) default,
	which is essentially the same as it always has been, i.e. it uses the system font, unless
	directed to use the window font via a control variant. 2) you can specify to use
	the big or small system font in a generic manner. The Big system font is the font
	used in menus, etc. Chicago has filled that role for some time now. Small system
	font is currently Geneva 10. The meta-font number implies the size and style.
	
	NOTE:		Not all font attributes are used by all controls. Most, in fact, ignore
				the fore and back color (Static Text is the only one that does, for
				backwards compatibility). Also size, face, and addFontSize are ignored
				when using the meta-font numbering.
*)
(**)


																(* Meta-font numbering - see not above *)
kControlFontBigSystemFont: (# exit -1 #);							(* force to big system font*)
kControlFontSmallSystemFont: (# exit -2 #);							(* force to small system font*)
kControlFontSmallBoldSystemFont: (# exit -3 #);				(* force to small bold system font*)


(* Add these masks together to set the flags field of a ControlFontStyleRec	*)
(* They specify which fields to apply to the text. It is important to make	*)
(* sure that you specify only the fields that you wish to set.				*)


kControlUseFontMask: (# exit 0x0001 #);
kControlUseFaceMask: (# exit 0x0002 #);
kControlUseSizeMask: (# exit 0x0004 #);
kControlUseForeColorMask: (# exit 0x0008 #);
kControlUseBackColorMask: (# exit 0x0010 #);
kControlUseModeMask: (# exit 0x0020 #);
kControlUseJustMask: (# exit 0x0040 #);
kControlUseAllMask: (# exit 0x00FF #);
kControlAddFontSizeMask: (# exit 0x0100 #);


(*
struct ControlFontStyleRec {
	SInt16 							flags;
	SInt16 							font;
	SInt16 							size;
	SInt16 							style;
	SInt16 							mode;
	SInt16 							just;
	RGBColor 						foreColor;
	RGBColor 						backColor;
};

typedef struct ControlFontStyleRec ControlFontStyleRec;

typedef ControlFontStyleRec *			ControlFontStylePtr;
*)

(**)
(* Common data tags for Get/SetControlData												*)
(**)


kControlFontStyleTag: (# exit 0x666F6E74 #);
kControlKeyFilterTag: (# exit 0x666C7472 #);


(**)
(* Errors are in the range -30580 .. -30599												*)
(**)


errMessageNotSupported: (# exit -30580 #);
errDataNotSupported: (# exit -30581 #);
errControlDoesntSupportFocus: (# exit -30582 #);
errWindowDoesntSupportFocus: (# exit -30583 #);
errUnknownControl: (# exit -30584 #);
errCouldntSetFocus: (# exit -30585 #);
errNoRootControl: (# exit -30586 #);
errRootAlreadyExists: (# exit -30587 #);
errInvalidPartCode: (# exit -30588 #);
errControlsAlreadyExist: (# exit -30589 #);
errControlIsNotEmbedder: (# exit -30590 #);
errDataSizeMismatch: (# exit -30591 #);
errControlHiddenOrDisabled: (# exit -30592 #);
errWindowRegionCodeInvalid: (# exit -30593 #);
errCantEmbedIntoSelf: (# exit -30594 #);
errCantEmbedRoot: (# exit -30595 #);
errItemNotControl: (# exit -30596 #);




																(* Control feature bits - returned by GetControlFeatures *)
kControlSupportsGhosting: (# exit 1 %sll 0 #);
kControlSupportsEmbedding: (# exit 1 %sll 1 #);
kControlSupportsFocus: (# exit 1 %sll 2 #);
kControlWantsIdle: (# exit 1 %sll 3 #);
kControlWantsActivate: (# exit 1 %sll 4 #);
kControlHandlesTracking: (# exit 1 %sll 5 #);
kControlSupportsDataAccess: (# exit 1 %sll 6 #);
kControlHasSpecialBackground: (# exit 1 %sll 7 #);
kControlGetsFocusOnClick: (# exit 1 %sll 8 #);
kControlSupportsCalcBestRect: (# exit 1 %sll 9 #);
kControlSupportsLiveFeedback: (# exit 1 %sll 10 #);




																(* Control Messages *)
kControlMsgDrawGhost: (# exit 13 #);
kControlMsgCalcBestRect: (# exit 14 #);							(* Calculate best fitting rectangle for control*)
kControlMsgHandleTracking: (# exit 15 #);
kControlMsgFocus: (# exit 16 #);							(* param indicates action.*)
kControlMsgKeyDown: (# exit 17 #);
kControlMsgIdle: (# exit 18 #);
kControlMsgGetFeatures: (# exit 19 #);
kControlMsgSetData: (# exit 20 #);
kControlMsgGetData: (# exit 21 #);
kControlMsgActivate: (# exit 22 #);
kControlMsgSetUpBackground: (# exit 23 #);
kControlMsgCalcValue: (# exit 24 #);
kControlMsgSubControlHit: (# exit 25 #);
kControlMsgCalcValueFromPos: (# exit 26 #);
kControlMsgTestNewMsgSupport: (# exit 27 #);					(* See if this control supports new messaging*)


(**)
(* 	This structure is passed into a CDEF when called with the kControlMsgHandleTracking	*)
(*	message 																			*)
(**)
(*
struct ControlTrackingRec {
	Point 							startPt;
	SInt16 							modifiers;
	ControlActionUPP 				action;
};

typedef struct ControlTrackingRec ControlTrackingRec;

typedef ControlTrackingRec *			ControlTrackingPtr;

*)
(**)
(* This structure is passed into a CDEF when called with the kControlMsgKeyDown message *)
(**)
(*
struct ControlKeyDownRec {
	SInt16 							modifiers;
	SInt16 							keyCode;
	SInt16 							charCode;
};

typedef struct ControlKeyDownRec ControlKeyDownRec;

typedef ControlKeyDownRec *				ControlKeyDownPtr;
*)

(**)
(* This structure is passed into a CDEF when called with the kControlMsgGetData or		*)
(* kControlMsgSetData message 															*)
(**)
(*
struct ControlDataAccessRec {
	ResType 						tag;
	ResType 						part;
	Size 							size;
	Ptr 							dataPtr;
};

typedef struct ControlDataAccessRec ControlDataAccessRec;

typedef ControlDataAccessRec *			ControlDataAccessPtr;
*)

(**)
(* This structure is passed into a CDEF when called with the kControlCalcBestRect msg 	*)
(**)
(*
struct ControlCalcSizeRec {
	SInt16 							height;
	SInt16 							width;
	SInt16 							baseLine;
};

typedef struct ControlCalcSizeRec ControlCalcSizeRec;

typedef ControlCalcSizeRec *			ControlCalcSizePtr;
*)

(**)
(* This structure is passed into a CDEF when called with the kControlMsgSetUpBackground *)
(* message is sent																		*)
(**)
(*
struct ControlBackgroundRec {
	SInt16 							depth;
	Boolean 						colorDevice;
};

typedef struct ControlBackgroundRec ControlBackgroundRec;

typedef ControlBackgroundRec *			ControlBackgroundPtr;
*)

(**)
(*	Key Filter																			*)
(*																						*)
(* Definition of a key filter for intercepting and possibly changing keystrokes			*)
(* which are destined for a control														*)
(**)
(**)
(*	 BEVEL BUTTON INTERFACE (CDEF 2)													*)
(**)
(*	Bevel buttons allow you to control the content type (pict/icon/etc.), the behavior	*)
(* (pushbutton/toggle/sticky), and the bevel size. You also have the option of			*)
(*	attaching a menu to it. When a menu is present, you can specify which way the 		*)
(*	popup arrow is facing (down or right).												*)
(*																						*)
(*	This is all made possible by overloading the Min, Max, and Value parameters for the	*)
(*	control, as well as adjusting the variant. Here's the breakdown of what goes where:	*)
(*																						*)
(*	Parameter					What Goes Here											*)
(*					*)
(*	Min							Hi Byte = Behavior, Lo Byte = content type.				*)
(*	Max							ResID for resource-based content types.					*)
(*	Value						MenuID to attach, 0 = no menu, please.					*)
(*																						*)
(*	The variant is broken down into two halfs. The low 2 bits control the bevel type.	*)
(*	Bit 2 controls the popup arrow direction (if a menu is present) and bit 3 controls	*)
(*	whether or not to use the control's owning window's font.							*)
(*																						*)
(*	Constants for all you need to put this together are below. The values for behaviors	*)
(*	are set up so that you can simply add them to the content type and pass them into	*)
(*	the Min parameter of NewControl.													*)
(*																						*)
(*	An example call:																	*)
(*																						*)
(*	control = NewControl( window, &bounds, "\p", true, 0, kContentIconSuiteRes + 		*)
(*							kBehaviorToggles, myIconSuiteID, bevelButtonSmallBevelProc,	*)
(*							0L );														*)
(*																						*)
(*	Attaching a menu:																	*)
(*																						*)
(*	control = NewControl( window, &bounds, "\p", true, kMyMenuID, kContentIconSuiteRes,	*)
(*			myIconSuiteID, bevelButtonSmallBevelProc + kBevelButtonMenuOnRight, 0L );	*)
(*																						*)
(*	This will attach menu ID kMyMenuID to the button, with the popup arrow facing right.*)
(*	This also puts the menu up to the right of the button. You can also specify that a	*)
(*	menu can have multiple items checked at once by adding kBehaviorMultiValueMenus		*)
(*	into the Min parameter. If you do use multivalue menus, the GetBevelButtonMenuValue	*)
(*	helper function will return the last item chosen from the menu, whether or not it	*)
(*	was checked.																		*)
(*																						*)
(*	NOTE: 	Bevel buttons with menus actually have *two* values. The value of the 		*)
(*			button (on/off), and the value of the menu. The menu value can be gotten	*)
(*			with the GetBevelButtonMenuValue helper function.							*)
(*																						*)
(*	Handle-based Content																*)
(*																	*)
(*	You can create your control and then set the content to an existing handle to an	*)
(*	icon suite, etc. using the macros below. Please keep in mind that resource-based	*)
(*	content is owned by the control, handle-based content is owned by you. The CDEF will*)
(*	not try to dispose of handle-based content. If you are changing the content type of	*)
(*	the button on the fly, you must make sure that if you are replacing a handle-		*)
(*	based content with a resource-based content to properly dispose of the handle,		*)
(*	else a memory leak will ensue.														*)
(*																						*)


																(* Bevel Button Proc IDs *)
kControlBevelButtonSmallBevelProc: (# exit 32 #);
kControlBevelButtonNormalBevelProc: (# exit 33 #);
kControlBevelButtonLargeBevelProc: (# exit 34 #);




																(* Bevel button graphic alignment values *)
kControlBevelButtonAlignSysDirection: (# exit -1 #);					(* only left or right*)
kControlBevelButtonAlignCenter: (# exit 0 #);
kControlBevelButtonAlignLeft: (# exit 1 #);
kControlBevelButtonAlignRight: (# exit 2 #);
kControlBevelButtonAlignTop: (# exit 3 #);
kControlBevelButtonAlignBottom: (# exit 4 #);
kControlBevelButtonAlignTopLeft: (# exit 5 #);
kControlBevelButtonAlignBottomLeft: (# exit 6 #);
kControlBevelButtonAlignTopRight: (# exit 7 #);
kControlBevelButtonAlignBottomRight: (# exit 8 #);


(* typedef SInt16 							ControlButtonGraphicAlignment;*)


																(* Bevel button text alignment values *)
kControlBevelButtonAlignTextSysDirection: (# exit teFlushDefault #);
kControlBevelButtonAlignTextCenter: (# exit teCenter #);
kControlBevelButtonAlignTextFlushRight: (# exit teFlushRight #);
kControlBevelButtonAlignTextFlushLeft: (# exit teFlushLeft #);


(* typedef SInt16 							ControlButtonTextAlignment;*)


																(* Bevel button text placement values *)
kControlBevelButtonPlaceSysDirection: (# exit -1 #);					(* if graphic on right, then on left*)
kControlBevelButtonPlaceNormally: (# exit 0 #);
kControlBevelButtonPlaceToRightOfGraphic: (# exit 1 #);
kControlBevelButtonPlaceToLeftOfGraphic: (# exit 2 #);
kControlBevelButtonPlaceBelowGraphic: (# exit 3 #);
kControlBevelButtonPlaceAboveGraphic: (# exit 4 #);


(* typedef SInt16 							ControlButtonTextPlacement;*)
(* Add these variant codes to kBevelButtonSmallBevelProc to change the type of button *)


kControlBevelButtonSmallBevelVariant: (# exit 0 #);
kControlBevelButtonNormalBevelVariant: (# exit (1 %sll 0) #);
kControlBevelButtonLargeBevelVariant: (# exit (1 %sll 1) #);
kControlBevelButtonMenuOnRight: (# exit (1 %sll 2) #);


(*
   Behaviors of bevel buttons. These are set up so you can add
   them together with the content types.
*)


kControlBehaviorPushbutton: (# exit 0 #);
kControlBehaviorToggles: (# exit 0x0100 #);
kControlBehaviorSticky: (# exit 0x0200 #);
kControlBehaviorMultiValueMenu: (# exit 0x4000 #);					(* only makes sense when a menu is attached.*)
kControlBehaviorOffsetContents: (# exit 0x8000 #);


(* Content types supported by bevel buttons *and* image wells*)


kControlContentTextOnly: (# exit 0 #);
kControlContentIconSuiteRes: (# exit 1 #);
kControlContentCIconRes: (# exit 2 #);
kControlContentPictRes: (# exit 3 #);
kControlContentIconSuiteHandle: (# exit 129 #);
kControlContentCIconHandle: (# exit 130 #);
kControlContentPictHandle: (# exit 131 #);
kControlContentIconRef: (# exit 132 #);


(*typedef SInt16 							ControlContentType;*)
(* Data tags supported by the bevel button controls *)


kControlBevelButtonContentTag: (# exit 0x636F6E74 #);		(* ButtonContentInfo*)
kControlBevelButtonTransformTag: (# exit 0x7472616E #);	(* IconTransformType*)
kControlBevelButtonTextAlignTag: (# exit 0x74616C69 #);	(* ButtonTextAlignment*)
kControlBevelButtonTextOffsetTag: (# exit 0x746F6666 #);	(* SInt16*)
kControlBevelButtonGraphicAlignTag: (# exit 0x67616C69 #); (* ButtonGraphicAlignment*)
kControlBevelButtonGraphicOffsetTag: (# exit 0x676F6666 #); (* Point*)
kControlBevelButtonTextPlaceTag: (# exit 0x74706C63 #);	(* ButtonTextPlacement*)
kControlBevelButtonMenuValueTag: (# exit 0x6D76616C #);	(* SInt16*)
kControlBevelButtonMenuHandleTag: (# exit 0x6D686E64 #);	(* MenuHandle*)


(* Structure to pass into bevel buttons and image wells to set/get content type *)
(*
struct ControlButtonContentInfo {
	ControlContentType 				contentType;
	union {
		SInt16 							resID;
		CIconHandle 					cIconHandle;
		Handle 							iconSuite;
		Handle 							iconRef;
		PicHandle 						picture;
	} 								u;
};

typedef struct ControlButtonContentInfo ControlButtonContentInfo;

typedef ControlButtonContentInfo *		ControlButtonContentInfoPtr;
*)

(**)
(*	 SLIDER (CDEF 3)																	*)
(**)
(*	There are several variants that control the behavior of the slider control. Any		*)
(*	combination of the following three constants can be added to the basic CDEF ID		*)
(*	(kSliderProc).																		*)
(*																						*)
(*	Variants:																			*)
(*																						*)
(*		kSliderLiveFeedback	 	Slider does not use "ghosted" indicator when tracking.	*)
(*								ActionProc is called (set via SetControlAction) as the	*)
(*								indicator is dragged. The value is updated so that the	*)
(*								actionproc can adjust some other property based on the	*)
(*								value each time the action proc is called. If no action	*)
(*								proc is installed, it reverts to the ghost indicator.	*)
(*																						*)
(*		kSliderHasTickMarks	 	Slider is drawn with 'tick marks'. The control			*)
(*								rectangle must be large enough to accomidate the tick	*)
(*								marks.													*)
(*
|*		kSliderReverseDirection	Slider thumb points in opposite direction than normal.	*)
(*								If the slider is vertical, the thumb will point to the	*)
(*								left, if the slider is horizontal, the thumb will point	*)
(*								upwards.												*)
(*																						*)
(*		kSliderNonDirectional	This option overrides the kSliderReverseDirection and	*)
(*								kSliderHasTickMarks variants. It creates an indicator	*)
(*								which is rectangular and doesn't point in any direction	*)
(*								like the normal indicator does.							*)


																(* Slider proc IDs *)
kControlSliderProc: (# exit 48 #);
kControlSliderLiveFeedback: (# exit (1 %sll 0) #);
kControlSliderHasTickMarks: (# exit (1 %sll 1) #);
kControlSliderReverseDirection: (# exit (1 %sll 2) #);
kControlSliderNonDirectional: (# exit (1 %sll 3) #);



(**)
(*	 DISCLOSURE TRIANGLE (CDEF 4)														*)
(**)
(*	This control can be used as either left or right facing. It can also handle its own	*)
(*	tracking if you wish. This means that when the 'autotoggle' variant is used, if the	*)
(*	user clicks the control, it's state will change automatically from open to closed	*)
(*	and vice-versa depending on its initial state. After a successful call to Track-	*)
(* 	Control, you can just check the current value to see what state it was switched to.	*)


																(* Triangle proc IDs *)
kControlTriangleProc: (# exit 64 #);
kControlTriangleLeftFacingProc: (# exit 65 #);
kControlTriangleAutoToggleProc: (# exit 66 #);
kControlTriangleLeftFacingAutoToggleProc: (# exit 67 #);




																(* Tagged data supported by disclosure triangles *)
kControlTriangleLastValueTag: (# exit 0x6C617374 #);		(* SInt16*)


(**)
(*	 PROGRESS INDICATOR (CDEF 5)														*)
(**)
(*	This CDEF implements both determinate and indeterminate progress bars. To switch, 	*)
(*	just use SetControlData to set the indeterminate flag to make it indeterminate call	*)
(*	IdleControls to step thru the animation. IdleControls should be called at least		*)
(*	once during your event loop.														*)
(*																						*)


																(* Progress Bar proc IDs *)
kControlProgressBarProc: (# exit 80 #);




																(* Tagged data supported by progress bars *)
kControlProgressBarIndeterminateTag: (# exit 0x696E6465 #); (* Boolean*)


(**)
(*	 LITTLE ARROWS (CDEF 6)															*)
(**)
(* 	This control implements the little up and down arrows you'd see in the Memory		*)
(*	control panel for adjusting the cache size. 										*)


																(* Little Arrows proc IDs *)
kControlLittleArrowsProc: (# exit 96 #);


(**)
(*	 CHASING ARROWS (CDEF 7)															*)
(**)
(*	To animate this control, make sure to call IdleControls repeatedly.					*)
(*																						*)


																(* Chasing Arrows proc IDs *)
kControlChasingArrowsProc: (# exit 112 #);


(**)
(*	 TABS (CDEF 8)																		*)
(**)
(*	Tabs use an auxiliary resource (tab#) to hold tab information such as the tab name	*)
(*	and an icon suite ID for each tab.													*)
(*																						*)
(*	The ID of the tab# resource that you wish to associate with a tab control should 	*)
(*	be passed in as the Value parameter of the control. If you are using GetNewControl, *)
(*	then the Value slot in the CNTL resource should have the ID of the 'tab#' resource	*)
(*	on creation.																		*)
(*																						*)


																(* Tabs proc IDs *)
kControlTabLargeProc: (# exit 128 #);							(* Large tab size	*)
kControlTabSmallProc: (# exit 129 #);					(* Small tab size	*)




																(* Tagged data supported by progress bars *)
kControlTabContentRectTag: (# exit 0x72656374 #);		(* Rect*)
kControlTabEnabledFlagTag: (# exit 0x656E6162 #);		(* Boolean*)
kControlTabFontStyleTag: (# exit kControlFontStyleTag #);			(* ControlFontStyleRec*)


(**)
(*	 VISUAL SEPARATOR (CDEF 9)															*)
(**)
(*	Separator lines determine their orientation (horizontal or vertical) automatically	*)
(*	based on the relative height and width of their contrlRect.							*)


																(* Visual separator proc IDs *)
kControlSeparatorLineProc: (# exit 144 #);



(**)
(*	 GROUP BOX (CDEF 10)																*)
(**)
(*	The group box CDEF can be use in several ways. It can have no title, a text title, 	*)
(*	a check box as the title, or a popup button as a title. There are two versions of 	*)
(*	group boxes, primary and secondary, which look slightly different.					*)


																(* Group Box proc IDs *)
kControlGroupBoxTextTitleProc: (# exit 160 #);
kControlGroupBoxCheckBoxProc: (# exit 161 #);
kControlGroupBoxPopupButtonProc: (# exit 162 #);
kControlGroupBoxSecondaryTextTitleProc: (# exit 164 #);
kControlGroupBoxSecondaryCheckBoxProc: (# exit 165 #);
kControlGroupBoxSecondaryPopupButtonProc: (# exit 166 #);




																(* Tagged data supported by group box *)
kControlGroupBoxMenuHandleTag: (# exit 0x6D68616E #);		(* MenuHandle (popup title only)*)
kControlGroupBoxFontStyleTag: (# exit kControlFontStyleTag #);			(* ControlFontStyleRec*)


(**)
(*	 IMAGE WELL (CDEF 11)																*)
(**)
(*	Image Wells allow you to control the content type (pict/icon/etc.) shown in the 	*)
(*	well.																				*)
(*																						*)
(*	This is made possible by overloading the Min and Value parameters for the control.	*)
(*																						*)
(*	Parameter					What Goes Here											*)
(*						*)
(*	Min							content type (see constants for bevel buttons)			*)
(*	Value						Resource ID of content type, if resource-based.			*)
(*																						*)
(*																						*)
(*	Checked State																		*)
(*																			*)
(*	The checked state is enabled by setting the value of the control to 1, just like a 	*)
(*	check box.																			*)
(*																						*)
(*	Handle-based Content																*)
(*																	*)
(*	You can create your control and then set the content to an existing handle to an	*)
(*	icon suite, etc. using the macros below. Please keep in mind that resource-based	*)
(*	content is owned by the control, handle-based content is owned by you. The CDEF will*)
(*	not try to dispose of handle-based content. If you are changing the content type of	*)
(*	the button on the fly, you must make sure that if you are replacing a handle-		*)
(*	based content with a resource-based content to properly dispose of the handle,		*)
(*	else a memory leak will ensue.														*)
(*																						*)
(*																						*)
(*	AutoTracking																		*)
(*																			*)
(*	Image Wells are capable of autotracking. The current autotracking feature sets the 	*)
(*	value itself, so that the control remains hilited. It behaves as a sort of palette 	*)
(*	type object where clicking selects it, it cannot be delected by clicking it again, 	*)
(*	clicking on another object should cause the focus to change (as in Get Info windows)*)
(*	and the application should then set the value to 0 to take away the checked border.	*)
(*																						*)


																(* Image Well proc IDs *)
kControlImageWellProc: (# exit 176 #);
kControlImageWellAutoTrackProc: (# exit 177 #);




																(* Tagged data supported by image wells *)
kControlImageWellContentTag: (# exit 0x636F6E74 #);		(* ButtonContentInfo*)
kControlImageWellTransformTag: (# exit 0x7472616E #);		(* IconTransformType*)


(**)
(*	 POPUP ARROW (CDEF 12)																*)
(**)
(*	The popup arrow CDEF is used to draw the small arrow normally associated with a 	*)
(*	popup control. The arrow can point in four directions, and a small or large version *)
(*	can be used. This control is provided to allow clients to draw the arrow in a 		*)
(*	normalized fashion which will take advantage of themes automatically.				*)
(*																						*)


																(* Popup Arrow proc IDs *)
kControlPopupArrowEastProc: (# exit 192 #);
kControlPopupArrowWestProc: (# exit 193 #);
kControlPopupArrowNorthProc: (# exit 194 #);
kControlPopupArrowSouthProc: (# exit 195 #);
kControlPopupArrowSmallEastProc: (# exit 196 #);
kControlPopupArrowSmallWestProc: (# exit 197 #);
kControlPopupArrowSmallNorthProc: (# exit 198 #);
kControlPopupArrowSmallSouthProc: (# exit 199 #);


(**)
(*	 PLACARD (CDEF 14)																	*)
(**)


																(* Placard proc IDs *)
kControlPlacardProc: (# exit 224 #);


(**)
(*	 CLOCK (CDEF 15)																	*)
(**)
(* 	NOTE:	You can specify more options in the Value paramter when creating the clock.	*)
(*			See below.																	*)


																(* Clock proc IDs *)
kControlClockTimeProc: (# exit 240 #);
kControlClockTimeSecondsProc: (# exit 241 #);
kControlClockDateProc: (# exit 242 #);
kControlClockMonthYearProc: (# exit 243 #);


(**)
(* 	These flags can be passed into 'value' field on creation of the control.			*)
(* 	Value is set to 0 after control is created.											*)
(*																						*)
(*	The kClockIsLive value tells the clock to automatically update on idle (clock will	*)
(*	have the current time). This flag is only valid when the kClockIsDisplayOnly flag	*)
(*	is set.																				*)
(**)


kControlClockNoFlags: (# exit 0 #);
kControlClockIsDisplayOnly: (# exit 1 #);
kControlClockIsLive: (# exit 2 #);




																(* Tagged data supported by clocks *)
kControlClockLongDateTag: (# exit 0x64617465 #);		(* LongDateRec*)
kControlClockFontStyleTag: (# exit kControlFontStyleTag #);			(* ControlFontStyleRec*)


(**)
(*	 USER PANE (CDEF 16)																*)
(**)


																(* User Pane proc IDs *)
kControlUserPaneProc: (# exit 256 #);


(* Tagged data supported by user panes *)
(* Currently, they are all proc ptrs for doing things like drawing and hit testing, etc. *)


kControlUserItemDrawProcTag: (# exit 0x75696470 #);		(* UserItemUPP*)
kControlUserPaneDrawProcTag: (# exit 0x64726177 #);		(* ControlUserPaneDrawingUPP*)
kControlUserPaneHitTestProcTag: (# exit 0x68697474 #);	(* ControlUserPaneHitTestUPP*)
kControlUserPaneTrackingProcTag: (# exit 0x7472616B #);	(* ControlUserPaneTrackingUPP*)
kControlUserPaneIdleProcTag: (# exit 0x69646C65 #);		(* ControlUserPaneIdleUPP*)
kControlUserPaneKeyDownProcTag: (# exit 0x6B657964 #);	(* ControlUserPaneKeyDownUPP*)
kControlUserPaneActivateProcTag: (# exit 0x61637469 #);	(* ControlUserPaneActivateUPP*)
kControlUserPaneFocusProcTag: (# exit 0x666F6369 #);		(* ControlUserPaneFocusUPP*)
kControlUserPaneBackgroundProcTag: (# exit 0x6261636B #);	(* ControlUserPaneBackgroundUPP*)


(*
  
  	 EDIT TEXT (CDEF 17)
  
*)


																(* Edit Text proc IDs *)
kControlEditTextProc: (# exit 272 #);
kControlEditTextDialogProc: (# exit 273 #);
kControlEditTextPasswordProc: (# exit 274 #);




																(* Tagged data supported by edit text *)
kControlEditTextStyleTag: (# exit kControlFontStyleTag #);			(* ControlFontStyleRec*)
kControlEditTextTextTag: (# exit 0x74657874 #);		(* Buffer of chars - you supply the buffer*)
kControlEditTextTEHandleTag: (# exit 0x7468616E #);		(* The TEHandle of the text edit record*)
kControlEditTextKeyFilterTag: (# exit kControlKeyFilterTag #);
kControlEditTextSelectionTag: (# exit 0x73656C65 #);		(* EditTextSelectionRec*)
kControlEditTextPasswordTag: (# exit 0x70617373 #);		(* The clear text password text*)


(*

struct ControlEditTextSelectionRec {
	SInt16 							selStart;
	SInt16 							selEnd;
};
typedef struct ControlEditTextSelectionRec ControlEditTextSelectionRec;

typedef ControlEditTextSelectionRec *	ControlEditTextSelectionPtr;
*)

(**)
(*	 STATIC TEXT (CDEF 18)																*)
(**)
(* Static Text proc IDs *)


kControlStaticTextProc: (# exit 288 #);


(* Tagged data supported by static text *)


kControlStaticTextStyleTag: (# exit kControlFontStyleTag #);			(* ControlFontStyleRec*)
kControlStaticTextTextTag: (# exit 0x74657874 #);		(* Copy of text*)
kControlStaticTextTextHeightTag: (# exit 0x74686569 #);	(* SInt16*)


(**)
(*	 PICTURE CONTROL (CDEF 19)															*)
(**)
(*	Value parameter should contain the ID of the picture you wish to display when		*)
(*	creating controls of this type. If you don't want the control tracked at all, use 	*)
(*	the 'no track' variant.																*)


																(* Picture control proc IDs *)
kControlPictureProc: (# exit 304 #);
kControlPictureNoTrackProc: (# exit 305 #);					(* immediately returns kControlPicturePart*)


(**)
(*	 ICON CONTROL (CDEF 20)															*)
(**)
(*	Value parameter should contain the ID of the ICON or cicn you wish to display when	*)
(*	creating controls of this type. If you don't want the control tracked at all, use 	*)
(*	the 'no track' variant.																*)
(* Icon control proc IDs *)


kControlIconProc: (# exit 320 #);
kControlIconNoTrackProc: (# exit 321 #);							(* immediately returns kControlIconPart*)
kControlIconSuiteProc: (# exit 322 #);
kControlIconSuiteNoTrackProc: (# exit 323 #);					(* immediately returns kControlIconPart*)


(* Tagged data supported by icon controls *)


kControlIconTransformTag: (# exit 0x7472666D #);		(* IconTransformType*)
kControlIconAlignmentTag: (# exit 0x616C676E #);		(* IconAlignmentType*)


(**)
(*	 WINDOW HEADER (CDEF 21)															*)
(**)


																(* Window Header proc IDs *)
kControlWindowHeaderProc: (# exit 336 #);							(* normal header*)
kControlWindowListViewHeaderProc: (# exit 337 #);				(* variant for list views - no bottom line*)


(**)
(*	 LIST BOX (CDEF 22)																*)
(**)
(*	Lists use an auxiliary resource to define their format. The resource type used is 	*)
(*	'ldes' and a definition for it can be found in Appearance.r. The resource ID for 	*)
(*	the ldes is passed in the 'value' parameter when creating the control.				*)


																(* List Box proc IDs *)
kControlListBoxProc: (# exit 352 #);
kControlListBoxAutoSizeProc: (# exit 353 #);




																(* Tagged data supported by list box *)
kControlListBoxListHandleTag: (# exit 0x6C68616E #);		(* ListHandle*)
kControlListBoxKeyFilterTag: (# exit kControlKeyFilterTag #);			(* ControlKeyFilterUPP*)
kControlListBoxFontStyleTag: (# exit kControlFontStyleTag #);			(* ControlFontStyleRec*)


(**)
(*	 PUSH BUTTON (CDEF 23)																*)
(**)
(*	The new standard checkbox and radio button controls support a "mixed" value that	*)
(*	indicates that the current setting contains a mixed set of on and off values. The 	*)
(*	control value used to display this indication is defined in Controls.h:				*)
(*																						*)
(*		kControlCheckBoxMixedValue = 2													*)
(*																						*)
(*	Two new variants of the standard pushbutton have been added to the standard control	*)
(*	suite that draw a color icon next to the control title. One variant draws the icon	*)
(*	on the left side, the other draws it on the right side (when the system justifica-	*)
(*	tion is right to left, these are reversed).											*)
(*																						*)
(*	When either of the icon pushbuttons are created, the contrlMax field of the control *)
(*	record is used to determine the ID of the 'cicn' resource drawn in the pushbutton.	*)
(*																						*)
(*	In addition, a push button can now be told to draw with a default outline using the	*)
(*	SetControlData routine with the kPushButtonDefaultTag below.						*)
(*																						*)


																(* Theme Push Button/Check Box/Radio Button proc IDs *)
kControlPushButtonProc: (# exit 368 #);
kControlCheckBoxProc: (# exit 369 #);
kControlRadioButtonProc: (# exit 370 #);
kControlPushButLeftIconProc: (# exit 374 #);							(* Standard pushbutton with left-side icon*)
kControlPushButRightIconProc: (# exit 375 #);					(* Standard pushbutton with right-side icon*)




																(* Tagged data supported by standard buttons *)
kControlPushButtonDefaultTag: (# exit 0x64666C74 #);		(* default ring flag*)


(**)
(*	 SCROLL BAR (CDEF 24)																*)
(**)
(*	This is the new Appearance scroll bar.												*)
(*																						*)


																(* Theme Scroll Bar proc IDs *)
kControlScrollBarProc: (# exit 384 #);							(* normal scroll bar*)
kControlScrollBarLiveProc: (# exit 386 #);					(* live scrolling variant*)


(**)
(*	 POPUP BUTTON (CDEF 25)															*)
(**)
(*	This is the new Appearance Popup Button. It takes the same variants and does the 	*)
(*	same overloading as the previous popup menu control. There are some differences:	*)
(*																						*)
(*	Passing in a menu ID of -12345 causes the popup not to try and get the menu from a	*)
(*	resource. Instead, you can build the menu and later stuff the menuhandle field in 	*)
(*	the popup data information.															*)
(*																						*)
(*	You can pass -1 in the Max parameter to have the control calculate the width of the	*)
(*	title on its own instead of guessing and then tweaking to get it right. It adds the	*)
(*	appropriate amount of space between the title and the popup.						*)
(*																						*)


																(* Theme Popup Button proc IDs *)
kControlPopupButtonProc: (# exit 400 #);
kControlPopupFixedWidthVariant: (# exit 1 %sll 0 #);
kControlPopupVariableWidthVariant: (# exit 1 %sll 1 #);
kControlPopupUseAddResMenuVariant: (# exit 1 %sll 2 #);
kControlPopupUseWFontVariant: (# exit kControlUsesOwningWindowsFontVariant #);


(**)
(* Menu Manager constants, etc.														*)
(**)


kMenuStdMenuProc: (# exit 63 #);
kMenuStdMenuBarProc: (# exit 63 #);




kMenuNoModifiers: (# exit 0 #);							(* Mask for no modifiers*)
kMenuShiftModifier: (# exit (1 %sll 0)  #);					(* Mask for shift key modifier*)
kMenuOptionModifier: (# exit (1 %sll 1) #);						(* Mask for option key modifier*)
kMenuControlModifier: (# exit (1 %sll 2) #);						(* Mask for control key modifier*)
kMenuNoCommandModifier: (# exit (1 %sll 3) #);						(* Mask for no command key modifier*)




kMenuNoIcon: (# exit 0 #);							(* No icon*)
kMenuIconType: (# exit 1 #);							(* Type for ICON*)
kMenuShrinkIconType: (# exit 2 #);							(* Type for ICON plotted 16 x 16*)
kMenuSmallIconType: (# exit 3 #);							(* Type for SICN*)
kMenuColorIconType: (# exit 4 #);							(* Type for cicn*)
kMenuIconSuiteType: (# exit 5 #);							(* Type for Icon Suite*)
kMenuIconRefType: (# exit 6 #);						(* Type for Icon Ref*)




(*** API. Not complete ***)

(* OSErr CreateRootControl (WindowPtr window,
 *									 ControlHandle *control) THREEWORDINLINE(0x303C, 0x0001, 0xAA73);
 *
 *)
 
CreateRootControl: external
	(# window: @integer;
		control: ^longInt;
		err: @shortInt;
	enter (window, control[])
	do '{$303C,$0001,$AA73}'->PascalTrap;
	exit err
	#);

DILoad: external
	(# 
	do 'DILOAD' -> callPascal;
	#);
DIBadMount: external
	(# where: @integer;
		evtMessage: @integer;
		error: @shortInt;
	enter (where,evtMessage)
	do 'DIBADMOUNT' -> callPascal;
	exit error
	#);


(* The following are icons for which there are both icon suites and SICNs. *)

kGenericDocumentIconResource: (# exit -4000 #);
kGenericStationeryIconResource: (# exit -3985 #);
kGenericEditionFileIconResource: (# exit -3989 #);
kGenericApplicationIconResource: (# exit -3996 #);
kGenericDeskAccessoryIconResource: (# exit -3991 #);
kGenericFolderIconResource: (# exit -3999 #);
kPrivateFolderIconResource: (# exit -3994 #);
kFloppyIconResource: (# exit -3998 #);
kTrashIconResource: (# exit -3993 #);
kGenericRAMDiskIconResource: (# exit -3988 #);
kGenericCDROMIconResource: (# exit -3987 #);

(* The following are icons for which there are SICNs only. *)
kDesktopIconResource: (# exit -3992 #);
kOpenFolderIconResource: (# exit -3997 #);
kGenericHardDiskIconResource: (# exit -3995 #);
kGenericFileServerIconResource: (# exit -3972 #);
kGenericSuitcaseIconResource: (# exit -3970 #);
kGenericMoverObjectIconResource: (# exit -3969 #);

(* The following are icons for which there are icon suites only. *)

kGenericPreferencesIconResource: (# exit -3971 #);
kGenericQueryDocumentIconResource: (# exit -16506 #);
kGenericExtensionIconResource: (# exit -16415 #);
kSystemFolderIconResource: (# exit -3983 #);
kAppleMenuFolderIconResource: (# exit -3982 #);

kStartupFolderIconResource: (# exit -3981 #);
kOwnedFolderIconResource: (# exit -3980 #);
kDropFolderIconResource: (# exit -3979 #);
kSharedFolderIconResource: (# exit -3978 #);
kMountedFolderIconResource: (# exit -3977 #);
kControlPanelFolderIconResource: (# exit -3976 #);
kPrintMonitorFolderIconResource: (# exit -3975 #);
kPreferencesFolderIconResource: (# exit -3974 #);
kExtensionsFolderIconResource: (# exit -3973 #);
kFontsFolderIconResource: (# exit -3968 #);
kFullTrashIconResource: (# exit -3984 #);


kLarge1BitMask: (# exit 'ICN#' #);
kLarge4BitData: (# exit 'icl4' #);
kLarge8BitData: (# exit 'icl8' #);
kSmall1BitMask: (# exit 'ics#' #);
kSmall4BitData: (# exit 'ics4' #);
kSmall8BitData: (# exit 'ics8' #);
kMini1BitMask: (# exit 'icm#' #);
kMini4BitData: (# exit 'icm4' #);
kMini8BitData: (# exit 'icm8' #);


(*  alignment type values *)
kAlignNone: (# exit 0x0 #);
kAlignVerticalCenter: (# exit 0x1 #);
kAlignTop: (# exit 0x2 #);
kAlignBottom: (# exit 0x3 #);
kAlignHorizontalCenter: (# exit 0x4 #);
kAlignAbsoluteCenter: (# exit kAlignVerticalCenter #);
kAlignCenterTop: (# exit kAlignTop #);
kAlignCenterBottom: (# exit kAlignBottom #);
kAlignLeft: (# exit 0x8 #);
kAlignCenterLeft: (# exit kAlignVerticalCenter #);
kAlignTopLeft: (# exit kAlignTop #);
kAlignBottomLeft: (# exit kAlignBottom #);
kAlignRight: (# exit 0xC #);
kAlignCenterRight: (# exit kAlignVerticalCenter #);
kAlignTopRight: (# exit kAlignTop #);
kAlignBottomRight: (# exit kAlignBottom #);



(*  transform type values  *)

kTransformNone: (# exit 0x0 #);
kTransformDisabled: (# exit 0x1 #);
kTransformOffline: (# exit 0x2 #);
kTransformOpen: (# exit 0x3 #);
kTransformLabel1: (# exit 0x0100 #);
kTransformLabel2: (# exit 0x0200 #);
kTransformLabel3: (# exit 0x0300 #);
kTransformLabel4: (# exit 0x0400 #);
kTransformLabel5: (# exit 0x0500 #);
kTransformLabel6: (# exit 0x0600 #);
kTransformLabel7: (# exit 0x0700 #);
kTransformSelected: (# exit 0x4000 #);
kTransformSelectedDisabled: (# exit kTransformSelected #);
kTransformSelectedOffline: (# exit kTransformSelected #);
kTransformSelectedOpen: (# exit kTransformSelected #);



(*  Selector mask values  *)

kSelectorLarge1Bit: (# exit 0x00000001 #);
kSelectorLarge4Bit: (# exit 0x00000002 #);
kSelectorLarge8Bit: (# exit 0x00000004 #);
kSelectorSmall1Bit: (# exit 0x00000100 #);
kSelectorSmall4Bit: (# exit 0x00000200 #);
kSelectorSmall8Bit: (# exit 0x00000400 #);
kSelectorMini1Bit: (# exit 0x00010000 #);
kSelectorMini4Bit: (# exit 0x00020000 #);
kSelectorMini8Bit: (# exit 0x00040000 #);
kSelectorAllLargeData: (# exit 0x000000FF #);
kSelectorAllSmallData: (# exit 0x0000FF00 #);
kSelectorAllMiniData: (# exit 0x00FF0000 #);
kSelectorAll1BitData: (# exit kSelectorLarge1Bit #);
kSelectorAll4BitData: (# exit kSelectorLarge4Bit #);
kSelectorAll8BitData: (# exit kSelectorLarge8Bit #);
kSelectorAllAvailableData: (# exit 0xFFFFFFFF #);



(***
	typedef pascal OSErr (*IconActionProcPtr)(ResType theType, Handle *theIcon, void *yourDataPtr);
***)


(***
	typedef pascal Handle (*IconGetterProcPtr)(ResType theType, void *yourDataPtr);
***)



GetIconSuite: external
	(* extern pascal OSErr GetIconSuite(Handle *theIconSuite, SInt16 theResID, IconSelectorValue selector)
	 * 			THREEWORDINLINE($303C, $0501, $ABC9);
	 *)
	(# theIconSuite: ^LongInt;
		theResID: @shortInt;
		selector: @integer;
		error: @shortint;
	enter (theIconSuite[], theResID, selector)
	do '{$303C,$0501,$ABC9}' -> PascalTrap;
	exit error
	#);

PlotIconSuite: external
	(* extern pascal OSErr PlotIconSuite(const Rect *theRect, IconAlignmentType align, IconTransformType transform, Handle theIconSuite)
 	 *		THREEWORDINLINE($303C, $0603, $ABC9);
	 *)
(# theRect: ^QRect;
	align: @integer;
	transform: @integer;
	theIconSuite: @integer;
	error: @shortint;
enter (theRect[], align, transform, theIconSuite)
do '{$303C,$0603,$ABC9}' -> PascalTrap
exit error
#);

(****

struct CIcon {
	PixMap							iconPMap;
	BitMap							iconMask;
	BitMap							iconBMap;
	Handle							iconData;
	SInt16							iconMaskData[1];
};
typedef struct CIcon CIcon, *CIconPtr, **CIconHandle;

extern pascal CIconHandle GetCIcon(SInt16 iconID)
 ONEWORDINLINE($AA1E);
extern pascal void PlotCIcon(const Rect *theRect, CIconHandle theIcon)
 ONEWORDINLINE($AA1F);
extern pascal void DisposeCIcon(CIconHandle theIcon)
 ONEWORDINLINE($AA25);


extern pascal Handle GetIcon(SInt16 iconID)
 ONEWORDINLINE($A9BB);
extern pascal void PlotIcon(const Rect *theRect, Handle theIcon)
 ONEWORDINLINE($A94B);
extern pascal OSErr PlotIconID(const Rect *theRect, IconAlignmentType align, IconTransformType transform, SInt16 theResID)
 THREEWORDINLINE($303C, $0500, $ABC9);
extern pascal OSErr NewIconSuite(Handle *theIconSuite)
 THREEWORDINLINE($303C, $0207, $ABC9);
extern pascal OSErr AddIconToSuite(Handle theIconData, Handle theSuite, ResType theType)
 THREEWORDINLINE($303C, $0608, $ABC9);
extern pascal OSErr GetIconFromSuite(Handle *theIconData, Handle theSuite, ResType theType)
 THREEWORDINLINE($303C, $0609, $ABC9);
extern pascal OSErr ForEachIconDo(Handle theSuite, IconSelectorValue selector, IconActionUPP action, void *yourDataPtr)
 THREEWORDINLINE($303C, $080A, $ABC9);
extern pascal OSErr DisposeIconSuite(Handle theIconSuite, Boolean disposeData)
 THREEWORDINLINE($303C, $0302, $ABC9);
extern pascal OSErr PlotIconSuite(const Rect *theRect, IconAlignmentType align, IconTransformType transform, Handle theIconSuite)
 THREEWORDINLINE($303C, $0603, $ABC9);
extern pascal OSErr MakeIconCache(Handle *theHandle, IconGetterUPP makeIcon, void *yourDataPtr)
 THREEWORDINLINE($303C, $0604, $ABC9);
extern pascal OSErr LoadIconCache(const Rect *theRect, IconAlignmentType align, IconTransformType transform, Handle theIconCache)
 THREEWORDINLINE($303C, $0606, $ABC9);
extern pascal OSErr PlotIconMethod(const Rect *theRect, IconAlignmentType align, IconTransformType transform, IconGetterUPP theMethod, void *yourDataPtr)
 THREEWORDINLINE($303C, $0805, $ABC9);
extern pascal OSErr GetLabel(SInt16 labelNumber, RGBColor *labelColor, Str255 labelString)
 THREEWORDINLINE($303C, $050B, $ABC9);
extern pascal Boolean PtInIconID(Point testPt, const Rect *iconRect, IconAlignmentType align, SInt16 iconID)
 THREEWORDINLINE($303C, $060D, $ABC9);
extern pascal Boolean PtInIconSuite(Point testPt, const Rect *iconRect, IconAlignmentType align, Handle theIconSuite)
 THREEWORDINLINE($303C, $070E, $ABC9);
extern pascal Boolean PtInIconMethod(Point testPt, const Rect *iconRect, IconAlignmentType align, IconGetterUPP theMethod, void *yourDataPtr)
 THREEWORDINLINE($303C, $090F, $ABC9);
extern pascal Boolean RectInIconID(const Rect *testRect, const Rect *iconRect, IconAlignmentType align, SInt16 iconID)
 THREEWORDINLINE($303C, $0610, $ABC9);
extern pascal Boolean RectInIconSuite(const Rect *testRect, const Rect *iconRect, IconAlignmentType align, Handle theIconSuite)
 THREEWORDINLINE($303C, $0711, $ABC9);
extern pascal Boolean RectInIconMethod(const Rect *testRect, const Rect *iconRect, IconAlignmentType align, IconGetterUPP theMethod, void *yourDataPtr)
 THREEWORDINLINE($303C, $0912, $ABC9);
extern pascal OSErr IconIDToRgn(RgnHandle theRgn, const Rect *iconRect, IconAlignmentType align, SInt16 iconID)
 THREEWORDINLINE($303C, $0613, $ABC9);
extern pascal OSErr IconSuiteToRgn(RgnHandle theRgn, const Rect *iconRect, IconAlignmentType align, Handle theIconSuite)
 THREEWORDINLINE($303C, $0714, $ABC9);
extern pascal OSErr IconMethodToRgn(RgnHandle theRgn, const Rect *iconRect, IconAlignmentType align, IconGetterUPP theMethod, void *yourDataPtr)
 THREEWORDINLINE($303C, $0915, $ABC9);
extern pascal OSErr SetSuiteLabel(Handle theSuite, SInt16 theLabel)
 THREEWORDINLINE($303C, $0316, $ABC9);
extern pascal SInt16 GetSuiteLabel(Handle theSuite)
 THREEWORDINLINE($303C, $0217, $ABC9);
extern pascal OSErr GetIconCacheData(Handle theCache, void **theData)
 THREEWORDINLINE($303C, $0419, $ABC9);
extern pascal OSErr SetIconCacheData(Handle theCache, void *theData)
 THREEWORDINLINE($303C, $041A, $ABC9);
extern pascal OSErr GetIconCacheProc(Handle theCache, IconGetterUPP *theProc)
 THREEWORDINLINE($303C, $041B, $ABC9);
extern pascal OSErr SetIconCacheProc(Handle theCache, IconGetterUPP theProc)
 THREEWORDINLINE($303C, $041C, $ABC9);
extern pascal OSErr PlotIconHandle(const Rect *theRect, IconAlignmentType align, IconTransformType transform, Handle theIcon)
 THREEWORDINLINE($303C, $061D, $ABC9);
extern pascal OSErr PlotSICNHandle(const Rect *theRect, IconAlignmentType align, IconTransformType transform, Handle theSICN)
 THREEWORDINLINE($303C, $061E, $ABC9);
extern pascal OSErr PlotCIconHandle(const Rect *theRect, IconAlignmentType align, IconTransformType transform, CIconHandle theCIcon)
 THREEWORDINLINE($303C, $061F, $ABC9);

***)

FindFolder: External
	(# vRefNum: @shortInt;
		folderType: @integer;
		createFolder: @boolean;
		foundVRefNum: ^shortRef;
		foundDirID: ^longInt;
		error: @shortInt;
	enter (vRefNum, folderType, createFolder, foundVRefNum[], foundDirID[])
	do '{$7000, $A823}' -> pascalTrap
	exit error
	#);
	
kOnSystemDisk: 					(# exit 0x8000 #);
kCreateFolder: 					(# exit true #);
kDontCreateFolder: 				(# exit false #);
kSystemFolderType: 				(# exit (* 'macs' *) 0x6d616373 #);
kDesktopFolderType: 				(# exit (* 'desk' *) 0x6465736b #);
kTrashFolderType: 				(# exit (* 'trsh' *) 0x74727368 #);
kWhereToEmptyTrashFolderType: (# exit (* 'empt' *) 0x656d7074 #);
kPrintMonitorDocsFolderType: 	(# exit (* 'prnt' *) 0x70726e74 #);
kStartupFolderType: 				(# exit (* 'strt' *) 0x73747274 #);
kShutdownFolderType: 			(# exit (* 'shdf' *) 0x73686466 #);
kAppleMenuFolderType: 			(# exit (* 'amnu' *) 0x616d6e75 #);
kControlPanelFolderType: 		(# exit (* 'ctrl' *) 0x6374726c #);
kExtensionFolderType: 			(# exit (* 'extn' *) 0x6578746e #);
kFontsFolderType: 				(# exit (* 'font' *) 0x666f6e74 #);
kPreferencesFolderType: 		(# exit (* 'pref' *) 0x70726566 #);
kTemporaryFolderType: 			(# exit (* 'temp' *) 0x74656d70 #);
