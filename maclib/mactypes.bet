ORIGIN '~beta/basiclib/v1.5/external';
BODY 'private/mactypesimpl';
-- CStructLib: Attributes --
Short:
  (# Pos:< IntegerValue; 
  enter (# val: @Integer;  enter val do (Pos,val)->PutShort;  #)
  exit Pos->GetSignedShort
  #);
  

-- Lib: Attributes --
NIL: (# exit 0 #);
Short2Int:
  (# int: @Integer; 
  enter int
  do (@@ int,int)->tos'%putShort[0]'; @@ int->tos'%adrGetSignedShort'->int
  exit int
  #);
Debugger: External (* enter Macsbug *) (# do '$A9FF'->PascalTrap;  #);
DebugStr: External (* enter Macsbug with a message *)
  (# t: [1] @Char;  enter t do '$ABFF'->PascalTrap;  #);
BlockMove: External
  (# srcPtr,dstPtr,byteCount: @Integer; 
  enter (srcPtr,dstPtr,byteCount)
  do (*'BLOCKMOVE'->*) CallPascal; 
  #);
MoveHHi: External (# h: @Integer;  enter h do (*'MOVEHHI'->*) callpascal #);
getqd: (* returns startaddress of global variables *) External
  (# theqd: @Integer;  exit theqd #);
LongInt: CStruct
  (# ByteSize::< (# do 4->Value;  #);
     loWord: Short (# Pos::< (# do 2->Value;  #);  #);
     hiWord: Short (# Pos::< (# do 0->Value;  #);  #);
     
  enter R[1]
  exit R[1]
  #);
CharRef: CStruct
  (# ByteSize::< (# do 2->Value;  #)
  enter (# val: @Integer;  enter val do (0,val)->putByte;  #)
  exit 0->getByte
  #);
ShortRef: CStruct
  (# ByteSize::< (# do 2->Value;  #)
  enter (# val: @Integer;  enter val do (0,val)->putShort;  #)
  exit 0->getShort
  #);
ByteRef: CStruct
  (# ByteSize::< (# do 1->Value;  #)
  enter (# val: @Integer;  enter val do (0,val)->putByte;  #)
  exit 0->getByte
  #);
MacRect: CStruct
  (# ByteSize::< (# do 8->Value;  #);
     Top: Short (# Pos::< (# do 0->Value;  #);  #);
     Left: Short (# Pos::< (# do 2->Value;  #);  #);
     Bottom: Short (# Pos::< (# do 4->Value;  #);  #);
     Right: Short (# Pos::< (# do 6->Value;  #);  #);
     
  enter ((Left,Top),(Right,Bottom))
  exit ((Left,Top),(Right,Bottom))
  #);
MacPoint: CStruct
  (# ByteSize::< (# do 4->Value;  #);
     v: Short (# Pos::< (# do 0->Value;  #);  #);
     h: Short (# Pos::< (# do 2->Value;  #);  #);
     SetPoint: (# h,v: @Integer;  enter (h,v) do (0,v)->PutShort; (2,h)->PutShort;  #);
     GetPoint:
       (# h,v: @Integer;  do 0->GetSignedShort->v; 2->GetSignedShort->h;  exit (h,v) #);
     
  enter R[1]
  exit R[1]
  #);
PascalString: CStruct
  (# ByteSize::< (# do 256->Value; INNER ;  #);
     Length: (# exit 0->GetByte #);
     SetText: (# t: ^Text;  enter t[] do <<SLOT PascalStringSetText:Descriptor>>;  #);
     GetText:
       (# t: ^Text; 
       do <<SLOT PascalStringGetText:Descriptor>>; 
       exit t[]
       #);
     
  enter SetText
  exit GetText
  #);
RecordPeek:
(* super-pattern for describing record-structures 
 *	allocated by the toolbox
 *)
  (# ptr: @Integer;
     GetByte: (# inx: @Integer;  enter inx exit ptr+inx->tos'%adrGetByte' #);
     PutByte: (# val,inx: @Integer;  enter (inx,val) do (ptr+inx,val)->tos'%putByte[0]' #);
     GetShort: (# inx: @Integer;  enter inx exit ptr+inx->tos'%adrGetShort' #);
     GetSignedShort: (# inx: @Integer;  enter inx exit ptr+inx->tos'%adrGetSignedShort' #);
     PutShort: (# val,inx: @Integer;  enter (inx,val) do (ptr+inx,val)->tos'%putShort[0]' #);
     GetLong: (# inx: @Integer;  enter inx exit ptr+inx->tos'%adrGetLong' #);
     PutLong:
       (# val,inx: @Integer; 
       enter (inx,val)
       do
          (ptr+inx+2,val)->tos'%putShort[0]'; (ptr+inx,val->tos'%shiftRight[16]')->tos'%putShort[0]'
       #);
     GetRect:
       (# inx,top,left,bottom,right: @Integer; 
       enter inx
       do
          inx+0->getSignedShort->top;
          inx+2->getSignedShort->left;
          inx+4->getSignedShort->bottom;
          inx+6->getSignedShort->right;
          
       exit ((left,top),(right,bottom))
       #);
     SetRect:
       (# inx,top,left,bottom,right: @Integer; 
       enter (inx,((left,top),(right,bottom)))
       do
          ptr+inx->inx;
          (inx,top)->tos'%putShort[0]';
          (inx+2,left)->tos'%putShort[0]';
          (inx+4,bottom)->tos'%putShort[0]';
          (inx+6,right)->tos'%putShort[0]';
          
       #);
     Byte: (* for declaring fields *)
       (# Pos:< IntegerValue; 
       enter (# val: @Integer;  enter val do (Pos,val)->putByte #)
       exit Pos->getByte
       #);
     Short:
       (# Pos:< IntegerValue; 
       enter (# val: @Integer;  enter val do (Pos,val)->putShort #)
       exit Pos->getShort
       #);
     SignedShort:
       (# Pos:< IntegerValue; 
       enter (# val: @Integer;  enter val do (Pos,val)->putShort #)
       exit Pos->getSignedShort
       #);
     Long:
       (# Pos:< IntegerValue; 
       enter (# val: @Integer;  enter val do (Pos,val)->putLong #)
       exit Pos->getLong
       #);
     DoubleLong:
       (# Pos:< IntegerValue; 
       enter
         (# val1,val2: @Integer; 
         enter (val1,val2)
         do (Pos,val1)->putLong; (Pos+4,val2)->putLong; 
         #)
       exit (Pos->getLong,Pos+4->getLong)
       #);
     Rect: doubleLong
       (# val: @Integer;
          Top:
            (# enter (# enter val do (Pos,val)->PutShort;  #)
            exit Pos->getSignedShort
            #);
          Left:
            (# enter (# enter val do (Pos+2,val)->PutShort;  #)
            exit (Pos+2)->getSignedShort
            #);
          Bottom:
            (# enter (# enter val do (Pos+4,val)->PutShort;  #)
            exit (Pos+4)->getSignedShort
            #);
          Right:
            (# enter (# enter val do (Pos+6,val)->PutShort;  #)
            exit (Pos+6)->getSignedShort
            #);
          TopLeft:
            (# enter (# enter val do (Pos,val)->PutLong;  #) exit Pos->GetLong #);
          BottomRight:
            (# enter (# enter val do (Pos+4,val)->PutLong;  #) exit (Pos+4)->GetLong #);
          
       #);
     PString:
       (# Pos:< IntegerValue;
          Length: (# exit Pos->GetByte #);
          SetText: (# t: ^Text;  enter t[] do <<SLOT PStringSetText:Descriptor>>;  #);
          GetText:
            (# t: ^Text; 
            do <<SLOT PStringGetText:Descriptor>>; 
            exit t[]
            #);
          
       enter SetText
       exit GetText
       #);
     ReadOnlyByte:
     (* for declaring fields *) (# Pos:< IntegerValue;  exit Pos->getByte #);
     ReadOnlyShort: (# Pos:< IntegerValue;  exit Pos->getShort #);
     ReadOnlySignedShort: (# Pos:< IntegerValue; val: @Integer;  exit Pos->getSignedShort #);
     ReadOnlyLong: (# Pos:< IntegerValue;  exit Pos->getLong #);
     ReadOnlyDoubleLong: (# Pos:< IntegerValue;  exit (Pos->getLong,Pos+4->getLong) #);
     ReadOnlyRect: readOnlyDoubleLong (# #);
     InitFromHandle:
       (# hndl: @Integer;  enter hndl do hndl->MoveHHi; hndl->tos'%adrGetLong'->ptr #);
     
  enter ptr
  exit ptr
  #);
GlobVars:
  (# qd: @Integer;
     (* startAddress of global variables *)
     thePortAddress: @Integer;
     (* last address of global variables = address of thePort *)
     thePort: (# exit thePortAddress->tos'%adrGetLong' #);
     (* offsets found in MAC revealed, Volume 1, p541 *)
     whiteAddress: (# exit thePortAddress-8 #);
     BlackAddress: (# exit thePortAddress-16 #);
     GrayAddress: (# exit thePortAddress-24 #);
     ltGrayAddress: (# exit thePortAddress-32 #);
     dkGrayAddress: (# exit thePortAddress-40 #);
     ArrowAddress: (# exit thePortAddress-108 #);
     ScreenBitsAddress: (# exit thePortAddress-122 #);
     RandSeedAddress: (# exit thePortAddress-126 #);
     screenBitsBoundsBR:
       (# bottom,right: @Integer; 
       do
          thePortAddress-122+10->tos'%adrGetShort'->bottom;
          thePortAddress-122+12->tos'%adrGetShort'->right
       exit (right,bottom)
       #);
     init:
       (# do getqd->qd; qd+202->thePortAddress; (* initgraf now done in betaenvbody *)  #);
     
  #);
initToolbox: (# g: ^GlobVars;  enter g[] do g.init; INNER ;  #);
ToResType: (*	Converts a text to the the ResType equivalent. *)
  (# theText: [4] @Char; theResType: @Integer; 
  enter theText
  do <<SLOT TxToRes:Descriptor>>; 
  exit theResType
  #);
FromResType: (*	Reverse of ToResType. *)
  (# theResType: @Integer; theText: [4] @Char; 
  enter theResType
  do <<SLOT ResToTx:Descriptor>>; 
  exit theText
  #);
PToC:
(* Converts a char-repetition, where the length is the first 
 *	byte to a repetition of that length.
 *)
  (# p: [1] @Char
  enter p
  exit (# c: [p[1]] @Char do (for i: p[1] repeat p[i+1]->c[i];  for);  exit c #)
  #);
CToP: (* Reverse of PToC. *)
  (# c: [1] @Char
  enter c
  exit
    (# p: [c.range+1] @Char
    do (for i: c.range repeat c[i]->p[i+1];  for); c.range->p[1]; 
    exit p
    #)
  #);
currentEntVersion: (# exit 2 #);
  

