ORIGIN '~beta/basiclib/external';

-- CStructLib: Attributes --
(***
Short:
  (# Pos:< IntegerValue; 
  enter (# val: @Integer;  enter val do (Pos,val)->PutShort;  #)
  exit Pos->GetSignedShort
  #);
***)
(*
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-96
 *       All rights reserved.
 *
 ****** Patterns for external interface *****
 * 
 * In CStructLib, the operations on a cStruct are defined.
 * The pattern ExternalRecord is an interface to e.g. CStruct objects
 * allocated from C or other external languages.
 *)
(* idx=1 *)
GetByte: 
  (# byteoffset: @integer 
  enter byteoffset 
  do byteoffset->CHK 
  exit byteoffset -> R.%getByte
  (* Above line tos_converted from: exit (R,byteoffset)->TOS'%inxGetByte' *)
  #);
PutByte: 
  (# val,byteoffset: @integer
  enter(byteoffset,val) 
  do byteoffset->CHK; (val, byteoffset) -> R.%putByte
  (* Above line tos_converted from: do byteoffset->CHK; (R,byteoffset,val) ->TOS'%inxPutByte' *)
  #);
GetShort: 
  (# byteoffset: @integer
  enter byteoffset do byteoffset->CHK exit ((byteoffset) div 2) -> R.%getShort
  (* Above line tos_converted from: enter byteoffset do byteoffset->CHK exit (R,byteoffset)->TOS'%inxGetShort' *)
  #);
PutShort: 
  (# val,byteoffset: @integer
  enter(byteoffset,val) 
  do byteoffset->CHK; (val, (byteoffset) div 2) -> R.%putShort
  (* Above line tos_converted from: do byteoffset->CHK; (R,byteoffset,val) ->TOS'%inxPutShort' *)
  #);
GetSignedShort: 
  (# byteoffset: @integer
  enter byteoffset 
  exit %getSignedShortAt(@@R[1]+byteoffset)
  #);
GetLong: 
  (# byteoffset: @integer
  enter byteoffset
  do byteoffset->CHK
  exit ((byteoffset) div 4) -> R.%getLong
  (* Above line tos_converted from: exit (R,byteoffset)->TOS'%inxGetLong' *)
  #);
PutLong: 
  (# val,byteoffset: @integer
  enter(byteoffset,val)
  do byteoffset->CHK;
     (val, (byteoffset) div 4) -> R.%putLong
     (* Above line tos_converted from: (R,byteoffset,val) ->TOS'%inxPutLong' *)
  #);
Byte: (* Used for declaring CStruct fields *)
  (# p: @pos; pos:< IntegerObject; val: @integer;
     set: @(# 
           enter val 
           do (val, p) -> R.%putByte 
           (* Above line tos_converted from: do (R,p,val)->TOS'%inxPutByte' *)
           #);
  enter set
  exit p -> R.%getByte
  (* Above line tos_converted from: exit (R,p)->TOS'%inxGetByte' *)
  #);
Short: (* Used for declaring CStruct fields *)
  (# p: @pos; pos:< IntegerObject; val: @integer;
     set: @(# 
           enter val 
           do (val, (p) div 2) -> R.%putShort 
           (* Above line tos_converted from: do (R,p,val)->TOS'%inxPutShort' *)
           #);
  enter set
  exit ((p) div 2) -> R.%getShort
  (* Above line tos_converted from: exit (R,p)->TOS'%inxGetShort' *)
  #);
SignedShort: 
  (# p: @pos; pos:< IntegerObject; val: @integer;
     set: @(# 
           enter val 
           do (val, (p) div 2) -> R.%putShort
           (* Above line tos_converted from: do (R,p,val)->TOS'%inxPutShort' *)
           #);
  enter set
  exit %getSignedShortAt(@@R[1]+p)
  #);
Long: (* Used for declaring CStruct fields *)
  (# p: @pos; pos:< IntegerObject; val: @integer;
     set: @(# 
           enter val 
           do (val, (p) div 4) -> R.%putLong 
           (* Above line tos_converted from: do (R,p,val)->TOS'%inxPutLong' *)
           #);
  enter set
  exit ((p) div 4) -> R.%getLong
  (* Above line tos_converted from: exit (R,p)->TOS'%inxGetLong' *)
  #);



-- Lib: Attributes --
NIL: (# exit 0 #);
Short2Int:
  (# int: @Integer; 
  enter int
  do (int,0)->int.%putShort; 
  (* Above line tos_converted from: do (@@int,int)->tos'%putShort[0]'; *)
     (0->int.%getSignedShort)->int
     (* Above line tos_converted from: @@int->tos'%adrGetSignedShort'->int *)
  exit int
  #);
Debugger: External (* enter Macsbug *) (# do '$A9FF'->PascalTrap;  #);
DebugStr: External (* enter Macsbug with a message *)
  (# t: [1] @Char;  enter t do '$ABFF'->PascalTrap;  #);
BlockMove: External
  (# srcPtr,dstPtr,byteCount: @Integer; 
  enter (srcPtr,dstPtr,byteCount)
  do (*'BLOCKMOVE'->*) CallPascal; 
  #);
MoveHHi: External (# h: @Integer;  enter h do (*'MOVEHHI'->*) callpascal #);
getqd: (* returns startaddress of global variables *) External
  (# theqd: @Integer;  exit theqd #);
LongInt: CStruct
  (# ByteSize::< (# do 4->Value;  #);
     loWord: Short (# Pos::< (# do 2->Value;  #);  #);
     hiWord: Short (# Pos::< (# do 0->Value;  #);  #);
     
  enter R[1]
  exit R[1]
  #);
CharRef: CStruct
  (# ByteSize::< (# do 2->Value;  #)
  enter (# val: @Integer;  enter val do (0,val)->putByte;  #)
  exit 0->getByte
  #);
ShortRef: CStruct
  (# ByteSize::< (# do 2->Value;  #)
  enter (# val: @Integer;  enter val do (0,val)->putShort;  #)
  exit 0->getShort
  #);
ByteRef: CStruct
  (# ByteSize::< (# do 1->Value;  #)
  enter (# val: @Integer;  enter val do (0,val)->putByte;  #)
  exit 0->getByte
  #);
  
QRect: Data
	(# top: @int16;
	   left: @int16;
	   bottom: @int16;
	   right: @int16;
	#);
MacRect: Com
	(# r: @QRect;
	enter ((r.left, r.top), (r.right, r.bottom))
	exit ((r.left, r.top), (r.right, r.bottom))
	#);
QPoint: Data
	(# v: @int16;
	   h: @int16;
	#);	
MacPoint: COM
  (# p: @QPoint;
     v:
	   (#
	   enter p.v
	   exit p.v
	   #);
	 h:
	    (#
		enter p.h
		exit p.h
		#);
     SetPoint: (# enter (p.h, p.v) #);
     GetPoint: (# exit (p.h, p.v) #);
       
     Set:
	 	(# value: @int32u;
		enter value
		do value %band 0xFFFF -> p.h;
		   value %srl 16 -> p.v;
		#);
  enter Set
  exit (p.v %sll 16) %bor p.h
  #);
PascalString: CStruct
	(# ByteSize::< (# do 256->Value; INNER ;  #);
		Length: (# exit 0->GetByte #);
		SetText: 
			(# t: ^Text;  enter t[] 
			do (if t.lgth <= 255 then
					(if t.lgth > 0 then
						(0,t.lgth)->PutByte; (@@ t.T[1],@@ R[1]+1,t.lgth)->BlockMove; 
					else
						(0, 0) -> PutByte;
					if);
				else
					Exception
						(# 
						do 'length of a PascalString\ncannot exceed 255\n'->msg.Append; 
						#);       
				if);     
			#);
		GetText:
			(# t: ^Text;
				len: @Integer; 
			do &Text[]->t[];
   			Length->len;
				(if len > 0 then 
					 len->t.T.New; 
					 len->t.lgth->t.pos; 
					 (@@ R[1]+1,@@ t.T[1],len)->BlockMove;  
				if)
			exit t[]
			#);
	
	enter SetText
	exit GetText
	#);
  
  
ToolboxRecord: ExternalRecord
	(* super-pattern for describing record-structures 
	 *	allocated by the toolbox
	 *)
	(# initFromHandle:
			(# h: @integer;
			enter h
			do (%getLongAt(h)) -> ptr;
			(* Above line tos_converted from: do h -> TOS'%adrGetLong' -> ptr; *)
			#);
		Rect: DoubleLong
			(# val: @Integer;
				Top: @
                             (# set: @(# 
                                      enter val 
                                      do (val) %putShortAt(ptr+p+2*0);
                                      (* Above line tos_converted from: do (ptr+p,val)->TOS'%putShort[0]'; *)
                                      #)
					enter set
					exit (%getSignedShortAt(ptr+p))
					(* Above line tos_converted from: exit ptr+p->TOS'%adrGetSignedShort' *)
					#);
				Left: @
                             (# set: @(# 
                                      enter val 
                                      do (val) %putShortAt(ptr+p+2+2*0); 
                                      (* Above line tos_converted from: do (ptr+p+2,val)->TOS'%putShort[0]'; *)
                                      #)
					enter set
					exit ((%getSignedShortAt(ptr+p+2)))
					(* Above line tos_converted from: exit (ptr+p+2)->TOS'%adrGetSignedShort' *)
					#);
				Bottom: @
                             (# set: @(# 
                                      enter val 
                                      do (val) %putShortAt(ptr+p+4+2*0);
                                      (* Above line tos_converted from: do (ptr+p+4,val)->TOS'%putShort[0]'; *)
                                      #)
					enter set
					exit ((%getSignedShortAt(ptr+p+4)))
					(* Above line tos_converted from: exit (ptr+p+4)->TOS'%adrGetSignedShort' *)
					#);
				Right: @
                             (# set: @(# 
                                      enter val 
                                      do (val) %putShortAt(ptr+p+6+2*0);
                                      (* Above line tos_converted from: do (ptr+p+6,val)->TOS'%putShort[0]'; *)
                                      #)
					enter set
					exit ((%getSignedShortAt(ptr+p+6)))
					(* Above line tos_converted from: exit (ptr+p+6)->TOS'%adrGetSignedShort' *)
					#);
				TopLeft: @
                             (# set: @(# 
                                      enter val 
                                      do (val) %putLongAt(ptr+p);
                                      (* Above line tos_converted from: do (ptr+p,val)->TOS'%putLong'; *)
                                      #) 
					enter set
					exit (%getLongAt(ptr+p)) 
					(* Above line tos_converted from: exit ptr+p->TOS'%adrGetLong' *)
					#);
				BottomRight:
                             (# set: @(# 
                                      enter val 
                                      do (val) %putLongAt(ptr+p+4); 
                                      (* Above line tos_converted from: do (ptr+p+4,val)->TOS'%putLong'; *)
                                      #)
					enter  set
					exit ((%getLongAt(ptr+p+4))) 
					(* Above line tos_converted from: exit (ptr+p+4)->TOS'%adrGetLong' *)
					#);
			#);
		PString:
			(# p: @pos; pos:< IntegerValue;
				
                           length: @(# 
                                    exit (%getByteAt(ptr+p)) 
                                    (* Above line tos_converted from: exit ptr+p->TOS'%adrGetByte' *)
                                    #);
				setText: @
					(*
					 * This operation can cause a garbage collection.
					 *)
					(# t: ^Text;  enter t[] 
					do (if t[] <> NONE then
							(if t.lgth <= 255 then
									(if t.lgth > 0 then
										(t.lgth) %putByteAt(ptr+p+0);
										(* Above line tos_converted from: (ptr+p, t.lgth)->TOS'%putByte[0]'; *)
									 	(@@t.T[1], ptr+p+1, t.lgth)->BlockMove;
									else
										(0) %putByteAt(ptr+p+0);
										(* Above line tos_converted from: (ptr+p, 0)->TOS'%putByte[0]'; *)
									if);
							else
								Exception
									(# 
									do 'length of a PascalString\ncannot exceed 255\n'->msg.Append; 
									#);       
							if);
						else
							(0) %putByteAt(ptr+p+0);
							(* Above line tos_converted from: (ptr+p, 0)->TOS'%putByte[0]'; *)
						if);
					#);
				getText: @
					(*
					 * This operation can cause a garbage collection.
					 *)
					(# t: ^Text;
						len: @Integer; 
					do &text[] -> t[];
						length -> len;
						(if len > 0 then 
							len->t.T.New; len->t.lgth->t.pos; (ptr+p+1, @@t.T[1], len)->BlockMove;
						if)
					exit t[]
					#);
			 
			enter setText
			exit getText
			#);
	#);

GlobVars:
  (# qd: @Integer;
     (* startAddress of global variables *)
     thePortAddress: @Integer;
     (* last address of global variables = address of thePort *)
     thePort: (# exit (%getLongAt(thePortAddress)) #);
     (* Above line tos_converted from: thePort: (# exit thePortAddress->tos'%adrGetLong' #); *)
     (* offsets found in MAC revealed, Volume 1, p541 *)
     whiteAddress: (# exit thePortAddress-8 #);
     BlackAddress: (# exit thePortAddress-16 #);
     GrayAddress: (# exit thePortAddress-24 #);
     ltGrayAddress: (# exit thePortAddress-32 #);
     dkGrayAddress: (# exit thePortAddress-40 #);
     ArrowAddress: (# exit thePortAddress-108 #);
     ScreenBitsAddress: (# exit thePortAddress-122 #);
     RandSeedAddress: (# exit thePortAddress-126 #);
     screenBitsBoundsBR:
       (# bottom,right: @Integer; 
       do
          %getShortAt(thePortAddress-122+10)->bottom;
          (* Above line tos_converted from: thePortAddress-122+10->tos'%adrGetShort'->bottom; *)
          %getShortAt(thePortAddress-122+12)->right
          (* Above line tos_converted from: thePortAddress-122+12->tos'%adrGetShort'->right *)
       exit (right,bottom)
       #);
     init:
       (# do (* getqd->qd; qd+202->thePortAddress;*) (* initgraf now done in betaenvbody *)  #);
     
  #);
initToolbox: (# g: ^GlobVars;  enter g[] do g.init; INNER ;  #);
ToResType: (*	Converts a text to the the ResType equivalent. *)
	(# theText: [4] @Char; theResType: @Integer;
		const3: (# exit 16777216 #);
		const2: (# exit 65536 #);
		const1: (# exit 256 #);
	enter theText
	do theText[1]*const3->theResType;
		(theText[2]*const2)+theResType->theResType;
		(theText[3]*const1)+theResType->theResType;
		theText[4]+theResType->theResType;
	exit theResType
	#);
FromResType: (*	Reverse of ToResType. *)
	(# theResType: @Integer; theText: [4] @Char;
		const3: (# exit 16777216 #);
   	const2: (# exit 65536 #);
   	const1: (# exit 256 #);
	enter theResType
	do theResType div const3->theText[1];
   	theResType mod const3->theResType;
   	theResType div const2->theText[2];
   	theResType mod const2->theResType;
   	theResType div const1->theText[3];
   	theResType mod const1->theText[4];
	exit theText
	#);
PToC:
(* Converts a char-repetition, where the length is the first 
 *	byte to a repetition of that length.
 *)
  (# p: [1] @Char
  enter p
  exit (# c: [p[1]] @Char do (for i: p[1] repeat p[i+1]->c[i];  for);  exit c #)
  #);
CToP: (* Reverse of PToC. *)
  (# c: [1] @Char
  enter c
  exit
    (# p: [c.range+1] @Char
    do (for i: c.range repeat c[i]->p[i+1];  for); c.range->p[1]; 
    exit p
    #)
  #);
currentEntVersion: (# exit 2 #);
  

