ORIGIN '~beta/basiclib/v1.6/external';

-- CStructLib: Attributes --
Short:
  (# Pos:< IntegerValue; 
  enter (# val: @Integer;  enter val do (Pos,val)->PutShort;  #)
  exit Pos->GetSignedShort
  #);
  

-- Lib: Attributes --
NIL: (# exit 0 #);
Short2Int:
  (# int: @Integer; 
  enter int
  do (@@ int,int)->tos'%putShort[0]'; @@ int->tos'%adrGetSignedShort'->int
  exit int
  #);
Debugger: External (* enter Macsbug *) (# do '$A9FF'->PascalTrap;  #);
DebugStr: External (* enter Macsbug with a message *)
  (# t: [1] @Char;  enter t do '$ABFF'->PascalTrap;  #);
BlockMove: External
  (# srcPtr,dstPtr,byteCount: @Integer; 
  enter (srcPtr,dstPtr,byteCount)
  do (*'BLOCKMOVE'->*) CallPascal; 
  #);
MoveHHi: External (# h: @Integer;  enter h do (*'MOVEHHI'->*) callpascal #);
getqd: (* returns startaddress of global variables *) External
  (# theqd: @Integer;  exit theqd #);
LongInt: CStruct
  (# ByteSize::< (# do 4->Value;  #);
     loWord: Short (# Pos::< (# do 2->Value;  #);  #);
     hiWord: Short (# Pos::< (# do 0->Value;  #);  #);
     
  enter R[1]
  exit R[1]
  #);
CharRef: CStruct
  (# ByteSize::< (# do 2->Value;  #)
  enter (# val: @Integer;  enter val do (0,val)->putByte;  #)
  exit 0->getByte
  #);
ShortRef: CStruct
  (# ByteSize::< (# do 2->Value;  #)
  enter (# val: @Integer;  enter val do (0,val)->putShort;  #)
  exit 0->getShort
  #);
ByteRef: CStruct
  (# ByteSize::< (# do 1->Value;  #)
  enter (# val: @Integer;  enter val do (0,val)->putByte;  #)
  exit 0->getByte
  #);
MacRect: CStruct
  (# ByteSize::< (# do 8->Value;  #);
     Top: Short (# Pos::< (# do 0->Value;  #);  #);
     Left: Short (# Pos::< (# do 2->Value;  #);  #);
     Bottom: Short (# Pos::< (# do 4->Value;  #);  #);
     Right: Short (# Pos::< (# do 6->Value;  #);  #);
     
  enter ((Left,Top),(Right,Bottom))
  exit ((Left,Top),(Right,Bottom))
  #);
MacPoint: CStruct
  (# ByteSize::< (# do 4->Value;  #);
     v: Short (# Pos::< (# do 0->Value;  #);  #);
     h: Short (# Pos::< (# do 2->Value;  #);  #);
     SetPoint: (# h,v: @Integer;  enter (h,v) do (0,v)->PutShort; (2,h)->PutShort;  #);
     GetPoint:
       (# h,v: @Integer;  do 0->GetSignedShort->v; 2->GetSignedShort->h;  exit (h,v) #);
     
  enter R[1]
  exit R[1]
  #);
PascalString: CStruct
	(# ByteSize::< (# do 256->Value; INNER ;  #);
		Length: (# exit 0->GetByte #);
		SetText: 
			(# t: ^Text;  enter t[] 
			do (if t.lgth <= 255 then
					(if t.lgth > 0 then
						(0,t.lgth)->PutByte; (@@ t.T[1],@@ R[1]+1,t.lgth)->BlockMove; 
					else
						(0, 0) -> PutByte;
					if);
				else
					Exception
						(# 
						do 'length of a PascalString\ncannot exceed 255\n'->msg.Append; 
						#);       
				if);     
			#);
		GetText:
			(# t: ^Text;
				len: @Integer; 
			do &Text[]->t[];
   			Length->len;
				(if len > 0 then 
					 len->t.T.New; 
					 len->t.lgth->t.pos; 
					 (@@ R[1]+1,@@ t.T[1],len)->BlockMove;  
				if)
			exit t[]
			#);
	
	enter SetText
	exit GetText
	#);
  
  
ToolboxRecord: ExternalRecord
	(* super-pattern for describing record-structures 
	 *	allocated by the toolbox
	 *)
	(# initFromHandle:
			(# h: @integer;
			enter h
			do h -> TOS'%adrGetLong' -> ptr;
			#);
		Rect: DoubleLong
			(# val: @Integer;
				Top: @
					(# set: @(# enter val do (ptr+p,val)->TOS'%putShort[0]';  #)
					enter set
					exit ptr+p->TOS'%adrGetSignedShort'
					#);
				Left: @
					(# set: @(# enter val do (ptr+p+2,val)->TOS'%putShort[0]';  #)
					enter set
					exit (ptr+p+2)->TOS'%adrGetSignedShort'
					#);
				Bottom: @
					(# set: @(# enter val do (ptr+p+4,val)->TOS'%putShort[0]';  #)
					enter set
					exit (ptr+p+4)->TOS'%adrGetSignedShort'
					#);
				Right: @
					(# set: @(# enter val do (ptr+p+6,val)->TOS'%putShort[0]';  #)
					enter set
					exit (ptr+p+6)->TOS'%adrGetSignedShort'
					#);
				TopLeft: @
					(# set: @(# enter val do (ptr+p,val)->TOS'%putLong';  #) 
					enter set
					exit ptr+p->TOS'%adrGetLong' 
					#);
				BottomRight:
					(# set: @(# enter val do (ptr+p+4,val)->TOS'%putLong';  #)
					enter  set
					exit (ptr+p+4)->TOS'%adrGetLong' 
					#);
			#);
		PString:
			(# p: @pos; pos:< IntegerValue;
				
				length: @(# exit ptr+p->TOS'%adrGetByte' #);
				setText: @
					(*
					 * This operation can cause a garbage collection.
					 *)
					(# t: ^Text;  enter t[] 
					do (if t[] <> NONE then
							(if t.lgth <= 255 then
									(if t.lgth > 0 then
										(ptr+p, t.lgth)->TOS'%putByte[0]';
									 	(@@t.T[1], ptr+p+1, t.lgth)->BlockMove;
									else
										(ptr+p, 0)->TOS'%putByte[0]';
									if);
							else
								Exception
									(# 
									do 'length of a PascalString\ncannot exceed 255\n'->msg.Append; 
									#);       
							if);
						else
							(ptr+p, 0)->TOS'%putByte[0]';
						if);
					#);
				getText: @
					(*
					 * This operation can cause a garbage collection.
					 *)
					(# t: ^Text;
						len: @Integer; 
					do &text[] -> t[];
						length -> len;
						(if len > 0 then 
							len->t.T.New; len->t.lgth->t.pos; (ptr+p+1, @@t.T[1], len)->BlockMove;
						if)
					exit t[]
					#);
			 
			enter setText
			exit getText
			#);
	#);

GlobVars:
  (# qd: @Integer;
     (* startAddress of global variables *)
     thePortAddress: @Integer;
     (* last address of global variables = address of thePort *)
     thePort: (# exit thePortAddress->tos'%adrGetLong' #);
     (* offsets found in MAC revealed, Volume 1, p541 *)
     whiteAddress: (# exit thePortAddress-8 #);
     BlackAddress: (# exit thePortAddress-16 #);
     GrayAddress: (# exit thePortAddress-24 #);
     ltGrayAddress: (# exit thePortAddress-32 #);
     dkGrayAddress: (# exit thePortAddress-40 #);
     ArrowAddress: (# exit thePortAddress-108 #);
     ScreenBitsAddress: (# exit thePortAddress-122 #);
     RandSeedAddress: (# exit thePortAddress-126 #);
     screenBitsBoundsBR:
       (# bottom,right: @Integer; 
       do
          thePortAddress-122+10->tos'%adrGetShort'->bottom;
          thePortAddress-122+12->tos'%adrGetShort'->right
       exit (right,bottom)
       #);
     init:
       (# do getqd->qd; qd+202->thePortAddress; (* initgraf now done in betaenvbody *)  #);
     
  #);
initToolbox: (# g: ^GlobVars;  enter g[] do g.init; INNER ;  #);
ToResType: (*	Converts a text to the the ResType equivalent. *)
	(# theText: [4] @Char; theResType: @Integer;
		const3: (# exit 16777216 #);
		const2: (# exit 65536 #);
		const1: (# exit 256 #);
	enter theText
	do theText[1]*const3->theResType;
		(theText[2]*const2)+theResType->theResType;
		(theText[3]*const1)+theResType->theResType;
		theText[4]+theResType->theResType;
	exit theResType
	#);
FromResType: (*	Reverse of ToResType. *)
	(# theResType: @Integer; theText: [4] @Char;
		const3: (# exit 16777216 #);
   	const2: (# exit 65536 #);
   	const1: (# exit 256 #);
	enter theResType
	do theResType div const3->theText[1];
   	theResType mod const3->theResType;
   	theResType div const2->theText[2];
   	theResType mod const2->theResType;
   	theResType div const1->theText[3];
   	theResType mod const1->theText[4];
	exit theText
	#);
PToC:
(* Converts a char-repetition, where the length is the first 
 *	byte to a repetition of that length.
 *)
  (# p: [1] @Char
  enter p
  exit (# c: [p[1]] @Char do (for i: p[1] repeat p[i+1]->c[i];  for);  exit c #)
  #);
CToP: (* Reverse of PToC. *)
  (# c: [1] @Char
  enter c
  exit
    (# p: [c.range+1] @Char
    do (for i: c.range repeat c[i]->p[i+1];  for); c.range->p[1]; 
    exit p
    #)
  #);
currentEntVersion: (# exit 2 #);
  

