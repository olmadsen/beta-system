ORIGIN 'mactypes';
-- Lib: Attributes --
blackColor: (# exit 33 #);
whiteColor: (# exit 30 #);
redColor: (# exit 205 #);
greenColor: (# exit 341 #);
blueColor: (# exit 409 #);
cyanColor: (# exit 273 #);
magentaColor: (# exit 137 #);
yellowColor: (# exit 69 #);
regionPtr: RecordPeek
  (# rgnSize: Short (# Pos::< (# do 0->Value;  #);  #);
     rgnBBox: Rect (# Pos::< (# do 2->Value;  #);  #);
     
  #);
macBitMap: CStruct
  (# ByteSize::< (# do 14->Value;  #);
     baseAddr: Long (# Pos::< (# do 0->Value;  #);  #);
     rowBytes: Short (# Pos::< (# do 4->Value;  #);  #);
     topLeft: Long (# Pos::< (# do 6->Value;  #);  #);
     botRight: Long (# Pos::< (# do 10->Value;  #);  #);
     bounds: (# enter (topLeft,botRight) exit (topLeft,botRight) #);
     
  #);
grafPortPtr: RecordPeek
  (# device: ReadOnlyShort (# Pos::< (# do 0->Value;  #);  #);
     baseAddr: Long (# Pos::< (# do 2->Value;  #);  #);
     rowBytes: Short (# Pos::< (# do 6->Value;  #);  #);
     bounds: Rect (# Pos::< (# do 8->Value;  #);  #);
     portBitsAddr: ReadOnlyLong (# Pos::< (# do 2->Value;  #);  #);
     portBitsBoundsTL: (# exit (8->getShort,10->getShort) #);
     PortRect: Rect (# Pos::< (# do 16->Value;  #);  #);
     PortRectTL: (# exit (# exit (16->getShort,18->getShort) #) #);
     visRgn: ReadOnlyLong (# Pos::< (# do 24->Value;  #);  #);
     clipRgn: ReadOnlyLong (# Pos::< (# do 28->Value;  #);  #);
     bkPatAdr: ReadOnlyLong (# Pos::< (# do 32->Value;  #);  #);
     fillPatAdr: ReadOnlyLong (# Pos::< (# do 40->Value;  #);  #);
     pnLoc: ReadOnlyLong (# Pos::< (# do 48->Value;  #);  #);
     pnSize: ReadOnlyLong (# Pos::< (# do 52->Value;  #);  #);
     pnMode: ReadOnlyShort (# Pos::< (# do 56->Value;  #);  #);
     pnPatAdr: ReadOnlyLong (# Pos::< (# do 58->Value;  #);  #);
     pnVis: ReadOnlyShort (# Pos::< (# do 66->Value;  #);  #);
     txFont: ReadOnlyShort (# Pos::< (# do 68->Value;  #);  #);
     txFace: ReadOnlyShort (# Pos::< (# do 70->Value;  #);  #);
     txMode: ReadOnlyShort (# Pos::< (# do 72->Value;  #);  #);
     txSize: ReadOnlyShort (# Pos::< (# do 74->Value;  #);  #);
     spExtra: ReadOnlyLong (# Pos::< (# do 76->Value;  #);  #);
     fgColor: ReadOnlyLong (# Pos::< (# do 80->Value;  #);  #);
     bkColor: ReadOnlyLong (# Pos::< (# do 84->Value;  #);  #);
     colrBit: ReadOnlyShort (# Pos::< (# do 88->Value;  #);  #);
     patStretch: ReadOnlyShort (# Pos::< (# do 90->Value;  #);  #);
     picSave: Long (# Pos::< (# do 92->Value;  #);  #);
     rgnSave: Long (# Pos::< (# do 96->Value;  #);  #);
     polySave: Long (# Pos::< (# do 100->Value;  #);  #);
     
  #);
PicturePtr: RecordPeek
  (# picSize: ReadOnlyShort (# Pos::< (# do 0->Value;  #);  #);
     Rect: ReadOnlyRect (# Pos::< (# do 2->Value;  #);  #);
     
  #);
polygonPtr: RecordPeek
  (# polySize: Short (# Pos::< (# do 0->Value;  #);  #);
     polyBBox: Rect (# Pos::< (# do 2->Value;  #);  #);
     
  #);
penState: CStruct
  (# ByteSize::< (# do 18->Value;  #);
     pnLoc: Long (# Pos::< (# do 0->Value;  #);  #);
     pnSize: Long (# Pos::< (# do 4->Value;  #);  #);
     pnMode: Short (# Pos::< (# do 8->Value;  #);  #);
     
  #);
FontInfo: CStruct
  (# ByteSize::< (# do 8->Value;  #);
     ascent: Short (# Pos::< (# do 0->Value;  #);  #);
     descent: Short (# Pos::< (# do 2->Value;  #);  #);
     widMax: Short (# Pos::< (# do 4->Value;  #);  #);
     leading: Short (# Pos::< (# do 6->Value;  #);  #);
     
  #);
RGBColor: CStruct
  (# ByteSize::< (# do 6->Value;  #);
     red: Short (# Pos::< (# do 0->Value;  #);  #);
     green: Short (# Pos::< (# do 2->Value;  #);  #);
     blue: Short (# Pos::< (# do 4->Value;  #);  #);
     
  #);
GDevicePtr: RecordPeek
  (# gdRefNum: Short (# Pos::< (# do 0->Value;  #);  #);
     (* driver's unit number *)
     gdID: Short (# Pos::< (# do 2->Value;  #);  #);
     (* client ID for search procs *)
     gdType: Short (# Pos::< (# do 4->Value;  #);  #);
     (* fixed/CLUT/diRect *)
     gdITable: Long (# Pos::< (# do 6->Value;  #);  #);
     (* Handle to inverse lookup table *)
     gdResPref: Short (# Pos::< (# do 10->Value;  #);  #);
     (* preferred resolution of GDITable *)
     gdSearchProc: Long (# Pos::< (# do 12->Value;  #);  #);
     (* search proc list head *)
     gdCompProc: Long (# Pos::< (# do 16->Value;  #);  #);
     (* complement proc list *)
     gdFlags: Short (# Pos::< (# do 20->Value;  #);  #);
     (* grafDevice flags word *)
     gdPMap: Long (# Pos::< (# do 22->Value;  #);  #);
     (* describing pixMap *)
     gdRefCon: Long (# Pos::< (# do 26->Value;  #);  #);
     (* reference Value *)
     gdNextGD: Long (# Pos::< (# do 30->Value;  #);  #);
     (* GDHandle Handle of next gDevice *)
     gdRect: Rect (# Pos::< (# do 34->Value;  #);  #);
     (* device's bounds in global coordinates *)
     gdMode: Long (# Pos::< (# do 42->Value;  #);  #);
     (* device's current mode *)
     gdCCBytes: Short (# Pos::< (# do 46->Value;  #);  #);
     (* depth of expanded cursor data *)
     gdCCDepth: Short (# Pos::< (# do 48->Value;  #);  #);
     (* depth of expanded cursor data *)
     gdCCXData: Long (# Pos::< (# do 50->Value;  #);  #);
     (* Handle to cursor's expanded data *)
     gdCCXMask: Long (# Pos::< (# do 54->Value;  #);  #);
     (* Handle to cursor's expanded mask *)
     gdReserved: Long (# Pos::< (# do 58->Value;  #);  #);
     (* future use. MUST BE 0 *)
     
  #);
ColorSpec: CStruct
  (# ByteSize::< (# do 8->Value;  #);
     Value: Short (# Pos::< (# do 0->Value;  #);  #);
     rgb: CStruct
       (# ByteSize::< (# do 6->Value;  #);
          red: Short (# Pos::< (# do 2->Value;  #);  #);
          green: Short (# Pos::< (# do 4->Value;  #);  #);
          blue: Short (# Pos::< (# do 6->Value;  #);  #);
          
       enter (red,green,blue)
       exit (red,green,blue)
       #);
     
  #);
ColorTable: CStruct
  (# ByteSize::< (# do 8->Value;  #);
     ctSeed: Long (# Pos::< (# do 0->Value;  #);  #);
     ctFlags: Short (# Pos::< (# do 4->Value;  #);  #);
     ctSize: Short (# Pos::< (# do 6->Value;  #);  #);
     (*  ctTabel: cSpecArray *)
     
  #);
CGrafPortPtr: RecordPeek
  (# device: ReadOnlyShort (# Pos::< (# do 0->Value;  #);  #);
     portPixMapAdr: Long (# Pos::< (# do 2->Value;  #);  #);
     portVersion: Short (# Pos::< (# do 6->Value;  #);  #);
     grafVarsAdr: Long (# Pos::< (# do 8->Value;  #);  #);
     chExtra: Short (# Pos::< (# do 12->Value;  #);  #);
     pnLocHFrac: Short (# Pos::< (# do 14->Value;  #);  #);
     PortRect: Rect (# Pos::< (# do 16->Value;  #);  #);
     visRgn: ReadOnlyLong (# Pos::< (# do 24->Value;  #);  #);
     clipRgn: ReadOnlyLong (# Pos::< (# do 28->Value;  #);  #);
     bkPixPatAdr: Long (# Pos::< (# do 32->Value;  #);  #);
     rgbFgColor:
       (# red: Short (# Pos::< (# do 36->Value;  #);  #);
          green: Short (# Pos::< (# do 38->Value;  #);  #);
          blue: Short (# Pos::< (# do 40->Value;  #);  #);
          
       enter (red,green,blue)
       exit (red,green,blue)
       #);
     rgbBgColor:
       (# red: Short (# Pos::< (# do 42->Value;  #);  #);
          green: Short (# Pos::< (# do 44->Value;  #);  #);
          blue: Short (# Pos::< (# do 46->Value;  #);  #);
          
       enter (red,green,blue)
       exit (red,green,blue)
       #);
     pnLoc: ReadOnlyLong (# Pos::< (# do 48->Value;  #);  #);
     pnSize: ReadOnlyLong (# Pos::< (# do 52->Value;  #);  #);
     pnMode: ReadOnlyShort (# Pos::< (# do 56->Value;  #);  #);
     pnPixPatAdr: Long (# Pos::< (# do 58->Value;  #);  #);
     filPixPatAdr: Long (# Pos::< (# do 62->Value;  #);  #);
     pnVis: ReadOnlyShort (# Pos::< (# do 66->Value;  #);  #);
     txFont: ReadOnlyShort (# Pos::< (# do 68->Value;  #);  #);
     txFace: ReadOnlyShort (# Pos::< (# do 70->Value;  #);  #);
     txMode: ReadOnlyShort (# Pos::< (# do 72->Value;  #);  #);
     txSize: ReadOnlyShort (# Pos::< (# do 74->Value;  #);  #);
     spExtra: ReadOnlyLong (# Pos::< (# do 76->Value;  #);  #);
     fgColor: ReadOnlyLong (# Pos::< (# do 80->Value;  #);  #);
     bkColor: ReadOnlyLong (# Pos::< (# do 84->Value;  #);  #);
     colrBit: ReadOnlyShort (# Pos::< (# do 88->Value;  #);  #);
     patStretch: ReadOnlyShort (# Pos::< (# do 90->Value;  #);  #);
     picSave: Long (# Pos::< (# do 92->Value;  #);  #);
     rgnSave: Long (# Pos::< (# do 96->Value;  #);  #);
     polySave: Long (# Pos::< (# do 100->Value;  #);  #);
     
  #);
GrafVars: CStruct
  (# ByteSize::< (# do 26->Value;  #);
     rgbOpColor:
       (# red: Short (# Pos::< (# do 0->Value;  #);  #);
          green: Short (# Pos::< (# do 2->Value;  #);  #);
          blue: Short (# Pos::< (# do 4->Value;  #);  #);
          
       enter (red,green,blue)
       exit (red,green,blue)
       #);
     rgbHiliteColor:
       (# red: Short (# Pos::< (# do 6->Value;  #);  #);
          green: Short (# Pos::< (# do 8->Value;  #);  #);
          blue: Short (# Pos::< (# do 10->Value;  #);  #);
          
       enter (red,green,blue)
       exit (red,green,blue)
       #);
     pmFgColor: Long (# Pos::< (# do 12->Value;  #);  #);
     pmFgIndex: Short (# Pos::< (# do 16->Value;  #);  #);
     pmBkColor: Long (# Pos::< (# do 18->Value;  #);  #);
     pmBkIndex: Short (# Pos::< (# do 22->Value;  #);  #);
     pmFlags: Short (# Pos::< (# do 24->Value;  #);  #);
     
  #);
PixMapPtr: RecordPeek
  (# baseAddr: Long (# Pos::< (# do 0->Value;  #);  #);
     rowBytes: Short (# Pos::< (# do 4->Value;  #);  #);
     bounds: Rect (# Pos::< (# do 6->Value;  #);  #);
     pmVersion: Short (# Pos::< (# do 14->Value;  #);  #);
     packType: Short (# Pos::< (# do 16->Value;  #);  #);
     packSize: Long (# Pos::< (# do 18->Value;  #);  #);
     hRes: Long (# Pos::< (# do 22->Value;  #);  #);
     vRes: Long (# Pos::< (# do 26->Value;  #);  #);
     pixelType: Short (# Pos::< (# do 30->Value;  #);  #);
     pixelSize: Short (# Pos::< (# do 32->Value;  #);  #);
     cmpCount: Short (# Pos::< (# do 34->Value;  #);  #);
     cmpSize: Short (# Pos::< (# do 36->Value;  #);  #);
     planeBytes: Long (# Pos::< (# do 38->Value;  #);  #);
     pmTable: Long (# Pos::< (# do 42->Value;  #);  #);
     pmReserved: Long (# Pos::< (# do 46->Value;  #);  #);
     
  #);
PixPatPtr: RecordPeek
  (# patType: Short (# Pos::< (# do 0->Value;  #);  #);
     patMap: Long (# Pos::< (# do 2->Value;  #);  #);
     patData: Long (# Pos::< (# do 6->Value;  #);  #);
     patXData: Long (# Pos::< (# do 10->Value;  #);  #);
     patXValid: Short (# Pos::< (# do 14->Value;  #);  #);
     patXMap: Long (# Pos::< (# do 18->Value;  #);  #);
     pat1Data: DoubleLong (# Pos::< (# do 22->Value;  #);  #);
     
  #);
CCrsr: RecordPeek
  (# crsrType: Short (# Pos::< (# do 0->Value;  #);  #);
     crsrMap: Long (# Pos::< (# do 2->Value;  #);  #);
     crsrData: Long (# Pos::< (# do 6->Value;  #);  #);
     crsrXData: Long (# Pos::< (# do 10->Value;  #);  #);
     crsrXValid: Short (# Pos::< (# do 14->Value;  #);  #);
     crsrXHandle: Long (# Pos::< (# do 16->Value;  #);  #);
     crsr1Data: Short (# Pos::< (# do 20->Value;  #);  #);
     crsrMask: Short (# Pos::< (# do 22->Value;  #);  #);
     crsrHotSpot: Long (# Pos::< (# do 24->Value;  #);  #);
     crsrXTable: Long (# Pos::< (# do 28->Value;  #);  #);
     crsrID: Long (# Pos::< (# do 32->Value;  #);  #);
     
  #);
CIcon: RecordPeek
  (# iconPMap:
       (# baseAddr: Long (# Pos::< (# do 0->Value;  #);  #);
          rowBytes: Short (# Pos::< (# do 4->Value;  #);  #);
          bounds: Rect (# Pos::< (# do 6->Value;  #);  #);
          pmVersion: Short (# Pos::< (# do 14->Value;  #);  #);
          packType: Short (# Pos::< (# do 16->Value;  #);  #);
          packSize: Long (# Pos::< (# do 18->Value;  #);  #);
          hRes: Long (# Pos::< (# do 22->Value;  #);  #);
          vRes: Long (# Pos::< (# do 26->Value;  #);  #);
          pixelType: Short (# Pos::< (# do 30->Value;  #);  #);
          pixelSize: Short (# Pos::< (# do 32->Value;  #);  #);
          cmpCount: Short (# Pos::< (# do 34->Value;  #);  #);
          cmpSize: Short (# Pos::< (# do 36->Value;  #);  #);
          planeBytes: Long (# Pos::< (# do 38->Value;  #);  #);
          pmTable: Long (# Pos::< (# do 42->Value;  #);  #);
          pmReserved: Long (# Pos::< (# do 46->Value;  #);  #);
          
       #);
     iconMask:
       (# baseAddr: Long (# Pos::< (# do 50->Value;  #);  #);
          rowBytes: Short (# Pos::< (# do 54->Value;  #);  #);
          bounds: Long (# Pos::< (# do 56->Value;  #);  #);
          
       #);
     iconBMap:
       (# baseAddr: Long (# Pos::< (# do 60->Value;  #);  #);
          rowBytes: Short (# Pos::< (# do 64->Value;  #);  #);
          bounds: Long (# Pos::< (# do 66->Value;  #);  #);
          
       #);
     iconData: Long (# Pos::< (# do 70->Value;  #);  #);
     (* iconMaskData: ARRAY [0..0] OF Integer; {icons mask and BitMap data} *)
     
  #);
MatchRec: CStruct
  (# ByteSize::< (# do 10->Value;  #);
     red: Short (# Pos::< (# do 0->Value;  #);  #);
     green: Short (# Pos::< (# do 2->Value;  #);  #);
     blue: Short (# Pos::< (# do 4->Value;  #);  #);
     matchData: Long (# Pos::< (# do 6->Value;  #);  #);
     
  #);
Initgraf: External (# thePort: @Integer;  enter thePort do '$A86E'->PascalTrap;  #);
OpenPort: External (# thePort: @Integer;  enter thePort do '$A86F'->PascalTrap;  #);
InitPort: External (# thePort: @Integer;  enter thePort do '$A86D'->PascalTrap;  #);
ClosePort: External (# thePort: @Integer;  enter thePort do '$A87D'->PascalTrap;  #);
SetPort: External (# thePort: @Integer;  enter thePort do '$A873'->PascalTrap;  #);
GetPort: External (# thePort: ^LongInt;  enter thePort[] do '$A874'->PascalTrap;  #);
GrafDevice: External (# device: @ShortInt;  enter device do '$A872'->PascalTrap;  #);
SetPortBits: External (# portBits: @Integer;  enter portBits do '$A875'->PascalTrap;  #);
PortSize: External
  (# width,height: @ShortInt;  enter (width,height) do '$A876'->PascalTrap;  #);
MovePortTo: External (# l,t: @ShortInt;  enter (l,t) do '$A877'->PascalTrap;  #);
SetOrigin: External (# dh,dv: @ShortInt;  enter (dh,dv) do '$A878'->PascalTrap;  #);
SetClip: External (# rgn: @Integer;  enter rgn do '$A879'->PascalTrap;  #);
GetClip: External (# rgn: @Integer;  enter rgn do '$A87A'->PascalTrap;  #);
ClipRect: External (# r: ^MacRect enter r[] do '$A87B'->PascalTrap;  #);
BackPat: External (# pat: @Integer;  enter pat do '$A87C'->PascalTrap;  #);
InitCursor: External (# do '$A850'->PascalTrap;  #);
SetCursor: External (# cursor: @Integer;  enter cursor do '$A851'->PascalTrap;  #);
HideCursor: External (# do '$A852'->PascalTrap;  #);
ShowCursor: External (# do '$A853'->PascalTrap;  #);
ObscureCursor: External (# do '$A856'->PascalTrap;  #);
HidePen: External (# do '$A896'->PascalTrap;  #);
ShowPen: External (# do '$A897'->PascalTrap;  #);
GetPen: External (# p: ^macPoint enter p[] do '$A89A'->PascalTrap;  #);
GetPenState: External (# penstate: @Integer;  enter penState do '$A898'->PascalTrap;  #);
SetPenState: External (# penstate: @Integer;  enter penState do '$A899'->PascalTrap;  #);
PenSize: External
  (# width,height: @ShortInt;  enter (width,height) do '$A89B'->PascalTrap;  #);
PenMode: External (# p: @ShortInt;  enter p do '$A89C'->PascalTrap;  #);
PenPat: External (# patAddr: @Integer;  enter patAddr do '$A89D'->PascalTrap;  #);
PenNormal: External (# do '$A89E'->PascalTrap;  #);
MoveTo: External (# h,v: @ShortInt;  enter (h,v) do '$A893'->PascalTrap;  #);
Move: External (# dh,dv: @ShortInt;  enter (dh,dv) do '$A894'->PascalTrap;  #);
LineTo: External (# h,v: @ShortInt;  enter (h,v) do '$A891'->PascalTrap;  #);
Line: External (# dh,dv: @ShortInt;  enter (dh,dv) do '$A892'->PascalTrap;  #);
TextFont: External (# font: @ShortInt;  enter font do '$A887'->PascalTrap;  #);
TextFace: External (# face: @ShortInt;  enter face do '$A888'->PascalTrap;  #);
TextMode: External (# mode: @ShortInt;  enter mode do '$A889'->PascalTrap;  #);
TextSize: External (# size: @ShortInt;  enter size do '$A88A'->PascalTrap;  #);
DrawChar: External (# ch: @ShortInt;  enter ch do '$A883'->PascalTrap;  #);
DrawString: External (# s: [1] @char enter s do '$A884'->PascalTrap;  #);
DrawText: External
  (# ptr: @Integer; firstByte,byteCount: @ShortInt; 
  enter (ptr,firstByte,byteCount)
  do '$A885'->PascalTrap; 
  #);
CharWidth: External (# ch,result: @ShortInt;  enter ch do '$A88D'->PascalTrap;  exit result #);
TextWidth: External
  (# ptr: @Integer; firstByte,byteCount,result: @ShortInt; 
  enter (ptr,firstByte,byteCount)
  do '$A886'->PascalTrap; 
  exit result
  #);
StringWidth: External
  (# s: [1] @Char; result: @ShortInt;  enter s do '$A88C'->PascalTrap;  exit result #);
MeasureText: External
  (# ptr,charLocs: @Integer; Count: @ShortInt; 
  enter (count,ptr,charLocs)
  do '$A837'->PascalTrap; 
  #);
GetFontInfo: External (# info: ^fontInfo;  enter info[] do '$A88B'->PascalTrap;  #);
ForeColor: External (# color: @Integer;  enter color do '$A862'->PascalTrap;  #);
BackColor: External (# color: @Integer;  enter color do '$A863'->PascalTrap;  #);
ColorBit: External (# whichBit: @ShortInt;  enter whichBit do '$A864'->PascalTrap;  #);
SetRect: External
  (# Rect: ^MacRect; l,t,r,b: @ShortInt;  enter (Rect[],l,t,r,b) do '$A8A7'->PascalTrap;  #);
OffsetRect: External
  (# r: ^MacRect; dh,dv: @ShortInt;  enter (r[],dh,dv) do '$A8A8'->PascalTrap;  #);
InsetRect: External
  (# r: ^MacRect; dh,dv: @ShortInt;  enter (r[],dh,dv) do '$A8A9'->PascalTrap;  #);
SectRect: External
  (# src1,src2,dest: ^MacRect; result: @Boolean
  enter (src1[],src2[],dest[])
  do '$A8AA'->PascalTrap; 
  exit result
  #);
UnionRect: External
  (# src1,src2,dest: ^MacRect enter (src1[],src2[],dest[]) do '$A8AB'->PascalTrap;  #);
EqualRect: External
  (# r1,r2: ^MacRect; result: @Boolean
  enter (r1[],r2[])
  do '$A8A6'->PascalTrap; 
  exit result
  #);
EmptyRect: External
  (# r: ^MacRect; result: @Boolean enter r[] do '$A8AE'->PascalTrap;  exit result #);
FrameRect: External (# r: ^MacRect enter r[] do '$A8A1'->PascalTrap;  #);
PaintRect: External (# r: ^MacRect enter r[] do '$A8A2'->PascalTrap;  #);
EraseRect: External (# r: ^MacRect enter r[] do '$A8A3'->PascalTrap;  #);
InvertRect: External (# r: ^MacRect enter r[] do '$A8A4'->PascalTrap;  #);
FillRect: External
  (# r: ^MacRect; patAdr: @Integer;  enter (r[],patAdr) do '$A8A5'->PascalTrap;  #);
FrameOval: External (# r: ^MacRect enter r[] do '$A8B7'->PascalTrap;  #);
PaintOval: External (# r: ^MacRect enter r[] do '$A8B8'->PascalTrap;  #);
EraseOval: External (# r: ^MacRect enter r[] do '$A8B9'->PascalTrap;  #);
InvertOval: External (# r: ^MacRect enter r[] do '$A8BA'->PascalTrap;  #);
FillOval: External
  (# r: ^MacRect; patAdr: @Integer;  enter (r[],patAdr) do '$A8BB'->PascalTrap;  #);
FrameRoundRect: External
  (# r: ^MacRect; ow,oh: @ShortInt;  enter (r[],ow,oh) do '$A8B0'->PascalTrap;  #);
PaintRoundRect: External
  (# r: ^MacRect; ow,oh: @ShortInt;  enter (r[],ow,oh) do '$A8B1'->PascalTrap;  #);
EraseRoundRect: External
  (# r: ^MacRect; ow,oh: @ShortInt;  enter (r[],ow,oh) do '$A8B2'->PascalTrap;  #);
InvertRoundRect: External
  (# r: ^MacRect; ow,oh: @ShortInt;  enter (r[],ow,oh) do '$A8B3'->PascalTrap;  #);
FillRoundRect: External
  (# r: ^MacRect; patAdr: @Integer; ow,oh: @ShortInt; 
  enter (r[],ow,oh,patAdr)
  do '$A8B4'->PascalTrap; 
  #);
FrameArc: External
  (# r: ^MacRect; ow,oh: @ShortInt;  enter (r[],ow,oh) do '$A8BE'->PascalTrap;  #);
PaintArc: External
  (# r: ^MacRect; ow,oh: @ShortInt;  enter (r[],ow,oh) do '$A8BF'->PascalTrap;  #);
EraseArc: External
  (# r: ^MacRect; ow,oh: @ShortInt;  enter (r[],ow,oh) do '$A8C0'->PascalTrap;  #);
InvertArc: External
  (# r: ^MacRect; ow,oh: @ShortInt;  enter (r[],ow,oh) do '$A8C1'->PascalTrap;  #);
FillArc: External
  (# r: ^MacRect; patAdr: @Integer; ow,oh: @ShortInt; 
  enter (r[],ow,oh,patAdr)
  do '$A8C2'->PascalTrap; 
  #);
NewRgn: External (# theHandle: @Integer;  do '$A8D8'->PascalTrap;  exit theHandle #);
OpenRgn: External (# do '$A8DA'->PascalTrap;  #);
CloseRgn: External (# theHandle: @Integer;  enter theHandle do '$A8DB'->PascalTrap;  #);
DisposeRgn: External (# theHandle: @Integer;  enter theHandle do '$A8D9'->PascalTrap;  #);
CopyRgn: External (# s,d: @Integer;  enter (s,d) do '$A8DC'->PascalTrap;  #);
SetEmptyRgn: External (# theHandle: @Integer;  enter theHandle do '$A8DD'->PascalTrap;  #);
SetRectRgn: External
  (# theHandle: @Integer; l,t,r,b: @ShortInt; 
  enter (theHandle,l,t,r,b)
  do '$A8DE'->PascalTrap; 
  #);
RectRgn: External
  (# theHandle: @Integer; r: ^MacRect enter (theHandle,r[]) do '$A8DF'->PascalTrap;  #);
OffsetRgn: External
  (# theHandle: @Integer; dh,dv: @ShortInt; 
  enter (theHandle,dh,dv)
  do '$A8E0'->PascalTrap; 
  #);
InsetRgn: External
  (# theHandle: @Integer; dh,dv: @ShortInt; 
  enter (theHandle,dh,dv)
  do '$A8E1'->PascalTrap; 
  #);
SectRgn: External
  (# rgna,rgnb,rgnd: @Integer;  enter (rgna,rgnb,rgnd) do '$A8E4'->PascalTrap;  #);
UnionRgn: External
  (# rgna,rgnb,rgnd: @Integer;  enter (rgna,rgnb,rgnd) do '$A8E5'->PascalTrap;  #);
DiffRgn: External
  (# rgna,rgnb,rgnd: @Integer;  enter (rgna,rgnb,rgnd) do '$A8E6'->PascalTrap;  #);
XorRgn: External
  (# rgna,rgnb,rgnd: @Integer;  enter (rgna,rgnb,rgnd) do '$A8E7'->PascalTrap;  #);
RectInRgn: External
  (# r: ^MacRect; rgn: @Integer; result: @Boolean
  enter (r[],rgn)
  do '$A8E9'->PascalTrap; 
  exit result
  #);
EqualRgn: External
  (# rgna,rgnB: @Integer; result: @Boolean
  enter (rgnA,rgnB)
  do '$A8E3'->PascalTrap; 
  exit result
  #);
EmptyRgn: External
  (# rgn: @Integer; result: @Boolean enter rgn do '$A8E2'->PascalTrap;  exit result #);
FrameRgn: External (# theHandle: @Integer;  enter theHandle do '$A8D2'->PascalTrap;  #);
PaintRgn: External (# theHandle: @Integer;  enter theHandle do '$A8D3'->PascalTrap;  #);
EraseRgn: External (# theHandle: @Integer;  enter theHandle do '$A8D4'->PascalTrap;  #);
InvertRgn: External (# theHandle: @Integer;  enter theHandle do '$A8D5'->PascalTrap;  #);
FillRgn: External
  (# theHandle,patAddr: @Integer;  enter (theHandle,patAddr) do '$A8D6'->PascalTrap;  #);
ScrollRect: External
  (# r: ^MacRect; dh,dv: @ShortInt; updateRgn: @Integer; 
  enter (r[],dh,dv,updateRgn)
  do '$A8EF'->PascalTrap; 
  #);
CopyBits: External
  (# scrBitsAddr,dstBitsAddr,maskRgn: @Integer; srcRect,destRect: ^MacRect; mode: @ShortInt; 
  enter (scrBitsAddr,dstBitsAddr,srcRect[],destRect[],mode,maskRgn)
  do '$A8EC'->PascalTrap; 
  #);
SeedFill: External
  (# srcptr,dstPtr: @Integer; srcR,dstR,height,words,seedH,seedW: @ShortInt; 
  enter (srcPtr,dstPtr,srcR,dstR,height,words,seedH,seedW)
  do '$A839'->PascalTrap; 
  #);
CalcMask: External
  (# srcptr,dstPtr: @Integer; srcR,dstR,height,words: @ShortInt; 
  enter (srcPtr,dstPtr,srcR,dstR,height,words)
  do '$A838'->PascalTrap; 
  #);
CopyMask: External
  (# scrBitsAddr,maskBitsAddr,dstBitsAddr: @Integer; srcRect,maskRect,destRect: ^MacRect; 
  enter (scrBitsAddr,maskBitsAddr,dstBitsAddr,srcRect[],maskRect[],destRect[])
  do '$A817'->PascalTrap; 
  #);
OpenPicture: External
  (# picFrame: ^MacRect; picHandle: @Integer; 
  enter picFrame[]
  do '$A8F3'->PascalTrap; 
  exit picHandle
  #);
PicComment: External
  (# kind,dataSize: @ShortInt; data: @Integer; 
  enter (kind,dataSize,data)
  do '$A8F2'->PascalTrap; 
  #);
ClosePicture: External (# do '$A8F4'->PascalTrap;  #);
DrawPicture: External
  (# pic: @Integer; dstRect: ^MacRect enter (pic,dstRect[]) do '$A8F6'->PascalTrap;  #);
KillPicture: External (# pic: @Integer;  enter pic do '$A8F6'->PascalTrap;  #);
OpenPoly: External (# polyHandle: @Integer;  do '$A8CB'->PascalTrap;  exit polyHandle #);
ClosePoly: External (# do '$A8CC'->PascalTrap;  #);
KillPoly: External (# polyHandle: @Integer;  enter polyHandle do '$A8CD'->PascalTrap;  #);
OffsetPoly: External
  (# polyHandle: @Integer; dh,dv: @ShortInt; 
  enter (polyHandle,dh,dv)
  do '$A8CE'->PascalTrap; 
  #);
FramePoly: External (# polyHandle: @Integer;  enter polyHandle do '$A8C6'->PascalTrap;  #);
PaintPoly: External (# polyHandle: @Integer;  enter polyHandle do '$A8C7'->PascalTrap;  #);
ErasePoly: External (# polyHandle: @Integer;  enter polyHandle do '$A8C8'->PascalTrap;  #);
InvertPoly: External (# polyHandle: @Integer;  enter polyHandle do '$A8C9'->PascalTrap;  #);
FillPoly: External
  (# polyHandle: @Integer; patAdr: @Integer; 
  enter (polyHandle,patAdr)
  do '$A8CA'->PascalTrap; 
  #);
SetPt: External (# p: ^macPoint; h,v: @ShortInt;  enter (p[],h,v) do '$A880'->PascalTrap;  #);
LocalToGlobal: External (# p: ^macPoint enter p[] do '$A870'->PascalTrap;  #);
GlobalToLocal: External (# p: ^macPoint enter p[] do '$A871'->PascalTrap;  #);
Random: External (# result: @ShortInt;  do '$A861'->PascalTrap;  exit result #);
StuffHex: External
  (# thingPtr: @Integer; s: [1] @char enter (thingPtr,s) do '$A866'->PascalTrap;  #);
GetPixel: External
  (# h,v,result: @ShortInt;  enter (h,v) do '$A865'->PascalTrap;  exit result #);
ScalePt: External
  (# p: ^macPoint; srcRect,dstRect: ^MacRect
  enter (p[],srcRect[],dstRect[])
  do '$A8F8'->PascalTrap; 
  #);
MapPt: External
  (# p: ^macPoint; srcRect,dstRect: ^MacRect
  enter (p[],srcRect[],dstRect[])
  do '$A8F9'->PascalTrap; 
  #);
MapRect: External
  (# r: ^MacRect; srcRect,dstRect: ^MacRect
  enter (r[],srcRect[],dstRect[])
  do '$A8FA'->PascalTrap; 
  #);
MapRgn: External
  (# r: @Integer; srcRect,dstRect: ^MacRect
  enter (r,srcRect[],dstRect[])
  do '$A8FB'->PascalTrap; 
  #);
MapPoly: External
  (# p: @Integer; srcRect,dstRect: ^MacRect
  enter (p,srcRect[],dstRect[])
  do '$A8FC'->PascalTrap; 
  #);
Addpt: External
  (# src: @Integer; dst: ^macPoint enter (src,dst[]) do '$A87E'->PascalTrap;  #);
Subpt: External
  (# src: @Integer; dst: ^macPoint enter (src,dst[]) do '$A87F'->PascalTrap;  #);
EqualPt: External
  (# pt1,pt2: @Integer; result: @Boolean
  enter (pt1,pt2)
  do '$A881'->PascalTrap; 
  exit result
  #);
PtInRect: External
  (# pt1: @Integer; r: ^MacRect; result: @Boolean
  enter (pt1,r[])
  do '$A8AD'->PascalTrap; 
  exit result
  #);
Pt2Rect: External
  (# pt1,pt2: @Integer; r: ^MacRect enter (pt1,pt2,r[]) do '$A8AC'->PascalTrap;  #);
PtToAngle: External
  (# pt1: @Integer; r: ^MacRect; angle: ^CStruct
  enter (r[],pt1,angle[])
  do '$A8C3'->PascalTrap; 
  #);
PtInRgn: External
  (# pt1: @Integer; r: @Integer; result: @Boolean
  enter (pt1,r)
  do '$A8E8'->PascalTrap; 
  exit result
  #);
QDError: External (# result: @ShortInt;  do '$AA40'->PascalTrap;  exit result #);
GetForeColor: External (# c: ^RGBColor enter c[] do '$AA19'->PascalTrap;  #);
GetBackColor: External (# c: ^RGBColor enter c[] do '$AA1A'->PascalTrap;  #);
(*  Color quickdraw and stuff  *)
openCPort: External (# thePort: @Integer;  enter thePort do '$AA00'->PascalTrap;  #);
initCPort: External (# thePort: @Integer;  enter thePort do '$AA01'->PascalTrap;  #);
closeCPort: External (# thePort: @Integer;  enter thePort do '$AA02'->PascalTrap;  #);
RGBForeColor: External (# c: ^RGBColor enter c[] do '$AA14'->PascalTrap;  #);
RGBBackColor: External (# c: ^RGBColor enter c[] do '$AA15'->PascalTrap;  #);
SetCPixel: External
  (# h,v: @ShortInt; c: ^RGBColor enter (h,v,c[]) do '$AA16'->PascalTrap;  #);
GetCPixel: External
  (# h,v: @ShortInt; c: ^RGBColor enter (h,v,c[]) do '$AA17'->PascalTrap;  #);
AllocCursor: External (# do '$AA1D'->PascalTrap;  #);
BackPixPat: External (# pp: @Integer;  enter pp do '$AA0B'->PascalTrap;  #);
Color2Index: External
  (# myColor: ^RGBColor; result: @Integer; 
  enter myColor[]
  do '$AA33'->PascalTrap; 
  exit result
  #);
DisPosCTable: External (# cTable: @Integer;  enter cTable do '$AA24'->PascalTrap;  #);
DisPosPixMap: External (# pm: @Integer;  enter pm do '$AA04'->PascalTrap;  #);
FillCArc: External
  (# r: ^MacRect; startAngle,arcAngle: @ShortInt; pp: @Integer; 
  enter (r[],startAngle,arcAngle,pp)
  do '$AA11'->PascalTrap; 
  #);
FillCRect: External (# r: ^MacRect; pp: @Integer;  enter (r[],pp) do '$AA0E'->PascalTrap;  #);
GetCTSeed: External (# seed: @Integer;  do '$AA28'->PascalTrap;  exit seed #);
GetPixPat: External
  (# patID: @ShortInt; pp: @Integer;  enter patID do '$AA0C'->PascalTrap;  exit pp #);
NewPixMap: External (# pp: @Integer;  do '$AA03'->PascalTrap;  exit pp #);
ProtectEntry: External
  (# index: @ShortInt; protect: @Boolean;  enter (index,protect) do '$AA3D'->PascalTrap;  #);
SetCCursor: External (# cCrsr: @Integer;  enter cCrsr do '$AA1C'->PascalTrap;  #);
SpaceExtra: External (# extra: @Integer;  enter extra do '$A88E'->PascalTrap;  #);
BitMapToRegion: External
  (# rgn: @Integer; bMap: @Integer; error: @Integer; 
  enter (rgn,bMap)
  do '$A8D7'->PascalTrap; 
  exit error
  #);
CharExtra: External (# extra: @Integer;  enter extra do '$AA23'->PascalTrap;  #);
CopyPixMap: External
  (# srcPM,dstPM: @Integer;  enter (srcPM,dstPM) do '$AA05'->PascalTrap;  #);
DisPosCCursor: External (# cCrsr: @Integer;  enter cCrsr do '$AA26'->PascalTrap;  #);
DisPosPixPat: External (# pp: @Integer;  enter pp do '$AA08'->PascalTrap;  #);
FillCOval: External (# pp: @Integer; r: ^MacRect;  enter (r[],pp) do '$AA0F'->PascalTrap;  #);
FillCRgn: External (# rgn,pp: @Integer;  enter (rgn,pp) do '$AA12'->PascalTrap;  #);
GetCCursor: External
  (# crsrID: @ShortInt; CCrsrHandle: @Integer; 
  enter crsrID
  do '$AA1B'->PascalTrap; 
  exit CCrsrHandle
  #);
GetDeviceList: External (# GDHandle: @Integer;  do '$AA29'->PascalTrap;  exit GDHandle #);
GetGDevice: External (# GDHandle: @Integer;  do '$AA32'->PascalTrap;  exit GDHandle #);
GetMaxDevice: External
  (# globalRect: ^MacRect; GDHandle: @Integer; 
  enter globalRect[]
  do '$AA27'->PascalTrap; 
  exit GDHandle
  #);
HiliteColor: External (# color: ^RGBColor;  enter color[] do '$AA22'->PascalTrap;  #);
MakeITable: External
  (# cTabH,iTabH: @Integer; res: @ShortInt; 
  enter (cTabH,iTabH,res)
  do '$AA39'->PascalTrap; 
  #);
NewPixPat: External (# PixPatHandle: @Integer;  do '$AA07'->PascalTrap;  exit PixPatHandle #);
OpColor: External (# color: ^RGBColor;  enter color[] do '$AA21'->PascalTrap;  #);
PenPixPat: External (# PixPatHandle: @Integer;  enter PixPatHandle do '$AA0A'->PascalTrap;  #);
PlotCIcon: External
  (# mr: ^MacRect; icon: @Integer;  enter (mr[],icon) do '$AA1F'->PascalTrap;  #);
RealColor: External
  (# color: ^RGBColor; result: @Boolean; 
  enter color[]
  do '$AA36'->PascalTrap; 
  exit result
  #);
ReserveEntry: External
  (# index: @ShortInt; reserve: @Boolean;  enter (index,reserve) do '$AA3E'->PascalTrap;  #);
SeedCFill: External
  (# srcBits,dstBits,matchProc,matchData: @Integer;
     srcRect,dstRect: ^MacRect;
     seedH,seedV: @ShortInt;
     
  enter (srcBits,dstBits,srcRect[],dstRect[],matchProc,matchData)
  do '$AA50'->PascalTrap; 
  #);
SetClientID: External (# id: @Integer;  enter id do '$AA3C'->PascalTrap;  #);
SetEntries: External
  (# start,count: @ShortInt; aTable: @Integer; 
  enter (start,count,aTable)
  do '$AA3F'->PascalTrap; 
  #);
SetPortPix: External
  (# PixMapHandle: @Integer;  enter PixMapHandle do '$AA06'->PascalTrap;  #);
CalcCMask: External
  (# srcBits,dstBits,matchProc,matchData: @Integer;
     srcRect,dstRect: ^MacRect;
     seedRGB: ^RGBColor;
     
  enter (srcBits,dstBits,srcRect[],dstRect[],seedRGB[],matchProc,matchData)
  do '$AA4F'->PascalTrap; 
  #);
CopyPixPat: External
  (# srcPP,dstPP: @Integer;  enter (srcPP,dstPP) do '$AA09'->PascalTrap;  #);
DisPosCIcon: External (# theIcon: @Integer;  enter theIcon do '$AA25'->PascalTrap;  #);
DisPosGDevice: External (# GDHandle: @Integer;  enter GDHandle do '$AA30'->PascalTrap;  #);
FillCPoly: External
  (# poly,PixPatHandle: @Integer;  enter (poly,PixPatHandle) do '$AA13'->PascalTrap;  #);
FillCRoundRect: External
  (# mr: ^MacRect; ovalWidth,ovalHeight: @ShortInt; PixPatHandle: @Integer; 
  enter (mr[],ovalWidth,ovalHeight,PixPatHandle)
  do '$AA10'->PascalTrap; 
  #);
GetCIcon: External
  (# iconID: @ShortInt; CIconHandle: @Integer; 
  enter iconID
  do '$AA1E'->PascalTrap; 
  exit CIconHandle
  #);
GetCTable: External
  (# ctID: @ShortInt; CTabHandle: @Integer; 
  enter ctID
  do '$AA18'->PascalTrap; 
  exit CTabHandle
  #);
GetMainDevice: External (# GDHandle: @Integer;  do '$AA2A'->PascalTrap;  exit GDHandle #);
GetNextDevice: External
  (# curDevice,nextDevice: @Integer; 
  enter curDevice
  do '$AA2B'->PascalTrap; 
  exit nextDevice
  #);
GetSubTable: External
  (# myColors,targetTbl: @Integer; iTabRes: @ShortInt; 
  enter (myColors,iTabRes,targetTbl)
  do '$AA37'->PascalTrap; 
  #);
Index2Color: External
  (# index: @Integer; aColor: ^RGBColor;  enter (index,aColor[]) do '$AA34'->PascalTrap;  #);
InitGDevice: External
  (# qdRefNum: @ShortInt; mode,gdh: @Integer; 
  enter (qdRefNum,mode,gdh)
  do '$AA2E'->PascalTrap; 
  #);
MakeRGBPat: External
  (# ppxPatHandle: @Integer; myColor: ^RGBColor; 
  enter (ppxPatHandle,myColor[])
  do '$AA0D'->PascalTrap; 
  #);
NewGDevice: External
  (# refNum: @ShortInt; mode: @Integer;  enter (refNum,mode) do '$AA2F'->PascalTrap;  #);
RestoreEntries: External
  (# srcTable,dstTable: @Integer; selection: ^CStruct; 
  enter (srcTable,dstTable,selection[])
  do '$AA4A'->PascalTrap; 
  #);
SaveEntries: External
  (# srcTable,resultTable: @Integer; selection: ^CStruct; 
  enter (srcTable,resultTable,selection[])
  do '$AA49'->PascalTrap; 
  #);
SetDeviceAttribute: External
  (# gdh: @Integer; attribute: @ShortInt; Value: @Boolean; 
  enter (gdh,attribute,Value)
  do '$AA2D'->PascalTrap; 
  #);
SetGDevice: External (# gd: @Integer;  enter gd do '$AA31'->PascalTrap;  #);
TestDeviceAttribute: External
  (# gdh: @Integer; attribute: @ShortInt; flag: @Boolean; 
  enter (gdh,attribute)
  do '$AA2C'->PascalTrap; 
  exit flag
  #);
  

