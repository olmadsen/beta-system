ORIGIN 'mactypes';
INCLUDE 'memory'
-- lib: Attributes --
FInfo: CStruct
  (# ByteSize::< (# do 16->value #);
     fdType: Long (# Pos::< (# do 0->value #) #);
     fdCreator: Long (# Pos::< (# do 4->value #) #);
     fdFlags: Short (# Pos::< (# do 8->value #) #);
     fdLocation: Long (# Pos::< (# do 10->value #) #);
     fdFldr: Short (# Pos::< (# do 14->value #) #);
     Type: @
       (# theType: [4] @Char; 
       enter (# enter theType do theType->ToResType->fdType;  #)
       exit (# do fdType->FromResType->theType;  exit theType #)
       #);
     Creator: @
       (# theCreator: [4] @Char; 
       enter (# enter theCreator do theCreator->ToResType->fdCreator;  #)
       exit (# do fdCreator->FromResType->theCreator;  exit theCreator #)
       #);
     
  #);
FSSpec: CStruct
  (# ByteSize::< (# do 70->value;  #);
     vRefNum: Short (# Pos::< (# do 0->value;  #);  #);
     parID: Long (# Pos::< (# do 2->value;  #);  #);
     name:
       (# nameStart: (# exit 6 #);
          set:
            (# itsName: ^Text; 
            enter itsName[]
            do (if (itsName[] <> NONE) AND (itsName.lgth > 0) then
				   (nameStart,itsName.lgth)->putByte;
				   (@@ itsName.T[1],@@ R[2]+3,itsName.lgth)->blockmove;
				else
					(nameStart,0)->putByte;
				if);
               
            #);
          get:
            (# itsName: ^Text; len: @Integer; 
            do
               &Text[]->itsName[];
               nameStart->getByte->len;
			   (if len > 0 then
			   	  len ->itsName.T.new;
				   (@@ R[2]+3,@@ itsName.T[1],len)->blockmove;
				   itsName.T.range->itsName.lgth->itsName.pos;
				if);
               
            exit itsName[]
            #);
          
       enter set
       exit get
       #);
     
  #);
GetFInfo: external
  (# fileName: [1] @Char; vRefNum: @ShortInt; fndrInfo: ^FInfo; OSErr: @ShortInt; 
  enter (fileName,vRefNum,fndrInfo[])
  do callpascal
  exit OSErr
  #);
SetFInfo: external
  (# fileName: [1] @Char; vRefNum: @ShortInt; fndrInfo: ^FInfo; OSErr: @ShortInt; 
  enter (fileName,vRefNum,fndrInfo[])
  do callpascal
  exit OSErr
  #);
Create: External
  (# fileName: [1] @Char; vRefNum: @ShortInt; Creator,Type: @Integer; OSErr: @ShortInt; 
  enter (fileName,vRefNum,Creator,Type)
  do callpascal
  exit OSErr
  #);
DirCreate: External
  (# vRefNum: @ShortInt;
     parentDirID: @Integer;
     directoryName: [1] @Char;
     createdDirID: ^LongInt;
     error: @Integer;
     
  enter (vRefNum,parentDirID,directoryName,createdDirID[])
  do (*'DIRCREATE'->*) callpascal
  exit error
  #);
FSDelete: External
  (# fileName: [1] @Char; vRefNum: @ShortInt; error: @Integer; 
  enter (fileName,vRefNum)
  do callpascal
  exit error
  #);
FSMakeFSSpec: external
  (# vRefNum: @ShortInt;
     dirID: @Integer;
     filename: [1] @Char;
     spec: ^FSSpec;
     result: @ShortInt;
     
  enter (vRefNum,dirID,filename,spec[])
  do '{$303C,$0001,$AA52}'->pascalTrap; 
  exit result
  #);
FSpExchangeFiles: External
  (# source,dest: ^FSSpec; result: @ShortInt; 
  enter (source[],dest[])
  do '{$303C,$000F,$AA52}'->pascalTrap
  exit result
  #);
FSpOpenDF: External
  (# spec: ^FSSpec; permission: @Char; refNum: ^ShortRef; result: @ShortInt; 
  enter (spec[],permission,refNum[])
  do '{$303C,$0002,$AA52}'->pascalTrap
  exit result
  #);
FSpOpenRF: External
  (# spec: ^FSSpec; permission: @Char; refNum: ^ShortRef; result: @ShortInt; 
  enter (spec[],permission,refNum[])
  do '{$303C,$0003,$AA52}'->pascalTrap
  exit result
  #);
FSpCreate: external
  (# spec: ^FSSpec; creator,fileType: @Integer; scriptTag: @ShortInt; result: @ShortInt; 
  enter (spec[],creator,fileType,scriptTag)
  do '{$303C,$0004,$AA52}'->pascalTrap
  exit result
  #);
FSpDirCreate: external
  (# spec: ^FSSpec; scriptTag: @ShortInt; createdDirID: ^LongInt; result: @ShortInt; 
  enter (spec[],scriptTag,createdDirID[])
  do '{$303C,$0005,$AA52}'->pascalTrap
  exit result
  #);
FSpDelete: external
  (# spec: ^FSSpec; result: @ShortInt; 
  enter spec[]
  do '{$303C,$0006,$AA52}'->pascalTrap
  exit result
  #);
FSpGetFInfo: external
  (# spec: ^FSSpec; fndrInfo: ^FInfo; OSErr: @ShortInt; 
  enter (spec[],fndrInfo[])
  do '{$303C,$0007,$AA52}'->pascalTrap
  exit OSErr
  #);
FSpSetFInfo: external
  (# spec: ^FSSpec; fndrInfo: ^FInfo; OSErr: @ShortInt; 
  enter (spec[],fndrInfo[])
  do '{$303C,$0008,$AA52}'->pascalTrap
  exit OSErr
  #);
FSpSetFLock: external
  (# spec: ^FSSpec; result: @ShortInt; 
  enter spec[]
  do '{$303C,$0009,$AA52}'->pascalTrap
  exit result
  #);
FSpRstFLock: external
  (# spec: ^FSSpec; result: @ShortInt; 
  enter spec[]
  do '{$303C,$000A,$AA52}'->pascalTrap
  exit result
  #);
FSpRename: external
  (# spec: ^FSSpec; newName: [1] @Char; result: @ShortInt; 
  enter (spec[],newName)
  do '{$303C,$000B,$AA52}'->pascalTrap
  exit result
  #);
HCreate: external
  (# vRefNum: @shortInt;
     dirID: @integer;
     fileName: [1] @Char;
     creator,fileType: @Integer;
     result: @ShortInt;
     
  enter (vRefNum,dirID,fileName,creator,fileType)
  do (*'HCREATE'->*) callpascal
  exit result
  #);
HDelete: external
  (# vRefNum: ^ShortRef; dirID: ^LongInt; fileName: [1] @Char; result: @ShortInt; 
  enter (vRefNum,dirID,fileName)
  do (*'HDELETE'->*) callpascal
  exit result
  #);
HGetVol: external
  (# volName: ^PascalString; vRefNum: ^ShortRef; dirID: ^LongInt; result: @ShortInt; 
  enter (volName[],vRefNum[],dirID[])
  do callpascal
  exit result
  #);
fseek: External
  (# macStream,p,mode,status: @Integer;  enter (macStream,p,mode) do CallC exit status #);
ftell: External (# macStream,pos: @Integer;  enter macStream do CallC exit pos #);
fread: External
  (# addr,size,n,macStream: @Integer;
     (* n is no of elems. to read. *)
     n1: @Integer;
     (* The number of elements successfully read. *)
     
  enter (addr,size,n,macStream)
  do CallC
  exit n1
  #);
fwrite: External
  (# addr,size,n,macStream: @Integer;
     (* n is no of elems. to write. *)
     n1: @Integer;
     (* The number of elements successfully written. *)
     
  enter (addr,size,n,macStream)
  do CallC
  exit n1
  #);
fflush: External (# macStream,status: @Integer;  enter macStream do CallC exit status #);
fclose: External (# macStream,status: @Integer;  enter macStream do CallC exit status #);
fputc: External
  (# macStream: @Integer; ch: @Integer; status: @Integer; 
  enter (ch,macStream)
  do CallC
  exit status
  #);
fputs: External
  (# macStream: @Integer; T: @Integer; status: @Integer; 
  enter (T,macStream)
  do CallC
  exit status
  #);
fgetc: External (# macStream: @Integer; ch: @Integer;  enter macStream do CallC exit ch #);
  

