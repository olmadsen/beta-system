ORIGIN 'mactypes';
INCLUDE 'memory';

-- Lib: Attributes --
ScrapStuff: ToolboxRecord
  (# scrapSize: long (# Pos::< (# do 0->Value;  #);  #);
     scrapHandle: long (# Pos::< (# do 4->Value;  #);  #);
     scrapCount: short (# Pos::< (# do 8->Value;  #);  #);
     scrapState: short (# Pos::< (# do 10->Value;  #);  #);
     scrapName: long (# Pos::< (# do 12->Value;  #);  #);
     
  #);
InfoScrap: External (# res: @Integer;  do '$A9F9'->PascalTrap;  exit res #);
UnloadScrap: External (# res: @Integer;  do '$A9FA'->PascalTrap;  exit res #);
LoadScrap: External (# res: @Integer;  do '$A9FB'->PascalTrap;  exit res #);
ZeroScrap: External (# res: @Integer;  do '$A9FC'->PascalTrap;  exit res #);
GetScrap: External
  (# hDest,theType,res: @Integer; offSet: ^longInt; 
  enter (hDest,theType,offSet[])
  do '$A9FD'->PascalTrap; 
  exit res
  #);
PutScrap: External
  (# length,resType,source,res: @Integer; 
  enter (length,resType,source)
  do '$A9FE'->PascalTrap; 
  exit res
  #);
  

GetScrapAsText:
	(#	length: @integer;
		offset: @longInt;
		resType: @integer;;
		textHndl: @integer;
		address: @integer;
		txt: ^text;
		type: [4] @char;
	enter type
	do type -> toResType -> resType;
		0 -> NewHandle -> textHndl;
		(textHndl, resType, offset[]) -> GetScrap -> length;
		&text[] -> txt[];
		(if length > 0 then
			length -> txt.extend;
			textHndl -> TOS'%adrGetLong' -> address;
			(address,@@txt.T[1],length) -> BlockMove;
			length -> txt.lgth -> txt.pos;
		if);
		textHndl -> DisposeHandle;
	exit txt[]
	#);
		
PutTextScrap:
	(# data: ^text;
		type: [4] @char;
		resType: @integer;
		ignore: @integer;
	enter (data[], type)
	do type -> toResType -> resType;
		(if data.lgth > 0 then
			(data.lgth, resType, @@data.T[1]) -> PutScrap -> ignore;
		if);
	#);