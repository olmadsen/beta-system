Communication protocol between sif and freja.

Application commands (global) in Sif:
=====================================

off:
# 0 off
  turns off the notifications from Sif
on:
# 0 on 
  turns on the notifications from Sif

openGroup: * currently not used
# 0 openGroup <name>
  opens the fragment group <name> 
  a full path can be used, else local to current directory
! <editorId> openGroup <ok>
  <ok> is a boolean 

openForm:  
# 0 openForm <name> <index>
  opens an editor instance on the fragment form <name> and selects the node
  specified by <index>, if <index> is zero the root is selected.
  If the editor already is instantiated, the node will only be selected.
  
! 0 openForm <ok> [<editorId>] 
  if non-ok there is no editorId

newBETAProgram:
# 0 newBETAProgram <name>
! <editorId> openGroup <ok>

newBETALib:
# 0 newBETALib <name>
! <editorId> openGroup <ok>

quit:  
# 0 quit
closes all Freja editors,
deletes the corresponding .ast# files,
and finally quits Sif
NB! no feedback, Sif is closing the socket

closeComm:  
# 0 closeComm
NB! no feedback, Sif is closing the socket

save:
# 0 save 
creates .ast~ files and new .bet files for all Freja editors.
deletes the corresponding .ast# files.
! <editorId> save <ok>

autoSave:
# 0 autoSave 
creates .ast# files for all Freja editors.
! <editorId> save <ok>


Fragment form specific commands (commands to editor instances) in Sif: 
======================================================================

save * currently not used
# <editorId> save 
  saves the group that this fragment belongs to
! <editorId> save <ok>
 
undo:
# <editorId> undo
  undoes the last change (only one step)
! <editorId> undo <ok>

cut:  
# <editorId> cut
! <editorId> cut <ok>

copy:  
# <editorId> copy 
! <editorId> copy <ok>

paste:  
# <editorId> paste
! <editorId> paste <ok>

before:  
# <editorId> before
  inserts a list element nonterminal before current focus
! <editorId> before <ok>

after:  
# <editorId> after
  inserts a list element nonterminal after current focus
! <editorId> after <ok>

expandAfter:  
# <editorId> expandAfter <synCatNo>
  This is a composite command:
  1. inserts a list element nonterminal after current focus
  2. expands the nonterminal according to <synCatNo>
     NB!! expects currently only PatternDecl
  3. selects the AttributeDeclOpt nonterminal in the expanded construct
! <editorId> expandAfter <ok>

parseAfter:  
# <editorId> parseAfter <index> <synCatNo> <parseText>
  This is a composite command:
  1. inserts a list element nonterminal after the list element <index>
  2. parses the <parseText> according to <synCatNo>
  3. selects the newly created node: <afterIndex> 
     (NB! no parse errors allowed!)
! <editorId> parseAfter <ok> <afterIndex>

changeFocus:  
# <editorId> changeFocus <index> <length>

  selects the node at <index> with length <length>
  <length> is used for sublists. if only one must be selected
  <length> must be 1.
  
! <editorId> changeFocus <ok> <editStatus>

   where

  <editStatus> ::= <editType> <editMenuStatus> [{<synCatNo> <synCatName>}+]
  
  <editType> ::| 'expanded' | 'unexpNormal' | 'unexpOptional'
  
  <editMenuStatus> ::= <undoPermit> <pastePermit> <listInsertPermit> (three booleans)
  
  The last part is only used if <editType> is 'unexpNormal' or 'unexpOptional'
  See the commands expandNormal and expandOptional.
  <synCatName> is a text and <synCatNo> is an integer. 
  "1 Empty" means that the nonterminal can be derived empty.

getStatus:  
# <editorId> getStatus 
  returns the current selection and editStatus in this editor 
! <editorId> getStatus <ok> <index> <length> <editStatus>

expandNormal:  
# <editorId> expandNormal <synCatNo>
  expands (derives) the nonterminal at current focus with production no <synCatNo>
! <editorId> expandNormal <ok>

expandOptional:  
# <editorId> expandOptional <synCatNo>
  if <synCatNo> is 1 the nonterminal at current focus is derived empty
  else it is expanded with production no <synCatNo>
! <editorId> expandOptional <ok>

expandLexem:  
# <editorId> expandLexem <text>
  expands the lexem at current focus with <text>
! <editorId> expandLexem <ok>

insertOptionals:  
# <editorId> insertOptionals
  inserts optional nonterminals in current focus
! <editorId> insertOptionals  <ok>

removeOptionals:  
# <editorId> removeOptionals
  removes optional nonterminals in current focus
! <editorId> removeOptionals  <ok>

startLink:
# <editorId> startLink
  adds a link anchor to the component of this fragment form
  current focus defines the anchor
! <editorId> startLink <ok>

endLink:
# <editorId> endLink
  adds a link anchor to the component of this fragment form
  current focus defines the anchor
  links kan be multiheaded
! <editorId> endLink <ok>

getAnchors:  
# <editorId> getAnchors 
  returns a list of anchors in this fragmentform
! <editorId> getAnchors <ok> <noOfAnchors> [ <index> ] *

followLink:
# <editorId> followLink <index>
  follows the link if current focus <index> has an anchor
! <editorId> followLink <ok>

check: 
# <editorId> check
calls the checker on the fragment group of the editor indicated by <editorId>
currently possible semantic errors are not report in the status.
<ok> tells wheter there are semantic errors.
Which fragment groups that have been checked is reported in 
the groupCheced command that is send from Sif after the checking
! <editorId> check <ok>

parse: 
# <editorId> parse <index> <parsetext>
  parses the text <parsetext> according to the node <index>, 
  if no parse errors <ok> is true, else <errorpos> contains
  the position of the error in the text and <parseErrorText>
  the error message
! <editorId> parse <ok> <errorpos> <parseErrorText>

prettyprint:
#  <editorId> prettyprint <index>
prettyprints the node corresponding to <index> in the text 'ppText'
! <editorId> prettyprint <ok> <ppText>

Application commands (global) in Freja:
=======================================

openGroup: * is currently not used
# 0 openGroup <name>
  opens the fragment group <name> 
  a full path can be used, else local to current directory
! 0 openGroup <ok>
  <ok> is a boolean 

openForm:  
# <editorId> openForm <name> <index>
  opens an editor instance on the fragment form <name> and selects the node
  specified by <index>, if <index> is zero the root is selected.
  If the editor already is instantiated, the node will only be selected.
! <editorId> openForm <ok> 

groupChecked: 
# 0 groupChecked  [ <editorId> ]+
The fragment groups of the editors indicated by the editorIds have been 
checked in Sif. There is only one editorId per fragment group
! 0  groupChecked <ok> 

quit:  
# 0 quit
NB! no feedback, Freja is closing the socket

closeComm:  
# 0 closeComm
NB! no feedback, Freja is closing the socket


Fragment form specific commands in Freja: 
=========================================

Whenever an editing operation is performed in Sif, whether initiated by Freja, 
or "manually" initiated in Sif, two commands are sent to Freja:

<fragmentChanged> followed by 'focusChanged', where 

<fragmentChanged> ::| newFragment
                    | astReplaced 
		    | listElementInserted 
		    | listElementsDeleted
                    | listElementsReplaced

newFragment:  
# <editorId> newFragment <name> <index>
  opens an editor instance on the fragment form <name> and selects the node
  specified by <index>, if <index> is zero the root is selected.
! <editorId> <ok> 

astReplaced:
# <editorId> astReplaced <oldIndex> <newIndex>
! <editorId> <ok>

astReplacedSequence:
# <editorId> astReplacedSequence {<oldIndex> <newIndex>}+
! <editorId> <ok>

listElementInserted:
# <editorId> listElementInserted <fatherIndex> <position> <synCatNo> <synCatName>
! <editorId> <ok>

listElementsDeleted:
# <editorId> listElementsDeleted <fatherIndex> <position> <length> <oldElements>
  <oldElements> ::= { <elementIndex> } i    (i = <length>)
! <editorId> <ok>

listElementsReplaced:
# <editorId> listElementsReplaced <fatherIndex> <position> <length> <oldElement> <newLength> 
  <oldElement> ::= { <elementIndex> } i    (i = <length>)
! <editorId> <ok>
 
focusChanged:
# <editorId> focusChanged <index> <length>
! <editorId> <ok>

presentAnchor:
# <editorId> presentAnchor <index>
  present the anchor indicated by <index> in some way 
! <editorId> <ok>

