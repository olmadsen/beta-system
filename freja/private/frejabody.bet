ORIGIN '../freja';
INCLUDE '~beta/process/v1.4/osinterface'
        '~beta/containers/v1.4/seqContainers'
        '~beta/sysutils/v1.4.2/endian'
        '~beta/guienv/v1.3.1/utils/private/promptsbody';
-- FrejaCheckEditMenuTextEdit: DoPart --
do
   not FrejaEditMenu.TextModeOn->FrejaEditMenu.TextModeOn;
   FrejaEditMenu.TextModeOn->FrejaEditMenu.iTextEdit.Check  

-- FrejaDesignInterfaceDoPart: DoPart --
do
   false->userdataVerbose;
   true
     ->ShowSifSelection
     (*toby: Hack, because editormenu is currently not initialised
      ess: udmaerket hack :-) *) ;
   false->verbose;
   false->callbackVerbose;
   false->switch[10]->switch[11]->switch[12];
   false->switch[1]->switch[2]->switch[20]->switch[21]->switch[22]->switch[23];
   false->switch[17] (* autosave etc *) ;
   false->switch[18] (* tracing endian problem on linux *) ;
   false->switch[40] (* procedural communication with Sif *) ;
     

-- FrejaDoPart: Descriptor --
(# 
do
(*'Mjolner BETA System - Freja v2.1(1)'->putline;
 'Please send error reports and comments to freja@mjolner.dk'->putline*) 
#)  

-- FrejaDesignInterfaceOnInit: Descriptor --
(# 
do
   theFragmentBrowser.designsetup;
   theFragmentBrowser;
   (theFragmentBrowser.mps.ast[],theFragmentBrowser.mps.betaCFL[])
     ->(mps[],betaGram[]);
   theExternalInterface[]
     ->theFragmentBrowser.ymerBrowser.edenv.frejaInterface[];
   &mps.metagrammar[]->metaGram[];
   (UserMenu3,'File')->theFileMenu.init;
   menuID.editMenu->theFileMenu.insertBefore;
   enable.ConnEndsGrammarCallBack;
   enable.KbdEventCallBack;
   false->withDexter;
   menuID.fileMenu->DSMenuDeleteMenu;
   DocFileMenu[]->menuBar.remove
#)  

-- ChangedFocus: Descriptor --
(#
   t: ^Text;
   ok: @boolean;
   editorid: @Integer;
   anAST: ^MPS.AST;
   theExp: ^mps.expanded;
   graf: ^theGraphicalInterface.DesignInterface;
   theDoc: ^theGraphicalInterface.theDesignInterface.OADDocument;
   ff: ^mps.fragmentform
do
   (if theGraphicalInterface.switch[12]
    // true then
       '----------------------------------------------------------------------'
         ->screen.putLine;
       'Show Sif Selection: '->putText;
       ShowSIFSelection->putInt;
       '  newObject.theSifEditor: '->putText;
       (newObject.theSifEditor).fe.id->putInt;
       newline;
       
   if);
   (if oldFocus[] <> none then (* use oldFocus instead of oldObject *)
       theGraphicalInterface.theDesignInterface[]->graf[];
       graf.theDocument[]->theDoc[];
       (if oldFocus.theText.isModeOn then
           (if theGraphicalInterface.switch[12]
            // true then 'Finish textediting'->screen.putLine; 
           if);
           oldFocus.theText.modeOff;
           false->theDoc.FrejaEditMenu.textModeOn
             ->theDoc.FrejaEditMenu.iTextEdit.check;
           
       if);
       
   if);
   (if ShowSIFSelection then
       (if newObject.theSifEditor <> none then
           newObject.getASTNode->anAST[];
           (if anAST[] <> none then
               (if anAST## <= betaGram.AttributeDecl## then
                   anAST[]->theExp[];
                   (if anAST.Symbol = betaGram.RepetitionDecl then
                       theExp.getSon3->anAST[]
                    else
                       theExp.getSon2->anAST[]
                   if);
                   setFocus:
                   (if anAST.kind = mps.kinds.unExpanded then
                       (anAST[],1)->(newObject.theSifEditor).changeFocus
                    else
                       (if (anAST## <= betaGram.ReferenceSpecification##) or
                       (anAST## <= betaGram.Remote##) then
                           anAST[]->theExp[];
                           theExp.getSon1->anAST[];
                           restart setFocus
                        else
                           (newObject.getASTNode,1)
                             ->(newObject.theSifEditor).changeFocus
                       if)
                   if)
                else
                   (newObject.getASTNode,1)
                     ->(newObject.theSifEditor).changeFocus
               if)
            else
               newObject.getFragment->ff[];
               newObject.astIndex
                 ->ff.indexToNode
                   (#
                      indexOutOfRange::< 
                        (# 
                        do 'indexOutOfRange'->putLine; true->continue; 
                        #);
                      noSuchSymbol::< 
                        (#  do 'noSuchSymbol'->putLine; true->continue;  #);
                      grammarGenRefArrayError::< 
                        (# 
                        do 'grammarGenRefArrayError'->putLine; true->continue; 
                        #)
                   #)->anAST[];
               (anAST[],1)->(newObject.theSifEditor).changeFocus
           if);
           
       if)
   if);
   
#)  

-- declarationTextChanged: Descriptor --
(# (* should we use currentFocus or theObject? *) 
do
   (if theObject[] <> none
    // true then
       (if theObject.theDiagram <> none
        // true then
           (if theObject.theSifEditor <> none then
               (node[],theParseText)->(theObject.theSifEditor).parse
           if)
        else
           'DoParse: theDiagram is NONE'->putline; 
       if)
    else
       'DoParse: CurrentFocus is NONE'->putline; 
   if)
#)  

-- openFormInSif: Descriptor --
(# t: ^text; theTitle: @Text; editorId: @Integer
do
   fn[]->theFragmentNode[];
   (if switch[1] then
       (if theFragmentNode[] <> none then
           
        else
           'theFragmentNode is NONE !!!!'->putline
       if)
   if);
   (if fn.theSifEditor = none then
       (ff.fullname,none )->theController.globalSifCommands.openForm
   if);
   
#)  

-- prefixExpand: Descriptor --
(# t: ^Text; 
do
(*(if CurrentFocus[] <> none
 // true then
 (if CurrentFocus.theDiagram <> none
 // true then
 (if CurrentFocus.SifEditorInstanceNo <> 0
 // true then
 [* '# '->t[];
 CurrentFocus.SifEditorInstanceNo->t.putint;
 (if normal
 // true then ' expandNormal '->t.append; 
 else
 ' expandOptional '->t.append; 
 if); *]
 'Go call sif to expand the prefix'->screen.putline; 
 if)
 else
 'DoExpand: theDiagram is NONE'->putline; 
 if)
 else
 'DoExpand: CurrentFocus is NONE'->putline; 
 if)*) 
#)  

-- copy: Descriptor --
(# 
do
   'copy: '->puttext;
   (if theObject[] <> none // true then theObject.astIndex->putint if);
   newline;
   
#)  

-- onFocusChange: Descriptor --
(#
(* Selects the diagram node that corresponds to the focus in sif (node).
 * If the diagram node doesn't exist, the path up to the rooth in the AST is
 * traversed until an AST node that has a corresponding diagram node is found.
 * This diagram node is then detailed and the same is done for the AST nodes
 * that have been met on the way up.
 * The stack S is used for this.
 *)
   theObject: ^PatternDiagramNode;
   theListDiagram: ^ListDiagram;
   anAST2: ^mps.ast;
   S: @stack (# element::< mps.ast (* integerObject *) #);
   io: ^integerObject;
   hasDetailed,noNodeFound: @boolean;
   
do
   false->status;
   true->noNodeFound;
   S.init;
   (if switch[10] // true then 'Freja ----- onFocusChange: '->putline;  if);
   search:
     (# 
     do
        (if switch[10] // true then 'searching...'->putLine;  if);
        (if (node[] <> none )
         // true then
            (if switch[11]
             // true then
                'Freja ----- node.Index: '->putText;
                node.Index->putInt;
                newLine;
                
            if);
            node[]->ASTtoNode->theObject[]
         else
            none ->theObject[]; 
        if);
        (if (theObject[] <> none )
         // true then
            theObject.theDiagram->theListDiagram[];
            (if theObject## <= theListDiagram.FragmentNode## then
            (* don't show these *)
                true->status; leave search
             else
                theObject[]->CurrentObject (#  do true->autoPan #);
                currentFocus[]->oldFocus[];
                theObject[]->CurrentFocus[];
                false->noNodeFound;
                
            if);
            true->status;
            (if S.empty and noNodeFound then
                (if switch[11]
                 // true then 'Freja ----- stack is empty'->putLine; 
                if);
                theGroupPage.patternDiagrams.theList.scanFragmentDiagrams
                  (# 
                  do
                     thisDiagram.localNodes.scan
                       (#
                          theListDiagram: ^ListDiagram;
                          theFragmentNode: ^theListDiagram.FragmentNode
                       do
                          current.theDiagram->theListDiagram[];
                          (if current## <= theListDiagram.fragmentNode## then
                              current[]->theFragmentNode[];
                              (if node.frag[] = theFragmentNode.theFragment then
                                  (if theFragmentNode.currentDecomposDiagram <>
                                  none then
                                      (theFragmentNode.currentDecomposDiagram).
                                      titleNode[]
                                        ->CurrentObject
                                          (#  do true->autoPan #);
                                      currentFocus[]->oldFocus[];
                                      (theFragmentNode.currentDecomposDiagram).
                                      titleNode[]->CurrentFocus[]
                                   else
                                      theFragmentNode[]
                                        ->CurrentObject
                                          (#  do true->autoPan #);
                                      currentFocus[]->oldFocus[];
                                      theFragmentNode[]->CurrentFocus[]
                                  if)
                              if)
                          if)
                       #)
                  #);
                
             else
                openDownUntilNode:
                (if S.empty = false then
                    S.pop->anAST2[];
                    (if switch[11]
                     // true then
                        'Freja ----- pop '->putText;
                        anAST2.index->putInt;
                        newline;
                        
                    if);
                    anAST2[]->ASTtoNode->theObject[];
                    (if theObject[] = none then
                    (* 'detailing... '->statusbar.set;*)
                        (if currentFocus[] <> none then
                            false->currentFocus.IndicateSelection;
                            currentFocus.detail;
                            true->hasDetailed;
                            anAST2[]->ASTtoNode->theObject[];
                            (if theObject[] <> none
                             // true then
                                (if switch[11]
                                 // true then
                                    'Freja ----- node found'->putLine; 
                                if);
                                theObject[]->CurrentObject;
                                currentFocus[]->oldFocus[];
                                theObject[]->CurrentFocus[];
                                true->status;
                                
                             else
                                'node not found in detailed diagram!!'->putLine;
                                
                            if);
                            restart openDownUntilNode
                        if)
                    if)
                if)
            if)
         else
            (if (node[] <> none )
             // true then
                (if switch[11]
                 // true then
                    'Freja ----- node.symbol '->putText;
                    node.symbol->putint;
                    ' node.index '->putText;
                    node.index->putint;
                    ' '->put;
                    node.symbol->betaGram.symbolToName->putLine;
                    
                if);
                (if node.kind
                 // mps.kinds.interior then
                    (if node.symbol
                     // betaGram.SimpleDecl // betaGram.PatternDecl
                     // betaGram.VirtualDecl // betaGram.BindingDecl
                     // betaGram.FinalDecl
                     //
                     betaGram.RepetitionDecl (*// betaGram.VariablePatternDecl*)
                     then
                        (if switch[11]
                         // true then
                            'Freja ----- push '->putText;
                            node.index->putInt;
                            newline;
                            
                        if);
                        (*&integerObject[]->io[];
                         node.index->io.value;
                         io[]->S.push;
                         *)
                        node[]->S.push
                    if)
                 // mps.kinds.unexpanded then
                    (if
                    (node[]->qua (# as:: mps.unexpanded #)).nonterminalSymbol
                     // gram.AttributeDeclOpt then
                        (if switch[11]
                         // true then
                            'Freja ----- push nonterminal'->putText;
                            node.index->putInt;
                            newline;
                            
                        if);
                        (*&integerObject[]->io[];
                         node.index->io.value;
                         io[]->S.push;*)
                        node[]->S.push
                    if)
                if);
                node.father->node[];
                restart search;
                
             else
            (* astIndex not on the path up to the root *)
                'astIndex not on the path up to the root'->putLine;
                false->status;
                
            if);
            
        if)
     #);
   (* if focusChanged has detail,
    * refresh page due to delay in update *)
   (if hasDetailed then Redraw if)
#)  

-- presentAnchor: Descriptor --
(# theObject: ^PatternDiagramNode; 
do
(*  '[[Freja: presentAnchor '->screen.puttext;
 theIndex->screen.putint;
 theIndex->AstToNode->theObject[];
 (if theObject[] <> none
 // true then theObject[]->CurrentObject;
 else
 'no such index shown in Freja'->screen.puttext;
 if);
 ']]'->screen.putline;
 * *) 
#)  

-- GetStatusFromSif: Descriptor --
(# t: ^Text; theNode: ^PatternDiagramNode; 
do
   (if theObject[] <> none then
       (if theObject.struc <= PatternDiagramNode##
        // true then
           theObject[]->theNode[];
           (if theNode.theSifEditor = none then
               (if theGraphicalInterface.switch[12]
                // true then
                   'Freja ------ No Sif Editor Instance open'->putline; 
               if);
               
            else
               (theNode.theSifEditor).getStatus
           if);
           
        else
           'Freja ------ ERROR: GetStatus: theObject is not a DiagramNode'
             ->putline;
           
       if)
   if)
#)  

-- DoExpand: Descriptor --
(# 
do
   (if CurrentFocus[] <> none then
       (if CurrentFocus.theDiagram <> none then
           (if CurrentFocus.theSifEditor <> none then
               (if normal then
                   synCatNo->(CurrentFocus.theSifEditor).expandNormal; 
                else
                   synCatNo->(CurrentFocus.theSifEditor).expandOptional; 
               if);
               
           if)
        else
           'DoExpand: theDiagram is NONE'->putline; 
       if)
    else
       'DoExpand: CurrentFocus is NONE'->putline; 
   if)
#)  

-- DoExpandLexem: Descriptor --
(# 
do
   (if CurrentFocus[] <> none then
       (if CurrentFocus.theDiagram <> none then
           (if CurrentFocus.theSifEditor <> none then
               name->(currentFocus.theSifEditor).expandLexem
           if)
       if)
    else
       'DoExpandLexem: CurrentFocus is NONE'->putline; 
   if)
#)  

-- MakeAPalette: Descriptor --
(# tt: ^Text; 
do
   (if OADPalette.isopen
    // false then (100,100,200,400)->OADPalette.PositionNew; 
    else
       OADPalette.clear; 
   if);
   nonTerminalCatName->OADPalette.title;
   (if t[]
    // none then 
    else
       t.reset;
       t.getatom->tt[];
       (if tt[]
        // none then 
        else
           (if ('Enter'->tt.equal)
            // true then OADPalette.close; 
            else
               t.reset;
               loop:
               (if 1
                // 1 then
                   (t.getint,t.getatom)->OADPalette.add;
                   (if t.pos+1 < t.length // true then restart loop if)
               if);
               THIS(OADPage)[]->CurrentPage;
               (* select the drawing page again
                * in order to make the palette work right *)
               
           if)
       if)
   if);
   
#)  

-- StaticItemConnectorOnInit: Descriptor --
(#
   aPatternDiagramNode,anotherPatternDiagramNode: ^PatternDiagramNode;
   theListDiagram,theOtherListDiagram: ^ListDiagram;
   theOtherOADDiagram: ^OADDiagram;
   aDiagramNode: ^theOtherListDiagram.DiagramNode;
   aNonTerminalNode: ^theListDiagram.NonTerminalNode;
   t: ^Text;
   titleText: @text;
   anAST: ^MPS.AST;
   anExp,anotherExp: ^mps.expanded;
   theNames: ^betaGram.Names;
   theNameDcl: ^betaGram.NameDcl;
   theAttrDecl: ^betaGram.AttributeDecl;
   theDesc: ^betaGram.ObjectDescriptor;
   existingConnectors: ^ObjectList;
   theCon: ^Connector
do
   (if switch[1] then 'StaticItemConnector onInit!'->putline if);
   0->Orient;
   true->getEnds->(node1[],node2[]);
   (if (node1[] <> none ) and (node2[] <> none ) then
       (if (node1## <= PatternDiagramNode##) and
       (node2## <= PatternDiagramNode##) then
           node1[]->aPatternDiagramNode[];
           aPatternDiagramNode.theDiagram->theListDiagram[];
           node2[]->anotherPatternDiagramNode[];
           (if (aPatternDiagramNode## <= theListDiagram.SimpleNode##) then
               aPatternDiagramNode.getASTNode->anExp[];
               anExp.getSon1->theNames[];
               theNames.getSon1->theNameDcl[];
               theNameDcl.getNameDecl->anAST[];
               (if anAST.kind = mps.kinds.unExpanded then
                   '<<NameDecl>>'->t[]
                else
                   theNameDcl.getText->t[]
               if);
               ':@'->t.append;
               anotherPatternDiagramNode.thisDiagram->theOtherListDiagram[];
               (if theOtherListDiagram[] <> none then
                   (if anotherPatternDiagramNode## <=
                   theOtherListDiagram.title## then
                       theOtherListDiagram[]->theOtherOADDiagram[];
                       theOtherOADDiagram.theDescriptor->theDesc[];
                       theDesc.father->anotherExp[];
                       (if anotherExp## <= betaGram.AttributeDecl## then
                           anotherExp.getSon1->theNames[];
                           theNames.getSon1->theNameDcl[];
                           theNameDcl.getNameDecl->anAST[];
                           (if anAST.kind = mps.kinds.unExpanded then
                               '<<NameAppl>>'->t.puttext
                            else
                               theNameDcl.getText->t.puttext
                           if);
                           node1.getconnectors->existingConnectors[];
                           (if existingConnectors[] <> none then
                               existingConnectors.scan
                                 (# 
                                 do
                                    (if (current## <= DynamicItemConnector##) or
                                    (current## <= DynamicComponentConnector##)
                                     then
                                        current[]->theCon[]; theCon.delete
                                    if)
                                 #)
                           if);
                           (anExp[],t)->(aPatternDiagramNode.theSifEditor).parse
                        else
                           Delete;
                           'Destination is singularly defined'->alertUser
                       if)
                   if)
                else
                   anotherPatternDiagramNode.theDiagram->theOtherListDiagram[];
                   (if
                   (anotherPatternDiagramNode## <=
                    theOtherListDiagram.PatternNode##) or
                   (anotherPatternDiagramNode## <=
                    theOtherListDiagram.VirtualNode##) or
                   (anotherPatternDiagramNode## <=
                    theOtherListDiagram.BindingNode##) or
                   (anotherPatternDiagramNode## <=
                    theOtherListDiagram.FinalNode##) then
                       anotherPatternDiagramNode[]->aDiagramNode[];
                       aDiagramNode.theDeclaration->theAttrDecl[];
                       theAttrDecl.getSon1->theNames[];
                       theNames.getSon1->theNameDcl[];
                       theNameDcl.getNameDecl->anAST[];
                       (if anAST.kind = mps.kinds.unExpanded then
                           '<<NameAppl>>'->t.puttext
                        else
                           theNameDcl.getText->t.puttext
                       if);
                       node1.getconnectors->existingConnectors[];
                       (if existingConnectors[] <> none then
                           existingConnectors.scan
                             (# 
                             do
                                (if (current## <= DynamicItemConnector##) or
                                (current## <= DynamicComponentConnector##) then
                                    current[]->theCon[]; theCon.delete
                                if)
                             #)
                       if);
                       (anExp[],t)->(aPatternDiagramNode.theSifEditor).parse
                    else
                       'binding or final declaration'->alertUser
                   if)
               if)
            else
               (if aPatternDiagramNode## <= theListDiagram.NonTerminalNode##
                then
                   aPatternDiagramNode[]->aNonTerminalNode[];
                   '<<NameDecl>>:@'->t[];
                   anotherPatternDiagramNode.thisDiagram->theOtherListDiagram[];
                   (if theOtherListDiagram[] <> none then
                       (if anotherPatternDiagramNode## <=
                       theOtherListDiagram.title## then
                           theOtherListDiagram[]->theOtherOADDiagram[];
                           theOtherOADDiagram.theDescriptor->theDesc[];
                           theDesc.father->anotherExp[];
                           (if anotherExp## <= betaGram.AttributeDecl## then
                               anotherExp.getSon1->theNames[];
                               theNames.getSon1->theNameDcl[];
                               theNameDcl.getNameDecl->anAST[];
                               (if anAST.kind = mps.kinds.unExpanded then
                                   '<<NameAppl>>'->t.puttext
                                else
                                   theNameDcl.getText->t.puttext
                               if);
                               node1.getconnectors->existingConnectors[];
                               (if existingConnectors[] <> none then
                                   existingConnectors.scan
                                     (# 
                                     do
                                        (if
                                        (current## <= DynamicItemConnector##) or
                                        (current## <=
                                         DynamicComponentConnector##) then
                                            current[]->theCon[]; theCon.delete
                                        if)
                                     #)
                               if);
                               (aNonTerminalNode.unExp,t)
                                 ->(aNonTerminalNode.theSifEditor).parse
                            else
                               Delete;
                               'Destination is singularly defined'->alertUser
                           if)
                       if)
                    else
                       anotherPatternDiagramNode.theDiagram
                         ->theOtherListDiagram[];
                       (if
                       (anotherPatternDiagramNode## <=
                        theOtherListDiagram.PatternNode##) or
                       (anotherPatternDiagramNode## <=
                        theOtherListDiagram.VirtualNode##) or
                       (anotherPatternDiagramNode## <=
                        theOtherListDiagram.BindingNode##) or
                       (anotherPatternDiagramNode## <=
                        theOtherListDiagram.FinalNode##) then
                           anotherPatternDiagramNode[]->aDiagramNode[];
                           aDiagramNode.theDeclaration->theAttrDecl[];
                           theAttrDecl.getSon1->theNames[];
                           theNames.getSon1->theNameDcl[];
                           theNameDcl.getNameDecl->anAST[];
                           (if anAST.kind = mps.kinds.unExpanded then
                               '<<NameAppl>>'->t.puttext
                            else
                               theNameDcl.getText->t.puttext
                           if);
                           node1.getconnectors->existingConnectors[];
                           (if existingConnectors[] <> none then
                               existingConnectors.scan
                                 (# 
                                 do
                                    (if (current## <= DynamicItemConnector##) or
                                    (current## <= DynamicComponentConnector##)
                                     then
                                        current[]->theCon[]; theCon.delete
                                    if)
                                 #)
                           if);
                           (aNonTerminalNode.unExp,t)
                             ->(aNonTerminalNode.theSifEditor).parse
                        else
                           'binding or final declaration'->alertUser
                       if)
                   if)
                else
                   Delete;
                   'Source must be either a nonterminal or a simple declaration'
                     ->alertUser
               if)
           if)
        else
           'Source or destination is not part of a pattern diagram'->alertUser
       if)
   if);
   Delete
#)  

-- StaticComponentConnectorOnInit: Descriptor --
(#
   aPatternDiagramNode,anotherPatternDiagramNode: ^PatternDiagramNode;
   theListDiagram,theOtherListDiagram: ^ListDiagram;
   theOtherOADDiagram: ^OADDiagram;
   aDiagramNode: ^theOtherListDiagram.DiagramNode;
   aNonTerminalNode: ^theListDiagram.NonTerminalNode;
   t: ^Text;
   titleText: @text;
   anAST: ^MPS.AST;
   anExp,anotherExp: ^mps.expanded;
   theNames: ^betaGram.Names;
   theNameDcl: ^betaGram.NameDcl;
   theAttrDecl: ^betaGram.AttributeDecl;
   theDesc: ^betaGram.ObjectDescriptor;
   existingConnectors: ^ObjectList;
   theCon: ^Connector
do
   (if switch[1] then 'StaticComponentConnector onInit!'->putline if);
   0->Orient;
   true->getEnds->(node1[],node2[]);
   (if (node1[] <> none ) and (node2[] <> none ) then
       (if (node1## <= PatternDiagramNode##) and
       (node2## <= PatternDiagramNode##) then
           node1[]->aPatternDiagramNode[];
           aPatternDiagramNode.theDiagram->theListDiagram[];
           node2[]->anotherPatternDiagramNode[];
           (if (aPatternDiagramNode## <= theListDiagram.SimpleNode##) then
               aPatternDiagramNode.getASTNode->anExp[];
               anExp.getSon1->theNames[];
               theNames.getSon1->theNameDcl[];
               theNameDcl.getNameDecl->anAST[];
               (if anAST.kind = mps.kinds.unExpanded then
                   '<<NameDecl>>'->t[]
                else
                   theNameDcl.getText->t[]
               if);
               ':@|'->t.append;
               anotherPatternDiagramNode.thisDiagram->theOtherListDiagram[];
               (if theOtherListDiagram[] <> none then
                   (if anotherPatternDiagramNode## <=
                   theOtherListDiagram.title## then
                       theOtherListDiagram[]->theOtherOADDiagram[];
                       theOtherOADDiagram.theDescriptor->theDesc[];
                       theDesc.father->anotherExp[];
                       (if anotherExp## <= betaGram.AttributeDecl## then
                           anotherExp.getSon1->theNames[];
                           theNames.getSon1->theNameDcl[];
                           theNameDcl.getNameDecl->anAST[];
                           (if anAST.kind = mps.kinds.unExpanded then
                               '<<NameAppl>>'->t.puttext
                            else
                               theNameDcl.getText->t.puttext
                           if);
                           node1.getconnectors->existingConnectors[];
                           (if existingConnectors[] <> none then
                               existingConnectors.scan
                                 (# 
                                 do
                                    (if (current## <= DynamicItemConnector##) or
                                    (current## <= DynamicComponentConnector##)
                                     then
                                        current[]->theCon[]; theCon.delete
                                    if)
                                 #)
                           if);
                           (anExp[],t)->(aPatternDiagramNode.theSifEditor).parse
                        else
                           Delete;
                           'Destination is singularly defined'->alertUser
                       if)
                   if)
                else
                   anotherPatternDiagramNode.theDiagram->theOtherListDiagram[];
                   (if
                   (anotherPatternDiagramNode## <=
                    theOtherListDiagram.PatternNode##) or
                   (anotherPatternDiagramNode## <=
                    theOtherListDiagram.VirtualNode##) or
                   (anotherPatternDiagramNode## <=
                    theOtherListDiagram.BindingNode##) or
                   (anotherPatternDiagramNode## <=
                    theOtherListDiagram.FinalNode##) then
                       anotherPatternDiagramNode[]->aDiagramNode[];
                       aDiagramNode.theDeclaration->theAttrDecl[];
                       theAttrDecl.getSon1->theNames[];
                       theNames.getSon1->theNameDcl[];
                       theNameDcl.getNameDecl->anAST[];
                       (if anAST.kind = mps.kinds.unExpanded then
                           '<<NameAppl>>'->t.puttext
                        else
                           theNameDcl.getText->t.puttext
                       if);
                       node1.getconnectors->existingConnectors[];
                       (if existingConnectors[] <> none then
                           existingConnectors.scan
                             (# 
                             do
                                (if (current## <= DynamicItemConnector##) or
                                (current## <= DynamicComponentConnector##) then
                                    current[]->theCon[]; theCon.delete
                                if)
                             #)
                       if);
                       (anExp[],t)->(aPatternDiagramNode.theSifEditor).parse
                    else
                       'binding or final declaration'->alertUser
                   if)
               if)
            else
               (if aPatternDiagramNode## <= theListDiagram.NonTerminalNode##
                then
                   aPatternDiagramNode[]->aNonTerminalNode[];
                   '<<NameDecl>>:@|'->t[];
                   anotherPatternDiagramNode.thisDiagram->theOtherListDiagram[];
                   (if theOtherListDiagram[] <> none then
                       (if anotherPatternDiagramNode## <=
                       theOtherListDiagram.title## then
                           theOtherListDiagram[]->theOtherOADDiagram[];
                           theOtherOADDiagram.theDescriptor->theDesc[];
                           theDesc.father->anotherExp[];
                           (if anotherExp## <= betaGram.AttributeDecl## then
                               anotherExp.getSon1->theNames[];
                               theNames.getSon1->theNameDcl[];
                               theNameDcl.getNameDecl->anAST[];
                               (if anAST.kind = mps.kinds.unExpanded then
                                   '<<NameAppl>>'->t.puttext
                                else
                                   theNameDcl.getText->t.puttext
                               if);
                               node1.getconnectors->existingConnectors[];
                               (if existingConnectors[] <> none then
                                   existingConnectors.scan
                                     (# 
                                     do
                                        (if
                                        (current## <= DynamicItemConnector##) or
                                        (current## <=
                                         DynamicComponentConnector##) then
                                            current[]->theCon[]; theCon.delete
                                        if)
                                     #)
                               if);
                               (aNonTerminalNode.unExp,t)
                                 ->(aNonTerminalNode.theSifEditor).parse
                            else
                               Delete;
                               'Destination is singularly defined'->alertUser
                           if)
                       if)
                    else
                       anotherPatternDiagramNode.theDiagram
                         ->theOtherListDiagram[];
                       (if
                       (anotherPatternDiagramNode## <=
                        theOtherListDiagram.PatternNode##) or
                       (anotherPatternDiagramNode## <=
                        theOtherListDiagram.VirtualNode##) or
                       (anotherPatternDiagramNode## <=
                        theOtherListDiagram.BindingNode##) or
                       (anotherPatternDiagramNode## <=
                        theOtherListDiagram.FinalNode##) then
                           anotherPatternDiagramNode[]->aDiagramNode[];
                           aDiagramNode.theDeclaration->theAttrDecl[];
                           theAttrDecl.getSon1->theNames[];
                           theNames.getSon1->theNameDcl[];
                           theNameDcl.getNameDecl->anAST[];
                           (if anAST.kind = mps.kinds.unExpanded then
                               '<<NameAppl>>'->t.puttext
                            else
                               theNameDcl.getText->t.puttext
                           if);
                           node1.getconnectors->existingConnectors[];
                           (if existingConnectors[] <> none then
                               existingConnectors.scan
                                 (# 
                                 do
                                    (if (current## <= DynamicItemConnector##) or
                                    (current## <= DynamicComponentConnector##)
                                     then
                                        current[]->theCon[]; theCon.delete
                                    if)
                                 #)
                           if);
                           (aNonTerminalNode.unExp,t)
                             ->(aNonTerminalNode.theSifEditor).parse
                        else
                           'binding or final declaration'->alertUser
                       if)
                   if)
                else
                   Delete;
                   'Source must be either a nonterminal or a simple declaration'
                     ->alertUser
               if)
           if)
        else
           'Source or destination is not part of a pattern diagram'->alertUser
       if)
   if);
   Delete
#)  

-- SpecializationConnectorOnInit: Descriptor --
(#
   aPatternDiagramNode,anotherPatternDiagramNode: ^PatternDiagramNode;
   theListDiagram,theOtherListDiagram: ^ListDiagram;
   theOADDiagram,theOtherOADDiagram: ^OADDiagram;
   theOtherPatternDeclDiagram: ^PatternDeclDiagram;
   aDiagramNode: ^theOtherListDiagram.DiagramNode;
   t: ^Text;
   titleText: @text;
   theDesc,theOtherDesc: ^betaGram.ObjectDescriptor;
   anAST,anotherAST,testAST,testAST2,aDeclAST: ^MPS.AST;
   anExp: ^mps.expanded;
   theNames: ^betaGram.Names;
   theNameDcl: ^betaGram.NameDcl;
   theMainPart: ^betaGram.MainPart;
   existingConnectors: ^ObjectList;
   aCon: ^Connector;
   theCon: ^theOtherListDiagram.PrefixConnector;
   theSimpleCon: ^theOtherListDiagram.SimplePrefixConnector;
   nd1,nd2: @integerRef;
   object1,object2: ^designObject;
   wed: ^WedgeNode
do
   (if switch[1] then 'SpecializationConnector onInit!'->putline if);
   true->getEnds->(node2[],node1[]);
   delete;
   (if (node1[] <> none ) and (node2[] <> none ) then
       (if (node1## <= PatternDiagramNode##) and
       (node2## <= PatternDiagramNode##) then
           node1[]->aPatternDiagramNode[];
           aPatternDiagramNode.theDiagram->theListDiagram[];
           node2[]->anotherPatternDiagramNode[];
           anotherPatternDiagramNode.theDiagram->theOtherListDiagram[];
           (if (theListDiagram## <= FragmentDiagram##) or
           (theOtherListDiagram## <= FragmentDiagram##) then
               'Source and/or destination is a fragment diagram'->AlertUser
            else
               (if (theListDiagram## <= PatternAttDiagram##) or
               (theOtherListDiagram## <= PatternAttDiagram##) then
                   'Source and/or destination is an attributes form diagram'
                     ->AlertUser
                else
                   theListDiagram[]->theOADDiagram[];
                   theOtherListDiagram[]->theOtherOADDiagram[];
                   theOADDiagram.theDescriptor->theDesc[];
                   theOtherOADDiagram.theDescriptor->theOtherDesc[];
                   theDesc.father->anAST[];
                   (if anAST## <= betaGram.referenceSpecification## then
                       'The destination is a singular object'->AlertUser
                    else
                       theOtherDesc.father->anotherAST[];
                       anAST.father->testAST[];
                       anotherAST.father->testAST2[];
                       (if (testAST[] <> none ) and (testAST2[] <> none ) then
                           (if theListDiagram[] <> theOtherListDiagram[] then
                               theOtherDesc.getPrefixOpt->anotherAST[];
                               anAST[]->anExp[];
                               anExp.getSon1->theNames[];
                               theNames.getSon1->theNameDcl[];
                               theNameDcl.getNameDecl->aDeclAST[];
                               (if aDeclAST.kind = mps.kinds.unExpanded then
                                   '<<NameAppl>>'->t[]
                                else
                                   theNameDcl.getText->t[]
                               if);
                               (anotherAST[],t)
                                 ->
                                   (anotherPatternDiagramNode.theSifEditor).
                                   parse;
                               (if theListDiagram.LocalNodes.Last <> none then
                                   (theListDiagram.LocalNodes.Last).elm[]
                                     ->node1[]
                                else
                                   theListDiagram.titleNode[]->node1[]
                               if);
                               &theOtherListDiagram.PrefixConnector[]->theCon[];
                               &theOtherListDiagram.SimplePrefixConnector[]
                                 ->theSimpleCon[];
                               (theOtherListDiagram.titleNode[],node1[])
                                 ->theCon.PrefixNew;
                               (theOtherListDiagram.titleNode[],node1[])
                                 ->theSimpleCon.PrefixNew;
                               theListDiagram.titleNode[]
                                 ->theOtherListDiagram.titleNode.CreateRegion;
                               (if
                               (theOtherListDiagram.titleNode.thePrefixConn <>
                                none ) and
                               (theOtherListDiagram.titleNode.
                                  theSimplePrefixConn <> none ) then
                                   (if
                                   ((theOtherListDiagram.titleNode.thePrefixConn
                                    ).ID,true,nd1[],nd2[])->DSRdAttrGetConnEnds
                                    then
                                       nd1->theObjectList.Find->object1[];
                                       (if object1[] <> none then
                                           (if object1## <= wedgeNode## then
                                               object1[]->wed[]
                                            else
                                               nd2->theObjectList.Find
                                                 ->object2[];
                                               (if object2[] <> none then
                                                   (if object2## <= wedgeNode##
                                                    then
                                                       object2[]->wed[]
                                                   if)
                                               if)
                                           if)
                                       if)
                                    else
                                       'GetEnds failed connector ID: '->puttext;
                                       (
                                       theOtherListDiagram.titleNode.
                                         thePrefixConn).ID->putint;
                                       newline
                                   if);
                                   (theOtherListDiagram.titleNode.thePrefixConn)
                                     .delete;
                                   (if wed[] <> none then wed.delete if);
                                   (if
                                   ((
                                    theOtherListDiagram.titleNode.
                                      theSimplePrefixConn).ID,true,nd1[],nd2[])
                                     ->DSRdAttrGetConnEnds then
                                       nd1->theObjectList.Find->object1[];
                                       (if object1[] <> none then
                                           (if object1## <= wedgeNode## then
                                               object1[]->wed[]
                                            else
                                               nd2->theObjectList.Find
                                                 ->object2[];
                                               (if object2[] <> none then
                                                   (if object2## <= wedgeNode##
                                                    then
                                                       object2[]->wed[]
                                                   if)
                                               if)
                                           if)
                                       if)
                                    else
                                       'GetEnds failed connector ID: '->puttext;
                                       (
                                       theOtherListDiagram.titleNode.
                                         theSimplePrefixConn).ID->putint;
                                       newline
                                   if);
                                   (
                                   theOtherListDiagram.titleNode.
                                     theSimplePrefixConn).delete;
                                   (if wed[] <> none then wed.delete if)
                               if);
                               theCon[]
                                 ->theOtherListDiagram.titleNode.thePrefixConn;
                               theSimpleCon[]
                                 ->
                                   theOtherListDiagram.titleNode.
                                     theSimplePrefixConn;
                               theOtherListDiagram[]
                                 ->theOtherPatternDeclDiagram[];
                               theDesc[]->theOtherPatternDeclDiagram.thePrefix;
                               theOtherPatternDeclDiagram.theParentNode
                                 ->aDiagramNode[];
                               theDesc[]->aDiagramNode.thePrefix;
                               (if (theOtherDesc.father).symbol =
                               betaGram.staticItem then
                                   ((theOtherDesc.father).father,theDesc.father)
                                     ->patternDiagrams.InheritanceList.insert
                                else
                                   (theOtherDesc.father,theDesc.father)
                                     ->patternDiagrams.InheritanceList.insert
                               if)
                            else
                               'Source and destination is the same diagram'
                                 ->AlertUser
                           if)
                        else
                           'Source and/or destination is a descriptor form diagram'
                             ->AlertUser
                       if)
                   if)
               if)
           if)
        else
           'Source or destination is not part of a pattern diagram'->AlertUser
       if)
    else
       (if switch[1] then
           'SpecializationConnectorOnInit: node1 and/or node2 was none'->putline
       if)
   if)
#)  

-- BindingConnectorOnInit: Descriptor --
(#
   aPatternDiagramNode,anotherPatternDiagramNode: ^PatternDiagramNode;
   aDiagramNode: ^theListDiagram.DiagramNode;
   aPatternNode: ^theListDiagram.PatternNode;
   anotherDiagramNode: ^theOtherListDiagram.DiagramNode;
   aNonTerminalNode: ^theListDiagram.NonTerminalNode;
   theListDiagram,theOtherListDiagram: ^ListDiagram;
   anAST: ^MPS.AST;
   theNames: ^betaGram.Names;
   theNameDcl: ^betaGram.NameDcl;
   ObjSpecText: @Text;
   t: ^Text
do
   (if switch[1] then 'BindingConnector onInit'->putline if);
   true->getEnds->(node1[],node2[]);
   delete;
   (if (node1[] <> none ) and (node2[] <> none ) then
       (if (node1## <= PatternDiagramNode##) and
       (node2## <= PatternDiagramNode##) then
           node1[]->aPatternDiagramNode[];
           aPatternDiagramNode.theDiagram->theListDiagram[];
           node2[]->anotherPatternDiagramNode[];
           anotherPatternDiagramNode.theDiagram->theOtherListDiagram[];
           (if
           (anotherPatternDiagramNode## <= theOtherListDiagram.VirtualNode##) or
           (anotherPatternDiagramNode## <= theOtherListDiagram.BindingNode##)
            then
               (if (theListDiagram## <= FragmentDiagram##) or
               (theOtherListDiagram## <= FragmentDiagram##) then
                   'Source and/or destination is a fragment diagram'->AlertUser
                else
                   (if (theListDiagram## <= PatternAttDiagram##) or
                   (theOtherListDiagram## <= PatternAttDiagram##) then
                       'Source and/or destination is an attributes form diagram'
                         ->AlertUser
                    else
                       (if aPatternDiagramNode## <= theListDiagram.title## then
                           'Source must be an attribute of a pattern diagram'
                             ->AlertUser
                        else
                           anotherPatternDiagramNode[]->anotherDiagramNode[];
                           (anotherDiagramNode.theDeclaration).getSon1
                             ->theNames[];
                           theNames.getSon1->theNameDcl[];
                           theNameDcl.getNameDecl->anAST[];
                           (if anAST.kind = mps.kinds.unExpanded then
                               '<<NameDecl>>'->t[]
                            else
                               theNameDcl.getText->t[]
                           if);
                           '::< '->t.puttext;
                           (if aPatternDiagramNode## <=
                           theListDiagram.PatternNode## then
                               aPatternDiagramNode[]->aPatternNode[];
                               (aPatternNode.theDeclaration).getSon2->anAST[];
                               (mps[],anAST.frag[],anAST[],ObjSpecText[],none
                                (*streamName[]*) ,80,0,false
                                (*abstractPresentation*) ,false
                                (*showSemanticErrors*) ,false
                                (*includeComments*) ,false,false,false,false,'',
                                false (*onlyProperties*) ,false
                                (*
                                 test*) )->ppFragment;
                               (1,ObjSpecText.length-3)->ObjSpecText.sub
                                 ->t.puttext
                            else
                               '<<ObjectSpecification>>'->t.puttext
                           if);
                           (if aPatternDiagramNode## <=
                           theListDiagram.DiagramNode## then
                               aPatternDiagramNode[]->aDiagramNode[];
                               (aDiagramNode.theDeclaration,t)
                                 ->(aPatternDiagramNode.theSifEditor).parse
                            else
                               (if aPatternDiagramNode## <=
                               theListDiagram.NonTerminalNode## then
                                   aPatternDiagramNode[]->aNonTerminalNode[];
                                   (aNonTerminalNode.unexp,t)
                                     ->(aPatternDiagramNode.theSifEditor).parse
                                else
                                   'BindingConnectorOnInit: Source neither DiagramNode nor NonTerminalNode??'
                                     ->putline
                               if)
                           if)
                       if)
                   if)
               if)
            else
               'Destination must be a virtual or a binding declaration'
                 ->AlertUser
           if)
        else
           'Source or destination is not part of a pattern diagram'->AlertUser
       if)
   if)
#)  

-- FinalBindingConnectorOnInit: Descriptor --
(#
   aPatternDiagramNode,anotherPatternDiagramNode: ^PatternDiagramNode;
   aDiagramNode: ^theListDiagram.DiagramNode;
   aPatternNode: ^theListDiagram.PatternNode;
   anotherDiagramNode: ^theOtherListDiagram.DiagramNode;
   aNonTerminalNode: ^theListDiagram.NonTerminalNode;
   theListDiagram,theOtherListDiagram: ^ListDiagram;
   anAST: ^MPS.AST;
   theNames: ^betaGram.Names;
   theNameDcl: ^betaGram.NameDcl;
   ObjSpecText: @Text;
   t: ^Text
do
   (if switch[1] then 'BindingConnector onInit!'->putline if);
   true->getEnds->(node1[],node2[]);
   delete;
   (if (node1[] <> none ) and (node2[] <> none ) then
       (if (node1## <= PatternDiagramNode##) and
       (node2## <= PatternDiagramNode##) then
           node1[]->aPatternDiagramNode[];
           aPatternDiagramNode.theDiagram->theListDiagram[];
           node2[]->anotherPatternDiagramNode[];
           anotherPatternDiagramNode.theDiagram->theOtherListDiagram[];
           (if
           (anotherPatternDiagramNode## <= theOtherListDiagram.VirtualNode##) or
           (anotherPatternDiagramNode## <= theOtherListDiagram.BindingNode##)
            then
               (if (theListDiagram## <= FragmentDiagram##) or
               (theOtherListDiagram## <= FragmentDiagram##) then
                   'Source and/or destination is a fragment diagram'->AlertUser
                else
                   (if (theListDiagram## <= PatternAttDiagram##) or
                   (theOtherListDiagram## <= PatternAttDiagram##) then
                       'Source and/or destination is an attributes form diagram'
                         ->AlertUser
                    else
                       (if aPatternDiagramNode## <= theListDiagram.title## then
                           'Source must be an attribute of a pattern diagram'
                             ->AlertUser
                        else
                           anotherPatternDiagramNode[]->anotherDiagramNode[];
                           (anotherDiagramNode.theDeclaration).getSon1
                             ->theNames[];
                           theNames.getSon1->theNameDcl[];
                           theNameDcl.getNameDecl->anAST[];
                           (if anAST.kind = mps.kinds.unExpanded then
                               '<<NameDecl>>'->t[]
                            else
                               theNameDcl.getText->t[]
                           if);
                           ':: '->t.puttext;
                           (if aPatternDiagramNode## <=
                           theListDiagram.PatternNode## then
                               aPatternDiagramNode[]->aPatternNode[];
                               (aPatternNode.theDeclaration).getSon2->anAST[];
                               (mps[],anAST.frag[],anAST[],ObjSpecText[],none
                                (*streamName[]*) ,80,0,false
                                (*abstractPresentation*) ,false
                                (*showSemanticErrors*) ,false
                                (*includeComments*) ,false,false,false,false,'',
                                false (*onlyProperties*) ,false
                                (*
                                 test*) )->ppFragment;
                               (1,ObjSpecText.length-3)->ObjSpecText.sub
                                 ->t.puttext
                            else
                               '<<ObjectSpecification>>'->t.puttext
                           if);
                           (if aPatternDiagramNode## <=
                           theListDiagram.DiagramNode## then
                               aPatternDiagramNode[]->aDiagramNode[];
                               (aDiagramNode.theDeclaration,t)
                                 ->(aPatternDiagramNode.theSifEditor).parse
                            else
                               (if aPatternDiagramNode## <=
                               theListDiagram.NonTerminalNode## then
                                   aPatternDiagramNode[]->aNonTerminalNode[];
                                   (aNonTerminalNode.unexp,t)
                                     ->(aPatternDiagramNode.theSifEditor).parse
                                else
                                   'BindingConnectorOnInit: Source neither DiagramNode nor NonTerminalNode??'
                                     ->putline
                               if)
                           if)
                       if)
                   if)
               if)
            else
               'Destination must be a virtual or a binding declaration'
                 ->AlertUser
           if)
        else
           'Source or destination is not part of a pattern diagram'->AlertUser
       if)
   if)
#)  

-- PatternVariableConnectorOnInit: Descriptor --
(#
   aPatternDiagramNode,anotherPatternDiagramNode: ^PatternDiagramNode;
   theListDiagram,theOtherListDiagram: ^ListDiagram;
   theOtherOADDiagram: ^OADDiagram;
   aDiagramNode: ^theOtherListDiagram.DiagramNode;
   aNonTerminalNode: ^theListDiagram.NonTerminalNode;
   t: ^Text;
   titleText: @text;
   anAST: ^MPS.AST;
   anExp,anotherExp: ^mps.expanded;
   theNames: ^betaGram.Names;
   theNameDcl: ^betaGram.NameDcl;
   theAttrDecl: ^betaGram.AttributeDecl;
   theDesc: ^betaGram.ObjectDescriptor;
   existingConnectors: ^ObjectList;
   theCon: ^Connector
do
   (if switch[1] then 'StaticItemConnector onInit!'->putline if);
   true->getEnds->(node1[],node2[]);
   (if (node1[] <> none ) and (node2[] <> none ) then
       (if (node1## <= PatternDiagramNode##) and
       (node2## <= PatternDiagramNode##) then
           node1[]->aPatternDiagramNode[];
           aPatternDiagramNode.theDiagram->theListDiagram[];
           node2[]->anotherPatternDiagramNode[];
           (if (aPatternDiagramNode## <= theListDiagram.SimpleNode##) then
               aPatternDiagramNode.getASTNode->anExp[];
               anExp.getSon1->theNames[];
               theNames.getSon1->theNameDcl[];
               theNameDcl.getNameDecl->anAST[];
               (if anAST.kind = mps.kinds.unExpanded then
                   '<<NameDecl>>'->t[]
                else
                   theNameDcl.getText->t[]
               if);
               ':##'->t.append;
               anotherPatternDiagramNode.thisDiagram->theOtherListDiagram[];
               (if theOtherListDiagram[] <> none then
                   (if anotherPatternDiagramNode## <=
                   theOtherListDiagram.title## then
                       theOtherListDiagram[]->theOtherOADDiagram[];
                       theOtherOADDiagram.theDescriptor->theDesc[];
                       theDesc.father->anotherExp[];
                       (if anotherExp## <= betaGram.AttributeDecl## then
                           anotherExp.getSon1->theNames[];
                           theNames.getSon1->theNameDcl[];
                           theNameDcl.getNameDecl->anAST[];
                           (if anAST.kind = mps.kinds.unExpanded then
                               '<<NameAppl>>'->t.puttext
                            else
                               theNameDcl.getText->t.puttext
                           if);
                           node1.getconnectors->existingConnectors[];
                           (if existingConnectors[] <> none then
                               existingConnectors.scan
                                 (# 
                                 do
                                    (if (current## <= DynamicItemConnector##) or
                                    (current## <= DynamicComponentConnector##)
                                     then
                                        current[]->theCon[]; theCon.delete
                                    if)
                                 #)
                           if);
                           (anExp[],t)->(aPatternDiagramNode.theSifEditor).parse
                        else
                           Delete;
                           'Destination is singularly defined'->AlertUser
                       if)
                   if)
                else
                   anotherPatternDiagramNode.theDiagram->theOtherListDiagram[];
                   (if
                   (anotherPatternDiagramNode## <=
                    theOtherListDiagram.PatternNode##) or
                   (anotherPatternDiagramNode## <=
                    theOtherListDiagram.VirtualNode##) or
                   (anotherPatternDiagramNode## <=
                    theOtherListDiagram.BindingNode##) or
                   (anotherPatternDiagramNode## <=
                    theOtherListDiagram.FinalNode##) then
                       anotherPatternDiagramNode[]->aDiagramNode[];
                       aDiagramNode.theDeclaration->theAttrDecl[];
                       theAttrDecl.getSon1->theNames[];
                       theNames.getSon1->theNameDcl[];
                       theNameDcl.getNameDecl->anAST[];
                       (if anAST.kind = mps.kinds.unExpanded then
                           '<<NameAppl>>'->t.puttext
                        else
                           theNameDcl.getText->t.puttext
                       if);
                       node1.getconnectors->existingConnectors[];
                       (if existingConnectors[] <> none then
                           existingConnectors.scan
                             (# 
                             do
                                (if (current## <= DynamicItemConnector##) or
                                (current## <= DynamicComponentConnector##) then
                                    current[]->theCon[]; theCon.delete
                                if)
                             #)
                       if);
                       (anExp[],t)->(aPatternDiagramNode.theSifEditor).parse
                    else
                       'The destination is not a pattern, virtual, binding or final declaration'
                         ->AlertUser
                   if)
               if)
            else
               (if aPatternDiagramNode## <= theListDiagram.NonTerminalNode##
                then
                   aPatternDiagramNode[]->aNonTerminalNode[];
                   '<<NameDecl>>:##'->t[];
                   anotherPatternDiagramNode.thisDiagram->theOtherListDiagram[];
                   (if theOtherListDiagram[] <> none then
                       (if anotherPatternDiagramNode## <=
                       theOtherListDiagram.title## then
                           theOtherListDiagram[]->theOtherOADDiagram[];
                           theOtherOADDiagram.theDescriptor->theDesc[];
                           theDesc.father->anotherExp[];
                           (if anotherExp## <= betaGram.AttributeDecl## then
                               anotherExp.getSon1->theNames[];
                               theNames.getSon1->theNameDcl[];
                               theNameDcl.getNameDecl->anAST[];
                               (if anAST.kind = mps.kinds.unExpanded then
                                   '<<NameAppl>>'->t.puttext
                                else
                                   theNameDcl.getText->t.puttext
                               if);
                               node1.getconnectors->existingConnectors[];
                               (if existingConnectors[] <> none then
                                   existingConnectors.scan
                                     (# 
                                     do
                                        (if
                                        (current## <= DynamicItemConnector##) or
                                        (current## <=
                                         DynamicComponentConnector##) then
                                            current[]->theCon[]; theCon.delete
                                        if)
                                     #)
                               if);
                               (aNonTerminalNode.unExp,t)
                                 ->(aNonTerminalNode.theSifEditor).parse
                            else
                               Delete;
                               'Destination is singularly defined'->AlertUser
                           if)
                       if)
                    else
                       anotherPatternDiagramNode.theDiagram
                         ->theOtherListDiagram[];
                       (if
                       (anotherPatternDiagramNode## <=
                        theOtherListDiagram.PatternNode##) or
                       (anotherPatternDiagramNode## <=
                        theOtherListDiagram.VirtualNode##) or
                       (anotherPatternDiagramNode## <=
                        theOtherListDiagram.BindingNode##) or
                       (anotherPatternDiagramNode## <=
                        theOtherListDiagram.FinalNode##) then
                           anotherPatternDiagramNode[]->aDiagramNode[];
                           aDiagramNode.theDeclaration->theAttrDecl[];
                           theAttrDecl.getSon1->theNames[];
                           theNames.getSon1->theNameDcl[];
                           theNameDcl.getNameDecl->anAST[];
                           (if anAST.kind = mps.kinds.unExpanded then
                               '<<NameAppl>>'->t.puttext
                            else
                               theNameDcl.getText->t.puttext
                           if);
                           node1.getconnectors->existingConnectors[];
                           (if existingConnectors[] <> none then
                               existingConnectors.scan
                                 (# 
                                 do
                                    (if (current## <= DynamicItemConnector##) or
                                    (current## <= DynamicComponentConnector##)
                                     then
                                        current[]->theCon[]; theCon.delete
                                    if)
                                 #)
                           if);
                           (aNonTerminalNode.unExp,t)
                             ->(aNonTerminalNode.theSifEditor).parse
                        else
                           'The destination is not a pattern, virtual, binding or final declaration'
                             ->AlertUser
                       if)
                   if)
                else
                   Delete;
                   'Source must be either a nonterminal or a simple declaration'
                     ->AlertUser
               if)
           if)
        else
           'Source or destination is not part of a pattern diagram'->AlertUser
       if)
   if);
   Delete
#)  

-- OTOAssociationRelationOnInit: Descriptor --
(#
   node1,node2: ^DesignObject;
   aPatternDiagramNode,anotherPatternDiagramNode,theParentNode,lastNode:
     ^PatternDiagramNode;
   theListDiagram,theOtherListDiagram,theParentDiagram,thePatternNodeDiagram:
     ^ListDiagram;
   theAssocNode: ^AssociationNode;
   thePatternNode: ^thePatternNodeDiagram.PatternNode;
   theNonTerminalNode: ^theParentDiagram.NonTerminalNode;
   theOADDiagram,theOtherOADDiagram: ^OADDiagram;
   theDesc,theOtherDesc: ^betaGram.ObjectDescriptor;
   anAST,anotherAST,testAST,testAST2,aDeclAST,anotherDeclAST,lastAST: ^MPS.AST;
   anExp,anotherExp: ^mps.expanded;
   theNames,theOtherNames: ^betaGram.Names;
   theNameDcl,theOtherNameDcl: ^betaGram.NameDcl;
   help,indextext: @Text;
   t,theName,theOtherName,dummyQual: ^Text;
   index: @integer
do
   (if switch[1] then 'SpecializationConnector onInit!'->putline if);
   true->getEnds->(node1[],node2[]);
   delete;
   (if (node1[] <> none ) and (node2[] <> none ) then
       (if (node1## <= PatternDiagramNode##) and
       (node2## <= PatternDiagramNode##) then
           node1[]->aPatternDiagramNode[];
           aPatternDiagramNode.theDiagram->theListDiagram[];
           node2[]->anotherPatternDiagramNode[];
           anotherPatternDiagramNode.theDiagram->theOtherListDiagram[];
           (if (theListDiagram## <= FragmentDiagram##) or
           (theOtherListDiagram## <= FragmentDiagram##) then
               'Source and/or destination is a fragment diagram'->AlertUser
            else
               (if (theListDiagram## <= PatternAttDiagram##) or
               (theOtherListDiagram## <= PatternAttDiagram##) then
                   'Source and/or destination is an attributes form diagram'
                     ->AlertUser
                else
                   (if theListDiagram.localNodes.empty then
                       theListDiagram.titleNode.getASTNode->anAST[];
                       (if anAST[] <> none then
                           (anAST[],1)
                             ->
                               (theListDiagram.titleNode.theSifEditor).
                               changeFocus
                       if);
                       (theListDiagram.titleNode.theSifEditor).insertOptionals
                   if);
                   (if theOtherListDiagram.localNodes.empty then
                       theOtherListDiagram.titleNode.getASTNode->anAST[];
                       (if anAST[] <> none then
                           (anAST[],1)
                             ->
                               (theOtherListDiagram.titleNode.theSifEditor).
                               changeFocus
                       if);
                       (theOtherListDiagram.titleNode.theSifEditor).
                       insertOptionals
                   if);
                   theListDiagram[]->theOADDiagram[];
                   theOtherListDiagram[]->theOtherOADDiagram[];
                   theOADDiagram.theDescriptor->theDesc[];
                   theOtherOADDiagram.theDescriptor->theOtherDesc[];
                   theDesc.father->anAST[];
                   theOtherDesc.father->anotherAST[];
                   anAST.father->testAST[];
                   anotherAST.father->testAST2[];
                   (if (testAST[] <> none ) and (testAST2[] <> none ) then
                       (if (anAST.symbol <> betaGram.StaticItem) and
                       (anotherAST.symbol <> betaGram.StaticItem) then
                           (if theListDiagram[] <> theOtherListDiagram[] then
                               theListDiagram.theParentNode->theParentNode[];
                               theParentNode.theDiagram->theParentDiagram[];
                               (theParentDiagram.localNodes.last).elm[]
                                 ->lastNode[];
                               lastNode.getAstNode->lastAST[];
                               (if lastAST[] = none then
                                   (if lastNode## <=
                                   theParentDiagram.NonterminalNode## then
                                       lastNode[]->theNonTerminalNode[];
                                       theNonTerminalNode.unexp->lastAST[]
                                    else
                                       'No AST for last node??'->putline
                                   if)
                               if);
                               (if lastAST[] <> none then
                                   anAST[]->anExp[];
                                   anExp.getSon1->theNames[];
                                   theNames.getSon1->theNameDcl[];
                                   theNameDcl.getNameDecl->aDeclAST[];
                                   (if aDeclAST.kind = mps.kinds.unExpanded then
                                       'NoName'->theName[]
                                    else
                                       theNameDcl.getText->theName[]
                                   if);
                                   theName.copy->t[];
                                   anotherAST[]->anotherExp[];
                                   anotherExp.getSon1->theOtherNames[];
                                   theOtherNames.getSon1->theOtherNameDcl[];
                                   theOtherNameDcl.getNameDecl
                                     ->anotherDeclAST[];
                                   (if anotherDeclAST.kind =
                                   mps.kinds.unExpanded then
                                       'NoName'->theOtherName[]
                                    else
                                       theOtherNameDcl.getText->theOtherName[]
                                   if);
                                   theOtherName[]->t.puttext;
                                   ':OneToOneAssociation(# leftType::< '
                                     ->t.puttext;
                                   (lastAST[],anAST[])->getQualificationWithPath
                                     ->t.puttext;
                                   '; rightType::< '->t.puttext;
                                   (lastAST[],anotherAST[])
                                     ->getQualificationWithPath->t.puttext;
                                   ' #) '->t.puttext;
                                   &AssociationNode[]->theAssocNode[];
                                   (one,theListDiagram[],one,
                                    theOtherListDiagram[])
                                     ->theAssocNode.display;
                                   (if not gppProp.associations then
                                       false->theAssocNode.BorderVisible;
                                       (theAssocNode.c1).theText.get->help;
                                       help[]->(theAssocNode.c1).invisibleText;
                                       (theAssocNode.c1).theText.clear;
                                       false->(theAssocNode.c1).BorderVisible;
                                       (theAssocNode.c2).theText.get->help;
                                       help[]->(theAssocNode.c2).invisibleText;
                                       (theAssocNode.c2).theText.clear;
                                       false->(theAssocNode.c2).BorderVisible
                                   if);
                                   (theParentDiagram[],t[])->parseAfter;
                                   currentFocus[]->theAssocNode.thePatternNode;
                                   currentFocus.theDiagram
                                     ->thePatternNodeDiagram[];
                                   currentFocus[]->thePatternNode[];
                                   theAssocNode[]
                                     ->thePatternNode.theAssociationNode;
                                   (anAST[],one,anotherAST[],one,
                                    thePatternNode.theDeclaration)
                                     ->patternDiagrams.AssociationList.insert;
                                   t.clear;
                                   (theListDiagram.localNodes.last).elm[]
                                     ->lastNode[];
                                   lastNode.getAstNode->lastAST[];
                                   (if lastAST[] = none then
                                       (if lastNode## <=
                                       theListDiagram.NonterminalNode## then
                                           lastNode[]->theNonTerminalNode[];
                                           theNonTerminalNode.unexp->lastAST[]
                                        else
                                           'No AST for last node??'->putline
                                       if)
                                   if);
                                   (if lastAST[] <> none then
                                       'the'->t.puttext;
                                       theName[]->t.puttext;
                                       theOtherName[]->t.puttext;
                                       ':^'->t.puttext;
                                       theName[]->t.puttext;
                                       theOtherName[]->t.puttext;
                                       (theListDiagram[],t[])->parseAfter
                                   if);
                                   t.clear;
                                   (theOtherListDiagram.localNodes.last).elm[]
                                     ->lastNode[];
                                   lastNode.getAstNode->lastAST[];
                                   (if lastAST[] = none then
                                       (if lastNode## <=
                                       theOtherListDiagram.NonterminalNode##
                                        then
                                           lastNode[]->theNonTerminalNode[];
                                           theNonTerminalNode.unexp->lastAST[]
                                        else
                                           'No AST for last node??'->putline
                                       if)
                                   if);
                                   (if lastAST[] <> none then
                                       'the'->t.puttext;
                                       theName[]->t.puttext;
                                       theOtherName[]->t.puttext;
                                       ':^'->t.puttext;
                                       (lastAST[],anAST[])
                                         ->getQualificationWithPath
                                         ->dummyQual[];
                                       '.'
                                         ->dummyQual.findCh
                                           (#  do inx->index #);
                                       (index+1,dummyQual.length)
                                         ->dummyQual.delete;
                                       dummyQual[]->t.puttext;
                                       theName[]->t.puttext;
                                       theOtherName[]->t.puttext;
                                       (theOtherListDiagram[],t[])->parseAfter
                                   if)
                                else
                                   'lastAST i NONE??'->putline
                               if)
                            else
                               'Source and destination is the same diagram'
                                 ->AlertUser
                           if)
                        else
                           'Source and/or destination is singularly defined'
                             ->AlertUser
                       if)
                    else
                       'Source and/or destination is a descriptor form diagram'
                         ->AlertUser
                   if)
               if)
           if)
        else
           'Source or destination is not part of a pattern diagram'->AlertUser
       if)
   if)
#)  

-- OTMAssociationRelationOnInit: Descriptor --
(#
   node1,node2: ^DesignObject;
   aPatternDiagramNode,anotherPatternDiagramNode,theParentNode,lastNode:
     ^PatternDiagramNode;
   theListDiagram,theOtherListDiagram,theParentDiagram,thePatternNodeDiagram:
     ^ListDiagram;
   theAssocNode: ^AssociationNode;
   thePatternNode: ^thePatternNodeDiagram.PatternNode;
   theNonTerminalNode: ^theParentDiagram.NonTerminalNode;
   theOADDiagram,theOtherOADDiagram: ^OADDiagram;
   theDesc,theOtherDesc: ^betaGram.ObjectDescriptor;
   anAST,anotherAST,testAST,testAST2,aDeclAST,anotherDeclAST,lastAST: ^MPS.AST;
   anExp,anotherExp: ^mps.expanded;
   theNames,theOtherNames: ^betaGram.Names;
   theNameDcl,theOtherNameDcl: ^betaGram.NameDcl;
   help,indextext: @Text;
   t,theName,theOtherName,dummyQual: ^Text;
   index: @integer
do
   (if switch[1] then 'SpecializationConnector onInit!'->putline if);
   true->getEnds->(node1[],node2[]);
   delete;
   (if (node1[] <> none ) and (node2[] <> none ) then
       (if (node1## <= PatternDiagramNode##) and
       (node2## <= PatternDiagramNode##) then
           node1[]->aPatternDiagramNode[];
           aPatternDiagramNode.theDiagram->theListDiagram[];
           node2[]->anotherPatternDiagramNode[];
           anotherPatternDiagramNode.theDiagram->theOtherListDiagram[];
           (if (theListDiagram## <= FragmentDiagram##) or
           (theOtherListDiagram## <= FragmentDiagram##) then
               'Source and/or destination is a fragment diagram'->AlertUser
            else
               (if (theListDiagram## <= PatternAttDiagram##) or
               (theOtherListDiagram## <= PatternAttDiagram##) then
                   'Source and/or destination is an attributes form diagram'
                     ->AlertUser
                else
                   (if theListDiagram.localNodes.empty then
                       theListDiagram.titleNode.getASTNode->anAST[];
                       (if anAST[] <> none then
                           (anAST[],1)
                             ->
                               (theListDiagram.titleNode.theSifEditor).
                               changeFocus
                       if);
                       (theListDiagram.titleNode.theSifEditor).insertOptionals
                   if);
                   (if theOtherListDiagram.localNodes.empty then
                       theOtherListDiagram.titleNode.getASTNode->anAST[];
                       (if anAST[] <> none then
                           (anAST[],1)
                             ->
                               (theOtherListDiagram.titleNode.theSifEditor).
                               changeFocus
                       if);
                       (theOtherListDiagram.titleNode.theSifEditor).
                       insertOptionals
                   if);
                   theListDiagram[]->theOADDiagram[];
                   theOtherListDiagram[]->theOtherOADDiagram[];
                   theOADDiagram.theDescriptor->theDesc[];
                   theOtherOADDiagram.theDescriptor->theOtherDesc[];
                   theDesc.father->anAST[];
                   theOtherDesc.father->anotherAST[];
                   anAST.father->testAST[];
                   anotherAST.father->testAST2[];
                   (if (testAST[] <> none ) and (testAST2[] <> none ) then
                       (if (anAST.symbol <> betaGram.StaticItem) and
                       (anotherAST.symbol <> betaGram.StaticItem) then
                           (if theListDiagram[] <> theOtherListDiagram[] then
                               theListDiagram.theParentNode->theParentNode[];
                               theParentNode.theDiagram->theParentDiagram[];
                               (theParentDiagram.localNodes.last).elm[]
                                 ->lastNode[];
                               lastNode.getAstNode->lastAST[];
                               (if lastAST[] = none then
                                   (if lastNode## <=
                                   theParentDiagram.NonterminalNode## then
                                       lastNode[]->theNonTerminalNode[];
                                       theNonTerminalNode.unexp->lastAST[]
                                    else
                                       'No AST for last node??'->putline
                                   if)
                               if);
                               (if lastAST[] <> none then
                                   anAST[]->anExp[];
                                   anExp.getSon1->theNames[];
                                   theNames.getSon1->theNameDcl[];
                                   theNameDcl.getNameDecl->aDeclAST[];
                                   (if aDeclAST.kind = mps.kinds.unExpanded then
                                       'NoName'->theName[]
                                    else
                                       theNameDcl.getText->theName[]
                                   if);
                                   theName.copy->t[];
                                   anotherAST[]->anotherExp[];
                                   anotherExp.getSon1->theOtherNames[];
                                   theOtherNames.getSon1->theOtherNameDcl[];
                                   theOtherNameDcl.getNameDecl
                                     ->anotherDeclAST[];
                                   (if anotherDeclAST.kind =
                                   mps.kinds.unExpanded then
                                       'NoName'->theOtherName[]
                                    else
                                       theOtherNameDcl.getText->theOtherName[]
                                   if);
                                   theOtherName[]->t.puttext;
                                   ':OneToManyAssociation(# oneType::< '
                                     ->t.puttext;
                                   (lastAST[],anAST[])->getQualificationWithPath
                                     ->t.puttext;
                                   '; ManyElmType::< '->t.puttext;
                                   (lastAST[],anotherAST[])
                                     ->getQualificationWithPath->t.puttext;
                                   ' #) '->t.puttext;
                                   &AssociationNode[]->theAssocNode[];
                                   (one,theListDiagram[],many,
                                    theOtherListDiagram[])
                                     ->theAssocNode.display;
                                   (if not gppProp.associations then
                                       false->theAssocNode.BorderVisible;
                                       (theAssocNode.c1).theText.get->help;
                                       help[]->(theAssocNode.c1).invisibleText;
                                       (theAssocNode.c1).theText.clear;
                                       false->(theAssocNode.c1).BorderVisible;
                                       (theAssocNode.c2).theText.get->help;
                                       help[]->(theAssocNode.c2).invisibleText;
                                       (theAssocNode.c2).theText.clear;
                                       false->(theAssocNode.c2).BorderVisible
                                   if);
                                   (theParentDiagram[],t[])->parseAfter;
                                   currentFocus[]->theAssocNode.thePatternNode;
                                   currentFocus.theDiagram
                                     ->thePatternNodeDiagram[];
                                   currentFocus[]->thePatternNode[];
                                   theAssocNode[]
                                     ->thePatternNode.theAssociationNode;
                                   (anAST[],one,anotherAST[],many,
                                    thePatternNode.theDeclaration)
                                     ->patternDiagrams.AssociationList.insert;
                                   t.clear;
                                   (theListDiagram.localNodes.last).elm[]
                                     ->lastNode[];
                                   lastNode.getAstNode->lastAST[];
                                   (if lastAST[] = none then
                                       (if lastNode## <=
                                       theListDiagram.NonterminalNode## then
                                           lastNode[]->theNonTerminalNode[];
                                           theNonTerminalNode.unexp->lastAST[]
                                        else
                                           'No AST for last node??'->putline
                                       if)
                                   if);
                                   (if lastAST[] <> none then
                                       'the'->t.puttext;
                                       theName[]->t.puttext;
                                       theOtherName[]->t.puttext;
                                       ':^'->t.puttext;
                                       theName[]->t.puttext;
                                       theOtherName[]->t.puttext;
                                       (theListDiagram[],t[])->parseAfter
                                   if);
                                   t.clear;
                                   (theOtherListDiagram.localNodes.last).elm[]
                                     ->lastNode[];
                                   lastNode.getAstNode->lastAST[];
                                   (if lastAST[] = none then
                                       (if lastNode## <=
                                       theOtherListDiagram.NonterminalNode##
                                        then
                                           lastNode[]->theNonTerminalNode[];
                                           theNonTerminalNode.unexp->lastAST[]
                                        else
                                           'No AST for last node??'->putline
                                       if)
                                   if);
                                   (if lastAST[] <> none then
                                       'the'->t.puttext;
                                       theName[]->t.puttext;
                                       theOtherName[]->t.puttext;
                                       ':^'->t.puttext;
                                       (lastAST[],anAST[])
                                         ->getQualificationWithPath
                                         ->dummyQual[];
                                       '.'
                                         ->dummyQual.findCh
                                           (#  do inx->index #);
                                       (index+1,dummyQual.length)
                                         ->dummyQual.delete;
                                       dummyQual[]->t.puttext;
                                       theName[]->t.puttext;
                                       theOtherName[]->t.puttext;
                                       (theOtherListDiagram[],t[])->parseAfter
                                   if)
                                else
                                   'lastAST i NONE??'->putline
                               if)
                            else
                               'Source and destination is the same diagram'
                                 ->AlertUser
                           if)
                        else
                           'Source and/or destination is singularly defined'
                             ->AlertUser
                       if)
                    else
                       'Source and/or destination is a descriptor form diagram'
                         ->AlertUser
                   if)
               if)
           if)
        else
           'Source or destination is not part of a pattern diagram'->AlertUser
       if)
   if)
#)  

-- MTMAssociationRelationOnInit: Descriptor --
(#
   node1,node2: ^DesignObject;
   aPatternDiagramNode,anotherPatternDiagramNode,theParentNode,lastNode:
     ^PatternDiagramNode;
   theListDiagram,theOtherListDiagram,theParentDiagram,thePatternNodeDiagram:
     ^ListDiagram;
   theAssocNode: ^AssociationNode;
   thePatternNode: ^thePatternNodeDiagram.PatternNode;
   theNonTerminalNode: ^theParentDiagram.NonTerminalNode;
   theOADDiagram,theOtherOADDiagram: ^OADDiagram;
   theDesc,theOtherDesc: ^betaGram.ObjectDescriptor;
   anAST,anotherAST,testAST,testAST2,aDeclAST,anotherDeclAST,lastAST: ^MPS.AST;
   anExp,anotherExp: ^mps.expanded;
   theNames,theOtherNames: ^betaGram.Names;
   theNameDcl,theOtherNameDcl: ^betaGram.NameDcl;
   help,indextext: @Text;
   t,theName,theOtherName,dummyQual: ^Text;
   index: @integer
do
   (if switch[1] then 'SpecializationConnector onInit!'->putline if);
   true->getEnds->(node1[],node2[]);
   delete;
   (if (node1[] <> none ) and (node2[] <> none ) then
       (if (node1## <= PatternDiagramNode##) and
       (node2## <= PatternDiagramNode##) then
           node1[]->aPatternDiagramNode[];
           aPatternDiagramNode.theDiagram->theListDiagram[];
           node2[]->anotherPatternDiagramNode[];
           anotherPatternDiagramNode.theDiagram->theOtherListDiagram[];
           (if (theListDiagram## <= FragmentDiagram##) or
           (theOtherListDiagram## <= FragmentDiagram##) then
               'Source and/or destination is a fragment diagram'->AlertUser
            else
               (if (theListDiagram## <= PatternAttDiagram##) or
               (theOtherListDiagram## <= PatternAttDiagram##) then
                   'Source and/or destination is an attributes form diagram'
                     ->AlertUser
                else
                   (if theListDiagram.localNodes.empty then
                       theListDiagram.titleNode.getASTNode->anAST[];
                       (if anAST[] <> none then
                           (anAST[],1)
                             ->
                               (theListDiagram.titleNode.theSifEditor).
                               changeFocus
                       if);
                       (theListDiagram.titleNode.theSifEditor).insertOptionals
                   if);
                   (if theOtherListDiagram.localNodes.empty then
                       theOtherListDiagram.titleNode.getASTNode->anAST[];
                       (if anAST[] <> none then
                           (anAST[],1)
                             ->
                               (theOtherListDiagram.titleNode.theSifEditor).
                               changeFocus
                       if);
                       (theOtherListDiagram.titleNode.theSifEditor).
                       insertOptionals
                   if);
                   theListDiagram[]->theOADDiagram[];
                   theOtherListDiagram[]->theOtherOADDiagram[];
                   theOADDiagram.theDescriptor->theDesc[];
                   theOtherOADDiagram.theDescriptor->theOtherDesc[];
                   theDesc.father->anAST[];
                   theOtherDesc.father->anotherAST[];
                   anAST.father->testAST[];
                   anotherAST.father->testAST2[];
                   (if (testAST[] <> none ) and (testAST2[] <> none ) then
                       (if (anAST.symbol <> betaGram.StaticItem) and
                       (anotherAST.symbol <> betaGram.StaticItem) then
                           (if theListDiagram[] <> theOtherListDiagram[] then
                               theListDiagram.theParentNode->theParentNode[];
                               theParentNode.theDiagram->theParentDiagram[];
                               (theParentDiagram.localNodes.last).elm[]
                                 ->lastNode[];
                               lastNode.getAstNode->lastAST[];
                               (if lastAST[] = none then
                                   (if lastNode## <=
                                   theParentDiagram.NonterminalNode## then
                                       lastNode[]->theNonTerminalNode[];
                                       theNonTerminalNode.unexp->lastAST[]
                                    else
                                       'No AST for last node??'->putline
                                   if)
                               if);
                               (if lastAST[] <> none then
                                   anAST[]->anExp[];
                                   anExp.getSon1->theNames[];
                                   theNames.getSon1->theNameDcl[];
                                   theNameDcl.getNameDecl->aDeclAST[];
                                   (if aDeclAST.kind = mps.kinds.unExpanded then
                                       'NoName'->theName[]
                                    else
                                       theNameDcl.getText->theName[]
                                   if);
                                   theName.copy->t[];
                                   anotherAST[]->anotherExp[];
                                   anotherExp.getSon1->theOtherNames[];
                                   theOtherNames.getSon1->theOtherNameDcl[];
                                   theOtherNameDcl.getNameDecl
                                     ->anotherDeclAST[];
                                   (if anotherDeclAST.kind =
                                   mps.kinds.unExpanded then
                                       'NoName'->theOtherName[]
                                    else
                                       theOtherNameDcl.getText->theOtherName[]
                                   if);
                                   theOtherName[]->t.puttext;
                                   ':ManyToManyAssociation(# leftType::< '
                                     ->t.puttext;
                                   (lastAST[],anAST[])->getQualificationWithPath
                                     ->t.puttext;
                                   '; rightType::< '->t.puttext;
                                   (lastAST[],anotherAST[])
                                     ->getQualificationWithPath->t.puttext;
                                   ' #) '->t.puttext;
                                   &AssociationNode[]->theAssocNode[];
                                   (many,theListDiagram[],many,
                                    theOtherListDiagram[])
                                     ->theAssocNode.display;
                                   (if not gppProp.associations then
                                       false->theAssocNode.BorderVisible;
                                       (theAssocNode.c1).theText.get->help;
                                       help[]->(theAssocNode.c1).invisibleText;
                                       (theAssocNode.c1).theText.clear;
                                       false->(theAssocNode.c1).BorderVisible;
                                       (theAssocNode.c2).theText.get->help;
                                       help[]->(theAssocNode.c2).invisibleText;
                                       (theAssocNode.c2).theText.clear;
                                       false->(theAssocNode.c2).BorderVisible
                                   if);
                                   (theParentDiagram[],t[])->parseAfter;
                                   currentFocus[]->theAssocNode.thePatternNode;
                                   currentFocus.theDiagram
                                     ->thePatternNodeDiagram[];
                                   currentFocus[]->thePatternNode[];
                                   theAssocNode[]
                                     ->thePatternNode.theAssociationNode;
                                   (anAST[],many,anotherAST[],many,
                                    thePatternNode.theDeclaration)
                                     ->patternDiagrams.AssociationList.insert;
                                   t.clear;
                                   (theListDiagram.localNodes.last).elm[]
                                     ->lastNode[];
                                   lastNode.getAstNode->lastAST[];
                                   (if lastAST[] = none then
                                       (if lastNode## <=
                                       theListDiagram.NonterminalNode## then
                                           lastNode[]->theNonTerminalNode[];
                                           theNonTerminalNode.unexp->lastAST[]
                                        else
                                           'No AST for last node??'->putline
                                       if)
                                   if);
                                   (if lastAST[] <> none then
                                       'the'->t.puttext;
                                       theName[]->t.puttext;
                                       theOtherName[]->t.puttext;
                                       ':^'->t.puttext;
                                       theName[]->t.puttext;
                                       theOtherName[]->t.puttext;
                                       (theListDiagram[],t[])->parseAfter
                                   if);
                                   t.clear;
                                   (theOtherListDiagram.localNodes.last).elm[]
                                     ->lastNode[];
                                   lastNode.getAstNode->lastAST[];
                                   (if lastAST[] = none then
                                       (if lastNode## <=
                                       theOtherListDiagram.NonterminalNode##
                                        then
                                           lastNode[]->theNonTerminalNode[];
                                           theNonTerminalNode.unexp->lastAST[]
                                        else
                                           'No AST for last node??'->putline
                                       if)
                                   if);
                                   (if lastAST[] <> none then
                                       'the'->t.puttext;
                                       theName[]->t.puttext;
                                       theOtherName[]->t.puttext;
                                       ':^'->t.puttext;
                                       (lastAST[],anAST[])
                                         ->getQualificationWithPath
                                         ->dummyQual[];
                                       '.'
                                         ->dummyQual.findCh
                                           (#  do inx->index #);
                                       (index+1,dummyQual.length)
                                         ->dummyQual.delete;
                                       dummyQual[]->t.puttext;
                                       theName[]->t.puttext;
                                       theOtherName[]->t.puttext;
                                       (theOtherListDiagram[],t[])->parseAfter
                                   if)
                                else
                                   'lastAST i NONE??'->putline
                               if)
                            else
                               'Source and destination is the same diagram'
                                 ->AlertUser
                           if)
                        else
                           'Source and/or destination is singularly defined'
                             ->AlertUser
                       if)
                    else
                       'Source and/or destination is a descriptor form diagram'
                         ->AlertUser
                   if)
               if)
           if)
        else
           'Source or destination is not part of a pattern diagram'->AlertUser
       if)
   if)
#)  

-- parseAfter: DoPart --
do
   currentFocus[]->oldFocus[];
   (theListDiagram.LocalNodes.last).elm[]->currentFocus[]->currentObject;
   currentFocus.getASTNode->anAST[];
   (if anAST[] <> none then
       (anAST[],1)->(currentFocus.theSifEditor).changeFocus
    else
       currentFocus[]->theNonTerminalNode[];
       (theNonTerminalNode.unExp,1)->(currentFocus.theSifEditor).changeFocus
   if);
   (if canListInsert then
       (currentFocus.theSifEditor).after;
       currentFocus[]->theNonTerminalNode[];
       (theNonTerminalNode.unExp,parseText)
         ->(theNonTerminalNode.theSifEditor).parse
   if)  

-- FrejaOADPagePrivate: Descriptor --
(#
   constructingStaticItem: @Boolean;
   constructingDynamicItem: @Boolean;
   performingInsertAfter: @Boolean;
   performingInsertBefore: @Boolean;
   performingCut: @Boolean;
   performingCopy: @Boolean;
   performingPasteBefore: @Boolean;
   performingPaste: @Boolean;
   performingPasteAfter: @Boolean;
   performingExpand: @Boolean;
   ExpandNormal: @Boolean;
   ExpandSynCatNo: @Integer;
   performingNewPatternExpAfter: @Boolean;
   performingPartObjectExpAfter: @Boolean;
   performingDynamicReferenceExpAfter: @Boolean;
   performingVirtualPatternExpAfter: @Boolean;
   performingBindingOFVirtualPatternExpAfter: @Boolean;
   performingFinalBindingOFVirtualPatternExpAfter: @Boolean;
   newAssociationNode: ^AssociationNode;
   doOADPaste: @Boolean;
   
#)  

-- FrejaOADDocumentOnInit: Descriptor --
(# 
do
(* DocCreateMenu.init;
 *                   DocMakeupMenu.init;
 *                   DocPageMenu.init;
 *                   DocGroupMenu.init;
 *)
   (if not isBigEndian then DocTextMenu.init if);
   (UserMenu3,'File')->theFileMenu.init;
   (UserMenu2,'Edit')->FrejaEditMenu.init;
   (UserMenu9,'Templates')->AttributeKindMenu.init;
   (UserMenu8,'Expand')->theExpandMenu.Init;
   (UserMenu6,'Relations')->RelationsMenu.init;
   DocCreateMenu.init;
   DocMakeUpMenu.init;
   DocAlignMenu.init;
   UserMenu5->PageMenu.insertBefore;
   UserMenu7->DocAlignMenu.insertBefore;
   MenuID.AlignMenu->DocMakeUpMenu.insertBefore;
   MenuID.MakeUpMenu->DocCreateMenu.insertBefore;
   MenuID.CreateMenu->ViewMenu.insertBefore;
   UserMenu4->RelationsMenu.insertBefore;
   UserMenu6->theExpandMenu.insertBefore;
   UserMenu8->AttributeKindMenu.insertBefore;
   UserMenu9->FrejaEditMenu.insertBefore;
   UserMenu2->theFileMenu.insertBefore;
   (*  (UserMenu2,'Sif')->EditorMenu.init; *)
   (*  (UserMenu5,'Create') -> ObjectCreateMenu.init;*)
   
#)  

-- FrejaConnEndsGrammar: Descriptor --
(#
   thePage: ^theDocument.Page;
   theOADPage: ^theOADDocument.OADPage;
   theObject,theNode: ^thePage.DesignObject;
   delCon: ^theOADPage.DeletableConnector
do
   (if callbackVerbose then
       'callback ConnEndsGrammar'->putline;
       'conn: '->puttext;
       conn->putint;
       newline;
       'whichEnd: '->puttext;
       whichEnd->putint;
       newline;
       'nodeID: '->puttext;
       nodeID->putint;
       newline;
       'primNode: '->puttext;
       primNode->putint;
       newline
   if);
   theDocument.currentPage->thePage[];
   conn->theDocument.theObjectList.find->theObject[];
   (if theObject[] <> none then
       theDocument[]->theOADDocument[];
       (if thePage## <= theOADDocument.OADpage## then
           thePage[]->theOADPage[];
           (if theObject## <= theOADPage.deletableConnector## then
               NodeID->theDocument.theObjectList.find->theNode[];
               (if theNode[] <> none then
                   theObject[]->delCon[];
                   (theNode[],WhichEnd)->delCon.onReattach->ok
                else
                   'Cannot find new connector end '->puttext;
                   nodeID->putint;
                   newline
               if)
            else
               (if switch[1] then
                   'callback ConnEndsGrammar: it is not a deletableConnector'
                     ->putline
               if)
           if)
       if)
    else
       'Cannot find reattached connector '->puttext; conn->putint; newline
   if)
#)  

-- FrejaKbdEvent: Descriptor --
(#
   L: [1] @integer;
   aPtr: @externalRecord;
   thePage: ^theOADDocument.Page;
   op: ^theOADDocument.OADPage;
   theObject: ^op.DesignObject;
   thePatternDiagramNode: ^op.PatternDiagramNode;
   theListDiagram: ^op.ListDiagram;
   theDiagram: ^op.Diagram;
   thePosition: ^theListDiagram.localNodes.theCellType;
   theDiagPos: ^op.patternDiagrams.theList.theCellType;
   x,y,left,top,right,bottom: @integer
do
(*'KbdEvent, frejaLocked is: '->putText;
 Frejalocked->putInt;
 newLine;*)
   (if theFragmentBrowser.isActive then
       true->ok
    else
       (if callbackVerbose then 'Callback KbdEvent'->putLine if);
       (1,keyNrP)->getIntList->L;
       (if kbdStateP.controlKey = 1 then
           true->ok
        else
           false->ok;
           theDocument[]->theOADDocument[];
           (if theOADDocument[] <> none then
               theOADDocument.currentPage->thePage[];
               (if thePage[] <> none then
                   (if thePage## <= theOADDocument.OADPage## then
                       thePage[]->op[];
                       (if not op.ongoingTextediting then
                           (if op.currentObject <> none then
                               op.currentObject->theObject[];
                               (if theObject## <= op.PatternDiagramNode## then
                                   theObject[]->thePatternDiagramNode[];
                                   thePatternDiagramNode.theDiagram
                                     ->theListDiagram[];
                                   (if theListDiagram[] <> none then
                                       (if kbdStateP.altKey = 1 then
                                       (*(if [*enter*] L[1] = 65293 then
                                        thePatternDiagramNode.abstract
                                        if)*)
                                           (if L[1]
                                            // (*enter*) 65293 then
                                            (*theOADDocument.FrejaEditMenu.
                                             insertAfter.hit*)
                                               
                                            // (*pil til venstre*) 65361 then
                                               op.patternDiagrams.theList.locate
                                                 (#
                                                    predicate::< 
                                                      (# 
                                                      do
                                                         (theListDiagram[] =
                                                          current.elm.e[])
                                                           ->value
                                                      #)
                                                 #)->theDiagPos[];
                                               (if theDiagPos[] <> none then
                                                   (if theDiagPos.pred[] <> none
                                                   then
                                                       theDiagPos.pred.elm.e[]
                                                         ->theDiagram[];
                                                       theDiagram.titlenode[]
                                                         ->op.currentObject;
                                                       theDiagram.titleNode.
                                                         onSelect
                                                    else
                                                       ascii.bel->screen.put
                                                   if)
                                               if)
                                            // (*pil op*) 65362 then
                                               (if not
                                               (theListDiagram.localNodes.empty)
                                                then
                                                   theListDiagram.localNodes.
                                                     locate
                                                     (#
                                                        predicate::< 
                                                          (# 
                                                          do
                                                             (thePatternDiagramNode[]
                                                              = current.elm[])
                                                               ->value
                                                          #)
                                                     #)->thePosition[];
                                                   (if thePosition[] <> none
                                                    then
                                                       (if thePosition.pred[] <>
                                                       none then
                                                           thePosition.pred.
                                                             elm[]
                                                             ->op.currentObject;
                                                           thePosition.pred.elm.
                                                             onSelect
                                                        else
                                                           theListDiagram.
                                                             titleNode[]
                                                             ->op.currentObject;
                                                           theListDiagram.
                                                             titleNode.onSelect
                                                       if)
                                                    else
                                                       ascii.bel->screen.put
                                                   if)
                                                else
                                                   ascii.bel->screen.put
                                               if)
                                            // (*pil til hoejre*) 65363 then
                                               op.patternDiagrams.theList.locate
                                                 (#
                                                    predicate::< 
                                                      (# 
                                                      do
                                                         (theListDiagram[] =
                                                          current.elm.e[])
                                                           ->value
                                                      #)
                                                 #)->theDiagPos[];
                                               (if theDiagPos[] <> none then
                                                   (if theDiagPos.succ[] <> none
                                                   then
                                                       theDiagPos.succ.elm.e[]
                                                         ->theDiagram[];
                                                       theDiagram.titlenode[]
                                                         ->op.currentObject;
                                                       theDiagram.titleNode.
                                                         onSelect
                                                    else
                                                       ascii.bel->screen.put
                                                   if)
                                               if)
                                            // (*pil ned*) 65364 then
                                               (if not
                                               (theListDiagram.localNodes.empty)
                                                then
                                                   theListDiagram.localNodes.
                                                     locate
                                                     (#
                                                        predicate::< 
                                                          (# 
                                                          do
                                                             (thePatternDiagramNode[]
                                                              = current.elm[])
                                                               ->value
                                                          #)
                                                     #)->thePosition[];
                                                   (if thePosition[] <> none
                                                    then
                                                       (if thePosition.succ[] <>
                                                       none then
                                                           thePosition.succ.
                                                             elm[]
                                                             ->op.currentObject;
                                                           thePosition.succ.elm.
                                                             onSelect
                                                        else
                                                           ascii.bel->screen.put
                                                       if)
                                                    else
                                                       (
                                                       theListDiagram.localNodes
                                                       .head).elm[]
                                                         ->op.currentObject;
                                                       (
                                                       theListDiagram.localNodes
                                                       .head).elm.onSelect
                                                   if)
                                                else
                                                   ascii.bel->screen.put
                                               if)
                                           if)
                                       if)
                                   if)
                               if)
                           if)
                       if)
                   if)
               if);
               (if not theOADDocument.FrejaEditMenu.TextModeOn then
                   (if kbdstateP.altKey = 1 then
                       (if L[1]
                        // (*space*) 32 then
                           (if not
                           theOADDocument.FrejaEditMenu.iTextEdit.isDisabled
                            then
                               theOADDocument.FrejaEditMenu.iTextEdit.hit
                           if)
                        // (*A*) 65 then
                           (if not
                           theOADDocument.FrejaEditMenu.iPasteAfter.isDisabled
                            then
                               theOADDocument.FrejaEditMenu.iPasteAfter.hit
                           if)
                        // (*B*) 66 then
                        (* theOADDocument.FrejaEditMenu.iPasteBefore.hit*)
                           
                        // (*U*) 85 then
                           (if not
                           theOADDocument.FrejaEditMenu.iPasteBefore.isDisabled
                            then
                               theOADDocument.FrejaEditMenu.iPasteBefore.hit
                           if)
                        // (*a*) 97 then
                           (if not
                           theOADDocument.FrejaEditMenu.insertAfter.isDisabled
                            then
                               theOADDocument.FrejaEditMenu.insertAfter.hit
                           if)
                        // (*b*) 98 then
                        (* theOADDocument.FrejaEditMenu.insertBeforeItem.hit*)
                           
                        // (*c*) 99 then
                           (if not
                           theOADDocument.FrejaEditMenu.iCopy.isDisabled then
                               theOADDocument.FrejaEditMenu.iCopy.hit
                           if)
                        // (*d*) 100 then
                           (if not
                           theOADDocument.ViewMenu.detailItem.isDisabled then
                               theOADDocument.ViewMenu.detailItem.hit
                           if)
                        // (*f*) 102 then
                           (if not
                           theOADDocument.AttributeKindMenu.
                             FinalBindOfVirtPattern.isDisabled then
                               theOADDocument.AttributeKindMenu.
                                 FinalBindOFVirtPattern.hit
                           if)
                        // (*h*) 104 then
                           (if not
                           theOADDocument.AttributeKindMenu.LocalPattern.
                             isDisabled then
                               theOADDocument.AttributeKindMenu.LocalPattern.hit
                           if)
                        // (*i*) 105 then
                           (if not
                           theOADDocument.AttributeKindMenu.VirtualPattern.
                             isDisabled then
                               theOADDocument.AttributeKindMenu.VirtualPattern.
                                 hit
                           if)
                        // (*j*) 106 then
                           (if not
                           theOADDocument.FrejaEditMenu.iTextEdit.isDisabled
                            then
                               theOADDocument.FrejaEditMenu.iTextEdit.hit
                           if)
                        // (*k*) 107 then
                           (if not
                           theOADDocument.ViewMenu.AbstractItem.isDisabled then
                               theOADDocument.ViewMenu.AbstractItem.hit
                           if)
                        // (*l*) 108 then
                           (if not
                           theOADDocument.FrejaEditMenu.iShowOptionals.
                             isDisabled then
                               theOADDocument.FrejaEditMenu.iShowOptionals.hit
                           if)
                        // (*m*) 109 then
                           (if not
                           theOADDocument.AttributeKindMenu.
                             BindingOfVirtualPattern.isDisabled then
                               theOADDocument.AttributeKindMenu.
                                 BindingOfVirtualPattern.hit
                           if)
                        // (*n*) 110 then
                           (if not
                           theOADDocument.FrejaEditMenu.iRemoveOptionals.
                             isDisabled then
                               theOADDocument.FrejaEditMenu.iRemoveOptionals.hit
                           if)
                        // (*o*) 111 then
                           (if not
                           theOADDocument.AttributeKindMenu.PartObject.
                             isDisabled then
                               theOADDocument.AttributeKindMenu.PartObject.hit
                           if)
                        // (*p*) 112 then
                           (if not
                           theOADDocument.AttributeKindMenu.NewPattern.
                             isDisabled then
                               theOADDocument.AttributeKindMenu.NewPattern.hit
                           if)
                        // (*q*) 113 then
                           (if not
                           theOADDocument.FrejaEditMenu.iClear.isDisabled then
                               theOADDocument.FrejaEditMenu.iClear.hit
                           if)
                        // (*r*) 114 then
                           (if not
                           theOADDocument.AttributeKindMenu.DynamicReference.
                             isDisabled then
                               theOADDocument.AttributeKindMenu.DynamicReference
                               .hit
                           if)
                        // (*s*) 115 then
                           (if not
                           theOADDocument.FrejaEditMenu.iSearch.isDisabled then
                               theOADDocument.FrejaEditMenu.iSearch.hit
                           if)
                        // (*t*) 116 then
                           (if not
                           theOADDocument.FrejaEditMenu.iEditOtherText.
                             isDisabled then
                               theOADDocument.FrejaEditMenu.iEditOtherText.hit
                           if)
                        // (*u*) 117 then
                           (if not
                           theOADDocument.FrejaEditMenu.insertBeforeItem.
                             isDisabled then
                               theOADDocument.FrejaEditMenu.insertBeforeItem.hit
                           if)
                        // (*v*) 118 then
                           (if not
                           theOADDocument.FrejaEditMenu.iPaste.isDisabled then
                               theOADDocument.FrejaEditMenu.iPaste.hit
                           if)
                        // (*w*) 119 then
                           (if not
                           theOADDocument.FrejaEditMenu.iEditName.isDisabled
                            then
                               theOADDocument.FrejaEditMenu.iEditName.hit
                           if)
                        // (*x*) 120 then
                           (if not theOADDocument.FrejaEditMenu.iCut.isDisabled
                            then
                               theOADDocument.FrejaEditMenu.iCut.hit
                           if)
                        // (*z*) 122 then
                           (if not
                           theOADDocument.FrejaEditMenu.iUndo.isDisabled then
                               theOADDocument.FrejaEditMenu.iUndo.hit
                           if)
                       if)
                    else
                       true->ok
                   if)
                else
               (* (if kbdstateP.controlKey = 1 then
                (if L[1]
                // [*space*] 32 then
                theOADDocument.FrejaEditMenu.iTextEdit.hit
                // [*t*] 116 then
                theOADDocument.FrejaEditMenu.iRevertTextEdit.hit
                if)
                if)*)
                   
               if)
           if)
       if)
   if)
#)  

-- FrejaMouseDown: Descriptor --
(#  do  #)  

-- FrejaDoubleClick: Descriptor --
(#  do  #)  

-- FrejaPromptForText: DoPart --
do
   '                        '->message.append;
   (none ,'Freja',message[],defaultText[])
     ->theFragmentBrowser.promptForText
       (#
          ok::<  (#  do usertext[]->confirm #);
          cancel::<  (#  do THIS(FrejaPromptForText).cancel #);
          popup::< 
            (# 
            do
               (if defaultText[] <> none then
                   private.theText.all->private.theText.selection
               if)
            #)
       #)  

-- frejaSetReadOnly: DoPart --
do
   (if not readOnlyModeOn then
       true->readOnlyModeOn;
       'Write protected'->statusbar.set;
       FrejaEditMenu.iUndo.mydisable;
       FrejaEditMenu.iCut.mydisable;
       (* FrejaEditMenu.iCopy.mydisable;*)
       FrejaEditMenu.iPasteBefore.mydisable;
       FrejaEditMenu.iPaste.mydisable;
       FrejaEditMenu.iPasteAfter.mydisable;
       FrejaEditMenu.iClear.mydisable;
       FrejaEditMenu.insertBeforeItem.mydisable;
       FrejaEditMenu.insertAfter.mydisable;
       FrejaEditMenu.iEditName.mydisable;
       FrejaEditMenu.iTextEdit.mydisable;
       FrejaEditMenu.iRemoveOptionals.mydisable;
       FrejaEditMenu.iShowOptionals.mydisable;
       FrejaEditMenu.iCheck.mydisable;
       AttributeKindMenu.disable;
       theExpandMenu.disable;
       RelationsMenu.disable
   if)  

-- frejaUnsetReadOnly: DoPart --
do
   (if readOnlyModeOn then
       false->readOnlyModeOn;
       statusbar.reset;
       FrejaEditMenu.iUndo.myenable;
       FrejaEditMenu.iCut.myenable;
       (* FrejaEditMenu.iCopy.myenable;*)
       FrejaEditMenu.iPasteBefore.myenable;
       FrejaEditMenu.iPaste.myenable;
       FrejaEditMenu.iPasteAfter.myenable;
       FrejaEditMenu.iClear.myenable;
       FrejaEditMenu.insertBeforeItem.myenable;
       FrejaEditMenu.insertAfter.myenable;
       FrejaEditMenu.iEditName.myenable;
       FrejaEditMenu.iTextEdit.myenable;
       FrejaEditMenu.iRemoveOptionals.myenable;
       FrejaEditMenu.iShowOptionals.myenable;
       FrejaEditMenu.iCheck.myenable;
       AttributeKindMenu.enable;
       theExpandMenu.enable;
       RelationsMenu.enable
   if)  

-- GraphicalInterfaceEnableEditName: DoPart --
do
   theDesignInterface.theDocument[]->theOADDocument[];
   theOADDocument.FrejaEditMenu.iEditName.enable  

-- theGraphicalInterfaceDisableEditName: DoPart --
do
   theDesignInterface.theDocument[]->theOADDocument[];
   theOADDocument.FrejaEditMenu.iEditName.disable  

-- selfAssociateWindow: Descriptor --
theFragmentBrowser.window
  (#
     createAssociation:
       (#
          op: ^OADPage;
          thePatternDiagramNode,theParentNode,lastNode: ^op.PatternDiagramNode;
          theListDiagram,theParentDiagram,thePatternNodeDiagram:
            ^op.ListDiagram;
          theOADDiagram: ^op.OADDiagram;
          theAssocNode: ^op.AssociationNode;
          thePatternNode: ^thePatternNodeDiagram.PatternNode;
          theNonTerminalNode: ^theParentDiagram.NonTerminalNode;
          theDesc: ^betaGram.ObjectDescriptor;
          anAST,aDeclAST,lastAST: ^mps.ast;
          anExp: ^mps.expanded;
          theNames: ^betaGram.Names;
          theNameDcl: ^betaGram.NameDcl;
          theName,t,help: ^text
       do
          currentPage->op[];
          op.currentObject->thePatternDiagramNode[];
          thePatternDiagramNode.theDiagram->theListDiagram[];
          (if theListDiagram.localNodes.empty then
              theListDiagram.titleNode.getASTNode->anAST[];
              (if anAST[] <> none then
                  (anAST[],1)
                    ->(theListDiagram.titleNode.theSifEditor).changeFocus
              if);
              (theListDiagram.titleNode.theSifEditor).insertOptionals
          if);
          theListDiagram[]->theOADDiagram[];
          theOADDiagram.theDescriptor->theDesc[];
          theDesc.father->anAST[];
          (if true
           // switchesFrame.contents.otoBox.state then
              theListDiagram.theParentNode->theParentNode[];
              theParentNode.theDiagram->theParentDiagram[];
              (theParentDiagram.localNodes.last).elm[]->lastNode[];
              lastNode.getAstNode->lastAST[];
              (if lastAST[] = none then
                  (if lastNode## <= theParentDiagram.NonterminalNode## then
                      lastNode[]->theNonTerminalNode[];
                      theNonTerminalNode.unexp->lastAST[]
                   else
                      'No AST for last node??'->putline
                  if)
              if);
              (if lastAST[] <> none then
                  anAST[]->anExp[];
                  anExp.getSon1->theNames[];
                  theNames.getSon1->theNameDcl[];
                  theNameDcl.getNameDecl->aDeclAST[];
                  (if aDeclAST.kind = mps.kinds.unExpanded then
                      'NoName'->theName[]
                   else
                      theNameDcl.getText->theName[]
                  if);
                  theName.copy->t[];
                  theName[]->t.puttext;
                  ':OneToOneAssociation(# leftType::< '->t.puttext;
                  theName[]->t.puttext;
                  '; rightType::< '->t.puttext;
                  theName[]->t.puttext;
                  ' #) '->t.puttext;
                  &op.AssociationNode[]->theAssocNode[];
                  (op.one,theListDiagram[],op.one,theListDiagram[])
                    ->theAssocNode.display;
                  (if not gppProp.associations then
                      false->theAssocNode.BorderVisible;
                      (theAssocNode.c1).theText.get->help;
                      help[]->(theAssocNode.c1).invisibleText;
                      (theAssocNode.c1).theText.clear;
                      false->(theAssocNode.c1).BorderVisible;
                      (theAssocNode.c2).theText.get->help;
                      help[]->(theAssocNode.c2).invisibleText;
                      (theAssocNode.c2).theText.clear;
                      false->(theAssocNode.c2).BorderVisible
                  if);
                  (theParentDiagram[],t[])->op.parseAfter;
                  op.currentFocus[]->theAssocNode.thePatternNode;
                  op.currentFocus.theDiagram->thePatternNodeDiagram[];
                  op.currentFocus[]->thePatternNode[];
                  theAssocNode[]->thePatternNode.theAssociationNode;
                  (anAST[],op.one,anAST[],op.one,thePatternNode.theDeclaration)
                    ->op.patternDiagrams.AssociationList.insert;
                  t.clear;
                  (theListDiagram.localNodes.last).elm[]->lastNode[];
                  lastNode.getAstNode->lastAST[];
                  (if lastAST[] = none then
                      (if lastNode## <= theListDiagram.NonterminalNode## then
                          lastNode[]->theNonTerminalNode[];
                          theNonTerminalNode.unexp->lastAST[]
                       else
                          'No AST for last node??'->putline
                      if)
                  if);
                  (if lastAST[] <> none then
                      'the'->t.puttext;
                      theName[]->t.puttext;
                      theName[]->t.puttext;
                      ':^'->t.puttext;
                      theName[]->t.puttext;
                      theName[]->t.puttext;
                      (theListDiagram[],t[])->op.parseAfter
                  if)
               else
                  'lastAST i NONE??'->putline
              if)
           // switchesFrame.contents.otmBox.state then
              theListDiagram.theParentNode->theParentNode[];
              theParentNode.theDiagram->theParentDiagram[];
              (theParentDiagram.localNodes.last).elm[]->lastNode[];
              lastNode.getAstNode->lastAST[];
              (if lastAST[] = none then
                  (if lastNode## <= theParentDiagram.NonterminalNode## then
                      lastNode[]->theNonTerminalNode[];
                      theNonTerminalNode.unexp->lastAST[]
                   else
                      'No AST for last node??'->putline
                  if)
              if);
              (if lastAST[] <> none then
                  anAST[]->anExp[];
                  anExp.getSon1->theNames[];
                  theNames.getSon1->theNameDcl[];
                  theNameDcl.getNameDecl->aDeclAST[];
                  (if aDeclAST.kind = mps.kinds.unExpanded then
                      'NoName'->theName[]
                   else
                      theNameDcl.getText->theName[]
                  if);
                  theName.copy->t[];
                  theName[]->t.puttext;
                  ':OneToManyAssociation(# oneType::< '->t.puttext;
                  theName[]->t.puttext;
                  '; ManyElmType::< '->t.puttext;
                  theName[]->t.puttext;
                  ' #) '->t.puttext;
                  &op.AssociationNode[]->theAssocNode[];
                  (op.one,theListDiagram[],op.many,theListDiagram[])
                    ->theAssocNode.display;
                  (if not gppProp.associations then
                      false->theAssocNode.BorderVisible;
                      (theAssocNode.c1).theText.get->help;
                      help[]->(theAssocNode.c1).invisibleText;
                      (theAssocNode.c1).theText.clear;
                      false->(theAssocNode.c1).BorderVisible;
                      (theAssocNode.c2).theText.get->help;
                      help[]->(theAssocNode.c2).invisibleText;
                      (theAssocNode.c2).theText.clear;
                      false->(theAssocNode.c2).BorderVisible
                  if);
                  (theParentDiagram[],t[])->op.parseAfter;
                  op.currentFocus[]->theAssocNode.thePatternNode;
                  op.currentFocus.theDiagram->thePatternNodeDiagram[];
                  op.currentFocus[]->thePatternNode[];
                  theAssocNode[]->thePatternNode.theAssociationNode;
                  (anAST[],op.one,anAST[],op.many,thePatternNode.theDeclaration)
                    ->op.patternDiagrams.AssociationList.insert;
                  t.clear;
                  (theListDiagram.localNodes.last).elm[]->lastNode[];
                  lastNode.getAstNode->lastAST[];
                  (if lastAST[] = none then
                      (if lastNode## <= theListDiagram.NonterminalNode## then
                          lastNode[]->theNonTerminalNode[];
                          theNonTerminalNode.unexp->lastAST[]
                       else
                          'No AST for last node??'->putline
                      if)
                  if);
                  (if lastAST[] <> none then
                      'the'->t.puttext;
                      theName[]->t.puttext;
                      theName[]->t.puttext;
                      ':^'->t.puttext;
                      theName[]->t.puttext;
                      theName[]->t.puttext;
                      (theListDiagram[],t[])->op.parseAfter
                  if)
               else
                  'lastAST i NONE??'->putline
              if)
           // switchesFrame.contents.mtmBox.state then
              theListDiagram.theParentNode->theParentNode[];
              theParentNode.theDiagram->theParentDiagram[];
              (theParentDiagram.localNodes.last).elm[]->lastNode[];
              lastNode.getAstNode->lastAST[];
              (if lastAST[] = none then
                  (if lastNode## <= theParentDiagram.NonterminalNode## then
                      lastNode[]->theNonTerminalNode[];
                      theNonTerminalNode.unexp->lastAST[]
                   else
                      'No AST for last node??'->putline
                  if)
              if);
              (if lastAST[] <> none then
                  anAST[]->anExp[];
                  anExp.getSon1->theNames[];
                  theNames.getSon1->theNameDcl[];
                  theNameDcl.getNameDecl->aDeclAST[];
                  (if aDeclAST.kind = mps.kinds.unExpanded then
                      'NoName'->theName[]
                   else
                      theNameDcl.getText->theName[]
                  if);
                  theName.copy->t[];
                  theName[]->t.puttext;
                  ':ManyToManyAssociation(# leftType::< '->t.puttext;
                  theName[]->t.puttext;
                  '; rightType::< '->t.puttext;
                  theName[]->t.puttext;
                  ' #) '->t.puttext;
                  &op.AssociationNode[]->theAssocNode[];
                  (op.many,theListDiagram[],op.many,theListDiagram[])
                    ->theAssocNode.display;
                  (if not gppProp.associations then
                      false->theAssocNode.BorderVisible;
                      (theAssocNode.c1).theText.get->help;
                      help[]->(theAssocNode.c1).invisibleText;
                      (theAssocNode.c1).theText.clear;
                      false->(theAssocNode.c1).BorderVisible;
                      (theAssocNode.c2).theText.get->help;
                      help[]->(theAssocNode.c2).invisibleText;
                      (theAssocNode.c2).theText.clear;
                      false->(theAssocNode.c2).BorderVisible
                  if);
                  (theParentDiagram[],t[])->op.parseAfter;
                  op.currentFocus[]->theAssocNode.thePatternNode;
                  op.currentFocus.theDiagram->thePatternNodeDiagram[];
                  op.currentFocus[]->thePatternNode[];
                  theAssocNode[]->thePatternNode.theAssociationNode;
                  (anAST[],op.many,anAST[],op.many,
                   thePatternNode.theDeclaration)
                    ->op.patternDiagrams.AssociationList.insert;
                  t.clear;
                  (theListDiagram.localNodes.last).elm[]->lastNode[];
                  lastNode.getAstNode->lastAST[];
                  (if lastAST[] = none then
                      (if lastNode## <= theListDiagram.NonterminalNode## then
                          lastNode[]->theNonTerminalNode[];
                          theNonTerminalNode.unexp->lastAST[]
                       else
                          'No AST for last node??'->putline
                      if)
                  if);
                  (if lastAST[] <> none then
                      'the'->t.puttext;
                      theName[]->t.puttext;
                      theName[]->t.puttext;
                      ':^'->t.puttext;
                      theName[]->t.puttext;
                      theName[]->t.puttext;
                      (theListDiagram[],t[])->op.parseAfter
                  if)
               else
                  'lastAST i NONE??'->putline
              if)
          if)
       #);
     bCancel: @pushButton
       (#
          open:: 
            (#  do 'Cancel'->label; (30,140)->position; (60,20)->size #);
          eventhandler:: 
            (# onMouseUp::  (#  do THIS(selfAssociateWindow).close #) #)
       #);
     bOk: @pushButton
       (#
          open::  (#  do 'OK'->label; (100,140)->position; (60,20)->size #);
          eventhandler:: 
            (#
               onMouseUp:: 
                 (# 
                 do createAssociation; THIS(selfAssociateWindow).close
                 #)
            #)
       #);
     switchesFrame: @labelled
       (#
          contentsType:: canvas
            (#
               otoBox: @radioButton
                 (#
                    open:: 
                      (# 
                      do 'One-to-One'->label; (10,10)->position; (90,20)->size
                      #);
                    eventhandler:: 
                      (#
                         onMouseUp:: 
                           (# 
                           do
                              (if not state then
                                  false->otmBox.state; false->mtmBox.state
                               else
                                  true->state
                              if)
                           #)
                      #)
                 #);
               otmBox: @radioButton
                 (#
                    open:: 
                      (# 
                      do 'One-to-Many'->label; (10,40)->position; (90,20)->size
                      #);
                    eventhandler:: 
                      (#
                         onMouseUp:: 
                           (# 
                           do
                              (if not state then
                                  false->otoBox.state; false->mtmBox.state
                               else
                                  true->state
                              if)
                           #)
                      #)
                 #);
               mtmBox: @radioButton
                 (#
                    open:: 
                      (# 
                      do
                         'Many-to-Many'->label; (10,70)->position; (90,20)->size
                      #);
                    eventhandler:: 
                      (#
                         onMouseUp:: 
                           (# 
                           do
                              (if not state then
                                  false->otoBox.state; false->otmBox.state
                               else
                                  true->state
                              if)
                           #)
                      #)
                 #);
               open:: 
                 (# 
                 do otoBox.open; otmBox.open; mtmBox.open; true->otoBox.state
                 #)
            #);
          open:: 
            (#  do 'Association Type'->label; ((10,10),(160,130))->frame #)
       #);
     open::< 
       (# 
       do
          hide;
          THIS(selfAssociateWindow).contents->bCancel.open;
          THIS(selfAssociateWindow).contents->bOk.open;
          THIS(selfAssociateWindow).contents->switchesFrame.open;
          'Associate to Self'->title;
          (170,171)->size;
          INNER
       #);
     popup: (#  do open; showModal #)
  #)  

