ORIGIN 'preferencesDBbody';
INCLUDE '~beta/sysutils/envstring';
INCLUDE '~beta/unixlib/passwdhome';

--- preferencesLoad: dopart ---
do (# f: @file; line: ^text; sec, secSep: ^text;
      filename:@text;
      user,userhome:^text;
   do '$(HOME)'->expandenvVar->userhome[];
      userhome[]->putline;
      userhome->filename;
      '/.mjolnerrc/'->filename.append;
      OptionsName[]->filename.append;
      filename[]->f.name;
      filename[]->putline;
      (if f.entry.exists and f.entry.readable then
          f.openRead;
          ' *--+ *\\(\\w+\\) *: *section *--+ *'->secSep[];
          loop:
            (if not f.eos then
                f.getline->line[]; 
                (if line.length=0 then leave loop; if);
                line.reset;
                secSep[]->line.regexp_match
                (# noMatch:: (# do restart loop #)
                do ((1->regs.start)+1,1->regs.end)->line.sub->sec[];
                #);
                (if sec[]->sectionName.equalNCS then
                    innerLoop:
                      (if not f.eos then
                          f.getline->line[]; 
                          (if line.length=0 then 
                              l:
                                (if not f.eos then
                                    f.get -> line.put;
                                    restart l;
                                if);
                          if);
                          (if line.length=0 then leave innerLoop; if);
                          line.reset;
                          ' *\\(\\w+\\) *\\(\\w+\\) *\\(.+\\)'
                            ->line.regexp_match
                          (# noMatch::
                               (#
                               do secSep[]->line.regexp_match
                                  (# noMatch::
                                       (# 
                                       do 'Ignoring bogus line: '->puttext; 
                                          line[]->putline;
                                          restart innerLoop
                                       #)
                                  do leave loop
                                  #)
                               #);
                             n, t, v: ^text;
                             prefType: ##preference; prefVar: ^preference;
                          do ((1->regs.start)+1,1->regs.end)->line.sub->n[];
                             ((2->regs.start)+1,2->regs.end)->line.sub->t[];
                             ((3->regs.start)+1,3->regs.end)->line.sub->v[];
                             this(preferences).private.types.find
                             (# predicate::
                                  (# do current.name[]->t.equalNCS->value #);
                                notFound::
                                  (# (* instantiate as text type *)
                                  do 'Unknown preference type: "'->puttext;
                                     t[]->puttext;
                                     '" - "text" preference type used instead'
                                       ->putline;
                                     'CURRENTLY NOT IMPLEMENTED'->putline;
                                  #)
                             do current.type##->prefType##
                             #);
                             this(preferences).private.prefs.find
                             (# predicate::
                                  (# do current.name[]->n.equalNCS->value #);
                                notFound::
                                  (# (* define new variable *)
                                  do 'Undefined preference variable: "'->puttext;
                                     n[]->puttext;
                                     '" - Automatically defined'
                                       ->putline;
                                     'CURRENTLY NOT IMPLEMENTED'->putline;
                                  #)
                             do current.value[]->prefVar[];
                                true->current.value.changed;
                             #);
                             l: (if (v.length->v.inxGet)='\\' then
                                    (ascii.newline,v.length)->v.inxPut;
                                    (if not f.eos then
                                        f.getline->v.append; restart l
                                    if)
                                if);
                             v[]->prefVar.read;
                             restart innerLoop;
                          #);
                      if)
                 else restart loop
                if)
            if)
       else OptionsError
      if);
      f.close
   #)
   


--- preferencesSave: dopart ---
do (if changed then
       (# f, fn, fTemp: @file; line, sec, secSep: ^text; doneDump: @boolean;
          userhome,user:^text;
          filename:@text;
       do 'LOGNAME'->expandenvVar->user[];
          user[]->getpasswdhome->userhome[];
          userhome->filename;
          '//.mjolnerrc//'->filename.append;
          OptionsName[]->filename.append;
          filename[]->f.name; filename[]->fn.name;
          (if f.entry.exists and f.entry.readable and f.entry.writeable then
              '~'->OptionsName.append; 
              OptionsName[] -> fTemp.name;
              (if fTemp.entry.exists and fTemp.entry.writeable then
                  fTemp.delete;
              if);
              OptionsName[]->f.entry.rename;
              f.openRead; fn.openWrite;
              ' *--+ *\\(\\w+\\) *: *section *--+ *'->secSep[];
              loop:
                (if not f.eos then
                    f.getline->line[]; 
                    (if line.length=0 then leave loop; if);
                    line.reset; line[]->fn.putline;
                    secSep[]->line.regexp_match
                    (# noMatch:: (# do restart loop #)
                    do ((1->regs.start)+1,1->regs.end)->line.sub->sec[];
                    #);
                    (if sec[]->sectionName.equalNCS then
                        (fn[],false)->dump; true->doneDump;
                        innerloop:
                          (if not f.eos then
                              f.getline->line[]; 
                              (if line.length=0 then 
                                  l:
                                    (if not f.eos then
                                        f.get -> line.put;
                                        restart l;
                                    if);
                              if);
                              (if line.length=0 then leave innerLoop; if);
                              line.reset;
                              secSep[]->line.regexp_match
                              (# noMatch:: (# do restart innerloop #) 
                              do line[]->fn.putline; leave innerLoop
                              #)
                          if)
                     else
                        restart loop
                    if)
                if);
              (if not doneDump then
                  '--- '->fn.puttext; sectionName[]->fn.puttext; ': section ---'->fn.putline;
                  (fn[],false)->dump;
              if);
              loop:
                (if not f.eos then
                    f.getline->fn.putline;
                    restart loop
                if);
              f.close; fn.close
           else (if f.entry.writeable then
                    fn.openWrite;
                    '--- '->fn.puttext; sectionName[]->fn.puttext; ': section ---'->fn.putline;
                    (fn[],false)->dump;
                 else OptionsError
                if)
          if)
       #)
   if)
