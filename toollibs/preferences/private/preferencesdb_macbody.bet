ORIGIN 'preferencesDBbody';
LIB_ITEM 'preferencesdb';
INCLUDE '~beta/sysutils/envstring'
        '~beta/basiclib/directory';
INCLUDE '~beta/maclib/morefiles';
INCLUDE '~beta/maclib/files';
INCLUDE '~beta/maclib/folders';
	
	
-- lib: attributes --
getPrefs:
	(# path: ^text;
	   vRefNum: @shortRef;
	   dirID: @longInt;
	   spec: @FSSpec;
	   error: @integer;
	   name: ^Text;
	enter name[]
	do (kOnSystemDisk, kPreferencesFolderType, kCreateFolder, vRefNum[], dirID[])
		  -> FindFolder 
		  -> error;
	   (if error = 0 then
		  (vRefNum, dirID,'', spec[]) -> FSMakeFSSpec -> error;
		  (if error = 0 then
			 spec[] -> convertToFullPath -> path[];
			 (if path[] <> NONE then
				name[] -> path.append;
			 if);
		  if);
	   if);
	exit path[]
	#);
			
-- preferencesLoad: DoPart --
do
     (#
        f: @file;
        line: ^text;
        sec,secSep: ^text;
        filename: ^text;
        user,userhome: ^text;
        secondtry: @boolean;
		
     do OptionsName[] -> getPrefs -> fileName[];
	    
        filename[]->f.name;
		l:
        (if f.entry.exists and f.entry.readable then
            f.openRead;
            ' *--+ *\\(\\w+\\) *: *section *--+ *'->secSep[];
            loop:
            (if not f.eos then
                f.getline->line[];
                (if line.length = 0 then leave loop;  if);
                line.reset;
                secSep[]
                  ->line.regexp_match
                    (# noMatch::  (#  do restart loop #)
                    do ((1->regs.start)+1,1->regs.end)->line.sub->sec[]; 
                    #);
                (if sec[]->sectionName.equalNCS then
                    innerLoop:
                    (if not f.eos then
                        f.getline->line[];
                        (if line.length = 0 then
                            l:
                            (if not f.eos then
                                f.get->line.put; restart l; 
                            if);
                            
                        if);
                        (if line.length = 0 then leave innerLoop;  if);
                        line.reset;
                        ' *\\(\\w+\\) *\\(\\w+\\) *\\(.+\\)'
                          ->line.regexp_match
                            (#
                               noMatch:: 
                                 (# 
                                 do
                                    secSep[]
                                      ->line.regexp_match
                                        (#
                                           noMatch:: 
                                             (# 
                                             do
                                                'Ignoring bogus line: '
                                                  ->puttext;
                                                line[]->putline;
                                                restart innerLoop
                                             #)
                                        do leave loop
                                        #)
                                 #);
                               n,t,v: ^text;
                               prefType: ##preference;
                               prefVar: ^preference;
                               
                            do
                               ((1->regs.start)+1,1->regs.end)->line.sub->n[];
                               ((2->regs.start)+1,2->regs.end)->line.sub->t[];
                               ((3->regs.start)+1,3->regs.end)->line.sub->v[];
                               THIS(preferences).private.types.find
                                 (#
                                    predicate:: 
                                      (# 
                                      do current.name[]->t.equalNCS->value
                                      #);
                                    notFound:: 
                                      (# (* instantiate as text type *) 
                                      do
                                         'Unknown preference type: "'->puttext;
                                         t[]->puttext;
                                         '" - "text" preference type used instead'
                                           ->putline;
                                         'CURRENTLY NOT IMPLEMENTED'->putline;
                                         
                                      #)
                                 do current.type##->prefType##
                                 #);
                               THIS(preferences).private.prefs.find
                                 (#
                                    predicate:: 
                                      (# 
                                      do current.name[]->n.equalNCS->value
                                      #);
                                    notFound:: 
                                      (# (* define new variable *) 
                                      do
                                         restart innerLoop;
                                         'Undefined preference variable: "'
                                           ->puttext;
                                         n[]->puttext;
                                         '" - Automatically defined'->putline;
                                         'CURRENTLY NOT IMPLEMENTED'->putline
                                      #)
                                 do
                                    current.value[]->prefVar[];
                                    true->current.value.changed;
                                    
                                 #);
                               l:
                               (if (v.length->v.inxGet) = '\\' then
                                   (ascii.newline,v.length)->v.inxPut;
                                   (if not f.eos then
                                       f.getline->v.append; restart l
                                   if)
                               if);
                               v[]->prefVar.read;
                               restart innerLoop;
                               
                            #);
                        
                    if)
                 else
                    restart loop
                if)
            if);
            f.close;
            
         else
            (if secondtry then
                OptionsError (* raise exception *)
             else
                '$(BETALIB)'->expandenvVar->userhome[];
                userhome->filename;
                '/mjolnertool/'->filename.append;
                OptionsName[]->filename.append;
                filename[]->f.name;
                true->secondtry;
                restart l;
                
            if);
            
        if);
        
     #)  

-- preferencesSave: DoPart --
do
   l:(if changed then
         (#
            f,fn,fTemp: @file;
            line,sec,secSep: ^text;
            doneDump: @boolean;
            userhome,user: ^text;
            filename: ^text;
            
         do OptionsName[] -> getPrefs -> fileName[];
            filename[]->f.name;
            filename[]->fn.name;
            (if not f.entry.exists then
                f.openwrite;
                f.close;
            if);
            (if f.entry.exists and f.entry.readable and f.entry.writeable then
                '~'->fileName.append;
                fileName[]->fTemp.name;
                (if fTemp.entry.exists and fTemp.entry.writeable then
                    fTemp.delete; 
                if);
                fileName[]->f.entry.rename (#  #);
				
				
                f.openRead;
				
                fn.openWrite;
                ' *--+ *\\(\\w+\\) *: *section *--+ *'->secSep[];
                loop:
                (if not f.eos then
                    f.getline->line[];
                    (if line.length = 0 then leave loop;  if);
                    line.reset;
                    line[]->fn.putline;
                    secSep[]
                      ->line.regexp_match
                        (# noMatch::  (#  do restart loop #)
                        do ((1->regs.start)+1,1->regs.end)->line.sub->sec[]; 
                        #);
                    (if sec[]->sectionName.equalNCS then
                        (fn[],true)->dump;
                        true->doneDump;
                        innerloop:
                        (if not f.eos then
                            f.getline->line[];
                            (if line.length = 0 then
                                l:
                                (if not f.eos then
                                    f.get->line.put; restart l; 
                                if);
                                
                            if);
                            (if line.length = 0 then leave innerLoop;  if);
                            line.reset;
                            secSep[]
                              ->line.regexp_match
                                (# noMatch::  (#  do restart innerloop #)
                                do line[]->fn.putline; leave innerLoop
                                #)
                        if)
                     else
                        restart loop
                    if)
                if);
                (if not doneDump then
                    '--- '->fn.puttext;
                    sectionName[]->fn.puttext;
                    ': section ---'->fn.putline;
                    (fn[],false)->dump;
                    
                if);
                loop:
                (if not f.eos then f.getline->fn.putline; restart loop if);
                f.close;
                fn.close
             else
                (if f.entry.writeable then
                    fn.openWrite;
                    '--- '->fn.puttext;
                    sectionName[]->fn.puttext;
                    ': section ---'->fn.putline;
                    (fn[],false)->dump;
                    
                 else
                    OptionsError
                if)
            if)
         #)
   if)  

