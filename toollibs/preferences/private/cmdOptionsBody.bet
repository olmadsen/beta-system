ORIGIN '../cmdOptions';
INCLUDE '~beta/basiclib/v1.6/formatio';
INCLUDE 'preferencesBody';

--- preferencesReadArguments: dopart ---
do (# readArgs:
	(# peekArg:< (# arg: ^text do INNER exit arg[] #);
	   getArg:< (# arg: ^text do INNER exit arg[] #);
	   moreArgs:< booleanValue;
	   init:< (# do INNER #);
	   option, optionName: ^text; shortCutChar: @char;
	   combinedShortcuts: @boolean;
	   activateCmd:
	     private.prefs.find
	     (# predicate:: 
		  (#
		  do (current.type##<=cmdPreference##) and
		     (optionName[]->current.name.equalNCS)->value
		  #);
		notFound::
		  (#
		  do '*** Unknown command option "'->puttext;
		     option[]->puttext;
		     '" - ignored'->putline
		  #);
		pref: ^cmdArgs
	     do (if (current.type##<=cmdArgs##) then
		    current.value[]->pref[];
		    0->pref.noOfArgs;
		    l: (if (moreArgs) and
			   ('-'<>(1->(peekArg).inxGet)) then
			   (if ((0=pref.maxArgs) or
			       (pref.noOfArgs<pref.maxArgs)) and
			       (peekArg->pref.legalArg) then
			       (if pref.noOfArgs=pref.args.range then
				   1->pref.args.extend
			       if);
			       pref.noOfArgs+1->pref.noOfArgs;
			       getArg->pref.args[pref.noOfArgs][];
			       restart l
			   if)
		       if);
		    0->private.args.new
		if);  
		(current.value[]->qua(# as:: cmdPreference #)).onAction
	     #);
	   activateCmdToggle:
	     private.prefs.find
	     (# predicate:: 
		  (#
		  do (current.type##<=cmdToggle##) and
		     (optionName[]->current.name.equalNCS)->value
		  #);
		notFound::
		  (#
		  do '*** Unknown command option "'->puttext;
		     option[]->puttext;
		     '" - ignored'->putline
		  #)
	     do (current.value[]->qua(# as:: cmdToggle #)).offAction
	     #);
	   activateShortCut:
	     private.prefs.find
	     (# predicate:: 
		  (#
		  do (current.type##<=cmdPreference##) and
		     (shortCutChar=(current.value[]->qua(# as:: cmdPreference #)).shortCut)
		       ->value
		  #);
		notFound::
		  (#
		  do '*** Unknown command shortcut "'->puttext;
		     shortCutChar->put;
		     '" - ignored'->putline
		  #);
		pref: ^cmdArgs
	     do (if (current.type##<=cmdArgs##) then
		    (if not combinedShortcuts then
			current.value[]->pref[];
			0->pref.noOfArgs;
			l: (if (moreArgs) and
			       ('-'<>(1->(peekArg).inxGet)) then
			       current.value[]->pref[];
			       (if ((0=pref.maxArgs) or
				   (pref.noOfArgs<pref.maxArgs)) and
				   (peekArg->pref.legalArg) then
				   (if pref.noOfArgs=pref.args.range then
				       1->pref.args.extend
				   if);
				   pref.noOfArgs+1->pref.noOfArgs;
				   getArg->pref.args[pref.noOfArgs][];
				   restart l
			       if)
			   if)
		     else
			'*** Shortcut forms of command options with arguments are '
			  ->putline;
			'*** only allowed as the last shortcut in a shortcut list'
			  ->putline;
			'*** Offending shortcut "'->puttext; shortCutChar->put;
			'" - ignored'->putline
		    if)
		if);
		(current.value[]->qua(# as:: cmdPreference #)).onShortcutAction
	     #)
	do init;
	   l: (if moreArgs then
		  getArg->option[];
		  (if true
		   // '--no'->((1,4)->option.sub).equalNCS then
		      (if private.noOfArgs>0 then INNER readArgs if);
		      (5,option.length)->option.sub->optionName[];
		      activateCmdToggle
		   // '--'->((1,2)->option.sub).equalNCS then
		      (if private.noOfArgs>0 then INNER readArgs if);
		      (3,option.length)->option.sub->optionName[];
		      activateCmd
		   // '-'=(1->option.inxGet) then
		      (if private.noOfArgs>0 then INNER readArgs if);
		      1->option.setpos;
		      option.scan
		      (# while:: (# do true->value #)
		      do ch->shortCutChar;
			 (option.pos<option.length)->combinedShortcuts;
			 activateShortCut
		      #);
		   else
		      (* rest is 'plain' text arguments *)
		      (if private.noOfArgs=private.args.range then 1->private.args.extend if);
		      private.noOfArgs+1->private.noOfArgs;
		      option[]->private.args[private.noOfArgs][];
		  if);
		  restart l
	      if)
	#);
   do (if argStream[]=NONE then
	  readArgs
	  (# i: @integer;
	     init:: (# do 1->i #);
	     moreArgs:: (# do (i<noOfArguments)->value #);
	     peekArg:: (# do i+1->arguments->arg[] #);
	     getArg:: (# do i+1->i->arguments->arg[] #);
	  do INNER readArguments
	  #);
       else
	  readArgs
	  (# args: [0]^text; i: @integer;
	     init::
	       (#
	       do argStream.reset;
		  l: (if not argStream.eos then
			 1->args.extend;
			 argStream.getAtom->args[args.range][];
			 restart l
		     if);
	       #);
	     moreArgs:: (# do (i<args.range)->value #);
	     peekArg:: (# do args[i+1][]->arg[] #);
	     getArg:: (# do args[i+1->i][]->arg[] #);
	  do INNER readArguments
	  #)
      if);
      INNER readArguments;
   #)
     
--- preferencesNoOfArgs: dopart ---
do private.noOfArgs->value

--- preferencesScanArguments: dopart ---
do (for i: noOfArgs repeat
	private.args[i][]->current[];
	INNER scanArguments
   for);

--- dumpCmds: dopart ---
do (if strm[]=NONE then screen[]->strm[] if);
   'Usage:\t%s [options] [%s1 ... %sN]\n'
     ->strm.putformat(# do programName->s; argumentName->s; argumentName->s #);
   '\twhere %s is not an option, and\n'
     ->strm.putformat(# do argumentName->s #);
   '\twhere [options] are one or more of:\n'
     ->strm.putline;
   private.prefs.scan
   (# where:: (# do (current.type##<=cmdPreference##)->value #);
      pref: ^cmdPreference
   do current.value[]->pref[];
      ' --'->strm.puttext; current.name[]->strm.puttext;
      (for private.typesMaxWidth-current.name.length repeat ' '->strm.put for);
      (if (pref##<=cmdtoggle##) and
	  (pref.onShortcutAction##=(pref[]->qua(# as:: cmdToggle #)).offAction##) then
	  '*    '->strm.puttext
       else
	  (if pref.default then '*'->strm.put else ' '->strm.put if); ' '->strm.put;
	  (if pref.shortcut<>0 then
	      '-'->strm.put; pref.shortcut->strm.put; ' '->strm.put
	   else '   '->strm.puttext
	  if);
      if);
      pref.description.scanAll
      (#
      do ch->strm.put;
	 (if ch//ascii.nl//ascii.cr then
	     (for private.typesMaxWidth+8 repeat ' '->strm.put for)
	 if)
      #);
      strm.newline;
      (if pref##<=cmdtoggle## then
	  ' --no'->strm.puttext; current.name[]->strm.puttext;
	  (for private.typesMaxWidth-current.name.length-2 repeat ' '->strm.put for);
	  (if (pref.onShortcutAction##=(pref[]->qua(# as:: cmdToggle #)).offAction##) then
	      (if pref.shortcut<>0 then
		  '  -'->strm.puttext; pref.shortcut->strm.put; ' '->strm.put
	       else '   '->strm.puttext
	      if)
	   else
	      '*   '->strm.puttext
	  if);
	  strm.newline;
      if);
      strm.newline;
   #);
   'For long options with both "--<name>" and "--no<name>" forms:'
     ->strm.putline;
   '\tActivate the option using   "--<name>"'->strm.putline;
   '\tDeactivate the option using "--no<name>"'->strm.putline;
   'The single letter option type "-<ch>" allow multiple letters'
     ->strm.putline;
   '\tafter the "-" (e.g. "-qwd").'->strm.putline;
   'Long option names are case insensitive.'->strm.putline;
   'Single letter options are case sensitive.'->strm.putline;
   '"*" above indicates the default option.'->strm.putline;
