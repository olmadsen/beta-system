Origin '~beta/basiclib/betaenv';
Include 'indenter';
Body 'private/betaIndenterBody';

-- lib: attributes --

betaIndenter: indenter
  (#           
     <<SLOT betaTextFieldLib:Attributes>>;
     init::  (#  <<SLOT Init:DoPart>> #);
     textLine::
       (# comment,star: @boolean;
          rigid,commentIndent,commentDirty: @integer;
       #);
     
     setContents:: (# <<SLOT beta_setContents:doPart>> #);
     
     updateCommentIndent:
       (# line,indentValue: @integer;
       enter (line,indentValue)
       <<SLOT updateCommentIndent:doPart>>
       #);
     
     getIndent::
       (# <<SLOT beta_getIndent:doPart>> #);
     
     getActualIndent::
       (# <<SLOT beta_getActualIndent: doPart>> #);
     
     newPosition:
       (# line,absolutCol,indentValue: @integer
       enter (line,indentValue,absolutCol)
       <<SLOT newPosition:doPart>>
       exit (absolutCol,indentValue)
       #);
     
     HandleCommentBegin:
       (* if the line has a begin
        * comment. Then return the body 
        * of this comment
        *)
       (# line,indent: @integer;
          found: @boolean; t: ^text;
       enter line
       <<SLOT HandleCommentBegin:doPart>>
       exit (found, indent, t[])
       #);
     
     Handle_comment:
       (* Checks if the previous line is a 
        * comment or start one
        *)
       (# line: @integer
       enter line
       <<SLOT Handle_comment:DoPart>>
       #);
     
     indentLine:: 
       (# <<SLOT beta_indent_line:DoPart>> #);
     
     indent_current:
       (#  line,indentValue: @integer; done: @boolean
       enter line
       <<SLOT indent_current:DoPart>>
       exit (indentValue,done)
       #);
     
     indent_previous:
       (# line,indentValue: @integer
       enter line
       <<SLOT indent_previous:DoPart>>
       exit indentValue
       #);
     
     check_doPart:
       (# indentValue,line: @integer;
       enter line
       <<SLOT check_doPart: doPart>>
       exit indentValue
       #);
     
     findBlockDefIndent:
       (# line,type,indent: @integer; found:@boolean
       enter (line,type)
       <<SLOT findBlockDefIndent: doPart>>
       exit (indent,found)
       #);
     
     beginsWithCommentEnd:
       (# t: ^text; value: @boolean
       enter t[]
       <<SLOT beginsWithCommentEnd:doPart>>
       exit value
       #);
     
     lableCheck:
       (# t: ^text; b: @boolean
       enter t[]
       <<SLOT lableCheck:DoPart>>
       exit b
       #);
     remove_harmless:
       (# t: ^text
       enter t[]
       <<SLOT remove_harmless:DoPart>>
       #);
     close_construct:
       (* Returns the close-construct to the first 
        * seen unmatched open-construct when 
        * scanning backwards from the called
        * position
        *)
       (# line,pos: @integer; endBlock: ^text;
       enter (line,pos)
       <<SLOT close_construct:DoPart>>
       exit endBlock[]
       #);
     
     surrounding_comment:
       (# line,col,pos,endPos: @integer
       enter (line,col)
       <<SLOT surrounding_comment:DoPart>>
       exit (pos,endPos)
       #);
     
     inside_comment: 
       (# line,pos: @integer; value: @boolean 
       enter (line,pos)
       <<SLOT inside_comment:doPart>>
       exit value
       #);     
     
     shadow_string_constants:
       (* makes all text in a stringconstant 
        * to whitespace
        *)
       (# t: ^text
       enter t[]
       <<SLOT shadow_string_constants:DoPart>>
       exit t[]
       #);
     
     constructAllowed:
       (# line,pos: @integer; value: @boolean
       enter (line,pos)
       <<SLOT constructAllowed:doPart>> 
       exit value
       #);
  #)
