ORIGIN 'mpsinterface';
LIB_DEF 'toollibsmpsutil' '../../lib';
INCLUDE '~beta/mps/astlevel';
BODY 'private/mpsutilsbody';

(* original file: *)

--- mpsinterfacelib:attributes ---

getEnclosingAst:
  (* Returns the first enclosing ast of the syntactical category given by
   * symbol.
   * 
   * By default, the attempt to locate the enclosing ast stops if a
   * fragment is met. This default may be changed by further binding
   * followFragments to TrueObject. *)
  (# followFragments:< BooleanValue;
     a,af: ^AST.ast;
     symbol: @Integer;
  enter (a[],symbol)
  do 
     loop:
       (if a[]<>NONE then
           (if a.symbol=symbol then
               leave loop;
            else
               a.father->af[];
               (if af[]//NONE then
                   (if followFragments then a.frag[]->findSlot->a[]
                    else
                       NONE->a[];
                       leave loop;
                   if);
                else
                   af[]->a[];
               if);
               restart loop;
           if);
       if);
  exit a[]
  #);

findSlot:
  (* Return the SLOT bound to fragmentForm ff. *)
  (# ff: ^AST.fragmentForm;
     fg,fgf: ^AST.fragmentGroup;
     theSlot: ^AST.slotDesc;
  enter ff[]
  do (if ff.binding[]//NONE then
         ff.father->fg[];
         fg[]->fgf[];
         (* Setup origin chain. *)
         loop:
           (if fgf[]<>NONE then
               (if fgf.origin//NONE then
                   fgf[]->mySetupOrigin;
                   fgf.origin->fgf[];
                   restart loop;
               if)
           if);
         ff[]->fg.bind->ff.binding[]->theSlot[]
      else
         ff.binding[]->theSlot[];
     if);
  exit theSlot[]
  #);

lastInList:
  (* Returns the last non-optional element in l *)
  (# listType:< AST.list;
     l: ^listType;
     last: ^AST.ast;
  enter l[]
  do 
     l.newScan 
     (# 
     do (if current.kind<>AST.kinds.optional then
            current[]->last[]
        if)
     #);
  exit last[]   
  #);

nextbrother:
  (* Returns the next non-optional brother of a. *)
  (# a: ^AST.ast;
  enter a[]   
  do a.nextbrother->a[];
     loop:
       (if a[]<>NONE then
           (if a.kind<>AST.kinds.optional then
               leave loop
            else
               a.nextbrother->a[];
               restart loop;
           if);
       if);
  exit a[]
  #);


(* From interfacebuilder/mpsstuff/mpsutils: *)

-- listLib: attributes --

iterate:
  (# doSlot:<
       (#  theSlot: ^slotDesc;
       enter theSlot[] 
       do inner;
       #);
     doOptional:<
       (# theOptional: ^optional;
       enter theOptional[]
       do inner;
       #);
     current: ^sonCat;
  <<SLOT MPSlistIterate: doPart>>
  #);

removeEmptySons:
  (# <<SLOT MPSlistRemoveEmptySons: doPart>> #);
prepend:
  (# son: ^sonCat;
  enter son[]
  <<SLOT MPSlistPrepend: doPart>>
  #);
smartAppend:
  (# son: ^sonCat;
  enter son[]
  <<SLOT MPSListSmartAppend: doPart>>
  #);

-- astLib: attributes --

hasGUIcomment: booleanValue
  (# 
  <<SLOT MPSAsthasGUIcomment: doPart>>
  #);
guiInfo:
  (# value: @integer;
  enter (# enter value <<SLOT MPSAstEnterGUIinfo: doPart>> #)
  exit (# <<SLOT MPSASTExitGUIinfo: doPart>> exit value #)
  #);

iterateComments:
  (# current: ^text;
  <<SLOT MPSAstIterateComments: doPart>>
  #);
myInsertSubComment:
  (# theComment: ^text;
     inx: @integer;
  enter (theComment[], inx)
  <<SLOT MPSAstInsertSubComments: doPart>>
  #);

-- astInterfaceLib: attributes --

interactiveErrorReporter: errorReporter
  (# 
     beforeFirstError::<
       (# <<SLOT MPSinteractiveErrorReporterbeforeFirstError: doPart>> #);
     afterLastError::<
       (# <<SLOT MPSinteractiveErrorReporterafterLastError: doPart>> #);
     forEachError::<
       (# <<SLOT MPSinteractiveErrorReporterforEachError: doPart>> #);
  #);

-- fragmentGroupLib: attributes --
localPath:
  (# fullPath: ^text;
     localizedPath: ^text;
  enter fullPath[]
  <<SLOT MPSfragmentGroupLocalPath: doPart>>
  exit localizedPath[]
  #);
fullPath:
  (# localPath: ^text;
     expandedPath: ^text;
  enter localPath[]
  <<SLOT MPSfragmentGroupFullPath: doPart>>
  exit expandedPath[]
  #);
shortName:
  (# name: ^text;
  <<SLOT MPSfragmentGroupShortName: doPart>>
  exit name[]
  #);

scanBodyGroups:
  (* Primitive version: doesnt include MDBODY *)
  (# currentLocalPath, currentFullPath: ^text;
  <<SLOT fragmentGroupScanBodyGroups: doPart>>
  #);


(* end of file *)
