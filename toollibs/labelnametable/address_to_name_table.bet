ORIGIN 'nameTable';
--LIB: attributes--
address_to_name_table:
  (#
     handle: @integer;
     startLabelRead:<Object;
     doneLabelRead:<Object;
     execfilename:<
       (# name: ^text;
       do INNER
       exit name[]
       #);
     labels: [initialCapacity] ^Text;
     values: [initialCapacity] @Integer;
     initialCapacity: (# exit 6000 #);
     count: @Integer;
     max: @Integer;
     initialized: @Boolean;
     nmforked: @Boolean;
     forknm:
       (# tmp: ^text;
       do execFilename->tmp[];
          (tmp,false)->initReadNameTable->handle;
          TRUE->nmforked; 
       #);
     readFromExecutable:
       (* Reads the code labels of the executable into this table. *)
       (# tmp: ^Text; val: @Integer; 
       do startLabelRead;
          (if not nmforked then forknm if);
          initialCapacity->max;
          (* It is assumed that the labels are read in ascending order!! *)
          loop:
            (* datpete 14/3/96; chnged check for 0 to check for -1:
             * sgi has several symbols for address 0, 
             * which comes first in the ascending order 
             * => no labels are read.
             *)
            (if (handle->nextAddress->val) <> - 1 then
                count+1->count;
                (if count > max then
                    labels.range->labels.extend;
                    labels.range->max;
                    values.range->values.extend;
                    
                if);
                ''->tmp[];
                handle->nextLabel->tmp;
                tmp[]->labels[count][];
                val->values[count];
                restart loop;
                
            if);
          doneLabelRead;
          TRUE->initialized;
          FALSE->nmforked;
          
       #);
     findNearestLabel:
       (#
          adr: @Integer;
          low,mid,high: @Integer;
          label: ^Text;
          value: @Integer;
          
       enter adr
       do
          (if not initialized then readFromExecutable if);
          (if count > 0 then (* count=0 => the executable is stripped *)
              1->low;
              count->high;
              (low+high) div 2->mid;
              binsearch:
                (if high = low then
                    (if values[low] = adr then
                        labels[low][]->label[]; values[low]->value; 
                     else
                        (if mid > 1 then
                            labels[low-1][]->label[]; values[low-1]->value; 
                        if);
                        
                    if);
                    
                 else
                    (if values[mid] < adr then
                        mid+1->low; 
                     else
                        mid->high; 
                    if);
                    (low+high) div 2->mid;
                    restart binsearch;
                    
                if)
           else
              'Unknown label'->label[]; adr->value
          if);
          
       exit (label[],value)
       #);
     
  #)
