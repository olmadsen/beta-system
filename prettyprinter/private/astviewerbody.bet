ORIGIN '../astviewer';


-- AstViewerInit: doPart --
do (if gram[] = NONE then
       grammarname[] -> grammartable.lookup -> gram[];
   if);
   (if gram[] <> NONE then
       &gram.UnParser[] -> unparser[];
       filename[] -> unparser.init;
   if);
   80 -> width;
   
-- AstViewerPrintUntilLevelOn: doPart --
do (# tokens: @TokenStream;
   do tokens.init;
      width -> tokens.width;
      (node[], tokens[], level) -> unparser.unparse;
      tokens.computeLength;
      output[] -> tokens.printOn;
      NONE -> unparser.output[];
   #);
   
-- AstViewerPrintOn: doPart --
do (node[], -1, output[]) -> printUntilLevelOn;
   
-- AstViewerPrintFragmentOn: doPart --
do ('--', 0) -> output.putString;
   output.blank;
   (frag.name, 0) -> output.putString;
   output.blank;
   (':', 0) -> output.putString;
   output.blank;
   (frag.category -> gram.symbolToName, 0) -> output.putString;
   output.blank;
   ('--', 0) -> output.putString;
   output.newline;
   (frag.root[], output[]) -> printOn;
   output.newline;
   
-- AstViewerPrintFragmentGroupOn: doPart --
do (# tokens: @TokenStream;
      isSpecial:
        (# name: ^Text;
           result: @boolean;
        enter name[]
        do (if true
            //'slots' -> name.equalNCS
            //'donecheck' -> name.equalNCS
            //'unique_group_id' -> name.equalNCS then
               true -> result;
           if);
        exit result
        #);
   do (if group.prop[] <> NONE then
          tokens.init;
          width -> tokens.width;
          tokens.putBegin;
          group.prop.properties.scan
          (#
          do (if NOT (current.name[] -> isSpecial) then
                 current.name[] -> tokens.putString;
                 (if NOT current.parameters.empty then
                     Never -> tokens.putBlank;
                     tokens.putBegin;
                     current.parameters.scan
                     (# string: ^Text;
                     do (if current.type
                         //StringValue then
                            &Text[] -> string[];
                            '\'' -> string.put;
                            current.value[] -> string.puttext;
                            '\'' -> string.put;
                            string[] -> tokens.putString;
                         //ConstValue then
                            current.value[] -> tokens.putString;
                         //NameValue then
                            current.value[] -> tokens.putString;
                        if);
                        Normal -> tokens.putBlank;
                     #);
                     tokens.putEnd;
                 if);
                 ';' -> tokens.putString;
                 Always -> tokens.putBlank;
             if);
          #);
          tokens.putEnd;
          tokens.computeLength;
          output[] -> tokens.printOn;
          output.newline;
          group.scan
          (#
          do (current[], output[]) -> printFragmentOn;
          #);
      if);
      
   #);
   
-- AstViewerPrint: doPart --
do (# thePrinter: @StreamPrinter;
   do output[] -> thePrinter.init;
      (node[], thePrinter[]) -> printOn;
   #);
   
-- AstViewerPrintFragment: doPart --
do (# thePrinter: @StreamPrinter;
   do output[] -> thePrinter.init;
      (frag[], thePrinter[]) -> printFragmentOn;
   #);
   
-- AstViewerPrintFragmentGroup: doPart --
do (# thePrinter: @StreamPrinter;
   do output[] -> thePrinter.init;
      (group[], thePrinter[]) -> printFragmentGroupOn;
   #);
   
-- AstViewerPrintAsHTML: doPart --
do (# thePrinter: @HTMLPrinter;
   do output[] -> thePrinter.init;
      (node[], thePrinter[]) -> printOn;
   #);
   
-- AstViewerPrintFragmentAsHTML: doPart --
do (# thePrinter: @HTMLPrinter;
   do output[] -> thePrinter.init;
      (frag[], thePrinter[]) -> printFragmentOn;
   #);
   
-- AstViewerPrintFragmentGroupAsHTML: doPart --
do (# thePrinter: @HTMLPrinter;
   do output[] -> thePrinter.init;
      (group[], thePrinter[]) -> printFragmentGroupOn;
   #);
