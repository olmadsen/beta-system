ORIGIN 'checkerdopart';
LIB_ITEM 'betacompiler';
INCLUDE 'checklib';
INCLUDE 'nxoffsets';
INCLUDE 'setnxoffsets'
--- ChkFormBody: descriptor ----
(# thisDescOrgOff: @integer;
   
   AllocReturn: @
     (# hasReturn: @boolean
     do (if not hasReturn then
            ((4 - (offCount mod 4)) mod 4) + offCount->offCount;
            offCount -> thisDesc.returnOff;
            offCount + 8 -> offCount;
            true -> hasReturn; 
        if)
     #);
   ChkPre:
     (# preError:
          (# no: @integer 
          enter no 
          do true->PreErr; 
             (pre,no)->WE.semError 
          #);
        preError2: WE.makeError
          (# no: @integer
          enter no
          do 'The superpattern "' -> XT;
             N[] -> XA;
             (if no
              // 1 then 
                 '" is defined using a descriptor slot' -> XT;
                 '\n\tA pattern defined using a descriptor slot\n\t' -> XTl; 
              // 2 then 
                 '" is defined using a mainPart slot' -> XT;
                 '\n\tA pattern defined using a mainPart slot\n\t' -> XTl; 
              // 3 then 
                 '" is a virtual pattern' -> XT;
                 '\n\tA virtual pattern ' -> XTl; 
             if);
             'cannot be used as a superpattern' -> XTl;
             true -> preErr
          #);
        PreErr: @boolean;
        isStaticPtn: @
          (* checks that node is a static pattern;
           * P, where P is a pattern is OK;
           * R.P, where R is a static item is OK;
           * R[exp].P is not OK
           *)
          (# sort: @ASTindex; MN: @Integer; staticPre: @boolean
          do pre.son->N; thisDesc.father->sort;
             (if sort.label=gram.finalDecl then sort->chkVB if);
             (* SetUp will now check if the super-pattern is 
              * a static denotation
              *)
             N->&SetUp->(dclRef,preDesc);
             (* IT should be considered what will happen if setUp 
              * reports an error
              *)
             (* the following checks if the super-pattern is a simple
              * name which might imply that the origin of super can
              * be re-used for this descriptor.  
              *)
             (if N.label = gram.nameApl then 
                 (if N.stringlength = 0 then
                     (* Implicit prefix as in V::< (# #)
                      * if remote we cannot reuse origin; se reuseOrigin
                      *)
                     (# VS: @ASTindex
                     do dclRef.sort->VS; VS.son->VS; VS.brother->VS;
                        (if VS.label = gram.remote then true->remote if)
                 #)if)
              else true->remote
             if);
             (* here used to be some dead code for the remote case *)
             (if not preErr then
                 dclRef.sort->preSort;
                 (* we are currently checking the prefix P of a descriptor
                  *     P (# #)
                  * ------
                  * Note the special case (!!!)
                  *    P:< (# ... #)
                  *    PP::< (# ... #)
                  * when checking the descriptor for PP, the implicit
                  * prefix refers to P, but the descriptor of the 
                  * implict prefix referes to the descriptor of P, ie.
                  * the descriptor of the implict prefix of P is NOT
                  * marked as virtual. 
                  * In cases like
                  * P:< (# #); A: P(# #),
                  * P's descriptor is marked as virtual and fails the 
                  * tests below.
                  * 
                  * First test that the prefix is actually declared as a
                  * pattern, and not as a simple attribute like P: @ T
                  *)
                 (if preSort.label 
                  // gram.patternDecl 
                     (*// gram.finalDecl - final was move to here from below
                      * to handle finalBindings as prefix;
                      * see FEJL/mads2.bet.
                      * Not so simple, since a final may be bound to a virtual,
                      * etc. I.e. more checking is needed.
                      * Alos ref. is noe in descOrigin for mads2 with
                      * this fix
                      *)
                     then
                     (if preDesc.label = gram.unexpanded then
                         (* P: <<SLOT P:descriptor>> *)
                         (PRE[],false,1) -> preError2
                         (* else P: P0(# ... #) *)
                      else
                         (if preDesc.label = gram.objectDescriptor then
                             preDesc.son -> Node;
                             Node.brother -> Node;
                             (if Node.label = gram.unexpanded then
                                 (PRE[],false,2) -> preError2
                         if)if)
                     if)
                  // gram.virtualDecl // gram.bindingDecl 
                  // gram.finalDecl then
                     (*- no longer an error; 
                      * see mads2 comment above . OOPS: still a problem!
                      *)
                     (* P:< X; P::< X; P:: X, where X may be 
                      *   A - a name, remote name ,etc
                      *   P0(# ...#)
                      *   <<SLOT ...>>
                      * The above is only OK, if X is a descriptor, and then
                      * we have the special case  (!!!) mentioned above
                      *)
                     (if preDesc.label = Gram.objectDescriptor then (*ok*)
                      else
                      (*// gram.virtualDecl // gram.bindingDecl 
                       *// gram.unExpanded then*)
                           (PRE[],false,3) -> preError2
                         (* (thisDesc.origin,N)->actualDesc->(N.descRef,MN); *)
                     if)    
                  else 48 ->preError
                     (*(thisDesc.origin,N)->actualDesc->(N.descRef,MN) *)
             if)if)
          exit preErr
          #);
        SuperOnDist:
          (# on,pn: @integer; isSub: @boolean; 
             preDescOrigin,descOrig: ^ASTindex; 
          do thisDesc[]->DescOrigin->descOrig[]; 
             preDesc[]->DescOrigin->preDescOrigin[];
             (*197->trace
              (#do thisDesc[]->A; descOrig[]->A; 
              preDesc[]->A; preDescOrigin[]->A 
              #);
              *)
             L: (if descOrig.isNull then
                    messagestream.putLine; (thisDesc[],screen[],12)->thePP;
                    '*** Warning! The code generator may not be '->messagestream.putline;
                    'able to generate correct origin for super!'->messagestream.putline;
                    0->on; N.pn->pn
                 else
                    (descOrig,preDescOrigin)->ChkQua->(pn,isSub);
                    (if not isSub then
                        descOrig[]->DescOrigin->descOrig[]; 
                        on+1->on;
                        restart L
                if)if)
          exit(on,pn)
          #);
        ReuseOrigin: @
          (* check if origin of super can be reused *)
          (# reuse,rem: @boolean; spec: @ASTindex;
             ThisDescOrigin,PreDescOrigin: ^ASTindex
          do L:  
               (if not remote and (N.ON=0) (* order of clauses is important
                                            * since N.ON is NOT defined for
                                            * gram.remote
                                            *) then 
                   (if N.pn = 0 then 
                       True -> Reuse (* 19.4:98:  imp was missing *)
                    else 
                       thisDesc[]->DescOrigin->ThisDescOrigin[];
                       preDesc[]->DescOrigin->PreDescOrigin[];
                       (if preSort.label
                        // gram.virtualDecl 
                        // gram.bindingDecl
                        // gram.finalDecl then
                           (* thisDesc in            W :: < (# ... #)
                            * the super may then be  V :< (# ... #)
                            * or                     V :< A
                            * the first case can reuse origin, the second 
                            * only if A is atsame level as V
                            *)
                           preSort.son->spec; spec.brother->spec;
                           (if spec.label = gram.objectDescriptor then 
                               true -> reUse
                            else (* V:< A *) 
                               spec->getName->(spec,rem);
                               (if (spec.on>0) then
                                   (******** has to checked!!! ***********)
                                   (* (if common.switch[480]//false then
                                    superOnDist->(N.on,N.pn) if); ****)
                                   leave L
                           if)if);
                       if);
                       (if ThisDescOrigin.originOff = PreDescOrigin.originOff
                           then true->Reuse;
                   if)if);
                else
                   (if isComOrHolder or isDispatch then
                       (*'\ncomKind:'->puttext;*)
                       (preDesc -> comDesc.equal)
                       or (preDesc -> dispatchDesc.equal)
                       or (preDesc -> holderDesc.equal)
                       or (preDesc -> stateDesc.equal)
                         -> Reuse;
                       (* (if Reuse then 'reUse:'->puttext if)*)
                   if);

               if)
          exit Reuse
          #);
        access,kind: @integer; remote(*,isCproc*): @boolean; 
        N,dclRef,preSort,NODE: @ASTindex
     do null->preDesc; 
        false->insertable;
        (* insertable means simple sinsertable as in:
         *  do ...; (#do ... #); ...
         *)
        L:
          (if pre.label = gram.prefix then
              true->hasSuper;
              (if isStaticPtn then (* error in prefix *) 
               else
                  (preDesc,common.prefKind)->&GetSpecSize->(offCount,access);
                  (if (preDesc->sematt.descKind->kind)=dataKind then
                      4->virtOff; (* if zero it will later be set to -4
                                   * which will create problems in chkLst
                                   *)
                      (*0->offCount;*)
                      leave L
                  if);
                  preDesc -> Sematt.descKind -> kind; 
                  (if offCount=0 then
                      (* Prefix error - probably circular prefix*)
                      (if kind = constKind then
                          16->preError
                      if);
                      true->preErr
                   else
                      (* if access//common.cstInd then 55->preError*)

                      (kind = comKind) or (kind = holderKind) -> isComOrHolder;
                      (kind = dispatchKind) -> isDispatch;
                      (kind = ExternalKind)->isCproc;
                      (*super is sub of External*)
                      (if kind
                       // standardKind then
                          (if preDesc->CprocDesc.equal->isCproc then
                              12 (* prototype + gcCount + origin*)
                              +400 (*NOT so good: for CallC, etc*)->offCount;
                              8 -> virtOff; 
                              8 -> ThisDesc.originOff 
                                -> thisDescOrgOff;
                              externalKind -> kind
                           (* // (preDesc->CstrucDesc.equal) then 
                            * we never come here!
                            *)
                           else 57->preError
                          if)
                       // constKind then (* we probably never com here;
                                          * see case 'offCount=0' above
                                          *)
                          16->preError
                       // procKind then
                       else
                          (* perhaps test on preDesc.label
                           * // gram.virtualDecl//gram.bindingDecl
                           * // gram.unExpanded then  17->preError
                           *)
                          (if kind = stateKind then
                              (# preN: @ASTindex
                              do true -> isState;
                                 thisDesc.origin -> theOriginDesc;
                                 pre.son -> preN;
                                 theOriginDesc.virtSize + 4 -> virtOff;
                                 theOriginDesc.originOff 
                                   -> thisDesc.originOff;
                                 (if ctst then
                                     191->trace
                                     (#do 'StateDesc:'->xT;
                                        thisDesc[] -> xA;
                                        preN[] -> xA;
                                        'OriginOff:'->xT; 
                                        thisDesc.originOff->xI;
                                        'Origin.originOff:'->xT;
                                        theOriginDesc.originOff->xI; xN;
                                        theOriginDesc[] -> xA;
                                     #);
                                 if);
                                 (if preN.label <> gram.nameApl then
                                     'Pattern STATE: super is not nameApl'
                                       -> thisTranslate.systemException
                                 if)
                                 (*true -> sameOriginAsSuper*)
                              #)
                           else
                              (if switch180 then preDesc.returnOff-> offCount if);
                              preDesc[]->sematt.insertable->insertable;
                              preDesc.virtSize + 4 -> virtOff;
                              (* preDesc.virtSize is the largest byte offset
                               * in the dispatch table of the super ptn.
                               * If the super ptn has an INNER then
                               * preDesc.virtSize is the byte offset of the 
                               * inner dispatch for the super pattern
                               * and thus of the Possible M-entry point of 
                               * thisDesc.
                               * virtOff is initialized to preDesc.virtSize+4,
                               * and virtOff wil thus be the next byte offset
                               * that can be allocated to a virtual in
                               * thisDesc
                               *)      
                              (* allocate possible origin *) 
                              (if ReuseOrigin then
                                  (* same origin as prefix *)
                                  preDesc.originOff
                                    -> ThisDesc.originOff
                                    -> thisDescOrgOff;
                                  preDesc[]->sematt.hasAcode->hasAcode;
                                  true->sameOriginAsSuper
                               else (* allocate new origin *)
                                  offCount
                                    -> ThisDesc.originOff
                                    -> thisDescOrgOff;
                                  offCount+4 -> offCount;
                                  true -> hasAcode
                          if)if);
                          False->isCst;
              if)if)if);
              preDesc[]->sematt.type->preType;
              (if ctst then
                  198->trace
                  (#
                  do 'ChkPre: ' ->xT; N[]->xA;
                     'isComOrHolder='->xT; isComOrHolder->xB;
                     'isDispatch=' -> xT; isdispatch -> xB;
                     'kind=' -> xT; kind -> kindAsText->xT;
                     ' type='->xT; preType -> xI; 
                     predesc[]->xA;
                  #);
              if)
           else (* No prefix *) 
              12 (* prototype + gcCount + origin*) -> offCount;
              4 -> virtOff; 
              (* inefficient to test descKind as below: *)
              (if ThisDesc -> ComDesc.equal then
                  true -> isComOrHolder;
                  comKind -> descKind
               else
                  (if (ThisDesc -> HolderDesc.equal) then
                      (if ctst then 
                          191->trace(#do 'ChkPre:holder'-> xT #)
                      if);
                      true -> isComOrHolder;
                      holderKind -> descKind
                   else
                      (if (ThisDesc -> StateDesc.equal) then
                          stateKind -> descKind
                  if)if);
                  (* we should also exclude externalVirtualKind in COM
                   * but currently no desc like comDesc exists
                   *)
                  (* allocate space for M-entry point of this Desc;
                   * it MUST always exist, since "R:^object" can be
                   * executed.
                   * For COM objects it is NOT needed. However, it
                   * currently seems to be allocated anyway, probably
                   * in genlib
                   *)
                  virtOff + 4 -> virtOff;
              if);
              8->ThisDesc.originOff->thisDescOrgOff;
              emptyType->preType
          if);
        (if PreErr then
            pre.son->getName->(N,remote);
            errorName->N.dclRef; 
            superObject->preDesc->N.descref;
            (* used to be integerDesc, but superObject has an inner *)
        if);
        (* NO - if part of COM then direct else cstInd
         * (if isComOrHolder then common.cstInd -> descAccess if)
         *)
     exit kind
     #);
   
   ChkAtt:
     (# ChkSpec:
          (# isPTNorSlot:
               (# N: @ASTindex
               enter N
               do (if N.label //gram.objectDescriptor//gram.unExpanded then 
                      (*skip*)
                   else (N,(N->&GetSort))->isPtn
               if)#);
             
             rep: @boolean; spec,desc,N: @ ASTindex;
             specSize,access,descKind: @ integer
          enter(spec,rep)
          do spec.son -> N;
             (if N.label = gram.computedRemote then
                 (n,96) -> WE.SemError;
                 leave chkSpec
             if);
             N -> &GetDesc->desc;
             insertable and ((desc->sematt.descKind)=standardKind)
               -> insertable;
             (if spec.label
              // gram.dynamicItem // gram.dynamicComponent then
                 common.refSize*4->specSize; common.varInd->access;
                 (N,(N->&GetSort),false,true)->isNonSimplePtn
              // gram.staticItem then 
                 (desc,common.itemKind) -> getSpecSize -> (specSize,access);
                 N->&isPTNorSlot;
                 (if desc.label=gram.objectDescriptor then
                     desc->sematt.descKind->descKind
                  else
                     generalKind->descKind (*???*)
                 if);
                 (if descKind
                  // standardKind then
                  // generalKind then
                     true->hasAcode;
                     (*// comKind *)
                  // dataKind then
                     (if not 
                         (isComOrHolder 
                         or isCproc
                         or (preKind = dataKind)
                         or (preKind = holderKind)) then
                         (*NOTE: isData and dataKind is NOT the same??*)
                         (* (spec,116) -> WE.warning;*)
                     if);
                  // holderKind then
                     (* this used NOT to be done, but 
                      * hasAcode should be true if code is needed in
                      * the G-part and it is to set the origin, even
                      * if no dopart of the part object*)
                     true -> hasAcode;
                     (if ctst then 
                         192 -> trace(#
                                     do 'HolderPart: '->xT; 
                                        isComOrHolder ->xB #)
                     if);
                     (if not isComOrHolder then
                         (* holder objects are allocated
                          *  - offline in non COM/Holder-objects
                          *  - inline  in     COMIHolder-objects
                          *)
                         common.refSize*4 -> specSize;
                         common.cstInd -> access 
                     if);
                  // comKind then
                     (* A COM part object is inlined if part of a COM object;
                      * but is allocated offline if part of a 
                      * general objects *)
                     (if ctst then 
                         192 -> trace(#
                                     do 'ComPart: '->xT; isComOrHolder -> xB
                                     #)
                     if);
                     (if not isComOrHolder then
                         (* COM objects are allocated
                          *  - offline in non COM/Holder-objects
                          *  - inline  in     COMIHolder-objects
                          *)                         
                         common.refSize*4 -> specSize;
                         common.cstInd -> access
                     if);
                     true->hasAcode; (* see comment for holderKind *)
                  // externalVirtualKInd then
                     (if not isComOrHolder then
                         (* Enclosing object is NOT a COM object*)
                         (spec,117) -> WE.SemError; 
                     if)
                  else
                     (* when do we come here? If kind is not standard
                      * or general - i.e. error message is NOT meaningful
                      *)
                     (if rep then (spec,26)->&WE.SemError if)
                 if)
              // gram.staticComponent then (*********)
                 true->hasAcode;
                 (desc,common.compKind)->getSpecSize->(specSize,access);
                 N->&isPTNorSlot;
                 (*(if rep then 
                     (if common.switch[48] then (spec,25)->WE.Warning
                      else (spec,25)->&WE.SemError 
                  if)if)*)
              // gram.variablePattern then
                 common.refSize*4->specSize; common.varInd->access;
                 spec.son->getSort->desc;
                 (if desc.label = gram.patternDecl then
                  else (spec,43)->WE.semError if)
             if);
             (*(spec,desc,spec.label)->&SetMode*)
          exit(specSize,access)
          #);
        
        isLib: @ boolean;
     enter isLib (* true if a fragment of ptn-attributes are being translated*)
     do att->ScanList
        (# SetOffSet: @
             (# off: @integer; (* orgOff=0 for virtOff *)
             enter off
             do nameL->ScanList
                (# name: @ASTindex
                do currentNode->name;
                   (* align memory offset *)
                   (if specSize
                    // 1 then (* no align *)
                    // 2 then (* align to 2 bytes *) (off mod 2) + off->off
                    // 4 then (* align to 4 bytes *)
                       ((4 - (off mod 4)) mod 4) + off->off
                    else (* 8 or n*4, n>1, align to 8 bytes*) 
                       (* OBS! This must be reconsidered, since it will not
                        * work with parts objects having real objects
                        *)
                       ((8 - (off mod 8)) mod 8) + off->off
                   if);
                   off->name.off;
                   off+specSize->off;
                   access->name.access
                #)
             exit off
             #);
           
           D,EV,nameL,desc,spec,sort,N: @ ASTindex; 
           specSize,access: @integer;
           
           LibErr: @ (#do(if isLib then (D,31)->&WE.SemError if)#)
           
        do currentNode->D; 192->trace(#do D[]->xA #);
           true->hasAttributes;
           (if not D.isSlot then
               D.son->nameL; false ->isCst; common.direct->access;
               (if D.label
                // gram.simpleDecl then (* (simple <nameLst> <dataSpec>) *)
                   LibErr;
                   (nameL.brother,false)->chkSpec->(specSize,access);
                   (offCount)->SetOffSet->offCount;
                // gram.repetitionDecl then
                   LibErr;
                   (if common.switch[64] then AllocReturn if);
                   true->hasAcode;                   
                   nameL.brother->EV; EV->ChkIndex;
                   (EV.brother,true)->chkSpec->(specSize,access);
                   common.repDopeSize*4->specSize;
                   (offCount)->SetOffSet->offCount;
                // gram.patternDecl then 
                   nameL.brother->desc;
                   (*nameL->isSingleName ->N;*)
                   (desc[],0,0,N[])->DS.put;
                   false->insertable
                // gram.virtualDecl then
                   LibErr;
                   nameL->isSingleName->N;
                   nameL.brother->spec->&GetDesc->desc;
                   (*192->trace(#do
                                'Virtual: ' -> xT;
                                desc.label->xI;
                                desc[]->xA;
                                'unexpaned: '->xT; 
                                gram.unexpanded->xI;xN
                             #);
                    *)
                   (* ERROR here: an unexpanded mainpart is NOT
                    * uxexpanded here, since in
                    *     V: < <<SLOT mmm:mainPart>>
                    * the mainPart is part of an object descriptor;
                    * we thus have to decode the objectDescriptor
                    * and test if there is an unExpaned mainpart.
                    * And: using a mainpart in a virtual
                    * is NOT implemented - i.e. it is an error
                    *)
                   (if spec.label 
                    // gram.objectDescriptor // gram.unExpanded then 
                       common.direct->access
                    else 
                       (spec,spec->&GetSort,false,false)->&isNonSimplePtn;
                       (if (desc.origin->thisDesc.equal) then
                           common.direct->access
                        else common.cstInd->access                       
                       if)
                   if);
                   (if desc.label
                    //gram.virtualDecl 
                    //gram.bindingDecl //gram.unexpanded then 
                       (spec,32)->&WE.SemError
                   if);
                   4->specSize; (* size of virtual entry in prototype *)
                   (virtOff)->SetOffSet->virtOff;
                   false->insertable
                // gram.bindingDecl //gram.finalDecl then
                   LibErr;
                   (if isState and isState then
                       (D,nameL,nameL.brother,preDesc,theOriginDesc[])
                         -> &CheckBinding;
                       
                       (*  
                        * (if isState and (preDesc->sematt.stateDesc.equal) 
                        * then
                        * (D,nameL,nameL.brother,theOriginDesc)
                        * ->&CheckBinding
                        *)
                    else
                       (D,nameL,nameL.brother,preDesc,none) -> &CheckBinding
                   if);
                   false->insertable
     if)if)#)#);
   
   ChkIndex:
     (# inx,inx1: @ ASTindex; eK,cstVal,n,type: @integer; hasCode: @boolean
     enter inx
     do (if inx.label
         // gram.SimpleIndex then inx.son->inx1
         // gram.namedIndex then inx.son->inx1; inx1.brother->inx1
        if);
        (thisDesc,inx1,key.exitt,false)
          -> &ChkEval
          -> (eK,cstVal,n,hasCode,type);
        (ThisDesc,inx,UnaryCompKind,inx1,valType,inx1,type)->&CmpLst
     #);
   
   
   ChkImpLst: 
     (# IL: @ ASTindex
     enter IL
     do IL->ScanList
        (# imp,lab: @ ASTindex; oldRelInsOff: @integer
        do currentNode->imp; 
           193->trace(#do (*offcount->xI;*) imp[]->xA #); 
           false->isCst;
           relInsOff->oldRelInsOff; 
           (if imp.label
            // gram.labelledImp then
               imp.son->lab; 
               (common.labelSize*4->tmpSto.Alloc)->lab.off;
               lab.brother->&ChkImpLst
            // gram.restartImp // gram.leaveImp then
               imp.son->lab->&SetUp; lab->isLab
            // gram.forImp then imp->&ChkFor
            // gram.generalIfImp then imp->&ChkIf
            // gram.simpleIfImp then imp->&chkSimpleIf
            // gram.innerImp then 
               imp.son->lab; 
               (if lab.label = gram.empty then 
                   (if singular then (imp,97)->WE.Warning if);
                   true->innerFound
                else  (* inner P *)
                   (# D: @ASTindex; isVirt,K: @integer
                   do lab->&SetUp;
                      (lab[],thisDesc,lab.on,2(*inner*))->isEnclosing;
                      (thisDesc,lab)->actualDesc->(D,K);
                      D.kind->K;
                      (true,12,1) -> K.%putBits;
                      K->D.kind;
               #)if)
            else (* evaluation*) (thisDesc,imp,key.single,false)->&chkEval
           if);
           oldRelInsOff->relInsOff
     #)#);
   
   ChkSimpleIf:
     (* <SimpleIfImp> = (<eval> <thenPart> <elsePartOpt>) *)
     (# imp,eval,thenP,elseP: @ASTindex;
        hasCode: @boolean; eK,cstVal,n,type: @integer
     enter imp
     do imp.son->eval; eval.brother->thenP; thenP.brother->elseP;
        (thisDesc,eval,key.exitt,false)
          -> &ChkEval
          -> (eK,cstVal,n,hasCode,type);
        (ThisDesc,imp,unaryCompKind,eval,boolType,eval,type)->&CmpLst;
        thenP->&ChkImpLst;
        (if elseP.label = gram.elsePart then elseP.son->&ChkImpLst if)
     #);
   ChkIf:
     (# imp,alt,elseP,eval: @ ASTindex; off,type,typeKind: @integer;
        hasCode: @boolean; eK,cstVal,n: @integer
     enter imp
     do imp.son->eval; eval.brother->alt; alt.brother->elseP;
        (*  (if E0 ..... if) *)
        (thisDesc,eval,key.exitt,false)
          -> &ChkEval
          -> (eK,cstVal,n,hasCode,type);
        alt->ScanList    (*         // E1 ... then I1  *)
        (# selLst,impL: @ ASTindex;
        do currentNode->selLst;
           selLst.son->selLst; selLst.brother->impL;
           selLst->ScanList (*   // E1 // E2 ... // En *)
           (# sel,selEV: @ ASTindex
           do currentNode->sel; 
              (ThisDesc,sel.son->selEV,key.exitt,false)
                -> &ChkEval
                -> (eK,cstVal,n,hasCode,typeKind);
              (ThisDesc,sel,BinaryCompKind,eval,type,selEV,typeKind)
                -> &CmpLst
                -> typeKind
           #);
           impL->& ChkImpLst
        #);
        (if elseP.label = gram.elsePart then elseP.son->&ChkImpLst if);
            (* allocation of tmp. location for E in (if E // ... if).
             * Note that the allocation is NOT sequential. If-, for-imp
             * inside then-parts of if are allocated BEFORE allocation
             * of tmp. for E, since the inner parts have been checked above
             *)
        (* the following check should be superflous, since is done
         * in cmpLst already
         *)
        (if typeKind
         // boolType // cBoolType 
         // valType // cValType  
         // charType // charType // primType then
            (* common.ifSize*4->TmpSto.Alloc->off*)
         // VIrefType // CIrefType // VCrefType // CCrefType 
         // noneType // vStrucType // cStrucType then
            (*common.ifSize*4->TmpSto.Alloc->off;*)
            (*-off->off;*) (* hack to mark this location as a reference *)
         // realType //cRealType then 
            (* ((8 - (offCount mod 8)) mod 8) + offCount->offCount;*)
            (* common.ifSize*4+4->TmpSto.Alloc->off*)
         else
            (eval,51)->&WE.SemError
        if);
        (*(off,1)->imp.PutAttribute*)
     #);
   
   ChkFor: 
     (# imp,index,name,impL: @ ASTindex; off: @integer
     enter imp
     do (common.forSize*4->TmpSto.Alloc->off,1)->imp.PutAttribute; 
        imp.son->index; index.brother->impL;
        (if index.label = gram.NamedIndex then
            index.son->name; off(*-thisDesc.originOff*)->name.off;
            (if isDoPartForm then
                (*common.direct*) 3 (*index*)->name.access
        if)if);
        index->&ChkIndex; impL->&ChkImpLst; 
        (off,common.forSize*4)->TmpSto.deAlloc
     #);
   

   
   ChkObjSize:
     (#
     do (if (offCount>32760) then (desc,28)->&WE.SemError if);
     #);
   
   ChkDataKind:
     (# 
     do (*191->trace(#do 'ChkDataKind: '->xT; thisDesc[] -> xA #);*)
        (* the following is to ensure that attributes can refer to the 
         * descriptor being checked 
         *)
        (desc[],dataKind,hasNcode,hasDo,hasXcode,isData,innerFound
        ,insertable,descAccess,hasAcode,hasOnlyInner,false,false,false,0(*?*))
          ->MarkDesc;
        att->scanList
        (# decl,D: @ASTindex
        do currentNode->decl;
           (if decl.label = gram.simpleDecl then (* ok*)
               (* only basic patterns and data-objects allowed in:
                * <SimpleDecl>  ::= <Names> ':' <referenceSpecification>;
                * <referenceSpecification> ::| <StaticItem> | <DynamicItem> 
                *  | <StaticComponent> | <DynamicComponent> | <VariablePattern>
                * <StaticItem> ::= '@' <ObjectSpecification>;
                * <DynamicItem> ::= '^' <AttributeDenotation>;
                * <StaticComponent> ::= '@' '|' <ObjectSpecification>;
                * <DynamicComponent> ::= '^' '|' <AttributeDenotation>;
                *)
               decl.son->decl; decl.brother->decl; 
               (if decl.label = gram.variablePattern then 
                   (decl,89)->WE.semError
                else
                   decl.son->decl;
                   (* Why was this check here ? We may have singular
                    * data attributes?
                    *
                    * (if decl.label = gram.objectDescriptor then
                    * (decl,89)->WE.semError
                    * else
                    *)
                   decl ->GetDesc -> D;
                   L:
                     (if D -> sematt.DescKind
                      // standardKind // dataKind 
                      // holderKind 
                      // comKind then (* OK *)
                      // undefined then
                         (D[],false,decl[],-1)->&chkForm;
                         restart L
                      else (decl,89)->WE.semError
               if)if)
            else (decl,89)->WE.semError
           if)
        #);
        (if (entP.label<>gram.empty) then
            (* only local names in enter-part*)
        if);
        (if (doP.label<>gram.empty)  then (doP,90)->WE.semError if);
        (if (exitP.label<>gram.empty) then
            (* only local names in exitr-part*)
        if)
     #);
   ChkXDesc:
     (# handleVarPtnPar:
          (# theDesc: @ASTindex; theParam: ^ASTindex; PL: @integer
          enter(theDesc,theParam[])
          do theDesc.son->getDesc->theDesc;
             (* for some reason theDesc=sort for varPtn, see getCatsort *)
             (if (theDesc->sematt.DescKind) = unDefined then
                 (* enforce checking *)
                 (theDesc[],false,theParam[],-1)->&ChkForm
             if); 
             theDesc->DescChain->(theDesc,PL);
             (if (theDesc->cProcDesc.equal) then 
              else  (theParam,34)->&WE.SemError 
             if)
          #);
        handleRefObjectPar:(* check if sub of cStruc *)
          (# theDesc,D: @ASTindex; theParam: ^ASTindex; PL: @integer
          enter(theDesc,theParam[])
          do (*192->trace(#do'handleRefObjectPar:'->xT;
                          theDesc[]->xA
              #);*)
             (if (theDesc->semAtt.descKind) = undefined then
                 (* enforce checking!!*)
                 (theDesc[],false,theParam[],-1)->&chkForm
              else (*192->trace(#do 'No check of cStruc'->T #)*)
             if);
             theDesc->D->&DescChain->(theDesc,PL);
                 (*192->trace(#do 'After DescChain'->T #);*)
             (if (theDesc->sematt.descKind) <> externalClassKind then
                 (* can we optimize the following using descKind? *)
                 (if not (theDesc->semAtt.cStrucDesc.equal) then
                     (if not (theDesc->semAtt.cProcDesc.equal) then
                         (if not (theDesc->sematt.dataDesc.equal) then
                             (if not (theDesc->sematt.comDesc.equal) then 
                                 (if false
                                  // theDesc->sematt.holderDesc.equal
                                  // theDesc->sematt.SuperObject.equal then
                                  else
                                     (* here we hack to check if wtext descriptor: 
                                      * currently a basic pattern like wtext, which
                                      * is NOT ine betaenv is not recognized as a
                                      * basic pattern by initterm.
                                      * We should fix this!
                                      *)
                                     L:
                                       (# F: @ASTindex; T: ^text
                                       do (theParam,34)->&WE.SemError 
                                       #)
             if)if)if)if)if)if)
          #);
        HandlePartObjectPar:
          (# theDesc: @ASTindex; theParam: ^ASTindex;
          enter(theDesc,theParam[])
          do (*192->trace
              (#do'handlePartObjectPar:'->xT;theParam[]->xA;theDesc[]->xA #);
              *)
             (if (theDesc->semAtt.descKind) = undefined then
                 (* enforce checking!!*)
                 (theDesc[],false,theParam[],-1)->&chkForm
             if);
             (if(theDesc -> sematt.descKind) <> sematt.dataKind then
                 (theParam,34)->&WE.SemError
             if)
          #);
        ChkEnterPar:
          (# thisDesc: ^ASTindex
          enter thisDesc[]
          do (thisDesc[],true)->ScanCNX
             (# refObjectPar:: 
                  (#do (theDesc,theParam[])->handleRefObjectPar #);
                partObjectPar:: 
                  (#do (theDesc,theParam[])->handlePartObjectPar #);
                varPtn:: (#do (theDesc,theParam[])->handleVarPtnPar #);
                            (*int64Par:: (#do (theParam,126) -> WE.Warning #);*)
                error:: (#do (theParam,34)->&WE.SemError #)
             #);        
          #);
        ChkExitPar:
          (# thisDesc: ^ASTindex
          enter thisDesc[]
          do (if (((thisDesc[],false)->ScanCNX
                 (# refObjectPar:: 
                      (#do (theDesc,theParam[])->handleRefObjectPar #);
                    partObjectPar:: 
                      (#
                      do (theDesc,theParam[])->handlePartObjectPar;
                         (if thisDesc[] -> sematt.hasDo then
                             (* this is a COM virtual implemented in BETA;
                              * or a callBack implemented in BETA
                              *)
                             (theParam[]
                             ,'A data-object cannot be returned by-value '
                             'from a COM virtual or call-back function'
                             ) -> WE.NewWarning
                         if)
                      #);
                    varPtn:: (#do (theDesc,theParam[])->handleVarPtnPar #);
                                (*int64Par:: (#do (theParam,126) -> WE.Warning #);*)
                    error:: 
                      (#
                      do (if not (thisDesc[] -> sematt.hasDo) then
                             (theParam,34)->&WE.SemError 
                         if)
                      #);
                    Warn::
                      (#
                      do (theParam[]
                         ,'An external parameter should be a simple name'
                         ) -> WE.NewWarning
                      #)
                 #)
                 ) >1)
                 then (exitP,35)->&WE.SemError
             if);             
          #);
        father: @ASTindex; descKind: @integer;
        isSingular: @boolean
     do (if ctst then
            198->trace(#do 'Checking X desc' #);
        if);
        thisDesc.father->father;
        (father.label <> gram.patternDecl) -> isSingular;           

        INNER ChkXDesc;
     #);
   ChkCprocDesc: ChkXDesc
     (# 
     do (if isSingular then
            (if true then
                '\n*** OBS allowing singular external'
                'for dynamic compilation experiments'
                  -> putline;
             else
                (thisDesc,98)->&WE.SemError 
        if)if);   
        thisDesc[] -> ChkEnterPar;
        thisDesc[] -> ChkExitPar;
        (if id[] = NONE then 
            (* if called from getSpecSize: NONE or NULL  *)
            &ASTindex[]->id[];
        if);
        (if id.isNull then father.son->isSingleName->id if);
        (*193->trace(#do 'cProcDecoderC id[]='->T; id[]->A #);*)
        (NONE,id.getText,thisDesc[],NonVirtualForm)
          ->cProcDecoder
        (# 
        do (if extKind (* test if a call-back routine *)
            // sematt.cCallBackExt 
            // semAtt.PascCallBackExt
            // semAtt.StdCallbackExt then
               callBackKind->descKind;
               (if common.switch[64] then AllocReturn if);
               offCount -> thisDesc.size;
               (* clean-up below may be necessary *)
            else
               externalKind->descKind
           if);
           (if explicitCallId and (extKind <> PascTrapExt) then
               callId.scanAll(#
                             do (if ch <= ' ' then 
                                    (if not common.switch[188] then
                                        (extEntry,112)->&WE.Warning
                                    if)
                                if)
                             #)
           if)
        #);
        (* 0->ThisDesc.size->ThisDesc.virtSize;*)
     exit descKind
     #);
   ChkComDesc: chkXDesc
     (* current format
      * 
      * account: COM
      * (# deposit:< ...
      *    ...
      * #)
      * 
      * account is marked as comKind;
      * a special COM protototype MUST be made
      * 
      * deposit, etc should also be marked as something
      * so special code can be generated
      *)
     (# checkForVirtuals:
          (#
          do att -> scanList
             (# D,spec,nameL,dclRef: @ASTindex; K: @integer
             do currentNode -> D;
                (if not D.isSlot then
                    (if D.label 
                     // gram.virtualDecl
                     // gram.bindingDecl 
                     // gram.finalDecl then
                        (if ctst then
                            191->trace(#do 'COM virtual:'->xT; D[] -> xA #)
                        if);
                        D.son -> nameL; nameL.brother -> spec;
                        (if spec.label <> gram.objectDescriptor then
                            (* OBS! if pattern name used here and NOT a
                             * descriptor, the pattern can ONLY be used
                             * as a virtual Com pattern. I.e. all other
                             * uses of the pattern should be checked
                             *)
                            spec -> SetUp -> (dclRef,spec)
                        if);
                        (if spec -> superObject.equal then
                            (D,118)->&WE.SemError
                        if);

                        (if spec.label = gram.objectDescriptor then
                            (* It is the virtual desc that MUST be
                             * checked for enter parameters
                             *)
                            (if ctst then
                                191->trace
                                (#do 'descKind:'->xT;spec->sematt.descKind->xI#)
                            if);;
                            (* the following check for a COM virtual
                             * being for other purposes does NOT work.
                             * When we come here the virtual may alreday
                             * have been checked as a generalKind
                             *)
                            (if spec -> sematt.descKind
                             // externalVirtualKind 
                             // dispatchVirtualKind
                             // generalKind then
                             // undefined then
                                (spec[],false,NONE,-1) -> chkForm
                             else
                                (D,119)->&WE.Warning
                            if);
                            spec[] -> ChkEnterPar;
                            spec[] -> ChkExitPar;
                            spec.kind -> K;
                            (if isDispatch then
                                (dispatchVirtualKind,0) -> K.%putByte;
                             else
                                (externalVirtualKind,0) -> K.%putByte;
                            if);
                            K -> spec.kind;
                            (*  spec -> sematt.descKind -> putint; 
                             newline*)
                         else
                            'Error in checking of virtual COM pattern'
                            -> bugstream.putline
                if)if)if)
             #)
          #);
        father: @ASTindex;
        isDispatch: @boolean
     enter isDispatch
     do 191->trace(#do 'Checking COM desc: isDispatch='->xT; isDispatch->xB #);
        checkForVirtuals;
     #);
   ClassifyDesc:
     (* A descriptor may be classified as: 
      *    inlineDO
      *    inlineNX
      *    hasOnlyNX
      *
      * a descriptor is inlineNX if it has the form
      * 
      *    P(# ... enter(a,b,c) exit E #)
      * 
      * where
      * 
      * - P must be inlineNX
      * - a,b,c must be simple integer, boolean, char or shortint variables
      * - E must be a simple expression
      *   - simple variables, including R[e1] (e1 simple), S.p,
      *   - binary and unary operators
      *   - NO assignments,
      *   - NO object executions
      *   - dynamic generations?
      *   - No computed object evals
      *   - eval list OK
      *   - constants OK
      *   - text constants?
      *   - structure refs?
      *   - repetition slice?
      *   - primitives, unaryPrimitive OK
      *   - address OK
      * 
      *)
     (#
        putKind: (# k: @integer
                 enter k
                 do (if k
                     // 0 then 'Undef:'->puttext
                     // constEval then 'Const:'->puttext
                     // simpleVarListEval then 'VarList:'->puttext
                     // simpleExpEval then 'SimpleExp:'->puttext
                     // generalEval then 'General'->puttext
                     else 'Very undef:'->puttext
                 if)#);
        FN: @ASTindex;
     do (*196->trace
        (#
        do 'Enter:'->xT; nExpKind->putKind;
           'Exit:'->xT; xExpKind->putKind;
         #);*)
        (if (descKind = generalKind) 
            and not hasDo 
            and (nExpKind = simpleVarListEval)
            and (xExpKind = simpleExpEval) then            
            (if preDesc.isNull then true->inlineNX
             else
                sameOriginAsSuper and (preDesc[] ->sematt.inlineNX) 
                  -> inlineNX
            if);
            desc.father -> FN;
            (if FN.label
             // gram.staticItem // gram.staticComponent then
                false -> inlineNX;
                (if ctst then 
                    196 -> trace(#do 'StaticInlineNX: '->xT; FN[] -> xA #)
                if)
            if);
        if);
        (if not inlineNX then
            (if not (hasSuper or hasAttributes or hasNpart or hasXpart) then
                (if common.switch[212] then 
                   (if desc.size = 12 then 
                       (*191->trace(#do '\OnlyDo'->putLine #);*)
                       true->inlineDO 
                if)if)
            if);
            (* disjoint properties?*)
            (if not (hasSuper or hasAttributes or hasDo) then
                (*195->trace(#do 'ChkFormBody:onlyNX:'->T #);*)
                (if hasSuper then
                    preDesc[]->sematt.hasOnlyNX->hasOnlyNX
                 else true->hasOnlyNX
            if)if);
        if);
        (*196->trace(#do'IsInline:'->T; inlineNX->I; newline #)*)
     #);
   cNXoffSets: NXoffSets
     (# testAndCheckDesc::
          (#
          do (if (desc->sematt.descKind) = sematt.unDefined then
                 (desc[],false,none,-1) -> &ChkForm
             if);

          #)
     #);
      
   isCst: @boolean;  descVal: @ integer; 
   expKind,nExpKind,xExpKind: @integer;
   
   isCproc
   ,isDoPartForm: @boolean;
   type,nSize,nTmpSize,xSize,xTmpSize: @integer;
   descKind,preKind, preType: @integer;
   (* innerFound declared in docheck *)
   hasSuper,hasNpart,hasXpart,hasAttributes, sameOriginAsSuper
   ,hasNcode,hasDo,hasXcode,inlineNX,inlineDO,hasOnlyNX
   ,isData,insertable,hasAcode,hasOnlyInner
   ,isComOrHolder, isDispatch,isState: @boolean;  
   descAccess: @integer; 
   (* action-part of ChkForm;
    * enter par. id is origin if desc.label = doPart
    *);
   pre,mainP,att,entP,exitP,doP: ^ ASTindex;
   theOriginDesc,father: @ASTindex;
   
   chkObjDesc:
     (# exitt:< object
     do desc->ThisDesc;
        (if (thisDesc->sematt.descKind->descKind) = sematt.beingChecked then
            (desc,19)->&WE.SemError;
            0->ThisDesc.size; false->descOK
         else   
            (# originDesc: ^ASTindex
            do &ASTindex[] -> originDesc[]; 
               desc.origin -> originDesc; 
               (if originDesc.label = gram.descriptorForm then
                   Desc[] -> DescOrigin -> originDesc[];
                   (if ctst then
                       198 -> trace(# do 'chkForm:originDesc: ' -> xT; xN;
                                      originDesc[] -> xA
                                   #)
                   if);
                   (* 16/10/00: this is a bit more complicated than
                    * previously assumed. OriginDesc may be a dopart
                    * in which case descKind is NOT defined;
                    * discovered while testing with newindex.bet;
                    * look at tstbreakbody::koks - this case MUST
                    * be considered!!!
                    *)
                    (if (not originDesc.isNull) 
                        AND (originDesc.label=gram.objectDescriptor)
                        AND ((originDesc->sematt.descKind) = undefined) then
                       (* (1) For normal nested descriptors, origin has 
                        *     either been checked or is beingChecked.
                        *     Except as described in (3).
                        * (2) For descriptorForms we may have
                        *        ---xxx:descriptor---
                        *        (# ...; 
                        *           A: (# ...Y: <<SLOT Y:descriptor>>; ...#);
                        *           ...
                        *         #)
                        *        ---Y:descriptor---
                        *        (# ... #)
                        * (3) Exception to (1): Checking of Y implies
                        *     checking of A which implies that the origin
                        *     of A has not been checked
                        * 
                        * When Y is checked, xxx may NOT have been checked
                        * Inside this if, we are in the descriptor situation.
                        * We thus check the origin. During checking of 
                        * origin, a checking of this descriptor
                        * may have been initiated. 
                        * If this is the case we leave this checker
                        *)
                       (if ctst then
                           191->trace(#do 'origin is NOT checked:'-> xT#)
                       if);
                       (originDesc[],false,none,-1)->&ChkForm;
                       (if (desc->sematt.descKind) <> unDefined then
                           (if ctst then
                               191->trace(#do 'Desc has been checked while checking origin'-> xT #)
                           if);
                           (*leave DoCheck*)
                           exitt
                       if)
               if)if)
            #);
            desc[]->descSonsRef->(pre[],mainP[],att[],entP[],doP[],exitP[]);
            thisDesc[]->sematt.markBeingChecked;
            common.direct->descAccess; 
            (if (insertOff = -1) (*or switch182*) then
                (* 'normal' checking of descriptor *)
                0->offCount; (*true->isCst; *)
                desc.father->father;
                (if not father.isNull then
                    father.label=gram.patternDecl -> isCst
                if);
                ChkPre->preKind(*isCproc*);
                false->&ChkAtt;
                (* align data attributes before allocation in do-part.
                 * But why is this necessary?
                 * Eliminated 29.4.93.
                 * Changed to 4-byte align. 17.10.93
                 *)
                ((4 - (offCount mod 4)) mod 4) + offCount->offCount;
                (if common.switch[65] and hasAcode then
                    AllocReturn
                if);
             else
                (*1->trace(#do 'check insertion:'->xT; desc[] -> xA #);*)
                (* ChkForm is called with insertOff>-1 for 
                 * singular inserted items
                 * in the do-part of an object-descriptor:
                 *    (# ... do ...; (#do ... #); ... #)
                 * A singular inserted item is insertable if it has 
                 * no superptn and no attributes.
                 * The descriptor is marked as insertable.
                 * Tmp. attributes (for,label) are allocated in 
                 * the enclosing object.
                 * OriginOff of the descriptor is defined to be the same
                 * as for its origin and desc.origin is defined to be
                 * origin of its descriptor. (does not work)
                 *)
                (# D: @ASTindex; K: @integer
                do true->insertable;
                   4->virtOff;
                   desc.kind->K;
                   (true,13,1) -> K.%putBits;
                   K->desc.kind;
                   desc->D;
                   (if D.label = gram.objectDescriptor then
                       D.origin->D;
                       (* 192->trace(#do 'Comp.desc origin:'->xT; D[]->xA #);*)
                       findDescNode:
                         (if D.label
                          // gram.objectDescriptor then (*ok*)
                          // gram.descriptorForm // gram.attributesForm then
                             D.xOrigin->D;
                             restart findDescNode
                          // gram.unExpanded then
                             D.slotOrigin->D; 
                             restart findDescNode
                          // gram.doPart then
                             (if ctst then
                                 192->trace(#do 'D1: ' -> xT; D.descNo -> xI;
                                              D[] -> xA #)
                             if);;
                             (if not (D[]->sematt.doPartHasTmp) then
                                 D.xOrigin->D;              
                                 restart findDescNode 
                             if)
                          // gram.mainPart then
                             D.xOrigin->D; restart findDescNode
                          else (* forL repetition etc *)
                             D.origin -> D;
                             restart findDescNode
                         if)
                    else 
                       'Error 2 in simple insertion!'
                         -> thisTranslate.systemException
                   if);
                   (* Note that: desc[]->sematt.descOrigin->D[]; 
                    * don't for for nested inserted descriptors, i.e. if
                    * descorigin is insertable, then we get the wrong size
                    * for initializing offCount
                    *)
                   (* 192->trace(#do 'D:'->xT; D[] -> xA;
                    xN; desc[] -> xA;
                    xN; 
                    D.index -> xI;
                    desc.originOff -> xI
                    #);*)
                   insertOff(*D.size*)->offCount;
                   (if d.label = gram.doPart then
                       (* this is probably juts needed for the checker
                        * since 8 is hardcoded as originOff in
                        * the code generator
                        *)
                       8 -> desc.originOff
                    else
                       D.originOff -> desc.originOff;
                   if);
                   (*  192->trace(#do'Inserted desc:originDesc: '->xT; 
                    offcount->xI; desc.originOff -> xI;
                    D[]->xA
                    #);*)
                   (*D.origin->desc.origin*)
                #)
            if);
            
            (if entP.label <> gram.empty then
                (ThisDesc,entP.son,key.enterr,true)
                  ->&ChkEval
                  ->(nExpKind,DescVal,nSize,hasNcode,type);
                (if hasNcode then
                 else 0->entP.NXoff
                if);
                nSize->entP.NXsize; 
                false->isCst; 
                true->hasNpart;
             else
                simpleVarListEval -> nExpKind
            if);
            (* Allocate space for Return in INNER-dispatch;
             * INNER-dispatch space is allocated unless the descriptor has 
             * (1) a do-part and a super with NO inner, or
             * (2) no do-part and a super
             *)
            virtOff + 4 -> virtOff;
            (if doP.label <> gram.empty then
                (if pre.label = gram.prefix then
                    (if not (preDesc[]->sematt.hasInner) then
                        (preDesc[],desc[]) -> WE.NoInner;
                        (* deallocate INNER-dispatch *)
                        virtOff - 4 -> virtOff
                if)if);  
                false->isCst; true->hasDo;
                (if not doP.isSlot then
                    doP->&ChkImpLst
                 else true->innerFound
                if);
                (if common.switch[65] and not hasAcode then
                    (* if HasAcode, returnOff is already allocated *)
                    AllocReturn;
                if);
             else
                (if ((pre.label = gram.prefix) or isComOrHolder or isDispatch)
                    and not mainP.isSlot then
                    (* deallocate INNER-dispatch;
                     * No do-part and a superPtn
                     *)
                    virtOff - 4 -> virtOff
            if)if);
            (if exitP.label <> gram.empty then
                (ThisDesc,exitP.son,key.exitt,true)
                  -> &ChkEval
                  -> (xExpKind,descVal,xSize,hasXcode,type);
                (if ctst then
                    178 -> trace(#do 'hasXcode:'->xT; hasXcode -> xB;
                                   thisDesc[] -> xA;
                                   ' type: ' -> xT; type -> xI
                                #)
                if);
                (if hasXcode then else 0->exitP.NXoff if);
                xSize->exitP.NXsize;(* seems redundant??*)
                (* OBS! It has NOT been validated if preType is always OK;
                 * There may be cases where preType is emptyType, but
                 * there is actually a non-empty exit-part. This may e.g. be
                 * the case with exit of objetcs. To check this, chkEvalBody
                 * must be carefully checked to see if the value 'type'
                 * is always well defined.
                 * If preType is emptyType, but he prefix has an exit-part,
                 * then type for this desc may e.g. be valType where it
                 * should be listType
                 *)
                (if preType <> emptyType then listType->type if);
                hasXpart;
             else
                preType->type;
                (* OBS! ***** Recurseive checker problem *****
                 * Consider
                 *    A: (# V:< T ... exit V #);
                 *    AA: A(# V:: TT ... #),
                 *    T: (# ... exit aChar #);
                 *    TT: T(# ... exit aChar #)
                 * preType for AA is defined by exit-part for T, i.e. char
                 * since A is just checked in context A (superChain defined
                 * by A). The preType should be difend by the exit-part
                 * for TT and be list
                 *)
                simpleExpEval->xExpKind
            if);
            (if mainP.isSlot then
                AllocReturn;
                generalKind->descKind; true->hasDo; true->innerFound;
                false->isCst; common.cstInd->descAccess;
                true -> hasAcode (* due to newindex.bet problems:
                                  * we cannot save kind for a mainpart:
                                  * when the mainpart later is checked
                                  * information about e.g. hasAcode
                                  * cannot be saved in kind; by
                                  * setting true->hasAcode, there
                                  * will always be a G-part for the
                                  * mainpart; see gdbody::genMainPart
                                  *)
            if);
            isCst and (xExpKind = constEval) -> isCst; 
            (if not preDesc.isNull then
                (preDesc[]->semAtt.hasNcode) or hasNcode ->hasNcode;
                (preDesc[]->semAtt.hasXcode) or hasXcode ->hasXcode;
            if);
            (if switch180 then
                (# NOS,XOS : ^NXoffSets
                do offCount -> thisDesc.returnOff; (* !! temporary use *)
                   (if hasNcode then
                       &cNXoffSets[] -> NOS[];
                       (thisDesc[],true,thisDesc->BV.newSingle,offCount) 
                         -> NOS.SetNXoffsets;
                       NOS.startOff -> offCount;
                       (if ctst then
                           178->trace
                           (#
                           do 'NoffSets:'-> xT; 
                              'attSize ='-> xT; thisDesc.returnOff -> xI;
                              ', offCount ='->xT; offCount->xI; xN;
                              thisDesc[] -> xA; xN;                         
                              NOS.dump
                           #)
                       if);
                   if);
                   (if hasXcode then
                       &cNXoffSets[] -> XOS[];
                       (thisDesc[],false,thisDesc->BV.newSingle,offCount) 
                         -> XOS.SetNXoffsets;
                       XOS.startOff -> offCount;
                       (if ctst then
                           178->trace
                           (#
                           do 'XoffSets:'-> xT; 
                              'attSize ='-> xT; thisDesc.returnOff -> xI;
                              ', offCount ='->xT; offCount->xI; xN;
                              thisDesc[] -> xA; xN;                         
                              XOS.dump
                           #)
                       if);
                   if);
                #)
            if);
            (if isCst then
                (*194->trace(#do desc[]->A; L; descVal->I #);*)
                descVal -> ThisDesc.virtSize;
                constKind -> descKind
             else 
                InsLst.alloc;
                (* align to 4 bytes *)
                (*((8 - (offCount mod 8)) mod 8) + offCount->offCount;*)
                (if switch181 then
                    193->trace
                    (#
                    do 'NXtmp:'-> xT; offCount -> xI; 
                       NXtmp.maxNXdepth -> xI
                    #);
                    offCount -> ThisDesc.returnOff; (* can we do this?*)
                    (* currently we allocate twice the max. 
                     * Should be made more precise *)
                    NXtmp.maxNXdepth*2*4 + offCount -> offCount
                if);
                offCount -> ThisDesc.size; 
                virtOff-4 -> ThisDesc.virtSize;
                ChkObjSize; 
                (if descKind
                 // procKind
                 // classKind
                 // externalClassKind
                 // holderKind
                 // comKind 
                 // dispatchKind then
                 // externalVirtualKind then  
                 else
                    generalKind -> descKind
                if)
            if);
            (if ctst then
                198->trace(#do 'IsDispatch:'->xT;
                             ThisDesc -> DispatchDesc.equal -> xB; xN;
                             thisDesc[] -> xA;
            #)if);
            (* Note! Here we explicitly check for iDispatch *)
            (if (ThisDesc -> DispatchDesc.equal -> isDispatch) then
                dispatchKind -> descKind -> preKind
            if);
            
            (if preKind
             // externalKind // callBackKind then &ChkCprocDesc->descKind 
             // dataKind then &ChkDataKind; dataKind->descKind
             // comKind then 
                (if ctst then 198->trace(#do 'COM super pattern'->xT #)if);
                comKind -> descKind;
                ChkComDesc
             // dispatchKind then
                dispatchKind -> descKind;
                true -> ChkComDesc
             // HolderKind then
                HolderKind -> descKind
             // stateKInd then
                stateKind -> descKind
             // procKind then
                procKind -> descKind
             // classKind then
                classKind -> descKind
             // externalClassKind then
                externalClassKind -> descKind
            if);
            True->descOK;
            
            NOT (hasNcode or hasDo or hasXcode)->isData;
            L:
              (if (desc[]->sematt.hasInner) or innerFound then
                  (*inner P*) true->innerFound;
                  (if doP.isSlot=false then
                      doP->scanList
                      (# imp: @ASTindex; i: @integer
                      do (if (i+1->i) > 1 then false->hasOnlyInner; leave L if);
                         currentNode->imp;
                         (if imp.label<>gram.innerImp then leave L if);
                         (if preDesc.isNull then true->hasOnlyInner
                          else
                             preDesc[]->sematt.hasOnlyInner->hasOnlyInner
              if)#)if)if);
            ClassifyDesc;
            (# F: @ASTindex;
            do desc.father -> F;
               (if F.label // gram.bindingDecl // gram.finalDecl then
                   (* perhaps more cases here *)
                   false -> insertable
               if)
            #);
            (*193->trace(#do 'chkDesc:type: ' -> xT; type -> xI #);*)
            (desc[],descKind,hasNcode,hasDo,hasXcode,isData,innerFound
            ,insertable,descAccess,hasAcode,hasOnlyInner
            ,inlineNX,inlineDO,hasOnlyNX,type)
              -> MarkDesc;
            (if ctst then 
                (if common.switch[196] then desc[]->&DumpDesc if)
            if)
        if)
     #);
   chkAttForm:
     (# A: @ ASTindex
     do desc.son->A; A[]->att[];
        desc.xOrigin->desc->thisDesc; (*!!!!!!!!!!???????????????????*)
        0->offCount; True->&ChkAtt
        (*illegal recursive checking of att-form should not be possible*)
     #);
   chkDoPart:
     (* compile-time information in AST-node:
      * --------------------------------------------------------------
      * doPart: att-1: descNo: size of do-part object;
      *                        size = 0 implies that no tmp. locations 
      *                                 for for-imp, etc are needed
      * doPart: att-2: ?
      * 
      * Run-time layout of do-part object:
      * ----------------------------------
      * 0 : simple prototype id
      * 4 : GC field
      * 8 : origin
      * 12: size
      * 16: tmp data 1
      * ..:
      *)

     (# (* thisDesc (declared in docheck.bet) is the descriptor
         * containing the slot corresponding to the doPart form;
         * below we may assign theForm -> thisDesc!!
         *)
        theForm,   (* the doPart form currently being checked: 'do ...'*)
        theSlot:   (* the slot in thisDesc *)
          @ ASTindex;
        hasDoPartObject: @boolean (* this doPart form needs a doPartObject
                                   * since it needs tmp storage or
                                   * has singular descriptors that may
                                   * or may not be inlined
                                   *)
     do desc -> theForm;
        192->trace(#do 'doPart:theForm ' -> xT; theForm[]->xA #);
        theForm.xOrigin -> theSlot; 
        192->trace(#do 'doPart:theSlot ' -> xT; theSlot[]->xA #);
        theSlot.slotOrigin -> thisDesc;
        192->trace(#do 'doPart:thisDesc ' -> xT; thisDesc[]->xA #);
        &ASTindex[] -> doP[];
        theForm.son->doP;
        
        (*thisDesc.size->offCount;*)
        true -> isDoPartForm; (* not used?*)
        (if theForm[]->sematt.doPartHasTmp then
            (* In initform it is checked if the dopart has any
             * for- or labelled-imperatives in which case
             * a dopart object is needed. In that case,
             * descNo = 1.
             * But why are we assigning to thisDesc?
             *)
            theForm->thisDesc;
            true -> hasDoPartObject
        if);
        16->offCount;
        (*192->trace(#do 'doPartForm:chkImpLst: ' -> xT;
         theForm.descNo -> xI; xN;
         doP[] -> xA;
         #);*)
        doP->&ChkImpLst;
        
        (if hasDoPartObject then
            ((8 - (offCount mod 8)) mod 8) + offCount
              -> offCount
         else
            (if offCount = 16 then (* no tmp. att. allocated *)
                0->offCount;
                (if theForm[] -> sematt.doPartHasTmp then
                    'Inconsistencies in storage allocation for doPart'
                      -> thisTranslate.systemException
                if)
        if)if);
        (* 192->trace
         (#do (if offCount=0 then 'No '->xT if); 'doPartObj'->xT#);*)
        (if true (*not switch182*) then
            offCount->theForm.descNo; 
            (*!!!!! ChkImpLst may allocate storage for possible for-imp, etc.
             * the size is stored en theForm.descNo. This is a hack.
             * Se  also control.bet where descNo is cleared for forms
             * other than doPart and mainpart
             *)
        if);
        ChkObjSize;
     #);
   chkMainPart:
     (* OLM: 28/12/98: 
      * - fixed wrong calculation of mainPart/descriptor size
      * - the size is stored in the theForm.descNo which is a similar
      *   hack also done for doPart forms. (see above).
      * - STILL MISSING: proper treatment of possible enter/exit parts
      *   which may be visible via include of the mainPart form. 
      *)
     (# theForm: @ASTindex
     do desc -> theForm;
        desc[] 
          -> mainPartSons 
          -> (thisDesc,pre[],att[],entP[],doP[],exitP[]);
        (if entP.label <> gram.empty then
            (entP,125) -> WE.Warning
        if);
        (if exitP.label <> gram.empty then
            (exitP,125) -> WE.Warning
        if);
        0 -> offCount;
        false -> isCst;
        ChkPre -> preKind;
        (* the following initializations should be checked*)
        generalKind -> descKind;
        common.cstInd -> descAccess;
        false -> hasNcode -> hasXcode -> isData 
          -> insertable -> hasOnlyInner -> inlineNx 
          -> inlineDo -> hasOnlyNX;
        
        (if ctst then  192->trace(#do 'mainP1:'->xT; offCount->xI#)if);
        false->&ChkAtt;          
        (if ctst then
            192->trace
            (#do 'mainP2:'->xT; offCount->xI; 'hasAcode:'->xT; hasAcode->xB#)
        if);
        doP.label <> gram.empty -> hasDo;
        
        doP->&ChkImpLst; (* enter/exit  is missing *)
        (if ctst then 192->trace(#do 'mainP3:'->xT; offCount->xI#)if);
        offCount->theForm.descNo; 
        ChkObjSize;
        (desc[],descKind,hasNcode,hasDo,hasXcode,isData,innerFound
        ,insertable,descAccess,hasAcode,hasOnlyInner
        ,inlineNX,inlineDO,hasOnlyNX,type)
          ->MarkDesc;        
     #)
do 191 -> trace
   (#do 'Checking: DescKind='-> xT; 
      (if desc.label 
       // gram.objectDescriptor // gram.descriptorForm then
          desc->sematt.descKind->xI; 
       // gram.attributesForm // gram.attributes then
          ' attributes'->xT;
       // gram.doPart then ' dopart' -> xT
       // gram.mainPart then
          ' mainpart' -> xT
       else ' ???' -> xT
      if);
      xN; 
      desc[]->xA ;
   #);
   DoCheck:
     (if desc.label 
      // gram.objectDescriptor then 
         chkObjDesc(# exitt::(# do leave DoCheck #)#)
      // gram.attributesForm then
         chkAttForm
      // gram.doPart then
         chkDoPart
      // gram.mainPart then
         chkMainPart
     if);
#) (* ChkForm *)

