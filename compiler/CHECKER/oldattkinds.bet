ORIGIN 'sematt'; 
LIB_ITEM 'betacompiler';
---semattLib:attributes---
(*-------------------- desc kind -------------------
 *  descriptors are classified into
 *  beingChecked: curently being checked by chkDesc
 *  undefined: has not yet been checked
 *  standard: like integer, boolean, char, true, ...
 *  const:    like integer, (#exit 9#),
 *  cProc:    a direct subpattern of Cproc 
 *  general:  a general user defined pattern
 * 
 *  In addition various properties are associated with each  descriptor
 *
 *  descKind and the properties are packed into the AST attribute 'kind':
 *  descKind   = kind[0-7]
 *  hasNcode   = kind[8]
 *  hasDcode   = kind[9]
 *  hasXcode   = kind[10]
 *  isData     = kind[11]
 *  hasInner   = kind[12]
 *  insertable = kind[13]
 *  descAccess = kind[14]
 *  interpreted= kind[15]  used by interpreter: descriptor is interpreted
 *  hasAcode   = kind[16]  Allocation-code is needed (non-empty G-part)
 *  hasOnlyInner= kind[17] On the form P(# ... do inner #), where P also
 *                         hasOnlyInner - enter/exit-parts may appear
 *  inlineNX    = kind[18] Form: (# a,b,c: @integer enter(a,b,c) exit E #)
 *                         Code is inlined
 *  enter/exit  = kind[25:26] Used by compciler to check for recursion
 *                            in enter/exit list; chklst.bet
 *  type        = kind[27:31] The type of basic patterns like
 *                            boolean, char, short, integer, real
 * 
 *)
beingChecked: (#exit 50(*must be positive*) #);
unDefined: (#exit 0 #);
standardKind: (#exit 1#); constKind: (#exit 2#); 
externalKind: (#exit 3#); generalKind: (#exit 4#);
dataKind: (#exit 5#); callBackKind: (#exit 6#);
externalVirtualKind: (#exit 7 #);
comKind: (#exit 8 #); holderKind: (#exit 9 #);
stateKind: (#exit 10 #);
dispatchKind: (#exit 11 #);  
dispatchVirtualKind: (#exit 12 #); 
classKind: (# exit 13 #);
procKind: (# exit 14 #);
externalClassKind: (# exit 15 #);
consKind: (# exit 16 #);
staticProcKind: (# exit 17 #);
staticConsKind: (# exit 18 #);

kindAstext:
  (# kind: @integer; T: @text
  enter kind
  do (if kind
      // standardKind then 'standard'->T;
      // constKind then 'const'->T;
      // generalKind then 'general'->T;
      // classKind then 'class'->T;
      // procKind then 'proc'->T
      else
         kind->T.putint
     if)
  exit T[]
  #);

insEval: (#exit 1#); simpleEval: (#exit 2#); 
repValEval: (#exit 3#); repRefEval: (#exit 4 #);
itemEval: (#exit 5#); compEval: (#exit 6#); sysKind: (#exit 7#);
repKind: (#exit 8#); realEval: (#exit 9#);

(* enter-exit list are classified using the following categories;
 * see chkEvalBody
 *)
constEval: (#exit 1 #);
simpleVarListEval: (#exit 2 #);
inlineNXeval: (#exit 3 #);
simpleExpEval: (#exit 4 #);
generalEval: (#exit 5 #);

(* for some unknown reason there seems to be a memory leak
 * if the patterns below are made static items!
 * Each of them should at most be able to hold on to one
 * ref., but they seem to hold onto much more??
 *)
(* Operations using D.kind may fail if the descriptor (D) is
 * not an objectDesciptor; this only occurs in very
 * special cases; e.g. compiler/compiler/TST/FEJL/container.
 * Perhaps all the operations below should check that
 * D is a descriptor??
 *)
markBeingChecked: 
  (# D: ^ASTindex; K: @integer
  enter D[] 
  do (beingChecked,0) -> K.%putByte; K->D.kind
  #);
descKind:  
  (# D: @ASTindex; K: @integer
  enter D 
  do D.kind -> K; 0 -> K.%getByte ->K 
  exit K
  #);
has: 
  (# d: ^ASTindex; K: @integer ; B: @boolean
  enter d[] 
  do d.kind -> K; INNER
  exit B
  #);

hasNcode:   has(# do (8,1) -> K.%getBits -> B #);
hasDo:      has(# do (9,1) -> K.%getBits -> B #);
hasXcode:   has(# do (10,1) -> K.%getBits -> B #);
isData:     has(# do (11,1) -> K.%getBits -> B #);
hasInner:   has(# do (12,1) -> K.%getBits -> B #);
insertable: has(# <<SLOT sematt_insertable:doPart>> #);
descAccess: integerValue
  (# D: ^ASTindex; K: @integer
  enter D[] 
  do d.kind -> K; 
     (14,1) -> K.%getBits -> value
  #);
hasAcode: has
  (#
  do (if common.switch[214] then 
         (if common.switch[64] and not common.switch[65] then 
             true->b
          else
             (16,1) -> K.%getBits -> B
         if)
      else true -> B
     if)
  #);
hasOnlyInner: has(# do (17,1) -> K.%getBits -> B #);
inlineNX:     has(# do (18,1) -> K.%getBits -> B #);
inlineDO:     has(# do (19,1) -> K.%getBits -> B #);
hasOnlyNX:    has(# do (20,1) -> K.%getBits -> B #);
type: integerValue       
  (# D: ^ASTindex; K: @integer
  enter D[] 
  do d.kind -> K; 
     (27,5) -> K.%getBits -> value
  #);
doPartHasTmp: booleanValue
  (# doP: ^ASTindex
  enter doP[]
  <<SLOT sematt_doPartHasTmp:doPart>>
  #);
MarkDesc:
  (# desc: ^ASTindex; descKind,xType: @Integer; (* byte *)
     hasNcode,hasDo,hasXcode,isData,hasInner,insertable
     ,hasAcode,hasOnlyInner,inlineNX,inlineDO,hasOnlyNX: @boolean;
     descAccess: @integer (* OBS only 0 or 1 *)
  enter(desc[],descKind,hasNcode,hasDo,hasXcode,isData,hasInner
     ,insertable,descAccess,hasAcode,hasOnlyInner,inlineNX,inlineDO
     ,hasOnlyNX,xType)
  do <<SLOT MarkDesc:descriptor>>
  #);
StandardMark:
  (# d: @ASTindex; descKind,type,K: @integer
  enter (d,descKind,type)
  do (descKind,0) -> K.%putByte;
     (type,27,5) -> K.%putBits;
     K->d.kind
  #);   
MarkInner:
  (# d: @ASTindex; descKind,K: @integer
  enter (d,descKind)
  do (descKind,0) -> K.%putByte;
     (1,12,1) -> K.%putBits;
     K->d.kind;
  #);
StandardMarkInner:
  (# d: @ASTindex; descKind,type,K: @integer
  enter (d,descKind,type)
  do (descKind,0) -> K.%putByte;
     (type,27,5) -> K.%putBits;
     (1,12,1) -> K.%putBits;
     K->d.kind
  #);  
MarkOnlyInner:
  (# d: @ASTindex; kind: @integer
  enter d
  do (* set hasInner = true *)
     d.kind->kind;
     (true,12,1) -> kind.%putBits;
     (*hasinner*)
     (true,17,1) -> kind.%putBits;
     (*only inner*)
     kind->d.kind;          
  #);
GetAndSetOp1: booleanValue
  (# D: @ASTindex; K: @integer
  enter D
  do D.kind -> K;
     (25,1) -> K.%getBits -> value;
     (1,25,1) -> K.%putBits;
     K->D.kind
  #);
GetAndSetOp2: booleanValue
  (# D: @ASTindex; K: @integer
  enter D
  do D.kind -> K;
     (26,1) -> K.%getBits -> value;
     (1,26,1) -> K.%putBits;
     K -> D.kind
  #);
ClearOp1:
  (# D: @ASTindex; K: @integer
  enter D
  do D.kind -> K;
     (0,25,1) -> K.%putBits;
     K -> D.kind
  #);
ClearOp2:
  (# D: @ASTindex; K: @integer
  enter D
  do D.kind -> K;
     (0,26,1) -> K.%putBits;
     K -> D.kind
  #);
  
---sematt_insertable:doPart---
do (if false (*switch182*) then
       false -> B
    else
       (13,1) -> K.%getBits -> B 
   if)
   
---sematt_doPartHasTmp:doPart---
do (if false (*switch182*) then
       common.switch[323] and (doP.descNo > 0) -> value
    else
       (doP.descNo > 0) -> value
   if)

---MarkDesc:descriptor---
(# K: @Integer
do (if false then
       (if not common.switch[205] and (descKind = callBackKind) then
           (* callBackKind is ONLY activated when switch[205] is true *)
           externalKind -> descKind
   if)if);
   (descKind  , 0)   -> K.%putByte;
   (hasNcode  , 8,1) -> K.%putBits;
   (hasDo     , 9,1) -> K.%putBits;
   (hasXcode  ,10,1) -> K.%putBits;
   (isData    ,11,1) -> K.%putBits;
   (hasInner  ,12,1) -> K.%putBits;
   (insertable,13,1) -> K.%putBits;
   (descAccess,14,1) -> K.%putBits;
   (* bit 15 is used by the interpreter *)   
   
   (if not common.switch[214] then true -> hasAcode if);
   (if not common.switch[215] then false->hasOnlyInner if);
   
   (hasAcode    ,16,1) -> K.%putBits; 
   (hasOnlyInner,17,1) -> K.%putBits;
   
   (if common.switch[211] then (inlineNX ,18,1) -> K.%putBits if);
   (if common.switch[212] then (inlineDO ,19,1) -> K.%putBits if);
   (if common.switch[213] then (hasOnlyNX,20,1) -> K.%putBits if);

   (xType,27,5) -> K.%putBits;
       (* 166->trace(#do 'Type:'->T; xType->I; newline#);
        * 191->trace(#do (if hasAcode then 'hasAcode'->T if);
        * (if hasOnlyInner then 'OnlyInner'->T if) #);
        *)
   (if desc.label 
    // gram.objectDescriptor then
       K -> desc.kind;
    // gram.doPart then
       '\n *** marking doPart ! ' -> putline
    // gram.mainPart then
       (*  '\n *** marking mainPart ! ' -> putline*)
    // gram.attributes // gram.attributesForm then
       '\n *** marking attributes ! ' -> putline
    else
       '\n *** marking unknown ! ' -> putline
   if)  
#)
