ORIGIN 'chklst';
INCLUDE '~beta/betaast/semanticerrortext';
LIB_ITEM 'betacompiler'
---chkLstLib:attributes---
mkLst:
  (# L: [1]^text; T: ^text;
     l1,l2,l3,l4,l5: ^text
  enter(L1[],L2[],L3[],L4[],L5[])
  do (*L[1][] -> T[];
      (for i: L.range-1 repeat L[i+1][] -> T.append for)
      *)
     L1[] -> T[];
     (if L2[] <> none then L2[] -> T.append if);
     (if L3[] <> none then L3[] -> T.append if);
     (if L4[] <> none then L4[] -> T.append if);
     (if L5[] <> none then L5[] -> T.append if);
  exit T[]
  #);

          
rep2repError:
  (# EV,Lelm,Relm: ^ASTindex; no: @integer;
     T: ^text; S: @text;
     L: [2] ^text;
     E: [1] ^ASTindex
  enter(EV[],Lelm[],Relm[],no)
  do (EV[],false) -> WE.makeError
     (#
     do 'In the repetition assignment "' -> XT;
        EV[] -> XA;
        '" ' -> XT;
        (if no
         // 127 then 
            '\n   the size of the left-side elements ("' -> XTl;
            Lelm[] -> XA;
            '")' -> XT;
            '\n   must be the same as the size of the right-side elements("' 
              -> XTl;
            Relm[] -> XA;
            '")' -> XT            
         // 128 then
            '\n   the left-side elements ("' -> XTl;
            Lelm[] -> XA;
            '") are static items,' -> XT;
            '\n   but the right-side elements ("' -> XTl;
            Relm[] -> XA;
            '") are not' -> XT            

         // 129 then
            '\n   the left-side elements ("' -> XTl;
            Lelm[] -> XA;
            '") are basic patterns,' -> XT;
            '\n   but the right-side elements ("' -> XTl;
            Relm[] -> XA;
            '") are not' -> XT            
            
         // 130 then
            '\n   the left-side elements ("' -> XTl;
            Lelm[] -> XA;
            '") are basic patterns,' -> XT;
            '\n   but the right-side elements ("' -> XTl;
            Relm[] -> XA;
            '") are not' -> XT            
         // 131 then
            '\n   the left-side elements ("' -> XTl;
            Lelm[] -> XA;
            '") are dynamic items,' -> XT;
            '\n   but the right-side elements ("' -> XTl;
            Relm[] -> XA;
            '") are not' -> XT            
            
         // 132 then
            'Repetition assignment is not implemented for variable patterns'
              -> XT
        if)
     #)
  #);

Rep2RepAsg:
  (# Lelm,Relm: ^ASTindex; 
     lChain,rChain: ^actualDesc.DB.superChain;
     valAsg: @boolean;
     level: @integer;
  enter(Lelm[],Relm[],lChain[],rChain[],valAsg,level)
  do (if ctst then
         221 -> trace 
         (#do 'Rep2RepAsg:'->xT;
            (if valAsg then 'value:'-> xT
             else 'ref:'-> xT
            if);
            lelm[] -> xA; rElm[] -> xA;
            '\nlChain:' -> xT; lChain.print;
            '\nrChain:' -> xT; rChain.print;
         #)
     if);
     (if Lelm.label
      // gram.textConst then
         (* 'abcdefg' -> R *)
         (* should we end here and not somewhere above?
          * Case 3: e.g?
          *)
      // gram.staticItem then
         (# lDesc, rDesc: @ASTindex; 
            (*isVirt,MN: @integer;
             chain1:  ^actualDesc.DB.SuperChain;*)
         do (if Relm.label = gram.staticItem then
                (* (Lchain[],Lelm.son)
                 -> actualDesc.DB.theDescForm
                 -> (Ldesc,MN,chain1[],isVirt);
                 *)
                (* (Rchain[],Relm.son)
                 -> actualDesc.DB.theDescForm
                 -> (Rdesc,MN,chain1[],isVirt);
                 *)
                Lchain.desc -> lDesc;
                rChain.desc -> rDesc;
                (if cTst then
                    221->trace
                    (#
                    do 'lDesc:\n' ->xT; lDesc[] -> xA;
                       'rDesc:\n' ->xT; rDesc[] -> xA;
                    #)
                if);
                
                (if Ldesc -> isStandard then
                    (if rDesc -> isStandard then
                        (if (lDesc.size = rDesc.size)
                                then
                            (if (lDesc->realDesc.equal)
                                and
                                not (rDesc->realDesc.equal) 
                                or
                                (rDesc->realDesc.equal)
                                and
                                not (lDesc->realDesc.equal) 
                                then
                                (EV[],Lelm[],Relm[],127) -> rep2repError
                            if)
                         else                            
                            (EV[],Lelm[],Relm[],127) -> rep2repError
                        if)
                     else
                        (*(EV,129) -> WE.SemError*)
                        (EV[],Lelm[],Relm[],129) -> rep2repError
                    if)
                 else
                    (if rDesc -> isStandard then
                        (*(EV,130) -> WE.SemError*)
                        (EV[],Lelm[],Relm[],130) -> rep2repError
                     else
                        (* check of general repetitions:
                         *  R1,R2: [3] @ T
                         *  R1 -> R2
                         * Does NOT work
                         *)
                        (* (EV,Lelm.son,Relm.son,Lchain[],Rchain[],level+1,0,0)
                         -> ChkLst
                         *)
                        (EV,133)->&WE.Warning
                    if)
                if)
             else
                (*(EV,128) -> WE.SemError*)
                (EV[],Lelm[],Relm[],128) -> rep2repError
            if)
         #)
      // gram.dynamicItem then
         (if Relm.label = gram.dynamicItem then
             
          else
             (*(EV,131) -> WE.SemError*)
             (EV[],Lelm[],Relm[],131) -> rep2repError
         if)
      // gram.staticComponent then
      // gram.dynamicComponent then
      // gram.variablePattern then
         (*(EV,132) -> WE.SemError*)
         (EV[],Lelm[],Relm[],132) -> rep2repError
      else
         '\n ***ShouldNotHappen:Repetition assignment error' -> putline
     if)
  #);
---ChkTxtCstToTxtRef:doPart---
   (* Check assignments like 'Hello'->T[] where T must be T: ^text.
    * use global var Relm .
    * Relm: object,stream,text, subText,...
    *       qua,   qua,   noQua, error, ...
    *)
do (# R,rDesc: @AStindex; MN2: @integer; RC:^ActualDesc.DB.superChain;
      found: @boolean; RptnForm: @integer
   do (if Relm.label = gram.dynamicItem then
          Rchain.desc -> rDesc; 
          rChain[] -> RC[];
       else
          Relm.son->R;
          (Rchain[],R)->ActualDesc.DB.theDescForm->(rDesc,MN2,RC[],RptnForm); 
      if);
      (textDesc,rDesc)->&ChkQua->(MN2,found);
      (if found then
          (if RC.ptnForm//1//2 then
              (* qua-check needed here 
               * Must be fixed in cstTxtVal:asgToRef
               *)
              (EV,24)->&WE.Warning
          if)
       else
          (if switch182 (* bytecode *) then
              (if (rDesc->descKind) = unDefined then
                  (rDesc[],false,none,-1)->&chkForm
              if);
              (* can be 'hello' -> S[]; where S: ^java.lang.String *)
              (if (rDesc -> descKind) =  externalClassKind then
                  (* we assume java.lang.string; but this should
                   * only be legal when calling methods in
                   * external classes
                   *)
               else
                  (EV,11)->&WE.SemError; true->ListError
              if)
           else
              (EV,11)->&WE.SemError; true->ListError
          if)
      if)
   #)
---QuaCheck:doPart---
do QuaLoop:
     (# getAtt: @
          (# S: ^AStindex
          enter S[]
          do (if ctst then
                 198 ->trace(#do S[]->xA; (S.asAst).dump #)
             if);
             (if S.label = gram.objectReference then S.son->S if);
             (if S.label
              // gram.ObjectDenotation then
                 S.son->S;
                 (if S.label = gram.thisObject then S.son->S if)
              // gram.dynamicItemGeneration 
              // gram.dynamicComponentGeneration
                 then S.son->S
              // gram.structureReference then S.son->S
             if);
          #);
        printInfo:
          (# D: @ASTindex
          do -1 -> trace
             (#
             do LE[] -> xA; '[] -> ' -> xT; RE[] -> xA; '[]' -> xT;
                '\n\tQualification left: ' -> xT; 
                LD.father -> D; D[] -> xA;
                '\n\tFrom: ' -> xT; LC.virtDcl[] -> xA;
                '\n\tQualification right: ' -> xT; 
                RD.father -> D; D[] -> xA;
                (if RC[] <> none then
                    '\n\tFrom: ' -> xT; RC.virtDcl[] -> xA;
                if)
          #)#);
        lstErr: 
          (# isn: @boolean; n: @integer
          enter(isn,n)
          do (if isN and isEnter (* isN may be dropped?*) then
                 (if not (LE->RE.equal) then
                     (if N = 24 then
                         199->trace
                         (# 
                         do 'Qua check for:\n\t' -> xT;
                            PrintInfo
                         #);
                         (EV,24)->WE.Warning;                       
                      else 
                         N -> quaError;
                         (*(EV,N)->&WE.SemError; *)
                         true->ListError
          if)if)if)#);
        RC,LC: ^ActualDesc.DB.SuperChain;
        found: @boolean; LptnForm,RptnForm: @integer;
        MN1,MN2,PD: @integer; 
        LD,RD,L: @ASTindex; 
     do (if ctst then
            223->trace
            (#
            do 'QuaChk: '->xT;
               100 -> SwitchOn;
               LE[] -> xA; RE[] -> xA; xN;
               100 -> SwitchOff;
               Lchain.print; 
               '-----'->xT;
               rChain.print
            #)
        if);
        LE[]->getAtt; RE[]->getAtt;
        (Lchain[],LE)->ActualDesc.DB.theDescForm->(LD,MN1,LC[],LptnForm); 
        RE.father -> RD;
        223->trace(#do 'QuaCheck2:'->xT;                      
                     LD[] -> xA; 
                     100 -> SwitchOn;
                     RD[]-> xA; 
                     100 -> SwitchOff;
                  #);

        (if RD.label = gram.dynamicItem then
            Rchain.desc -> RD;
            Rchain[] -> RC[]; (* just a guess!*)
         else
            (Rchain[],RE)->ActualDesc.DB.theDescForm->(RD,MN2,RC[],RptnForm); 
        if);
        (if ctst then
            223->trace
            (#do 'QuaChk3: '->xT;
               printInfo;
               '\n\tLeft ptnForm: '->xT; LC.ptnForm->xI; LptnForm->xI;
               '\n\tRight ptnForm: '->xT; 
               (if RC[] <> none then RC.ptnForm->xI; RptnForm->xI; if)
            #)
        if);
        (LD,RD)->&ChkQua(# error::(#do leave QuaLoop #)#)->(PD,found);
        (if (LD->isStandard) and not (LD->cProcDesc.equal) then 
            -1 -> QuaError
        if);
        (if found then 
            (if (RC.ptnForm=VirtualInPtnForm) 
                and (LC.ptnForm=VirtualInPtnForm) then
                (*(RptnForm=2) and (LptnForm=2) then*)
                (* an assignment of the form
                 *    x[]->y[]
                 * where 
                 *    x: ^V; y: ^ W
                 * and V and W are virtuals and LD <= RD.
                 * If V=W then NO qua-check is needed
                 * If V<>W, then a qua-check is needed
                 *)
                (if RC.virtDcl->LC.virtDcl.equal then
                    (* no qua-check*)
                    (if not (LD->RD.equal) then
                        '\n***Direct virtual, but descs not equal!'
                          ->putline
                    if)
                 else
                    (isEnter,24)->&LstErr
                if)
             else
                L:
                  (#
                  do (if (LC.virtDcl[] <> NONE)
                         and (LC.virtDcl.label = gram.finalDecl)
                         and (RptnForm >= VirtualForm) then
                         (* 16/8/98:
                          * To eliminate qua check in FEJL/hmlqua.bet;
                          * L may be final bound to a virtual R;
                          * 5/12/98: originally only effective with 
                          * switch 199 since we were close to freezing r4.2;
                          * a simpler situation:
                          *   P1: (# typeB:< Stream;
                          *          B: ^typeB;
                          *       do INNER;
                          *       #);
                          *   P2: (# typeC:< Stream;
                          *          C: ^typeC;
                          *       do P1(# typeB::typeC;
                          *            do B[]->C[];
                          *            #)
                          *       #);
                          *)
                         (# A: @ASTindex; AD: @ AttDesc       
                         do LC.virtDcl.son -> A;
                            A.brother -> A; 
                            (A[],ThisDesc->BV.NewSingle)-> AD;
                            RC.virtDcl -> A;
                            (if AD.sort -> A.equal then
                                leave L
                     if)#)if);
                     
                     (* qua-check if R is virtual *)
                     (RptnForm >= VirtualForm,24)->&LstErr
                  #)
            if)
         else
            (if LE.label = gram.objectDescriptor then
                (* &P(# ... #)[] -> R[]; -- always an error *)
                (true,20)->&LstErr
             else
                (* check if L is static-ref in which case
                 * the QUA-error can be deteched at compile-time
                 *)
                LE->GetSort->L;
                L.son->L; L.brother->L;
                (* This check is only relevant for simplDecl,
                 * since currently no:
                 *    X: [..] @T
                 *)
                (if ctst then 198->trace(#do' Static?'->xT #)if);
                (if L.label//gram.staticItem//gram.staticComponent
                    then (true,20)->&LstErr
                 else
                    (RD,LD)->&ChkQua->(PD,found);
                    (if found then 
                        (isEnter,24)->&LstErr 
                     else 
                        223->trace
                        (#
                        do 'text2string?:'->xT;
                           LD[] -> xA; xN;
                           RD[] -> xA; xN;
                           sematt.textDesc[] -> xA; xN;
                           RD->descKind -> putint;
                        #);
                        (if switch182
                            and ((RD->descKind) = unDefined) then
                            (* perhaps we should just get top
                             * super and check if it is externalClass
                             * checking may perhaps give a recursion error
                             *)
                            (RD[],false,none,-1)->&chkForm
                        if);
                        (if switch182
                            and ((LD->descKind) = unDefined) then
                            (* perhaps we should just get top
                             * super and check if it is externalClass
                             * checking may perhaps give a recursion error
                             *)
                            (LD[],false,none,-1)->&chkForm
                        if);
              
                        (if switch182
                            and (LD->sematt.textDesc.equal)
                            and ((RD->descKind) = externalClassKind) then
                            (if not common.switch[188] then
                                'BetaText -> ExternalClass' -> putline
                            if);
                         else
                            (if (RD->sematt.textDesc.equal)
                            and ((LD->descKind) = externalClassKind) then
                                (if not common.switch[188] then
                                    'ExternalClass -> BetaText' -> putline;
                                if);
                             else
                                (isEnter,20)->&LstErr;                        
                                (* used to be an error also for comparison 
                                 * but never caught - however is just always false!
                                 *)
                        if)if)
     if)if)if)if)#)
---chkBinOpTypes:doPart--
do (# 
   do (*198->trace
       (#do 'chkBinTypes: '->T; EV[]->A;
       Ltype->I; LE[]->A; Rtype->I; RE[]->A
       #);*)
      
      (if EV.label
       // gram.caseSelection (* from general-if *) then
          gram.eqExp->op
       else
          EV.label->op
      if);
      LType mod 16 -> Ltype;
      RType mod 16 -> RType;
      op->EvalClass.OpType->opType;

      (if ctst then
          198->trace
          (# S: @text; resType: @integer
          do op->xI; ' ' ->put; opType->xI; ' '->put;
             opType->EvalClass.opString->S; S[]->xT; ' '->put; 
             Ltype->sematt.evalClass.typeString->xT; ' '->put; 
             Rtype->sematt.evalClass.typeString->xT;; ' '->put;
             (if ((op,Ltype,Rtype)->EvalClass.map->resType)=0 then
                 'error'->xT
              else resType->xI; xN
             if)
          #)
      if);
      (if (*op->evalClass.OpType*) opType
       // evalClass.addOp then 
          (Ltype,RType)->evalClass.addMap->type;
          (if type 
           // 0 then 0->m (* error *)
           // -1 then 4->m; valType -> type
           else 
              (* ok *)
              1 -> m ;
              (if op = gram.realDivExp then realType -> type if);
          if);
       // evalClass.relOp then 
          (Ltype,RType)->evalClass.relMap->m;
          cBoolType->type;
       // evalClass.allRelOp then 
          (Ltype,RType)->evalClass.allRelMap->m;
          cBoolType->type;
       // evalClass.boolOp then 
          (Ltype,RType)->evalClass.boolMap->m;
          cBoolType->type
       // evalClass.modOp then 
          (Ltype,Rtype)->evalClass.modMap->type;
          (if type=0 then 0->m else 1->m if);
       else 0->m
      if);
      (if m 
       // 0 then (EV[],Ltype,Rtype)->BinaryError;
          (* // 1 then  ok*)
       // 2 then (* qua-check *)
          (EV,LE,LChain[],RE, RChain[],false)
            -> QuaCheck(# quaError::(#do (EV,no) -> WE.SemError #)#)
       // 3 // 4 then (* 3: cRep/cChar op rep/ref - never legal;
                       * 4: bool/int is now illegal
                       *)
          (EV[],Ltype,Rtype)->BinaryError;
       (*// 4 then 
          (EV,106)->&WE.Warning;*)
          (*valType -> type - should be handled above *)
      if);
   #)
---xChkLstBody:doPart---
   (* a SLOT/form CANNOT have the same name as the file:
    * i.e. conflict between chkLstBody:dopart and chklstbody.bet
    * IS NOT CHECKED BY COMPILER
    *)
do chk:
     (# LisNested,RisNested: @boolean;
        LCurrent: 
          (# current: ^ASTindex
          do (if Lscan[] <> NONE then
                 Lscan.current[] -> current[];
                 (if current.isNull then
                     LVX[] -> current[]
                 if)
              else
                 Lelm[] -> current[]
             if)
          exit current[]
          #);
        RCurrent: 
          (# current: ^ASTindex
          do (if Rscan[] <> NONE then
                 Rscan.current[] -> current[];
                 (if current.isNull then 
                     RVx[] -> current[];  
                 if)
              else
                 Relm[] -> current[];
             if)
          exit current[]
          #);
        LhasNoNXpart: booleanValue
          (# 
          do (if (Lscan[] <> NONE) then
                 Lscan.hasNoNXpart -> value
             if)
          #);
        RhasNoNXpart: booleanValue
          (# 
          do (if ctst then 
                 223->trace
                 (#do 'RhasNoNXpart: Rscan[]isNone=' ->xT; 
                    Rscan[] = NONE -> xB;
                    (if (Rscan[] <> NONE) then
                        ' Rscan.hasNoNXpart='->xT;
                        Rscan.hasNoNXpart->xB
                    if)
             #)if);
             (if (Rscan[] <> NONE) then
                 Rscan.hasNoNXpart -> value
             if)
          #);
     do (if ctst then    
            221->trace
            (#
            do 'ChkLst:'->xT;
               'Ltype='->xT; Ltype->evalClass.typeString->xT; 
               ' LVx='->xT; LVx[]->xA; 
               ' -> '->xT;
               'Rtype='->xT; Rtype->evalclass.typestring->xT; 
               ' RVx='->xT; RVx[]->xA; 
            #);
        if);
        (if (RVx.label = gram.objectReference)
            and ((RVx.sonRef).label = gram.dynamicItemGeneration) then
            (# RC: ^ActualDesc.DB.SuperChain;
               constructorDesc: ^ASTindex;
               isDefaultConstructor: @boolean
            do (RVx.sonRef,rChain[])
                 -> FindConstructor
                 -> (constructorDesc[],isDefaultConstructor,RC[]);
               (if constructorDesc[] <> none then
                   223->trace(# N: @astindex
                             do 'constructorQ: EV:'->xT;
                                EV[] -> xA;
                                'Lelm: ' -> xT; 
                                Lelm[] -> xA;
                                'ConstructorDesc: ' -> xT;
                                constructorDesc[] -> xA;
                             #);
                   (EV,LVx
                   ,constructorDesc
                   ,Lchain[],RC[],level+1(*?*),Ltype,0(*?*),true) 
                     -> ChkLst;
                   
                leave chk
        if)#)if);


        (if (LType mod 16) 
         // 0 
         // listType
         // VIrefType // VCrefType // VStrucType 
            (* for a ref  we need the actual element in e.g.
             *   f.foo->r[]
             * where foo may exit some s[]. s[] is needed for the 
             * qua-check. Improve on this!
             *)
         // reptype // cRepType 
            (* We need to get the kind and element type
             * @char, ^text, etc. ChkEValBody sets repType
             * for repetitionSlice; and ditto for textConst
             *)
         // primType (* needed for %thiss object *) then
            &|ScanEV[] -> LScan[];
            (LVx,true,Lchain[],true)
              -> LScan
              -> (Lelm,Ltype,Lchain[],LisNested);
         else 
            LVx->Lelm
        if);
        (if Rtype 
         // 0 
         // listType 
         // VIrefType // CIrefType // VCrefType // CCrefTYpe 
         // VStrucType // CStrucType 
         // repType then
            (if RVx.label = gram.dynamicItem then
                (if Rtype <> VIrefType then
                    'ChkLst:inconsistent Rtype'
                      -> thisTranslate.systemException
                if);
                RVx -> Relm
             else
                &|ScanEV[]->RScan[];
                (RVx,NOT isEnter,Rchain[],false)
                  -> RScan
                  -> (Relm,Rtype,Rchain[],RisNested);
                (if ctst then
                    223->trace(#do 'ref/struc/repType='-> xT;
                                 Rtype->evalClass.typeString->xT; 
                                 ' typeKind='->xT; RSCan.typeKind->xI;
                                 RSCan.nxCount-> xI;
                                 RScan.N->xI;
                                 RScan.cstVal->xI;
                                 rscan.isCst -> xB; 
                                 ' elm='->xT; rScan.elm[] -> xA;
                              #)
                if)
            if)
         else 
            RVx->Relm
        if);
        (if ctst then
            222->trace
            (#
            do 'CompKind=' -> xT; compKind -> xI; 
               ' Ltype='->xT; Ltype->evalClass.typeString->xT; 
               ' Lelm='->xT; Lelm[]->xA; 
               ';'->put;
               ' Rtype=' -> xT; Rtype->evalclass.typestring->xT; 
               ' Relm=' -> xT; Relm[]->xA;
            #);
        if);
        
        (if LType
         // listType then  (* only legal for assignCompKind *)
            (if Rtype = repType then
                List2RepAsg
             else
                MatchLists
            if);
            0->typeKind; (* see comment for 0->typeKind below*)
            (* Why do we do the following? 
             * Added and not listError to prevent crash in case
             * of list2 rep error
             *)
            (if (lScan[] <> NONE) and not listError then lScan if);
            (if (rScan[] <> NONE) and not listError then rScan if);
         else (* empty, bool,char,int,real,ref,prim,rep*)
            (if lScan[] <> NONE then lScan if); (* cannot be done at end due to leave*)
            (if rScan[] <> NONE then rScan if);
            (if compKind
             // assignCompKind then (* check assignment *)
                (if ctst then
                    222->trace(#
                              do 'assignMap='->xT;
                                 (Ltype mod 16, RType mod 16) 
                                   -> evalClass.assignMap 
                                   -> xI;
                #)if);           
                (if RType >= 16 then (* cannot assign const*)
                    '?'->put;
                    (if RVx.label = gram.objectReference then
                        (# mn,RptnForm: @integer;
                           RC: ^ActualDesc.DB.SuperChain;
                           constructorDesc: ^ASTindex;
                           S: @ASTindex;
                           isDefaultConstructor: @boolean
                        do '>'->put;
                           RVx.son -> S;
                           (if S.label = gram.dynamicItemGeneration then
                               '!' -> put;
                               (S[],rChain[])
                                 -> FindConstructor
                                 -> (constructorDesc[],isDefaultConstructor
                               ,RC[]);
                               (if constructorDesc[] <> none then
                                   223->trace(#
                                             do 'constructor: EV:'->xT;
                                                EV[] -> xA;
                                                'Lelm: ' -> xT; 
                                                Lelm[] -> xA;
                                                'ConstructorDesc: ' -> xT;
                                                constructorDesc[] -> xA
                                             #);
                                   (EV,Lelm,constructorDesc,Lchain[],RC[],level+1(*?*),Ltype,0(*?*),true) 
                                     -> ChkLst;
                                       
                                   leave chk
                    if)if)#)if);
                            
                    (EVx[],false,Lcurrent,Rcurrent,level
                    ,LisNested,RisNested
                    ,LhasNoNXpart,RhasNoNXpart) 
                      -> DynAsgError
                    (#
                    do '\n   since "' -> XTl;
                       Rcurrent -> XA;
                       '" is a constant, literal or expression' -> XT
                    #)
                 else               
                    (* assignMap may return an action-code: 
                     *    quaCheck, cChar->ref/rep, etc.
                     * The typeKind of assignment is always Rtype!
                     *)
                    (if ((Ltype mod 16, RType mod 16) 
                          ->evalClass.assignMap)
                     // 1 then (* ok*)
                        0 (*RType*)->typeKind; 
                        (* RType is the Ntype of R, we must have the exit type;
                         * Is only relevant in cases like
                         *   ((a,b)->foo, and bar)->fisk
                         * In normal assignments cmpLst is called independet
                         * of the type.
                         * Optimizations are, however, possible here
                         *)
                        leave chk;
                     // 2 then
                        (EVx,Lelm.son,Lchain[],Relm.son,Rchain[],true)
                          -> QuaCheck
                        (# quaError::
                             (# Le,Re: @ASTindex
                             do Lelm.father -> Le; Relm.father->Re;
                                (if no
                                 // -1 // 20 then
                                    (EV[],false,Le[],Re[],level
                                    ,LisNested,RisNested
                                    ,LhasNoNXpart,RhasNoNXpart) 
                                      -> DynAsgError
                                    (#
                                    do (if no
                                        // -1 then '\n   since "' -> XTl;
                                           Le[] -> XA;
                                           '" is a reference to a basic pattern'->XT
                                        // 20 then
                                           '\n   due to incompatiple qualifications' -> XTl
                                       if)
                                    #);
                                    
                                 else
                                    (EV,no) -> WE.SemError
                                if)
                             #)
                        #);
                        0->typeKind;
                        leave chk;
                     // 3 then
                        (if LType // cRepType // cCharType then
                            (if RType
                             // repType then (* 'fisk'/'a'->R, R: [e]@char *)
                             // VIRefType then (* 'fisk'/'a'->S[]; S: ^text *)
                                (EVx,Relm,Rchain[])->ChkTxtCstToTxtRef
                             else (EVx[],Ltype,Rtype)->AssignError
                            if)
                         else (EVx[],Ltype,Rtype)->AssignError
                        if);
                        0->typeKind;
                        leave chk;
                     // 5 // 6 // 7 // 8  then
                        (* To handle: (1,2,3) -> aRep *)
                        Relm -> GetRepElmType
                        (# error:: 
                             (#do (RVx[],false,false) -> list2repError #)
                        #)
                          -> Rtype;
                        (if ctst then
                            223->trace
                            (#
                            do 'ToRep: '->xT; 
                               Ltype->evalClass.typeString->xT; 
                               Lelm[]->xA; 
                               ';'->put;
                               Rtype->evalclass.typestring->xT; 
                               Relm[]->xA;
                            #)
                        if);
                        (EV,Lelm,Relm,Lchain[],Rchain[],level+1,Ltype,Rtype,false)
                          -> ChkLst
                     // 11 then
                        (* Lelm = aRef[] -> aRep where aRep: [e] ^ aRefType;
                         * We assume aRef = (some att denotation)
                         * We must pass aRef = (ref ... )
                         *)
                        Lelm.father -> Lelm;
                        List2RepAsg
                     // 9 then (* rep -> rep *)
                        (Lelm[],Relm[],lChain[],rChain[],true,level) 
                          -> Rep2RepAsg
                     // 10 then
                        (* R1[] -> R2[] where R1,R2: [...] ... *)
                        (if ctst then 221->trace(# do 'AsgRep:' -> xT; #)if);
                        (Lelm[],Relm[],lChain[],rChain[],false,level) 
                          -> Rep2RepAsg

                     // 4 (* bool/int -> int/bool *) 
                     // 0 then
                        (if ctst then
                            221-> trace
                            (#
                            do 'Level: ' ->xT; level -> xI; LisNested->xB;
                               RisNested -> xB
                        #)if);
                        (if Rtype = listType then
                            (true,8) -> LstErr;
                         else
                            (# mn,RptnForm: @integer;
                               RC: ^ActualDesc.DB.SuperChain;
                               constructorDesc: ^ASTindex;
                               S: @ASTindex;
                               isDefaultConstructor: @boolean
                            do 
                               222->trace(#
                                         do 'DynAsgErr: '->xT;
                                            100 -> switchon;
                                            RVx[] -> xA;
                                            100 -> switchoff
                                         #);
                            (if RVx.label = gram.dynamicItemGeneration then
                                (RVx[],rChain[])
                                  -> FindConstructor
                                  -> (constructorDesc[],isDefaultConstructor,RC[]);
                                (if constructorDesc[] <> none then
                                    223->trace(# N: @astindex
                                              do 'constructor: EV:'->xT;
                                                 EV[] -> xA;
                                                 'Lelm: ' -> xT; 
                                                 Lelm[] -> xA;
                                                 'ConstructorDesc: '-> xT;
                                                 constructorDesc[] -> xA;
                                              #);
                                    
                                    (EV,LVx
                                    ,constructorDesc
                                    ,Lchain[],RC[],level+1(*?*)
                                    ,Ltype,0(*?*),true) 
                                      -> ChkLst;
                                    
                                   leave chk
                            if)if)#);
                            (EVx[],false,Lcurrent,Rcurrent,level
                            ,LisNested,RisNested
                            ,LhasNoNXpart,RhasNoNXpart) 
                              -> DynAsgError
                        if)
                    if);
                if)
             // BinaryCompKind then
                (EVx[],Lelm[],LType,LChain[],Relm[],Rtype,RChain[])
                  -> ChkBinOpTypes 
                  -> typeKind;
                    (*222->trace(#do 'BinOp:'->xT; typeKind->evalClass.typeString->xT #);*)
                leave chk
             // UnaryCompKind then 
                (if EVX.label
                 // gram.indexed // gram.simpleIndex // gram.namedIndex then
                    (* R[e], R: [e]...; (for i: e repeat ... for) *)
                    (if Rtype mod 16
                     // valType // charType // primType then (*OK*)
                     else
                        (EVx,38)->&WE.SemError; true->ListError
                    if)
                 //gram.simpleIfImp then
                    (if not (((RType mod 16) =  boolType) 
                        or ((Rtype mod 16) = primType)) then
                        (LVx,91)->&WE.SemError; true->ListError
                    if)
                 // gram.unaryMinusExp // gram.unaryPlusExp then
                    (if Rtype mod 16
                     // valType// charType// realType // primType then (*ok*)
                     else  (EVx,22) -> &WE.SemError; true->ListError
                    if)
                 // gram.notExp then
                    (if not (((Rtype mod 16 ) = boolType) 
                        or ((Rtype mod 16) = primType)) then
                        (if (RType mod 16) = valType then
                            (EV,106)->&WE.Warning
                         else
                            (EVx,22) -> &WE.SemError; true->ListError
                        if)
                if)if);
                Rtype->typeKind  
            if);
        if);
        (if ListError then
            lScan[]->ClearList;
            rScan[]->ClearList;
         else
            none->LScan[]->RScan[]
        if);
        
     #)
