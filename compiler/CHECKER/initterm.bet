ORIGIN 'check' 
---InitBasicDescs:doPart---
   (* To handle int8, ... int64u;
    * NOT FINISHED!
    * Unsigned must be marked in the descriptor. Now: -1 -> D.attSize
    * Codegenerator must be adjusted to handle a sign.
    * Adresss has been added an signed: @boolean; 
    * ldByte and lfHalf msut check if op1.signed; this has been
    * done in SUN4Bmachine. Until other machines are fixed
    * int8 and int16 will behave like int8u/int16u, ie. as char/shortInt.
    * All operations must be added sign/unsigned; currently only ldByte
    * and ldHalf handles this. add, shift, etc are NOT handled, and this may
    * take some time.
    * Type checking must be reconsidered.
    * Finally: the strategy below implies that it is NOT necessary to store
    * standard descriptors in the AST. 
    * They are re-initialized with each compilation.
    *)
do base.father -> base; base.father -> base;
   base -> AST.scanList
   (# dcl,names,d: @AST.index;
      StandardMark:
        (# d: @AST.Index; descKind,type,K: @integer
        enter(d,descKind,type)
        do (@@K,descKind) ->TOS'%putByte[0]'; 
           (@@K,type)->TOS'%putBits[27,5]';
           K->d.kind
        #);
      
   do currentNode -> dcl; 
      (if dcl.label = gram.unExpanded then
       else
          dcl.son -> names -> AST.scanList
          (# name: @AST.index
          do currentNode -> name;
             (if true
              // 'int8' -> name.textEQ then
                 names.brother -> int8Desc;
                 1 -> int8Desc.size; 0 -> int8Desc.attSize;
                 (int8Desc,standardKind,valType)->standardMark;
              // 'int8u' -> name.textEQ then
                 names.brother -> int8uDesc;
                 1 -> int8uDesc.size; -1 -> int8uDesc.attSize;
                 (int8uDesc,standardKind,valType)->standardMark;
              // 'int16' -> name.textEQ then
                 names.brother -> int16Desc;
                 2 -> int16Desc.size; 0 -> int16Desc.attSize;
                 (int16Desc,standardKind,valType)->standardMark;
              // 'int16u' -> name.textEQ then
                 names.brother -> int16uDesc;
                 2 -> int16uDesc.size; -1 -> int16uDesc.attSize;
                 (int16uDesc,standardKind,valType)->standardMark;
              // 'shortInt'->name.textEQ then
                 names.brother-> shortDesc; 
                 2->shortDesc.size; -1 -> shortDesc.attSize;
                 (shortDesc,standardKind,valType)->standardMark;
              // 'int32' -> name.textEQ then
                 names.brother -> int32Desc;
                 4 -> int32Desc.size; 0 -> int32Desc.attSize;
                 (int32Desc,standardKind,valType)->standardMark;
              // 'int32u' -> name.textEQ then
                 names.brother -> int32uDesc;
                 4 -> int32uDesc.size; -1 -> int32uDesc.attSize;
                 (int32uDesc,standardKind,valType)->standardMark;
              // 'int64' -> name.textEQ then
                 names.brother -> int64Desc;
                 8 -> int64Desc.size; 0 -> int64Desc.attSize;
                 (int64Desc,standardKind,valType)->standardMark;
              // 'int64u' -> name.textEQ then
                 names.brother -> int64uDesc;
                 8 -> int64uDesc.size; -1 -> int64uDesc.attSize;
                 (int64uDesc,standardKind,valType)->standardMark;
             if)                      
          #)
      if)
   #)
   
---InitWithoutCheck:descriptor---
(# setType:
     (# d: ^ast.index; type,k: @integer
     enter(d[],type)
     do d.kind->K;
        (@@K,type)->TOS'%putBits[27,5]';
        K->d.kind
     #);
   node: @AST.index
     
do (if not hasOrigin then (* BetaEnv *)
       (* Restore standard descriptors and error name *)
       theGroup.Scan
       (# FF: ^AST.FragmentForm; sysDesc: @AST.Index
       do current[]->FF[]; FF.theGSForm->sysDesc;
          18->sysDesc.getSysAtt->SemAtt.dataDesc;
          17->sysDesc.getSysAtt->Sematt.byteDesc;
          16->sysDesc.getSysAtt->Sematt.textDesc;
          15->sysDesc.getSysAtt->Sematt.repDesc;
          14->sysDesc.getSysAtt->Sematt.shortDesc;
          13->sysDesc.getSysAtt->Sematt.boolDesc;
          12->sysDesc.getSysAtt->Sematt.realDesc;
          11->sysDesc.getSysAtt->Sematt.cStrucDesc;
          10->sysDesc.getSysAtt->Sematt.charDesc;
          9->sysDesc.getSysAtt->Sematt.SuperObject;
          8->sysDesc.getSysAtt->Sematt.CprocDesc; 
          7->sysDesc.getSysAtt->Sematt.Errorname; 
          6->sysDesc.getSysatt->Sematt.integerDesc;
          5->sysDesc.getSysAtt->Sematt.TrueDesc;
          4->sysDesc.getSysAtt->SemAtt.FalseDesc;
       #);
       Sematt.DumpStd;
       (* temporary stuff needed to be compatible with betaenv/tstenv 
        * that has NOT been compiled with this version of the compiler.
        *)
       boolDesc -> InitBasicDescs;
       
       (charDesc[],charType)->setType;
       (shortDesc[],valType)->setType;
       (boolDesc[],boolType)->setType;
       (realDesc[],realType)->setType;
       (integerDesc[],valType)->setType;
       (falseDesc[],cBoolType)->setType;
       (trueDesc[],cBoolType)->setType;

   if)
#)
----------------------InitTerm:descriptor---------------------
(# SlotError:
     (# node: @AST.index; D: ^AST.slotDesc; U: ^AST.unExpanded
     enter node
     do (node,47)->&SemError;
        (* transform unExpanded node into slot-node *)
        (* node.a ->U[];
         * node.f->AST.grammarTable.BETA.newSlot->D[]->U.theSlot;
         * '***ERROR***'->D.name;
         *)
        true->fatalInitTermError
     #);
   textApl: @AST.index;
   InitStd: 
     (*******************************************)
     (* initialization of standard declarations *)
   (# standardMark:
        (# d: @AST.Index; descKind,type,K: @integer
        enter(d,descKind,type)
        do (@@K,descKind) ->TOS'%putByte[0]'; 
           (@@K,type)->TOS'%putBits[27,5]';
           K->d.kind
        #);
      sysDesc,desc,att: @AST.index;
      theGroup: ^AST.FragmentGroup 
   enter(theGroup[],sysDesc) (* sysDesc = (system <desc> ) *)
   do (if verboseLevel<verboseLevel.actions then
          '!'->infostream.put;
      if);
          (*132->trace(#do 'InitStd:'->T; sysDesc[]->A #);*)
      sysDesc.son->desc;desc.son->att;att.brother->att;(*main-p*) att.son->att;
          (*132->trace(#do 'InitStd:att:'->T; att[]->A #);*)
      att->AST.scanList
      (# dcl,names,d: @ AST.index;
      do currentNode->dcl; (* dcl = (xxDecl <names> <spec> ) *)
         (*132->trace(#do 'InitStd:'->T; dcl[]->A #);*)
         (if dcl.label//gram.unExpanded then
             (if not dcl.isSlot then dcl->slotError if)
          else
             dcl.son->names->AST.scanList
             (# name : @ AST.index;
                ifhack:
                  (#
                  do (if true
                      // ('shortInt'->name.textEQ) then
                         names.brother->d; 2->d.size; 
                         0->d.attSize; d->shortDesc; 
                       (d,standardKind,valType)->standardMark;
                      // ('errorName'->name.textEQ) then
                         name->errorName; 
                      // ('External'->name.textEQ) then
                         (# kind: @integer
                         do names.brother->d->cProcDesc; 
                            (*common.standard*)4(*???*)->cProcDesc.size;
                            (d,standardKind,0)->standardMark;
                            (* set hasInner = true *)
                            d.kind->kind;
                            (@@kind,true)->TOS'%putBits[12,1]';(*hasinner*)
                            (@@kind,true)->TOS'%putBits[17,1]';(*onlyinner*)
                            kind->d.kind
                         #)
                      // ('cStruc'->name.textEQ) 
                      // ('cStruct'->name.textEQ) then
                         names.brother->d->cStrucDesc;
                         (*(d,standardKind,0)->standardMark; 
                          common.standard->cStrucDesc.size;*)
                      // ('Object'->name.textEQ) then
                         names.brother->superObject
                      // ('Repetition'->name.textEQ) then
                         names.brother->repDesc; 
                      // ('real'->name.textEQ) then
                         names.brother->d->realDesc; 
                         8->d.size;
                         (d,standardKind,realType)->standardMark 
                      // 'data'->name.textEQ then
                         names.brother->dataDesc;
                         0->dataDesc.size->dataDesc.attSize;
                         (dataDesc,dataKind,0)->standardMark;
                         (* hack to handle TOS'%..' *)
                     if)
                  #);
             do currentNode->name;
                (if name.label // gram.nameDcl then
                    (if true
                     // ('text'->name.textEQ)  then
                        name->textApl;
                        names.brother->d->textDesc;
                     // ('char'->name.textEQ)  then
                        names.brother->d->charDesc;
                        1->d.size;
                        (d,standardKind,charType)->standardMark;
                        -1 -> d.attSize; (* unsigned *)
                     // ('boolean'->name.textEQ) then
                        names.brother->d->boolDesc;
                        1->d.size;
                        (d,standardKind,boolType)->standardMark;
                        0->d.attSize; 
                     // ('false'->name.textEQ) then
                        names.brother->d; (*common.standard*)4->d.size;
                        (d,constKind,cBoolType)->standardMark;
                        0->d.attSize; d->falseDesc; 
                     // ('true'->name.textEQ) then
                        names.brother->d; (*common.standard*)4->d.size;
                        (d,constKind,cBoolType)->standardMark;
                        1->d.attSize; d->trueDesc; 
                     // ('integer'->name.textEQ) then
                        names.brother->d; (*common.standard*)4->d.size;
                        (d,standardKind,valType)->standardMark;
                        0->d.attSize; d->integerDesc; 
                     else (* this else part is due to offset problems
                           * on the  HP snake. Must be fixed
                           *)
                        &ifhack;
      if)if)#)if)#);

      (4,falseDesc)->sysDesc.PutSysAtt; (5,TrueDesc)->sysDesc.PutSysAtt;
      (6,integerDesc)->sysDesc.PutSysAtt; (7,errorName)->sysDesc.PutSysAtt;
      (8,CprocDesc)->sysDesc.PutSysAtt; (9,superObject)->sysDesc.PutSysAtt;
      (10,charDesc)->sysDesc.PutSysAtt; (11,cStrucDesc)->sysDesc.PutSysAtt;
      (12,realDesc)->sysDesc.PutSysAtt; (13,boolDesc)->sysDesc.PutSysAtt;
      (14,shortDesc)->sysDesc.PutSysAtt; (15,repDesc)->sysDesc.putSysAtt;
      (16,textDesc)->sysDesc.putSysAtt; (17,byteDesc)->sysDesc.putSysAtt;
      (18,dataDesc)->sysDesc.putSysAtt;
      boolDesc -> InitBasicDescs;
      dumpStd
   #);
   
   
   InitBrothers:
     (# node,origin: @ AST.index
     enter(node,origin)
     do L: (if not node.isNull  then
               (node,origin)->&Init;
               node.brother->node;
               restart L
     if)#);
   CollectDecl: 
     (# desc,att,root,libRoot: @ AST.index; ind: @integer;
        PrintDcl:
          (# R: @AST.index
          enter R
          do (for ind repeat ' '->Lst.put for);
             (if not R.isNULL then
                 R.getText->Lst.Puttext; lst.newline;
                 ind+1->ind;
                 R.Left->&PrintDcl;
                 R.Right->&PrintDcl;
                 ind-1->ind
              else '.'->lst.put; lst.newline
             if);
          #);
        PrintLib:
          (# L,N: @AST.index
          enter L
          do (if not L.isNull then
                 'Include '->lst.PutText;
                 L.son->N; N.gettext->lst.Puttext; lst.newline;
                 L.Next->&PrintLib
          if)#);
        son1,n: @AST.index
     enter(desc,att)
     do (if not wasChanged then
            (*****  NOTE term being re-checked.
             * In this case the else part is NOT executed !!!
             *)
            (att,desc)->&Init (* normal scan of attributes *)
         else
            AST.null->LibRoot; 
            att->AST.scanList
            (# dcl: @AST.index; (* dcl=SORT[NL,T] *)
            do currentNode->dcl; dcl.ClearError;
               (if dcl.label = gram.unExpanded then
                   (if dcl.isSlot then 
                       (dcl,desc)->&Init;
                       (if libRoot.isNull then dcl->libRoot
                        else libRoot->dcl.next; dcl->libRoot 
                       if)
                    else
                       dcl->slotError 
                   if)
                else
                   dcl.son->son1;
                   (if dcl.label
                    // gram.bindingDecl // gram.finalDecl then 
                       (dcl[],desc)->&InitBinding
                    // gram.repetitionDecl then (* repetition[NL INDEX SPEC] *)
                       dcl.son->n; (dcl,n.brother,desc)->&initSemi
                    else
                       (son1.brother,desc)->&InitBrothers
                   if);
                   son1->AST.scanList
                   (# name: @AST.index; (* nameDcl *)
                   do currentNode->name; dcl->name.sort;
                      AST.null->name.left->name.right;
                      (if root.isNull then name->Root
                       else 
                          (root,name)
                            -> Find
                          (# left:: (#do name->father.left #);
                             right:: (#do name->father.right #);
                          do name.ClearError; (* in case of re-check *)
                             (name,1)->&SemError 
                          #)
            if)#)if)#);
            Root->desc.DclRoot; libRoot->desc.lib;
        if);
        (*(if switch[131] //then
         '------'->lst.puttext; lst.newline;
         root-> &PrintDcl; libRoot->&PrintLib if)*)
     #);
   InitBinding:
     (* node = (bindingDecl <name> <BS> ) 
      |  test for a declaration of the form
      |  B ::< (# ... #)
      |  where a prefix with name empty string is added.
      |  dclRef of empty name is NULL and
      |  declRef of empty Name refers to B   *)
     (# node: ^AST.index; origin,B,BS,BSpre,BsPn: @AST.index
     enter(node[],origin)
     do node.son->B; B.brother->BS; B->singleName->B;
        B.ClearError;
        AST.null->B.virtDcl; (BS,origin)->&Init; (* init. whole desc *)
        (*132->trace(#do 'initT'->T; node[]->A #);*)
        (if BS.label // gram.objectDescriptor then
            BS.son->BSpre;
            (if BSpre.label // gram.empty then
                BS->AST.addPrefix->BsPn; node->BsPn.descRef;
                origin->BsPn.origin; AST.null->BsPn.dclRef;
             else BSpre.son->BsPn; BsPn->GetName->BsPn;
                (if BsPn.stringLength//0 then
                    (* the dummy prefix was added by controlfragment
                     * before compaction of AST*)
                    node->BsPn.descRef; 
                    origin->BsPn.origin; AST.null->BsPn.dclRef
                 else (*normal  prefix, initialized by init above*)
                    (*AST.null->BsPn.descRef*)  if)
            if);
            (*origin->BsPn.origin; AST.null->BsPn.dclRef;*)
        if)
     #);
   InitSemi: 
     (# semi,index,origin: @ AST.index;
     enter(semi,index,origin)
     do (*133->trace(#do index[]->A #);*)
        (if index.label// gram.namedIndex then
            origin->semi.origin; semi->origin;
            index.son->index; semi->index.sort
        if);
        (semi.son,origin)->&initBrothers
     #);
   Init: 
     (* recursive traversal of the AST *)
     (# node,origin: @ AST.index;
        InitDesc:
          (#
             tMode: @
               (# V: @integer;
                  init: (#do 0->V #);
                  addN: (#do V+1->V #);
                  addD: (#do V+2->V #);
                  addX: (#do V+4->V #)
               exit V
               #);
             DescSonsRef:
               (*** NOTe: this pattern is similar to the one in sematt except
                * that here it is also tested if an unexpanded is in fac
                * a slot
                *)
               (# desc: ^AST.index; pre,mainP,att,enterP,doP,exitP: @AST.index
               enter desc[]
               do desc.son -> pre;  
                  pre.brother -> mainP; (* main-part*) 
                  (if mainP.label//gram.unExpanded then
                      (if not mainP.isSlot then mainP->slotError if);
                      integerDesc.son->att; att.brother->att; att.son->att
                      (* this is a bloody hack in order to make sure that
                       * att, etc. are NOT AST.null but gram.empty 
                       *)                      
                   else mainP.son->att; (* attribute-part *)
                  if);
                  att.brother->enterP; (* actionPart *)
                  enterP.son->enterP;  (* enter Part*)
                  enterP.brother->doP;     (* doPart *)
                  doP.brother->exitP;     (* exitPart *)
                  (if (doP.label<>gram.empty)  then
                      (if doP.label = gram.unExpanded then
                          (if not doP.isSlot then doP->slotError if)
                       else
                          doP.son->doP (* impList of doPart *)
                  if)if)
               exit(pre[],mainP[],att[],enterP[],doP[],exitP[])
               #);
             mp: @ AST.index
          do level+1->level;
             node[]->DescSonsRef->(pref[],mainP[],att[],enterP[],doP[],exitP[]);
             (* hack to handle T<<SLOT A:mainPart>> *)
             node.son->mp; mp.brother->mp;
             (if mp.isSlot then (mp,node)->&init if);
             (FF.fragNode,descNo + 1->descNo)->node.descId;
             (if (node->DescKind)//standardKind//constKind then (*skip*)
              //dataKind then
                 (* FIX 8/3/95: for a fragment not being parsed,
                  * descKind will not be cleared. This implies that
                  * such data descriptor will not be rechecked.
                  * It is only pattern 'data' that should not have
                  * its kind set to undefined
                  *)
                 (if not (node->dataDesc.equal) then
                     0->node.attSize;
                     0->node.kind
                 if)
              else 
                 0->node.attSize;
                 0->node.kind; (* see also standardMark *)
                 (* kind=0 represents sematt.unDefined *)
             if);
             (**** preliminary change ****)
             origin->node.origin;
             (if pref.label//gram.prefix then
                 pref.clearError;
                 (* origin of a prefix nameApl is origin of the descriptor *)
                 (pref.son,origin)->&InitBrothers
              // gram.unexpanded then pref->slotError
             if);
             tMode.init;
             (node,att)->&collectDecl;
             (if (enterP.label<>gram.empty)  then
                 (if enterP.label = gram.unexpanded then enterP->SlotError 
                  else 
                     tMode.addN; (enterP.son,node)->&Init
             if)if);
             (if (doP.label<>gram.empty)  then
                 tMode.addD; (doP,node)->&Init
             if);
             (if (exitP.label<>gram.empty)  then
                 (if exitP.label = gram.unexpanded then exitP->SlotError 
                  else
                     tMode.addX; (exitP.son,node)->&Init
             if)if);
             (*            tMode->node.kind*)
             level-1->level;
          #);
        InitLabelSemi: 
          (# node,origin,labelDcl: @ AST.index
          enter(node,origin)
          do node.son->labelDcl; node->labelDcl.sort;
             origin->node.origin;
             (labelDcl,node)->& initBrothers
          #);
        pref,mainP,att,enterP,doP,exitP: ^ AST.index; n: @AST.index
     enter(node,origin)
     do (if not node.isNull then
            (*132->trace(#do level->I; hasTmpSto->I; node[]->A #);*)
            node.ClearError;
            (* 0->node.ErrInx;*) (* in case of recheck *)
            (if node.Label
             // gram.nameApl then
                origin->node.origin; AST.null->node.dclRef->node.descRef
                (* note that origin shares space with on !!!! *)
             // gram.objectDescriptor then &InitDesc
             // gram.forImp then (* forImp[INDEX IMP+;] *)
                (if level//0 then true->hasTmpSto if);
                (node,node.son,origin)->&initSemi
             // gram.labelledImp then (* (label (nameDcl> <imp*;>)) *)
                (if level//0 then true->hasTmpSto if);
                (node,origin)->&initLabelSemi
             // gram.bindingDecl//gram.finalDecl then 
                (node[],origin)->&InitBinding
             // gram.repetitionDecl then (* repetition[NL INDEX SPEC] *)
                node.son->n; (node,n.brother,origin)->&initSemi
             // gram.textConst // gram.integerConst 
             // gram.codeConst // gram.codeString // gram.empty then (*skip*)
             // gram.nameDcl then (* skip *)
             // gram.unexpanded then
                (if node.isSlot then
                    (*132->trace(#do node[]->A #);*)
                    origin->node.slotOrigin
                 else node->SlotError 
                if)
             else
                (if node.nodeClass
                 // AST.kinds.cons then (node.son,origin)->&InitBrothers;
                 // AST.kinds.list then
                    node->AST.scanList(#do (currentNode,origin)->&Init #)
                 // AST.kinds.dummy then (node.son,origin)->&Init
                 else
                if)
     if)if)#);(* Init *)
   
   sysForm,formDesc: @AST.Index; (* the descriptor of F *)
   origin,pref: @AST.index; OP: ^AST.SlotDesc; initialEnv: @boolean;
   level: @integer; (* level no. of nested descriptors *)
   hasTmpSto    (* true if tmp. sto. need for doPart-form.
                 * Will be true if for-imp and/or labelled-imp at out-level
                 * of doPart-form. 
                 *)
   ,doPw,mainPw: @boolean;
   
   OriginError:
     (# n: @integer 
     enter n
     do '\n\n*** The fragment\n\t'->messagestream.puttext; 
        theGroup.fullName->messagestream.puttext;
        '\n\thas NO ORIGIN!\n\t'->messagestream.puttext;
        'All fragments except ''betaenv'' must have an ORIGIN'
          ->messagestream.putText;
        (for i: n repeat '!'->messageStream.put for);
        messageStream.putLine;
        (theGroup[],11)->msg;
     #)
do FF.theGSForm->sysForm; 
   0->sysForm.descNo; 
   (* descNo contains the index of the search cash
    * for this form; must be zero initially *)
   
   (* sysForm= (objectDescriptor <desc> )
    *        | (AttributesForm <att_dcl+;> )
    *   | (doPart <impList*;> )
    *)
        (*132->trace(#do sysForm[]->A #);*)
   (if (FF.binding[]->OP[]) // NONE (* bad condition to test *) then
       (if sematt.integerDesc.isNull and sematt.superObject.isNull
        //false then 
           (* if integerDesc or suporObject are not null, then
            * betaenv/tstenv has already been defined
            *)
           1->originError
        else
           (if sysForm.label//gram.objectDescriptor//gram.descriptorForm then
               (theGroup[],sysForm)->&InitSTD;
               true->initialEnv;
               (* Check that this was in fact betaenv or tstenv.
                * This is done by checking that pattern integer and
                * pattern object have been defined. In principle
                * one should check that all basic patterns have been defined.
                *)
               (if sematt.integerDesc.isNull or sematt.superObject.isNull
                   then 2->originError
               if)
            else
               3->originError
       if)if);
    else
       OP.node->origin; (* a SLOT *)
       (*origin.slotOrigin->origin*) (* origin of SLOT *)
   if);
   
   (* descNo,libDescNo: For each descriptorFrom descNo must
    be initialised to zero. I.e within each descriptor, the descriptors
    are numbered sequentially starting with 1.
    For attribute forms, all the descriptors must be numbered sequentially
    starting with 1.
    *)
   origin->sysForm.xOrigin;(* reference to fragment origin *)
   (if sysForm.label 
    // gram.descriptorForm then
       sysForm.son->formDesc; formDesc.son->pref;
       (if pref.label//gram.prefix then
           (*132->trace(#do 'Formdesc has prefix:'->T #);*)
           1->descNo
        else 0->descNo
       if); 
       (formDesc,sysForm)->&Init;
       (if initialEnv then
           (# N: @AST.index; T: ^text
           do
              (* the cProcDesc has the form:
               * external: (#...,externalEntry,...:@text...#)
               * the nameApl text MUST appear as if it has 
               * been checked.
               *)
              cProcDesc->N;
              N.son->N; N.brother->N; N.son->N; (* attributes *)
              N->AST.scanList(# do currentNode->N #);
              (if N.isNull then
                  '\n\n!! Warning: problem with pattern ''external'''->messagestream.putline
               else
                  (if N.label//gram.simpleDecl then
                      N.son->N; N.brother->N; N.son->N;
                      (* N=attributeDenotation=nameApl *)
                      N.getText->T[];
                      (if 'text'->T.equalNCS then
                          1->N.on; 
                          textApl->N.dclRef;
                          textDesc->N.descRef
                  if)if)
              if);
           #)
       if);
       (formDesc[],common.itemKind,0,NONE)->DS.put; 
       (* kind,cons are not correct: the compiler seems to assume
        * that kind>0 implies singular?
        *)
    // gram.attributesForm then
       attDescNo->descNo;
       (sysForm,sysForm.son)->&CollectDecl;
       sysForm->formDesc;
       descNo->attDescNo;
       (formDesc[],0,0,NONE)->DS.put; (* kind,cons are not correct *)
    // gram.doPart then
       (if not doPw then
           (if not switch[44] then
               (*messagestream.newline;
                'WARNING! "DoPart" slots are not implemented!'->messagestream.putline*)
           if);
           true->doPW
       if);
       0->level; false->hasTmpSto;
       0->descNo; sysForm->formDesc;
       (formDesc(*node*),sysForm)->&Init;
       (if hasTmpSto then
           1->formDesc.descNo; 
           (*135->trace(#do 'TmpSto needed:'->T; formDesc[]->A #)*)
       if);
       (formDesc[],formDesc[](*?*))->DS.putDo; (* kind,cons are not correct *)
    // gram.mainPart then
       (*
        (if mainPw//false then
        (if switch[44]//false then
        messagestream.newline;
        'WARNING! "MainPart" slots are not implemented!'->messagestream.putline;
        if);
        true->mainPW
        if);*)
       0->descNo; sysForm->formDesc;
       (* Note: part of initDesc must be called here, since
        * collectDcl, etc MUST be called. InitDesc mus, however, be
        * adjusted to handle a main-part and not just a descriptor;
        * apparently some of this is done, but names declared in a mainpart
        * are NOT visible? No: the mainpart handling in InitDesc is just
        * to decode T<<SLOT A: mainPart>>
        *)
       (formDesc(*node*),sysForm)->&Init;
       (formDesc[],sysForm[](*?*))->DS.putDo; (* kind,cons are not correct *)
   if);
   
#)
