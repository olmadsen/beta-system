 ORIGIN 'checkerdopart' ;
LIB_ITEM 'betacompiler';
INCLUDE '~beta/betaast/scanBetaText';
INCLUDE 'checklib';
BODY 'chklstbody'
 ----- CmpLstBody: descriptor ----
(* switch[221:250] *)
(* 221: chkLst     *)
(* 222:            *)
(* 223:            
 * 225: chkTxtCstToTxtRef, to be eliminated 
 *)
(# <<SLOT chkLstLib: attributes>>;
   ListError: @boolean;
   CmpError:
     (# EV: ^ASTindex; Ltype,Rtype: @integer;
        EV1,EV2: @ASTindex
     enter(EV[],Ltype,Rtype)
     do (*newline; Ltype->evalClass.typestring->puttext;
         ' '->put; RTYpe->evalClass.typestring->puttext;*)
        INNER;            
        true->listError
     #);
   OpError: CmpError
     (# 
     do inner
     #);
   opString:
     (# op: ^ASTindex; T: @text
     enter op[]
     do (if op.label
         // gram.eqExp      then '"="'   -> T
         // gram.neExp      then '"<>"'  -> T
         // gram.leExp      then '"<="'   -> T
         // gram.ltExp      then '"<"'   -> T
         // gram.geExp      then '">="'   -> T
         // gram.gtExp      then '">"'   -> T
         // gram.plusExp    then '"+"'   -> T
         // gram.minusExp   then '"-"'   -> T
         // gram.orExp      then '"or"'  -> T
         // gram.xorExp     then '"xor"' -> T
         // gram.timesExp   then '"*"'   -> T
         // gram.realDivExp then '"/"'   -> T
         // gram.intDivExp  then '"div"' -> T
         // gram.modExp     then '"mod"' -> T
         // gram.andExp     then '"and"' -> T            
         else
            '"???"' -> T
        if)
     exit T[]
     #);
            
   BinaryError: OpError
     (#
     do (if (EV.label->evalClass) = evalClass.binOp then
            (EV[],false) -> WE.MakeError
            (#
            do EV.son->EV1; EV1.brother->EV2;
               'In "'->XT; 
               EV[]-> XA; 
               '", the operator ' -> XT;
               EV[] -> opString -> XTl;
               ' cannot be applied to\n      the ' -> XTl;
               Ltype->evalClass.typestring -> XTl;
               '-evaluation "' -> XTl;
               EV1[] -> XA;
               '" and \n      the ' -> XT;
               Rtype->evalClass.typestring -> XTl;
               '-evaluation "'->XTl;
               EV2[] -> XA;
               '"'-> XT
        #)if)
     #);
   (*UnaryError: OpError
     (#
     do (EV,103)->&WE.SemError
     #);*)
   AssignError: CmpError
     (#
     do (if RType >= 16 then (EV,105)->&WE.SemError
         else (EV,104)->&WE.SemError
        if)
     #);
   DynAsgError: WE.MakeError
     (# Lelm,Relm: ^ASTindex; level: @integer;
        LisNested,RisNested,inExit,inEnter,LhasNoExit,RhasNoEnter: @boolean
     enter(Lelm[],Relm[],level,LisNested,RisNested,LhasNoExit,RhasNoEnter)
     do (if ctst then
            221 -> trace(#do 'DynAsgError:'->xT; 
                           level -> xI; 
                           LisNested -> xB;
                           RisNested -> xB
                        #)
        if);
        (level > 1) or LisNested  -> inExit;
        (level > 1) or RisNested -> inEnter;

        'In "' -> XT;
        EV[]-> xA;
        '", '-> XT;
        (if inExit then '\n   "' -> XTl
         else '"' -> XTl
        if);
        Lelm[]-> XA;
        '"' -> XT;
        (if LhasNoExit then
            ', which has no exit-part\n  ' -> XTL
         else
            (if inExit then 
                ' in the exit-part of the left-side\n  ' -> XTl;
        if)if);
        ' cannot be assigned to: ' -> xTl;
        (if inEnter then '\n   "' -> XTl
         else '"' -> XTl
        if);
        Relm[] -> XA;
        '"' -> XT;
        (if RhasNoEnter then
            ', which has no enter-part' -> XTL
         else
            (if inEnter then
                ' in the enter-part of the right-side' -> XTl
        if)if);
        INNER;
        true -> listError
     #);
   list2repError: WE.MakeError
     (# isList: @boolean
     enter isList
     do (if isList then
            'An evaluation-list ' -> XT;
         else
            'An evaluation ' -> XT
        if);
        'can only be assigned to a repetition\n'
        'where the elements are basic patterns '
        '(integer,boolean,char)\n'
        'or references to object "' -> xTl;
        EV[] -> xA;
        '" is not a basic pattern' -> XT;
        true -> listError
     #);
   ChkTxtCstToTxtRef:
     (# EV,RElm: @ASTindex; Rchain: ^actualDesc.DB.superChain
     enter(EV,Relm,Rchain[])
     <<SLOT ChkTxtCstToTxtRef:doPart>>
     #);
   QuaCheck:
     (* In L[]->R[] or L[]=R[] check qualification *)
     (# quaError:< (# no: @integer enter no do inner #);
        EV,LE,RE: @ASTindex;
        isEnter: @Boolean; 
        Lchain,RChain: ^ActualDesc.DB.SuperChain
     enter(EV,LE,Lchain[],RE,RChain[],isEnter)
     <<SLOT QuaCheck:doPart>>
     #);
   ChkBinOpTypes:
     (*
      * LE + RE
      * LE - RE
      * LE * RE: valType,valType->valType
      *          realType,realType->realType
      *          valType,realType->realType
      *          realType,valType->realType
      *          valType,charType->valType,warning
      *          charType,valType->valType,warning
      *          charType,charType->valType,warning
      * LE div RE: as above?
      * LE mod RE: as above?
      * LE / RE  : as above?
      * LE relOp RE: valType,valType -> boolType
      *              realType,realType -> booleType
      *              realType,valType -> boolType
      *              valType,realType -> boolType
      *              charType,charType-> boolType
      *              boolType,boolType-> boolType
      *  relOp=refEQ,refNE:
      *              refType,refType -> boolType
      *              noneType,noneType->boolType
      *              refType,noneType->boolType
      *              noneType,refType->boolType
      *              
      * LE boolOp RE: boolType,boolType->boolType
      *)
     (# op: @integer; EV, LE,RE: ^ASTindex; 
        Ltype,Rtype,type,opType,m: @integer;
        LChain,RChain: ^ActualDesc.DB.SuperChain
     enter(EV[],LE[],Ltype,LChain[],RE[],Rtype,RChain[])
     <<SLOT chkBinOpTYpes:doPart>>
     exit type
     #);


   LstErr:
     (# B: @boolean; N: @Integer
     enter(B,N)
     do (if B then 
            (if not (LV->RV.equal) then
                (* if L=R, i.e. the same eval, then it is either
                 * unaryMinus, notExp or chkIndex or rep[index].
                 * The error msg should be suppressed here, since a better
                 * one is given at the call of cmpLst
                 *)
                (if N = 24 then (EV,24)->WE.Warning 
                 else 
                    (EV,N)->&WE.SemError;
                    true->ListError
     if)if)if)#);
   Strip:
     (* transform (A) into A *)
     (# L,E: @ASTindex
     enter L
     do Elim:
          (if L.label = gram.EvalList then
              L.son->ScanList
              (# N: @Integer 
              do currentNode->E; N+1->N;
                 (if N = 2 then leave Elim if);
                 (* more than one elm in list *)
              #); 
              E->L;
              restart Elim; (* perhaps ((...(E)...)) *)
          if)
     exit L
     #);
   ChkLst:
     (# ClearList:
          (# scan: ^ | ScanEv; elm: @ASTindex;
             type: @integer; chain: ^ActualDesc.DB.SuperChain
          enter scan[]
          do (if scan[] <> NONE then
                 L: (# isNested: @boolean
                    do scan->(elm,type,chain[], isNested);
                       (if type <> emptyType then restart L if)
                    #);
                 NONE->scan[]
             if)
          #);
        LstError:
          (# Ltype,Rtype,no: @integer
          enter(Ltype,Rtype)
          do true->ListError;
             (if Ltype
              // emptyType then
                 (if Rtype
                  // emptyType then
                     (if level = 1 then 60->no else 61->no if)
                  // VIrefType // VCrefType then
                     (if level = 1 then 67->no else 68->no if)
                  else
                     (if level =1 then 62->no else 63->no if)
                 if)
              // valType  // realType
              // cValType // cCharType // cRealType then
                 (if Rtype
                  //emptyType then
                     (if level = 1 then 64->no else 65->no if)
                  // listType then 66->no
                  else 11->no
                 if)
              // listType then 
                 (if Rtype
                  //emptyType then
                     (if level = 1 then 64->no else 65->no if)
                  // valType  // realType
                  // cValType // cCharType // cRealType then 66->no
                  else 11->no
                 if)
              // VIrefType//VCrefType//CIrefType//CCrefType then
                 (if Rtype
                  //emptyType then
                     (if level = 1 then 69->no else 70->no if)
                  else 11->no
                 if)
              else
                 (if Rtype
                  //emptyType then
                     (if level = 1 then 64->no else 65->no if)
                  else 11->no
                 if)
             if);
             (EV,no)->WE.SemError
          #);
        emptyErr: (* not used *)
          (# left: @boolean
          enter left
          do (if left then
                 (if level = 1 then 
                     'No exit part on left-side'->messagestream.putline
                  else 
                     'An element on left-side has no exit part'
                       ->messagestream.putline
                 if)
              else
                 (if level = 1 then 
                     'No enter part on right-side'->messagestream.putline
                  else 'An element on right-side has no enter part'
                       ->messagestream.putline
                 if)
             if)
          #);
        GetRefType:
          (* EV = (ComputedObjectEvaluation <ObjectEvaluation>)
           *    | (ObjectReference <Reference>)
           * <ObjectEvaluation> = (InsertedItem <ObjectDescriptor>)
           *                    | <reference>
           * <reference> = <DynamicObjectGeneration>
           *             | (ObjectDenotation <attributeDenotation)
           * <DynamicObjectGeneration> = NOT possible more!!!!!!!!
           *              (dynamicItemGeneration <ObjectSpecification> )
           *            | (dynComponentGeneration <ObjectSpecification> )
           *)
          (# EVL,sort,spec: @ASTindex; typeKind: @integer
          enter EVL
          do (if ctst then 221 ->trace(#do 'GetRefType:' ->xT; EVL[]->xA #)if);
             (if EVL.label 
              // gram.ObjectDenotation then
                 EVL.son->EVL;
                 (if EVL.label = gram.thisObject then CIrefType->typeKind
                  else 
                     EVL->&GetSort->sort;
                     sort.son->spec; spec.brother->spec;
                     (if sort.label = gram.repetitionDecl then 
                         spec.brother->spec;
                         (if EVL.label <> gram.indexed then 
                             (* R[] where R: [e] ... *)
                             ref2repType -> TypeKind;
                             leave GetRefType
                         (* else R[i][] *)
                         if)
                     if);
                     (if spec.label
                      // gram.dynamicItem then VIrefType->TypeKind
                      // gram.staticItem then CIrefType->typeKind
                      // gram.dynamicComponent then  VCrefType->TypeKind
                      // gram.staticComponent then CCrefType->typeKind
                 if)if)
              // gram.InsertedItem then
             if);
          exit(typeKind,spec)
          #);  
        ScanEV:
          (* component pattern for scanning the elements of an evaluation *)
          (# EntSpec:
               (# SetBit:
                     (# K: @integer; b: @boolean
                     do (if desc.label = gram.objectDescriptor then
                            (* newindex.bet problem !! *)
                            desc.kind->K;
                            (if isOp1 then
                                (if ctst then
                                    223 ->trace(#do 'SetBit:Op1:'->xT; desc[]->xA#)
                                if);
                                (25,1) -> K.%getBits -> b;
                                (1,25,1) -> K.%putBits
                             else
                                (if ctst then
                                    223 ->trace(#do 'SetBit:Op2:'->xT; desc[]->xA#)
                                if);
                                (26,1) -> K.%getBits -> b;
                                (1,26,1) -> K.%putBits;
                            if);
                            K->desc.kind
                        if)
                     exit b
                     #);
                   ClearBit:
                     (# K: @integer; b: @boolean
                     do (if desc.label = gram.objectDescriptor then
                            (* newindex.bet problem *)
                            desc.kind->K;
                            (if isOp1 then 
                                (0,25,1) -> K.%putBits
                             else
                                (0,26,1) -> K.%putBits
                            if);
                            K->desc.kind
                        if)
                     #);
                   GetNX:
                    (# NX: @ASTindex
                    enter NX
                    do (if (NX.label<>gram.empty) then
                           NX.son->&Strip->NX;
                           NXcount+1->NXcount; (* at least 1 *)
                           (if NX.label // gram.evalList then
                               NXcount+1->NXcount; (* at least 2 *)
                               NX.son->NX
                       if)if)
                    exit NX
                    #);
                  vs: @integer;
                  doSuspend:
                    (* restore desc state in case this was the last SUSPEND *)
                    (# 
                    do  
                       desc.virtSize->vs;
                       oldVirtSize->desc.virtSize;
                       SUSPEND;
                       vs->desc.virtSize
                    #);
                  ES,desc,LNX: @ ASTindex; 
                  Pref,mainP,att,NP,DP,XP: ^ASTindex; 
                  chain,chain1,L: ^ActualDesc.DB.SuperChain; 
                  MN,NXcount,N,N1,oldVirtSize: @integer;
                  goPre: @boolean;
                  (* ES is the prefix of the front descriptor in chain*)
                  isVirt: @integer
               enter(ES,N,chain[],goPre)
               do (if ctst then
                      223->trace(#do 'EntSpec:' -> xT; ES[]->xA; chain.print #);
                  if);
                  (* (if goPre//true then 
                   * chain[]->actualDesc.DB.SuperPred->chain[] 
                   * if);
                   * The above was done in a previous version. Consider a chain
                   *    D1 D2 ,,, Dn E1
                   * If goPre=true then E1.kind=nest. The prefix of E should
                   * be found in D1 D2 ... Dn. The old code would then return
                   * a chain
                   *    D1 D2 ... Dn E2
                   * where E2 was the prefix of E1. With the old code, E2.super
                   * would again be searched in D1 D2 ... Dn, but this will
                   * only work if E1 and E2 are at the same block level.
                   * In addition if E2 in its enter/exit list has virtuals
                   * bound in E1, the binding in E1 would not be found. Ex.:
                   *    Q: (# R: ^V; V:< (# x: @integer exit x #)
                   *       do INNER exit R #);
                   *    QQ: Q (# V::<(# y: @integer exit y#) #);
                   *    W: ^QQ;  N,M: @integer
                   *    W->(N,M);
                   * The new code searches the binding of E1 (ES) in
                   * D1 D2 ... Dn, but after the call of actualeDesc, the 
                   * following chain will be built
                   *    D1, D2, ... Dn E1 E2
                   * The search of a possible prefix of E2 is then done
                   * in the origin of 
                   *    D1 D2 ... Dn E1 E2
                   * and the super desc of E2, E3 will be app. with PRE:
                   *    D1 D2 ... Dn E1 E2 E3
                   *)

                  (if goPre then
                      (* the descriptor for ES is in the origin(encloser)
                       * of chain
                       *)
                      chain[]->chain1[]->actualDesc.DB.ENC->chain[]
                  if);
                  (chain[],ES)->actualDesc.DB.theDescForm->(desc,MN,chain[],isVirt);
                  (if goPre then 
                      (if isVirt >= VirtualForm then
                          (true,17)->lstErr;
                          integerDesc->desc
                       else 
                          (* append the prefix of the old chain*)
                          chain1[]->actualDesc.DB.PRE->chain[];
                          (* now desc = chain.desc *)
                      if);
                          (*175->trace(#do'goPre:'->T;  chain.print #);*)
                  if);
                  (* chain = includes superChain  from ES to desc of ES;
                   *         chain-desc = ES.desc
                   *)
                  ES -> current;
                  (if (ES->&SemAtt.IsRep) then
                      (if ctst then
                          223 -> trace
                          (#
                          do 'EntSpec:IsRep1:'->xT; ES[]->xA;
                      #)if);
                      ES->sematt.SimpleOrRepA -> elm;  (*ES->elm;*)
                      repType->typeKind;
                      (if false  then
                          (*(chain[],ES) -> actualDesc.DB.CatP ->eChain[]*)
                       else
                          chain[] -> eChain[]; (* OLM: 28/11/99: to handle
                                                * checking of rep asg:
                                                * R1 -> R2 *)
                      if);
                      (if ctst then
                          221->trace
                          (#do 'EntSpec:isRep2:'->xT; ES[] -> xA;
                             elm[] -> xA; eChain.print
                          #);
                      if);
                      SUSPEND
                   else
                      (if ((desc->isStandard) 
                          and ((desc->cProcDesc.equal)=false)) then
                          (if (desc->realDesc.equal) then 
                              desc->Elm; 
                              chain[]->eChain[]; 
                              realType->typeKind;
                           else 
                              desc->Elm;
                              desc[]->sematt.type->typeKind;
                              (if ctst then
                                  223->trace(#do 'Type:'->xT; 
                                           desc[]->sematt.type->puthex;
                                               typekind->xI #);
                              if);
                              ES->elm;
                          if);
                          chain[]->eChain[]; 
                          (if ctst then
                              223->trace(#do 'Type2:'->xT; 17->cstVal;
                                           typeKind->xI; es[]-> xA #);
                          if);
                          SUSPEND;
                              (*223->trace(#do 'type4:'->xT; typekind->xI #);*)
                       else
                          (* check that there is no recursion in NX-list 
                           * like in:
                           * T: (# ... exit T #)
                           * if a desc is met more than twice, 
                           * it is a recursion.
                           * The same desc may appear on the left and right
                           *)
                          (if SetBit then
			      (if left then (*exit-part*)
                                  (true,110) -> lstErr
                               else (*enter-part*)
                                  (true,111) -> lstErr
                              if);
                           else
                              true -> isNested;
                              0->NXcount;
                              desc[]
                                -> descSonsRef
                                -> (pref[],mainP[],att[],NP[],DP[],XP[]);
                              (if left then 
                                  XP -> &GetNX -> LNX
                               else 
                                  NP -> &GetNX -> LNX
                              if);

                              N+NXcount -> N;
                              none->mainP[]->att[]->NP[]->DP[]->XP[];
                              (if pref.label = gram.prefix then
                                  (* very tricky. virtSize must be well defined
                                   * at each SUSPEND. The following may cause
                                   * troubles in situations like 
                                   * A: (# ... exit B #); B: A (# ...#)
                                   * The error will be catched at the level of A, 
                                   * not at B.
                                   * However, be aware that unforseen situations 
                                   * may exist
                                   *)
                                  (pref.son,N,chain[],true)->&EntSpec->(N1,L[]);
                                  (if ((N=0) and (N1=1)) then L[]->chain[] if);
                                  N1->N;
                              if);
                              none->pref[]->mainP[]->att[]->NP[]->DP[]->XP[];
                              (if ctst then
                                  223->trace
                                  (#
                                  do 'EntSpecWithNX: NXcount=' -> xT;
                                     NXcount->xI;
                                     'N='->xT; N->xI;
                              #)if);
                              (if true
                                  (* N=total no. of N/X-elements *)
                                  (* NXcount=no. of N/X-elm in this main part *) 
                               // (NXcount=1) and (N=1) then 
                                  LNX -> Elm; (*&ObjStrip*)
                                  (*level+1->level;
                                   * dont work: also increment for
                                   * (# exit anInteger #)
                                   *)
                                  (* there is an enter/exit part consisting
                                   * of one element. The enter/exit part
                                   * of this element is now considered
                                   *)
                                  (# nxScan: @ | scanEv; isNestedx: @boolean
                                  do (elm,left,chain[],isOp1)
                                       -> nxScan
                                       -> (elm,typeKind,eChain[],isNestedx);
                                     nxScan.current -> current;
	                             (*223->trace(#do 'one-elmA:'->xT; 
                                                  typeKind->xI;
                                                  nxScan.typeKind->xI;
                                                  elm[]->xA;
                                                  N -> xI
                                      #);
                                      *)
                                     L: (if typeKind <> emptyType then
                                            SUSPEND;
                                            nxScan
                                              -> (elm,typeKind,eChain[],isNested);
                                            nxScan.current -> current;
                                            (*223->trace(#do 'one-elmB:'->xT; typeKind->xI; #);*)
                                            restart L 
                                        if);
                                  #)
                               // N > 1 then 
                                  listType->typeKind;
                                  LNX -> ScanList
                                  (#
                                  do (currentNode,chain[])->(Elm,eChain[]);
                                     Elm -> current;
                                     SUSPEND 
                                  #)
                               else
                                  (* This main-part has no NX-part,
                                   * but the super may have an NX-part;
                                   * if N > 0 then super has an NX-part;
                                   * if N = 0 then super has NO NX-part
                                   *)
                                  (if N = 0 then
                                      (* NO NX-part in this descriptor;
                                       * used for error reporting
                                       *)
                                      null -> current;
                                      true -> hasNoNXpart 
                                  if)
                      if)if)if);
                      ClearBit;
                      (* clear chkLst-bit *)
                      (*'\n***Clear chkLst-bit'->putLine*)
                  if);
                  emptyType->typeKind
               exit(N,chain[]) (* what is N used for? *)
               #);
             
             left,isOp1,transList: @boolean; 
             eChain,chain: ^actualDesc.DB.SuperChain;
             NE,EVL,elm,EVLx: @ASTindex; 
             lab,NXcount,typeKind,N,cstVal: @integer;
             isCst,hasCode,isNested,hasNoNXpart: @boolean;
             current: @ASTindex
          enter(NE,left,chain[],isOp1) (* ScanEV *)
          do (if NE.isNull then emptyType->typeKind
              else
                 NE -> &Strip -> EVL -> current; (* cheat *) 
                 (if ctst then
                     221->trace(#do 'ScanEv:'->xT; EVL[]->xA #);
                 if);
                 L:
                   (if EVL.label
                    // gram.assignmentEvaluation then
                       EVL.son->EVL; 
                       (if left then EVL.brother->EVL if);
                       EVL->&Strip->EVL;
                       restart L
                    // gram.objectDenotation then
                       EVL.son->elm;
                       (if elm.label = gram.remotePrimitive then 
                           (# EV1,op: @ASTindex;
                              vList: @
                                (# L: @integer
                                enter L
                                do listType->typeKind;
                                   (for L repeat SUSPEND for);
                                   emptyType->typeKind
                                #)
                           do elm.son->EV1; EV1.brother->op;
                              integerDesc->elm; chain[]->eChain[];
                              (if op[]->sematt.primitiveToNumber
                                  (# error::(# do #) #)
                               //5 //6 //7 //8 //13 then (*val->X.%getByte->Y*)
                                  primType->typeKind
                               //9 //10 //31 //19 //20 then 
                                  (*(a,b)->X.%putByte->Y*)
                                  (if left then 
                                      primType -> typeKind
                                   else 2 -> vList
                                  if)
                               //21 then (*(a,b,c)->X.%getBits->Y*)
                                  (if left then 
                                      primType -> typeKind
                                   else
                                      3 -> vList
                                  if)
                               else
                              if);
                              SUSPEND;
                           #)
                        else
                           (elm,0,chain[],false) -> &EntSpec -> (N,chain[]);
                       if)
                    // gram.staticItem then
                       EVL.son -> elm;
                       (elm,0,chain[],false) -> &EntSpec -> (N,chain[])
                    // gram.insertedItem 
                    // gram.dynamicItemGeneration 
                    // gram.dynamicComponentGeneration
                    // gram.prefix then
                       (* ObjectEval: *)
                       (EVL.son,0,chain[],false) -> &EntSpec -> (N,chain[]);
                    // gram.computedObjectEvaluation then 
                       EVL.son->EVL; restart L
                    // gram.objectReference then (* RefEval: *)
                       (# spec: @ASTindex; MN,isVirt: @integer
                       do EVL.son->evl;
                          (if evl.label
                           // gram.dynamicItemGeneration then 
                              CIrefType->typeKind
                           // gram.dynamicComponentGeneration then 
                              CCrefType->typeKind
                           else EVL -> GetRefType -> (typeKind,spec)
                          if);
                          chain[] -> eChain[];
                          (* not so nice: perhaps we can use 
                           * spec -> elm also when typeKind<>ref2repType
                           *)
                          (if typeKind = ref2repType then
                              spec -> Elm;
                              (chain[],EVL.son)
                                -> actualDesc.DB.theDescForm
                                -> (spec(*dummy*),MN,eChain[],isVirt);
                           else
                              EVL -> Elm
                          if)
                       #);
                       SUSPEND
                    // gram.structureReference then
                       (# sort: @ASTindex
                       do EVL.son->getSort->sort;
                          (if sort.label
                           // gram.patternDecl 
                           // gram.virtualDecl
                           // gram.bindingDecl // gram.finalDecl then
                              cStrucType->typeKind
                           // gram.simpleDecl then
                              sort.son->sort; sort.brother->sort;
                              (if sort.label = gram.variablePattern then
                                  vStrucType->typeKind 
                               else
                                  cStrucType->typeKind
                              if)
                           // gram.repetitionDecl then
                              sort.son->sort; sort.brother->sort; 
                              sort.brother->sort;
                              (if sort.label = gram.variablePattern then
                                  vStrucType->typeKind 
                               else
                                  cStrucType->typeKind
                              if)
                          if);
                          (EVL,chain[])->(Elm,eChain[]);
                          SUSPEND
                       #)
                    // gram.noneExp then
                       noneType->typeKind; (EVL,chain[])->(Elm,eChain[]);
                       SUSPEND  
                    // gram.EvalList then
                       listType->typeKind;
                       EVL.son->ScanList
                       (#do chain[]->eChain[]; 
                          currentNode->Elm;
                          SUSPEND 
                       #)
                    // gram.integerConst // gram.address then 
                       (* NB: should be integerConstDesc *) chain[]->eChain[];
                       EVL(*integerDesc*)->Elm; cValType->typeKind; SUSPEND;
                    // gram.repetitionSlice then
                       (# desc,N: @ASTindex; MN,isVirt: @integer 
                       do RepType->typeKind; 
                          (* The following code could be more efficient*)
                          EVL.son -> N -> SetUp;
                          N -> sematt.SimpleOrRepA -> elm;
                          
                          (* EVL.son -> elm;*)
                          (chain[],EVL.son)
                            -> actualDesc.DB.theDescForm
                            -> (desc,MN,eChain[],isVirt);
                          SUSPEND
                       #)
                    // gram.textConst then
                       (# T: ^ text; l: @integer
                       do EVL.gettext->T[];
                          Getlength:
                            T.scanBeta
                            (# 
                            do l+1->l;
                               (if l > 1 then  leave GetLength
                            if)#);
                          (if l = 1 then
                              integerDesc->Elm; 
                              cCharType->typeKind
                           else (* l=0 or l>1*)
                              null(*gEmpty*)->Elm; 
                              EVL -> elm;
                              cRepType->typeKind 
                          if); 
                          chain[]->eChain[];
                          SUSPEND
                       #)
                    // gram.primitive then 
                       EVL->SemAtt.ParsePrimitive
                       (# ExternalOp::<
                            (#
                            do null(*gEmpty*)->Elm; cPrimType->typeKind; 
                               chain[]->eChain[]; SUSPEND
                            #);
                          
                          inLineOp::<
                            (# vList:
                                 (# L: @integer
                                 enter L
                                 do listType->typeKind;
                                    (for L repeat SUSPEND for);
                                    emptyType->typeKind
                                 #);
                               Rvlist:
                                 (# L: @integer
                                 enter L
                                 do listType->typeKind; null->elm; 
                                    (for L repeat 
                                         SUSPEND; 
                                         integerDesc->elm;
                                    for);
                                    emptyType->typeKind
                                 #);
                               (* For some of the primitives a listType is 
                                * returned.  The elements of the list are
                                * returned as integerDesc (elm).
                                * The elements must be assignable
                                * to almost all types: bool char, int.
                                * integerDesc wrosk, since the hack below
                                * with alternative objectDescriptor
                                * (after // gram.primitive) returns
                                * primType for objectDescriptor always!
                                *)
                            do chain[]->eChain[]; integerDesc->elm;
                               (if OpCode 
                                //1//5//6//7//8//22//23//24//25//26
                                //27//28//29//30 then
                                   primType->typeKind
                                //9//10//21//31 then (* (x,y) ->op *)
                                   (if not left  then 2->vList
                                    else emptyType->typeKind
                                   if)
                                //2//3//4 then  (* (x,y)->OP->z *)
                                   (if not left then 2->vList
                                    else primType->typeKind
                                   if)
                                //11//12//13//14//15 then (* (R,y)->OP->z *)
                                   (if not left then 2->Rvlist
                                    else primType->typeKind
                                   if)
                                //16//17//18 then (* R,x,y)->OP *)
                                   (if not left then 3->RvList
                                    else emptyType->typeKind
                                   if)
                                else (* 19//20 *) primType->typeKind
                               if);
                               SUSPEND
                            #)
                       #)
                    // gram.objectDescriptor then
                       (if isConstructor then
                           (* we come here when checking constructors
                            * E -> &foo[] -> S[]
                            *)
                           (EVL,0,chain[],false) -> &EntSpec -> (N,chain[]);
                        else
                           (* this is a hack for handling (x,y)->TOS'%OP' *)
                           (* EVL = integerDesc *)
                           primType->typeKind;
                           chain[]->eChain[];
                           integerDesc->elm;
                           SUSPEND;
                       if)
                    //gram.primitiveExp then
                        integerDesc->Elm; 
                       cprimType->typeKind;
                       chain[]->eChain[]; 
                       SUSPEND
                    // gram.unaryPrimitiveExp then 
                       (* %thiss object *)
                       (# N: @ASTindex; t: ^text
                       do EVL.son -> N; 
                          N.gettext -> T[];
                          (if 'thiss' -> T.equalNCS then
                              CIrefType -> typeKind;
                              superObject ->Elm; 
                           else
                              integerDesc->Elm; 
                              cprimType->typeKind;
                          if);
                          chain[]->eChain[]; 
                          SUSPEND
                       #);
                    //gram.unaryPlusExp // gram.unaryMinusExp then
                       chain[]->eChain[]; integerDesc->Elm; 
                       cValType->typeKind;
                       SUSPEND;
                    // gram.notExp then
                       chain[]->eChain[]; integerDesc->Elm; 
                       cBoolType->typeKind;
                       SUSPEND;
                    else                            
                       (* BinOp // UnOp *)
                       (if (EVL.label -> lab -> SemAtt.evalClass)
                        // SemAtt.evalClass.BinOp then
                           chain[]->eChain[]; 
                           (if lab = gram.realDivExp then
                               cRealType -> typeKind;
                               realDesc -> elm;
                            else
                               (if lab -> evalClass.opType
                                // evalClass.addOp 
                                // evalClass.modOp then 
                                   cValType->typeKind;
                                   integerDesc->Elm; 
                                // evalClass.relOp//evalClass.allRelOp
                                // evalClass.boolOp then 
                                   cBoolType->typeKind;
                                   boolDesc->Elm;
                           if)if);
                           (* (if level= 1 then
                            (ThisDesc,EVL,key.exitt,false)->&ChkEval 
                            ->(isCst,cstVal,n,hasCode,typeKind)
                            * dont always work - 
                            * thisDesc is not always good!
                            * And not good anyway, since
                            * binop gets evaluated several times
                            * Some assignments
                            *    a+b -> c
                            * will be allowed since a+b gets type cPrimType
                            else
                            cPrimType->typeKind; ( * hack * )
                            if);
                            *)
                           SUSPEND
                        // SemAtt.evalClass.UnOp then
                           chain[]->eChain[]; 
                           integerDesc->Elm; 
                           primType (*!!hack! cValType*)->typeKind;
                           SUSPEND; 
                   if)if);
                 
                 chain[]->eChain[];
                 cycle
                 (#
                 do null->Elm; emptyType->typeKind;
                    SUSPEND; 
                    none->eChain[]
                 #)
             if)
          exit(Elm,typeKind,eChain[],isNested)
          #);
        
        GetRepElmType:
          (# Relm,desc: @ASTindex; 
             Rtype: @integer;
             error:< object
          enter Relm
          do (if ctst then 
                 221->trace(#do 'GetRepElmType:Relm='->xT; Relm[] -> xA #)
             if);
             L:
               (if Relm.label 
                // gram.staticItem then 
                   Relm.son -> Relm;
                   Relm -> sematt.descrip -> desc;
                   (if (desc -> sematt.isStandard) then
                       desc[] -> sematt.type -> Rtype
                    else
                       error
                   if)
                // gram.dynamicItem then
                   VIrefType -> Rtype
                else
                   '\n***getRepElmType:else!'->putline;
                   Relm -> SimpleOrRepA -> Relm;
                   restart L
               if);
          exit Rtype
          #);            
        MatchLists:
          (* PRE: LType = listType
           *      RType in [listType,object?, ...]
           *)
          (# LisNested,RisNested: @boolean;
             elm: @ASTindex;
          do (if ctst then
                 221->trace
                 (# do 'MatchLists: '->xT; xN;
                    'Ltype='->xT; LType->evalClass.typestring->xT; 
                    ' Lelm='->xT; Lelm[] -> xA;
                    ' -> '->xT; 
                    'Rtype='->xT; RType->evalClass.typestring->xT; 
                    ' Relm='->xT; Relm[] -> xA
             #)if);
                 
             (if not isEnter then 
                 (true,21)->&LstErr
              else
                 (* only valType and refType may be compared *)
                 (if Rtype = emptyType then 
                     (listType,emptyType)->LstError
                 if);
                 Loop:
                   Cycle
                   (#
                   do (if RType = emptyType then 
                          (true,8)->&LstErr; 
                          leave Loop 
                      if);
                      (if not Relm.isNull then
                          (* NOTE: call to chkLst will override typeKind.
                           * This is a problem for chkIndex, etc.
                           * see also LstErr
                           *)
                          (* do we ever come here with a binary operator?
                           * NO!
                           *)
                          (if ctst then
                              222->trace
                              (#do 'MatchLists2:'->xT;
                                 'Ltype='->xT; LType->evalClass.typestring->xT;
                                 ' -> ' -> xT;
                                 'Rtype='->xT; RType->evalClass.typestring->xT
                              #);
                          if);
                          (EVx,Lelm,Relm,Lchain[],Rchain[],level+1
                          ,Ltype,Rtype,false
                          )
                            ->&ChkLst;
                      if);
                      
                      Lscan->(Lelm,LType,Lchain[],LisNested);
                      (if Rscan[] <> NONE then
                          (* matchList may be called when Left is list
                           * and right is primitive. I.e. Lscan is never
                           * NONE, but Rscan can be NONE
                           *)
                          RScan->(Relm,RType,Rchain[],RisNested);
                      if);
                      (if Ltype = emptyType then 
                          ((RType<>emptyType),8)->&LstErr;
                          leave Loop
                      if);
             #)if)
          #);
        List2RepAsg:
          (# LisNested: @boolean
          do Relm -> GetRepElmType 
             (# error:: (#do (RVx[],false,true) -> list2repError #)
             #)
               -> Rtype;
             (if ctst then
                 221->trace
                 (# do 'List2RepAsg:'->xT;
                    'Ltype='->xT; LType->evalClass.typestring->xT; 
                    ' Lelm='->xT; Lelm[] -> xA;
                    ' -> '->xT; 
                    'Rtype='->xT; RType->evalClass.typestring->xT; 
                    ' Relm='->xT; Relm[] -> xA
             #)if);
             
             (if not isEnter then 
                 (true,21)->&LstErr
              else
                 (if not listError then
                     Loop:
                       Cycle
                       (#
                       do (if ctst then
                              222->trace
                              (#do 'List2RepAsg2:'->xT;
                                 'Ltype='->xT; LType->evalClass.typestring->xT;
                                 ' -> ' -> xT;
                                 'Rtype='->xT; RType->evalClass.typestring->xT
                              #);
                          if);
                          (EVx,Lelm,Relm,Lchain[],Rchain[]
                          ,level+1,Ltype,Rtype,false)
                            ->&ChkLst;
                          Lscan->(Lelm,LType,Lchain[],LisNested);
                          (if Ltype = emptyType then 
                              leave Loop
                          if);
             #)if)if)
          #);
        
        NXcount: @integer;
        (* counts the number of elements in enter/exit during EntSpec *)
        
        LScan,RScan: ^ | ScanEV;
        
        EVx,LVx,RVx,Lelm,Relm: @ASTindex; Ltype,Rtype: @integer; 
        Lchain,Rchain: ^actualDesc.DB.SuperChain;
        level: @integer;
        isConstructor: @boolean; (* we are checking assignment t
                                  * to constructor in
                                  * (e1,e2,e3) -> &foo[] -> S[]
                                  *)
     enter(EVx,LVx,RVx,Lchain[],Rchain[],level,Ltype,Rtype,isConstructor)
     <<SLOT xChkLstBody:doPart>>
     #); (* chkLst *)
   
   (* from origin : thisDesc,EV,L,R: @ASTindex; isEnter: @boolean *)
   isEnter: @boolean;
   
do
   compKind=assignCompKind->isEnter;
   (EV,LV,RV,(thisDesc->actualDesc.DB.newSingle)
   ,(thisDesc->actualDesc.DB.newSingle),1,Ltype,Rtype,false)->&ChkLst
#)
