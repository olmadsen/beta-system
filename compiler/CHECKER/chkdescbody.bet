ORIGIN 'docheck';
INCLUDE 'checklib';
--- ChkDescBody: descriptor ----
(* switch[191:199] *)
(* 191: desc trace *)
(* 192: dcl trace *)
(* 193: imp trace *)
(* 194: cst desc val *)
(* 195: desc after check, elim. *)
(* 196: dump att storage allocation *)
(# thisDescOrgOff: @integer;
   
   ChkPre:
     (# preError:
          (# no: @integer enter no do true->PreErr; (pre,no)->semError #);
        PreErr: @boolean;
        isStaticPtn: @
          (* checks that node is a static pattern;
           * P, where P is a pattern is OK;
           * R.P, where R is a static item is OK;
           * R[exp].P is not OK
           *)
          (# sort: @AST.index; MN: @Integer; staticPre: @boolean
          do pre.son->N; thisDesc.father->sort;
             (if sort.label=gram.finalDecl then sort->chkVB if);
             (* SetUp will now check if the super-pattern is 
              * a static denotation
              *)
             N->&SetUp->(dclRef,preDesc);
             (* IT should be considered what will happen if setUp 
              * reports an error
              *)
             (*(if InDecl->staticPre then
                 (N[],1)->&ChkDenKind
                 (# error::
                      (# 
                      do (if errNo 
                          // 1 then 48->preError
                          // 2 // 4 then  48->preError
                          // 3 // 5 then  48->preError
                          else 48->preError
                 if)#)#)
                 ->remote
              else
                 (N[],2)->&ChkDenKind
                 (# error::
                      (#
                      do (if errNo
                          // 2 // 4 then (N,1000)->&Warning
                          // 3 // 5 then (N,1001)->&Warning
                 if)#)#)
                 ->remote
              *)
             (* the following checks if the super-pattern is a simple
              * name which might imply that the origin of super can
              * be re-used for this descriptor.  
              *)
             (if N.label // gram.nameApl then 
                 (if N.stringlength//0 then
                     (* Implicit prefix as in V::< (# #)
                      * if remote we cannot reuse origin; se reuseOrigin
                      *)
                     (# VS: @AST.index
                     do dclRef.sort->VS; VS.son->VS; VS.brother->VS;
                        (if VS.label //gram.remote then true->remote if)
                 #)if)
              else true->remote
             if);
             (if true=false then (* remote MUST be defined !*)
             (if N.label
              // gram.nameApl then (* ok *)
                 (if N.stringlength//0 then
                     (* Implicit prefix as in V::< (# #)
                      * if remote we cannot reuse origin; se reuseOrigin
                      *)
                     (# VS: @AST.index
                     do dclRef.sort->VS; VS.son->VS; VS.brother->VS;
                        (if VS.label //gram.remote then true->remote if)
                 #)if)
              // gram.remote then 
                 (* reconsider the following check. It does not accept
                  * this(P).A(# ... #), but accepts this(P).X.A(# ... #)
                  *)
                 N.son->N->getSort->sort; N.brother->N;
                 (if sort.label//gram.simpleDecl then
                     sort.son->sort; sort.brother->sort; true->remote;
                     (if sort.label//gram.staticItem//gram.staticComponent then
                      else (* 48-preError *) if)
                  else 4->preError
                 if)
              // gram.computedRemote then
                 (* for this to work, computedRemote must be handled
                  * in PRE in virtual.bet
                  * 
                  * 192->trace(#do 'compRemPre:'->T; dclRef[]->A;preDesc[]->A#)
                  *)
                 '\n\n**** WARNING: computed-remote-prefix is currently being implemented!\n'->puttext;
                 (thisDesc[],screen[],100)->thePP
              else 48->preError
             if)if);
             (if not preErr then
                 dclRef.sort->preSort;
                 (* we are currently checking the prefix P of a descriptor
                  *     P (# #)
                  * ------
                  * Note the special case (!!!)
                  *    P:< (# ... #)
                  *    PP::< (# ... #)
                  * when checking the descriptor for PP, the implicit
                  * prefix refers to P, but the descriptor of the 
                  * implict prefix referes to the descriptor of P, ie.
                  * the descriptor of the implict prefix of P is NOT
                  * marked as virtual. 
                  * In cases like
                  * P:< (# #); A: P(# #),
                  * P's descriptor is marked as virtual and fails the 
                  * tests below.
                  * 
                  * First test that the prefix is actually declared as a
                  * pattern, and not as a simple attribute like P: @ T
                  *)
                 (if preSort.label 
                  // gram.patternDecl 
                  (*// gram.finalDecl - final was move to here from below
                   * to handle finalBindings as prefix;
                   * see FEJL/mads2.bet.
                   * Not so simple, since a final may be bound to a virtual,
                   * etc. I.e. more checking is needed.
                   * Alos ref. is noe in descOrigin for mads2 with
                   * this fix
                   *)
                                     then
                     (if preDesc.label//gram.unexpanded then
                         (* P: <<SLOT P:descriptor>> *)
                         17->preError
                         (* else P: P0(# ... #) *)
                     if)
                  // gram.virtualDecl // gram.bindingDecl 
                  // gram.finalDecl then
                     (*- no longer an error; 
                      * see mads2 comment above . OOPS: still a problem!
                      *)
                     (* P:< X; P::< X; P:: X, where X may be 
                      *   A - a name, remote name ,etc
                      *   P0(# ...#)
                      *   <<SLOT ...>>
                      * The above is only OK, if X is a descriptor, and then
                      * we have the special case  (!!!) mentioned above
                      *)
                     (if preDesc.label //Gram.objectDescriptor then (*ok*)
                      else
                      (*// gram.virtualDecl // gram.bindingDecl 
                       *// gram.unExpanded then*)
                         17->preError
                         (* (thisDesc.origin,N)->actualDesc->(N.descRef,MN); *)
                     if)    
                  else 48 ->preError
                     (*(thisDesc.origin,N)->actualDesc->(N.descRef,MN) *)
             if)if)
          exit preErr
          #);
        SuperOnDist:
          (# on,pn: @integer; isSub: @boolean; 
             preDescOrigin,descOrig: ^AST.index; 
          do thisDesc[]->DescOrigin->descOrig[]; 
             preDesc[]->DescOrigin->preDescOrigin[];
             (*197->trace
              (#do thisDesc[]->A; descOrig[]->A; 
              preDesc[]->A; preDescOrigin[]->A 
              #);
              *)
             L: (if descOrig.isNull then
                    messagestream.putLine; (thisDesc[],screen[],12)->thePP;
                    '*** Warning! The code generator may not be '->messagestream.putline;
                    'able to generate correct origin for super!'->messagestream.putline;
                    0->on; N.pn->pn
                 else
                    (descOrig,preDescOrigin)->ChkQua->(pn,isSub);
                    (if not isSub then
                        descOrig[]->DescOrigin->descOrig[]; 
                        on+1->on;
                        restart L
                if)if)
          exit(on,pn)
          #);
        ReuseOrigin: @
          (* check if origin of super can be reused *)
          (# reuse,rem: @boolean; spec: @AST.index;
             ThisDescOrigin,PreDescOrigin: ^AST.index
          do L:(if (N.ON=0) and not remote then
                   (if N.pn = 0 then True -> Reuse
                    else 
                       thisDesc[]->DescOrigin->ThisDescOrigin[];
                       preDesc[]->DescOrigin->PreDescOrigin[];
                       (if preSort.label
                        //gram.virtualDecl//gram.bindingDecl//gram.finalDecl
                           then
                           (* thisDesc in W :: < (# ... #)
                            * the super may then be  V :< (# ... #)
                            * or                     V :< A
                            * the first case can reuse origin, the second only
                            * if A is atsame level as V
                            *)
                           preSort.son->spec; spec.brother->spec;
                           (if spec.label = gram.objectDescriptor then (* ok *)
                            else (* V:< A *) 
                               spec->getName->(spec,rem);
                               (if (spec.on>0) then
                                   (************************** has to checked!!! ***************************)
                                   (* (if switch[480]//false then
                                    superOnDist->(N.on,N.pn) if); ****)
                                   leave L
                           if)if);
                       if);
                       (if ThisDescOrigin.originOff = PreDescOrigin.originOff
                           then true->Reuse
               if)if)if)
          exit Reuse
          #);
        access,kind: @integer; remote,isCproc: @boolean; 
        N,dclRef,preSort: @AST.index
     do AST.null->preDesc; 
        false->insertable;
        (* insertable means simple sinsertable as in:
         *  do ...; (#do ... #); ...
         *)
        L:
          (if pre.label=gram.prefix then
              true->hasSuper;
              (if isStaticPtn then (* error in prefix *) 
               else
                  (preDesc,common.prefKind)->&GetSpecSize->(offCount,access);
                  (if (preDesc->sematt.descKind->kind)=dataKind then
                      4->virtOff; (* if zero it will later be set to -4
                                   * which will create problems in chkLst
                                   *)
                      (*0->offCount;*)
                      leave L
                  if);
                  (if offCount=0 then
                      (* Prefix error - probably circular prefix*)
                      true->preErr
                   else
                      (* if access//common.cstInd then 55->preError*)
                      (if (preDesc->Sematt.descKind->kind)
                       // standardKind then
                          (if true
                           // (preDesc->CprocDesc.equal->isCproc) then
                              12 (* prototype + gcCount + origin*)
                              +400 (*NOT so good: for CallC, etc*)->offCount;
                              (if common.switch[66] then 
                                  8->virtOff; (* inner-dispatch *)
                               else
                                  4-> virtOff
                              if);
                              8->ThisDesc.originOff->thisDescOrgOff;
                              externalKind->kind
                           (* // (preDesc->CstrucDesc.equal) then 
                            * we never come here!
                            *)
                           else 57->preError
                          if)
                       // constKind then 16->preError
                       else
                          (* perhaps test on preDesc.label
                           * // gram.virtualDecl//gram.bindingDecl
                           * //gram.unExpanded then  17->preError
                           *)
                          preDesc[]->sematt.insertable->insertable;
                          preDesc.virtSize+4->virtOff;
                          (* allocate possible origin *) 
                          (if ReuseOrigin then
                              (* same origin as prefix *)
                              preDesc.originOff->ThisDesc.originOff
                                ->thisDescOrgOff;
                              (if common.switch[64] then
                                  true->hasAcode
                               else
                                  preDesc[]->sematt.hasAcode->hasAcode;
                              if);
                              true->sameOriginAsSuper
                           else (* allocate new origin *)
                              offCount->ThisDesc.originOff->thisDescOrgOff;
                              offCount+4->offCount;
                              true->hasAcode
                          if);
                          False->isCst;
                          (kind=ExternalKind)->isCproc 
                          (*super is sub of External*)
              if)if)if);
              preDesc[]->sematt.type->preType;
           else (* No prefix *) 
              12 (* prototype + gcCount + origin*) -> offCount;
              (if common.switch[66] then
                  8-> virtOff; (* allocate space for INNER-dispatch; *)
               else
                  4-> virtOff
              if);
              8->ThisDesc.originOff->thisDescOrgOff;
              emptyType->preType
          if);
        (if common.switch[64] (*and (doP.label <> gram.empty)*) 
            and ((kind = generalKind) or (kind=0 (* no super*))) then
              (* allocate space for dynamic-link and return address
               * offCount  : dynamic link
               * offCount+4: returnAddress
               * 
               * NOTE: returnAdr needed for V-entry points ALWAYS!
               * can be eliminated for V-entry points with NO A-code
               * 
               * See also below at callBackKind' where returnAdr 
               * is allocated for call-back patterns
               *)
              offCount -> thisDesc.returnOff;
              offCount + 8 -> offCount
          if);
        (if PreErr then
            pre.son->getName->(N,remote);
            errorName->N.dclRef; 
            superObject->preDesc->N.descref 
            (* used to be integerDesc, but superObject has an inner *)
        if)
     exit kind
     #);
   
   ChkAtt:
     (# ChkSpec:
          (# isPTNorSlot:
               (# N: @AST.index
               enter N
               do (if N.label //gram.objectDescriptor//gram.unExpanded then 
                      (*skip*)
                   else (N,(N->&GetSort))->isPtn
               if)#);
             
             rep: @boolean; spec,desc,N: @ AST.index;
             specSize,access,descKind: @ integer
          enter(spec,rep)
          do spec.son->N-> &GetDesc->desc;
             insertable and ((desc->sematt.descKind)=standardKind)->insertable;
             (if spec.label
              // gram.dynamicItem // gram.dynamicComponent then
                 common.refSize*4->specSize; common.varInd->access;
                 (N,(N->&GetSort),false)->isNonSimplePtn
              // gram.staticItem then 
                 (desc,common.itemKind)->getSpecSize->(specSize,access);
                 N->&isPTNorSlot;
                 (if desc.label=gram.objectDescriptor then
                     desc->sematt.descKind->descKind
                  else
                     generalKind->descKind
                 if);
                 (if descKind
                  // standardKind then
                  // generalKind then
                     true->hasAcode;
                     (*(if rep then 
                         (if switch[48] then (spec,26)->&Warning
                          else (spec,26)->&SemError 
                      if)if)*)
                  else
                     (if rep then (spec,26)->&SemError if)
                 if)
              // gram.staticComponent then (*********)
                 true->hasAcode;
                 (desc,common.compKind)->getSpecSize->(specSize,access);
                 N->&isPTNorSlot;
                 (*(if rep then 
                     (if switch[48] then (spec,25)->Warning
                      else (spec,25)->&SemError 
                  if)if)*)
              // gram.variablePattern then
                 common.refSize*4->specSize; common.varInd->access;
                 spec.son->getSort->desc;
                 (if desc.label//gram.patternDecl then
                  else (spec,43)->semError if);
             if);
             (*(spec,desc,spec.label)->&SetMode*)
          exit(specSize,access)
          #);
        
        isLib: @ boolean;
     enter isLib (* true if a fragment of ptn-attributes are being translated*)
     do att->AST.ScanList
        (# SetOffSet: @
             (# off: @integer; (* orgOff=0 for virtOff *)
             enter off
             do nameL->AST.ScanList
                (# name: @AST.index
                do currentNode->name;
                   (* align memory offset *)
                   (if specSize
                    // 1 then (* no align *)
                    // 2 then (* align to 2 bytes *) (off mod 2) + off->off
                    // 4 then (* align to 4 bytes *)
                       ((4 - (off mod 4)) mod 4) + off->off
                    else (* 8 or n*4, n>1, align to 8 bytes*) 
                       (* OBS! This must be reconsidered, since it will not
                        * work with parts objects having real objects
                        *)
                       ((8 - (off mod 8)) mod 8) + off->off
                   if);
                   off->name.off;
                   off+specSize->off;
                   access->name.access
                #)
             exit off
             #);
           
           D,EV,nameL,desc,spec,sort,N: @ AST.index; 
           specSize,access: @integer;
           
           LibErr: @ (#do(if isLib then (D,31)->&SemError if)#)
           
        do currentNode->D; 192->trace(#do D[]->xA #);
           true->hasAttributes;
           (if not D.isSlot then
               D.son->nameL; false ->isCst; common.direct->access;
               (if D.label
                // gram.simpleDecl then (* (simple <nameLst> <dataSpec>) *)
                   LibErr;
                   (nameL.brother,false)->chkSpec->(specSize,access);
                   (offCount)->SetOffSet->offCount;
                // gram.repetitionDecl then
                   LibErr;
                   nameL.brother->EV; EV->ChkIndex;
                   (EV.brother,true)->chkSpec->(specSize,access);
                   common.repDopeSize*4->specSize;
                   (offCount)->SetOffSet->offCount;
                   true->hasAcode
                // gram.patternDecl then 
                   nameL.brother->desc;
                   (*nameL->isSingleName ->N;*)
                   (desc[],0,0,N[])->DS.put;
                   false->insertable
                // gram.virtualDecl then
                   LibErr;
                   nameL->isSingleName->N;
                   nameL.brother->spec->&GetDesc->desc;
                   (if spec.label 
                    // gram.objectDescriptor // gram.unExpanded then 
                       common.direct->access
                    else 
                       (spec,spec->&GetSort,false)->&isNonSimplePtn;
                       (if (desc.origin->thisDesc.equal) then
                           common.direct->access
                        else common.cstInd->access                       
                       if)
                   if);
                   (if desc.label
                    //gram.virtualDecl 
                    //gram.bindingDecl //gram.unexpanded then 
                       (spec,32)->&SemError
                   if);
                   4->specSize; (* size of virtual entry in prototype *)
                   (virtOff)->SetOffSet->virtOff;
                   false->insertable
                // gram.bindingDecl //gram.finalDecl then
                   LibErr;
                   (D,nameL,nameL.brother,preDesc)->&CheckBinding;
                   false->insertable
     if)if)#)#);
   
   ChkIndex:
     (# inx,inx1: @ AST.index; eK,cstVal,n,type: @integer; hasCode: @boolean
     enter inx
     do (if inx.label
         // gram.SimpleIndex then inx.son->inx1
         // gram.namedIndex then inx.son->inx1; inx1.brother->inx1
        if);
        (thisDesc,inx1,key.exitt)->&ChkEval->(eK,cstVal,n,hasCode,type);
        (ThisDesc,inx,UnaryCompKind,inx1,valType,inx1,type)->&CmpLst
     #);
   
   
   ChkImpLst: 
     (# IL: @ AST.index
     enter IL
     do IL->AST.ScanList
        (# imp,lab: @ AST.index; oldRelInsOff: @integer
        do currentNode->imp; 
           193->trace(#do (*offcount->xI;*) imp[]->xA #); 
           false->isCst;
           relInsOff->oldRelInsOff; 
           (if imp.label
            // gram.labelledImp then
               imp.son->lab; 
               (common.labelSize*4->tmpSto.Alloc)->lab.off;
               lab.brother->&ChkImpLst
            // gram.restartImp // gram.leaveImp then
               imp.son->lab->&SetUp; lab->isLab
            // gram.forImp then imp->&ChkFor
            // gram.generalIfImp then imp->&ChkIf
            // gram.simpleIfImp then imp->&chkSimpleIf
            // gram.innerImp then 
               imp.son->lab; 
               (if lab.label//gram.empty then 
                   (if singular then (imp,97)->Warning if);
                   true->innerFound
                else  (* inner P *)
                   (# D: @AST.index; isVirt,K: @integer
                   do lab->&SetUp;
                      (lab[],thisDesc,lab.on,2(*inner*))->isEnclosing;
                      (thisDesc,lab)->actualDesc->(D,K);
                      (*lab.DescRef->(D,isVirt);*) D.kind->K;
                      (@@K,true)->TOS'%putBits[12,1]'; K->D.kind
               #)if)
            else (* evaluation*) (thisDesc,imp,key.single)->&chkEval
           if);
           oldRelInsOff->relInsOff
     #)#);
   
   ChkSimpleIf:
     (* <SimpleIfImp> = (<eval> <thenPart> <elsePartOpt>) *)
     (# imp,eval,thenP,elseP: @AST.index;
        hasCode: @boolean; eK,cstVal,n,type: @integer
     enter imp
     do imp.son->eval; eval.brother->thenP; thenP.brother->elseP;
        (thisDesc,eval,key.exitt)->&ChkEval->(eK,cstVal,n,hasCode,type);
        (ThisDesc,imp,unaryCompKind,eval,boolType,eval,type)->&CmpLst;
        thenP->&ChkImpLst;
        (if elseP.label//gram.elsePart then elseP.son->&ChkImpLst if)
     #);
   ChkIf:
     (# imp,alt,elseP,eval: @ AST.index; off,type,typeKind: @integer;
        hasCode: @boolean; eK,cstVal,n: @integer
     enter imp
     do imp.son->eval; eval.brother->alt; alt.brother->elseP;
        (*  (if E0 ..... if) *)
        (thisDesc,eval,key.exitt)->&ChkEval->(eK,cstVal,n,hasCode,type);
        alt->AST.ScanList    (*         // E1 ... then I1  *)
        (# selLst,impL: @ AST.index;
        do currentNode->selLst;
           selLst.son->selLst; selLst.brother->impL;
           selLst->AST.ScanList (*   // E1 // E2 ... // En *)
           (# sel,selEV: @ AST.index
           do currentNode->sel; 
              (ThisDesc,sel.son->selEV,key.exitt)->&ChkEval
                ->(eK,cstVal,n,hasCode,typeKind);
              (ThisDesc,sel,BinaryCompKind,eval,type,selEV,typeKind)
                ->&CmpLst->typeKind
           #);
           impL->& ChkImpLst
        #);
        (if elseP.label // gram.elsePart then elseP.son->&ChkImpLst if);
            (* allocation of tmp. location for E in (if E // ... if).
             * Note that the allocation is NOT sequential. If-, for-imp
             * inside then-parts of if are allocated BEFORE allocation
             * of tmp. for E, since the inner parts have been checked above
             *)
        (* the folloiwng check should be superflous, since is done
         * in cmpLst already
         *)
        (if typeKind
         // boolType // cBoolType 
         // valType // cValType  
         // charType // charType // primType then
            (* common.ifSize*4->TmpSto.Alloc->off*)
         // VIrefType // CIrefType // VCrefType // CCrefType 
         // noneType // vStrucType // cStrucType then
            (*common.ifSize*4->TmpSto.Alloc->off;*)
            (*-off->off;*) (* hack to mark this location as a reference *)
         // realType //cRealType then 
            (* ((8 - (offCount mod 8)) mod 8) + offCount->offCount;*)
            (* common.ifSize*4+4->TmpSto.Alloc->off*)
         else
            (eval,51)->&SemError
        if);
        (*(off,1)->imp.PutAttribute*)
     #);
   
   ChkFor: 
     (# imp,index,name,impL: @ AST.index; off: @integer
     enter imp
     do (common.forSize*4->TmpSto.Alloc->off,1)->imp.PutAttribute; 
        imp.son->index; index.brother->impL;
        (if index.label // gram.NamedIndex then
            index.son->name; off(*-thisDesc.originOff*)->name.off;
            (if isDoPartForm then
                (*common.direct*) 3 (*index*)->name.access
        if)if);
        index->&ChkIndex; impL->&ChkImpLst; 
        (off,common.forSize*4)->TmpSto.deAlloc
     #);
   

   
   ChkObjSize:
     (#
     do (if (offCount>32760) then (desc,28)->&SemError if);
     #);
   
   ChkDataKind:
     (#
     do (* the following is to ensure that attributes can refer to the 
         * descriptor being checked 
         *)
        (desc[],dataKind,hasNcode,hasDo,hasXcode,isData,innerFound
        ,insertable,descAccess,hasAcode,hasOnlyInner,false,false,false,0(*?*))
          ->MarkDesc;
        att->AST.scanList
        (# decl: @AST.index
        do currentNode->decl;
           (if decl.label // gram.simpleDecl then (* ok*)
               (* only basic patterns and data-objects allowed in:
                * <SimpleDecl>  ::= <Names> ':' <referenceSpecification>;
                * <referenceSpecification> ::| <StaticItem> | <DynamicItem> 
                *  | <StaticComponent> | <DynamicComponent> | <VariablePattern>
                * <StaticItem> ::= '@' <ObjectSpecification>;
                * <DynamicItem> ::= '^' <AttributeDenotation>;
                * <StaticComponent> ::= '@' '|' <ObjectSpecification>;
                * <DynamicComponent> ::= '^' '|' <AttributeDenotation>;
                *)
               decl.son->decl; decl.brother->decl; 
               (if decl.label
                //gram.variablePattern then (decl,89)->semError
                else
                   decl.son->decl;
                   (if decl.label//gram.objectDescriptor then
                       (decl,89)->semError
                    else
                       (if (decl->GetDesc->sematt.DescKind)
                        // standardKind//dataKind then
                        else (decl,89)->semError
               if)if)if)
            else (decl,89)->semError
           if)
        #);
        (if (entP.label<>gram.empty) then
            (* only local names in enter-part*)
        if);
        (if (doP.label<>gram.empty)  then (doP,90)->semError if);
        (if (exitP.label<>gram.empty) then
            (* only local names in exitr-part*)
        if)
     #);
   ChkCprocDesc:
     (# handleVarPtnPar:
          (# theDesc: @AST.index; theParam: ^AST.index; PL: @integer
          enter(theDesc,theParam[])
          do theDesc.son->getDesc->theDesc;
             (* for some reason theDesc=sort for varPtn, see getCatsort *)
             (if theDesc->sematt.DescKind//unDefined then
                 (* enforce checking *)
                 (theDesc[],false,theParam[],-1)->&ChkDesc
             if); 
             theDesc->DescChain->(theDesc,PL);
             (if (theDesc->cProcDesc.equal) then 
              else  (theParam,34)->&SemError 
             if)
          #);
        handlecStrucPar:(* check if sub of cStruc *)
          (# theDesc: @AST.index; theParam: ^AST.index; PL: @integer
          enter(theDesc,theParam[])
          do (*192->trace(#do'handleCstrucPar:'->T;
                          theDesc[]->A
                       #);*)
             (if (theDesc->semAtt.descKind) = undefined then
                 (* enforce checking!!*)
                 (theDesc[],false,theParam[],-1)->&chkDesc
              else (*192->trace(#do 'No check of cStruc'->T #)*)
             if);
             theDesc->&DescChain->(theDesc,PL);
             (*192->trace(#do 'After DescChain'->T #);*)
             (if not (theDesc->semAtt.cStrucDesc.equal) then
                 (if theDesc->semAtt.cProcDesc.equal then
                  else (if not (theDesc->sematt.dataDesc.equal)
                           then (theParam,34)->&SemError 
             if)if)if)
          #);
        checkForVirtuals:
          (#
          do att -> AST.scanList
             (# D,spec,nameL: @AST.index; K: @integer
             do currentNode -> D;
                (if not D.isSlot then
                    (if D.label 
                     // gram.virtualDecl then
                        'Virtual external'->putline;
                        D.son -> nameL; nameL.brother -> spec;
                        (if spec.label = gram.objectDescriptor then
                            (spec[],false,NONE,-1) -> chkDesc;
                            spec.kind -> K;
                            (externalVirtualKind,0) -> K.%putByte;
                            K -> spec.kind;
                         else
                            'error'->putline
                        if)
                    if)
                if)
             #)
          #);
             
        father: @AST.index; descKind: @integer
     do thisDesc.father->father;
        (if father.label<>gram.patternDecl then (thisDesc,98)->&SemError if);
        checkForVirtuals;
        (thisDesc[],true)->ScanCNX
        (# cStrucPar::< (#do (theDesc,theParam[])->handlecStrucPar #);
           varPtn::< (#do (theDesc,theParam[])->handleVarPtnPar #);
           error::<(#do (theParam,34)->&SemError #)
        #);
        (if (((thisDesc[],false)->ScanCNX
            (# cStrucPar::< (#do (theDesc,theParam[])->handlecStrucPar #);
               varPtn::<(#do (theDesc,theParam[])->handleVarPtnPar #);
               error::<(#do (theParam,34)->&SemError #)
            #)
            ) >1)
            then (exitP,35)->&SemError
        if);
        (if id[] = NONE then (* if called form getSpecSize: NONE or NULL  *)
            &AST.index[]->id[];
        if);
        (if id.isNull then father.son->isSingleName->id if);
        (*193->trace(#do 'cProcDecoderC id[]='->T; id[]->A #);*)
        (NONE,id.getText,thisDesc[],NonVirtualForm)
          ->cProcDecoder
        (# 
        do (if extKind (* test if a call-back routine *)
            //sematt.cCallBackExt//semAtt.PascCallBackExt
            //semAtt.StdCallbackExt then
               callBackKind->descKind;
               offCount -> thisDesc.returnOff;
               offCount + 8 -> offCount -> thisDesc.size;
               (* clean-up below may be necessary *)
            else
               externalKind->descKind
           if);
           (if explicitCallId and (extKind <> PascTrapExt) then
               callId.scanAll(#do (if ch <= ' ' then (extEntry,112)->&Warning
           if)#)if)
        #);
        (* 0->ThisDesc.size->ThisDesc.virtSize;*)
     exit descKind
     #);
   ClassifyDesc:
     (* A descriptor may be classified as: 
      *    inlineDO
      *    inlineNX
      *    hasOnlyNX
      *
      * a descriptor is inlineNX if it has the form
      * 
      *    P(# ... enter(a,b,c) exit E #)
      * 
      * where
      * 
      * - P must be inlineNX
      * - a,b,c must be simple integer, boolean, char or shortint variables
      * - E must be a simple expression
      *   - simple variables, including R[e1] (e1 simple), S.p,
      *   - binary and unary operators
      *   - NO assignments,
      *   - NO object executions
      *   - dynamic generations?
      *   - No computed object evals
      *   - eval list OK
      *   - constants OK
      *   - text constants?
      *   - structure refs?
      *   - repetition slice?
      *   - primitives, unaryPrimitive OK
      *   - address OK
      * 
      *)
     (#
        putKind: (# k: @integer
                 enter k
                 do (if k
                     // 0 then 'Undef:'->puttext
                     // constEval then 'Const:'->puttext
                     // simpleVarListEval then 'VarList:'->puttext
                     // simpleExpEval then 'SimpleExp:'->puttext
                     // generalEval then 'General'->puttext
                     else 'Very undef:'->puttext
                 if)#);
     do (*196->trace
        (#
        do 'Enter:'->xT; nExpKind->putKind;
           'Exit:'->xT; xExpKind->putKind;
         #);*)
        (if (descKind = generalKind) 
            and not hasDo 
            and (nExpKind = simpleVarListEval)
            and (xExpKind = simpleExpEval) then            
            (if preDesc.isNull then true->inlineNX
             else
                sameOriginAsSuper and (preDesc[] ->sematt.inlineNX) 
                  -> inlineNX
        if)if);
        (if not inlineNX then
            (if not (hasSuper or hasAttributes or hasNpart or hasXpart) then
                (if switch[212] then 
                   (if desc.size = 12 then 
                       (*191->trace(#do '\OnlyDo'->putLine #);*)
                       true->inlineDO 
                if)if)
            if);
            (* disjoint properties?*)
            (if not (hasSuper or hasAttributes or hasDo) then
                (*195->trace(#do 'ChkDescBody:onlyNX:'->T #);*)
                (if hasSuper then
                    preDesc[]->sematt.hasOnlyNX->hasOnlyNX
                 else true->hasOnlyNX
            if)if);
        if);
        (*196->trace(#do'IsInline:'->T; inlineNX->I; newline #)*)
     #);
   
   isCst: @boolean;  descVal: @ integer; 
   expKind,nExpKind,xExpKind: @integer;
   
   isCproc
   ,isDoPartForm: @boolean;
   type,nSize,nTmpSize,xSize,xTmpSize: @integer;
   descKind,preKind, preType: @integer;
   (* innerFound declared in docheck *)
   hasSuper,hasNpart,hasXpart,hasAttributes, sameOriginAsSuper
   ,hasNcode,hasDo,hasXcode,inlineNX,inlineDO,hasOnlyNX
   ,isData,insertable,hasAcode,hasOnlyInner: @boolean;  
   descAccess: @integer; 
   (* action-part of ChkDesc;
    * enter par. desc is not necessarily a descriptor,
    * enter par. id is origin if desc.label = doPart
    *);
   pre,mainP,att,entP,exitP,doP: ^ AST.index;
   father: @AST.index
do 191->trace(#do desc[]->xA #);
   (if desc.label 
    // gram.objectDescriptor then 
       desc->ThisDesc;
       (if (thisDesc->sematt.descKind)//sematt.beingChecked then
           (desc,19)->&SemError;
           0->ThisDesc.size; false->descOK
        else
           desc[]->descSonsRef->(pre[],mainP[],att[],entP[],doP[],exitP[]);
           thisDesc[]->sematt.markBeingChecked;
           common.direct->descAccess; 
           (if insertOff = -1 then
               (* 'normal' checking of descriptor *)
               0->offCount; (*true->isCst; *)
               desc.father->father;
               (if not father.isNull then
                   father.label=gram.patternDecl -> isCst
               if);
               &ChkPre->preKind(*isCproc*);
               false->&ChkAtt;
               (* align data attributes before allocation in do-part.
                * But why is this necessary?
                * Eliminated 29.4.93.
                * Changed to 4-byte align. 17.10.93
                *)
               ((4 - (offCount mod 4)) mod 4) + offCount->offCount;
            else
               (* ChkDesc is called with insertOff>-1 for 
                * singular inserted items
                * in the do-part of an object-descriptor:
                *    (# ... do ...; (#do ... #); ... #)
                * A singular insterted item is insertable if it has no superptn
                * and no attributes.
                * The descriptor is marked as insertable.
                * Tmp. attributes (for,label) are allocated in 
                * the enclosing object.
                * OriginOff of the descriptor is defined to be the same
                * as for its origin and desc.origin is defined to be
                * origin of its descriptor. (does not work)
                *)
               (# D: @AST.index; K: @integer
               do true->insertable; 4->virtOff;
                  desc.kind->K;
                  (@@K,true)->TOS'%putBits[13,1]';
                  K->desc.kind;
                  desc->D;
                  (if D.label//gram.objectDescriptor then
                      D.origin->D;
                      (*310->trace(#do 'Comp.desc origin:'->T; D[]->A #);*)
                      findDescNode:
                        (if D.label
                         //gram.objectDescriptor then (*ok*)
                         // gram.descriptorForm // gram.attributesForm then
                            D.xOrigin->D;
                            restart findDescNode
                         // gram.unExpanded then
                            D.slotOrigin->D; 
                            restart findDescNode
                         // gram.doPart then
                            (if D.descNo//0 then (* no tmp. data *)
                                D.xOrigin->D;              
                                restart findDescNode 
                            if)
                         //gram.mainPart then
                            D.xOrigin->D; restart findDescNode
                         else (* forL repetition etc *)
                            D.origin -> D;
                            restart findDescNode
                        if)
                   else 'Error 2 in simple insertion!'->systemError
                  if);
                  (* Note that: desc[]->sematt.descOrigin->D[]; 
                   * don't for for nested inserted descriptors, i.e. if
                   * descorigin is insertable, then we get the wrong size
                   * for initializing offCount
                   *)
                  insertOff(*D.size*)->offCount;
                  D.originOff->desc.originOff;
                  (*310->trace(#do'Inserted desc:originDesc: '->T; offcount->I;
                   D[]->A#);*)
                  (*D.origin->desc.origin*)
               #)
           if);
           (if entP.label <> gram.empty then
               (ThisDesc,entP.son,key.enterr)
                 ->&ChkEval
                 ->(nExpKind,DescVal,nSize,hasNcode,type);
               (if hasNcode then
                   offCount->entP.NXoff; (* fix *)
                   (*offCount+nTmpSize->offCount*)
                else 0->entP.NXoff
               if);
               nSize->entP.NXsize; 
               false->isCst; 
               true->hasNpart;
            else
               simpleVarListEval -> nExpKind
           if);
           (* Allocate space for Return in INNER-dispatch;
            * INNER-dispatch space is allocated unless the descriptor has 
            * (1) a do-part and a super with NO inner, or
            * (2) no do-part and a super
            *)
           (if common.switch[66] then virtOff + 4 -> virtOff if);
           (if doP.label <> gram.empty then
               (if pre.label = gram.prefix then
                   (if not (preDesc[]->sematt.hasInner) then
                       (preDesc[],desc[]) -> NoInner;
                       (* deallocate INNER-dispatch *)
                       (if common.switch[66] then virtOff - 4 -> virtOff if)
               if)if);
               false->isCst; true->hasDo;
               (if not doP.isSlot then
                   doP->&ChkImpLst
                else true->innerFound
               if)
            else
               (if pre.label = gram.prefix then
                   (* deallocate INNER-dispatch;
                    * No do-part and a superPtn
                    *)
                   (if common.switch[66] then virtOff - 4 -> virtOff if)
           if)if);
           (if exitP.label <> gram.empty then
               (ThisDesc,exitP.son,key.exitt)
                 -> &ChkEval
                 -> (xExpKind,descVal,xSize,hasXcode,type);
               (if hasXcode then
                   offCount->exitP.NXoff;
                   (*offCount+xTmpSize->offCount*)
                else 0->exitP.NXoff
               if);
               xSize->exitP.NXsize;
               (if preType <> emptyType then listType->type if);
               hasXpart;
            else
               preType->type;
               simpleExpEval->xExpKind
           if);
           (if mainP.isSlot then
               generalKind->descKind; true->hasDo; true->innerFound;
               false->isCst; common.cstInd->descAccess
           if);
           isCst and (xExpKind = constEval) -> isCst; 
           (if not preDesc.isNull then
               (preDesc[]->semAtt.hasNcode) or hasNcode ->hasNcode;
               (preDesc[]->semAtt.hasXcode) or hasXcode ->hasXcode;
           if);
           (if isCst then
               (*194->trace(#do desc[]->A; L; descVal->I #);*)
               descVal->ThisDesc.virtSize;
               constKind->descKind
            else 
               InsLst.alloc;
               (* align to 4 bytes *)
               (*((8 - (offCount mod 8)) mod 8) + offCount->offCount;*)
               offCount ->ThisDesc.size; virtOff-4->ThisDesc.virtSize;
               ChkObjSize; generalKind->descKind;
           if);
           (if preKind
            // externalKind // callBackKind then &ChkCprocDesc->descKind 
            // dataKind then &ChkDataKind; dataKind->descKind
           if);
           True->descOK;
           
           NOT (hasNcode or hasDo or hasXcode)->isData;
           L:
             (if (desc[]->sematt.hasInner) or innerFound then
                 (*inner P*) true->innerFound;
                 (if doP.isSlot=false then
                     doP->AST.scanList
                     (# imp: @AST.index; i: @integer
                     do (if (i+1->i) > 1 then false->hasOnlyInner; leave L if);
                        currentNode->imp;
                        (if imp.label<>gram.innerImp then leave L if);
                        (if preDesc.isNull then true->hasOnlyInner
                         else
                            preDesc[]->sematt.hasOnlyInner->hasOnlyInner
             if)#)if)if);
           ClassifyDesc;
           (desc[],descKind,hasNcode,hasDo,hasXcode,isData,innerFound
           ,insertable,descAccess,hasAcode,hasOnlyInner
           ,inlineNX,inlineDO,hasOnlyNX,type)
             ->MarkDesc;
           (if switch[196] then desc[]->&DumpDesc if)
       if)
           (* 195->trace(#do desc[]->A #) *)
    // gram.attributesForm then
       (# A: @ AST.index
       do desc.son->A; A[]->att[];
          desc.xOrigin->desc->thisDesc; (*!!!!!!!!!!???????????????????*)
          0->offCount; True->&ChkAtt
          (*illegal recursive checking of att-form should not be possible*)
       #)
    // gram.doPart then
       (# theForm,theSlot: @ AST.index;
          adjustOn:
            (# n: @AST.index
            enter n
            do (*192->trace(#do n[]->A #);*)
               (if not n.isNull then
                   (if n.label
                    //gram.nameApl then n.on+1->n.on (*true->n.inDoPart*)
                    //gram.nameDcl//gram.textConst//gram.integerConst//gram.empty
                       then
                    else 
                       (if n.nodeClass
                        // AST.kinds.cons then 
                           n.son->n->&adjustOn; 
                           n.brother->n;
                           L: (if not n.isNull then 
                                  n->&adjustOn; 
                                  n.brother->n;
                                  restart L
                              if)
                        // AST.kinds.list then
                           n->AST.scanList(#do currentNode->&adjustOn #)
            if)if)if)#)
       do desc->theForm;
          theForm.xOrigin->theSlot; theSlot.slotOrigin->thisDesc;
               (*192->trace(#do thisDesc[]->A #);*)
          &AST.index[]->doP[];
          theForm.son->doP;
          (* fix storage allocation *)
          (*thisDesc.size->offCount;*)
          (* simple data object
           * 0 : simple prototype id
           * 4 : GC field
           * 8 : origin
           * 12: size
           * 16: tmp data 1
           * ..:
           *)
          true->isDoPartForm; (* not used?*)
          (if theForm.descNo>0 then 
              theForm->thisDesc
          if);
          16->offCount;
          doP->&ChkImpLst;
          (* align*)
          (if offCount//16 then (* no tmp. att. allocated *)
              0->offCount;
              (if theForm.descno>0 then
                  '\nInconsistencies in tmp. sto. allocation for doPart\n'
                    ->bugstream.puttext
              if)
           else
              ((8 - (offCount mod 8)) mod 8) + offCount->offCount;
              (* on att must be incremented by one for all nameApl in doP*)
              (*doP->adjustOn;*)
          if);
          (*192->trace
           (#do (if offCount//0 then 'No '->T if); 'tmp.att.''s needed'->T#);*)
          offCount->theForm.descNo; 
          (*!!!!!!! ChkImpLst may allocate storage for possible for-imp, etc.
           * the size is stored en theForm.descNo. This is a hack.
           * Se  also control.bet where descNo is cleared for forms
           * other than doPart and mainpart
           *)
          ChkObjSize;
       #)
    // gram.mainPart then
       (* A lot seems to be missing here! How is the size of
        * the descriptor/mainpart computed?  It should be
        * computed from the size of the prefix. Where is
        * the size stored? It cannot be stored in the
        * descriptor node, since it is in the origin.
        * It must be stored in the mainpart.
        * Enter/exit may also be visible if the fragment is included
        *)
       id->thisDesc; (* not correct *)
       &AST.index[]->att[];&AST.index[]->entP[];
       &AST.index[]->doP[];&AST.index[]->exitP[];
       Desc.son->att; att.brother->entP; entP.son->entP;
       entP.brother->doP; doP.brother->exitP;
       (if (doP.label<>gram.empty) then
           (if not doP.isSlot then
               doP.son->doP (* impList of doPart *)
       if)if);
       (* pre is missing *)
       false->&ChkAtt;          
       doP->&ChkImpLst; (* enter/exit  is missing *)
   if)
#) (* ChkDesc *)

