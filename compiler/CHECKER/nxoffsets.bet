ORIGIN 'sematt';
LIB_ITEM 'betacompiler';
---semattLib:attributes---
NXoffSets: 
     (# <<SLOT NXoffSetsLib:attributes>>;
        testAndCheckDesc:<
          (# desc: ^ASTindex
          enter desc[]
          do INNER
          #);
     
        startOff: @integer;
        off: [10] @integer;
        size: [10] @int16u;
        kind: [10] @int16u;
        node: [10] ^ASTindex;
        superCh: [10] ^BV.superChain;
        next,top: @integer;
        valTmp: (#exit 1 #);
        refTmp: (#exit 2 #);
        repTmp: (#exit 3 #);
        valOff: (#exit 4 #);
        refOff: (#exit 5 #);
        repOff: (#exit 6 #);
        strucOff: (# exit 7 #);
        strucTmp: (# exit 8 #);
        Mark:
          (# E: ^ASTindex; chain: ^BV.superChain; byteSize: @integer
          enter(E[],chain[],byteSize) (* not used *)
          do (If ctst then
                 179->trace(#do 'Alloc'->xT; startOff->xI #)
             if);
             (if (top+1->top) > off.range then
                 off.range -> off.extend;
                 size.range -> size.extend;
                 kind.range -> kind.extend;
                 node.range -> node.extend;
                 superCh.range -> superCh.extend
             if);
             E[] -> node[top][];
             chain[] -> superCh[top][];
             INNER Mark
          #);
        Alloc: Mark
          (#
          do (if byteSize < 8 then
                 startOff -> off[top];
                 startOff + 4 -> startOff;
                 4 -> size[top]; (* currently size is 4; could be 
                                  * optimized for int8,int16,etc.
                                  * Note: size=4 is necessary for ref/rep
                                  * as none -> calls stCst
                                  *)
              else
                 ((8 - (startOff mod 8)) mod 8) + startOff -> startOff;
                 startOff -> off[top];
                 startOff + byteSize -> startOff;
                 byteSize -> size[top];
             if);
             INNER Alloc 
          #);
        AllocVal: @ Alloc(#do valTmp -> kind[top] #);
        AllocRef: @ Alloc
          (# isStruc: @boolean
          enter isStruc
          do (if isStruc then
                 strucTmp -> kind[top] 
              else
                 refTmp -> kind[top] 
             if)
          #); 
        AllocReP: @ Alloc(#do repTmp -> kind[top] #); 
        MarkOff: Mark
          (# of: @integer 
          enter of
          do of -> off[top];
             INNER MarkOff
          #);
        MarkVal: @ MarkOff
          (# 
          do valOff -> kind[top]; byteSize -> size[top]
          #);
        MarkRef: @ MarkOff
          (# isStruc: @boolean
          enter isStruc
          do (if isStruc then
                 strucOff -> kind[top] 
              else
                 refOff -> kind[top] 
             if)                 
          #);
        MarkRep: @ MarkOff(#do repOff -> kind[top] #);
        getNext:
          (#
          do next+1 -> next; 
             (if next > top then '\n*** NXlist overflow'->putline if)
          exit off[next]
          #);
        getKind: (#exit kind[next] #);
        getNode: (#exit node[next][] #);
        getChain: (#exit superCh[next][] #);
        getSize: (#exit size[next] #);
        displayCurrent: (#do ' '->put; next->displayItem; ' '->put  #);
        displayCurrent1: (#do ' '->put; next+1->displayItem; ' '->put #);
        displayItem:
          (# ix: @integer
          enter ix
          do (node[ix][],tracestream[],100) -> thePP;
             kind[ix] -> displayKind;
             off[ix] -> tracestream.putint; ','->put;
             size[ix] -> tracestream.putint;
          #);
        displayKind:
          (# K: @integer
          enter K
          do (if K
              // valTmp then ':valTmp:'->puttext
              // refTmp then ':refTmp:'->puttext
              // repTmp then ':repTmp:'->puttext
              // valOff then ':valOff:'->puttext
              // refOff then ':refOff:'->puttext
              // repOff then ':repOff:'->puttext
              // strucOff then ':strucOff:'->puttext
              // strucTmp then ':strucTmp:'->puttext
             if);
          #);
        dump:
          (#
          do 'NXoffSets(next:'->putText; next->putint; 
             ',top:'->puttext; top->putint; ';'->put;
             (for i: top repeat
                  i -> displayItem;
                  (if i<top then ','->put if)
             for);
             ')'->put
          #)
     #);

