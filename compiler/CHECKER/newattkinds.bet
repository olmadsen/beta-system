ORIGIN 'sematt'; 
LIB_ITEM 'betacompiler';
---semattLib:attributes---
(*-------------------- desc kind -------------------
 *  descriptors are classified into
 *  beingChecked: curently being checked by chkDesc
 *  undefined: has not yet been checked
 *  standard: like integer, boolean, char, true, ...
 *  const:    like integer, (#exit 9#),
 *  cProc:    a direct subpattern of Cproc 
 *  general:  a general user defined pattern
 * 
 *  In addition various properties are associated with each  descriptor
 *
 *  descKind and the properties are packed into the AST attribute 'kind':
 *  descKind   = kind
 * 
 *  hasNcode   = kind[0]
 *  hasDcode   = kind[1]
 *  hasXcode   = kind[2]
 *  isData     = kind[3]
 *  hasInner   = kind[4]
 *  insertable = kind[5]
 *  descAccess = kind[6]
 *  interpreted= kind[7]  used by interpreter: descriptor is interpreted
 *  hasAcode   = kind[8]  Allocation-code is needed (non-empty G-part)
 *  hasOnlyInner= kind[9] On the form P(# ... do inner #), where P also
 *                         hasOnlyInner - enter/exit-parts may appear
 *  inlineNX    = kind[10] Form: (# a,b,c: @integer enter(a,b,c) exit E #)
 *                         Code is inlined
 *  inlineDO    = kind[11] 
 *  hasonlyNX   = kind[12]
 * 
 * 
 *  enter/exit  = kind[13:14] Used by compciler to check for recursion
 *                            in enter/exit list; chklst.bet
 * 
 *  type        = type  The type of basic patterns like
 *                            boolean, char, short, integer, real
 * 
 *)

bit0: (# exit 2x0000000000000001 #);
bit1: (# exit 2x0000000000000010 #);
bit2: (# exit 2x0000000000000100 #);
bit3: (# exit 2x0000000000001000 #);
bit4: (# exit 2x0000000000010000 #);
bit5: (# exit 2x0000000000100000 #);
bit6: (# exit 2x0000000001000000 #);
bit7: (# exit 2x0000000010000000 #);
bit8: (# exit 2x0000000100000000 #);
bit9: (# exit 2x0000001000000000 #);
bit10: (# exit 2x0000010000000000 #);
bit11: (# exit 2x0000100000000000 #);
bit12: (# exit 2x0001000000000000 #);
bit13: (# exit 2x0010000000000000 #);
bit14: (# exit 2x0100000000000000 #);


beingChecked: (#exit 50(*must be positive*) #);
unDefined: (#exit 0 #);
standardKind: (#exit 1#); constKind: (#exit 2#); 
externalKind: (#exit 3#); generalKind: (#exit 4#);
dataKind: (#exit 5#); callBackKind: (#exit 6#);
externalVirtualKind: (#exit 7 #);
comKind: (#exit 8 #); holderKind: (#exit 9 #);
stateKind: (#exit 10 #);
dispatchKind: (#exit 11 #);  
dispatchVirtualKind: (#exit 12 #); 
classKind: (# exit 13 #);
procKind: (# exit 14 #);
externalClassKind: (# exit 15 #);
consKind: (# exit 16 #);
staticProcKind: (# exit 17 #);
staticConsKind: (# exit 18 #);

kindAstext:
  (# kind: @integer; T: @text
  enter kind
  do (if kind
      // standardKind then 'standard'->T;
      // constKind then 'const'->T;
      // generalKind then 'general'->T;
      // classKind then 'class'->T;
      // procKind then 'proc'->T
      else
         kind->T.putint
     if)
  exit T[]
  #);

insEval: (#exit 1#); simpleEval: (#exit 2#); 
repValEval: (#exit 3#); repRefEval: (#exit 4 #);
itemEval: (#exit 5#); compEval: (#exit 6#); sysKind: (#exit 7#);
repKind: (#exit 8#); realEval: (#exit 9#);

(* enter-exit list are classified using the following categories;
 * see chkEvalBody
 *)
constEval: (#exit 1 #);
simpleVarListEval: (#exit 2 #);
inlineNXeval: (#exit 3 #);
simpleExpEval: (#exit 4 #);
generalEval: (#exit 5 #);

(* for some unknown reason there seems to be a memory leak
 * if the patterns below are made static items!
 * Each of them should at most be able to hold on to one
 * ref., but they seem to hold onto much more??
 *)
(* Operations using D.kind may fail if the descriptor (D) is
 * not an objectDesciptor; this only occurs in very
 * special cases; e.g. compiler/compiler/TST/FEJL/container.
 * Perhaps all the operations below should check that
 * D is a descriptor??
 *)
markBeingChecked: 
  (# D: ^ASTindex; K: @integer;
  enter D[] 
  do  beingChecked -> D.kind;
  #);
descKind:  
  (# D: @ASTindex; K: @integer;
  enter D 
  do (if D.label = gram.ObjectDescriptor then
         D.kind -> K;
     if);
  exit K
  #);
setDescKind:
  (# D: @AstIndex; K: @integer;
     kind: @integer;
  enter (D, kind)
  do kind -> D.kind;
  #);
clearDescKind:
  (# D: @AstIndex;
  enter D
  do 0 -> D.kind_attrib;
     0 -> D.kind;
     0 -> D.mark;
     0 -> D.type;
  #);
has: 
  (# d: ^ASTindex; K: @integer ; B: @boolean
  enter d[] 
  do D.mark -> K; INNER
  exit B
  #);

hasNcode:   has(# do ((K %band bit0) <> 0) -> B  #);
hasDo:      has(# do ((K %band bit1) <> 0) -> B;  #);
hasXcode:   has(# do ((K %band bit2) <> 0) -> B;  #);
isData:     has(# do ((K %band bit3) <> 0) -> B; #);
hasInner:   has(# do ((K %band bit4) <> 0) -> B;  #);
insertable: has(# <<SLOT sematt_insertable:doPart>> #);
descAccess: integerValue
  (# D: ^ASTindex; K: @integer;
  enter D[] 
  do D.mark -> K; 
     (if (K %band bit6) <> 0 then
         1 -> value;
      else
         0 -> value;
     if);
  #);
hasAcode: has
  (#
  do (if common.switch[214] then 
         (if common.switch[64] and not common.switch[65] then 
             true->b
          else
             ((K %band bit8) <> 0) -> B;
         if)
      else true -> B
     if)
  #);
hasOnlyInner: has(# do ((K %band bit9) <> 0) -> B; #);
inlineNX:     has(# do ((K %band bit10) <> 0) -> B; #);
inlineDO:     has(# do ((K %band bit11) <> 0) -> B; #);
hasOnlyNX:    has(# do ((K %band bit12) <> 0) -> B;  #);
type: integerValue       
  (# D: ^ASTindex;
  enter D[] 
  do D.type -> value;
  #);
doPartHasTmp: booleanValue
  (# doP: ^ASTindex
  enter doP[]
  <<SLOT sematt_doPartHasTmp:doPart>>
  #);
MarkDesc:
  (# desc: ^ASTindex; descKind,xType: @Integer; (* byte *)
     hasNcode,hasDo,hasXcode,isData,hasInner,insertable
     ,hasAcode,hasOnlyInner,inlineNX,inlineDO,hasOnlyNX: @boolean;
     descAccess: @integer (* OBS only 0 or 1 *)
  enter(desc[],descKind,hasNcode,hasDo,hasXcode,isData,hasInner
     ,insertable,descAccess,hasAcode,hasOnlyInner,inlineNX,inlineDO
     ,hasOnlyNX,xType)
  do <<SLOT MarkDesc:descriptor>>
  #);
StandardMark:
  (# d: @ASTindex; descKind,type: @integer;
  enter (d,descKind,type)
  do descKind -> D.kind;
     type -> D.type;
     0->D.mark
  #);   
MarkInner:
  (# d: @ASTindex; descKind,K: @integer;
  enter (d,descKind)
  do descKind -> D.kind;
     (K %bor bit4) -> K;
     K->D.mark;
  #);
StandardMarkInner:
  (# d: @ASTindex; descKind,type,K: @integer;
  enter (d,descKind,type)
  do descKind -> D.kind;
     type -> D.type;
     (K %bor bit4) -> K;
     K->D.mark;
  #);
MarkSimplyInner:
  (# D: @ASTindex; K: @integer;
  enter D
  do D.mark->K;
     (K %bor bit4) -> K;
     K->D.mark;
  #);
MarkInsertable:
  (# D: @ASTindex; K: @integer;
  enter D
  do D.mark->K;
     (K %bor bit5) -> K;
     K->D.mark;
  #);
MarkOnlyInner:
  (# d: @ASTindex; kind: @integer
  enter d
  do (* set hasInner = true *)
     D.mark->kind;
     (kind %bor bit4) -> kind;
     (*hasinner*)
     (kind %bor bit9) -> kind;
     (*only inner*)
     kind->D.mark;          
  #);
GetAndSetOp1: booleanValue
  (# D: @ASTindex; K: @integer;
  enter D
  do D.mark -> K;
     (K %band bit13) = bit13 -> value;
     (K %bor bit13) -> K;
     K->D.mark
  #);
GetAndSetOp2: booleanValue
  (# D: @ASTindex; K: @integer;
  enter D
  do D.mark -> K;
     (K %band bit14) = bit14 -> value;
     (K %bor bit14) -> K;
     K -> D.mark
  #);
ClearOp1:
  (# D: @ASTindex; K: @integer;
  enter D
  do D.mark -> K;
     (K %band (%bnot bit13)) -> K;
     K -> D.mark
  #);
ClearOp2:
  (# D: @ASTindex; K: @integer;
  enter D
  do D.mark -> K;
     (K %band (%bnot bit14)) -> K;
     K -> D.mark
  #);
  
---sematt_insertable:doPart---
do (if false (*switch182*) then
       false -> B
    else
       ((K %band bit5) <> 0) -> B;
   if)
   
---sematt_doPartHasTmp:doPart---
do (if false (*switch182*) then
       common.switch[323] and (doP.descNo > 0) -> value
    else
       (doP.descNo > 0) -> value
   if)

---MarkDesc:descriptor---
(# K: @integer;
do (if false then
       (if not common.switch[205] and (descKind = callBackKind) then
           (* callBackKind is ONLY activated when switch[205] is true *)
           externalKind -> descKind
   if)if);
   (if false then
       (descKind  , 2)   -> K.%putByte;
    else
       (if desc.label = gram.ObjectDescriptor then
           descKind -> desc.kind;
       if);
   if);
   
   (if hasNCode then
       (K %bor bit0) -> K;
   if);
   (if hasDo then
       (K %bor bit1) -> K;
   if);
   (if hasXcode then
       (K %bor bit2) -> K;
   if);
   (if isData then
       (K %bor bit3) -> K;
   if);
   (if hasInner then
       (K %bor bit4) -> K;
   if);
   (if insertable then
       (K %bor bit5) -> K;
   if);
   (if descAccess = 1 then
       (K %bor bit6) -> K;
   if);
   (if not common.switch[214] then true -> hasAcode if);
   (if not common.switch[215] then false->hasOnlyInner if);
   
   (if hasACode then
       (K %bor bit8) -> K;
   if);
   (if hasOnlyInner then
       (K %bor bit9) -> K;
   if);
   (if common.switch[211] then 
       (if inlineNX then 
           (K %bor bit10) -> K;
       if);
   if);
   (if common.switch[212] then 
       (if inlineDO then
           (K %bor bit11) -> K;
       if);
   if);
   (if common.switch[213] then 
       (if hasOnlyNX then
           (K %bor bit12) -> K;
       if);
   if);
   
   (if desc.label = gram.ObjectDescriptor then
       xType -> desc.type;
   if);
       (* 166->trace(#do 'Type:'->T; xType->I; newline#);
        * 191->trace(#do (if hasAcode then 'hasAcode'->T if);
        * (if hasOnlyInner then 'OnlyInner'->T if) #);
        *)
   (if desc.label 
    // gram.objectDescriptor then
       K -> desc.mark;
    // gram.doPart then
       '\n *** marking doPart ! ' -> putline
    // gram.mainPart then
       (*  '\n *** marking mainPart ! ' -> putline*)
    // gram.attributes // gram.attributesForm then
       '\n *** marking attributes ! ' -> putline
    else
       '\n *** marking unknown ! ' -> putline
   if)  
#)
