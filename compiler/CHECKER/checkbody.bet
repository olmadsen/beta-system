ORIGIN 'check'
---SysLib:attributes---
find1:
     (# node,F: @ AST.index
     enter node 
     do node->F;
        L: (if F.isNull//false then
               (if F.label//gram.imperatives//gram.attributes then
                   (*'+'->output.put*) (* print F.son=node*)
                else (*'^'->output.put;*) F->node; node.father->F; restart L
           if)if)
     exit node
     #)
--CheckState:descriptor--
(# pd,md: [8] ^AST.index; (* list of pairs, preDesc, desc, where preDesc
                           * has no inner. To be finally checked by
                           * CheckNoInner
                           *)
   top: @integer;
   warn: [8] ^AST.index; err: [8] @integer; wTop: @integer;
   errCount: @integer
#)
--semError:descriptor--
(# find2:
     (# node,F,start,oldNode: @AST.index; lc: @integer
     enter node
     do node->F;
        L:
          (if F.isNull// false then
              node->oldNode;
              F->node;
              (if node.label //gram.objectDescriptor //gram.unExpanded then
                  '@'->messagestream.put;
                  n+1->n;
                  node.father->node (* print *)
               else
                  (if node.nodeClass//AST.kinds.list then
                      '>'->messagestream.put;
                      node.son->start;
                      0->lc;
                      M:
                        start->AST.scanList
                      (# node1: @ AST.index
                      do (if (lc+1->lc)>3 then
                             '+'->messagestream.put;
                             start.brother->start
                         if);
                         currentNode->node1;
                         (if node1->oldNode.equal then
                             '='->messagestream.put;
                             leave M
                      if)#);
                      (if lc>5 then
                          '3'->messagestream.put;
                          lc+n->n; start->node;
                          leave L
                      if);
                      lc+n->n;
                      n+1->n;
                      node.father->F;
                      restart L
                   else
                      (if n>5 then '5'->messagestream.puttext
                       else
                          '^'->messagestream.put;
                          node.father->F;
                          n+1->n;
                          restart L
          if)if)if)if)
        (* print node *)
     exit node
     #);
   n: @integer; node1,node2: @AST.index

do true -> error -> fatalError;
   (if not node.LocalErr then
       CheckState.errCount+1->CheckState.errCount;
       (if CheckState.errCount=1 then
           node.frag[]->semanticErrors; (* notification in system.bet *)
       if);
       errNo -> node.markerror;
       messagestream.newline;
       (*(node[],screen[],15) -> thePP; '-------'->messagestream.puttext;*)
       node->find1->node1;
       messagestream.newline;
       (node1[],messagestream[],20) -> thePP;	 
       (*'-------'->messagestream.puttext; node->find2->node2; messagestream.newline;
        (node2[],screen[],2+n) -> thePP;	 *)
       '--------------------------------------------' -> messagestream.puttext;
       (if errNo//0 then stop if)
   if)
#)
--warning:descriptor--
(* Warning are delayed until after the checking is completed.
 * A node can only hold one error message or one warning.
 * A warning on a node will thus block for an error message.
 * The warnings will therefore first be inserted in the AST after
 * the checking. I.e. when no more errors can occur.
 *)
(#
do L:
     (#do
        (if errNo
         // 24 (* qua*) then
            (if (not switch[60]) and (switch[42] or switch[19]) then
                leave L
            if)
         // 95 (* ^R.P dynamic *) then (if switch[90] then leave L if)
        if);
        (* all other warnings cannot be suppressed *)
       (if not node.localErr then
           (if (CheckState.wTop+1->CheckState.wTop)>CheckState.warn.range
               then
               CheckState.warn.range->CheckState.warn.extend; 
               CheckState.err.range->CheckState.err.extend
           if);
           node[]->CheckState.warn[CheckState.wTop][];
           errNo->CheckState.err[CheckState.wTop]  
       if)
     #)
#)
--noInner:doPart--
do (if (CheckState.top+1->CheckState.top)>CheckState.pd.range then
       CheckState.pd.range->CheckState.pd.extend; 
       CheckState.md.range->CheckState.md.extend
   if);
   preDesc[]->CheckState.pd[CheckState.top][]; 
   desc[]->CheckState.md[CheckState.top][]
   
--emitDelayedMsg:descriptor--
(# node: ^AST.index; first: @boolean; wrnNo: @integer
do (*49->trace
       (# pref,desc: ^ast.index; p: @AST.index; isVirt: @integer
       do (for i: checkState.top repeat '$'->put;
               checkstate.pd[i][]->pref[]; checkstate.md[i][]->desc[];
               pref[]->A; desc[]->A;
               desc.son->p; 
               (if p.label=gram.prefix then
                   p.son->sematt.descrip->(P,isvirt);
                   (if not (p->pref.equal) then
                       '\n*** No inner problem: '->T;
    if)if)for)#);*)
   (for i: CheckState.top repeat
        (if not (CheckState.pd[i][]->hasInner) then
            (* CheckState.errCount+1->CheckState.errCount;
             * counting is done in SemError below
             *) 
            (CheckState.md[i],41)->&SemError 
        if);
        none->CheckState.pd[i][]->CheckState.md[i][]
   for);
   0->CheckState.top;
   (* emit warnings *)
   true->first;
   (for i: CheckState.wTop repeat
        CheckState.warn[i][]->node[];
        L:
        (if node.localErr//false then
            (if CheckState.err[i]->wrnNo// 201 then
                (if switch[2]//false then leave L if)
            if);
            wrnNo->node.markError;
            (if first then 
                '\n=================' -> messagestream.puttext;
                '\nCompiler warnings:'->messagestream.puttext;
                '\n=================\n' -> messagestream.puttext;
                false->first
            if);
            warnCount+1->warnCount;
            (* it is not neccessary to find enclosing imp as in semErr,since
             * the only current warning is a QUA-warning which is always given
             * on an imp.
             * NOt true with binOp warnings
             *)
            messagestream.newline;
            node->find1->node;
            (node[],messagestream[],20)->thePP;
            '--------------------------------------------' -> messagestream.puttext;
        if);
        none->CheckState.warn[i][]
   for);
   0->CheckState.wTop; false->first;
   (if warnCount>0 then true->error if);
   CheckState.errCount->ErrCount
#)
--ErrorPrint:descriptor--
(# FF: ^AST.FragmentForm
do (if verboseLevel<verboseLevel.actions then
       '\n\nPrinting lst-file' -> messagestream.puttext;
   if);
   theGroup.scan
   (# R: @AST.index
   do (if current.type // AST.FormType then 
          current[] -> FF[]; 
          '-------'->lst.PutText; 
          FF.name -> lst.Puttext; ':' -> lst.Put; 
          (if FF.Category
           // gram.objectDescriptor // gram.descriptorForm then
              'ObjectDescriptor'->lst.puttext
           // gram.attributesForm//gram.attributes//gram.attributeDecl
              then 'Attributes'->lst.puttext
           // gram.doPart then 'DoPart'->lst.puttext
           // gram.mainPart then 'MainPart'->lst.puttext
           else '... '->lst.puttext
          if);
          '-------'->lst.putLine;
          FF.theGSForm->R; (R[],lst[],5000) ->thePP;
   if)#);
#)
