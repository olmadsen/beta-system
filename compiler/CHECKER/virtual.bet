ORIGIN 'sematt';
LIB_ITEM 'betacompiler';
INCLUDE 'checklib';
---ActualDesc:doPart---
   (* switch[251:280] 
    * 251: ActualDesc
    * 252: theDesc begin/end
    * 253: trace all calls - no superChain display
    * 254: trace all calls - with superChain display
    *)
do (# L: ^SuperChain; ptnForm: @integer
   do (if vtest then
          251->trace(#do 'ActualDesc: '->xT; ES[]->xA; xN; thisDesc[]->xA #)
      if);
      (ThisDesc->&NewSingle,ES)->&theDesc->(desc,MN,L[],ptnForm)
   #)
---NewSingle:doPart---
do (if vtest then 
       251->trace(#
                 do 'NewSingle:'->xT;
                    (if D.label = gram.DescriptorForm then
                        'is:DescriptorForm:'->xT
                    if);
                   xN;  D[]->xA;
   #)if);
   (if D.isNull then 
       'Origin is NULL (virtual binding)'->ThisTranslate.SystemException 
   if);
   findDescNode:
     (if D.label
      // gram.objectDescriptor then (* skip *)
         (if D[]->sematt.insertable then
             D.origin->D; restart findDescNode
         if)            
      // gram.descriptorForm // gram.attributesForm
      // gram.mainPart then
         D.xOrigin->D;
         restart findDescNode
      // gram.doPart then
         (if vtest then 
             252->trace(#do 'NewSingle:doPart:insertable:'->xT; D.descNo=0->xB #); 
         if);
         (if D.descNo = 0 then (* no tmp. data *)
             D.xOrigin->D;
             restart findDescNode
         if)
      // gram.unExpanded then
         D.slotOrigin->D; 
         restart findDescNode
      else (* forL repetition etc *)
         D.origin->D;
         restart findDescNode
     if);
   &SuperChain[]->L[]; single->L.kind; NONE->L.pred[]; D->L.desc;
---SuperChainPrint:descriptor---
(# theChain: ^superChain
do this(superChain)[] -> theChain[];
   254 -> trace
   (#
   do L:
        (#
        do xU;
           '---Chain= ' -> xT;
           theChain.kind->printKind;
           '[on/pn/on1/pn1]=' -> xT;
           theChain.on->xI; '/'->put; 
           theChain.pn-> xI;
           '/'->tracestream.put; 
           theChain.on1->xI;; '/'->tracestream.put; 
           theChain.pn1->xI; xN;
           'ES='->xT; theChain.ES[] -> xA; xN;
           'desc='->xT; theChain.desc[] -> xA; xN;
           'preDen='->xT; theChain.preDen[] -> xA; 
           xD;
           (if (theChain.pred[] -> theChain[]) <> NONE then 
               xN;
               restart L
           if);
#)#)#)
--superChain:doPart--
do true->common.switch[254]; print (* preliminary for test purposes *)
---SuperPred:doPart---
do SC.pred[]->SC[] 
---theDesc:doPart--
do
   (# ESd,dclRef,sort,sort1: @ASTindex; formId,MN: @integer; R: ^SuperChain; 
      isV: @integer
   do (if vtest then
          252->trace(#do '(theDesc:'->xT; ES[]->xA; LL.print #); 
      if);
      L:
        (if ES.label
         // gram.objectReference
         // gram.dynamicItemGeneration
         // gram.dynamicComponentGeneration
         // gram.objectDenotation 
         // gram.structureReference then
            ES.son -> ES;
            restart L
         // gram.assignmentEvaluation then
            ES.son -> ES; ES.brother -> ES;
            restart L
        if);
      0->MN;
      (if ES.label
       // gram.nameApl // gram.indexed // gram.remote
       // gram.thisObject // gram.computedRemote then
          (* ES: .. ESd;           ... ES ....
           *  ESd = (desc ...) | (descSlot ...) 
           *  LL o catP(ES) o catP(ESd)->LL     
           *)
          ES[]->GetDclAndDesc->(dclRef,desc);
          (if vtest then
              252->trace(#do 'desc = ' ->xT; desc[] -> xA #)
          if);
          (* In case of  V:<..;  W::V,
           * W[]->GetDclAnDesc->(..,desc)
           * desc = desc(V), i.e W is considered virtual, but
           * findbinding below will then look for actual binding of V
           * as the actual binding of W. This dont work!!
           *)
          (LL[],ES)->&CatP->LL[];
          dclRef.sort->sort;
          (if desc.label <> gram.variablePattern then
              (if sort.label 
               // gram.simpleDecl // gram.repetitionDecl
               // gram.finalDecl (*??? *)then
                  (* will this work if gram.variablePattern? *)
                  (*(if sort.label=gram.finalDecl then 
                   *   sort[]->CheckVirtualBinding
                   * this has never been in use, but perhaps should?
                   * if);
                   *)
                  (if vtest then 
                      253->trace
                      (#do(if sort.label=gram.finalDecl then'final1'->xT if)#);
                  if);
                  ES->&ESpec->ESd;
                  (if vtest then 253->trace
                   (#do 'theDesc2:'->xT; ESd[]->xA #); if);
                  (if ESd.label//gram.objectDescriptor//gram.unExpanded then
                      (* catP is identity *)
                   else
                      ESd->GetSort->sort1;
                      (if vtest then 
                          253->trace(#do 'theDesc3:'->xT; sort1[]->xA #); if);
                      (if sort1.label=gram.finalDecl then
                          (if vtest then 
                              253->trace(#do 'theDesc:final:'->xT;ESd[]->xA;desc[]->xA#); 
                          if);
                          (*sort1[]->CheckVirtualBinding; never in use *)
                          (LL[],ESd)->&theDesc->(desc,MN,LL[],ptnForm);
                          LL.pred[]->LL[];
                       else
                          (LL[],ESd)->&CatP->LL[]; (*ES->LL.ES;*)
                  if)if);
                  (if vtest then 
                      253->trace(#do'AfterCatP2:'->xT; desc[]->xA; LL.print #); 
                  if);
              if)
          if);
          (if desc.label
           // gram.objectDescriptor then
              desc.son -> sort1;
              sort1.brother -> sort1; (* mainpart *)
              (if sort1.label = gram.unExpanded then
                  (if vtest then 
                      252->trace(#do 'mainPartDesc1:' -> xT; desc[] -> xA#)
                  if);
                  sort1 -> GetDescSlot -> sort1;
                  (if not (sort1 -> SuperObject.equal) then
                      (* only take the mainpart if included *)
                      sort1 -> desc
                  if);
                  (if vtest then 
                      252->trace(#do 'mainPartDesc2:' -> xT; desc[] -> xA #)
                  if);
              if);
           // gram.unExpanded then desc->&GetDescSlot->desc
           // gram.virtualDecl // gram.bindingDecl then 
              (LL[],ES,desc,sort)->&VirtualBinding->(desc,MN,LL[],ptnForm);
              (if desc.isNull then
                  (ES[],23)->&VirtualError; superObject->Desc
              if);
              (*VirtualForm->ptnForm*)
           // gram.finalDecl then 
              (* will probably never come here! GetDclAndDesc calls
               * getSort, which will return the desc in the finalDecl and
               * aslo call ChkVB
               *)
              (if vtest then 
                  253->trace(#do 'theDesc:final:surprise: '->xT; desc[]->xA #)
              if);
              desc[]->&CheckVirtualBinding;
              ES.son-> ESd; ESd.brother->ESd;
              ESd[]->GetDclAndDesc->(dclRef,desc)
           // gram.variablePattern then
              (if vtest then 
                  253->trace(#do 'TheDesc:VarPtn: '->xT; desc[]->xA; LL.print #)
              if);
              (LL[],desc.son)->&theDesc->(desc,MN,LL[],isV);
              LL.pred[]->LL[]; (* desc will prepended below again *)
          if)
       // gram.objectDescriptor then 
          ES->desc
       // gram.finalDecl then 
          desc[]->&CheckVirtualBinding;
          ES.son-> ESd; ESd.brother->ESd;
          ESd[]->GetDclAndDesc->(dclRef,desc)
       // gram.unExpanded then ES->&GetDescSlot->desc
       // gram.virtualDecl // gram.bindingDecl  then
          (* can this happen???? *)
          'ActualDesc called with virtual/bind'->ThisTranslate.SystemException
       else '!'->put;
          1->trace(#do 'theDesc:no match:'->xT; ES[] -> xA #);       
      if);
      &SuperChain[]->R[]; nest->R.kind; LL[]->R.pred[];
      desc->R.desc; ES->R.ES; 
      LL.virtDcl[]->R.virtDcl[]; (*LL.ptnForm*)ptnForm->R.ptnForm;
      R[]->LL[];
          (*179->trace(#do desc[] -> xA #);*)
      (if vtest then 
          253->trace(#do 'theDesc):'->xT; ES[]->xA; LL.print; #) 
      if);

   #)
---ENC:doPart---
do (if vtest then 253->trace(#do 'Enc:'->xT; L.print #);  if);
   (# kind,ON,PN,ON1,PN1: @integer
   do (if L.kind->kind
       // single then 
          (if L.desc.label//gram.doPart then
              L.desc.xorigin->NewSingle->L[]
           else
              L.desc.origin->NewSingle->L[]
          if)
       // plain // implicitPre then
          L.on->ON; L.pn->PN; L.on1->ON1; L.pn1->PN1;
          L.pred[]->&ENC->L[];
          (for ON repeat L[]->&ENC->L[] for);
          (for PN repeat L[]->&PRE->L[] for);
          (if vtest then 
              253->trace
              (#
              do  (if kind//implicitPre then
                      'ENC:implicitPre ON/PN/ON1/PN1:'->xT; 
                      ON->xI; ' '->put; PN->xI; ' '->put; 
                      ON1->xI; ' '->put; PN1->xI; xN;
                      this(enc).L.print
              if)#);
          if);
          (for ON1 repeat L[]->&ENC->L[] for);
          (for PN1 repeat L[]->&PRE->L[] for);
       // remotePre then
          (if vtest then
              253->trace(#ss: @ASTindex 
                        do 'ENC:remotepre:PN='->xT;  
                           this(enc).L.pn->xI;
                           this(ENC).L.print; 
                           '******1****'->putline;
                           (if true (*this(enc).L.preden.isNull*) then
                               '*** preDen is null *** ' -> xT
                            else
                               this(enc).L.preden.dclref->ss;
                               '******2****'->putline;
                               ss[]->xA;
                               '******3****'->putline;
                           if)
                        #); 
          if);
          (L.pred[]->&ENC,L.preDen,L.pn)->&Remote->L[]
       // implicitRemotePre then
          (# preDen: @ASTindex; pn: @integer
          do L.preDen->preDen; L.pn->pn;
             (if vtest then 
                 253->trace
                 (#do 'ENC/ImplicitRemotePre: PN='->xT; pn->xI; 
                    preDen->dump;
                    this(ENC).L.print
                 #); 
             if);
             L.on->ON;(* ON should be zero! *) L.pn->PN;
             L.pred[]->&ENC->L[];
             (*(for ON repeat L[]->&ENC->L[] for);*)
             (for PN repeat L[]->&PRE->L[] for);
             (L[],preDen,0 (*pn*))->&Remote->L[]
          #)
       // nest then L.pred[]->L[]
       // thisObjPre then (* this dont work! *)
          'ENC:thisObjPre'->putLine;
          L.pred[]->L[]
       // computedRemotePre then (* this needs more testing! *)
          (# remEv,N,ref,refDesc: ^ASTindex
          do 
             (L.preDen[],this(BindVirtual)[],L.pred[]->ENC)
               ->ChkComputedEval->(remEv[],N[],ref[],refDesc[],L[])
          #)
      if);
      (if vtest then 253->trace(#do 'ENC:end:'->xT; L.print #); if);
   #)
---PRE:doPart---
do
   (# R: ^SuperChain; desc,pre,N: @ ASTindex; ptnForm: @integer; 
      D: ^ASTindex
   do &SuperChain[]->R[];  L[]->R.pred[];
      L.desc->desc; 
      (if desc.label = gram.mainPart then
          desc[] -> MainPartDesc -> D[];
          D -> desc
      if);
      desc.son->pre;
      (if vtest then 253->trace(#do 'PRE:'->xT; desc[]->xA #);  if);;
      (if pre.label = gram.prefix then
          pre.son->pre; pre[]->&GetDclAndDesc;
          pre->GetName->N;
          N.descRef->R.desc;
          (if pre.label
           // gram.nameApl // gram.indexed then
              N.on->R.on; N.pn->R.pn;  plain->R.kind;
              (if N.stringLength = 0 then 
                  (* Virtual patterns of the form
                   *   V:< A; or V:< R.A
                   *   V::< (# ... #)
                   * needs special treatment, since the search-path
                   * of the implicit super of the binding is NOT correct.
                   * The search-path of A from V:<A or V:<R.A must also be 
                   * included in the search-path from the implicit super.
                   * ON1,PN1 represents the search-path for A.
                   * Note that if A is explicitly given in
                   *     V::< A'(# ... #)
                   * Then path(A') = (on',pn') which may be different
                   * from the values (on,pn) and (on1,pn1), but
                   * (on,pn) followed by (on1,pn1) should end up at
                   * the same descriptor as going directly via (on',pn')
                   *)
                  (# V,VS: @ ASTindex (* V:< VS; or V:< (# ... #) *)
                  do N.dclRef->V; V.sort->VS; VS.son->VS; VS.brother->VS;
                     (if VS.label
                      // gram.nameApl then 
                         implicitPre->R.kind; VS.on->R.on1; VS.pn->R.pn1;
                         (if vtest then 253->trace
                             (#do 'PRE:implicitPre: on/pn:'->xT; 
                                VS.on->xI; '/'->put; VS.pn->xI; ' '->put;
                                V[]->xA; VS[]->xA 
                             #)
                         if);
                      // gram.remote then
                         implicitRemotePre->R.kind; VS.son->R.preDen;
                         (if vtest then 
                             259->trace
                             (#do 'PRE:implicit remote:'->xT; V[]->xA; VS[]->xA #)
                         if);
                      // gram.objectDescriptor then
                      else 
                         (if vtest then 
                             259->trace(#do 'PRE:implicit:'->xT; V[]->xA; VS[]->xA #); if);
                         'PRE: implicit error'->ThisTranslate.SystemException
              if)#)if)
           // gram.remote then
              remotePre->R.kind; pre.son->R.preDen; 
              R.preDen.brother->N; N.pn->R.pn;
           // gram.thisObject then 
              'Virtual binding:PRE:this(P) as super'->ThisTranslate.SystemException;
              thisObjPre->R.kind;
           // gram.computedRemote then
              computedRemotePre -> R.kind; 
              pre -> R.preDen;
              (if true then
                  (* problem discovered while testing with newindex;
                   * apparently 
                   *    R.preDen.brother -> N 
                   * in the else-part below is null!
                   *)
                  pre.son -> N;
                  N.brother -> N
               else
                  R.preDen.brother->N; 
              if);
              193 -> trace(#do 'computedRemote: ' -> xT; 
                             desc[] -> xA; xN;
                             pre[] -> xA; xN;
                             R.preDen[] -> xA; xN;
                             N[] -> xA#);
              N.pn->R.pn;
          if);
          (if vtest then 253->trace(#do 'PRE:end:'->xT; R.print #)if)
       else 
          L.print;
          'Pre is empty/null(virtual binding)'->ThisTranslate.SystemException
      if);
      R[]->L[]
   #)
------VirtualBody:attributes---
GetDescSlot:
  (# desc,DescSlot: @ASTindex;
     descSlotx: ^unExpanded
  enter desc
  do (if vtest then 
         252->trace(#do 'GetDescSlot:'->xT; desc[] -> xA;;
                      (if theGroup[]=none then 'theGroup is none'->xT
     if)#)if);
     desc->DescSlot; SuperObject->desc; (* in case no binding *)
     L: 
       (if true then
           descSlot.asAst -> descSlotX[];
           theGroup[]->DescSlotx.GetBinding
           (# Found::<
                (#do 
                   theBinding.theGSForm->desc; 
                   (* desc = (system <desc>) *)
                   (if desc.label = gram.mainPart then
                       192 -> trace(#do 'GotMainPart:'->xT #);
                    else
                       desc.son->desc;
                   if);
                   leave L
           #)#)
        else
          (* theGroup[]->DescSlot.GetBinding
           (# Found::<
                (#do 
                   theBinding.theGSForm->desc; 
                   (* desc = (system <desc>) * )
                   (if desc.label = gram.mainPart then
                       192 -> trace(#do 'GotMainPart:'->xT #);
                    else
                       desc.son->desc;
                   if);
                   leave L
                    #)#)*)
           
       if)
  exit desc
  #);


VirtualBinding:
  (* N is a name specified using a virtual category       *)
  (* N is applied in thisDesc                             *) 
(* virt is the decl. of the virtual category of N       *)
(* there are two cases:                                 *)
(* 1)   N ::< T                                         *)
(*      N is a virtual category used as inserted/dynamic object *)
(* 2)   V ::< T                                            *)
(*      N : @V                                             *)
(*      N is a named object spec. using a virtual category *)
(* virt refers to N ::< T                                  *)
(* Additional documentation is need in order to understand *)
(***********************************************************)
(# N,sort,virt,desc: @ ASTindex; ptnForm: @integer;
   LL: ^SuperChain; MN: @integer
enter(LL[],N,virt,sort)
do (if vtest then 253->trace
       (#do 'VirtualBinding:'->xT; N[]->xA; sort[]->xA;virt[]->xA;LL.print#)
   if);
   
   (True,LL[],virt.son->singleName,virt)->&Head->(desc,MN,LL[],ptnForm)
exit(desc,MN,LL[],ptnForm)
#);

Head:
  (# ptnForm: @integer; bot: @boolean; LL,L1: ^SuperChain;
     V,virtDcl,desc,aDesc: @ASTindex; MN: @integer
  enter(bot,LL[],V,virtDcl)
  do (if vtest then 253->trace(#do 'Head:'->xT; &LL.print #); if);
     null->aDesc;
     (if LL.kind
      // plain 
      // implicitPre
      // remotePre 
      // implicitRemotePre 
      // computedRemotePre then
         (False,LL.pred[],V,virtDcl)->&Head->(aDesc,MN,L1[],ptnForm)         
         (*// single // nest *)
      // thisObjPre then
         (* this(P)(# V::< ... do current.x; #) where X: ^V 
          * Does not work, since PRE will fail.
          * Some of the other cases should be further 
          * understood and tested; see FEJL/specialvirt
          *)
         (False,LL.pred[],V,virtDcl)->&Head->(aDesc,MN,L1[],ptnForm)
     if);
     
     (if aDesc.isNull then 
         (bot,LL[],V,virtDcl)->&FindBinding->(aDesc,MN,L1[],ptnForm)
     if);
  exit(aDesc,MN,L1[],ptnForm)
  #);

findBinding:
  (* Find the binding of V starting in desc.
   * virtDcl is the virtual/bind decl. that may have been further bound
   *)
  (# bot: @boolean; V,virtDcl,desc,aDesc,ES: @ ASTindex;
     ptnForm,pf,PD: @integer; L,L1: ^SuperChain
  enter(bot,L[],V,virtDcl)
  do L[]->L1[]; L.ES->ES; 
     (if vtest then 
         253->trace(#do 'findBinding1:'->xT; ES[]->xA;
                      this(findbinding).L.print
                   #); 
     if);
     search:
       (# pref,att,dclRef,descRef,sort,father: @ASTindex; 
          ok: @boolean;
          D,rpre,ratt,rentP,rdoP,rexitP: ^ASTindex
       do L.desc->desc;  null->aDesc;
          (if vtest then 253->trace(#do 'findBinding2:'->xT; desc[]->xA #)if);
          (if  desc.label = gram.mainPart then 
              desc[] 
                -> mainPartSons 
                -> (descRef,rpre[],ratt[],rentP[],rdoP[],rexitP[]);
              rpre -> pref;
              ratt -> att;
           else
              desc.son->pref; 
              pref.brother->att; (*main-p*) 
              (if att.label = gram.unExpanded then
                  (*NULL -> att scanList won't handlde NULL*)
                  (* newindex.bet problem *)
               else
                  att.son->att
              if);
          if);
          att->ScanList
          (# dcl,VD,VN,vDesc,son: @ASTindex
          do currentNode->dcl;
             M: (if dcl.label 
                 // gram.virtualDecl // gram.bindingDecl //gram.finalDecl then
                    (if vtest then 
                        253->trace(#do 'findBinding3:'->xT; dcl[]->xA; V[]->xA #)
                    if);
                    (if ((dcl.son->singleName->VN,V)->EQS)  then
                        (** the names are identical **)
                        dcl->VD; 
                        VD[]->&CheckVirtualBinding;
                        L: (if not (VD->virtDcl.equal) then
                               (if VD.label = gram.virtualDecl then leave M if);
                               (* VN.virtDcl is ONLY defined for
                                * bindingDecl. Not for virtualDecl
                                *)
                               VN.virtDcl->VN;
                               (if VN.isNull OR (VN->errorName.equal) then
                                   leave M if);
                               VN.sort->VD;
                               restart L
                           if);
                        (* dcl is a binding of virtDcl *)
                        VirtualForm->ptnForm;
                        (if dcl.label = gram.finalDecl then
                            NonVirtualForm->ptnForm
                         else
                            M:
                              (if ES.isNull then
                                  (if L1.kind // single // nest then
                                      (* we are in a descriptor
                                       * (#  V:< (::<) ... #)
                                       * The descriptor may be singular
                                       *)
                                      VirtualInPtnForm->ptnForm; 
                                      (* OBS! Just for testing
                                       * ES is null, but virtual
                                       * is 'inside' a pattern'
                                       * Below it is checked if 
                                       * the pattern is a static 
                                       * singular object
                                       *)
                                      L1.desc.father->sort;
                                   else 
                                      L1.pred[]->L1[];
                                      L1.ES->ES;
                                      restart M
                                  if)
                               else
                                  (if ES.label=gram.objectDescriptor then
                                      ES.father->father;
                                      (if father.label
                                       //gram.staticItem
                                       //gram.staticComponent
                                       //gram.insertedItem
                                       //gram.dynamicItemGeneration
                                       //gram.dynamicComponentGeneration then
                                          nonVirtualForm
                                          (*virtualInPtnForm*)->ptnForm
                                      if)
                                   else
                                      ES[]->GetDclAndDesc->(dclRef,descRef);
                                      dclRef.sort->sort;
                                      (if sort.label
                                       //gram.simpleDecl then
                                          sort.son->sort; sort.brother->sort;
                                          (if sort.label
                                           //gram.staticItem
                                           //gram.staticComponent then
                                              nonVirtualForm
                                              (*VirtualInPtnForm*)->ptnForm
                                          if)
                                       //gram.patternDecl
                                       //gram.virtualDecl
                                       //gram.bindingDecl
                                       //gram.finalDecl then
                                          (* like: t[]->foo where
                                           * foo: (# V:<.; x:^V enter x[] #)
                                           *)
                                          ES.father->father;
                                          L: (if father.label
                                              //gram.attributeDenotation
                                              //gram.remote
                                              //gram.indexed
                                              //gram.thisObject
                                              //gram.computedRemote
                                              //gram.remotePrimitive then
                                                 father.father->father;
                                                 restart L
                                             if);
                                          (if father.label
                                           //gram.objectDenotation then
                                              VirtualInPtnForm->ptnForm
                                          if);
                        if)if)if)if);
                        dcl.son->son;(*->singleName->VN; ( * is VN used??*)
                        (L[],son.brother)->&theDesc->(aDesc,PD,L[],pf);
                        (* PD is just a dummy here *)
                        (if vtest then 
                            253->trace
                            (#
                            do 'FinalBinding3:'->xT; 
                               (if ptnForm
                                // VirtualForm then ' VirtualForm:'->xT
                                // NonVirtualForm then ' NonVirtualForm:'->xT
                                // VirtualInPtnForm then ' VirtualInPtnForm:'->xT
                               if);
                               xN;
                               aDesc[]->xA;
                               'Found in:'->xT; desc->dump;
                               'Defining:'->xT; ES->dump
                            #)
                        if);
                        
                        L.pred[]->L[];
                        virtDcl.son->vDesc; 
                        vDesc.brother->&GetTheDesc->vDesc;
                        (aDesc[],vDesc[])->&QuaDist->PD; (* is this used? *)
                        dcl[]->L.virtDcl[];
                        ptnForm->L.ptnForm;
                        (if vtest then 
                            253->trace
                            (#do 'FindBinding4:'->xT;PD->xI;newline;aDesc[]->xA #)
                        if);
                        leave search
          if)if)#);
          (if bot then
              (if vtest then 253->trace(#do 'GoPre:'->xT #) if);
              (if pref.label = gram.prefix then
                  L[]->&PRE->L[];
                  restart Search
       if)if)#);
  exit(aDesc,PD,L[],ptnForm)
  #);

single: (#exit 0 #);
plain: (#exit 1 #);
remotePre: (#exit 2 #);
nest: (#exit 3 #);
implicitPre: (#exit 4 #);
implicitRemotePre: (#exit 5 #);
computedRemotePre: (#exit 6 #);
thisObjPre: (#exit 7 #);

Remote:
  (* L o PATH(AS) o CATP(esA) o nest(desc(esA)) 
   * Consider
   * 
   *    B: R.A(# ... #)
   * 
   *    R: @T;  R: @T(# ... #);
   * - L  is path to B
   * - AS is R
   * - pn is A.pn
   *  
   * The path to R is appended to L; 
   * the path for T or T(# ... #) is then appended;
   * and desc(esA) is nested:
   * 
   * - L' = L o PATH(AS) is computed by (L[],AS)->CatP
   * - L" = L' o CATP(esA) o nest(desc(esA)) 
   *           is computed by (L',AS->ESpec)->theDesc
   * 
   * Note, a recent extension! If A in the above example is NOT declared in
   * the main part of T or T(# ... #), the A.pn number of PRE's must be 
   * appended L.
   * 
   *)
  (# L: ^ SuperChain; AS,desc,dclRef,descRef,sort: @ ASTindex;
     pn,N,ptnForm: @integer
  enter(L[],AS,pn)
  do (if vtest then 
         253->trace
         (# ss: @ASTindex
         do 'Remote:PN='->xT; pn->xI; AS[]->xA; 
            (if as.label=gram.nameapl then as.dclref->ss; ss[]->xA if);
            L.print 
     #)if);
     (* Recent extension to handle:
      *    R: ^V.W; where  V:< ... - i.e. V is a virtual pattern;
      * CatP may be called for V.W, which call Remote for V, which call
      * ESpec for V; since V is virtual, the actualDesc of V should be
      * computed;
      * below ESpec is inlined with test for virtual.
      *)
     AS[]->&GetDclAndDesc->(dclRef,descRef);
     dclRef.sort -> sort;
     (if sort.label
      // gram.virtualDecl // gram.bindingDecl then
         (* '#'->put; check this: FEB.96 *)
         (L[],AS) -> &TheDesc -> (desc,N,L[],ptnForm)
         (* consider if the above call could be made in all cases*)
      else (* pattern and finalDecl should be OK with the old code!*)
         sort -> GetSpecOfSort -> sort;
         (if sort.label // gram.objectDescriptor // gram.unExpanded then
          else sort[] -> GetDclAndDesc
         if);
         ((L[],AS)->&CatP,sort(*AS->&ESpec*))->&theDesc->(desc,N,L[],ptnForm);
     if);
     AS->L.ES;
     (* the following 2 lines due to madsnvirt error *)
     (for pn repeat L[]->PRE->L[] for);
     AS->L.ES; (* should this really be done? *)
     (* L = L' o nest(desc) for some L' *)
     (if vtest then 
         253->trace(#do 'Remote/end:'->xT; AS[]->xA; desc[]->xA; L.print #)
     if);
  exit L[]
  #);

CatP: (* L o PATH(AS)->L *)
  (# AS: @ ASTindex; L: ^ SuperChain; ON,PN,pnAdjust: @integer
  enter(L[],AS)
  do (if vtest then 
         253->trace(#do 'CatP:'->xT; AS[]->xA; this(CatP).L.print #)
     if);
     (if AS.label // gram.objectDescriptor  // gram.unExpanded then
      else
         GetN:
           (if AS.label 
            // gram.remote then
               AS.son->AS;
               (L[],AS,0)->&Remote->L[];
               (* OBS! AS.pn is not passed to remote, since AS.pn
                * PRE are made below! 
                *)
               AS.brother->AS;
               (# dclRef: @ASTindex; pn1,pn2: @integer; found: @boolean
               do AS.pn->pn1;
                  (*(AS,L.desc)->LocalSearch->(found,pn2,dclRef);*)
                  (if pn1 <> pn2 then
                      (if vtest then 
                          253->trace
                          (#do
                             pn2 - pn1 -> pnAdjust;
                             '\nCatP/remote: pn1<>pn2 '->xT;
                             pn1->xI; ' '->put; pn2->xI; xN
                          #)  
                      if);
               if)#)
            // gram.indexed (* AS = (inx <att-den> <eval> ) *) then
               AS.son->AS; restart getN
            // gram.thisObject then AS.son->AS
            // gram.ComputedRemote then
               (# remEv,N,ref,refDesc: ^ASTindex; ptnForm: @boolean
               do (AS[],L[])->chkCompEval->(remEv[],N[],ref[],refDesc[],L[]);
                  (if vtest then 
                      253->trace
                      (#do 'CatP:CompRem:'->xT; remEv[]->xA;
                         N[]->xA; ref[]->xA; refDesc[]->xA;
                         (if common.switch[175] then this(CatP).L.print if)
                      #); 
                  if);
                  (*HOPE-(L[],refDesc)->&theDesc->(desc,N1,L[],ptnForm);*)
                  N->AS;
               #)
           if);
         AS.on->ON; AS.pn->PN;
         (if vtest then 
             253->trace
             (#do 'CatP:ON/PN:'->xT; ON->xI;'/'->put;PN->xI;AS[]->xA #); 
         if);
         (for ON repeat L[]->&ENC->L[] for);
         (for PN + pnAdjust repeat L[]->&PRE->L[] for);
     if);
     (if vtest then 
         253->trace(#do 'CatP/end:'->xT; this(CatP).L.print #) if);
  exit L[]
  #);
ESpec:
  (* N where N: * AS, for * in [ @,^];.
   *)
  (# N,AS,dclRef,descRef: @ASTindex
  enter N
  do N[]->&GetDclAndDesc->(dclRef,descRef);
     (if vtest then 
         253->trace
         (# SS: @ASTindex
         do 'ESPEC:'->xT; N[]->xA; 
            (if N.label=gram.nameApl then N.dclRef->SS; SS[]->xA if);
            dclRef[]->xA;
            dclRef.sort->SS; SS[]->xA 
     #) if);
     dclRef.sort->&GetSpecOfSort->AS;
     (if vtest then 253->trace(#do 'ESPEC2:'->xT; AS[]->xA #); if);
     (if AS.label // gram.objectDescriptor // gram.unExpanded then
      else (* <name-denotation> *)   
         AS[]->&getDclAndDesc 
     if);
     (if vtest then 253->trace(#do 'ESpec:end:'->xT; AS[]->xA #) if);
  exit AS
  #);
dump: 
  (# N: @ASTindex
  enter N
  do (if N.isNull then 'Null descriptor'->tracestream.puttext
      else
         (if (N.label=gram.objectDescriptor) (* newindex.bet problem *)
             and ((N->descKind) =  standardKind) then 
             'Standard:'->tracestream.putText
         if);
         (if common.switch[100] then 
             (*0->&N.LispPrint*)
             (N.asAst).dump
          else 
             (N[],tracestream[],7)->thePP
  if)if)#);
PrintKind:
  (# kind: @integer
  enter kind
  do 'kind='->tracestream.puttext;
     (if kind
      // 0 then 'single'->tracestream.puttext
      // 1 then 'plain'->tracestream.puttext
      // 2 then 'remotePre'->tracestream.puttext
      // 3 then 'nest'->tracestream.puttext
      // 4 then 'implicitPre'->tracestream.puttext
      // 5 then 'implicitRemotePre'->tracestream.puttext
      // 6 then 'computedRemotePre'->tracestream.putText
      // 7 then 'thisObjPre'->tracestream.putText
      else 'UNKOWN'->tracestream.puttext
     if);
  #)
