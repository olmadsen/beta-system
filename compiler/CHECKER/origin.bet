ORIGIN 'checkerdopart';
LIB_ITEM 'betacompiler';
INCLUDE 'sematt';
---translib:attributes---
indexToAst:
   (* convert an ASTindex node to a pair: 
    * (expanded,fragmentForm[])
    *)
   (# anIndex: ^ ASTindex;
   enter anIndex[]
   exit(anIndex.asAst,anIndex.theFragmentForm)
   #);
astToIndex:
   (* converts an expanded into an ASTindex *)
   (# A: ^ expanded; B: @ASTindex
   enter A[]
   do A[] -> AstAsAstIndex -> B
   exit B[]
   #);
AddOrigin: 
   (# napl: ^expanded; (* the nameApl-node *)
      na: ^nameAppl;
      nDcl: ^ nameDecl;
      nd,desc,sort,dclList,refSpec: ^expanded;  
      f: ^fragmentForm;
      descRef,originApl,encDesc,nDclIndex,N: ^ASTindex;
      N1: @ASTindex; allocDoPartObject: @boolean
   enter(originApl[], encDesc[])
   do (if false (*ctst*) then
          194->trace
          (# N: @ASTindex 
          do 'addOrigin:'->xT; originApl.father->N; N[]->xA 
          #)
      if);
      (if encDesc.label
       // gram.objectDescriptor // gram.doPart then (* skip *)
       else
          encDesc[] -> sematt.EncDesc -> encDesc[]
      if);
      (if encDesc -> sematt.descKind
       // sematt.undefined then
          '\n**** OBS! Enclosing descriptor is NOT checked'
          '\n**** code generation may fail' -> putline;
          (*(encDesc[],false,none,-1)->&sematt.chkForm;*)
      if);
      originApl[]->indexToAst->(desc[],f[]);
      (* create simpleDecl to represent sort of origin-decls,
       * this node need only be created once, since each new application
       * of origin can be aded to the list of names:
       *  origin,origin,,,,: ^ struc
       *
       * simpleDecl = (simpleDecl (names (nameDcl (nameDecl 'origin')))
       *                          (dynamicItem (nameApl (nameAppl 'struc'))))
       *)
      (gram.simpleDecl,f[])->grammarTable.beta.newAst->sort[];
      (gram.names,f[])->grammarTable.beta.newAST->dclList[]->sort.putSon1;
      (gram.dynamicItem,f[])->grammarTable.beta.newAst
        ->refSpec[]->sort.putSon2;
      (* create the nameApl representing the attributeDenotationin
       *     origin: ^ struc ( struc currently used)
       *)
      (gram.NameApl,f[])->grammarTable.beta.newAst->napl[];
      (nameAppl,f[])->grammarTable.beta.newAst->na[];
      'struc'->na.putText; 
      napl[]->astToIndex->N[]; 
      sematt.superObject->N.descRef; 
      sematt.superObject.father->N1; N1.son->N1; N1.son->N.dclRef;
      na[]->napl.putson1;
      napl[]->refSpec.putSon1;

      (* create new nameDecl for 'origin' *)
      (gram.nameDcl,f[])->grammarTable.beta.newAst->nd[]->dclList.putSon1;
      (nameDecl,f[])-> grammarTable.beta.newAST->nDcl[];
      nDcl[]->nd.putSon1;
      'object'->nDcl.putText; 
      nd[]->astToIndex->nDclIndex[];
      encDesc.originOff ->nDclIndex.off; 
      (if ctst then
          198->trace(#do 'origin: off='->xT;  encDesc.originOff->xI; xN;
                       encDesc[] -> xA;
      #)if);
                       
      1 ->nDclIndex.access;

      (* set dclRef of origin-apl *) 
      nDclIndex->originApl.dclRef;
      0->originApl.on->originApl.pn;
      (*encDesc.origin->descRef->originApl.descRef;*)

      (if encDesc.label 
       // gram.doPart then 
          encDesc.descNo > 0 -> allocDoPartObject;
          encDesc.xOrigin -> encDesc;
          (if encDesc.label = gram.unExpanded then
              encDesc.slotOrigin -> encDesc
          if);

          (if allocDoPartObject then
              (* A dopart object is allocated *)
              encDesc.originOff -> nDclIndex.off; 
              1 -> originApl.on;
           else
              (* no dopart object is allocated *)
              8 -> nDclIndex.off; 
          if)
       // gram.objectDescriptor then (* skip *)
       // gram.forImp then
          '*** for-imp' -> thisTranslate.systemException
       else
          '***** illegal enclosing descriptor when using origin'
          -> thisTranslate.systemException
      if);
      encDesc[] -> sematt.encDesc -> descRef[]; 
      descRef->originApl.descRef;
      (if false (*ctst*) then
          194->trace
          (# N: @ASTindex; 
          do 'addOrigin:'->xT; sort[]->astToIndex->xA;
             originApl.dclRef->N; N[]->xA; originApl.descRef->N; N[]->xA
      #)if);
   exit(nDclIndex,descRef)
   #)
