ORIGIN 'warningsAndErrors';
LIB_ITEM 'betacompiler';
INCLUDE '~beta/mps/utils/ast2asciiMap';
INCLUDE '~beta/betaast/semanticerrortext';
INCLUDE '~beta/pretty/asIsPretty';
INCLUDE '~beta/basiclib/streamPosition';
INCLUDE '~beta/toollibs/utils/fileExtensions';
(*INCLUDE '../CONTROL/asIsPretty'*)
---astlib:attributes---
hasLocalError: booleanValue
  (# scanAst:
       (# N: ^AST; X: ^expanded
       enter N[]
       do L: (if (N[]<> none) and N.internal then
                 N[] -> X[];
                 (if X.hasSemanticError then
                     true -> value;
                     leave L
                 if);
                 X.getSon1 -> scanAst; 
                 (if value then leave L if);
                 X.nextBrother -> N[];
                 restart L
             if)
       #);
  do this(AST)[]-> scanAst
  #);
internal: (# exit symbol > 0 #);

--We_init:doPart--
do checkState.init;
   INNER
---emitDelayedMsg:descriptor---
(# node: ^ASTindex; first: @boolean; wrnNo: @integer
do (*49->trace
    (# pref,desc: ^ASTindex; p: @ASTindex; isVirt: @integer
    do (for i: checkState.top repeat '$'->put;
    checkstate.pd[i][]->pref[]; checkstate.md[i][]->desc[];
    pref[]->A; desc[]->A;
    desc.son -> p; 
    (if p.label = gram.prefix then
    p.son -> sematt.descrip -> (P,isvirt);
    (if not (p->pref.equal) then
    '\n*** No inner problem: ' -> T;
    if)if)for)#);*)
   (for i: CheckState.top repeat
        (if not (CheckState.pd[i][]->hasInner) then
            (CheckState.md[i],41) -> &SemError 
        if);
        none -> CheckState.pd[i][] -> CheckState.md[i][]
   for);
   0 -> CheckState.top;
   (* emit warnings *)
   true -> first;
   (for i: CheckState.wTop repeat
        CheckState.warn[i][] -> node[];
        L:
          (if not (node.asAst).hasLocalError then
              (if (CheckState.err[i]->wrnNo) = 201 then
                  (if not common.switch[2] then leave L if)
              if);
              (if first then 
                  '\n==================' -> messagestream.puttext;
                  '\nCompiler warnings:' -> messagestream.puttext;
                  '\n==================' -> messagestream.puttext;
                  false->first
              if);
              warnCount+1 -> warnCount;
              (* it is not neccessary to find enclosing imp as in semErr,
               * since the only current warning is a QUA-warning,
               * which is always given on an imp.
               * Not true with binOp warnings
               *)
              (node,wrnNo) -> checkState.PrintMessage;
          if);
        none -> CheckState.warn[i][]
   for);
   0 -> CheckState.wTop; false -> first;
   (if warnCount > 0 then true -> error if);
   CheckState.errCount -> ErrCount
#)
--CheckState:descriptor--
(# pd,md: [8] ^ASTindex; (* list of pairs, preDesc, desc, 
                          * where preDesc has no inner. 
                          * To be finally checked by CheckNoInner
                          *)
   top: @integer;
   warn: [8] ^ASTindex; err: [8] @integer; wTop: @integer;
   errCount: @integer;
   
   (* for a2s *)
   a2s: ^theGroup.a2sHandle;
   
   betafile: @file(# pc: @positionConverter #);
   
   init: 
     (# betafilename: ^text;
     do &theGroup.a2sHandle[] -> a2s[];
        (theGroup.diskFileName).copy -> betafilename[];
        '.ast' -> betafileName.StripExtension;
        '.astL' -> betafileName.StripExtension;
        '.astl' -> betafileName.StripExtension;
        '.bet' -> betafileName.AppendExtension;
        betafilename[] -> betafile.name;
        betafile.openRead;
        betafile.pc.update;
        betafile.close;
     #);
   
   (* The following attributes are for collecting all nodes 
    * marked with an error or warning. The error marking
    * is cleared. It may subsequencently be restored.
    *    eClear: initialization;
    *    eScan: collect and clear;
    *    eRestore: restore
    * Is used when printing an error/warining for a node
    * in order to assure that only the actual message is
    * printed.
    *)
   eNodes: [4] ^ASTindex; eNumbers: [4] @integer; etop: @integer;
   eClear: (# do 0 -> eTop #);
   eScan:
     (# N,F: @ASTindex; ix: @integer
     enter N
     do N -> F;
        (*'\nscan:' -> puttext; (F[],messagestream[],20) -> thePP;*)
        L:
          (if not F.isNull and F.internal then
              (if ((*F.errInx*) (F.asAst).semanticError -> ix) <> 0 then
                  (*newline; ix -> putint;*)
                  (if (eTop+1 -> eTop) > eNodes.range then
                      eNodes.range -> eNodes.extend;
                      eNumbers.range -> eNumbers.extend
                  if);
                  &ASTindex[] -> eNodes[eTop][];
                  F -> eNodes[eTop];
                  ix -> eNumbers[eTop];
                  (*F.clearError;*)
                  false -> (F.asAst).hasSemanticError
              if);
              F.son -> eScan;
              F.brother -> F;
              restart L
          if);
        
     #);
   eRestore:
     (#
     do (for i: eTop repeat
             eNumbers[i] -> (eNodes[i].asAst).semanticError(*errInx*)
        for);
        0 -> eTop
     #);
   (* Printing of error/warning *)
   FindImpOrAtt: 
     (* Find nearest enclosing imperative or attribute of a node *)
     (# node,F: @ ASTindex
     enter node 
     do node -> F;
        L: (if not F.isNull then
               (if F.label 
                // gram.imperatives // gram.attributes then               
                else
                   F -> node; node.father -> F; 
                   restart L
           if)if)
     exit node
     #);
   PrintMessage:
     (* print error- or warning message *)
     (# node,node1: @ASTindex; msgNo,fragNo: @integer;
        start,end: @integer;
        line, col: @integer;
     enter(node,msgNo)
     do node -> FindImpOrAtt -> node1;
        checkState.eClear;
        node1 -> checkState.eScan;
        (*msgNo -> node.markerror;*)
        
        (if false then
            (if not (node.asAst).hasLocalError then
                msgNo -> (node.asAst).semanticError
            if)
         else
            (if not (node.asAst).hasLocalError then
                (* it is perhaps rare that there is a locaError?*)
                msgNo -> (node.asAst).semanticError
            if)
        if);
        (if not common.switch[441] then
            (node.theFragmentForm,node.nodeId) -> a2s.getPos -> (start,end);
        if);

        messagestream.newline;
        messagestream.newline;
        (if common.switch[441] then
            (node[],messagestream[],(node.asAst).getPos) -> PP 
         else
            (node1[],messagestream[],20) -> PP (* thePP;	*);
        if);
        
        (if start > 0 then
            '\n----- ' -> messagestream.puttext;
            'line: ' -> messagestream.puttext;
            start -> betafile.pc.posToLineCol -> (line, col);
            line -> messagestream.putint;
            '; ' -> messagestream.puttext;
            'char positions: ' -> messagestream.puttext;
            start -> messageStream.putint; 
            ',' -> messageStream.put; 
            end-> messageStream.putint;
            ' -----'-> messagestream.puttext;
         else
            '\n--------------------------------------------' 
              -> messagestream.puttext;
        if);
        checkState.eRestore;     
     #);   
#)
--semError:descriptor--
(# encloser:
     (* Consider R.X
      * if R is undeclared, avoid error message for X
      *)
     (# n,nx: @ASTindex
     enter n
     do (if n.label = gram.nameApl then
            n. father -> nx;
            (if nx.label = gram.remote then
                nx -> n
        if)if)
     exit n
     #);
   node1: @ASTindex
do true -> error -> fatalError;
   node -> encloser -> node1;
   (if not (node1.asAst).hasLocalError then
       CheckState.errCount+1 -> CheckState.errCount;
       (if CheckState.errCount = 1 then
           node.theFragmentForm -> errorNotification;
           (*thisTranslate.semanticErrorsNotification; *)
       if);
       (node,errNo) -> CheckState.PrintMessage;       
       (if errNo = 0 then stop if)
   if)
#)
--warning:descriptor--
(* Warnings are delayed until after the checking is completed.
 * A node can only hold one error message or one warning.
 * A warning on a node will thus block for an error message.
 * The warnings will therefore first be inserted in the AST after
 * the checking. I.e. when no more errors can occur.
 *)
(#
do L:
     (#do
        (if errNo
         // 24 (* qua*) then
            (if (not common.switch[60]) 
                and (common.switch[42] or common.switch[19]) then
                leave L
            if)
         // 95 (* ^R.P dynamic *) then (if common.switch[90] then leave L if)
        if);
        (* all other warnings cannot be suppressed *)
       (if not (node.asAst).hasLocalError then
           (if (CheckState.wTop+1->CheckState.wTop) > CheckState.warn.range
               then
               CheckState.warn.range -> CheckState.warn.extend; 
               CheckState.err.range -> CheckState.err.extend
           if);
           node[] -> CheckState.warn[CheckState.wTop][];
           errNo -> CheckState.err[CheckState.wTop]  
       if)
     #)
#)
---ErrorReport:doPart---
do (# T: ^text
   do L[1][] -> T[];
      (for i: L.range-1 repeat
           (if (i <= E.range) and (E[i][] <> none) then
               checkState.eClear;
               E[i] -> checkState.eScan;
               (if common.switch[441] then
                   (E[i][],T[],0) -> PP;
                else
                   (E[i][],T[],10) -> PP
               if);
               checkState.eRestore; 
           if);
           (if L[i+1][] <> none then
               L[i+1][] -> T.append
           if)
      for);
      (if isWarning then
          (EV[],T[]) -> NewWarning
       else
          (EV[],T[]) -> NewError
      if)
   #)
---NewError:doPart--
do (# no: @integer
   do m[] -> addErrorMsg -> no;
      (EV,no) -> SemError
   #)
---noInner:doPart---
do (if (CheckState.top+1->CheckState.top) > CheckState.pd.range then
       CheckState.pd.range -> CheckState.pd.extend; 
       CheckState.md.range -> CheckState.md.extend
   if);
   preDesc[] -> CheckState.pd[CheckState.top][]; 
   desc[] -> CheckState.md[CheckState.top][]
   
---ErrorPrint:descriptor---
(# FF: ^FragmentForm
do (if verboseLevel < verboseLevel.actions then
       '\n\nPrinting lst-file' -> messagestream.puttext;
   if);
   theGroup.scan
   (# R: @ASTindex
   do (if current.type = FormType then 
          current[] -> FF[]; 
          '-------'->lst.PutText; 
          FF.name -> lst.Puttext; 
          ':' -> lst.Put; 
          (if FF.Category
           // gram.objectDescriptor // gram.descriptorForm then
              'ObjectDescriptor' -> lst.puttext
           // gram.attributesForm // gram.attributes // gram.attributeDecl
              then 'Attributes' -> lst .puttext
           // gram.doPart then 'DoPart' -> lst.puttext
           // gram.mainPart then 'MainPart' -> lst.puttext
           else '... ' -> lst.puttext
          if);
          '-------' -> lst.putLine;
          FF.theGSForm->R; 
          (R[],lst[],5000) -> PP;
   if)#);
#)
---NewWarning:doPart---
do (# no: @integer
   do m[] -> addWarningMsg -> no;
      (EV,no) -> Warning
   #)
---computedRemoteError:doPart---
do (if no 
    // 84 then
       (EV[],false) -> makeError
       (#
       do 'The compiler cannot handle the computed-remote call: "' -> xT;
          EV[] -> XA;
          '"\n*  inside the descriptor:\n*  "' -> XT;
          desc[] -> XA; 
          '"\n*  since the call is recursive' -> XT
       #);
    else
       (EV[],false) -> makeError  
       (# E: @ASTindex
       do 'In the computed-remote: "' -> XT;
          EV[] -> XA;
          '", "' -> XT;
          EV.son -> E;
          E[] -> XA;
          (if no
           // 81 then '" cannot be an evaluation-list' -> XT
           // 82 then '" must have one exit-element' -> XT
           // 83 then '" is not a allowed here' -> XT
           else
              '" unknown error???\n' -> XT;
              '>>>Please report this to "support@mjolner.com"'
                -> XTl
          if)
       #)
   if)

