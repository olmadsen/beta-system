ORIGIN 'checkerdopart';
LIB_ITEM 'betacompiler';
INCLUDE 'nxoffsets';
BODY 'checklibbody'
---ChkFormLib:attributes---
GetSpecSize:
  (# catSort: @ ASTindex; 
     kind,size,access: @ integer;
  enter(catSort,kind)
  <<SLOT GetSpecSize:doPart>>
  exit(size,access)
  #);
isPtn:
  (# node,sort: @ ASTindex
  enter(node,sort)
  do (* node is a denotation, which must refer to a pattern *)
     (if sort.label
      // gram.patternDecl // gram.virtualDecl 
      // gram.bindingDecl // gram.finalDecl then (*ok*)
      else (node,4 ) -> WE.SemError
  if)#);
isNonSimplePtn:
  (# node,sort: @ ASTindex; varPtn,isDynObj: @boolean;
     isVarPtn:
       (#
       do (if sort.label = gram.variablePattern then 
              (if not varPtn then (node,4)->WE.SemError if)
           else (node,4)->WE.SemError
          if)
       #)
  enter(node,sort,varPtn,isDynObj)
  do (* node is a denotation, which must refer to a pattern *)
     (if sort.label
      // gram.patternDecl then
         sort.son->sort; sort.brother->sort; (* descriptor *)
         (if sort->DescKind
          // standardKind then
             (if not (sort->CstrucDesc.equal) then (node,39)->&WE.SemError if)
          // dataKind then
             (if not isDynObj then (node,120) -> WE.warning if)
         if)
      // gram.virtualDecl // gram.bindingDecl //gram.finalDecl then (*ok*)
      // gram.simpleDecl then
         sort.son->sort; sort.brother->sort; isVarPtn
      // gram.repetitionDecl then
         sort.son->sort; sort.brother->sort; sort.brother->sort; isVarPtn
      else (node,4)->&WE.SemError
  if)#);
isObject:
  (# node,dcl,sort: @ASTindex; (* dcl must be an object declaration *)
     error:<(#do (node,15)->&WE.SemError; INNER #)
  enter(node,dcl)
  do dcl.sort -> sort;
     (if sort.label // gram.simpleDecl // gram.repetitionDecl then (* ok *)
      else error
  if)#);
isObjectSpec:
  (* node is an ObjectEvaluation. The denotation generated by
   * ObjectEvaluation may however denote a pattern; in this case
   * the syntactic category should have been InsertedObject. This
   * cannot be expressed by the context-free grammar. The boolean
   * 'insertion' will be true in this case.
   * The object denoted by ObjectEvaluation may either be an item,
   * component or system. The actual kind is returned in 'evalKind'.
   *)
  (# node,sort: @ ASTindex; insertion: @boolean; evalKind: @integer;
     
     KindTst: @
       (#
       do itemEval->evalKind;
          (if sort.label
           // gram.staticComponent // gram.dynamicComponent then
              compEval->evalKind
           // gram.variablePattern then true->insertion
       if)#)
  enter(node,sort)
  do (if sort.label
      // gram.patternDecl // gram.virtualDecl
      // gram.bindingDecl // gram.finalDecl then
         True->insertion
      // gram.simpleDecl then (* sort=simple[NL,DATASPEC] *)
         sort.son -> sort;  sort.brother -> sort;
         KindTst
      // gram.repetitionDecl then
         (* sort=(repetition <NL> <index> <DATASPEC>) *)
         sort.son -> sort; sort.brother -> sort;sort.brother-> sort;
         KindTst
      // gram.forImp  then
         (* NB. in R: [I:10] .. both R and I has repetition as
          sort. I should have namedIndex as sort!!!!!!!!!!!!*)
      else (node,5) -> WE.SemError;
     if)
  exit(insertion,evalKind)
  #);
isLab: 
  (# lab,dclRef,sort: @ ASTindex
  enter lab
  do lab.dclref -> dclRef;
     dclRef.sort -> sort;
     (if sort.label <> gram.labelledImp then 
         (lab[],thisDesc,lab.on,3(*lab*))->isEnclosing
  if)#);
isEnclosing:
  (* N is a nameApl in desc used in this(N) or inner N;
   * N must be an enclosing pattern of desc:
   *  N: (# ...... (# ... this(N) ... #) #)
   * inner N is only legal in do-part:
   * N: (# ... do ... (# ... do ... inner N #) #)
   * on does not include possible nested for-loops,labelled imp's, etc.;
   * note that on>0; in 
   *    N: (#  do  inner N #)
   * N.on=1
   *)
  (# N: ^ASTindex; desc: @ASTindex; on: @integer; 
     thisInnerLab: @integer;
     (* 1: this as in this(P)
      * 2: inner as in inner P
      * 3: lab as in restart P or leave P
      * If inner or lab then only legal in doPart of  P
      *)
     inDo: @Boolean (* only legal in do-part *)
  enter(N[],desc,on,thisInnerLab)
  do <<SLOT isEnclosing:descriptor>>
  #);
AllocNXtmp: (* NOT used anymore - elim *)
  (# EV,encDesc: ^ASTindex; isN,outer: @boolean; 
     NXO: ^NXoffSets
  enter(EV[],isN,encDesc[],NXO[],outer)
  <<SLOT AllocNXtmp:doPart>>
  #);
MarkDesc:
  (# desc: ^ASTindex; descKind,xType: @Integer; (* byte *)
     hasNcode,hasDo,hasXcode,isData,hasInner,insertable
     ,hasAcode,hasOnlyInner,inlineNX,inlineDO,hasOnlyNX: @boolean;
     descAccess: @integer (* OBS only 0 or 1 *)
  enter(desc[],descKind,hasNcode,hasDo,hasXcode,isData,hasInner
     ,insertable,descAccess,hasAcode,hasOnlyInner,inlineNX,inlineDO
     ,hasOnlyNX,xType)
  do <<SLOT MarkDesc:descriptor>>
  #);
DumpDesc:
  (# desc: ^ASTindex
  enter desc[]
  do <<SLOT DumpDesc:descriptor>>
  #);
