ORIGIN 'nxoffsets';
LIB_ITEM 'betacompiler';
---NXoffSetsLib:attributes---
SetNXOffSets:
  (# desc: ^ASTindex;
     isEnter: @boolean;
     chain: ^BV.superChain;
     start: @integer;
     GeneralDesc:
       (# AllocPrefNX: @
            (* perhaps tricky - see docheck:GetPreDesc *)
            (# preDesc: @ASTindex; mn,isV: @integer
            do (if pref.label = gram.prefix then
                   (if false then
                       chain[] -> BV.ENC -> chain1[]; (* ? *)
                       (*(pref.son,chain1[]) -> GetTheDesc -> (preDesc,chain1[]);*)
                       (*********** VIRTUAL ********)
                       (*pref.son -> sematt.descrip -> preDesc;*)
                       (*pref.son -> getDesc -> preDesc[];*)
                       
                       (*** CLEAN-UP **)
                       chain[] -> BV.PRE -> chain1[];
                       (chain[],pref.son) -> BV.theDesc -> (preDesc,mn,chain2[],isV);
                    else
                       (* the computation of chain is tricky; an explanation
                        * should be added. It is ccode copied from:
                        *    sematt.bet: NXScanner:mkNXlst: 
                        *         (if pre.label = gram.prefix then ...
                        *)
                       chain[] -> BV.ENC -> chain2[]; 
                       (chain2[],pref.son) 
                         -> BV.theDesc 
                         -> (preDesc,mn,chain2[],isV);
                        chain[] -> BV.PRE -> chain1[];
                   if);                   
                   (preDesc[],isN,outer,chain1[]) -> GeneralDesc
               if)
            #);
          pref,mainP,att,entP,doP,exitP: ^ASTindex;
          desc,EV: ^ASTindex; E1: @ASTindex;
          isN,outer: @boolean;
          chain,chain1,chain2: ^BV.superChain;
          PL: @integer
       enter(desc[],isN,outer,chain[])
       do (if ctst then
              179->trace(#do 'GeneralDesc:'->xT; desc[] -> xA; (*chain.print*) #)
          if);
          desc[]
            -> DescSonsRef
            -> (pref[],mainP[],att[],entP[],doP[],exitP[]);
          AllocPrefNX;
          (if isN then
              (if entP.label <> gram.empty then
                  (*(if outer then entP.NXoff -> startOff if);  (* elim *)
                  entP.son -> E1;
                  (E1[],true,desc[],chain[],outer) -> AllocNXtmp;
              if)
           else
              (if exitP.label <> gram.empty then
                  (*(if outer then exitP.NXoff -> startOff if);  (*elim *)
                  exitP.son -> E1;
                  (E1[],false,desc[],chain[],outer) -> AllocNXtmp;
          if)if)
       #);

     AllocNXtmp:
       (# EV,encDesc: ^ASTindex; EVx: @ASTindex; isN: @boolean;
          AllocForObj: 
            (# E: ^ASTindex;
               E1,desc: @ASTindex;  MN: @integer; isV: @integer;
               pref,mainP,att,entP,doP,exitP: ^ASTindex;
               chain1: ^BV.superChain
            enter E[]
            do (if ctst then
                   179->trace(#do 'AllocForObj:'-> xT; E[]->xA; xN; chain.print #)
               if);
               E.son -> E1;
               (if E1.label = gram.remotePrimitive then
                   (E[],chain[],4) -> AllocVal
                else 
                   (chain[],E1) -> BV.theDesc -> (desc,MN,chain1[],isV); (* virtual*)
                   (if ctst then
                       179->trace(#do 'theDesc:'->xT; desc[] -> xA #)
                   if);
                   (if (E1->sematt.SimpleOrRep)
                    // gram.dynamicItem // gram.dynamicComponent
                    // gram.variablePattern
                    // gram.staticItem //gram.staticComponent then 
                       (if ctst then 
                           179->trace(#do 'IsRep:'-> xT; E1[]-> xA #)
                       if);
                       (E[],chain[],4) -> AllocRep
                    else 
                       L:
                         (if (desc -> sematt.descKind) 
                          // sematt.standardKind // sematt.constKind then
                             (# D: @ASTindex
                             do E.son -> D;
                                (if outer and (D.label = gram.nameApl) then
                                    (if D.on = 0 then 
                                        D.dclRef -> D;
                                        (E[],none,desc.size,D.off) -> MarkVal;
                                        leave L
                             if)if)#);
                             (E[],chain[],desc.size) -> AllocVal
                          else
                             desc[] -> testAndCheckDesc;
                             (desc[],isN,false,chain1[]) -> GeneralDesc
               if)if)if)
            #);
          chain: ^BV.superChain; outer: @boolean
       enter(EV[],isN,encDesc[],chain[],outer)
       do (if ctst then
              179->trace(#do 'AllocNXtmp:'-> xT; EV[]-> xA; (*chain.print*) #)
          if);
          L:
            (if EV.label
             // gram.assignmentEvaluation then
                (* allocate simple value or list of simple values??*)
                EV.son -> EV;
                (if not isN then EV.brother -> EV if);
                (*(EVx[],true,encDesc[],chain[],outer) -> AllocNXtmp*)
                (if ctst then
                    179->trace(#do 'AllocNXtmp2:'-> xT; EV[]-> xA #)
                if);
                restart L
             // gram.insertedItem 
             // gram.objectDenotation 
             // gram.dynamicItemGeneration 
             // gram.dynamicComponentGeneration then
                (* where do we store the list of offsets?
                 * the following call will override in object EV
                 * and not in the object with the enter/exit element.
                 * We probably have to enumerate whenever being used
                 *)
                EV[] -> AllocForObj
             // gram.computedObjectEvaluation then 
                'AllocNXtmp:ComputedEv'->putline
             // gram.objectReference 
             // gram.structureReference then
                (# D: @ASTindex; isStruc: @boolean
                do EV.son -> D; D.son->D;
                   EV.label = gram.structureReference -> isStruc;
                   (if ctst then
                       178->trace(#do 'nxOff:ref:'->xT; outer->xB; D.on->xI; 
                                    100->switchOn; D[]->xA; 100->switchOff 
                                 #)
                   if);
                   (if outer AND (D.label = gram.nameApl) AND (D.on = 0) then
                       D.dclRef -> D;
                       (if D.access = common.direct then
                           (EV[],chain[],4,isStruc) -> AllocRef
                        else
                           (EV[],chain[],4,D.off,isStruc) -> MarkRef
                       if)
                    else 
                       (EV[],chain[],4,isStruc) -> AllocRef
                if)#)
             // gram.evalList then 
                EV.son -> EVx; 
                EVx -> scanList
                (# E: ^ASTindex 
                do &ASTindex[] -> E[]; currentNode-> E; 
                   (E[],isN,encDesc[],chain[],outer) -> AllocNXtmp ;;
                   (if ctst then
                       179->trace(#do 'List:'->xT; (*chain.print*) #)
                   if)
                #)
             // gram.integerConst // gram.noneExp then 
                (* skip if outer level - no attribute space reserved.
                 * Check this for other categories as well
                 *)
                (EV[],chain[],4) -> AllocVal
             // gram.textConst then
                (EV[],chain[],4) -> AllocVal
             // gram.repetitionSlice then
                (EV[],chain[],4) -> AllocRep
             // gram.notExp (* perhaps just alloc a boolean *)
             // gram.unaryMinusExp // gram.unaryPlusExp then
                (EV[],chain[],4) -> AllocVal
             // gram.unaryPrimitiveExp 
             // gram.primitive then
                (EV[],chain[],4) -> AllocVal
             else
                (if (EV.label -> EvalClass) = EvalClass.binOp then
                    (EV[],chain[],4) -> AllocVal
                 else
                    'NXtmp NOT found' -> putline
                if)
            if)
       #)
  enter(desc[],isEnter,chain[],start)  
  do (*desc->BV.newSingle -> chain[];*)
     (if ctst then
         178->trace
         (#
         do 'SetNXoffSets:\n' -> xT; desc[] -> xA; newline; chain.print
         #)
     if);
     start -> startOff;
     (desc[],isEnter,true,chain[]) -> GeneralDesc;
     (if ctst then
         178->trace
         (#
         do (if isEnter then 'SetNOffSets:\n'->xT 
             else 'SetXoffSets:\n'->xT 
            if);
            desc[]->xA; xN; dump 
         #)
     if)
  #);
