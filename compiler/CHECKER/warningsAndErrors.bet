ORIGIN '../CONTROL/system'; (* to include index *)
LIB_ITEM 'betacompiler';
INCLUDE '../CONTROL/com';

BODY 'warningsAndErrorsBody';
---astInterfaceLib:attributes---
WarningsAndErrors:
  (# init:<
       (#
       enter(common[],gram[],theGroup[],lst[],messagestream[],verboseLevel)
       <<SLOT WE_init:doPart>>
       #);
     PP:<
       (# D: ^ASTindex; S: ^stream; L: @integer
       enter(D[],S[],L) 
       do inner
       #);
     hasInner:<  booleanValue(# d: ^ASTindex enter d[] do INNER #);
     errorNotification:<
       (# ff: ^FragmentForm;
       enter ff[]
       do inner
       #);
     
     
     Common: ^commonDef;
     Gram: ^Grammar; 
     theGroup: ^fragmentGroup;
     lst,messagestream: ^stream;     
     
     (* NEEDS fixing: must be related to verboselevel in system *)
     verboseLevel: @ (* Level of output during compilation: *)
       (# v: @Integer;
          verbose: (# exit 0 #); (* more than default? *)
          default: (# exit 1 #); (* normal, the old way, open, bind, etc. *)
          actions: (# exit 2 #); (* only if somthing happens, parse, etc.*)
          nothing: (# exit 3 #); (* nothing, only errors *)
       enter v
       exit v
       #);
     error,fatalError: @boolean; 
     
     CheckState: @ <<SLOT CheckState:descriptor>>;
     
     SemError: 
       (* FORM doCheck may crash if there is semantic errors !!!! 
        * Semantic errors: see ~beta/betaast/$V/semanticerrortext.bet
        *)
       (# node: @ AStindex; errNo: @integer
       enter(node,errNo) do <<SLOT SemError:descriptor>>
       #);
     Warning:
       (* for reporting warnings *)
       (# node: @ AStindex; errNo: @integer
       enter(node,errNo) do<<SLOT warning:descriptor>>
       #);
     
     NewWarning:
       (# EV: ^ASTindex; m: ^text; 
       enter(EV[],m[])
       <<SLOT NewWarning:doPart>>
       #);  
     ComputedRemoteError:
       (# no: @integer; EV,desc: ^ASTindex
       enter(no,EV[],desc[])
       <<SLOT computedRemoteError:doPart>>
       #);
     EmitWarningsAndErrors:
       (# errCount,warnCount: @integer;
       do EmitDelayedMsg ->( errCount,warnCount);
          (if (errCount > 0) or (warnCount > 0) then
              messagestream.newline;
          if);
          (if errCount > 0 then
              '\nNo. of fatal errors: ' -> messagestream.puttext; 
              errCount -> messagestream.putInt
          if);
          (if warnCount > 0 then
              '\nNo. of warnings:     ' -> messagestream.puttext; 
              warnCount -> messagestream.putint
          if);
          
          (if error then 
              (if verboseLevel<verboseLevel.actions then
                  '\n\nA detailed marking of '->messagestream.puttext;
                  (if true
                   // (errCount>0) and (warnCount=0) then 
                      'semantic errors '-> messagestream.puttext
                   // (errCount=0) and (warnCount>0) then
                      'warnings '-> messagestream.puttext
                   // (errCount>0) and (warnCount>0) then 
                      'semantic errors and warnings '->messagestream.puttext
                  if);
                  (if common.switch[32] then 
                      'can be generated by turning'
                      '\nthe--nolist (-l) option off\n\n'
                        -> messagestream.puttext;
                   else 
                      'may be found in the file:\n\t'->messagestream.puttext;
                      theGroup.fullName->messagestream.puttext; '.lst'
                        -> messagestream.puttext;
                      errorPrint 
                  if)
               else
                  (* compiler called with --mute *)
                  (* to complete error/warning output *)
                  messagestream.newline;
                  (if not common.switch[32] then
                      errorPrint
                  if);
              if);
          if);
       exit(error,fatalError)
       #);
     MakeError:
       (# L: [0] ^text; E: [0] ^ASTindex;
          XT:
            (# T: ^text
            enter T[]
            do 1 -> L.extend;
               T[] -> L[L.range][]
            #);
          XTl: (* add text to the last item *)
            (# T: ^text
            enter T[]
            do T[] -> L[L.range].append
            #);
          XA:
            (# ev: ^ASTindex;
            enter ev[]
            do 1 -> E.extend;
               ev[] -> E[E.range][]
            #);
          EV: ^ASTindex;
          isWarning: @boolean
       enter(EV[],isWarning)
       do INNER;
          (EV[],L,E,isWarning) -> ErrorReport
       #);                           
     ErrorReport:
       (# EV: ^AStindex; L: [1] ^text; E: [1] ^ASTindex; 
          isWarning: @boolean
       enter(EV[],L,E,isWarning) (* PRE: L.range = (E.range + 1) *)
       <<SLOT errorReport:doPart>>
       #);
     NewError:
       (# EV: ^ASTindex; m: ^text; 
       enter(EV[],m[])
       <<SLOT NewError:doPart>>
       #);  
     NoInner:
       (* mark that the super descriptor has no inner *)
       (# preDesc,desc: ^AStindex
       enter(preDesc[],desc[]) <<SLOT NoInner:doPart>>
       #);
     EmitDelayedMsg:
       (* Delayed error messages are emitted. This includes possible
        *  'super has no inner' an warnings.
        * For 'super has no inner', it is checked 
        * if the super still has no inner.
        * In situations like
        *    P: (# do ...; &(# do ...; inner P; ... #);
        *    P(# do ... #)
        * the descriptor P(# ... #) may be announced as having no inner,
        * since the the inner singular descriptor of P may not have been
        * checked before P(# ... #) is checked.
        * This procedure checks if the super desc still has no inner in which
        * case an error message is given.
        *)
       (# errCount,warnCount: @integer
       do <<SLOT EmitDelayedMsg:descriptor>>
       exit(errCount,warnCount)
       #);
     Errorprint: <<SLOT ErrorPrint:descriptor>>;

  #)
