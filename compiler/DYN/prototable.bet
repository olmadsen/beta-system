ORIGIN '~beta/containers/hashTable';
INCLUDE '~beta/sysutils/objinterface'
        '~beta/containers/list'
        '~beta/basiclib/numberio';
-- lib: Attributes --
protoTable: hashtable
  (#
     element:: 
       (# protoAddress: @integer; FGname: ^text
       enter (protoAddress,FGname[])
       exit (protoAddress,FGname[])
       #);
     rangeInitial::  (#  do 19->value #);
     hashFunction::  (#  do e.protoAddress->value #);
     groupID:
       (#
          protoAddress: @integer;
          originFGname: ^text;
          elm: ^element;
          searchElm: @element
       enter protoAddress
       do
          protoAddress->searchElm.protoAddress;
          searchElm[]->hashFunction
            ->findIndexed
              (#
                 NotFound:: 
                   (# dummyProto: @prototype
                   do
                      protoAddress->dummyProto;
                      dummyProto.groupID->originFGname[]
                   #);
                 predicate:: 
                   (#  do (current.protoAddress = protoAddress)->value #)
              do 'GroupId: ' -> putline;
                 current.FGname[]->originFGname[];
                 'done' -> putline
              #)
       exit originFGname[]
       #);
     removeProto:
       (#
          protoAddress: @integer;
          originFGname: ^text;
          elm: ^element;
          searchElm: @element
       enter protoaddress
       do
          protoAddress->searchElm.protoAddress;
          searchElm[]->hashFunction
            ->findIndexed
              (#
                 NotFound::  (#  do 'This should not happend'->putLine #);
                 predicate:: 
                   (#  do (current.protoAddress = protoAddress)->value #)
              do current[]->delete
              #)
       #)
  #);
integerList: list (# element:: integerObject #);
fragmentGroupTable: hashtable
  (#
     element:: 
       (# protoAddresses: ^integerList; FGname: ^text
       enter (protoAddresses[],FGname[])
       exit (protoAddresses[],FGname[])
       #);
     rangeInitial::  (#  do 19->value #);
     hashFunction:: 
       (#  do e.FGname.scanAll (#  do ch+value->value #) #);
     removeFragmentGroup:
       (#
          fragName: ^text;
          dummyElm: @element;
          PTtable: ^prototable;
          anIntegerList: ^integerList
       enter fragName[]
       do
          objectPool.get
            (#
               Type:: protoTable;
               init::
                 (# 
                 do
                    'removeFragmentGroup: This should not happend'->putLine;
                    stop
                 #)
            #)->PTtable[];
          (none ,fragName[])->dummyElm;
          dummyElm[]->hashFunction
            ->findIndexed
              (#
                 NotFound::
                   (# 
                   do 'removeFragmentGroup: This should not happend'->putLine
                   #);
                 predicate::
                   (#  do (fragName[]->current.FGname.equal)->value #)
              do
                 current.protoaddresses.scan
                   (#  do current->PTtable.removeProto #);
                 current.protoAddresses[]->anIntegerList[];
                 current[]->delete
              #)
       exit anIntegerList[]
       #);
     getIntegerList:
       (# fragName: ^text; dummyElm: @element; anIntegerList: ^integerList
       enter fragName[]
       do
          (none ,fragName[])->dummyElm;
          dummyElm[]->hashFunction
            ->findIndexed
              (#
                 NotFound:: 
                   (# 
                   do
                      'GetIntegerList: This should not happend'->putLine;
                      'FGname: '->puttext;
                      fragname[]->putLine
                   #);
                 predicate:: 
                   (#  do (fragName[]->current.FGname.equal)->value #)
              do current.protoAddresses[]->anIntegerList[]
              #)
       exit anIntegerList[]
       #)
  #);
scanPTtable:
  (# PTtable: ^protoTable
  enter PTtable[]
  do
     'Dumping prototable: '->putLine;
     PTtable.scan
       (# 
       do
          current.protoAddress
            ->putReal (# format::  (#  do 0->precision #) #);
          newLine;
          current.FGname[]->putLine
       #)
  #);
scanFGtable:
  (# FGtable: ^fragmentGroupTable
  enter FGtable[]
  do
     'Dumping fragmentGroupTable:'->putLine;
     FGtable.scan
       (# 
       do
          current.FGname[]->putLine;
          current.protoAddresses.scan
            (#  do current->putInt; ' '->putText #);
          newLine
       #)
  #)  

