ORIGIN '~beta/basiclib/v1.5/betaenv';
INCLUDE '~beta/basiclib/v1.5/numberio'
        '~beta/containers/v1.5/hashTable'
        '~beta/basiclib/v1.5/texthash';
OBJFILE default '$/labelnametable.o';
MAKE default 'external/labelnametable.make';
-- lib: Attributes --
initReadNameTable: external
(* Forks an nm process and sets up a pipe from which addresses and
 * labels may be read using "nextAddress" and "nextLabel". *)
  (# execFileName: [1] @Char;  enter execFileName #);
nextAddress: external (* exits 0 if no more code labels are available. *)
  (# address: @Integer;  exit address #);
nextLabel: external (# label: [1] @Char;  exit label #);
nameTable: hashTable
  (#
     element::
       (#
          name: ^text;
          adr: @integer;
          display:
            (# s: ^stream
            enter s[]
            do
               (if s[] = none then screen[]->s[] if);
               'Label:'->s.puttext;
               adr->s.puthex;
               ' '->s.put;
               name[]->s.putline;
               
            #)
       #);
     init:
       (# exeName: ^text; 
       enter exeName[]
       do
          exeName->initReadNameTable;
          H.init;
          loop:
            (# adr: @Integer; label: @Text
            do
               nextAddress->adr;
               nextLabel->label;
               (if trace then
                   'Label:'->puttext; adr->puthex; ' '->put; label[]->putline; 
               if);
               (label.copy,adr)->add;
               (if not ('_end'->Label.equal) then restart loop if)
            #)
       #);
     hashFunction:: (#  do e.name[]->H.hash->value #);
     equal:: (#  do left.name[]->right.name.equal->value #);
     add:
       (# name: ^text; adr: @integer; e: ^element
       enter (name[],adr)
       do &element[]->e[]; name[]->e.name[]; adr->e.adr; e[]->insert; 
       #);
     lookup:
       (# name: ^text; e: @element; adr: @integer
       enter name[]
       do
          name[]->E.name[];
          e[]->hashFunction
            ->findIndexed
              (# predicate::  (#  do (e[],current[])->equal->value #)
              do (*current.display*) current.adr->adr
              #)
       exit adr
       #);
     H: @honeyMan;
     trace: @boolean
  #)  

