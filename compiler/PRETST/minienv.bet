MDBODY pre 'minienv_prebody'

---------------betaenv: descriptor---------------   
(************************************************
 *          Component BETA environment          *
 ************************************************)
(# charValue: (# value: @char do INNER exit value #);
   BOOLEAN: (#  #);  
   FALSE: BOOLEAN(# #);  
   TRUE: BOOLEAN(# #);  
   int8: (# #);
   CHAR: (# #); int8u: (# #);
   int16: (# #);
   int16u: (# #); shortInt: (# #);
   int32: (# #); INTEGER: (# #);
   int32u: (# #);
   int64: (# #); 
   int64u: (# #);    
   real: (# x,y: @integer enter(x,y) exit(x,y) (* realdesc *) #);
   real32: (* single precision real for bytecode only *) (# #);   
   External:
     (# CallC,CallStd,CallPascal,Pascal,PascalTrap,
  	cExternalEntry,PascalExternalEntry: @text   
     #);       
   Com: (# #); 
   Holder: (# adr: @ integer #);   
   state: (# #);
   IntegerValue: (# value: @integer do INNER exit value #);
   IntegerObject: IntegerValue(# enter value do INNER #);
   
   proc: (# procname: @text #); 
   static_proc: (# procname: @text #); 
   cons: (# procname: @text #); 
   static_cons: (# procname: @text #); 
   class: (# #);
   externalClass: (# classname: @text #);
   Structure: (# #);  
   Data: (# #);       
   ErrorName: (# #);       
   Object:  
     (# _Struc:  
          (# (* Changed 12/8/97 by datpete: 
              * eliminates need for runtime routine ThisS
              *)    
             (* R: ##Object do TOS'ThisS'->R## exit R## *)
          exit THIS(Object)##   
          #);     
     do INNER 
     #);
   repetition:      
     (* pattern describing repetitions.
      * Do NOT use as superpattern!!! 
      *) 
     (# range: (* exit the range of THIS(rep) *)
          (# n: @ integer exit N #);
        new:  
          (* allocate a new repetition of N elements
           * the current elements in THIS(rep) becomes inaccessible
           *)  
          (# n: @integer enter n #);
        extend: (* extend THIS(rep) by N elements *)
          (# N: @integer enter N #);  
     #);
   stream:
     (# put:< (# ch: @ char enter ch do inner #);
        newline: (# do '\n' -> put #);
        puttext:
          (# T: ^text
          enter T[]      
          do (for i: T.T.range repeat T.T[i]-> put for);  
          #);
        putLine:   
          (# T: ^Text   
          enter T[] do T[] -> puttext; newline 
          #);  
        get:< (# ch: @char do inner exit ch #);
        putInt: 
          (# n,i: @integer; W: [12]@char  
          enter n 
          do (if n < 0 then '-'->put; -n->n if); 
             0->i;
             L:    
               (if n = 0 then   
                   (if i = 0 then 
                       '0'->put
                    else
                       (for j:i repeat
                            W[i-j+1]+'0'->put
                   for)if)  
                else 
                   n mod 10 -> W[i+1->i];  
                   n div 10 ->n;    
                   restart L 
               if)
          #);  
     #);
   text: stream
     (# T: [100] @char; lgth,pos: @integer ;
        setT: (# enter T do T.range -> lgth -> pos #);
        clear: (# do 0 -> pos #);
        put::<
          (# 
          do (if (pos+1->pos) <= T.range then
                 ch -> T[pos]
             if)
          #);
     enter setT  
     exit T     
     #);
   main_program: 
     (# <<SLOT LIB:attributes>>;
        stdIn,stdOut: ^stream;
        args: ^text 
     enter(stdIn[],stdOut[],args[])
     do <<SLOT program:descriptor>>
     #);
   scheduler: <<SLOT scheduler:descriptor>>
do scheduler
#)
 

 
