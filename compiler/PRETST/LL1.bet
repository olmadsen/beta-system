ORIGIN 'minienv'  
-- PROGRAM: descriptor ---
(# (* Example of BETA program implementing          *)
   (* a small primitive recursive descent parser    *)
   (* for expressions like: a * (b + c) !           *)
   (* ! terminates the input.                       *)
   (* The following grammar is used: *)
   (*   <exp>:: = <term> {('+' | '-') <term>}*      *)
   (*   <term>:: = <factor> {('*' | '/') <factor>}* *)
   (*   <factor>:: = 'a' | 'b' | 'c'                *)
   (*             |  '(' <exp> ')'                  *)
   (*                                               *)
   (* A trace of the recursive activations          *)
   (* generated during parsing is printed.          *)
   (* In addition a reverse polish translation      *)
   (* of the input is printed.                      *)
   NextChar: 
     (* read next char from screen *)
     (# 
     do skipBlanks: 
          (if (stdIn.get -> ch) // ' ' then
              restart skipBlanks
          if);
     #);
   ch: @char; (* next char on input  *)
   (* Trace and ind are used for generating a trace of recursive calls
    * encountered during parsing
    *)
   ind: @integer; (* current indentation *)
   Trace: 
     (# nest: 
          (# T: @text; n: @integer
          enter(T,n)
          do T[] -> stdOut.putText; stdOut.newline;
             ind+n -> ind;
             (for i: ind repeat ' ' -> stdOut.put for)
          #)
     do '[' -> stdOut.put; INNER; ('] ',-1) -> nest
     #);
   Exp: Trace
     (# c: @char
     do ('Exp',1) -> nest;
        &Term;
        parseAddOp: 
          (if ch // '+' // '-' then
              ch -> c;
              NextChar;
              &Term;
              c -> save;
              restart parseAddOp
     if)#);
   Term: Trace
     (# c: @char 
     do ('Term',1) -> nest;
        &Factor;
        parseMultOp: 
          (if ch // '*' // '/' then 
              ch ->  c;
              NextChar;
              &Factor;
              c -> save;
              restart parseMultOp
          if)
     #);
   Factor: Trace
     (# do
        ('Factor',1) -> nest;
        L: (# 
           do (if ch
               // 'a' // 'b' // 'c' then 
                  ch ->  save;
                  NextChar;
                  leave L
               // '(' then
                  NextChar;
                  &Exp;
                  (if ch // ')' then
                      NextChar;
                      leave L
                  if)
              if);
              '?' -> stdOut.put;
           #);
     #);
   Save: @
     (# T: @text;
        init: (# do T.clear #);
        print: (# do T[] -> stdOut.putText #);
     enter T.put
     #);
do 0 -> ind;
   save.init;
   'Type an expression: ' -> stdOut.putText;
   NextChar;
   &Exp;
   stdOut.newline;
   Save.print; stdOut.newline;
#)











