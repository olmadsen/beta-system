ORIGIN 'minienvbody' ;
INCLUDE 'Queue';
BUILD pre
'pre/BetaComponent.prc'
'BetaComponent.st'
'pre-st -o $0 $1';

BUILD pre
'pre/BetaStructure.prc'
'BetaStructure.st'
'pre-st -o $0 $1';

---minienv_lib:attributes---
trace: (# exit false #);

InterruptHandler: class 
  (# writeText: external
       (# T: [0] @char 
       enter T        
       do '%primitive:put' -> callC 
       #);   
     handle: proc
       (#
       do scheduler.switch
       #)
  #);
 
setClockInterruptHandler: external
  (#  
  do '%primitive:setClockInterruptHandler' -> callC  
  #);   

---terminate:descriptor---
(#
do terminated -> status;
   scheduler.disableInterrupt (* make sure we do not handle 
                               * interrupts immediately after 
                               * termination and before
                               * interrup is disabled by scheduler
                               *)
#)
--fork:doPart-- 
do 
   P[] -> scheduler.SQS.insert
---semaphore_rep:descriptor---
(# cnt: @integer;
   delayed: @Queue
#)
---semaphore_wait:dopart---
do scheduler.disableInterrupt; 
   (if trace then
       'wait:'->scheduler.out.puttext;
       scheduler.active.id[] -> scheduler.out.puttext;
   if);
   (if (rep.cnt-1 -> rep.cnt) < 0 then
       waiting -> scheduler.active.status;
       (if trace then ':delaying' -> scheduler.out.putline if);
       scheduler.active[] -> rep.delayed.insert;
       scheduler.active.%xsuspend; (* we suspend - 
                                    * and interrupt is enabled by the scheduler
                                    *)
    else
       (if trace then ':OK' -> scheduler.out.putline if);
       scheduler.enableInterrupt
   if);
   

---sempahore_signal:dopart---
do scheduler.disableInterrupt;
   (if scheduler.active[] <> none then
       (if trace then 
           'signal:'->scheduler.out.puttext;
           scheduler.active.id[] -> scheduler.out.puttext
       if); 
       (if (rep.cnt+1 -> rep.cnt) < 1 then
           (* reactivate a waiting component *)
           (# N: ^| beta_system
           do rep.delayed.next -> N[]; 
              (if trace then ':activating: '->scheduler.out.puttext if);
              (if N[] <> none then
                  (if trace then N.id[] -> scheduler.out.putline if);
                  running -> N.status;
                  N[] -> fork;
               else
                  (if trace then 
                      'xno waiting systems' -> scheduler.out.putline 
              if)if)
           #)
        else
           (if trace then scheduler.out.putline if);
       if);
    else
       rep.cnt+1 -> rep.cnt
   if);
   scheduler.enableInterrupt
   
---semaphore_count:doPart---
do rep.cnt -> V
   
---exclusive:doPart---
do scheduler.excl.wait;
   INNER exclusive;
   scheduler.excl.signal

   
---scheduler:descriptor---
(#
   out: @ stream
     (# put::<
          (# write: External  
               (# ch: @char
               enter ch 
               do '%primitive:put' -> callC 
               #);
          do ch -> write
          #) 
        
     #);
   in: @ stream
     (# get::<
          (# read: external 
               (# ch: @char
               do '%primitive:get' -> callC 
               exit ch
               #);
          do read -> ch
          #)
     #);
   setClockInterruptInterval: external
     (# n: @integer
     enter n
     do '%primitive:setClockInterruptInterval' -> callC
     #); 

   switch:
     (#
     do (if intOk then
            (if active[] <> none then
                active.%xsuspend;
            if)
         else
            2000 -> setClockInterruptInterval
        if)
     #);
   IH: @InterruptHandler; (* Need to assure that
                           * InterruptHandler is imported
                           *)
   main: ^| main_program;
   SQS: @ Queue;
   active: ^| beta_system;
   enableInterrupt: (# do true -> intOK #);
   disableInterrupt: (# do false -> intOK #);

   intOK: @boolean;
   excl: @semaphore;
   
do 'Start'->out.putline;
   (in[],out[],'') -> main_program;
   '\nmain ended\n' -> out.puttext;
   (if not SQS.isEmpty then

       setClockInterruptHandler;
       excl.signal;
       L:
         (# 
         do SQS.next -> active[];
            (if active[] = none then leave L if);
            2000 -> setClockInterruptInterval;
            true -> intOK;
            active;
            false -> intOK;
            (*active.id[] -> out.puttext;
             (if active.status = terminated then 'T'->out.put 
              else 'R'->out.put if);
            out.newline;*)
            (if active.status = running then active[] -> SQS.insert if);
            restart L
   #)if)
#)



