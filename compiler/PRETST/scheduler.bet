origin 'minienv';
INCLUDE 'Queue';
BODY 'schedulerbody'
---lib:attributes---
trace: (# exit false #);

InterruptHandler: class 
  (# writeText: external
       (# T: [0] @char 
       enter T         
       do '%primitive:put' -> callC 
       #);   
     handle: proc
       (#
       do current.switch
       #);
     current: ^bSys
  #);

setClockInterruptHandler: external
  (# IH: ^InterruptHandler
  enter IH[]
  do '%primitive:setClockInterruptHandler' -> callC  
  #);   
setClockInterruptInterval: external
  (# n: @integer 
  enter n 
  do '%primitive:setClockInterruptInterval' -> callC
  #); 

bSys:
  (# <<SLOT bSyslib:attributes>>;
     thread: BETA_system 
       (# id: @text; 
          setId: (# T: ^text enter T[] do T -> id #);
          status: @integer;
          terminate: <<SLOT terminate:descriptor>>;
          thisThread: ^| thread;
          continue:< (# do inner #);
       do running -> status;
          INNER;
          terminate
       #);
     cThread: thread
       (# fork:
            (# 
            do thisThread[] -> SQS.insert
            #);
          continue:: (# do fork #)
       do inner
       #);
     active: ^| thread;
     SQS: @Queue;
     semaphore: 
       (# rep: @ <<SLOT semaphore_rep:descriptor>>;
          wait: (# <<SLOT semaphore_wait:dopart>> #);
          signal: (# <<SLOT sempahore_signal:dopart>> #);      
          count:
            (# V: @integer 
              <<SLOT semaphore_count:doPart>>
            exit V
            #)
       #);
     excl: @semaphore;
     exclusive: (# <<SLOT exclusive:doPart>> #);
     intOk: @boolean;
     enableInterrupt: proc(# do true -> intOK #);
     disableInterrupt: proc(# do false -> intOK #);
     
     switch: proc
       (#
       do (if intOk then 
              (if active[] <> none then
                  active.%xsuspend; 
              if)
           else 
              2000 -> setClockInterruptInterval
          if)
       #);
     IH: @InterruptHandler; (* Need to assure that
                             * InterruptHandler is imported
                             *)

  do INNER;
  #);

ConcurrentSystem: bSys
  (# 
  do (*  schedule concurrent cThreads *)
     
     INNER; 
     
     '\nmain ended\n' -> out.puttext;
     (if not SQS.isEmpty then
         (* Threads have been inserted into SQS by fork
          * for concurrent execution 
          * 
          * Setup  handler for clock interrupts
          *)
         this(bSys)[] -> IH.current[];          
         IH[] -> setClockInterruptHandler;
         excl.signal;
         L:
           (# 
           do SQS.next -> active[]; 
              (if active[] = none then leave L if);
              true -> intOK; (* allow handling of interrupts *)
              2000 -> setClockInterruptInterval; (*reactivate clock interrupt*)
              active; (* attach active coroutine *)
              false -> intOK; (* disable interrupt handling *)
              (if trace then
                  active.id[] -> out.puttext;
                  (if active.status = terminated then 
                      'T'->out.put 
                   else 
                      'R'->out.put 
                  if);
                  out.newline;
              if);
              
              (if active.status = running then active[] -> SQS.insert if);
              restart L
     #)if)
  #);
AlternatingSystem: bSys
  (# aThread: thread
       (# start:
            (# 
            do thisThread[] -> SQS.insert
            #);
          continue :: (# do start #)
       do inner
       #)

  do (* schedule alternating aThreads *)
     INNER;
     (if not SQS.isEmpty then
         this(bSys)[] -> IH.current[];          
         L:
           (# 
           do SQS.next -> active[]; 
              (if active[] = none then leave L if);
              active; (* attach active coroutine *)
              (if trace then
                  'ASYS: ' -> out.puttext;
                  active.id[] -> out.puttext;
                  (if active.status = terminated then 
                      'T'->out.put 
                   else 
                      'R'->out.put 
                  if);
                  out.newline;
              if);
              
              (if active.status = running then active[] -> SQS.insert if);
              restart L

           #);
     if)    
  #);

