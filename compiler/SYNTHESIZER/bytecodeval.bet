ORIGIN 'evlib';
INCLUDE 'auxlib';
INCLUDE 'evlib';
INCLUDE 'nxlength';
INCLUDE 'signature';
INCLUDE 'genlib_bytecode';
---mkMethodArgs:doPart---
do (baseAdr[],lEv[],lChain[],isMultiple,llEV[]) -> MethodArgs -> V[]
   
---mkEnterArgs:doPart---
do EnterArgs -> V[]
   
---mkExitMultiVal:doPart---
do exitNo -> ExitMultiVal -> V[]
   
---evalLib:attributes---
methodArgs: evVal
  (# inEnter: @boolean;
     evId:: (# do 'MethodArgs:'->id[] #);
     display::
       (#
       do lEV[]-> xA 
       #);
     loadVal:: 
       (#
       do ((isMultiple,false,true,false,'',none)->eval).loadVal 
            -> V[] 
       #);
     loadVal2:: 
       (#
       do ((isMultiple,false,true,false,'',none)->eval).loadVal 
            -> V[] 
       #);
     pushVal::
       (#
       do '!methodArgs:pushVal:' -> mch.comment;
          ((isMultiple,false,true,false,'',none)->eval).pushVal 
            -> V[];
       #);
     mkReal::
       (#
       do ((isMultiple,false,true,false,'',none)->eval).mkReal 
            -> V[];
       #);
     asgToAdr::
       (# EH: @evalHandler; isRepAdr: @boolean
       do 301->trace(#
                    do 'asgToAdr:'->display; 'rA: ' -> xT; rA.display-> xT
                    #);
          '!methodArgs:asgToAdr:'->mch.comment;
          (if isMultiple then
              'index'-> rA.fieldName.equal -> isRepAdr 
          if);
          (isMultiple,true,true,isRepAdr,'',none) -> eval -> V[];
          301->trace(#do 'methodArgs:asgToAdrX: '->xT; V.display #);
          (* fieldType is not always set: as in 'a' -> c;
           * should perhaps be ensured in genAdr?
           *)
          (if rA.bAdr.localDesc[] <> none then
              rA.bAdr.localDesc[] -> theGen.mkSignature -> rA.fieldType[]
          if);
          rA[] -> V.asgToAdr -> V[];
          (if isMultiple and not isJava then mch.loadLocal if);
          301->trace(#
                    do 'methodArgs:asgToAdrZ: '->xT; 
                       (if V[] = none then
                           'V is None' -> xT
                        else
                           V.display
                       if)
                    #);
       #);
     asgToRefAdr::
       (# rA: ^mch.address; T: ^text
       do 301->trace(#do 'asgToRefAdr:'->display; #);
          '!methodArgs:asgToRefAdr1'->mch.comment;
          (rAbase[],destEV.sonRef,false,rChain[]) -> genAdr -> rA[]; 
          '!methodArgs:asgToRefAdr2:'
            -> (rA.fieldType.copy).prepend -> T[];
            T -> mch.comment;
          (if destEv.label=gram.structureReference then
              (theGen.StructureSignatureId->theGen.specialSignature).asText -> rA.fieldType[]
          if);
          (isMultiple,true,false,false,rA.fieldType[],rA.bAdr.localDesc[]) 
            -> eval -> V[];
          '!methodArgs:asgToRefAdr3'->mch.comment;
          (*V.pushVal -> V[];*)
          '!methodArgs:asgToRefAdr4'->mch.comment;
          (# T: ^text do rA.display->T[]; T -> mch.comment;#);
          (rA[],destEV[],rChain[]) -> V.asgToRefAdr -> V[];
          '!methodArgs:asgToRefAdr5'->mch.comment;
          (if isMultiple and not isjava then mch.loadLocal if);
       #);
     asgToRealAdr::
       (#
       do 301 -> trace(#
                      do 'asgToRealAdr:'->display
                      #);
          rA[] 
            -> ((isMultiple,true,true,false,'',none) -> eval).asgToRealAdr
            -> V[];
          (if isMultiple and not isjava then mch.loadLocal if);
       #);
     asgToRepAdr::
       (#
       do 301->trace(#do 'asgToRepAdr:'->display; #);
          'methodArgs:asgToRepAdr1'->mch.comment;
          (isMultiple,false,false,false,'',sematt.repDesc[]) ->eval -> V[];
          'methodArgs:asgToRepAdr2'->mch.comment;
          (* V.pushVal -> V[];*)
          (rA[],rEV[],rChain[]) -> V.asgToRepAdr -> V[];
          'methodArgs:asgToRepAdr3'->mch.comment;
          (*((12),1,1) -> (eval).asgToMethod*)
       #);
     asgToRepElm::
       (#
       do 301->trace(#
                    do 'asgToRepElm:'->display
                    #);
          (rA[],rEv[],rChain[])
          -> ((isMultiple,true,true,false,'',none)->eval).asgTorepElm
       #);
     asgToMethod::
       (# V: ^evVal
       do 301->trace(#do 'asgToMethod:'->display; #);
          (if llEV[] <> none then
              (*1->trace(#
                      do 'eval:assignToList:'->xT; llEV.display; xN;
                         lEv[] -> xA
                      #);*)
	      (baseAdr[],llEv[],lEv[],true,lChain[])
                -> assignValToEval
                -> V[]
           else          
              (baseAdr[],lEv[],true,lChain[])
                -> ExpEval
                -> V[];
          if);
          301->trace(#do 'asgToMethod2:'->display;V.display #);
          (enterTypes,noOfArgs,next,rElm[],rChain[]) 
            -> V.asgToMethod
            -> next
       #);
     asgToList::
       (# A: ^mch.address
       do 301->trace(#do 'asgToList:'->display; #);
          (if llEV[] <> none then
              (if false then
                  1->trace(#
                          do 'eval:assignToList:'->xT; llEV.display; xN;
                             lEv[] -> xA
                          #);
              if);
	      (baseAdr[],llEv[],lEv[],true,lChain[])
                -> assignValToEval
                -> V[]
           else
              (baseAdr[],lEv[],true,lChain[])
                -> ExpEval
                -> V[];
          if);
          (*V.loadVal -> V[];*)
          (*theGen.AllocAndstoreTmp -> A[];*)
          (BA[],EV[],rChain[]) -> V.asgToList
       #);
     asgToItem::
       (# V: ^evVal; sig: @theGen.signature;
       do 301->trace(#do 'asgToItem:'->display; #);
          (baseAdr[],lEv[],true,lChain[])
            -> ExpEval
            -> V[];
          (rDesc[],rChain[],false(*?*)) -> sig.setMethodDesc;
          rDesc[] -> sig.addEnter;
          sig.exitVoid;
          (# T: [sig.noOfEnterArgs] @integer;
             top: @integer
          do sig.scanEnter
             (#
             do current.elmType -> T[top+1 -> top]
             #);
             (T,top,1,rDesc[],rChain[]) -> V.asgToMethod
          #)
       #);
     asgToExitArgs::
       (# V: ^evVal; xT: ^ExitTypes
       do (baseAdr[],lEv[],true,lChain[])
            -> ExpEval
            -> V[];
          (rDesc[],exitNo,originAdr[],rChain[]) 
            -> V.asgToExitArgs 
            -> (exitNo,xT[]);
          xT[] -> xTypes.concatenate -> xTypes[]
       #);
     asgToCproc::
       (#
       do (if stest then 301->ctrace
              (#
              do 'methodArgs:asgToCproc: '->xT; lEv[] -> xA 
          #)if);
          eval -> V[];
          (*V.pushVal -> V[];*)
          (EV[],externalName[],desc[],extKind) -> V.asgToCproc -> V[]
       #);
     asgToInlinePrimitive::
       (#
       do 301->trace(#
                    do 'asgToInlinePrimitive:opCode: ' -> xT; opCode->xI
                    #);
          (OpCode,I1,I2) -> (eval).asgToInlinePrimitive -> V[];
          301->trace(#
                    do 'asgToInlinePrimitive:after: '->xT;
                       V.display
                    #)
       #);
     asgToNewPrim::
       (#
       do 301->trace(#
                    do 'asgToNewPrim:'->display; ev[]->xA
                    #);
          (baseA[],ev[],rchain[]) -> (eval).asgToNewPrim -> V[]
       #);
     cmpBoolAndJmp:: (#do '\nOBS! cmpBoolAndJmp'->putline #);
     cmp:: (# do '\nOBS! cmp'->putline; #);
     adrCmp:: (# do '\nOBS! adrCmp'->putline; #);
     cstCmp:: (# do '\nOBS! cstCmp'->putline; #);
     regCmp:: (# do '\nOBS! regCmp'->putline; #);
     times:: (# do 301->trace(# do 'times'->display #) #);
     adrTimes:: (# do 301->trace(#do 'adrTimes'->display #) #);
     cstTimes:: (# do 301->trace(#do 'cstTimes'->display #) #);
     regTimes:: (# do 301->trace(# do 'regTimes'->display #) #);          
     eval: 
       (# dup,pushVal
          ,isSimpleVal
          ,isRepAdr: @boolean; (* this eval is assigned to R[e] and
                                * the address of R[e] is on the stack
                                *)
          V: ^evVal;
          rType: ^text;
          rDesc: ^ASTindex;
          isExternalString: @boolean
       enter(dup,pushVal,isSimpleVal,isRepAdr,rType[],rDesc[])
       do 301->trace(#
                    do 'eval:'->display; xN;
                       'dup: ' -> xT; dup->xB;
                       'pushVal:'->xT; pushVal->xB;
                       'isSimpleVal:' ->xT; isSimpleVal -> xB;
                       'isRepAdr:'->xT; isRepAdr -> xB;
                       'rType:'->xT; rType[] -> xT; xN;
                       (if llEV[]<>none then 
                           'llEV:'->xT; llEV.display;; xN;
                       if);
                       'lEV:'->xT; lEV[] -> xA
                    #);
          'methodArgs:eval:1'->mch.comment;
          (if inEnter then
              false -> inEnterDoExitMethod
          if);
          (if llEV[] <> none then
              301->trace(#
                      do 'eval:assign:'->xT; llEV.display; xN;
                         lEv[] -> xA;
                         ' dup:'->xT; dup -> xB
                        #);
              (* Multiple assignment: llEV -> lEV
               * Case ente(a->b)
               *   llEV = enterArgs
               *   lEV  = a   or a -> b
               *   dup  = true
               *   The dup should be part of assignValToEval
               *   and not after 
               * llEv.pushVal -> llEv[]; - dont work since adr
               * of lEv is not computed
               *)
              (*llEV.markMultiple;*)
	      (baseAdr[],llEv[],lEv[],true,lChain[])
                -> assignValToEval
                -> V[]
           else
              (baseAdr[],lEv[],true ,lChain[]) 
                -> ExpEval
                -> V[]
          if);
          (if false then
              (if (V.evType = 1 (* could be char*))
                  and (rDesc[]<>none)
                  and (sematt.repDesc->rDesc.equal) then
                  (* could be 'a' -> R - in which case we should push 'a'
                   * or R.foo -> R where foo returns a char literal and
                   * here the value is already on the stack
                   *)
                  (* true -> pushVal -> isSimpleVal*)
          if)if);
          'methodArgs:eval:2'->mch.comment;
          (if V[] = none then '\nMethodArgs:eval:V is none ' -> putline if);
          301->trace(#
                    do 'eval2:'->display; 'dup:'->xT; dup->xB; xN; 
                       V.display 
                    #);
          (if pushval then
              (* we need the rType here for text/const literals;
               * this is tricky and should be reconsidered;
               * also since dup_x1 does not exist on .NET
               *)
              (* reconsider structure of pushVal here and in txtcstval *)
              (rType[]<>none) 
              and ((isJava and ('java/lang/String' -> rType.equal)) 
                   or ('class [mscorlib]System.String'->rType.equal))
                -> isExternalString;
              (if isExternalString then
                  (* to avoid conversion to BETA text - clumsy *)
                  true -> V.pushVal -> V[]
               else
                  isSimpleVal -> V.pushVal -> V[]
              if);
              301->trace(#do 'eval3: V:'->display; V.display #);
              (if not isSimpleVal and not isExternalString then
                  V.mkBetatext; (* reconsider *)
              if)    
          if);
          (if dup then
              (if isJava then
                  (if isRepAdr then
                      (2,0) -> mch.duplicate
                   else
                      (if V.evType = 3 (* float *) then
                          (1,1) -> mch.duplicate
                       else
                          (1,0) -> mch.duplicate
                      if)
                  if)
               else
                  301->trace(#do 'eval4: V:'->display; V.display #);
                  (0,0) -> mch.duplicate;
                  V.type -> theGen.mkSignature ->  mch.allocAndStoreLocal
              if)
          if);
          (* FIXME: the following is very messsy *)
          (if (V.evType = 1 ) and false
              and (rDesc[]<>none) 
              and (sematt.repDesc->rDesc.equal) then
              'char2rep' -> mch.callPrim
           else
              (if not isSimpleVal
                  and (rType[]<>none) 
                  and (rType.length > 0) (* from asgToRep *)
                  and (V.evType<>4 (* strucref->Structure *))
                  and (rDesc[] <> none) and not (sematt.textDesc->rDesc.equal)
                  (* In X.get -> T[]
                   * get may return externalString
                   * and T may be a text;
                   * here we avoid a text-cast
                   * instead a coersion is made
                   * in textVarVal; but ugly
                   *)
                  and not (V.type -> theGen.mkSignature -> rType.equal) then
                  rType[] -> mch.checkCast
          if)if);
          (if inEnter then
              true -> inEnterDoExitMethod
          if)
       exit V[]
       #);
     lEv: ^ASTindex; (* isMultiple = true: lEv = EV1 -> EV2 -> ... *)
     baseAdr: ^mch.Address;
     lChain: ^DH.superChain;
     isMultiple: @boolean;
     llEV: ^evVal; (* llEV= none: do eval(lEv)
                    * llEV<>none: do lleV -> lEv
                    *)
  enter(baseAdr[],lEv[],lChain[],isMultiple,llEV[])
  exit this(methodArgs)[]
  #);
methodCall: evVal
  (# evId:: (#do 'MethodCall:'->id[] #);
     display:: (# do sig.asText -> xT #);
     loadVal:: 
       (# 
       do 301->trace(#do 'methodCall:loadVal' -> xT #);
          (*this(methodCall)[] -> V[]; (* ???*) 
          thisExitVal -> V[]
       #);
     evType:: 
       (#
       do (if not sig.isMultiValExit and (sig.XXsig.isRef) then
              2 -> type
           else 
              (if exitValIsReal then 
                  3 -> type 
               else
                  1 -> type 
              if)
          if)
       #);
     type::
       (#
       do (if (sig[]<>none) and (sig.XXsig[] <> none) then
              sig.XXsig.theDesc -> desc[] 
           else
              '\nmethodCall:type:sig.XXsig is none'->putline
          if)
       #);
     toDataReg:: 
       (# 
       do 301->trace(#do 'methodCall:toDataReg' -> xT #);
       #);
     loadVal2:: 
       (# 
       do 301->trace(#do 'methodCall:loadVal2' -> xT #);
          thisExitVal -> V[]
       #);
     pushVal::
       (# dr: @mch.dataRegOperand
       do 301->trace(#do 'methodCall:pushVal' -> xT #);
          '!methodCall:pushVal' -> mch.comment;
          (* (dr,false,false,false) -> mkComputedEvVal -> V[];*)
          (* the result of the methodcall is on the stack *)
          (* this(methodCall)[] -> V[]*)
          thisExitVal -> V[]
       #);
     mkReal::
       (#
       do &mch.floatRegOp[] -> mkFloatEvVal -> V[]
       #);
     loadFloat :: (# do &mch.floatRegOp[] -> res[] #);
     getRefEval::
       (#
       do this(methodCall)[] -> V[]
       #);
     theAdr:: 
       (# A: @mch.RegAdr; D: ^ASTindex
       do (if sig.aplSig[] <> none then
              sig.XXsig.theDesc -> D[];
              (if not (D -> (sig.aplSig.theDesc).equal) then
                  'cast' -> mch.comment;
                  sig.aplSig.asText -> mch.checkCast
          if)if);
          A[] -> AV[]
       #);
     asgToAdr::
       (# dr: @mch.dataRegOperand; D: ^ASTindex
       do (* we assume a value on top of the stack *)
          dr.alloc;
          301->trace(#do 'asgToAdr: '->display; rA.display->xT #);
          type -> D[];
          (if sig.XXsig.elmType = 8 (* int64 *) then
              mch.int64ToInt32
          if);
          (dr[],rA[]) -> mch.stVal; (* no handling of size *)
          (dr,false,false,false) -> mkComputedEvVal -> V[];
       #);
     asgToRefAdr::
       (# EV: @ASTindex
       do 301 -> trace(#
                      do 'asgToRefAdr: '->display;
                         100 -> switchon;
                         sig.exitVal[] -> xA;
                         100 -> switchOff
                      #);
          sig.exitVal[]->sematt.evCase
          (# objRef::
               (#
               do (0,false,EV.sonRef,chain[]) 
                    -> mkComputedRefEvVal
                    -> V[]
               #);
             dynItemRef::
               (#
               do (0,false,EV.sonRef,chain[]) 
                    -> mkComputedRefEvVal
                    -> V[]
               #);
             strucRef::
               (#
               do (0,false,EV.sonRef,chain[]) 
                    -> mkComputedRefEvVal
                    -> V[]
               #);
             txtCst::
               (# T: ^text 
               do EV.gettext->T[]; T->mkTxtCstEvVal->V[]
               #)
          #);
          (rAbase[],destEV[],rChain[]) -> V.asgToRefAdr;
          (0,false,destEv[],rChain[])->mkComputedRefEvVal->V[];
       #);
     asgToRealAdr::
       (#
       do rA[] -> (&mch.floatRegOp[] -> mkFloatEvVal).asgToRealAdr -> V[]
       #);
     asgToRepAdr::
       (#
       do 301 -> trace(#
                      do 'methodCall:asgToRepAdr: '->xT;
                         sig.exitVal[] -> xA
                      #);
          (if sig.isMultiValExit then
              301->trace(#
                      do 'asgToRepAdr:'->display;
                         'method returning a list to be assigned to '
                         'a repetition is NOT implemented'
                         -> xT
                      #)
           else
              (if sig.XXsig.elmType = 12 (* array *) then
                  (* method has returned an array: store it in rA *)
                  (&mch.dataRegOperand[],rA[]) -> mch.stVal
               else
                  (* method has returned a value (simple or ref)
                   * that should be coerced into a repetition
                   *)
                  (rA[],rEV[],rChain[]) 
                    -> ((0,false,false,false)->mkComputedEvVal).asgToRepAdr 
                    -> V[]
          if)if)
       #);
     asgToRepElm::
       (#
       do 301->trace(#do 'asgToRepElm:'->display #);
          (rA[],rEv[],rChain[])
            -> ((0,false,false,false)->mkComputedEvVal).asgToRepElm
            -> V[]
       #);
     asgToItem::
       (#
       do '\nMethodCall:asgToItem' -> putline
          
       #);
     asgVal2Rep: (* duplicate  form computedval *)
       (# elmDesc,rEv: ^ASTindex; rChain: ^DH.superChain; 
          rA: ^mch.address;  noStore: @boolean;
          tA: ^mch.address;
          V: ^evVal
       enter(elmDesc[],rEV[],rChain[],rA[],noStore)
       do (* val -> aRep *)
          (*  stack = [... Val ] *)
          (if switch182 then
              sematt.integerDesc[] 
                -> theGen.mkSignature 
                -> theGen.allocAndStoreTmp 
                -> tA[]
          if);
          (elmDesc[],true,false,rA.size,1,rA[],noStore) -> asgToNewRep
          (#
          do (if switch182 then
                 (rEV[],rChain[],rA[]) -> asgToSingleElmArray
                 (#
                 do AI.bAdr.localDesc[]
                      -> theGen.mkSignature 
                      -> AI.fieldType[];
                    (tA[],mch.dataTop[]) -> mch.ldVal
                 #)
              else
                 NextElmAdr -> asgToAdr -> V[]
             if)
          #);
       exit V[]
       #);     

     asgToMethod::
       (* Assign m1 to m2 as in the following forsm
        *    m1 -> m2
        * or
        *    (e1,e2,...,m1,...en) -> m2
        * where m1 = this(methodCall)
        * and m2 is described by arguments to asgToMethod;
        * Push return value(s) from m1 as arguments to m2.
        * Note: m1 determines how many values to push;
        * m2 cannot be used to determine this, since
        * there may be other arguments to m2 than m1 as shown
        * by the 2. fomr above
        *)
       (# A: ^mch.address; aS: @mch.RegAdr; srcField: ^text; xNo: @integer;
          gNXl: ^|sematt.getNXlength; 
          rA: ^mch.address; desc: ^ASTindex;
          checkText2ExternalString:
            (# d: ^ASTindex;
               leftIsRep: @boolean
            enter(d[],leftIsRep)
            do (if (d[]<>none) then
                   (if true
                    // (d->sematt.textDesc.equal) 
                         and (enterTypes[next] = 13 (* external *)) then
                       'BetaText2ExternalString' -> mch.callprim 
                    // ((d->sematt.descKind) = sematt.externalClassKind)
                       and (enterTypes[next] = 14 (* textDesc *) ) then
                       'ExternalString2BetaText' -> mch.callprim
                    // (d->sematt.textDesc.equal) 
                       and  (enterTypes[next] = 12 (* array *)) then
                       'text2char' -> mch.comment;
                       'BetaText2BetaCharArray' -> mch.callPrim
                    else
                       (if not leftIsRep
                           and (enterTypes[next] = 12 (* array *)) then
                           baseAdr.copy -> rA[];
                           (rElm[],rChain[],rA[]) -> getElmDesc -> desc[];
                           301->trace(#
                                     do rElm[]->xA; xN; 
                                        desc[]->xA; desc.size -> xI 
                                     #);
                           desc.size -> rA.size;
                           desc[] -> rA.bAdr.localDesc[];
                           (desc[],rElm[],rChain[],rA[],true) -> asgVal2Rep
                       if)
               if)if)
            #);
            leftIsRep: @boolean
       do 301->trace(#
                    do 'MethodCall:asgToMethod: ' -> xT;
                       sig.asText -> xT; ' ' -> put;
                       noOfArgs -> xI; ':' -> put;
                       (for i: (noOfArgs,entertypes.range) -> min repeat
                            entertypes[i] -> xI; ' ' -> put;
                       for);
                    #);
          (if sig.isMultiValExit then
              sig.XXsig.asText -> theGen.AllocAndStoreTmp -> A[];
              (* we need to get the right values instead of
               * gen.thisRegAdr and thisSuperChain
               * from the place where methodCall is instantiated
               *)
              'exit_' -> srcField[];
              (sig.thisMethodDesc[] -> theGen.fieldSignature).asText 
                -> aS.receiverType[];
              true -> aS.isField;
              sig.scanExit
              (# desc: ^ASTindex
              do (A[],&mch.adrRegOperand[]) -> mch.ldVal;
                 xNo + 1 
                   -> xNo   
                   -> (srcField.copy).putint 
                   -> aS.fieldName[];
                 (if (current.elmType = 12)->leftIsRep (* array *) then
                     '\nbingo'->putline;
                     current.theDesc 
                       -> desc[] 
                       -> theGen.mkArraySignature 
                       -> aS.fieldType[]
                  else
                     current.theDesc 
                       -> desc[] 
                       -> theGen.mkSignature 
                       -> aS.fieldType[]
                 if);
                 (aS[],&mch.dataRegOperand[]) -> mch.ldVal;
                 (desc[],leftIsRep) -> checkText2ExternalString;
                 next + 1 -> next;                
              #)
           else
              (sig.XXsig.theDesc,sig.XXsig.elmType=12(*array*))
                -> checkText2ExternalString;
              next+1 -> next;              
          if)
       #);
     asgToExitArgs::
       (* Assign
        *    this(methodCall) -> (exit_exitNo, exit_exitNo+1, ...)
        * rDesc    : the receiver object with fields exit_exitNo, ...
        * exitNo   : next exit-field to be assigned
        * originAdr: address of origin of ...
        * rChain   : superChain 
        *)
       (# A: ^mch.address; aS,aD: @mch.RegAdr; 
          srcField,destField: ^text; xNo: @integer;
          xScan: @ | scanXadr; notFirst,more: @boolean;
          rSig: @thegen.signature;
       do (*'MethodCall:asgToExitArgs:'->puttext;*)
          (if sig.isMultiValExit then
              (* this(methodCall) returns a list of values *)
              sig.XXsig.asText -> theGen.AllocAndStoreTmp -> A[];
              (* we need to get the right values instead of
               * gen.thisRegAdr and thisSuperChain
               * from the place where methodCall is instantiated
               *)
              (sig.thisMethodDesc[],gen.thisRegAdr,0(*??nOff*),chain[]) 
                -> xScan -> more;
              'exit_' -> destField[];
              'exit_' -> srcField[];
              (sig.thisMethodDesc[] -> theGen.fieldSignature).asText 
                -> aS.receiverType[];
              (rDesc[] -> theGen.fieldSignature).asText 
                -> aD.receiverType[];
              (*'scanExit:'->puttext;*)
              sig.scanExit
              (#
              do (if notFirst then
                     (originAdr[],none) -> mch.ldVal
                 if);
                 true -> notFirst;
                 (A[],&mch.adrRegOperand[]) -> mch.ldVal;
                 true -> aS.isField;
                 true -> aD.isField;
                 xNo + 1 
                   -> xNo 
                   -> (srcField.copy).putint 
                   -> aS.fieldName[];
                 current.theDesc 
                   -> theGen.mkSignature 
                   -> aS.fieldType[]
                   -> aD.fieldType[](* -> puttext;*);
                 (aS[],&mch.dataRegOperand[]) -> mch.ldVal;
                 exitNo + 1 
                   -> exitNo
                   -> (destField.copy).putint 
                   -> aD.fieldName[];
                 (* OBS: missing handling os isRep *)
                 (current.theDesc,false) -> xTypes.add;
                 (&mch.dataRegOperand[],aD[]) -> mch.stVal;
              #);
          if)
       #);
     asgToList::
       (* Assign
        *    M -> (E1,E2,...En)
        * where M  = this(methodCall)
        * and   EV = (E1,E2,...,En)
        *)
       (# lEV: @ExitMultiVal; exitNo: @integer;
          nextEVlistElm: @|
            (# E: @ASTindex
            do EV -> scanList
               (#
               do currentNode -> E;
                  SUSPEND
               #)
            exit E[]
            #);
          E: ^ASTindex
               
       do 301->trace(#do 'asgToList:'->display #);
          
          sig.XXsig.asText 
            -> lEV.class[]
            -> theGen.AllocAndStoreTmp 
            -> lEV.tA[];
          (* here we should probably use sig.scanExit
           * to get the correct type of the exit-elements;
           * we should use gNXL on each element Ei in EV
           * to enumerate the enter-elements of Ei;
           * this should fix the type problem in tstnxoff
           * - which does not run with sun-java but is ok
           * with gij
           *)
          sig.scanExit
          (# more: @boolean; 
             xNo: @integer;
             gNXL: ^| sematt.getNXlength
          do (if (xNo+1 -> xNo) = (exitNo+1) then
                 nextEVListElm -> E[];
                 &|sematt.getNXlength[] -> gNXL[];
                 (E[],true,thisDesc[],rChain[]) -> gNXL -> more; 
                 L: (if more then 
                        exitNo+1 -> exitNo -> lEV;
                        301->trace(# F: @ASTindex
                                do 'exitNo: ' -> xT; exitNo->putInt; 
                                   ' left:'->puttext;
                                   current.asText -> puttext;
                                   ' right:'->puttext;
                                   current.theDesc->xA; xN;
                                   (current.theDesc).father -> F;
                                   F[]->xA
                                #);
                        current.theDesc -> lEV.elmDesc[];
                        current.elmType = 12 -> lEV.isRep;
                        (if lEV.isRep then
                            301->trace(#do 'isRep:'->xT #)
                        if);
                        (BA[],lEV[],E[],false,rChain[]) 
                          -> AssignValToEval 
                          -> V[];
                        C: (if (gNXL -> more) then
                               exitNo+1 -> exitNo;
                               restart C
                           if)
                    if);
             if)
          #)
       #);
     asgToCproc::
       (#
       do '\nOBS! MethodCall:asgToCproc:notImplemented'->putline;
          this(methodCall)[] -> V[]; (* just a hack - doesn't work *)
       #);
     pushCpar::
       (# D: ^ASTindex
       do sig.XXsig.theDesc -> D[];
          (if (D -> sematt.textDesc.equal) 
              and (type = common.externalStringXpar) then
              'BetaText2ExternalString' -> mch.callprim 
          if);
       #);
     asgToInlinePrimitive::
       (#
       do 301->trace(#
                    do 'asgToInlinePirmitive: ' ->display;
                    #);
          (OpCode,I1,I2) ->  (asComputedVal).asgToInlinePrimitive -> V[]
          (*(0,false,false,false) -> mkComputedEvVal -> V[]*)
       #);
     unMinus::<
       (# dr: @mch.dataRegOperand
       do (dr[],4)->mch.gNeg;
          (dr,false,false,false) -> mkComputedEvVal -> res[];          
       #);
     notExp::< 
       (# dr: @mch.dataRegOperand
       do (dr[],4)->mch.gNot;
          (dr,false,false,false) -> mkComputedEvVal -> res[]; 
       #);
     cmpBoolAndJmp::<
       (#
       do (if not common.switch[188] then
              '\nOBS! methodCall:cmpBoolAndJmp' -> putline;
          if)
       #);
     cmp::< 
       (# dr: @mch.dataRegOperand
       do dr->lV.regCmp->doCmp; 
       #);
     adrCmp::< 
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:AdrCmp'->putline 
          if);
          (evType=2) -> isRef
       #);
     cstCmp::< 
       (* this(methodCall) CMP rC *)
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:cstCmp'->putline
          if);
          rC[] -> op1[]; &mch.dataRegOperand[]->op2[]; 
          (evType=2) -> isRef
          (* op2 is top of stack (methodCall), so
           * showuld we do a swap of reverse CMP-operator?
           *)          
       #);
     regCmp::<(* this(methodCall) COMP rReg *)
       (#
       do 'methodCall:regCmp' -> mch.comment;
          &mch.dataRegOperand[] -> op1[];
          rreg[] -> op2[];
          false -> deAllocOp1 -> deAllocOp2;
          (evType=2) -> isRef
       #);
     
     add::< 
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:add'->putline 
          if);
          lv[] -> (asComputedVal).add -> res[]
       #);
               
     adrAdd::<
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:adrAdd'->putline
          if);
          rA[] -> (asComputedVal).adrAdd -> V[]
       #);
     cstAdd::<
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:cstAdd'->putline;
          if);
          rN -> (asComputedVal).cstAdd -> V[]
       #);
     regAdd::<
       (# 
       do (if not common.switch[188] then
                 '\nOBS! methodCall:regAdd'->putline 
          if);
          rReg -> (asComputedVal).regAdd -> V[]
       #); 
     sub::< 
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:sub'->putline 
          if);
          lv[] -> (asComputedVal).sub -> res[]
       #);
               
     adrSub::<
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:adrSub'->putline
          if);
          rA[] -> (asComputedVal).adrSub -> V[]
       #);
     cstSub::<
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:cstSub'->putline;
          if);
          rN -> (asComputedVal).cstSub -> V[]
       #);
     regSub::<
       (# 
       do (if not common.switch[188] then
                 '\nOBS! methodCall:regSub'->putline 
          if);
          rReg -> (asComputedVal).regSub -> V[]
       #); 
          
     times::
       (#
       do 301->trace(#
                    do 'times:' -> display
                    #);
          lv[] -> (asComputedVal).times -> res[]          
       #);
     adrTimes::
       (#
       do 301->trace(#
                    do 'adrTimes:' -> display
                    #);
          rA[] -> (asComputedVal).adrTimes -> V[]          
       #);
     cstTimes::
       (#
       do 301->trace(#
                    do 'cstTimes:' -> display
                    #);
          rN -> (asComputedVal).cstTimes -> V[]          
       #);
     regTimes::
       (#
       do 301->trace(#
                    do 'regTimes:' -> display
                    #);
          rReg -> (asComputedVal).regTimes -> V[]          
       #);
     divMod:: 
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:divMod:' -> putline
          if);
          (lV[],isDiv) -> (asComputedVal).divMod -> res[]
       #);
     adrDivMod:: 
       (# 
       do (if not common.switch[188] then
                 '\nOBS! methodCall:adrDivMod:' -> putline 
          if);
          (rA[],isDiv) -> (asComputedVal).adrDivMod -> W[];
       #);
     cstDivMod:: 
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:cstDivMod:' -> putline;
          if);
          (rN,isDiv) -> (asComputedVal).cstDivMod -> V[]
       #);
     regDivMod:: 
       (# 
       do (if not common.switch[188] then
                 '\nOBS! methodCall:regDivMod:' -> putline;
          if);
          (rReg,isDiv) -> (asComputedVal).regDivMod -> W[]
       #);
     orr::<
       (# do (if not common.switch[188] then
                 '\nOBS! methodCall:orr'->putline 
       if)#);
     adrOr::<
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:adrOr'->putline
          if)
       #);
     cstOr::<
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:cstOr'->putline; 
          if);
          this(methodCall)[] -> V[] 
       #);
     regOr::<
       (# do (if not common.switch[188] then
                 '\nOBS! methodCall:regOr'->putline
       if)#);
     andd::< 
       (# do (if not common.switch[188] then
                 '\nOBS! methodCall:andd'->putline
       if)#);
     adrAnd::<
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:adrAnd'->putline
          if)
       #);
     cstAnd::<
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:cstAnd'->putline;
          if);
          this(methodCall)[] -> V[] 
       #);
     regAnd::<
       (# do (if not common.switch[188] then
                 '\nOBS! methodCall:regAnd'->putline
       if)#); 
     rMult:: (# do   this(methodCall)[] -> res[] #);
     asComputedVal:
       (# EH: @evalHandler
       exit (0,false,false,false)->EH.mkComputedEvVal
       #);
     exitValIsReal: booleanValue
       (#
       do (sig.XXsig.elmType = 6) (* real *) -> value
       #);
     thisExitVal:
       (# V: ^evVal
       do (if exitValIsReal then
              mkReal -> V[]
           else
              (if sig.XXsig.isRef then
                  this(methodCall)[] -> V[]; (* not logical, but
                                              * we don't have thisEV
                                              * in the next one below
                                              *)
                  (*(0,false,EV[],chain[]) -> mkComputedRefEvVal -> V[]*)
               else
                  (if sig.XXsig.elmType = 8 (* int64 *) then
                      mch.int64ToInt32
                  if);
                  (0,evType=2,false,false) -> mkComputedEvVal -> V[]
          if) if)
       exit V[]
       #); 

     (* class: ^text*)
     sig: ^theGen.signature;
     chain: ^DH.superChain
  enter(sig[],chain[])
  exit this(methodCall)[]
  #);

EnterArgs: evVal
  (# off: @integer;
     pushNext:
       (# class: ^text;
          A: @mch.RegAdr; T: @text
       enter class[]
       do off+4 -> off -> A.off;
          '!enterArgs:pushNext: '->T; off -> T.putInt; T -> mch.comment;
          'arg_' -> A.fieldName[];
          off -> A.fieldName.putint;
          (if class[] <> none then
              (if ('D' -> class.equal) or ('J' -> class.equal) then
                  class[] -> A.fieldType[];
                  (A[],none) -> mch.ldVal;
                  (if isJava then
                      off+4 -> off -> A.off;
                  if);
               else
                  (A[],class[],none)->mch.loadRef
              if)
           else     
              'I' -> A.fieldType[];
              (A[],none) -> mch.ldVal
          if);
          (if isMultiple then
              (1,0) -> mch.duplicate
          if)
       #);
     evId:: (# do 'EnterArgs:'->id[] #);
     display:: (# T: @text do 'off:'->T; off->T.putint; T[]->xT #);
     pushVal:: 
       (#
       do 301->trace(#do 'pushVal:'->display #);
          (*type should be handled*) pushNext ;
          asComputedVal -> V[]
       #);
     asComputedVal:
       (# EH: @evalHandler
       exit (0,false,false,false)->EH.mkComputedEvVal
       #);
     asgToAdr:: 
       (# 
       do '!enterArgs:asgToAdr:'->mch.comment;
          (if rA.size = 8 then
              'J' -> pushnext
           else
              pushNext; 
          if);
          (none,rA[]) -> mch.stVal;
          asComputedVal -> V[]
       #);
     asgToRealAdr::
       (#
       do 'D' -> pushNext; (none,rA[]) -> mch.stVal 
       #);
     asgToRefAdr::
       (# sourceClassName,destClassName: ^text;
          dDesc: @ASTindex; RC: ^DH.superChain;
          rA,rAx: ^mch.address; destEval,dcl: @ASTindex; 
       do '!EnterArgs:asgToRefAdr:'->mch.comment;
          destEv.son -> destEval;
          (if destEv.label = gram.structureReference then
              sematt.structureDesc -> dDesc;
           else
              (rChain[],destEval) 
                -> DH.theDesc 
                ->(dDesc,RC[]);
          if);
          dDesc[] 
            -> theGen.mkSignature 
            -> sourceClassName[] 
            -> destClassName[];
          (rAbase.copy,destEval[],false,rChain[])->genAdr->rA[];
          sourceClassName[] -> pushNext;
          destEval.dclref -> dcl;
          dcl.gettext -> rA.fieldName[];
          &mch.RegAdr[] -> rAx[];
          (rAx[],false,sourceClassName[],destClassName[])
            -> rA.asgRefAdr       
       #);
     asgToRepAdr::
       (# sourceClassName,destClassName: ^text
       do '!EnterArgs:asgToRepAdr' -> mch.comment;
          (if true then
              rA.fieldType[] 
                -> sourceClassName[] 
                -> destClassName[]
                -> pushNext; 
           else
              '[C' -> pushNext; 
              '[C' -> sourceClassName[] -> destClassName[];
          if);
          (&mch.RegAdr[],false,sourceClassName[],destClassName[])
            -> rA.asgRefAdr
       #);
     (*  insert::
      (#
      do '!enterArgs:insert:'->mch.comment;
      #);*)
     asgToItem::
       (# sig: @theGen.Signature;
          basicname,knownName: ^text
       do '!enterArgs:asgToItem:'->mch.comment;
          301->trace(#
                    do 'enterArgs:asgToItem:'->xT;
                       rDesc[] -> xA; xN;
                       'rA:'->xT; rA.display->xT; xN
                    #);
          true->rA.isRef;
          (rDesc[],true) -> descName -> basicName[] -> knownName[]; (* FIX possible virtual *)
          (if not rA.noTmp then
              (rA[],basicName[],none)->mch.loadRef; (* dup should be used *)
              true -> rA.noTmp;
              (0,0) -> mch.duplicate; (* for execution of do-method *)
          if);
          (rDesc[],rChain[],false(*?*)) -> sig.setMethodDesc;
          rDesc[] -> sig.addEnter;
          sig.exitVoid;
          common.enterMethod -> sig.addMethod;  

          sig.scanEnter
          (# 
          do (if isRef then
                 'someClassOrArry' -> pushNext 
              else
                 pushNext
             if)
          #);
       #);
     asgToMethod::
       (#
       do 301->trace(#
                    do 'asgToMethod:'->display;
                       (for i: noOfArgs repeat
                            enterTypes[next] -> xI
                       for)
                    #);
          (for i: noOfArgs repeat
               (if enterTypes[next] 
                // 11 // 12 // 13 // 14 then
                   'SomeClass' -> pushNext
                // 6 (* real/double *) // 7 (* real32 *) then
                   'D' -> pushNext 
                // 8 (* long=int64*) then
                   'J' -> pushNext
                else
                   pushNext 
               if);
               next + 1 -> next
          for);
          (* OBS. check that moved 'inner' in mkByteCodeCall is OK
           * We need the descriptor - it may be singular -
           * it must be called as a a method; i.e. 
           * treated like an inner pattern with method-version
           * and new-version
           *)
          next + noOfArgs -> next 
       #);
     asgToList::
       (# 
       do EV -> scanList
          (# E: @ASTindex
          do currentNode -> E;
             (BA[],this(enterArgs)[],E[],false,rChain[]) 
               -> AssignValToEval 
               -> V[];             
          #);
          (EV[],BA[],rChain[]) -> mkListVal -> V[]
       #);
     init:
       (#
       do 8 -> off
       #);
  exit this(enterArgs)[]
  #);
ExitMultiVal: evVal
  (# evId:: (# do 'ExitMultiVal:'->id[] #);
     display:: 
       (#
       do 'exitNo:'->xT; exitNo->xI; 'elmDesc:'->xT; elmDesc[]->xAF
       #);          
     asgToAdr::
       (# A: @mch.RegAdr;
       do 301->trace(#
                    do 'asgToAdr:'->display
                    #);
          (if tA[] = none then
              '\OBS! exitMultiVal:tA is none' -> putline;
              12 -> A.off;
              true -> A.isRef;
              (A[],&mch.adrRegOperand[]) -> mch.ldVal;
           else
              (tA[],&mch.adrRegOperand[]) -> mch.ldVal;
          if);
          (mkA,&mch.dataRegOperand[]) -> mch.ldVal;          
          true -> rA.isField;
          (&mch.dataRegOperand[],rA[]) -> mch.stVal;
       #);
     asgToRealAdr::
       (#
       do 301->trace(#
                    do 'asgToRealAdr'->display;
                    #);
          (tA[],&mch.adrRegOperand[]) -> mch.ldVal;
          (mkA,&mch.dataRegOperand[]) -> mch.ldVal;
          true -> rA.isField;
          (&mch.dataRegOperand[],rA[]) -> mch.stVal;          
       #);
     asgToRefAdr::
       (# A: @mch.RegAdr; aS,rA: ^mch.address; 
          destClass: ^text; withQua: @boolean;
       do 301->trace(#
                    do 'asgToRefAdr'->display;
                    #);          
          (rAbase.copy,destEv.sonRef,false,rChain[])->genAdr->rA[];
          (tA[],&mch.adrRegOperand[]) -> mch.ldVal;
          (mkA->aS[],&mch.adrRegOperand[]) -> mch.ldVal; 
          (*rAbase.copy -> rA[];*)
          
          true -> rA.isField;  
          true -> rA.isRef;
          (if destEv.label=gram.structureReference then
              (theGen.StructureSignatureId->theGen.specialSignature).asText 
                -> destClass[]
           else
              rA.bAdr.localDesc[] 
                -> theGen.mkSignature -> rA.fieldType[] -> destClass[];
          if);
          (if (destClass[] <> none) and (aS.fieldType[] <> none) then
              not (destClass[] -> aS.fieldType.equal) -> withQua;
           else
              '\nOBS! destClass[]=none) or (aS.fieldType[]=none)'
                -> putline
          if);
          (&mch.adrRegOperand[],withQua,'???',destClass[])
            -> rA.asgRefReg
       #);
     asgToRepAdr::
       (#
       do 301->trace(#
                    do 'astToRepAdr:'->display;                       
                    #);
          (tA[],&mch.adrRegOperand[]) -> mch.ldVal;
          (mkA,&mch.dataRegOperand[]) -> mch.ldVal;
          true -> rA.isField;
          (&mch.dataRegOperand[],rA[]) -> mch.stVal;
       #);
     asgToItem::
       (# EH: @EvalHandler;
          nScan: @ | EH.scanNadr; more: @boolean;
          A: @mch.RegAdr;
       do 301->trace(#
                    do 'asgToItem'->display;
                    #);
          (rDesc[],rA[],0,rChain[],true) 
               -> nScan -> more;
             L:
            (if more then
                (tA[],&mch.adrRegOperand[]) -> mch.ldVal;
                (mkA,&mch.dataRegOperand[]) -> mch.ldVal;
                nScan -> more;
                restart L
            if) 
       #);
     asgToList::
       (#
       do 301->trace(#
                    do 'asgToList'->display;
                    #);
          EV -> scanList
          (# E: @ASTindex
          do currentNode -> E;
             (BA[],this(exitMultiVal)[],E[],false,rChain[]) 
               -> AssignValToEval 
               -> V[];             
          #);
          (EV[],BA[],rChain[]) -> mkListVal -> V[]
       #);
     mkA: 
       (# T: @text; aD: @mch.RegAdr 
       do (*'XA:exitMultiVal:mkA:'->puttext;*)
          'exit_' -> T;
          exitNo -> T.putint;
          exitno + 1 -> exitNo;
          T[] -> aD.fieldName[];
          class[] -> aD.receiverType[];

          (if (elmDesc[] = none) or (elmDesc.isNull) then
              '\nOBS!ExitMultiVal: ElmDesc is none or null'->putline;
              (if common.switch[311] then
                  (failureTrace,'ExitMultiVal: ElmDesc is none or null')
                    -> stop;
              if);
              sematt.integerDesc[] -> theGen.mkSignature -> aD.fieldType[]
           else
              (if elmDesc.label <> gram.objectDescriptor then
                  '\nOBS!ExitMultiVal: ElmDesc is not descriptor'->putline
               else
                  (if isRep then
                      elmDesc[] -> theGen.mkArraySignature -> aD.fieldType[]
                   else
                      elmDesc[] -> theGen.mkSignature -> aD.fieldType[];
                  if)
          if)if);
          (*aD.fieldType[] -> puttext; ',' -> put;*)
          true -> aD.isField
       exit aD[]
       #);
     xA: @text;
     class: ^text;
     tA: ^mch.address; (* address tmp-var for object *)
     exitNo: @integer;
     elmDesc: ^ASTindex;
     isrep: @boolean
  enter exitNo
  exit this(ExitMultiVal)[]
  #);
