ORIGIN 'evlib';
INCLUDE 'auxlib';
INCLUDE 'evlib';
INCLUDE 'signature';
---mkMethodArgs:doPart---
do (baseAdr[],lEv[],lChain[],isMultiple,llEV[]) -> MethodArgs -> V[]
   
---mkEnterArgs:doPart---
do EnterArgs -> V[]
   
---mkExitMultiVal:doPart---
do exitNo -> ExitMultiVal -> V[]
   
---evalLib:attributes---
methodArgs: evVal
  (# inEnter: @boolean;
     evId:: (# do 'MethodArgs:'->id[] #);
     display::
       (#
       do lEV[]-> xA 
       #);
     loadVal:: 
       (#
       do ((isMultiple,false,true,false,'',none)->eval).loadVal 
            -> V[] 
       #);
     loadVal2:: 
       (#
       do ((isMultiple,false,true,false,'',none)->eval).loadVal 
            -> V[] 
       #);
     pushVal::
       (#
       do '!methodArgs:pushVal:' -> mch.comment;
          ((isMultiple,false,true,false,'',none)->eval).pushVal 
            -> V[];
       #);
     mkReal::
       (#
       do ((isMultiple,false,true,false,'',none)->eval).mkReal 
            -> V[];
       #);
     asgToAdr::
       (# EH: @evalHandler; isRepAdr: @boolean
       do 301->trace(#
                    do 'asgToAdr:'->display; 'rA: ' -> xT; rA.display-> xT
                    #);
          '!methodArgs:asgToAdr:'->mch.comment;
          (if isMultiple then
              'index'-> rA.fieldName.equal -> isRepAdr 
          if);
          (isMultiple,true,true,isRepAdr,'',none) -> eval -> V[];
          301->trace(#do 'methodArgs:asgToAdrX: '->xT; V.display #);
          (* fieldType is not always set: as in 'a' -> c;
           * should perhaps be ensured in genAdr?
           *)
          (if rA.bAdr.localDesc[] <> none then
              rA.bAdr.localDesc[] -> theGen.mkSignature -> rA.fieldType[]
          if);
          rA[] -> V.asgToAdr -> V[];
          (if isMultiple and not isJava then mch.loadLocal if);
          301->trace(#
                    do 'methodArgs:asgToAdrZ: '->xT; 
                       (if V[] = none then
                           'V is None' -> xT
                        else
                           V.display
                       if)
                    #);
       #);
     asgToRefAdr::
       (# rA: ^mch.address; T: ^text
       do 301->trace(#do 'asgToRefAdr:'->display; #);
          '!methodArgs:asgToRefAdr1'->mch.comment;
          (rAbase[],destEV.sonRef,false,rChain[]) -> genAdr -> rA[]; 
          '!methodArgs:asgToRefAdr2:'
            -> (rA.fieldType.copy).prepend -> T[];
            T -> mch.comment;
          (if destEv.label=gram.structureReference then
              (theGen.StructureSignatureId->theGen.specialSignature).asText -> rA.fieldType[]
          if);
          (isMultiple,true,false,false,rA.fieldType[],rA.bAdr.localDesc[]) 
            -> eval -> V[];
          '!methodArgs:asgToRefAdr3'->mch.comment;
          (*V.pushVal -> V[];*)
          '!methodArgs:asgToRefAdr4'->mch.comment;
          (# T: ^text do rA.display->T[]; T -> mch.comment;#);
          (rA[],destEV[],rChain[]) -> V.asgToRefAdr -> V[];
          '!methodArgs:asgToRefAdr5'->mch.comment;
          (if isMultiple and not isjava then mch.loadLocal if);
       #);
     asgToRealAdr::
       (#
       do 301 -> trace(#
                      do 'asgToRealAdr:'->display
                      #);
          rA[] 
            -> ((isMultiple,true,true,false,'',none) -> eval).asgToRealAdr
            -> V[];
          (if isMultiple and not isjava then mch.loadLocal if);
       #);
     asgToRepAdr::
       (#
       do 301->trace(#do 'asgToRepAdr:'->display; #);
          'methodArgs:asgToRepAdr1'->mch.comment;
          (isMultiple,false,false,false,'',sematt.repDesc[]) ->eval -> V[];
          'methodArgs:asgToRepAdr2'->mch.comment;
          (* V.pushVal -> V[];*)
          (rA[],rEV[],rChain[]) -> V.asgToRepAdr -> V[];
          'methodArgs:asgToRepAdr3'->mch.comment;
          (*((12),1,1) -> (eval).asgToMethod*)
       #);
     asgToRepElm::
       (#
       do 301->trace(#
                    do 'asgToRepElm:'->display
                    #);
          (rA[],rEv[],rChain[])
          -> ((isMultiple,true,true,false,'',none)->eval).asgTorepElm
       #);
     asgToMethod::
       (# V: ^evVal
       do 301->trace(#do 'asgToMethod:'->display; #);
          (if llEV[] <> none then
              (*1->trace(#
                      do 'eval:assignToList:'->xT; llEV.display; xN;
                         lEv[] -> xA
                      #);*)
	      (baseAdr[],llEv[],lEv[],true,lChain[])
                -> assignValToEval
                -> V[]
           else          
              (baseAdr[],lEv[],true,lChain[])
                -> ExpEval
                -> V[];
          if);
          301->trace(#do 'asgToMethod2:'->display;V.display #);
          (enterTypes,noOfArgs,next,rElm[],rChain[]) 
            -> V.asgToMethod
            -> next
       #);
     asgToList::
       (# A: ^mch.address
       do 301->trace(#do 'asgToList:'->display; #);
          (if llEV[] <> none then
              (if false then
                  1->trace(#
                          do 'eval:assignToList:'->xT; llEV.display; xN;
                             lEv[] -> xA
                          #);
              if);
	      (baseAdr[],llEv[],lEv[],true,lChain[])
                -> assignValToEval
                -> V[]
           else
              (baseAdr[],lEv[],true,lChain[])
                -> ExpEval
                -> V[];
          if);
          (*V.loadVal -> V[];*)
          (*theGen.AllocAndstoreTmp -> A[];*)
          (BA[],EV[],rChain[]) -> V.asgToList
       #);
     asgToItem::
       (# V: ^evVal; sig: @theGen.signature;
       do 301->trace(#do 'asgToItem:'->display; #);
          (baseAdr[],lEv[],true,lChain[])
            -> ExpEval
            -> V[];
          (rDesc[],rChain[],false(*?*)) -> sig.setMethodDesc;
          rDesc[] -> sig.addEnter;
          sig.exitVoid;
          (# T: [sig.noOfEnterArgs] @integer;
             top: @integer
          do sig.scanEnter
             (#
             do current.elmType -> T[top+1 -> top]
             #);
             (T,top,1,rDesc[],rChain[]) -> V.asgToMethod
          #)
       #);
     asgToExitArgs::
       (# V: ^evVal; xT: ^ExitTypes
       do (baseAdr[],lEv[],true,lChain[])
            -> ExpEval
            -> V[];
          (rDesc[],exitNo,originAdr[],rChain[]) 
            -> V.asgToExitArgs 
            -> (exitNo,xT[]);
          xT[] -> xTypes.concatenate -> xTypes[]
       #);
     asgToCproc::
       (#
       do (if stest then 301->ctrace
              (#
              do 'methodArgs:asgToCproc: '->xT; lEv[] -> xA 
          #)if);
          eval -> V[];
          (*V.pushVal -> V[];*)
          (EV[],externalName[],desc[],extKind) -> V.asgToCproc -> V[]
       #);
     asgToInlinePrimitive::
       (#
       do 301->trace(#
                    do 'asgToInlinePrimitive:opCode: ' -> xT; opCode->xI
                    #);
          (OpCode,I1,I2) -> (eval).asgToInlinePrimitive -> V[];
          301->trace(#
                    do 'asgToInlinePrimitive:after: '->xT;
                       V.display
                    #)
       #);
     asgToNewPrim::
       (#
       do 301->trace(#
                    do 'asgToNewPrim:'->display; ev[]->xA
                    #);
          (baseA[],ev[],rchain[]) -> (eval).asgToNewPrim -> V[]
       #);
     cmpBoolAndJmp:: (#do '\nOBS! cmpBoolAndJmp'->putline #);
     cmp:: (# do '\nOBS! cmp'->putline; #);
     adrCmp:: (# do '\nOBS! adrCmp'->putline; #);
     cstCmp:: (# do '\nOBS! cstCmp'->putline; #);
     regCmp:: (# do '\nOBS! regCmp'->putline; #);
     times:: (# do 301->trace(# do 'times'->display #) #);
     adrTimes:: (# do 301->trace(#do 'adrTimes'->display #) #);
     cstTimes:: (# do 301->trace(#do 'cstTimes'->display #) #);
     regTimes:: (# do 301->trace(# do 'regTimes'->display #) #);          
     eval: 
       (# dup,pushVal
          ,isSimpleVal
          ,isRepAdr: @boolean; (* this eval is assigned to R[e] and
                                * the address of R[e] is on the stack
                                *)
          V: ^evVal;
          rType: ^text;
          rDesc: ^ASTindex;
          isExternalString: @boolean
       enter(dup,pushVal,isSimpleVal,isRepAdr,rType[],rDesc[])
       do 301->trace(#
                    do 'eval:'->display; xN;
                       'dup: ' -> xT; dup->xB;
                       'pushVal:'->xT; pushVal->xB;
                       'isSimpleVal:' ->xT; isSimpleVal -> xB;
                       'isRepAdr:'->xT; isRepAdr -> xB;
                       'rType:'->xT; rType[] -> xT; xN;
                       (if llEV[]<>none then 
                           'llEV:'->xT; llEV.display;; xN;
                       if);
                       'lEV:'->xT; lEV[] -> xA
                    #);
          'methodArgs:eval:1'->mch.comment;
          (if inEnter then
              false -> inEnterDoExitMethod
          if);
          (if llEV[] <> none then
              301->trace(#
                      do 'eval:assign:'->xT; llEV.display; xN;
                         lEv[] -> xA;
                         ' dup:'->xT; dup -> xB
                        #);
              (* Multiple assignment: llEV -> lEV
               * Case ente(a->b)
               *   llEV = enterArgs
               *   lEV  = a   or a -> b
               *   dup  = true
               *   The dup should be part of assignValToEval
               *   and not after 
               * llEv.pushVal -> llEv[]; - dont work since adr
               * of lEv is not computed
               *)
              (*llEV.markMultiple;*)
	      (baseAdr[],llEv[],lEv[],true,lChain[])
                -> assignValToEval
                -> V[]
           else
              (baseAdr[],lEv[],true ,lChain[]) 
                -> ExpEval
                -> V[]
          if);
          (if false then
              (if (V.evType = 1 (* could be char*))
                  and (rDesc[]<>none)
                  and (sematt.repDesc->rDesc.equal) then
                  (* could be 'a' -> R - in which case we should push 'a'
                   * or R.foo -> R where foo returns a char literal and
                   * here the value is already on the stack
                   *)
                  (* true -> pushVal -> isSimpleVal*)
          if)if);
          'methodArgs:eval:2'->mch.comment;
          (if V[] = none then '\nMethodArgs:eval:V is none ' -> putline if);
          301->trace(#
                    do 'eval2:'->display; 'dup:'->xT; dup->xB; xN; 
                       V.display 
                    #);
          (if pushval then
              (* we need the rType here for text/const literals;
               * this is tricky and should be reconsidered;
               * also since dup_x1 does not exist on .NET
               *)
              (* reconsider structure of pushVal here and in txtcstval *)
              (rType[]<>none) 
              and ((isJava and ('java/lang/String' -> rType.equal)) 
                   or ('class [mscorlib]System.String'->rType.equal))
                -> isExternalString;
              (if isExternalString then
                  (* to avoid conversion to BETA text - clumsy *)
                  true -> V.pushVal -> V[]
               else
                  isSimpleVal -> V.pushVal -> V[]
              if);
              301->trace(#do 'eval3: V:'->display; V.display #);
              (if not isSimpleVal and not isExternalString then
                  V.mkBetatext; (* reconsider *)
              if)    
          if);
          (if dup then
              (if isJava then
                  (if isRepAdr then
                      (2,0) -> mch.duplicate
                   else
                      (if V.evType = 3 (* float *) then
                          (1,1) -> mch.duplicate
                       else
                          (1,0) -> mch.duplicate
                      if)
                  if)
               else
                  301->trace(#do 'eval4: V:'->display; V.display #);
                  (0,0) -> mch.duplicate;
                  V.type -> theGen.mkSignature ->  mch.allocAndStoreLocal
              if)
          if);
          (* FIXME: the following is very messsy *)
          (if (V.evType = 1 ) and false
              and (rDesc[]<>none) 
              and (sematt.repDesc->rDesc.equal) then
              'char2rep' -> mch.callPrim
           else
              (if not isSimpleVal
                  and (rType[]<>none) 
                  and (rType.length > 0) (* from asgToRep *)
                  and (V.evType<>4 (* strucref->Structure *))
                  and (rDesc[] <> none) and not (sematt.textDesc->rDesc.equal)
                  (* In X.get -> T[]
                   * get may return externalString
                   * and T may be a text;
                   * here we avoid a text-cast
                   * instead a coersion is made
                   * in textVarVal; but ugly
                   *)
                  and not (V.type -> theGen.mkSignature -> rType.equal) then
                  rType[] -> mch.checkCast
          if)if);
          (if inEnter then
              true -> inEnterDoExitMethod
          if)
       exit V[]
       #);
     lEv: ^ASTindex; (* isMultiple = true: lEv = EV1 -> EV2 -> ... *)
     baseAdr: ^mch.Address;
     lChain: ^DH.superChain;
     isMultiple: @boolean;
     llEV: ^evVal; (* llEV= none: do eval(lEv)
                    * llEV<>none: do lleV -> lEv
                    *)
  enter(baseAdr[],lEv[],lChain[],isMultiple,llEV[])
  exit this(methodArgs)[]
  #);
EnterArgs: evVal
  (# off: @integer;
     pushNext:
       (# class: ^text;
          A: @mch.RegAdr; T: @text
       enter class[]
       do off+4 -> off -> A.off;
          '!enterArgs:pushNext: '->T; off -> T.putInt; T -> mch.comment;
          'arg_' -> A.fieldName[];
          off -> A.fieldName.putint;
          (if class[] <> none then
              (if ('D' -> class.equal) or ('J' -> class.equal) then
                  class[] -> A.fieldType[];
                  (A[],none) -> mch.ldVal;
                  (if isJava then
                      off+4 -> off -> A.off;
                  if);
               else
                  (A[],class[],none)->mch.loadRef
              if)
           else     
              'I' -> A.fieldType[];
              (A[],none) -> mch.ldVal
          if);
          (if isMultiple then
              (1,0) -> mch.duplicate
          if)
       #);
     evId:: (# do 'EnterArgs:'->id[] #);
     display:: (# T: @text do 'off:'->T; off->T.putint; T[]->xT #);
     pushVal:: 
       (#
       do 301->trace(#do 'pushVal:'->display #);
          (*type should be handled*) pushNext ;
          asComputedVal -> V[]
       #);
     asComputedVal:
       (# EH: @evalHandler
       exit (0,false,false,false)->EH.mkComputedEvVal
       #);
     asgToAdr:: 
       (# 
       do '!enterArgs:asgToAdr:'->mch.comment;
          (if rA.size = 8 then
              'J' -> pushnext
           else
              pushNext; 
          if);
          (none,rA[]) -> mch.stVal;
          asComputedVal -> V[]
       #);
     asgToRealAdr::
       (#
       do 'D' -> pushNext; (none,rA[]) -> mch.stVal 
       #);
     asgToRefAdr::
       (# sourceClassName,destClassName: ^text;
          dDesc: @ASTindex; RC: ^DH.superChain;
          rA,rAx: ^mch.address; destEval,dcl: @ASTindex; 
       do '!EnterArgs:asgToRefAdr:'->mch.comment;
          destEv.son -> destEval;
          (if destEv.label = gram.structureReference then
              sematt.structureDesc -> dDesc;
           else
              (rChain[],destEval) 
                -> DH.theDesc 
                ->(dDesc,RC[]);
          if);
          dDesc[] 
            -> theGen.mkSignature 
            -> sourceClassName[] 
            -> destClassName[];
          (rAbase.copy,destEval[],false,rChain[])->genAdr->rA[];
          sourceClassName[] -> pushNext;
          destEval.dclref -> dcl;
          dcl.gettext -> rA.fieldName[];
          &mch.RegAdr[] -> rAx[];
          (rAx[],false,sourceClassName[],destClassName[])
            -> rA.asgRefAdr       
       #);
     asgToRepAdr::
       (# sourceClassName,destClassName: ^text
       do '!EnterArgs:asgToRepAdr' -> mch.comment;
          (if true then
              rA.fieldType[] 
                -> sourceClassName[] 
                -> destClassName[]
                -> pushNext; 
           else
              '[C' -> pushNext; 
              '[C' -> sourceClassName[] -> destClassName[];
          if);
          (&mch.RegAdr[],false,sourceClassName[],destClassName[])
            -> rA.asgRefAdr
       #);
     (*  insert::
      (#
      do '!enterArgs:insert:'->mch.comment;
      #);*)
     asgToItem::
       (# sig: @theGen.Signature;
          basicname,knownName: ^text
       do '!enterArgs:asgToItem:'->mch.comment;
          301->trace(#
                    do 'enterArgs:asgToItem:'->xT;
                       rDesc[] -> xA; xN;
                       'rA:'->xT; rA.display->xT; xN
                    #);
          true->rA.isRef;
          (rDesc[],true) -> descName -> basicName[] -> knownName[]; (* FIX possible virtual *)
          (if not rA.noTmp then
              (rA[],basicName[],none)->mch.loadRef; (* dup should be used *)
              true -> rA.noTmp;
              (0,0) -> mch.duplicate; (* for execution of do-method *)
          if);
          (rDesc[],rChain[],false(*?*)) -> sig.setMethodDesc;
          rDesc[] -> sig.addEnter;
          sig.exitVoid;
          common.enterMethod -> sig.addMethod;  

          sig.scanEnter
          (# 
          do (if isRef then
                 'someClassOrArry' -> pushNext 
              else
                 pushNext
             if)
          #);
       #);
     asgToMethod::
       (#
       do 301->trace(#
                    do 'asgToMethod:'->display;
                       (for i: noOfArgs repeat
                            enterTypes[next] -> xI
                       for)
                    #);
          (for i: noOfArgs repeat
               (if enterTypes[next] 
                // 11 // 12 // 13 // 14 then
                   'SomeClass' -> pushNext
                // 6 (* real/double *) // 7 (* real32 *) then
                   'D' -> pushNext 
                // 8 (* long=int64*) then
                   'J' -> pushNext
                else
                   pushNext 
               if);
               next + 1 -> next
          for);
          (* OBS. check that moved 'inner' in mkByteCodeCall is OK
           * We need the descriptor - it may be singular -
           * it must be called as a a method; i.e. 
           * treated like an inner pattern with method-version
           * and new-version
           *)
          next + noOfArgs -> next 
       #);
     asgToList::
       (# 
       do EV -> scanList
          (# E: @ASTindex
          do currentNode -> E;
             (BA[],this(enterArgs)[],E[],false,rChain[]) 
               -> AssignValToEval 
               -> V[];             
          #);
          (EV[],BA[],rChain[]) -> mkListVal -> V[]
       #);
     init:
       (#
       do 8 -> off
       #);
  exit this(enterArgs)[]
  #);
ExitMultiVal: evVal
  (# evId:: (# do 'ExitMultiVal:'->id[] #);
     display:: 
       (#
       do 'exitNo:'->xT; exitNo->xI; 'elmDesc:'->xT; elmDesc[]->xAF
       #);          
     asgToAdr::
       (# A: @mch.RegAdr;
       do 301->trace(#
                    do 'asgToAdr:'->display
                    #);
          (if tA[] = none then
              '\OBS! exitMultiVal:tA is none' -> putline;
              12 -> A.off;
              true -> A.isRef;
              (A[],&mch.adrRegOperand[]) -> mch.ldVal;
           else
              (tA[],&mch.adrRegOperand[]) -> mch.ldVal;
          if);
          (mkA,&mch.dataRegOperand[]) -> mch.ldVal;          
          true -> rA.isField;
          (&mch.dataRegOperand[],rA[]) -> mch.stVal;
       #);
     asgToRealAdr::
       (#
       do 301->trace(#
                    do 'asgToRealAdr'->display;
                    #);
          (tA[],&mch.adrRegOperand[]) -> mch.ldVal;
          (mkA,&mch.dataRegOperand[]) -> mch.ldVal;
          true -> rA.isField;
          (&mch.dataRegOperand[],rA[]) -> mch.stVal;          
       #);
     asgToRefAdr::
       (# A: @mch.RegAdr; aS,rA: ^mch.address; 
          destClass: ^text; withQua: @boolean;
       do 301->trace(#
                    do 'asgToRefAdr'->display;
                    #);          
          (rAbase.copy,destEv.sonRef,false,rChain[])->genAdr->rA[];
          (tA[],&mch.adrRegOperand[]) -> mch.ldVal;
          (mkA->aS[],&mch.adrRegOperand[]) -> mch.ldVal; 
          (*rAbase.copy -> rA[];*)
          
          true -> rA.isField;  
          true -> rA.isRef;
          (if destEv.label=gram.structureReference then
              (theGen.StructureSignatureId->theGen.specialSignature).asText 
                -> destClass[]
           else
              rA.bAdr.localDesc[] 
                -> theGen.mkSignature -> rA.fieldType[] -> destClass[];
          if);
          (if (destClass[] <> none) and (aS.fieldType[] <> none) then
              not (destClass[] -> aS.fieldType.equal) -> withQua;
           else
              '\nOBS! destClass[]=none) or (aS.fieldType[]=none)'
                -> putline
          if);
          (&mch.adrRegOperand[],withQua,'???',destClass[])
            -> rA.asgRefReg
       #);
     asgToRepAdr::
       (#
       do 301->trace(#
                    do 'astToRepAdr:'->display;                       
                    #);
          (tA[],&mch.adrRegOperand[]) -> mch.ldVal;
          (mkA,&mch.dataRegOperand[]) -> mch.ldVal;
          true -> rA.isField;
          (&mch.dataRegOperand[],rA[]) -> mch.stVal;
       #);
     asgToItem::
       (# EH: @EvalHandler;
          nScan: @ | EH.scanNadr; more: @boolean;
          A: @mch.RegAdr;
       do 301->trace(#
                    do 'asgToItem'->display;
                    #);
          (rDesc[],rA[],0,rChain[],true) 
               -> nScan -> more;
             L:
            (if more then
                (tA[],&mch.adrRegOperand[]) -> mch.ldVal;
                (mkA,&mch.dataRegOperand[]) -> mch.ldVal;
                nScan -> more;
                restart L
            if) 
       #);
     asgToList::
       (#
       do 301->trace(#
                    do 'asgToList'->display;
                    #);
          EV -> scanList
          (# E: @ASTindex
          do currentNode -> E;
             (BA[],this(exitMultiVal)[],E[],false,rChain[]) 
               -> AssignValToEval 
               -> V[];             
          #);
          (EV[],BA[],rChain[]) -> mkListVal -> V[]
       #);
     mkA: 
       (# T: @text; aD: @mch.RegAdr 
       do (*'XA:exitMultiVal:mkA:'->puttext;*)
          'exit_' -> T;
          exitNo -> T.putint;
          exitno + 1 -> exitNo;
          T[] -> aD.fieldName[];
          class[] -> aD.receiverType[];

          (if (elmDesc[] = none) or (elmDesc.isNull) then
              '\nOBS!ExitMultiVal: ElmDesc is none or null'->putline;
              (if common.switch[311] then
                  (failureTrace,'ExitMultiVal: ElmDesc is none or null')
                    -> stop;
              if);
              sematt.integerDesc[] -> theGen.mkSignature -> aD.fieldType[]
           else
              (if elmDesc.label <> gram.objectDescriptor then
                  '\nOBS!ExitMultiVal: ElmDesc is not descriptor'->putline
               else
                  (if isRep then
                      elmDesc[] -> theGen.mkArraySignature -> aD.fieldType[]
                   else
                      elmDesc[] -> theGen.mkSignature -> aD.fieldType[];
                  if)
          if)if);
          (*aD.fieldType[] -> puttext; ',' -> put;*)
          true -> aD.isField
       exit aD[]
       #);
     xA: @text;
     class: ^text;
     tA: ^mch.address; (* address tmp-var for object *)
     exitNo: @integer;
     elmDesc: ^ASTindex;
     isrep: @boolean
  enter exitNo
  exit this(ExitMultiVal)[]
  #);
