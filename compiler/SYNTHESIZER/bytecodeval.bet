ORIGIN 'evlib';
INCLUDE 'auxlib';
INCLUDE 'evlib';
INCLUDE 'nxlength';
INCLUDE 'signature';
INCLUDE 'genlib_bytecode';
---mkMethodArgs:doPart---
do (baseAdr[],lEv[],lChain[],isMultiple,llEV[]) -> MethodArgs -> V[]
   
---mkEnterArgs:doPart---
do EnterArgs -> V[]
   
---mkExitMultiVal:doPart---
do exitNo -> ExitMultiVal -> V[]
   
---evalLib:attributes---
methodArgs: evVal
  (# inEnter: @boolean;
     evId:: (# do 'MethodArgs:'->id[] #);
     display::
       (#
       do lEV[]-> xA 
       #);
     loadVal:: 
       (#
       do ((isMultiple,false,true,false,'',none)->eval).loadVal 
            -> V[] 
       #);
     loadVal2:: 
       (#
       do ((isMultiple,false,true,false,'',none)->eval).loadVal 
            -> V[] 
       #);
     pushVal::
       (#
       do '!methodArgs:pushVal:' -> mch.comment;
          ((isMultiple,false,true,false,'',none)->eval).pushVal 
            -> V[];
       #);
     mkReal::
       (#
       do ((isMultiple,false,true,false,'',none)->eval).mkReal 
            -> V[];
       #);
     asgToAdr::
       (# EH: @evalHandler; isRepAdr: @boolean
       do 301->trace(#
                    do 'asgToAdr:'->display; 'rA: ' -> xT; rA.display-> xT
                    #);
          '!methodArgs:asgToAdr:'->mch.comment;
          (if isMultiple then
              'index$'-> rA.fieldName.equal -> isRepAdr 
          if);
          (isMultiple,true,true,isRepAdr,'',none) -> eval -> V[];
          301->trace(#do 'methodArgs:asgToAdrX: '->xT; V.display #);
          (* fieldType is not always set: as in 'a' -> c;
           * should perhaps be ensured in genAdr?
           *)
          (if rA.bAdr.localDesc[] <> none then
              rA.bAdr.localDesc[] -> theGen.mkSignature -> rA.fieldType[]
          if);
          rA[] -> V.asgToAdr -> V[];
          (if isMultiple and not isJava then mch.loadLocal if);
          301->trace(#
                    do 'methodArgs:asgToAdrZ: '->xT; 
                       (if V[] = none then
                           'V is None' -> xT
                        else
                           V.display
                       if)
                    #);
       #);
     asgToRefAdr::
       (# rA: ^mch.address; T: ^text
       do 301->trace(#do 'asgToRefAdr:'->display; #);
          '!methodArgs:asgToRefAdr1'->mch.comment;
          (rAbase[],destEV.sonRef,false,rChain[]) -> genAdr -> rA[]; 
          '!methodArgs:asgToRefAdr2:'
            -> (rA.fieldType.copy).prepend -> T[];
            T -> mch.comment;
          (if destEv.label=gram.structureReference then
              (theGen.StructureSignatureId->theGen.specialSignature).asText -> rA.fieldType[]
          if);
          (isMultiple,true,false,false,rA.fieldType[],rA.bAdr.localDesc[]) 
            -> eval -> V[];
          '!methodArgs:asgToRefAdr3'->mch.comment;
          (*V.pushVal -> V[];*)
          '!methodArgs:asgToRefAdr4'->mch.comment;
          (# T: ^text do rA.display->T[]; T -> mch.comment;#);
          (rA[],destEV[],rChain[]) -> V.asgToRefAdr -> V[];
          '!methodArgs:asgToRefAdr5'->mch.comment;
          (if isMultiple and not isjava then mch.loadLocal if);
       #);
     asgToRealAdr::
       (#
       do 301 -> trace(#
                      do 'asgToRealAdr:'->display
                      #);
          rA[] 
            -> ((isMultiple,true,true,false,'',none) -> eval).asgToRealAdr
            -> V[];
          (if isMultiple and not isjava then mch.loadLocal if);
       #);
     asgToRepAdr::
       (#
       do 301->trace(#do 'asgToRepAdr:'->display; #);
          'methodArgs:asgToRepAdr1'->mch.comment;
          (isMultiple,false,false,false,'',sematt.repDesc[]) ->eval -> V[];
          'methodArgs:asgToRepAdr2'->mch.comment;
          (* V.pushVal -> V[];*)
          (rA[],rEV[],rChain[]) -> V.asgToRepAdr -> V[];
          'methodArgs:asgToRepAdr3'->mch.comment;
          (*((12),1,1) -> (eval).asgToMethod*)
       #);
     asgToRepElm::
       (#
       do 301->trace(#
                    do 'asgToRepElm:'->display
                    #);
          (rA[],rEv[],rChain[])
          -> ((isMultiple,true,true,false,'',none)->eval).asgTorepElm
       #);
     asgToMethod::
       (# V: ^evVal
       do 301->trace(#do 'asgToMethod:'->display; #);
          (if llEV[] <> none then
              (*1->trace(#
                      do 'eval:assignToList:'->xT; llEV.display; xN;
                         lEv[] -> xA
                      #);*)
	      (baseAdr[],llEv[],lEv[],true,lChain[])
                -> assignValToEval
                -> V[]
           else          
              (baseAdr[],lEv[],true,lChain[])
                -> ExpEval
                -> V[];
          if);
          301->trace(#do 'asgToMethod2:'->display;V.display #);
          (enterTypes,noOfArgs,next,rElm[],rChain[]) 
            -> V.asgToMethod
            -> next
       #);
     asgToList::
       (# A: ^mch.address
       do 301->trace(#do 'asgToList:'->display; #);
          (if llEV[] <> none then
              (if false then
                  1->trace(#
                          do 'eval:assignToList:'->xT; llEV.display; xN;
                             lEv[] -> xA
                          #);
              if);
	      (baseAdr[],llEv[],lEv[],true,lChain[])
                -> assignValToEval
                -> V[]
           else
              (baseAdr[],lEv[],true,lChain[])
                -> ExpEval
                -> V[];
          if);
          (*V.loadVal -> V[];*)
          (*theGen.AllocAndstoreTmp -> A[];*)
          (BA[],EV[],rChain[]) -> V.asgToList
       #);
     asgToItem::
       (# V: ^evVal; sig: @theGen.signature;
       do 301->trace(#do 'asgToItem:'->display; #);
          (baseAdr[],lEv[],true,lChain[])
            -> ExpEval
            -> V[];
          (rDesc[],rChain[],false(*?*)) -> sig.setMethodDesc;
          rDesc[] -> sig.addEnter;
          sig.exitVoid;
          (# T: [sig.noOfEnterArgs] @integer;
             top: @integer
          do sig.scanEnter
             (#
             do current.elmType -> T[top+1 -> top]
             #);
             (T,top,1,rDesc[],rChain[]) -> V.asgToMethod
          #)
       #);
     asgToExitArgs::
       (# V: ^evVal; xT: ^ExitTypes
       do (baseAdr[],lEv[],true,lChain[])
            -> ExpEval
            -> V[];
          (rDesc[],exitNo,originAdr[],rChain[]) 
            -> V.asgToExitArgs 
            -> (exitNo,xT[]);
          xT[] -> xTypes.concatenate -> xTypes[]
       #);
     asgToCproc::
       (#
       do (if stest then 301->ctrace
              (#
              do 'methodArgs:asgToCproc: '->xT; lEv[] -> xA 
          #)if);
          eval -> V[];
          (*V.pushVal -> V[];*)
          (EV[],externalName[],desc[],extKind) -> V.asgToCproc -> V[]
       #);
     asgToInlinePrimitive::
       (#
       do 301->trace(#
                    do 'asgToInlinePrimitive:opCode: ' -> xT; opCode->xI
                    #);
          (OpCode,I1,I2) -> (eval).asgToInlinePrimitive -> V[];
          301->trace(#
                    do 'asgToInlinePrimitive:after: '->xT;
                       V.display
                    #)
       #);
     asgToNewPrim::
       (#
       do 301->trace(#
                    do 'asgToNewPrim:'->display; ev[]->xA
                    #);
          (baseA[],ev[],rchain[]) -> (eval).asgToNewPrim -> V[]
       #);
     cmpBoolAndJmp:: (#do '\nOBS! cmpBoolAndJmp'->putline #);
     cmp:: (# do '\nOBS! cmp'->putline; #);
     adrCmp:: (# do '\nOBS! adrCmp'->putline; #);
     cstCmp:: (# do '\nOBS! cstCmp'->putline; #);
     regCmp:: (# do '\nOBS! regCmp'->putline; #);
     times:: (# do 301->trace(# do 'times'->display #) #);
     adrTimes:: (# do 301->trace(#do 'adrTimes'->display #) #);
     cstTimes:: (# do 301->trace(#do 'cstTimes'->display #) #);
     regTimes:: (# do 301->trace(# do 'regTimes'->display #) #);          
     eval: 
       (# dup,pushVal
          ,isSimpleVal
          ,isRepAdr: @boolean; (* this eval is assigned to R[e] and
                                * the address of R[e] is on the stack
                                *)
          V: ^evVal;
          rType: ^text;
          rDesc: ^ASTindex;
          isExternalString: @boolean
       enter(dup,pushVal,isSimpleVal,isRepAdr,rType[],rDesc[])
       do 301->trace(#
                    do 'eval:'->display; xN;
                       'dup: ' -> xT; dup->xB;
                       'pushVal:'->xT; pushVal->xB;
                       'isSimpleVal:' ->xT; isSimpleVal -> xB;
                       'isRepAdr:'->xT; isRepAdr -> xB;
                       'rType:'->xT; rType[] -> xT; xN;
                       (if llEV[]<>none then 
                           'llEV:'->xT; llEV.display;; xN;
                       if);
                       'lEV:'->xT; lEV[] -> xA
                    #);
          'methodArgs:eval:1'->mch.comment;
          (if inEnter then
              false -> inEnterDoExitMethod
          if);
          (if llEV[] <> none then
              301->trace(#
                      do 'eval:assign:'->xT; llEV.display; xN;
                         lEv[] -> xA;
                         ' dup:'->xT; dup -> xB
                        #);
              (* Multiple assignment: llEV -> lEV
               * Case ente(a->b)
               *   llEV = enterArgs
               *   lEV  = a   or a -> b
               *   dup  = true
               *   The dup should be part of assignValToEval
               *   and not after 
               * llEv.pushVal -> llEv[]; - dont work since adr
               * of lEv is not computed
               *)
              (*llEV.markMultiple;*)
	      (baseAdr[],llEv[],lEv[],true,lChain[])
                -> assignValToEval
                -> V[]
           else
              (baseAdr[],lEv[],true ,lChain[]) 
                -> ExpEval
                -> V[]
          if);
          (if false then
              (if (V.evType = 1 (* could be char*))
                  and (rDesc[]<>none)
                  and (sematt.repDesc->rDesc.equal) then
                  (* could be 'a' -> R - in which case we should push 'a'
                   * or R.foo -> R where foo returns a char literal and
                   * here the value is already on the stack
                   *)
                  (* true -> pushVal -> isSimpleVal*)
          if)if);
          'methodArgs:eval:2'->mch.comment;
          (if V[] = none then '\nMethodArgs:eval:V is none ' -> putline if);
          301->trace(#
                    do 'eval2:'->display; 'dup:'->xT; dup->xB; xN; 
                       V.display 
                    #);
          (if pushval then
              (* we need the rType here for text/const literals;
               * this is tricky and should be reconsidered;
               * also since dup_x1 does not exist on .NET
               *)
              (* reconsider structure of pushVal here and in txtcstval *)
              (rType[]<>none) 
              and ((isJava and ('java/lang/String' -> rType.equal)) 
                   or ('class [mscorlib]System.String'->rType.equal))
                -> isExternalString;
              (if isExternalString then
                  (* to avoid conversion to BETA text - clumsy *)
                  true -> V.pushVal -> V[]
               else
                  isSimpleVal -> V.pushVal -> V[]
              if);
              301->trace(#do 'eval3: V:'->display; V.display #);
              (if not isSimpleVal and not isExternalString then
                  V.mkBetatext; (* reconsider *)
              if)    
          if);
          (if dup then
              (if isJava then
                  (if isRepAdr then
                      (2,0) -> mch.duplicate
                   else
                      (if V.evType = 3 (* float *) then
                          (1,1) -> mch.duplicate
                       else
                          (1,0) -> mch.duplicate
                      if)
                  if)
               else
                  301->trace(#do 'eval4: V:'->display; V.display #);
                  (0,0) -> mch.duplicate;
                  V.type -> theGen.mkSignature ->  mch.allocAndStoreLocal
              if)
          if);
          (* FIXME: the following is very messsy *)
          (if (V.evType = 1 ) and false
              and (rDesc[]<>none) 
              and (sematt.repDesc->rDesc.equal) then
              'char2rep' -> mch.callPrim
           else
              (if not isSimpleVal
                  and (rType[]<>none) 
                  and (rType.length > 0) (* from asgToRep *)
                  and (V.evType<>4 (* strucref->Structure *))
                  and (rDesc[] <> none) and not (sematt.textDesc->rDesc.equal)
                  (* In X.get -> T[]
                   * get may return externalString
                   * and T may be a text;
                   * here we avoid a text-cast
                   * instead a coersion is made
                   * in textVarVal; but ugly
                   *)
                  and not (V.type -> theGen.mkSignature -> rType.equal) then
                  rType[] -> mch.checkCast
          if)if);
          (if inEnter then
              true -> inEnterDoExitMethod
          if)
       exit V[]
       #);
     lEv: ^ASTindex; (* isMultiple = true: lEv = EV1 -> EV2 -> ... *)
     baseAdr: ^mch.Address;
     lChain: ^DH.superChain;
     isMultiple: @boolean;
     llEV: ^evVal; (* llEV= none: do eval(lEv)
                    * llEV<>none: do lleV -> lEv
                    *)
  enter(baseAdr[],lEv[],lChain[],isMultiple,llEV[])
  exit this(methodArgs)[]
  #);
methodCall: evVal
  (# evId:: (#do 'MethodCall:'->id[] #);
     display:: (# do sig.asText -> xT #);
     loadVal:: 
       (# 
       do 301->trace(#do 'methodCall:loadVal' -> xT #);
          (*this(methodCall)[] -> V[]; (* ???*) 
          thisExitVal -> V[]
       #);
     evType:: 
       (#
       do (if not sig.isMultiValExit and (sig.XXsig.isRef) then
              2 -> type
           else 
              (if exitValIsReal then 
                  3 -> type 
               else
                  1 -> type 
              if)
          if)
       #);
     type::
       (#
       do (if (sig[]<>none) and (sig.XXsig[] <> none) then
              sig.XXsig.theDesc -> desc[] 
           else
              '\nmethodCall:type:sig.XXsig is none'->putline
          if)
       #);
     toDataReg:: 
       (# 
       do 301->trace(#do 'methodCall:toDataReg' -> xT #);
       #);
     loadVal2:: 
       (# 
       do 301->trace(#do 'methodCall:loadVal2' -> xT #);
          thisExitVal -> V[]
       #);
     pushVal::
       (# dr: @mch.dataRegOperand
       do 301->trace(#do 'methodCall:pushVal' -> xT #);
          '!methodCall:pushVal' -> mch.comment;
          (* (dr,false,false,false) -> mkComputedEvVal -> V[];*)
          (* the result of the methodcall is on the stack *)
          (* this(methodCall)[] -> V[]*)
          thisExitVal -> V[]
       #);
     mkReal::
       (#
       do &mch.floatRegOp[] -> mkFloatEvVal -> V[]
       #);
     loadFloat :: (# do &mch.floatRegOp[] -> res[] #);
     getRefEval::
       (#
       do this(methodCall)[] -> V[]
       #);
     theAdr:: 
       (# A: @mch.RegAdr; D: ^ASTindex
       do (if sig.aplSig[] <> none then
              sig.XXsig.theDesc -> D[];
              (if not (D -> (sig.aplSig.theDesc).equal) then
                  'cast' -> mch.comment;
                  sig.aplSig.asText -> mch.checkCast
          if)if);
          A[] -> AV[]
       #);
     asgToAdr::
       (# dr: @mch.dataRegOperand; D: ^ASTindex
       do (* we assume a value on top of the stack *)
          dr.alloc;
          301->trace(#do 'asgToAdr: '->display; rA.display->xT #);
          type -> D[];
          (if sig.XXsig.elmType = 8 (* int64 *) then
              mch.int64ToInt32
          if);
          (dr[],rA[]) -> mch.stVal; (* no handling of size *)
          (dr,false,false,false) -> mkComputedEvVal -> V[];
       #);
     asgToRefAdr::
       (# EV: @ASTindex; ok: @boolean
       do 301 -> trace(#
                      do 'asgToRefAdr: '->display;
                         100 -> switchon;
                         sig.exitVal[] -> xA;
                         100 -> switchOff
                      #);
          (* the method, including exit-part has been executed
           * and a reference is returned on the stack. We must
           * get the type of the reference and assign it to destEv
           *)
          sig.exitVal[]->sematt.evCase
          (# objRef::
               (#
               do (0,false,EV.sonRef,chain[]) 
                    -> mkComputedRefEvVal
                    -> V[];
                  true -> ok
               #);
             dynItemRef::
               (#
               do (0,false,EV.sonRef,chain[]) 
                    -> mkComputedRefEvVal
                    -> V[];
                  true -> ok
               #);
             strucRef::
               (#
               do (0,false,EV.sonRef,chain[]) 
                    -> mkComputedRefEvVal
                    -> V[];
                  true -> ok
               #);
             txtCst::
               (# T: ^text 
               do EV.gettext->T[]; 
                  T->mkTxtCstEvVal->V[];
                  true -> ok
               #);
             insert::
               (# xScan: @| scanXadr; gXl: ^| sematt.getNXlength
               do (sig.thisMethodDesc[],rAbase.copy,0,chain[]) -> xScan; 
                  &|sematt.getNXlength[] -> gXl[];
                  (xScan.thisEv[],false,EV[],xScan.thisChain[])
                    -> gXl;
                  301->trace(#
                            do 'insert: ' -> xT;
                               gXl.thisEv[] -> xA
                            #);
                  (0,false,gXl.thisEv[],gXL.thisChain[]) 
                    -> mkComputedRefEvVal
                    -> V[];
                  true -> ok
               #)
          #);
          (if not ok then
              1-> trace(#
                       do 'asgToMethod:sig.ExitVal[]not handled: '->display;
                          xN;
                          sig.ExitVal[] -> xA
                       #)
          if);
          (rAbase[],destEV[],rChain[]) -> V.asgToRefAdr;
          (0,false,destEv[],rChain[]) -> mkComputedRefEvVal -> V[];
       #);
     asgToRealAdr::
       (#
       do rA[] -> (&mch.floatRegOp[] -> mkFloatEvVal).asgToRealAdr -> V[]
       #);
     asgToRepAdr::
       (#
       do 301 -> trace(#
                      do 'methodCall:asgToRepAdr: '->xT;
                         sig.exitVal[] -> xA
                      #);
          (if sig.isMultiValExit then
              301->trace(#
                      do 'asgToRepAdr:'->display;
                         'method returning a list to be assigned to '
                         'a repetition is NOT implemented'
                         -> xT
                      #)
           else
              (if sig.XXsig.elmType = 12 (* array *) then
                  (* method has returned an array: store it in rA *)
                  (&mch.dataRegOperand[],rA[]) -> mch.stVal
               else
                  (* method has returned a value (simple or ref)
                   * that should be coerced into a repetition
                   *)
                  (rA[],rEV[],rChain[]) 
                    -> ((0,false,false,false)->mkComputedEvVal).asgToRepAdr 
                    -> V[]
          if)if)
       #);
     asgToRepElm::
       (#
       do 301->trace(#do 'asgToRepElm:'->display #);
          (rA[],rEv[],rChain[])
            -> ((0,false,false,false)->mkComputedEvVal).asgToRepElm
            -> V[]
       #);
     asgToItem::
       (#
       do '\nMethodCall:asgToItem' -> putline
          
       #);
     asgVal2Rep: (* duplicate  form computedval *)
       (# elmDesc,rEv: ^ASTindex; rChain: ^DH.superChain; 
          rA: ^mch.address;  noStore: @boolean;
          tA: ^mch.address;
          V: ^evVal
       enter(elmDesc[],rEV[],rChain[],rA[],noStore)
       do (* val -> aRep *)
          (*  stack = [... Val ] *)
          (if switch182 then
              sematt.integerDesc[] 
                -> theGen.mkSignature 
                -> theGen.allocAndStoreTmp 
                -> tA[]
          if);
          (elmDesc[],true,false,rA.size,1,rA[],noStore) -> asgToNewRep
          (#
          do (if switch182 then
                 (rEV[],rChain[],rA[]) -> asgToSingleElmArray
                 (#
                 do AI.bAdr.localDesc[]
                      -> theGen.mkSignature 
                      -> AI.fieldType[];
                    (tA[],mch.dataTop[]) -> mch.ldVal
                 #)
              else
                 NextElmAdr -> asgToAdr -> V[]
             if)
          #);
       exit V[]
       #);     

     asgToMethod::
       (* Assign m1 to m2 as in the following forsm
        *    m1 -> m2
        * or
        *    (e1,e2,...,m1,...en) -> m2
        * where m1 = this(methodCall)
        * and m2 is described by arguments to asgToMethod;
        * Push return value(s) from m1 as arguments to m2.
        * Note: m1 determines how many values to push;
        * m2 cannot be used to determine this, since
        * there may be other arguments to m2 than m1 as shown
        * by the 2. fomr above
        *)
       (# A: ^mch.address; aS: @mch.RegAdr; srcField: ^text; xNo: @integer;
          gNXl: ^|sematt.getNXlength; 
          rA: ^mch.address; desc: ^ASTindex;
          checkText2ExternalString:
            (# d: ^ASTindex;
               leftIsRep: @boolean
            enter(d[],leftIsRep)
            do (if (d[]<>none) then
                   (if true
                    // (d->sematt.textDesc.equal) 
                         and (enterTypes[next] = 13 (* external *)) then
                       'BetaText2ExternalString' -> mch.callprim 
                    // ((d->sematt.descKind) = sematt.externalClassKind)
                       and (enterTypes[next] = 14 (* textDesc *) ) then
                       'ExternalString2BetaText' -> mch.callprim
                    // (d->sematt.textDesc.equal) 
                       and  (enterTypes[next] = 12 (* array *)) then
                       'text2char' -> mch.comment;
                       'BetaText2BetaCharArray' -> mch.callPrim
                    else
                       (if not leftIsRep
                           and (enterTypes[next] = 12 (* array *)) then
                           baseAdr.copy -> rA[];
                           (rElm[],rChain[],rA[]) -> getElmDesc -> desc[];
                           301->trace(#
                                     do rElm[]->xA; xN; 
                                        desc[]->xA; desc.size -> xI 
                                     #);
                           desc.size -> rA.size;
                           desc[] -> rA.bAdr.localDesc[];
                           (desc[],rElm[],rChain[],rA[],true) -> asgVal2Rep
                       if)
               if)if)
            #);
            leftIsRep: @boolean
       do 301->trace(#
                    do 'MethodCall:asgToMethod: ' -> xT;
                       sig.asText -> xT; ' ' -> put;
                       noOfArgs -> xI; ':' -> put;
                       (for i: (noOfArgs,entertypes.range) -> min repeat
                            entertypes[i] -> xI; ' ' -> put;
                       for);
                    #);
          (if sig.isMultiValExit then
              sig.XXsig.asText -> theGen.AllocAndStoreTmp -> A[];
              (* we need to get the right values instead of
               * gen.thisRegAdr and thisSuperChain
               * from the place where methodCall is instantiated
               *)
              'exit_' -> srcField[];
              (sig.thisMethodDesc[] -> theGen.fieldSignature).asText 
                -> aS.receiverType[];
              true -> aS.isField;
              sig.scanExit
              (# desc: ^ASTindex
              do (A[],&mch.adrRegOperand[]) -> mch.ldVal;
                 xNo + 1 
                   -> xNo   
                   -> (srcField.copy).putint 
                   -> aS.fieldName[];
                 (if (current.elmType = 12)->leftIsRep (* array *) then
                     '\nbingo'->putline;
                     current.theDesc 
                       -> desc[] 
                       -> theGen.mkArraySignature 
                       -> aS.fieldType[]
                  else
                     current.theDesc 
                       -> desc[] 
                       -> theGen.mkSignature 
                       -> aS.fieldType[]
                 if);
                 (aS[],&mch.dataRegOperand[]) -> mch.ldVal;
                 (desc[],leftIsRep) -> checkText2ExternalString;
                 next + 1 -> next;                
              #)
           else
              (sig.XXsig.theDesc,sig.XXsig.elmType=12(*array*))
                -> checkText2ExternalString;
              next+1 -> next;              
          if)
       #);
     asgToExitArgs::
       (* Assign
        *    this(methodCall) -> (exit_exitNo, exit_exitNo+1, ...)
        * rDesc    : the receiver object with fields exit_exitNo, ...
        * exitNo   : next exit-field to be assigned
        * originAdr: address of origin of ...
        * rChain   : superChain 
        *)
       (# A: ^mch.address; aS,aD: @mch.RegAdr; 
          srcField,destField: ^text; xNo: @integer;
          xScan: @ | scanXadr; notFirst,more: @boolean;
          rSig: @thegen.signature;
       do (*'MethodCall:asgToExitArgs:'->puttext;*)
          (if sig.isMultiValExit then
              (* this(methodCall) returns a list of values *)
              sig.XXsig.asText -> theGen.AllocAndStoreTmp -> A[];
              (* we need to get the right values instead of
               * gen.thisRegAdr and thisSuperChain
               * from the place where methodCall is instantiated
               *)
              (sig.thisMethodDesc[],gen.thisRegAdr,0(*??nOff*),chain[]) 
                -> xScan -> more;
              'exit_' -> destField[];
              'exit_' -> srcField[];
              (sig.thisMethodDesc[] -> theGen.fieldSignature).asText 
                -> aS.receiverType[];
              (rDesc[] -> theGen.fieldSignature).asText 
                -> aD.receiverType[];
              (*'scanExit:'->puttext;*)
              sig.scanExit
              (#
              do (if notFirst then
                     (originAdr[],none) -> mch.ldVal
                 if);
                 true -> notFirst;
                 (A[],&mch.adrRegOperand[]) -> mch.ldVal;
                 true -> aS.isField;
                 true -> aD.isField;
                 xNo + 1 
                   -> xNo 
                   -> (srcField.copy).putint 
                   -> aS.fieldName[];
                 current.theDesc 
                   -> theGen.mkSignature 
                   -> aS.fieldType[]
                   -> aD.fieldType[](* -> puttext;*);
                 (aS[],&mch.dataRegOperand[]) -> mch.ldVal;
                 exitNo + 1 
                   -> exitNo
                   -> (destField.copy).putint 
                   -> aD.fieldName[];
                 (* OBS: missing handling os isRep *)
                 (current.theDesc,false) -> xTypes.add;
                 (&mch.dataRegOperand[],aD[]) -> mch.stVal;
              #);
          if)
       #);
     asgToList::
       (* Assign
        *    M -> (E1,E2,...En)
        * where M  = this(methodCall)
        * and   EV = (E1,E2,...,En)
        *)
       (# lEV: @ExitMultiVal; exitNo: @integer;
          nextEVlistElm: @|
            (# E: @ASTindex
            do EV -> scanList
               (#
               do currentNode -> E;
                  SUSPEND
               #)
            exit E[]
            #);
          E: ^ASTindex
               
       do 301->trace(#do 'asgToList:'->display #);
          
          sig.XXsig.asText 
            -> lEV.class[]
            -> theGen.AllocAndStoreTmp 
            -> lEV.tA[];
          (* here we should probably use sig.scanExit
           * to get the correct type of the exit-elements;
           * we should use gNXL on each element Ei in EV
           * to enumerate the enter-elements of Ei;
           * this should fix the type problem in tstnxoff
           * - which does not run with sun-java but is ok
           * with gij
           *)
          sig.scanExit
          (# more: @boolean; 
             xNo: @integer;
             gNXL: ^| sematt.getNXlength
          do (if (xNo+1 -> xNo) = (exitNo+1) then
                 nextEVListElm -> E[];
                 &|sematt.getNXlength[] -> gNXL[];
                 (E[],true,thisDesc[],rChain[]) -> gNXL -> more; 
                 L: (if more then 
                        exitNo+1 -> exitNo -> lEV;
                        301->trace(# F: @ASTindex
                                do 'exitNo: ' -> xT; exitNo->putInt; 
                                   ' left:'->puttext;
                                   current.asText -> puttext;
                                   ' right:'->puttext;
                                   current.theDesc->xA; xN;
                                   (current.theDesc).father -> F;
                                   F[]->xA
                                #);
                        current.theDesc -> lEV.elmDesc[];
                        current.elmType = 12 -> lEV.isRep;
                        (if lEV.isRep then
                            301->trace(#do 'isRep:'->xT #)
                        if);
                        (BA[],lEV[],E[],false,rChain[]) 
                          -> AssignValToEval 
                          -> V[];
                        C: (if (gNXL -> more) then
                               exitNo+1 -> exitNo;
                               restart C
                           if)
                    if);
             if)
          #)
       #);
     asgToCproc::
       (#
       do '\nOBS! MethodCall:asgToCproc:notImplemented'->putline;
          this(methodCall)[] -> V[]; (* just a hack - doesn't work *)
       #);
     pushCpar::
       (# D: ^ASTindex
       do sig.XXsig.theDesc -> D[];
          (if (D -> sematt.textDesc.equal) 
              and (type = common.externalStringXpar) then
              'BetaText2ExternalString' -> mch.callprim 
          if);
       #);
     asgToInlinePrimitive::
       (#
       do 301->trace(#
                    do 'asgToInlinePirmitive: ' ->display;
                    #);
          (OpCode,I1,I2) ->  (asComputedVal).asgToInlinePrimitive -> V[]
          (*(0,false,false,false) -> mkComputedEvVal -> V[]*)
       #);
     unMinus::<
       (# dr: @mch.dataRegOperand
       do (dr[],4)->mch.gNeg;
          (dr,false,false,false) -> mkComputedEvVal -> res[];          
       #);
     notExp::< 
       (# dr: @mch.dataRegOperand
       do (dr[],4)->mch.gNot;
          (dr,false,false,false) -> mkComputedEvVal -> res[]; 
       #);
     cmpBoolAndJmp::<
       (#
       do (if not common.switch[188] then
              '\nOBS! methodCall:cmpBoolAndJmp' -> putline;
          if)
       #);
     cmp::< 
       (# dr: @mch.dataRegOperand
       do dr->lV.regCmp->doCmp; 
       #);
     adrCmp::< 
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:AdrCmp'->putline 
          if);
          (evType=2) -> isRef
       #);
     cstCmp::< 
       (* this(methodCall) CMP rC *)
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:cstCmp'->putline
          if);
          rC[] -> op1[]; &mch.dataRegOperand[]->op2[]; 
          (evType=2) -> isRef
          (* op2 is top of stack (methodCall), so
           * showuld we do a swap of reverse CMP-operator?
           *)          
       #);
     regCmp::<(* this(methodCall) COMP rReg *)
       (#
       do 'methodCall:regCmp' -> mch.comment;
          &mch.dataRegOperand[] -> op1[];
          rreg[] -> op2[];
          false -> deAllocOp1 -> deAllocOp2;
          (evType=2) -> isRef
       #);
     
     add::< 
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:add'->putline 
          if);
          lv[] -> (asComputedVal).add -> res[]
       #);
               
     adrAdd::<
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:adrAdd'->putline
          if);
          rA[] -> (asComputedVal).adrAdd -> V[]
       #);
     cstAdd::<
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:cstAdd'->putline;
          if);
          rN -> (asComputedVal).cstAdd -> V[]
       #);
     regAdd::<
       (# 
       do (if not common.switch[188] then
                 '\nOBS! methodCall:regAdd'->putline 
          if);
          rReg -> (asComputedVal).regAdd -> V[]
       #); 
     sub::< 
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:sub'->putline 
          if);
          lv[] -> (asComputedVal).sub -> res[]
       #);
               
     adrSub::<
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:adrSub'->putline
          if);
          rA[] -> (asComputedVal).adrSub -> V[]
       #);
     cstSub::<
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:cstSub'->putline;
          if);
          rN -> (asComputedVal).cstSub -> V[]
       #);
     regSub::<
       (# 
       do (if not common.switch[188] then
                 '\nOBS! methodCall:regSub'->putline 
          if);
          rReg -> (asComputedVal).regSub -> V[]
       #); 
          
     times::
       (#
       do 301->trace(#
                    do 'times:' -> display
                    #);
          lv[] -> (asComputedVal).times -> res[]          
       #);
     adrTimes::
       (#
       do 301->trace(#
                    do 'adrTimes:' -> display
                    #);
          rA[] -> (asComputedVal).adrTimes -> V[]          
       #);
     cstTimes::
       (#
       do 301->trace(#
                    do 'cstTimes:' -> display
                    #);
          rN -> (asComputedVal).cstTimes -> V[]          
       #);
     regTimes::
       (#
       do 301->trace(#
                    do 'regTimes:' -> display
                    #);
          rReg -> (asComputedVal).regTimes -> V[]          
       #);
     divMod:: 
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:divMod:' -> putline
          if);
          (lV[],isDiv) -> (asComputedVal).divMod -> res[]
       #);
     adrDivMod:: 
       (# 
       do (if not common.switch[188] then
                 '\nOBS! methodCall:adrDivMod:' -> putline 
          if);
          (rA[],isDiv) -> (asComputedVal).adrDivMod -> W[];
       #);
     cstDivMod:: 
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:cstDivMod:' -> putline;
          if);
          (rN,isDiv) -> (asComputedVal).cstDivMod -> V[]
       #);
     regDivMod:: 
       (# 
       do (if not common.switch[188] then
                 '\nOBS! methodCall:regDivMod:' -> putline;
          if);
          (rReg,isDiv) -> (asComputedVal).regDivMod -> W[]
       #);
     orr::<
       (# do (if not common.switch[188] then
                 '\nOBS! methodCall:orr'->putline 
       if)#);
     adrOr::<
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:adrOr'->putline
          if)
       #);
     cstOr::<
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:cstOr'->putline; 
          if);
          this(methodCall)[] -> V[] 
       #);
     regOr::<
       (# do (if not common.switch[188] then
                 '\nOBS! methodCall:regOr'->putline
       if)#);
     andd::< 
       (# do (if not common.switch[188] then
                 '\nOBS! methodCall:andd'->putline
       if)#);
     adrAnd::<
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:adrAnd'->putline
          if)
       #);
     cstAnd::<
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:cstAnd'->putline;
          if);
          this(methodCall)[] -> V[] 
       #);
     regAnd::<
       (# do (if not common.switch[188] then
                 '\nOBS! methodCall:regAnd'->putline
       if)#); 
     rMult:: (# do   this(methodCall)[] -> res[] #);
     asComputedVal:
       (# EH: @evalHandler
       exit (0,false,false,false)->EH.mkComputedEvVal
       #);
     exitValIsReal: booleanValue
       (#
       do (sig.XXsig.elmType = 6) (* real *) -> value
       #);
     thisExitVal:
       (# V: ^evVal
       do (if exitValIsReal then
              mkReal -> V[]
           else
              (if sig.XXsig.isRef then
                  this(methodCall)[] -> V[]; (* not logical, but
                                              * we don't have thisEV
                                              * in the next one below
                                              *)
                  (*(0,false,EV[],chain[]) -> mkComputedRefEvVal -> V[]*)
               else
                  (if sig.XXsig.elmType = 8 (* int64 *) then
                      mch.int64ToInt32
                  if);
                  (0,evType=2,false,false) -> mkComputedEvVal -> V[]
          if) if)
       exit V[]
       #); 

     (* class: ^text*)
     sig: ^theGen.signature;
     chain: ^DH.superChain
  enter(sig[],chain[])
  exit this(methodCall)[]
  #);

EnterArgs: evVal
  (# off: @integer;
     pushNext:
       (# class: ^text;
          A: @mch.RegAdr; T: @text
       enter class[]
       do off+4 -> off -> A.off;
          '!enterArgs:pushNext: '->T; off -> T.putInt; T -> mch.comment;
          'arg_' -> A.fieldName[];
          off -> A.fieldName.putint;
          (if class[] <> none then
              (if ('D' -> class.equal) or ('J' -> class.equal) then
                  class[] -> A.fieldType[];
                  (A[],none) -> mch.ldVal;
                  (if isJava then
                      off+4 -> off -> A.off;
                  if);
               else
                  (A[],class[],none)->mch.loadRef
              if)
           else     
              'I' -> A.fieldType[];
              (A[],none) -> mch.ldVal
          if);
          (if isMultiple then
              (1,0) -> mch.duplicate
          if)
       #);
     evId:: (# do 'EnterArgs:'->id[] #);
     display:: (# T: @text do 'off:'->T; off->T.putint; T[]->xT #);
     pushVal:: 
       (#
       do 301->trace(#do 'pushVal:'->display #);
          (*type should be handled*) pushNext ;
          asComputedVal -> V[]
       #);
     asComputedVal:
       (# EH: @evalHandler
       exit (0,false,false,false)->EH.mkComputedEvVal
       #);
     asgToAdr:: 
       (# 
       do '!enterArgs:asgToAdr:'->mch.comment;
          (if rA.size = 8 then
              'J' -> pushnext
           else
              pushNext; 
          if);
          (none,rA[]) -> mch.stVal;
          asComputedVal -> V[]
       #);
     asgToRealAdr::
       (#
       do 'D' -> pushNext; (none,rA[]) -> mch.stVal 
       #);
     asgToRefAdr::
       (# sourceClassName,destClassName: ^text;
          dDesc: @ASTindex; RC: ^DH.superChain;
          rA,rAx: ^mch.address; destEval,dcl: @ASTindex; 
       do '!EnterArgs:asgToRefAdr:'->mch.comment;
          destEv.son -> destEval;
          (if destEv.label = gram.structureReference then
              sematt.structureDesc -> dDesc;
           else
              (rChain[],destEval) 
                -> DH.theDesc 
                ->(dDesc,RC[]);
          if);
          dDesc[] 
            -> theGen.mkSignature 
            -> sourceClassName[] 
            -> destClassName[];
          (rAbase.copy,destEval[],false,rChain[])->genAdr->rA[];
          sourceClassName[] -> pushNext;
          destEval.dclref -> dcl;
          dcl.gettext -> rA.fieldName[];
          &mch.RegAdr[] -> rAx[];
          (rAx[],false,sourceClassName[],destClassName[])
            -> rA.asgRefAdr       
       #);
     asgToRepAdr::
       (# sourceClassName,destClassName: ^text
       do '!EnterArgs:asgToRepAdr' -> mch.comment;
          (if true then
              rA.fieldType[] 
                -> sourceClassName[] 
                -> destClassName[]
                -> pushNext; 
           else
              '[C' -> pushNext; 
              '[C' -> sourceClassName[] -> destClassName[];
          if);
          (&mch.RegAdr[],false,sourceClassName[],destClassName[])
            -> rA.asgRefAdr
       #);
     (*  insert::
      (#
      do '!enterArgs:insert:'->mch.comment;
      #);*)
     asgToItem::
       (# sig: @theGen.Signature;
          basicname,knownName: ^text
       do '!enterArgs:asgToItem:'->mch.comment;
          301->trace(#
                    do 'enterArgs:asgToItem:'->xT;
                       rDesc[] -> xA; xN;
                       'rA:'->xT; rA.display->xT; xN
                    #);
          true->rA.isRef;
          (rDesc[],true) -> descName -> basicName[] -> knownName[]; (* FIX possible virtual *)
          (if not rA.noTmp then
              (rA[],basicName[],none)->mch.loadRef; (* dup should be used *)
              true -> rA.noTmp;
              (0,0) -> mch.duplicate; (* for execution of do-method *)
          if);
          (rDesc[],rChain[],false(*?*)) -> sig.setMethodDesc;
          rDesc[] -> sig.addEnter;
          sig.exitVoid;
          common.enterMethod -> sig.addMethod;  

          sig.scanEnter
          (# 
          do (if isRef then
                 'someClassOrArry' -> pushNext 
              else
                 pushNext
             if)
          #);
       #);
     asgToMethod::
       (#
       do 301->trace(#
                    do 'asgToMethod:'->display;
                       (for i: noOfArgs repeat
                            enterTypes[next] -> xI
                       for)
                    #);
          (for i: noOfArgs repeat
               (if enterTypes[next] 
                // 11 // 12 // 13 // 14 then
                   'SomeClass' -> pushNext
                // 6 (* real/double *) // 7 (* real32 *) then
                   'D' -> pushNext 
                // 8 (* long=int64*) then
                   'J' -> pushNext
                else
                   pushNext 
               if);
               next + 1 -> next
          for);
          (* OBS. check that moved 'inner' in mkByteCodeCall is OK
           * We need the descriptor - it may be singular -
           * it must be called as a a method; i.e. 
           * treated like an inner pattern with method-version
           * and new-version
           *)
          next + noOfArgs -> next 
       #);
     asgToList::
       (# 
       do EV -> scanList
          (# E: @ASTindex
          do currentNode -> E;
             (BA[],this(enterArgs)[],E[],false,rChain[]) 
               -> AssignValToEval 
               -> V[];             
          #);
          (EV[],BA[],rChain[]) -> mkListVal -> V[]
       #);
     init:
       (#
       do 8 -> off
       #);
  exit this(enterArgs)[]
  #);
ExitMultiVal: evVal
  (# evId:: (# do 'ExitMultiVal:'->id[] #);
     display:: 
       (#
       do 'exitNo:'->xT; exitNo->xI; 'elmDesc:'->xT; elmDesc[]->xAF
       #);          
     asgToAdr::
       (# A: @mch.RegAdr;
       do 301->trace(#
                    do 'asgToAdr:'->display
                    #);
          (if tA[] = none then
              '\OBS! exitMultiVal:tA is none' -> putline;
              12 -> A.off;
              true -> A.isRef;
              (A[],&mch.adrRegOperand[]) -> mch.ldVal;
           else
              (tA[],&mch.adrRegOperand[]) -> mch.ldVal;
          if);
          (mkA,&mch.dataRegOperand[]) -> mch.ldVal;          
          true -> rA.isField;
          (&mch.dataRegOperand[],rA[]) -> mch.stVal;
       #);
     asgToRealAdr::
       (#
       do 301->trace(#
                    do 'asgToRealAdr'->display;
                    #);
          (tA[],&mch.adrRegOperand[]) -> mch.ldVal;
          (mkA,&mch.dataRegOperand[]) -> mch.ldVal;
          true -> rA.isField;
          (&mch.dataRegOperand[],rA[]) -> mch.stVal;          
       #);
     asgToRefAdr::
       (# A: @mch.RegAdr; aS,rA: ^mch.address; 
          destClass: ^text; withQua: @boolean;
       do 301->trace(#
                    do 'asgToRefAdr'->display;
                    #);          
          (rAbase.copy,destEv.sonRef,false,rChain[])->genAdr->rA[];
          (tA[],&mch.adrRegOperand[]) -> mch.ldVal;
          (mkA->aS[],&mch.adrRegOperand[]) -> mch.ldVal; 
          (*rAbase.copy -> rA[];*)
          
          true -> rA.isField;  
          true -> rA.isRef;
          (if destEv.label=gram.structureReference then
              (theGen.StructureSignatureId->theGen.specialSignature).asText 
                -> destClass[]
           else
              rA.bAdr.localDesc[] 
                -> theGen.mkSignature -> rA.fieldType[] -> destClass[];
          if);
          (if (destClass[] <> none) and (aS.fieldType[] <> none) then
              not (destClass[] -> aS.fieldType.equal) -> withQua;
           else
              '\nOBS! destClass[]=none) or (aS.fieldType[]=none)'
                -> putline
          if);
          (&mch.adrRegOperand[],withQua,'???',destClass[])
            -> rA.asgRefReg
       #);
     asgToRepAdr::
       (#
       do 301->trace(#
                    do 'astToRepAdr:'->display;                       
                    #);
          (tA[],&mch.adrRegOperand[]) -> mch.ldVal;
          (mkA,&mch.dataRegOperand[]) -> mch.ldVal;
          true -> rA.isField;
          (&mch.dataRegOperand[],rA[]) -> mch.stVal;
       #);
     asgToItem::
       (# EH: @EvalHandler;
          nScan: @ | EH.scanNadr; more: @boolean;
          A: @mch.RegAdr;
       do 301->trace(#
                    do 'asgToItem'->display;
                    #);
          (rDesc[],rA[],0,rChain[],true) 
               -> nScan -> more;
             L:
            (if more then
                (tA[],&mch.adrRegOperand[]) -> mch.ldVal;
                (mkA,&mch.dataRegOperand[]) -> mch.ldVal;
                nScan -> more;
                restart L
            if) 
       #);
     asgToList::
       (#
       do 301->trace(#
                    do 'asgToList'->display;
                    #);
          EV -> scanList
          (# E: @ASTindex
          do currentNode -> E;
             (BA[],this(exitMultiVal)[],E[],false,rChain[]) 
               -> AssignValToEval 
               -> V[];             
          #);
          (EV[],BA[],rChain[]) -> mkListVal -> V[]
       #);
     mkA: 
       (# T: @text; aD: @mch.RegAdr 
       do (*'XA:exitMultiVal:mkA:'->puttext;*)
          'exit_' -> T;
          exitNo -> T.putint;
          exitno + 1 -> exitNo;
          T[] -> aD.fieldName[];
          class[] -> aD.receiverType[];

          (if (elmDesc[] = none) or (elmDesc.isNull) then
              '\nOBS!ExitMultiVal: ElmDesc is none or null'->putline;
              (if common.switch[311] then
                  (failureTrace,'ExitMultiVal: ElmDesc is none or null')
                    -> stop;
              if);
              sematt.integerDesc[] -> theGen.mkSignature -> aD.fieldType[]
           else
              (if elmDesc.label <> gram.objectDescriptor then
                  '\nOBS!ExitMultiVal: ElmDesc is not descriptor'->putline
               else
                  (if isRep then
                      elmDesc[] -> theGen.mkArraySignature -> aD.fieldType[]
                   else
                      elmDesc[] -> theGen.mkSignature -> aD.fieldType[];
                  if)
          if)if);
          (*aD.fieldType[] -> puttext; ',' -> put;*)
          true -> aD.isField
       exit aD[]
       #);
     xA: @text;
     class: ^text;
     tA: ^mch.address; (* address tmp-var for object *)
     exitNo: @integer;
     elmDesc: ^ASTindex;
     isrep: @boolean
  enter exitNo
  exit this(ExitMultiVal)[]
  #);
getDclName:
  (# VN: ^ASTindex; N: @ASTindex; T: ^text
  enter VN[]
  do VN -> N;
     L:
       (if N.label
        // gram.nameApl then
           N.dclref -> N;
           N.gettext -> T[]
        // gram.remote then
           N.son -> N; N.brother -> N;
           restart L
        else
           '\ngetDclName: case not covered ' ->putline
       if)
  exit T[]
  #);
findReceiver:
  (# EV,rD,mD: ^ASTindex; (* EV = (remote <R> <foo>) 
                           * rD = possible receiver desc
                           * mD = methodDesc 
                           *)
     D: @ASTindex;
     R: ^ASTindex;
     descKind: @integer
  enter(EV[],rD[],mD[])
  do L:
       (if EV.label 
      // gram.remote then
         EV.sonRef -> R[];
         (thisDesc[],R[]) 
           -> GetActualDesc 
           -> (D,descKind);
         301->trace(#
                 do 'findReceiver:' -> xT; R[] -> xA; xN;
                    D[] -> xA; xN; rD[] -> xA
                 #); 
         (if R.label = gram.thisObject then
             (* is this always correct?*)
             D[] ->rD[]
          else
             (if not (D->rD.equal) then
                 D -> sematt.descChain
                 (* scan super patterns *)
                 (#
                 do (if desc->rD.equal then
                        (if not common.switch[188] then
                            'Receiver: Got it'->putline;
                        if);
                        D[] -> rD[];
                        leave L
                    if)
                 #);
                 (* no match??? *)
                 D[] -> rD[]
         if)if)
      // gram.nameApl then
         (* added to handle call from gram.virtual case *)
         EV.dclRef -> D;
         D.sort -> D;
         (if D.label
          // gram.virtualDecl
          // gram.bindingDecl
          // gram.finalDecl then
             (*1->trace(#do 'findReceiver: ' -> xT; D[] -> xA #);*)
             D[] -> sematt.EncDescOfNode -> R[]
          else
             (*1->trace(#
                     do 'findReceiver:case not covered:  ' -> xT; D[] -> xA
                     #);*)
             D[] -> sematt.EncDescOfNode -> R[]
         if);
         (if not (R->rD.equal) then
             rD -> sematt.descChain
             (#
             do (if desc->R.equal then
                   (* 1->trace(#
                            do 'finReceiver:gotIt: ' -> xT;
                               rD[] -> xA
                            #);*)
         if)#)if);
         (* so basically we just check consistency of enter arg rD
          * which should be the receiver - so we may skip this
          * call
          *)
      // gram.thisObject then
         '\nfindReceiver:ThisObject'->puttext
     if)
  exit rD[]
  #);

mkByteCodeCall: 
  (* incredibly ugly - FIXME *)
  (# EV: @ASTindex;
     OA: ^mch.address; 
     descId,class: ^text;
     descNo: @integer; local: @boolean;
     VN,receiver,method,finalMethod: @ASTindex;
     receiverDesc: ^ASTindex;
     W: ^evVal;
     sigTxt: ^text;
     sig: @theGen.Signature;
     descKind: @integer;
     isStatic,isRealStatic,isSingular,isFinal,isRemote,isVirtual
     ,isCons
     ,isVarPtn
     ,hasArguments       (* true : if arguments to EV: A -> EV 
                          * false: if no arguments: ;EV;
                          *)
     ,hasExit: @boolean; (* true : if a the return value is used
                          * false: if not; then a possible return
                          *        value should be popped
                          *)
     theThisDesc: @ASTindex; (* aliasing:-(*)
     chain: ^DH.superChain;
     A: ^mch.address
  enter(EV,hasArguments,hasExit,chain[])
  do EV.son -> VN;
     '!mkByteCodeCall:'->mch.comment;
     301->trace(# 
               do 'mkBytecodeCall: ' -> xT; EV[] -> xA; VN[] -> xA;
                  EV.sonRef -> xA
               #);
     thisDesc -> theThisDesc;
     (if VN.label = gram.objectDescriptor then
         (* make sure that innerdesc.getID is defined *)
         (VN,common.itemKind,2,null)->DS.push;
     if);
          (EV.sonRef,chain[],true) -> sig.setMethodDesc; 
     &ASTindex[] -> receiverDesc[]; 
     301->trace(# do 'mkBytecodeCall:label:'->xT;
                  VN.label -> xI
               #);
     (if VN.label 
      // gram.remote then
         (# md: @ASTindex; mdo: ^ASTindex
         do (* VN = R.foo *) 
            VN.son -> receiver;
            receiver.brother -> method;
            (if receiver.label = gram.thisObject then
                301->trace(#
                          do 'mkByteCodecall.this(foo).m:receiver: '->xT;
                             receiver[] -> xA
                          #)
             else
                (* OBS receiver is NOT used anymore *)
                receiver -> sematt.getName -> receiver; 
                (* receiver = R, method = foo *)  
                (* NOTE! below is an alternative - and correct - method
                 * for computing the desc of the receiver; we just use
                 * the origin of the method desc. In most cases this is the
                 * same as above, but for virtual methods bound to global
                 * patterns, this is not the same; the above code should
                 * be removed
                 *)
            if);
            (* EV = R.foo 
             * NOTE: EV is reference or similar, and then
             *       EV.sonRef = (remote <R> <foo> )
             *)
            301->trace(#
                      do 'mkBytecodecall:remote:'->xT; 
                         EV[] -> xA;
                         ' sonRef: '->xT; EV.sonRef -> xA
                      #);
            (thisDesc[],EV.sonRef) 
              -> GetActualDesc 
              -> (md,descKind);
            301->trace(#
                      do 'mkBytCodeCall: ' -> xT; md[] -> xA
                      #);
            (* Problem with
             *   T: (# foo: (# ... #) #)
             *   TT: T(# #);
             *   R: ^TT
             *   R.foo
             * method:  (# ... #) i.e. desc of foo
             * receiver: origin(method) = T
             * it should be TT
             *   T: (# V:< A #);
             *   TT: T(# V:: AA #);
             *   TTT: TT (# #)
             *   S1: ^TT;
             *   S2: ^TTT
             *   S1.V;  - is reciever origin of AA or the most specific
             *   S2.V   - subpattern of origin of AA? 
             *            then it is complicated
             *)
            md[] -> sematt.descOrigin -> mdo[];
            301->trace(#
                    do 'mkByteCall:remote:mdo:'->xH; mdo[] -> xA; xN;
                       md[] -> xA
                    #);
            (EV.sonRef,mdo[],md[]) -> findReceiver -> mdo[];
            mdo -> receiverDesc;
            true -> isRemote;
            (if true then
                (* compute receiver as actual desc of R in R.foo 
                 * previously we could not do this for virtuals
                 * bound to global patterns???
                 *)
                
            if);
            (if (md->sematt.descKind) 
             // sematt.staticProcKind then
                (if not common.switch[188] then
                    'staticCall'->putline;
                if);
                true -> isRealStatic;
                sig.markRealStatic; (* isStatic is used for
                                     * patterns at outermost levels
                                     * in lib-files
                                     *)
             // sematt.consKind then
                301->trace(#
                        do 'mkByteCodeCall:cons: '->xT;
                           'methodDesc: ' -> xT; md[] -> xA; xN;
                           'receiverDesc: '->xT; receiverDesc[] -> xA;
                        #);
                (* Create instance of: receiverDesc
                 * with constructor  : methodDesc
                 *)
                true -> isCons;
                md -> method
            if);
            301 -> trace(# 
                        do 'mkByteCodeCall:remote:2: ' -> xH;
                           'methodDesc: ' -> xT; md[] -> xA; xN;
                           'receiverDesc: '->xT; receiverDesc[] -> xA;
                        #)
         #)
      // gram.nameApl then
         (* VN = foo 
          * means: originN....origin2.origin1.foo
          * N >= 0
          *)
         VN -> method;
         testLibLevel: (* is this a pattern at the outermost
                        * lib level*)
           (# org: @ASTindex
           do sig.thisMethodDesc.origin -> org;
              (* dont work if virtual?*)
              (if org.label
               // gram.attributesForm then
                  301->trace(#
                            do 'Pattern: ' -> xT;
                               VN[] -> xA;
                               ' is at the outermost lib level' -> xT
                            #);
                  'invoke static ' -> mch.comment;
                  true -> isStatic;
               else
                  (* to find originN, go origin meth.N times *)
                  thisDesc -> receiverDesc;
                  (for i: method.on repeat
                       receiverDesc[] -> sematt.descOrigin -> receiverDesc[]
                  for);
                  (if false then
                      (* ok for calling V declared as V:: T
                       * not ok for     V declared as V:< T
                       *)
                  (# md: @AStindex; mdo: ^AStindex
                  do (thisDesc[],EV.sonRef) 
                       -> GetActualDesc 
                       -> (md,descKind);
                     md[] -> sematt.descOrigin -> mdo[];
                     mdo -> receiverDesc;                  
                  #)if)
              if);
           #)
      // gram.objectDescriptor then
        301->trace(#
                   do 'objectdescriptor: ' -> xT;
                      VN[] -> xA;
                   #);
         VN -> method; (* NOTE: VN IS AN OBJECTDESCRIPTOR *)
         method -> receiverDesc;
         (* Here we need to find the right origin of the method *)
         (if true then
             receiverDesc[] -> sematt.descOrigin -> receiverDesc[];
             (if receiverDesc.label 
              // gram.descriptorForm (*then
                 receiverdesc.xorigin -> receiverdesc;*)
              // gram.doPart then
                 receiverdesc.xorigin -> receiverdesc;
                 receiverdesc.slotOrigin -> receiverdesc;
             if)
          else
             receiverDesc.origin -> receiverDesc;
         if);
         (* (receiverDesc[],screen[],500) -> thePP;*)
         true -> isSingular;
         (*(VN,common.itemKind,2,null)->DS.push;*)
         301->trace(# do 'mkBytecodeCall3: VN:' -> xT; VN[] -> xA #);
      // gram.unExpanded then
         301->trace(#
                   do 'MkByteCodeCall:DescriptorSlot: ' -> xT; VN[] -> xA 
                   #);
         VN[] -> sematt.enclosingDesc -> receiverDesc[];
                      
         receiverDesc[] -> theGen.descLocation -> sig.location[];
         301->trace(#
                   do 'mkByteCodeCall:unExpanded:receiverLocation: "' -> xT;
                      (if sig.location[] = none then 
                          'none' -> xT
                       else 
                          sig.location[] -> xT
                      if);
                      '"' -> put
                   #);
         VN -> method;
         (VN,common.itemKind,3,VN) -> DS.push;
         true -> isSingular (* hack *)
      // gram.computedRemote then
         (# MN,isVirt: @integer; xchain: ^DH.superChain;
            remEv,N,ref,refDesc: ^ASTindex;
         (* (E).method 
          * DOES NOT WORK
          *)
         do VN.son -> receiver;
            receiver.brother -> method;
            L: receiver->scanList(#do currentNode->receiver; leave L #);
            (if true then
                301->trace(#
                          do 'mkByteCodeCallX: ' -> xT;
                             VN[] -> xA
                          #);
                (VN[],DH[],chain[]) 
                  -> sematt.chkComputedEval 
                  -> (remEv[],N[],ref[],receiverDesc[],xchain[]);
                301->trace(#
                          do 'mkByteCodeCallY: ' -> xT;
                             receiverDesc[] -> xA
                          #);
                
             else
                (chain[],(receiver.sonRef).son)  
                  -> DH.theDescForm 
                  -> (receiverDesc,MN,xchain[],isVirt);
            if)
         #)
      else
         '\n**** insert is NOT remote or nameApl'->putline
     if);
     (if isCons then
         301->trace(#
                 do 'cons: ' -> xT; receiverdesc[]->xA #);
         (receiverDesc[],common.itemKind) -> theGen.newInstance
         (# 
         do mch.nop;
            (method[],false,chain[]) -> consSig.addConstructorDesc;
(*            1->trace(#do 'X:'->xT; conssig.astext->xT #);*)
            false -> sig.isStatic;
            'olsen' -> sig.addMethod;
            method[] -> sig.addEnter;
            sig.setVoidXSig; 
            (*1->trace(#do sig.astext -> xT #);*)
            ((receiverDesc[],true) -> descName,receiverDesc[]) 
              -> sig.addReceiver;
            INNER MkByteCodeCall
         #);
         (mch.thisRegOp,false,EV[],chain[]) -> mkComputedRefEvVal -> W[]
      else
     (if not isStatic then
         ('G',receiverDesc[]) -> mkEntryPoint -> (class[],local);
         301->trace(#
                   do 'mkByteCodeCall:receiver: ' -> xT; class[] -> xT; xN;
                      receiverDesc[] -> xA
                   #);
         (class[],receiverDesc[]) -> sig.addReceiver;
     if);
     L:
     (if not isSingular then
         method.dclRef -> finalMethod;
         finalMethod.sort -> finalMethod;
         301 -> trace(#
                     do 'mkBytecodeCall:method.dclRef: ' -> xT;
                        finalMethod[] -> xA
                     #);

         (if finalMethod.label = gram.finalDecl then
             true -> isFinal;
             method.dclRef -> finalMethod;
             (if not isRemote then
                 (# md: @AStindex; mdo: ^AStindex
                 do (thisDesc[],EV.sonRef) 
                      -> GetActualDesc 
                      -> (md,descKind);
                    md[] -> sematt.descOrigin -> mdo[];
                    mdo -> receiverDesc;                  
                    ((receiverDesc[],true) -> descName,receiverDesc[]) 
                      -> sig.addReceiver
         #)if)if);         
         method.descRef -> method;
         301 -> trace(#
                     do 'mkBytecodeCall:method.descref: ' -> xT;
                        method[] -> xA
                     #);
         LL: 
           (if method.label 
            // gram.objectDescriptor 
            // gram.unExpanded then
               method -> receiverDesc
            // gram.finalDecl then (** ??? **)'FINAL'->putline;
            // gram.bindingDecl then

               method.son -> method;
               L:
                 method -> scanList
               (# do currentNode -> method; leave L #);
               method.virtDcl -> method;
               method.sort -> method;
               restart LL
               
            // gram.virtualDecl then
               method.son -> method;
               method.brother -> method; (* assume desc here *)
               false -> isStatic; (* V:< T never be in an attributes form *)
               true -> isVirtual;
               (* perhaps we should explicitly set the receiver? *)
               (if (EV.sonRef).label = gram.nameApl then
                   (* are we sure the other cases are covered? *)
                   (*1->trace(#
                           do 'mkByteCodeCall:virtual: ' -> xT; EV[] -> xA; 
                              ' on:'->xT; (EV.sonRef).on -> xI; xN;
                              thisDesc[] -> xA
                    #);*)
                   thisDesc -> receiverDesc;
                   (for i: (EV.sonRef).on repeat 
                        receiverDesc[] -> sematt.DescOrigin -> receiverDesc[]
                   for);
                   (EV.sonRef,receiverDesc[],none) 
                     -> findReceiver -> receiverDesc[];
                   ((receiverDesc[],true)->descName,receiverDesc[]) 
                     -> sig.addReceiver;
               if)
            // gram.variablePattern then
               (* R: (# F: ##T
                *    do ... F
                * receiverDesc: R
                * methodName  : F
                * methodDesc  : T
                *)
               301->trace(#
                         do 'mkByteCodeCall:varPtn: ' -> xT;
                            EV[] -> xA;
                         #);
               true -> isVarPtn;
               false -> isStatic;
               method[] -> sematt.EncDescOfNode -> receiverDesc[];
               ((receiverDesc[],true)->descName,receiverDesc[]) 
                 -> sig.addReceiver;
               sig.thisMethodDesc -> method;
               301->trace(#
                         do 'mkByteCodeCall:varPtn:X: ' -> xH;
                            'receiver: '->xT; receiverDesc[] -> xA; xN;
                            'methodName: ' -> xT; VN.gettext -> xT; xN;
                            'methodDesc: ' -> xT; method[]->xA
                         #);
           if);
         301 -> trace(# 
                     do 'call2:receiver:'->xH;
                        receiverDesc[] -> xA; xN; 
                        'method: '->xT; method[] -> xA; 
                     #);
2         
     if);

     (if isStatic then
         ((method[],true) -> descName,method[]) -> sig.addReceiver;
         sig.markStatic
     if);
     (* set the name of the method *)
     (if isVarPtn then
         VN.gettext -> sig.addMethod;
      else 
         (if (sig.thisMethodDesc -> sematt.descKind) = sematt.procKind then
             method[]  -> theGen.getExternalClassName -> sig.addMethod
          else
             (*1->trace(#do 'addMethod: ' -> xT; method[] -> xA; xN;
                        'VN: ' -> xT; VN[] -> xA;
                        'VN.text: ' -> xT; VN[] -> getDclName -> xT
                     #);*)
             (if isFinal and isRemote then
                 VN[] -> getDclName -> sig.addMethod 
              else
                 (method[],false) -> descName -> sig.addMethod
             if)
         if)
     if);
     (* the following should be generalised? *)
     (if method.isSlot then
         sig.noEnter
      else
         method[] -> sig.addEnter
     if);
     
     (if method.isSlot then
         sig.setVoidXSig
      else
         (# p,mp,att,n,doP,exitP,EV: ^ASTindex; S: ^text
         do sig.thisMethodDesc[] (* descriptor for method *)
              -> sematt.descSonsRef
              -> (p[],mp[],att[],n[],doP[],exitP[]);
        
            (if exitP[] <> none then
                exitP[] -> sig.addExit
             else
                sig.setVoidXSig
            if)
     #)if);
     sig.asText -> class[];
     301 ->trace(#do 'class: ' -> xT;  class[] -> xT #);
     (if not hasArguments 
         and (((sig.NNsig.top > 0) and not isStatic)
              or ((sig.NNsig.top > 1) and isStatic)) then
         (* is receiverDesc the right originDesc here?
          * is it ok with topDesc = none
          *)
         (# xD: @ASTindex; ba: ^mch.address;
            oldReturnSaved,oldInNDX: @boolean;
            mDesc: ^ASTindex;
         do thisDesc->xD;
            theThisDesc -> thisDesc;
            baseAdr.copy -> ba[];
            inEnterDoExitMethod -> oldInNDX;
            theGen.returnSaved -> oldReturnSaved;            
            (* instead of this clumsy save of global state,
             * we should make a new instance of theGen
             *)
            301 ->trace(#
                       do 'mkByteCodeCall:inlineMethod1:'->xT;
                        method[] -> xA; 
                        ' VN: ' -> xT; VN[] -> xA;
                        ' on: ' -> xT; VN.on -> xI;
                        xN;
                        'thisDesc: ' -> xT;
                        thisDesc[] -> xA; xN;
                        'theThisDesc: '->xT; 
                        theThisDesc[] -> xA; xN;
                        'baseAdr.bAdr.localDesc: ' -> xT;
                        baseAdr.bAdr.localDesc[] -> xA; xN;
                        baseadr.display->xT; 
                      #);
            (if isVirtual then
                301->trace(#do 'Virtual:genPtnMethod: '->xT; method[]->xA #);
                method[] -> mDesc[];
             else
                sig.thisMethodDesc[] -> mDesc[]
            if);
            ('inline$',mDesc[]
            ,false,false,receiverDesc[],none(*?*)
            ,true,false,true)
              -> theGen.genPtnMethod
            (# 
            do xD -> thisDesc;
               (baseAdr.copy,theThisDesc[],VN[],EHchain[])
                 -> genOrgAdrToOrgReg
                 -> OA[];
               xD -> thisDesc;
               ba[] -> baseAdr[];
            #);
            xD -> thisDesc;
            ba[] -> baseAdr[];
            oldInNDX -> inEnterDoExitMethod;
            301 ->trace(#
                       do 'mkByteCodeCall:inlineMethod2:'->xT; 
                          method[]->xA; xN;
                          baseAdr.bAdr.localDesc[] -> xA; xN;
                          baseadr.display->xT; xN;
                          thisDesc[] -> xA
                       #);
            (if thisDesc.label = gram.doPart then
                (* we should probably always do this *)
                theRealDesc[] -> theGen.InitGen
                (#
                do &ASTindex[] -> doP[]; 
                   thisDesc.son -> doP;                 
                   doP[] -> setDoP
                #);
                (theRealDesc[],true) -> theGen.initPtnGen;
                xD -> thisDesc; (* is overwritten by initPtnGen *)
                301->trace(#
                          do 'mkByteCodeCall:inlineMethod2:'->xT; 
                             'TheRealDesc: ' -> xT; theRealDesc[] -> xA; xN;
                             'FormDesc: ' -> xT; FormDesc[] -> xA; xN;
                             'ThisDesc: ' -> xT; thisDesc[] -> xA; xN;
                          #);
                
                
             else 
                (thisDesc[],false) -> theGen.initPtnGen
            if);
            oldReturnSaved -> theGen.returnSaved; (* is set to false
                                                   * in initPtnGen
                                                   *)
         #)
      else
         (if isFinal and isRemote then
             (baseAdr.copy,VN.sonRef,false,EHchain[])->genAdr->OA[];
             (OA[],mch.adrTop[]) -> mch.ldVal
          else
             (baseAdr.copy,theThisDesc[],VN[],EHchain[])
               -> genOrgAdrToOrgReg
               -> OA[];
         if);
         INNER;         
         (class[]->mch.newTextOp,'M',local,isStatic or isRealStatic)
           -> mch.gJsr;  
     if);
     (if not hasExit and (sig.XXsig.elmType <> 10 (*void*)) then
         (if sig.XXsig.elmType = 6 (* real/double *) then
             true -> mch.popStack
          else
             mch.popStack
     if)if);
     301->trace(#
             do 'mkByteCode:end: '->xT; sig.asText -> xT; sig.thischain
             #);
         (sig[],sig.thisChain[]) -> methodCall -> W[]
     if);
  exit W[]
  #)
