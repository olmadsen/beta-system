ORIGIN 'genlib';
LIB_ITEM 'betacodegen';
INCLUDE 'storeReg';
INCLUDE 'asgtoitem'
(*********************************************************************
 * See the file DOC/Com.html for status of current COM implementation
 *********************************************************************
 *)
---genCom:descriptor---
(#  
do (if stest then 
       301 ->trace(#Do 'Generating code for COM-object:'-> xT #)
   if);
   (sematt.comKind,inForm) -> GenObj;
#)
---genComVirtual:descriptor---
(# R: ^ProtoType; hasAcode: @boolean; N: @AStindex;
   objKind: @integer;
   objKind2: @integer;
   isComVirtual: @boolean;
   RL: ^RepList
do 301->trace(#do 'Generating code for Com-Virtual:'->xT #);

   &ProtoType[]->R[];
   ProtoHead[]->R.succ[];
   R[]->GS.thisPT[]->Protohead[];
   sematt.externalVirtualKind -> R.objKind;

   (thisFormName[],thisForm[],thisDescNo,theFormIndex
   ,thisDesc.nodeId
   ,ThisDesc.size,hasAcode
   ,objKind2)
     -> gen.BeginAlloc;
   
   (('T',thisDescNo,thisForm[],true) -> gen.SysLab,0,false)
     ->  mch.AllocObj;
   
   (if not ReturnSaved then
       (*(true,thisDesc.returnOff)->mch.SaveReturn;*)
       true -> ReturnSaved
   if);

   (* do NOT generate normal return 
    * Transfer arguments to object
    * May be proto should not be in %i1 and
    * may be we should call G direcly a la V-entry,
    * i.e. NO AlloCom
    *)
   (# nCOMargs,dataByValueByteSize: @integer
   do scanComArgs
      (#
      do (if switch181 then
             arg[] -> nScan.asgToComNelm
          else
             arg[] -> nScan.asgToNelm
         if)
      #)
        -> (nCOMargs,dataByValueByteSize,RL[]);   
      (pref,common.itemKind)->PrefixAlloc;
      (att,0,RL[])->GenAlloc;
   #);
   (# topD: @AStindex; ep: ^text; descNo: @integer; local: @boolean
   do (if hasPref then
          (if stest then
              301->trace(#do 'ThisPreDesc: '->xT; thisPrefDesc[] -> xA #)
          if);
          thisPrefDesc -> sematt.TopDesc -> topD;
          ('M',topD[]) -> mkEntryPoint -> (ep[],local);
          (if local then
              ep -> mch.jmpT
           else
              (ep,NONE) -> mch.jmpTLong
          if)
      if);
      (if (thisDescNo = 1) or (ThisDesc[]->Sematt.hasDo) then
          (if not (ThisDesc[]->sematt.hasOnlyInner) then
              (if not doP.isSlot then 
                  (0,NONE,NONE,false,true,none,none) -> GenDo
               else
                  ('M',thisDesc[]) -> mkEntryPoint -> (ep[],local);
                  (if local then
                      ep -> mch.jmpT
                   else
                      (ep,NONE) -> mch.jmpTLong
              if)if);
          if)
      if);
   #);
   
   (pref[],att[])->BindVirtuals;
   (nameId[],singular)->genSymbTable
#)
---ScanCOMargs:descriptor---
(# more: @boolean;
   paramNo,dataInc,size: @integer;
   nD: ^sematt.AttDesc;   
do (thisDesc[],gen.thisRegAdr,0,ThisSuperChain,true) -> nScan -> more;
   1 -> paramNo;
   0 -> holders.top -> dataByValueByteSize;
   L: (if more then
          mch.releaseReg;
          0 -> dataInc;
          nScan.thisEv[] -> sematt.AttDesc -> nD[];
          (if stest then
              311->ctrace(#do 'COMvirtual:TransferEnter: '->xT; nD.display#)
          if);
          (* the imp: not nD.isRep -> isValPar 
           * was previously made for standardKind and holderKind
           * WHY?
           *)          
          (if nD.kind
           // sematt.standardKind then
              (if nD.isRep then
                  (* are we sure that this is always a char rep?
                   * Should probably be checked
                   *)
                  (if nD.desc.size
                   // 1 then 
                      (paramNo,false) -> EH.CharRepArg -> arg[];     
                   // 2 then
                      (paramNo,true) -> EH.CharRepArg -> arg[];
                   else
                      'COMvirtual:repetition argument is not char or wchar'
                        -> thisTranslate.systemException
                  if);
                  
                  nD.dcl[] -> RL.insert   
               else
                  paramNo -> EH.ValueArg -> arg[];                  
              if);                            
           // sematt.holderKind then
              (paramNo,true) -> EH.RefArg -> arg[];
              (* perhaps we should save dcl *)
              (if nD.isRep then
                  'COMvirtual:holderRepetition:'
                    -> thisTranslate.systemException
              if);
              nD.apl[] -> holders.insert
           // sematt.dataKind then
              (if nD.spec.label 
               // gram.dynamicItem then
                  (paramNo,true) -> EH.RefArg -> arg[]
               // gram.staticItem then
                  (* Note: dataByValueByteSize is the extra no. of bytes
                   * used to pass a caLl-by-value-data(struct). 
                   * The compiler counts the number of arguments and 
                   * for each argument 4 bytes are assumed to be allocated
                   * on the stack.
                   * For a value-struct we therefore subtract 4 bytes
                   * from the size, since these 4 bytes are added 
                   * from the counting of arguments
                   *)
                  (nD.desc.size-4) -> dataInc;
                  dataByValueByteSize +  dataInc
                    -> dataByValueByteSize;
                  paramNo -> EH.DataArg -> arg[]
               else
                  'COMvirtual:dataPattern:inconsistencies'
                    -> thisTranslate.systemException
              if);
           // sematt.comKind
           // sematt.dispatchKind then
              (if nD.spec.label = gram.dynamicItem then
                  (paramNo,false) -> EH.RefArg -> arg[];
               else
                  'COMvirtual:generalPattern:inconsistencies'
                    -> thisTranslate.systemException
              if);
           else
              'COMvirtual:missing enter kind'->thisTranslate.systemException
          if);
          INNER ScanCOMargs;
          (* note that paramNo is not really the 'parameter number',
           * but the address of the stack of the parameter. This change
           * is to handle data-objects by-value.
           * Currently this works on Intel, but may not work on
           * other platforms
           *)
          paramNo + 1 + (dataInc div 4) -> paramNo;
          nScan -> more;
          restart L
      if);
   paramNo -> noOfCOMargs; (* including object/origin *)
#)
---evalLib:attributes---
(* we should make more EvVals corresponding to the possible
 * COM argument/external argument types and clean-up the
 * code in the BETA internal evvals
 *)
COMarg: EvVal
  (# loadVal:: (# do this(COMarg)[] -> V[] #);
     paramNo: @integer
  enter paramNo
  exit this(COMarg)[]
  #);
ValueArg: COMarg
  (# evId:: (# do 'ValueArg:'->id[] #);
     asgToAdr::<
       (# IR: ^mch.registerOperand
       do (paramNo,true) -> mch.GetComPar -> IR[];
          (if rA.size
           // 1 then (IR[],rA[])->mch.stByte
           // 2 then (IR[],rA[])->mch.stHalf
           // 4 then (IR[],rA[])->mch.stVal
           else
          if);  
          IR[] -> mch.gClr; (* perhaps not necessary *)
          rA.freeAdr
       #)
  #);
RefArg: COMarg
  (# evId:: (# do 'RefArg:'->id[] #);
     asgToAdr::<
       (#
       do 'RefArg:asgToAdr'->thisTranslate.systemException
       #);
     asgToRefAdr::<
       (# EV: @ASTindex; rA: ^mch.address; 
          IR: ^mch.registerOperand
       do (if stest then
              311->trace(#do 'RefArg:asgToRefAdr: '->xT; destEV[] -> xA#)
          if);
          (paramNo,isComRef) -> mch.GetComPar -> IR[];
          destEV.son -> EV;
          (EV[],false,rAbase[],IR[],paramNo,rChain[]) -> storeRegRef -> rA[];
          rA.freeAdr; 
          this(RefArg)[] -> V[]
       #);
     isCOMref: @boolean; (* false: argument is a COM ref argument;
                          * true: argument is e.g. a ref-to-int
                          *)
  enter isCOMref
  #);
CharRepArg: COMarg
  (# asgToRepAdr::<
       (# IR: ^mch.registerOperand
       do (if stest then
              311->trace(#do 'CharRepVal:asgToRepAdr:'->xT #)
          if);
          (paramNo,false) -> mch.getComPar -> IR[];
          3 -> mch.initPrimCall;
          (*common.switch[61] -> old61; true->common.switch[61];*)
          (if common.isIntel then
              IR[] -> mch.push; (*1 -> thisReg.toPrimDest;*)
           else
              IR[] -> mch.pushAdr; (*1 -> thisReg.toPrimDest;*)
          if);
          2 -> rA.pushRegAndOff;
          (* old61 -> common.switch[61];*)
          (if isWchar then
              'CopyT_W'-> mch.callPrim (* should be some CopyCWT *)
           else
              'CopyT'-> mch.callPrim
          if);
          0 -> mch.getPrimRes;
       #);
     isWchar: @boolean
  enter isWchar
  #);
DataArg: COMarg 
  (* Represents a cStruct passed by value to BETA from
   * an external call via a COMvirtual;
   * paramNo is the parameter number of the COMvirtual
   * of this cStruct;
   * Constraint: a DataVal can only be assigned to a data-object;
   *             i.e only asgToItem below can be called
   * OBS: do we need to increment paramNo corresponding to struct size?
   *)
  (# display::< (# do 'DataVal:'->xT #);
     release::< (##);
     asgToItem::<
       (# A: ^mch.address;
          IR: ^mch.RegisterOperand
       do (if stest then
              301->trace(#do 'DataVal:asgToItem:'-> xT; paramNo-> xI #)
          if);
          rA.copy -> A[];
          (if common.targetMAchineId
           // common.sun4s then
              (* sun style: a reference to the struct/data is 
               * passed as the argument
               *)
              (# dAdr: ^mch.regAdr; dr: ^mch.dataRegOperand;
                 aR: ^mch.adrRegOperand
              do &mch.RegAdr[] -> dAdr[];
                 (paramNo,false) -> mch.GetComPar -> aR[];
                 aR -> dAdr.reg;
                 (for i: rDesc.size div 4 repeat
                      (dAdr[],A[]) -> mch.cpMem -> dr[];
                      dr.deAlloc;
                      4 -> dAdr.addOff -> dAdr[];
                      4 -> A.addOff -> A[]
                 for)
              #)
           else
              (* Intel style: all struct/data elements are passed
               * as arguments.
               *)
              (for i: rDesc.size div 4 repeat
                   (paramNo+i-1,true) -> mch.GetComPar -> IR[];
                   (IR[],A[]) -> mch.stVal;
                   IR.deAlloc;
                   4 -> A.addOff -> A[]
              for);
          if);
          (if switch181 then rA[] -> rAx[] if)
       #);
     asgToList:: (# do 'DataArg:asgToList:notImplemented'-> thisTranslate.systemException #);
  #);
