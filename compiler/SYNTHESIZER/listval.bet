ORIGIN 'evlib';
LIB_ITEM 'betacodegen';
INCLUDE '~beta/betaast/scanBetaText';
INCLUDE 'auxlib';
INCLUDE 'inlinNXitem';
INCLUDE 'storeReg';
INCLUDE 'computedval';
INCLUDE 'genlib_bytecode';
INCLUDE 'bytecodeval';
---mkListVal:descriptor---
(# LV: ^ListVal
do &ListVal[]->LV[]->V[]; (evl[],thisBaseAdr[],lChain[])->LV
#)
---EvalLib:attributes---
basicType:
  (# desc: ^ASTindex; T: ^theGen.Type
  enter desc[]
  do (* datpete: 2003-01-29: Use of theGen.xxxValue operations *)
     (if true 
      // sematt.integerDesc -> desc.equal then
         &theGen.int32value[] -> T[]
      // sematt.int8Desc -> desc.equal 
      // sematt.int8uDesc -> desc.equal then
         &theGen.int8value[]-> T[]
      // sematt.int16Desc -> desc.equal 
      // sematt.int16uDesc -> desc.equal then
         &theGen.int16value[] -> T[]
      // sematt.boolDesc -> desc.equal then
         &theGen.boolvalue[] -> T[]
      // sematt.charDesc -> desc.equal then
         &theGen.charvalue[] -> T[]
      // sematt.realDesc -> desc.equal then
         &theGen.realvalue[] -> T[]
      // sematt.real32Desc -> desc.equal then
         &theGen.real32value[] -> T[]
     if) 
  exit T[]
  #); 
asgList2rep:
  (# baseAdr: ^mch.address;
     size,length: @integer;
     noStore,
     isValueRep,isBoolRep: @boolean;
     lChain,rChain,chain1: ^DH.superChain;
     evl,rEV: ^ASTindex;
     elmDesc: @ASTindex;
     V: ^evVal
  enter
     (baseAdr[],evl[],size,rEV[]
     ,lChain[],rChain[]
     ,isValueRep,isBoolRep,noStore)
  do (rChain[],rEV.son) -> DH.theDesc -> (elmDesc,chain1[]);
     elmDesc[]->theGen.mkarraySignature -> baseAdr.fieldType[];
     evl->scanList(# do length + 1 -> length #);
     (elmDesc[],isValueRep,isBoolRep,size,length,baseAdr[],noStore)
       -> asgToNewRep
     (#
     do evl->scanList
        (# EV: @AStindex; inx: @integer;
        do (if switch182 then 
               mch.duplicate;
               (inx->mch.newCstOp,&mch.dataRegOperand[])->mch.ldCst;
               inx+1->inx;                       
           if);
           currentNode -> EV;
           (baseAdr[],EV[],false,lChain[](*rChain[]*))
             -> ExpEval
             -> V[];
           (* OBS: Currently asgToRepElm is used, but we might
            * as well here decide whether to use asgToAdr,
            * asgToRealAdr, etc. And later also asgToRefAdr
            * when reference repetitions are supported
            *)
           (if stest then
               301->ctrace
               (#
               do 'listVal:asgList2Rep:elm:'->xT;
                  V.display;
                  mch.dumpreg;
           #)if);
           (if switch182 then
               (# AI: @mch.InxRegAdr; 
                  desc: @ASTindex;
                  chain1: ^DH.superChain
               do (if true then
                      elmDesc[] -> AI.bAdr.localDesc[];
                      elmDesc.size -> AI.size;
                      elmDesc[] -> theGen.mkSignature -> AI.fieldType[]
                   else
                      (rChain[],rEV)
                        -> DH.theDesc
                        -> (desc,chain1[]);
                      desc[] -> AI.bAdr.localDesc[];
                  if);
                  (AI[],rEV[],rChain[]) -> V.asgToRepElm -> V[];
               #)
            else
               (NextElmAdr,rEV[],rChain[]) -> V.asgToRepElm -> V[];
           if);
           V.release;
        #);
     #);
  #);
ListVal: EvVal
  (# thisVal::
       (#V: @ListVal do (evl[],thisBaseAdr[],lChain[])->V; V[]->thisV[] #);
     evId:: (# do 'ListVal:' -> id[] #);
     display::
       (# 
       do 'evl='->xT; evl[]->xA; xN;
          'thisBaseAdr='->xT; thisBaseAdr.display->xT;
          (*lCHain[]->printChain*)
       #);
     loadVal::< (#do cError(#do 'listVal: loadVal'->xT #)#);
     loadVal2::< (#do cError(#do 'listVal: loadVal'->xT #)#);
     theReg::<(#do thisBaseAdr.theReg -> aR #);
     release::
       (#
       do (*179->trace(#do 'list1:'-> xT; mch.dumpreg #);*)
          thisBaseAdr.freeAdr; 
          none->evl[]; none->thisBaseAdr[]; none->lChain[];
          (*179->trace(#do 'list2:'-> xT; mch.dumpreg #);*)
       #);
     toTmp::
       (#
       do (if thisBaseAdr.useCallReg then
              thisBaseAdr.toTmp->thisBaseAdr[]; mch.decrCallReg if)
       #);
     elimReg:: (# do (elimThis,elimCall)->thisBaseAdr.elimReg #);
     asgToAdr:: (* (E1,E2,...)->rA *)
       (#do cError(#do 'ListVal:asgToAdr'->xT; evl[]->xA #)#);
     asgToRepAdr::
       (# elmDesc: @ASTindex;
          length: @integer; isValueRep,unfreeze: @boolean
       do (if stest then
              301->trace(#do 'ListVal:asgToRepAdr;'->xT; evl[]->xA;
                           thisBaseAdr.display; xN;
                           100->SwitchOn;
                           rEv[]->xA;
                           100->SwitchOff
                        #)
          if);
          (if not thisBaseAdr.frozenReg then
              thisBaseAdr.freezeReg;
              true ->unfreeze
          if);
          evl->scanList(# do length + 1 -> length #);
          (* Value repetition is assumed, 
           * later ref rep should be supported *)
          
          (if rEV.son -> sematt.simpleOrRep 
           // gram.staticItem // gram.staticComponent then
              true -> isValueRep
           // gram.dynamicItem // gram.dynamicComponent then
              false -> isValueRep
          if);
          (rChain[],rEV.son) -> DH.theDesc -> (elmDesc,chain1[]);
          (elmDesc[],isValueRep,false,(*FIXME boolRep*)rA.size,length,rA[],false)
            -> asgToNewRep
          (#
          do evl->scanList
             (# EV: @AStindex; inx: @integer;
             do (if switch182 then 
                    mch.duplicate;
                    (inx->mch.newCstOp,&mch.dataRegOperand[])->mch.ldCst;
                    inx+1->inx;                       
                if);
                currentNode -> EV;
                (thisBaseAdr.copy,EV[],false,lChain[](*rChain[]*))
                  -> ExpEval
                  -> V[];
                (* OBS: Currently asgToRepElm is used, but we might
                 * as well here decide whether to use asgToAdr,
                 * asgToRealAdr, etc. And later also asgToRefAdr
                 * when reference repetitions are supported
                 *)
                (if stest then
                    301->ctrace
                    (#
                    do 'listVal:asgToRepAdr:elm:'->xT;
                       V.display;
                       mch.dumpreg;
                #)if);
                (if switch182 then
                    (# AI: @mch.InxRegAdr
                    do (if true then
                           elmDesc[] -> AI.bAdr.localDesc[];
                           elmDesc.size -> AI.size;
                           elmDesc[] -> theGen.mkSignature -> AI.fieldType[]
                        else
                           rA.bAdr.localDesc[] -> AI.bAdr.localDesc[];
                       if);
                       (AI[],rEV[],rChain[]) -> V.asgToRepElm -> V[];
                    #)
                 else
                    (NextElmAdr,rEV[],rChain[]) -> V.asgToRepElm -> V[];
                if);
                V.release;
             #);
          #);
          (if unFreeze then false -> baseAdr.frozenReg if);
          rA.freeAdr;
          this(ListVal)[] -> V[]
       #);
     asgToItem::
       (* evl=(E1,E2,...)
        * E1 -> EV.n1; E2 -> EV.n2 ... *)
       (# nScan: @ | scanNadr;
          NA: ^Mch.Address; more,first,onStack: @boolean;
          theEVL : @ASTindex;
          nxLevel: @integer;
          isSimple: @boolean; hasCode: @boolean
       do (*(if switch182 then
              (for i:7 repeat mch.duplicate for)
          if);*)
          (if switch181 then
              evl.father -> theEVL;
              (theEVL[],false,lChain[]) -> sematt.NXdepth -> (nxLevel,hasCode);
              (if hasCode then
                  false -> isSimple;
                  (if rA.useCallReg then 
                      (if rA.isCallReg then mch.decrCallReg
                       else
                          '\n***evval2:listVal::asgToItem:rA is NOT callreg'
                            -> putline
                      if);
                      rA.toTmp -> rA[];
                      (* rA.freezeReg (* who will release it? *)
                  if)
               else
                  true -> isSimple;
              if);
              
              (rDesc[],rA[](*not used*),0,rChain[],true) -> nScan;
              
              (rDesc[],rA[],rchain[],nScan[],isSimple) -> asgToN
              (# V: ^evVal;
                 EH: @EvalHandler;
                 localDesc: ^ASTindex
              do (if nScan.N = 1 then
                     (if stest then
                         301->trace(#do 'listVal:asgToItem:N=1'->xT #)
                     if);
                     (rObjAdr[],this(ListVal)[],nscan.thisEv[],false,nScan.thisChain[])
                       -> EH.AssignValToEval 
                       -> V[];
                     (if V[] <> NONE then V.release
                      else '\nListVal:asgToItem-1:V_is_None'->putline
                     if);                        
                  else
                     evl -> scanList
                     (# EV: @ASTindex;
                        lV,V: ^evVal;
                        rObjTmp: @addressTmpHandler;
                     do currentNode -> EV;
                        (EV[],false,lChain[]) 
                          -> sematt.NXdepth 
                          -> (nxLevel,hasCode);
                        (if hasCode then rObjAdr[]->rObjTmp.save if);
                        (thisBaseAdr[],EV[],false,lChain[])
                          -> ExpEval
                          -> lV[];
                        rObjAdr.bAdr.localDesc[] -> localDesc[];
                        (rObjAdr[],nScanN.PL,rObjAdr[]) 
                          -> SetSuperDesc 
                          -> rObjAdr[]; (* rObjAdr is a new object! *)
                        rObjTmp.restore;
                        rObjTmp.deAlloc;
                        rObjAdr.freezeReg; (* OBS! Overrides a possible 
                                            * non-freeze in asgToN. Gave
                                            * adr-negative during clean-up,
                                            * but should be reconsidered
                                            *)
                        
                        (rObjAdr[],lV[],nscan.thisEv[],false,nScan.thisChain[])
                          -> EH.AssignValToEval 
                          -> V[];
                        (if stest then
                            301->ctrace(#do 'listVal:in:asgtoItem:'->xT;
                                          display; xN;
                                          'V='->xT; V.display
                        #)if);
                        localDesc[] -> rObjAdr.bAdr.localDesc[];       
                        (if V[] <> NONE then V.release
                         else '\nListVal:asgToItem:VISNone'->putline
                        if);
                        nextEnterEval;
                     #)
                 if);
              #)
                -> this(asgToItem).rAx[] -> this(asgToItem).rA[]
           else
              (if common.switch[125] then
                  '\n*** list2item' -> putline;
                  (rDesc[],rA[],0,rChain[],true) -> nScan -> more;
                  (if nScan.N = 1 then
                      this(ListVal)[] -> nScan.asgToNelm
                   else
                      evl -> scanList 
                      (# EV: @ASTindex
                      do currentNode -> EV;
                         (* chain is valid for Left-side, 
                          * rChain for right-side *)
                         (thisBaseAdr.copy,EV[],false,lChain[](*rChain[]*))
                           -> ExpEval
                           -> nScan.asgToNelm; 
                         nScan -> more;
                  #)if)   
               else                  
                  rA[] -> moveToCallReg
                  (# chain1: ^DH.SuperChain
                  do EHchain[] -> chain1[];
                     (if rA.isCallReg and thisBaseAdr.isCallReg then
                         (* why does this never happen?*)
                         cError(#do 'ListVal:asgToItem:CallReg conflict'-> xT #)
                     if);
                     (rDesc[],thisA[]->rA[],0,rChain[],true) -> nScan -> more;
                     (if nScan.N=1 then
                         this(ListVal)[] -> nScan.asgToNelm
                      else 
                         (if thisBaseAdr.regType // mch.thisO // mch.callO then
                             evl -> scanList 
                             (# EV: @ASTindex
                             do currentNode -> EV;
                                (* chain is valid for Left-side, 
                                 * rChain for right-side *)
                                (thisBaseAdr.copy,EV[],false,lChain[](*rChain[]*))
                                  -> ExpEval
                                  -> nScan.asgToNelm; 
                                nScan -> more;
                                (if stest then
                                    301->trace(#do 'ListVal:asgToItem2'->xT; mch.dumpreg#)
                                if);
                             #)
                          else
                             (* with NXoffSets, baseAdr of a list should always
                              * be thisReg.
                              *)
                             (if switch180 then 
                                 cError(#do'listVal:asgToItem:Wrong Register'->xT#)
                             if);
                             pushThis; 
                             thisBaseAdr[] -> toThis -> thisBaseAdr[];
                             evl -> scanList 
                             (# EV: @ASTindex
                             do currentNode->EV;
                                (thisBaseAdr.copy,EV[],false,lChain[](*rChain[]*))
                                  -> ExpEval
                                  -> nScan.asgToNelm; 
                                nScan -> more
                             #);
                             popThis
                     if)if);
                     nScan.reset;
                  #)->rA[]; (* 27.4.93 *)
                  (* this could be handled more efficient, since a push callReg by
                   * moveToCallReg should not restore until the item has been 
                   * executed. Not possible with current structure.
                   * Might perhaps be done by push/pop of rA in the calls to
                   * asgToItem in transferEnter in evLib?
                   *)
              if)
          if)
       #);
     asgToNxOffSets::
       (# off: @integer; isRef,toCall: @boolean; A: ^mch.address;
          V: ^evVal
       do (if stest then 178->trace(#do 'listVal:asgToNXoffSets:'-> xT #)if);
          (if rA.isCallReg then
              (* this is only necessary if some Ev in evl is an object
               * that has to be executed. Some simple way of testing
               * this is missing
               *)
              rA.toTmp -> rA[]; 
              rA.freezeReg; (* freeze seems necessary
                             * since someone makes a freeAdr. 
                             *)
              mch.decrCallReg;
              true -> toCall;
              (*178->trace(#
               do 'listVal:asgToNXoffSets2:'-> xT; 
               rA.display->xT;
               mch.dumpReg #);*)
          if);          
          evl->scanList
          (# Ev: @ASTindex
          do currentNode->Ev;
             (thisBaseAdr.copy,Ev[],false,lChain[])->ExpEval->V[];
             (rA[],NX[],inXpart) -> V.asgToNxOffSets -> rA[];
             (if stest then
                 178->trace(# do 'listVal:asgToNXoffSets2B:'-> xT; 
                              mch.dumpReg #)
             if);             
             V.release
          #);
          (if toCall then
              (if rA.isCallReg then
                  cError(#do 'listVal:asgToNXoffSets:callRegproblem'->xT #)
              if);
              false -> rA.frozenReg;
              mch.GetCallReg; (* can callReg be busy here - and should
                               * it then be pushed, and where will it 
                               * then be popped
                               *)
              rA.toCallReg -> rA[];
              (if stest then
                  178->trace(#do 'listVal:asgToNXoffSets3:'-> xT; mch.dumpReg #)
              if);
          if)              
       #);
     asgToMethod::
       (* rElm: EV in enter-part being assigned *)
       (# V: ^ evVal;
          nScan: @ | scanNadr;
          chain1: ^DH.superChain;
          spec,descRef,RN1: @ASTindex;
          size: @integer;
          isRep,isValueRep,isBoolRep: @boolean;
          asgToMlist:
            (# scanRevl: @ | 
                 (# 
                 do EV.son->scanList(#do currentNode->rEv; SUSPEND #)
                 #);
               EV: ^ASTindex; 
            enter EV[]
            do 301->trace(#do 'asgToMethod:asgToMlist:'->xT; evl[] -> xA #);
               evl -> scanList
               (# EV: @ASTindex
               do currentNode -> EV;
                  scanRevl;
                  301->trace(#
                          do 'asgToMethod:asgToMlist:Elm:'->xT; 
                             ev[] -> xA;
                             rEV[] -> xA
                          #);
                  
                  
                  
                  (thisBaseAdr.copy,Ev[],true,lChain[])
                               -> ExpEval
                               -> V[];
                  (enterTypes,noOfArgs,next,rEv[],rChain[]) 
                               -> V.asgToMethod
                               -> next;           
               #)
            #);
          rEv,elmDesc: @ASTindex;
       do 301->trace(#
                    do 'listVal:asgToMethod:next:'->xT; next->xI; 
                       'type:'->xT; enterTypes[next]->xI; xN;
                       'left: ' -> xT; evl[] -> xA;  
                       'right: ' -> xT; rElm[] -> xA;
                       rchain
                    #);
          rElm.son -> sematt.simpleOrRepA -> spec;
          (if not spec.isNull then
              (if spec.label
               // gram.staticItem // gram.staticComponent then
                  true -> isRep -> isValueRep;
                  spec.son -> RN1; (*  R: [..] @ RN1 *)
                  RN1 -> sematt.descrip -> RN1;
                  RN1.size -> size;  
                  (if RN1.label = gram.objectDescriptor then
                      (sematt.boolDesc -> RN1.equal) -> isBoolRep
                  if)
               // gram.dynamicItem // gram.dynamicComponent then
                  true -> isRep; false -> isValueRep;
                  4 -> size; 
          if)if);

          (if isRep and (enterTypes[next] = 12) (* repetition *)  then
              301->trace(#
                      do 'listVal:asgToMethod:toRep:'->xT; evl[] -> xA; xN;
                         'size:'->xT; size -> xI;
                         'isValueRep:' -> xT; isValueRep->xB;
                           'isBoolRep:' -> xT; isBoolRep->xB;
                           ' rElm: '->xT; rElm[] -> xA;
                      #);
              (* we need
               * - isValueRep
               * - isBoolRep
               * - size
               * - fieldType (rep elm type - used for ref-reps )
               * - rEv: rElm.son? 
               *)
              (rChain[],rElm.son) -> DH.theDesc -> (elmDesc,chain1[]);
              (baseAdr.copy,evl[]
              ,size
              ,rElm[](* FIXME: rEv[] ? *)
              ,lChain[],rChain[],
              isValueRep,isBoolRep,true)
                -> asgList2Rep;
              next + 1 -> next
           else   
              (if false then
                  (enterTypes,noOfArgs,next,rElm[],rChain[]) 
                    -> V.asgToMethod
                       -> next                  
               else
                  (* OBS! Don't work: rElm is an evaluation; we cannot
                   * called theDesc and nScan, etc.
                   * So more complicated - like assignValToEval
                   *)
                  (if rElm.label
                   // gram.evalList then
                      301->trace(#
                              do 'asgToMethod:asgToList:'->xT; rElm[]->xA 
                              #);
                      rElm[] -> asgToMlist
                   // gram.assignmentEvaluation then
                      301->trace(#
                              do 'asgToMethod:asgToAssignEval:'->xT;
                                 rElm[]->xA 
                              #);
                      rElm.son -> RN1;
                      (enterTypes,noOfArgs,next,RN1[],rChain[]) 
                        -> asgToMethod
                        -> next                      
                   else
                      301->trace(#do ' list:2:methodA: '->xT; relm[] -> xA #);
                      (* in principle we need a case for each eval type
                       * so currently the following code is probably
                       * not complete
                       *)
                      (if rElm.label 
                       // gram.objectDenotation
                       // gram.insertedItem then
                          rElm.son -> rElm
                       // gram.thisObject then
                          'This!'->putline
                      if);
                      (if rElm.label = gram.objectDescriptor then
                          rElm -> descRef;
                          rChain[] -> chain1[]
                       else
                          (rChain[],rElm)
                            -> DH.theDesc
                            -> (descRef,chain1[])
                      if);
                      301->trace(#
                                do ' list:3:method: '->xT; 
                                   descRef[] -> xA;
                                   chain1
                                #);
                      (descRef[],thisBaseAdr[](*not used*),0,
                      chain1[](*rChain[]*),true) 
                        -> nScan;
                      (if nScan.N = 1 then
                          301->trace(#
                                  do 'asgToMethod:N=1:asgTo: '->xT;
                                     nScan.thisEv[] -> xA
                                  #);
                          (enterTypes,noOfArgs,next,nScan.thisEv[],nScan.thisChain[]) 
                            -> asgToMethod
                            -> next
                       else
                          evl->scanList 
                          (# Ev: @ASTindex
                          do currentNode->Ev;
                             301->trace(#
                                       do 'asgToMethod:[:'->display; xN;
                                          'next: ' -> xT; next->xI; 
                                          'type:'->xT; enterTypes[next]->xI 
                                       #);
                             (thisBaseAdr.copy,Ev[],true,lChain[])
                               -> ExpEval
                               -> V[];
                             (if V[] = none then
                                 '\nOBS! listVal:asgToMethod:V is none'
                                   ->putline
                             if);
                             301->trace(#
                                       do 'asgToMethod:]:' ->display; xN;
                                          'V: ' -> xT; V.display; xN;
                                          'type: ' -> xT; V.type -> xA;
                                       #);
                             (enterTypes,noOfArgs,next,nScan.thisEv[],nScan.thisChain[]) 
                               -> V.asgToMethod
                               -> next;
                             nScan 
          #)if)if)if)if)
       #);
     asgToExitArgs::
       (# xNo: @integer; V: ^evVal; xT: ^ExitTypes
       do (*'XA:listval:'->puttext;*)
          evl->scanList
          (# Ev: @ASTindex
          do currentNode->Ev;
             (thisBaseAdr.copy,Ev[],true,lChain[])->ExpEval->V[];
             301->trace(#do 'listVal:asgToExitArgs:'->xT; V.type -> xA #);
             (rDesc[],exitNo,originAdr[],rChain[]) 
               -> V.asgToExitArgs
               -> (xNo,xT[]);
             xT[] -> xTypes.concatenate -> xTypes[];
             exitNo + xNo -> exitNo;
          #);
       #);
     asgToInlineItem::
       (# inx: ^inlineNXitem
       do evl->scanList
          (# Ev: @ASTindex
          do currentNode->Ev;
             (thisBaseAdr.copy,Ev[],false,lChain[])->ExpEval->V[];
             (rDesc[],inlNX[],rChain[])->V.asgToInlineItem
          #);
          (*inlNX[]->inx[]; inx.eval->V[]*)
       #);
     asgToList::< (* assign evl=(le1,le2,...)->EV=(re1,re2,...) *)
       (# scanRevl: @ | 
            (# 
            do EV->scanList(#do currentNode->rEv; SUSPEND #)
            #);
          rEv: @ASTindex;
          W: @ListVal;
       do 301->trace(#
                    do 'asgToList:'->display
                    #);
          (if switch182 then
              evl->scanList
              (# EV: @ASTindex
              do currentNode->EV;
                 scanRevl;
                 301->trace(#
                           do 'asgToList:elm:'->display;
                              'elm:'->xT; EV[] -> xA
                           #);
                 (thisBaseAdr.copy,EV[],lChain[],false,none)
                   -> mkMethodArgs
                   -> V[];
                 (BA[],V[],rEv[],false,rChain[])->AssignValToEval->V[];
              #)
           else
              (if switch181 then
                  evl->scanList
                  (# EV: @ASTindex
                  do currentNode->EV;
                     scanRevl;
                     (thisBaseAdr.copy,Ev[],false,lChain[])->ExpEval->V[];
                     (BA[],V[],rEv[],false,rChain[])->AssignValToEval->V[]; 
                     V.release
                  #)
               else
                  (if thisBaseAdr.regType//mch.thisO//mch.callO then
                      (if stest then
                          301->trace(#do 'ListVal:asgToList2:'->xT #)
                      if);
                      evl->scanList
                      (# EV: @ASTindex
                      do currentNode->EV;
                         scanRevl;
                         (thisBaseAdr.copy,Ev[],false,lChain[])->ExpEval->V[];
                         (BA[],V[],rEv[],false,rChain[])->AssignValToEval->V[];
                         V.release
                      #)
                   else
                      (if switch180 then 
                          cError(#do 'listVal:asgToList:Wrong register'->xT #)
                      if);
                      BA[]->moveToCallReg
                      (#
                      do (*350->trace(#do 'PushThis6'-> xT #);*)
                         pushThis; 
                         thisBaseAdr[]->toThis->thisBaseAdr[];
                         evl->scanList
                         (# EV: @ASTindex
                         do currentNode->EV;
                            scanRevl;
                            (thisBaseAdr.copy,Ev[],false,lChain[])->ExpEval->V[];
                            (thisA[],V[],rEv[],false,rChain[])->AssignValToEval->V[]; 
                            V.release;
                         #);
                         thisA[]->BA[]; popThis
                      #)->BA[]; (* 27.4.93 - see asgToItem above *)
          if)if)if);
          (* return the right-side evalList, ev *)
          (ev[],BA[],rChain[])->W; W[]->V[]
       #);
     asgToDispatch::
       (# EL: [100] ^ASTindex; top: @integer;
          scanL:
            (# EV: ^ ASTindex; next,inc: @integer
            do (if sematt.cExt->mch.xParForward then 
                   1 -> inc; 1 -> next
                else -1 -> inc; top -> next
               if);
               (for i: top repeat
                    EL[next][] -> EV[];
                    INNER;
                    next + inc -> next
               for);                    
            #)
       do 301 -> ctrace
          (#
          do 'listVal:asgToDispatch:' -> xT; EV[] -> xA; xN;
             desc[]-> xA;
          #);
          evl->scanList
          (#
          do &ASTindex[]->EL[top+1->top][];
             currentNode->EL[top]
          #);
          (EV[],externalName[],desc[],extKind)
            -> GenCOMdispatch
          (#
          do scanL
             (# X: @integer
             do (thisBaseAdr.copy,EV[],false,lChain[]) -> ExpEval -> V[];
                V[] -> PushDispatchPar
             #);
          #) -> V[]
       #);
     asgToCproc::<
       (# CP: @ ExTernalCall; 
          EL: [100] ^ASTindex; top,max: @integer;
          chain1: ^DH.SuperChain; 
          inThis,popCall,popThis,arg2Saved: @boolean;
          savedArg2: @mch.dataRegOperand;
          callRegParNo: @integer
       do (if stest then
              301->ctrace(#do 'listVal:asgtoCproc:'->xT;  #);
          if);
          (if switch182 then
              (if true then
                  (EV[],desc[],externalName[],extKind) -> theGen.callExternal
                  (#
                  do evl->scanlist
                     (# E: @ASTindex
                     do currentNode -> E;
                        (thisBaseAdr.copy,E[],false,lChain[])
                          -> ExpEval
                          -> V[];
                        (* NOTE: the CP desclared in callExternal *)
                        (true->CP.getEnterP,extKind,CP.getEnterP.size
                        ,CP.pascExtProcInfo)
                          -> V.pushCpar;
                     #) 
                  #) -> V[]
               else
              (# sig: @theGen.signature;
                 XN: ^text
              do (externalName[],Desc[],extKind,EV.son)->CP; (* init *)
                 evl->scanlist
                 (# E: @ASTindex
                 do currentNode -> E;
                    (thisBaseAdr.copy,E[],false,lChain[])
                      -> ExpEval
                      -> V[];
                    (if true then
                        (true->CP.getEnterP,extKind,CP.getEnterP.size
                        ,CP.pascExtProcInfo)
                          -> V.pushCpar;
                     else
                        true->V.pushVal;
                    if)
                 #);
                 false -> sig.isStatic;
                 (EV[],thisSuperChain,true) -> sig.setMethodDesc;
                 desc[] -> sig.addEnter;
                 sig.addExit;
                 (desc[],false) -> descName -> XN[];
                 xn[] -> sig.addMethod;
                 ('beta/C$' -> (XN.copy).prepend,desc[]) -> sig.addreceiver;
                 1->trace(#
                         do 'call: ' -> xT; sig.asText -> xT
                         #);
                 (sig.asText->mch.newTextOp,'M',false,true)
                   -> mch.gJsr;   
                 (0,false,false,false)->mkComputedEvVal->V[]
              #)if)
           else
          FixBase
          (#
          do EHchain[]->chain1[];
             (externalName[],Desc[],extKind,EV.son)->CP; (* init *)
             evl->scanList
             (#
             do &ASTindex[]->EL[top+1->top][];
                currentNode->EL[top]
             #);
             (if extKind->mch.xParForward then
                 (* For some tstcproc.bet
                  * of the RISC's: mips, ppc, sparc (eventually),
                  * callReg is the same register as the 2nd argument register.
                  * (1) Before transferring external arguments, it must be
                  *     tested if callReg is busy, and if so, callReg MUST be
                  *     saved and later restored.
                  * (2) Evaluation of an argument may involve execution
                  *     of primitive operations, like AlloI, CopyT, etc; these
                  *     primitives may use argument registers; initPrimCall
                  *     will push possible busy arg. registers and getPrimRes
                  *     will restore them .....
                  * (3) Evaluation of arguments may call Beta procedures:
                  *     Eval of e.g. arg. 3:
                  *     Push arg1,arg2 (callreg)
                  *     AlloI -> callReg(arg2)
                  *     Pop arg1,arg2   - override callReg
                  *     .... transfer enter-params to callReg 
                  *     call M12FOO
                  *     We thus SAVE calReg(arg1) in a dataRegister when
                  *     it has been evaluated.
                  *     After AlloI we dont override callReg with arg. pop.
                  *     Before external call arg1 must be restored.
                  * RE 1. It seems that NO registers are ever stored before
                  * an external call? All busy registers should be saved?
                  * We now do it for MIPS/PPC - but should it be done
                  * in general?
                  *)
                 (if common.switch[61] then
                     (*mch.pushReg -> max; - dont work
                      * since some of the registers may have been released
                      * when the external is called. And then
                      * allocated after the call and then overwritten
                      * by mch.popReg
                      *)
                     (if extKind = sematt.VirtExt then
                         (* first arg. is theObject, so first eval
                          * in the list goes to callReg *)
                         1 -> callRegParNo
                      else
                         2 -> callRegParNo
                     if);                   
                     (if mch.callRegBusy and (top >= callRegParNo) then
                         (false,true) -> mch.pushThisOrCall;
                         true -> popCall;
                         (if thisBaseAdr.useCallReg then
                             (*350->trace(#do 'PushThis7'-> xT #);*)
                             pushThis;
                             true -> popThis;
			     thisBaseAdr[] -> toThis -> thisBaseAdr[];
                             (*'CallReg in use at ListVal:asgToCproc'
                              * ->systemError*)
                 if)if)if);
                 (if stest then
                     301->trace(#do 'ParNo: ' -> xT; callRegParNo -> xI;
                                  'extKind' -> xT; extKind -> xI#)
                 if);
                 (for i:top repeat
                      (thisBaseAdr.copy,EL[i][],false,lChain[])
                        -> ExpEval
                        -> V[];
                      (true->CP.getEnterP,extKind,CP.getEnterP.size
                      ,CP.pascExtProcInfo)
                        -> V.pushCpar;
                      (* arg2/callReg may be used during evaluation of 
                       * arg 3, 4, ... We thus save it and restore it
                       * when all arguments have been evaluated
                       *)
                      (if common.switch[61]
                          and (i = callRegParNo) and (top > callRegParNo) then
                          (* par no. 2 in callReg - MUST be saved *)
                          savedArg2.alloc; (* potentially dataReg overflow
                                            * if many nested C calls in
                                            * position of par. 2 of C-calls
                                            *)
                          (mch.callRegOp[],savedArg2[]) -> mch.cpReg;
                          true -> arg2Saved;
                          (* savedArg2[] -> mch.push (*data*)
                      if)
                 for);
              else                 
                 (for i:top repeat
                      (thisBaseAdr.copy,EL[top-i+1][],false,lChain[])
                        -> ExpEval
                        -> V[];
                      (false->CP.getEnterP,extKind,CP.getEnterP.size
                      
                      ,CP.pascExtProcInfo)
                        -> V.pushCpar;
                 for)
             if);
             (if arg2Saved then 
                 (*savedArg2[] -> mch.pop (*data*);
                 (savedArg2[],mch.callRegOp[]) -> mch.cpReg;
                 savedArg2.deAlloc
             if);
             CP.call;
             CP.getExitP->V[]; 
             (if popThis then (true,false) -> mch.popThisOrCall if);
             (if popCall then (false,true) -> mch.popThisOrCall if);
                 (*(if common.switch[61] then max -> mch.popReg if)*)
       #)if)#);
     asgToPrimitive::<
       (# CP: @primitiveCall; inThis: @boolean; chain1: ^DH.SuperChain
       do EHchain[]->chain1[];
          FixBase
          (# n: @integer
          do evl->scanlist(#do n+1->n (* this ONLY count 1 pr. elm!! *)#);
             (n,T[])->CP;
             evl->Scanlist
             (# EV: @ASTindex; V: ^EvVal
             do currentNode->EV;
                (thisBaseAdr.copy,EV[],false,lChain[])->ExpEval->V[];
                (3(* always long *),sematt.asmExt,0,0)->V.pushCpar;
             #);
             CP.call->V[];
       #)#);
     asgToInLinePrimitive::<
       (# xDr: [3] ^mch.dataRegOperand;  D: [3]@integer; Dmax,dRes: @integer;
          W: @ComputedEvVal; chain1: ^DH.SuperChain
       do EHchain[]->chain1[];
          FixBase
          (# dR1: ^mch.dataRegOperand
          do evl->scanList
             (# E: @ASTindex; V: ^evVal
             do currentNode->E; 
                (thisBaseAdr.copy,E[],false,lChain[])->ExpEval->V[];
                V.toDataReg->xDr[Dmax+1->Dmax][];
                xDr[Dmax]->D[Dmax]; (*V.release; !!*)
                (*350->trace(#do mch.dumpReg #)*)
             #);
             (opCode,I1,I2,D)->gen.inLinePrimitive->dRes->W.dr;
             W[]->V[];
             (for i: Dmax repeat
                  (if dRes = D[i] then else xDr[i].deAlloc if);
       for)#)#);
     asgToNewPrim::<
       (# EV1,EV2,op: @ASTindex; lv,rv,V1,V2: ^evVal; 
          opCode,pos,length,val: @integer;
	  dr,lDr,rDr,pDr,wDr: ^mch.dataRegOperand; 
          opT: ^text; A: ^mch.address;
	  ar: @mch.adrRegOperand;

          putBW:
            (* (val,byteNo)->A.putByte/Short
	     * (@@A,val)->putByte/Short 
             *) 
            (# size: @integer; bsNo: @integer
            enter size
            do (if switch182 then 
                   size -> putBWforByteCode
                else
                   evl->scanList
                   (# E: @ASTindex; i: @integer; dr1: ^mch.dataRegOperand
                   do currentNode->E;
                      (if i+1->i
                       // 1 then (* val *)
                          (baseAdr.copy,E[],false,rchain[])->ExpEval->lv[];
                       // 2 then (* byteNo *) 
                          E[]->getConst->(bsNo,V1[]); 
                          (if V1[] = none then
                              (if size = 2 then bsNo*2->bsNo if);
                              bsNo->A.addOff->A[]
                           else
                              V1.loadVal2->V1[]; (*Check this evrywhere*)
                              V1.toDataReg->dr1[];
                              (A[],dr1[],size)->primIndex->A[]
                          if)
                      if);
                   #) ;
                   lv.toDataReg->dr[];
                   (if size
                    // 1 then (dr[],A[])->mch.stByte
                    // 2 then (dr[],A[])->mch.stHalf
                    // 4 then (dr[],A[])->mch.stVal
                   if);
                   A.freeAdr; (* cleared if InxRegAdr *)
                   (dr,false,false,false)->mkComputedEvVal->V[]
                   (* A.aReg does NOT denote a real object - must be cleared *)
               if)
            #);
          putBWforBytecode:
            (# size,off: @integer; val,offSet: @ASTindex; V: ^evVal;
               eval:
                 (# shift: @integer
                 enter shift
                 do (baseAdr.copy,val[],false,rchain[])->ExpEval->lv[];
                    true -> lv.pushVal;
                    (if shift > 0 then
                        (mch.dataTop[],shift->mch.newCstOp)
                          -> mch.logicalShiftLeft;
                    if);
                    (mch.dataTop[],mch.dataTop[],4) -> mch.gOr
                 #)
            enter size
            do mch.duplicate;
               (A[],&mch.dataRegOperand[]) -> mch.ldVal;
               evl->scanList
               (# i: @integer
               do (if i+1 -> i
                   // 1 then currentNode -> val
                   // 2 then currentNode -> offSet
                  if)
               #);
               offSet[] -> getConst -> (off,V[]);
               (if size
                // 1 then 
                   (if V[] = none then
                       (if off
                        // 0 then
                           (mch.DataTop[],0x00FFFFFF->mch.newCstOp,4) 
                             -> mch.gAnd;
                           24 -> eval
                        // 1 then
                           (mch.DataTop[],0xFF00FFFF->mch.newCstOp,4) 
                             -> mch.gAnd;
                           16 -> eval
                        // 2 then
                           (mch.DataTop[],0xFFFF00FF->mch.newCstOp,4)
                             -> mch.gAnd;
                           8 -> eval;
                        // 3 then
                           (mch.DataTop[],0xFFFFFF00->mch.newCstOp,4) 
                             -> mch.gAnd;
                           0 -> eval
                       if);
                    else
                       '\nBytecode:putBW: '
                       'missing implementation '
                       'for computed byte position'
                         -> putline
                   if)
                // 2 then
                   (if V[] = none then
                       (if off
                        // 0 then
                           (mch.DataTop[],0x0000FFFF->mch.newCstOp,4) 
                             -> mch.gAnd;
                           16 -> eval
                        // 1 then
                           (mch.DataTop[],0xFFFF0000->mch.newCstOp,4) 
                             -> mch.gAnd;
                           0 -> eval
                       if);
                    else
                       '\nBytecode:putBW: '
                       'missing implementation '
                       'for computed short position'
                         -> putline
                   if)
                // 4 then
                   '\nPutByt:int32Rep'->putline
               if);
               (mch.dataTop[],A[]) -> mch.stVal
            #); 
          inxPut:
	    (* (val,inx)->R.inxPut/byte/short/long 
	     * (R,inx,val) -> inxPut/byte/short/long 
             * R is a repetition
	     * D[1]=adr(R), D[2]=inx, D[3]=val 
             *)
            (# val: ^mch.dataRegOperand;      
               size: @integer (* 0=byte, 1=word, 2=long *);
               oldS14,oldS15: @boolean
            enter size
            do (if switch182 then
                   size -> inxPutForByteCode
                else
                   common.switch[14]->oldS14; common.switch[15]->oldS15;
                   true->common.switch[14]->common.switch[15];
                   evl->scanList
                   (# E: @ASTindex;; i: @integer
                   do currentNode->E;
                      (if i+1->i
                       // 1 then
                          (baseAdr.copy,E[],false,rchain[])->ExpEval->lv[];
                          lv.toDataReg->val[];
                       // 2 then
                          (baseAdr.copy,E[],false,rchain[])->ExpEval->lv[];
                          lv.toDataReg->dr[];
                      if);
                   #);
                   (dr,true,size)->A.index->A[];
                   size->A.addOff->A[]; (* check that this works *)
                   (if size
                    // 1 then (val[],A[])->mch.stByte
                    // 2 then (val[],A[])->mch.stHalf
                    // 4 then (val[],A[])->mch.stVal
                   if);
                   oldS14->common.switch[14]; oldS15->common.switch[15];
                   (* A.aReg does NOT denote a real object - must be cleared *)
                   A.freeAdr; (* cleared if InxRegAdr *)
                   (val,false,false,false)->mkComputedEvVal->V[]
               if)
            #);
          inxPutForByteCode:
            (# size: @integer;
               val,offSet: @ASTindex;
               AR: @mch.InxRegAdr;
               ElementOffTemp, RepTemp, IndexTemp: ^mch.address;
               doIndex:
                 (# size: @integer
                      (* 1: putByte
                       * 2: putShort
                       * 4: putLong
                       *);
                    repElmSize: @integer (* element size of repetition *);
                 enter(size,repElmSize)
                 do (* stack = ... rep   *)
                    (if size>repElmSize then
                        'inxPutForByteCode: '
                        'cannot use R.%putXXX '
                        'when XXX is larger than element size of R' -> putline;
                    if);
                    (*1->trace(#
                            do 'inxPutForByteCode:type: ' -> xT;
                               (A.bAdr.localDesc[] -> basicType).asText -> xT
                            #);*)
                    (if isClr or common.switch[318] then 
                        (* stack =  ... rep,  *)
                        mch.duplicate;
                        (* stack =  ... rep,rep  *)
                        (* Save rep in temporary memory location *)
                        (A.bAdr.localDesc[]->basicType->theGen.Array).asText
                          -> theGen.allocAndStoreTmp 
                          -> RepTemp[];
                        (* stack =  ... rep,  *)
                    if);
                    A.receiverType[] -> AR.receiverType[];
                    'index$' -> AR.fieldName[];
                    (A.bAdr.localDesc[] -> basicType).asText -> AR.fieldType[];
                    (* evaluate index *)
                    (baseAdr.copy,offset[],false,rchain[])->ExpEval->lv[];
                    lv.pushVal;
                    (* stack = ... rep,index *)
                    (if size > 1 then
                        (* adjust index (part of semantics for inxPut):
                         * size 1: no adjustment
                         * size 2: multiply by 2
                         * size 4: multiply by 4
                         *)
                        (size -> mch.newCstOp,mch.dataTop[],4) -> mch.gMult
                    if);
                    
                    (* stack: ..., rep, index *)
                    (* Now analyze index:
                     *   R[repIndex] will be the element to work on.
                     *   repIndex is (index div repElmSize)
                     *   elementOff into R[repIndex] is (index mod repElmSize)
                     *)
                    mch.duplicate;
                    (repElmSize->mch.newCstOp,mch.dataTop[]) -> mch.ldCst;
                    (mch.dataTop[],&mch.doubleDataRegOperand[],false(*mod*)) 
                      -> mch.gDiv;
                    (if size < repElmSize then 
                        (* Multiply ElementOff with 8 to get bit position
                         * into element. If size is elementSize, elementOff
                         * must be 0, and no multiplication is needed.
                         *)
                        (8->mch.newCstOp,mch.dataTop[]) -> mch.ldCst;
                        (mch.dataTop[],mch.dataTop[],4) -> mch.gMult;
                    if);
                    (* store ElementOff in tmp *)
                    AR.fieldType[]
                      -> theGen.allocAndStoreTmp 
                      -> ElementOffTemp[];
                    (* stack: ..., rep, bytepos *)
                    (repElmSize->mch.newCstOp,mch.dataTop[]) -> mch.ldCst;
                    (mch.dataTop[],&mch.doubleDataRegOperand[],true(*div*)) 
                      -> mch.gDiv;
                    (* stack: ..., rep, repIndex *)
                    
                    (if size = repElmSize then
                        (* All bits will be modified *)
                        (0->mch.newCstOp,mch.dataTop[]) -> mch.ldCst;
                     else
                        (* Extract unmodified bits *)
                        (if isClr or common.switch[318] then
                            (* stack = [ .... rep,repIndex, *)
                            mch.duplicate;
                            (&theGen.int16Value[]).asText -> theGen.allocAndStoreTmp -> IndexTemp[];
                            (RepTemp[],mch.dataTop[]) -> mch.ldVal;
                            (IndexTemp[],mch.dataTop[]) -> mch.ldVal;
                            (* stack = [ .... rep,repIndex,rep,repIndex  *)
                         else
                            (* duplicate rep & index *)
                            (0,2) -> mch.duplicate;
                            (* stack = [ .... rep,repIndex,rep,repIndex  *)
                        if);
                        (* Now load element *)
                        (AR[],mch.dataTop[]) -> mch.ldVal;
                        (* stack = [ .... rep,repIndex,rep[repIndex] *)
                        
                        (* Push and-mask *)
                        (if size
                         // 1 then
                            (0xff000000->mch.newCstOp,mch.dataTop[])->mch.ldCst
                         // 2 then
                            (0xffff0000->mch.newCstOp,mch.dataTop[])->mch.ldCst
                        if);
                        (* stack = [ .... rep,repIndex,rep[repIndex],mask *)
                        
                        (* Load elementOff from temp *)
                        (ElementOffTemp[],mch.dataTop[]) -> mch.ldVal;
                        (* stack = [ .... rep,repIndex,rep[repIndex],mask,elementOff *)
                        (* Shift mask into position using elementOff *)
                        (mch.dataTop[],mch.dataTop[]) -> mch.logicalShiftRight;
                        (* Negate mask *)
                        (mch.dataTop[],4) -> mch.logNot;
                        
                        (* Extract unmodified bits from rep[repIndex] using mask *)
                        (mch.dataTop[],mch.dataTop[],4) -> mch.gAnd;
                    if);
                 #);
               eval:
                 (# size,repElmSize: @integer
                 enter(size,repElmSize)                    
                 do (baseAdr.copy,val[],false,rchain[])->ExpEval->lv[];
                    true->lv.pushVal;
                    (* stack = [ ...,rep,index,rep[index],val *)
                    (if true
                     // (size=1) and (repElmSize=4) then
                        (24->mch.newCstOp,mch.dataTop[]) -> mch.ldCst;
                        (ElementOffTemp[],mch.dataTop[]) -> mch.ldVal;
                        (mch.dataTop[],mch.dataTop[],4) -> mch.gSub;
                        (mch.dataTop[],mch.dataTop[]) 
                          -> mch.logicalShiftLeft;
                        (mch.dataTop[],mch.dataTop[],4) -> mch.gOr;
                     // (size=2) and (repElmSize=4) then
                        (16->mch.newCstOp,mch.dataTop[]) -> mch.ldCst;
                        (ElementOffTemp[],mch.dataTop[]) -> mch.ldVal;
                        (mch.dataTop[],mch.dataTop[],4) -> mch.gSub;
                        (mch.dataTop[],mch.dataTop[]) 
                          -> mch.logicalShiftLeft;
                        (mch.dataTop[],mch.dataTop[],4) -> mch.gOr;
                    if)
                 #);
               store:
                 (#
                 do (mch.dataTop[],AR[]) -> mch.stVal
                 #)
            enter size
            do 301->trace
               (#
               do (if size
                   // 1 then
                      (if A.size
                       // 1 then
                          'PutInt8:in:int8'->putline
                       // 2 then
                          'PutInt8:in:int16'->putline
                       // 4 then
                          'PutInt8:in:int32'->putline
                           else
                          '\nA.size:undefined'->putline
                      if)
                   // 2 then
                      (if A.size
                       // 1 then
                          'PutInt16:in:int8'->putline
                       // 2 then
                          'PutInt16:in:int16'->putline
                       // 4 then
                          'PutInt16:in:int32'->putline
                       else
                          '\nA.size:undefined'->putline
                      if)
                   // 4 then
                   else
                      '\nsize:undefined'->putline
                  if)
               #);
               evl->scanList
               (# i: @integer
               do (if i+1->i
                   // 1 then
                      currentNode -> val
                   // 2 then
                      currentNode -> offSet
                  if);
               #);
               (* load the repetition *)
               (A[],mch.dataTop[]) -> mch.ldVal;

               (if size
                // 1 then
                   (if A.size
                    // 1 then 
                       (* no index adjustment;
                        * ad in fact we need not load, mask and or
                        * the value since it is putbyte to a byte array
                        *)
                       doIndex; 
                       (* stack = [ ...,rep,index,rep[index] *)
                       eval;
                       (* stack = [ ...,rep,index,rep[index],val *)
                       (mch.dataTop[],mch.dataTop[],4) -> mch.gOr;
                       (mch.dataTop[],AR[]) -> mch.stVal
                    // 2 then

                    // 4 then
                       (* we need to select the right int32 element
                        * of the repetition: offset div 4;
                        * and then the right part of the int32 word:
                        * offset mod 4 - +/- 1
                        *)
                       (1,4) -> doIndex; 
                       (* stack = [ ...,rep,index,rep[index] *)
                       (1,4) -> eval;
                       (* stack = [ ...,rep,index,rep[index],val *)
                       store
                    else
                       '\nA.size:undefined'->putline
                   if)
                // 2 then
                   (if A.size
                    // 1 then 
                       '\nR%.putShort where R: [e] @char/int8/int8u'
                       ' is not implemented' -> putline;
                    // 2 then
                       '\nR%.putShort where R: [e] @int16/int16u'
                       ' is not implemented' -> putline;
                    // 4 then
                       (* we need to select the right int32 element
                        * of the repetition: offset div 4;
                        * and then the right part of the int32 word:
                        * offset mod 4 - +/- 1
                        *)
                       (2,4) -> doIndex; 
                       (* stack = [ ...,rep,index,rep[index] *)
                       (2,4) -> eval;
                       (* stack = [ ...,rep,index,rep[index],val *)
                       store
                    else
                       '\nA.size:undefined'->putline
                   if)                   
                // 4 then
                   (if A.size
                    // 1 then 
                       '\nR%.putLong where R: [e] @char/int8/int8u'
                       ' is not implemented' -> putline;
                    // 2 then
                       '\nR%.putLong where R: [e] @int16/int16u'
                       ' is not implemented' -> putline;
                    // 4 then
                       (* we need to select the right int32 element
                        * of the repetition: offset div 4;
                        * and then the right part of the int32 word:
                        * offset mod 4 - +/- 1
                        *)
                       (4,4) -> doIndex; 
                       (* stack = [ ...,rep,index,rep[index] *)
                       (4,4) -> eval;
                       (* stack = [ ...,rep,index,rep[index],val *)
                       store
                    else
                       '\nA.size:undefined'->putline
                   if)
                else
                   '\nsize:undefined'->putline
               if);
            #);
               
          getConst: 
            (# EH: @evalHandler;
               E: ^ASTindex; T: ^text; val: @integer; V: ^evVal;
               Ex: @AStindex;
            enter E[]
            do (if E.label = gram.integerConst then
	           E.getText->T[]; 0->T.setPos; T.getInt->val
		else 
                   (if switch182 then
                       E -> Ex; (* alisaing problem *)
                       (thisBaseAdr.copy,Ex[],rchain[],false,none)
                         -> EH.methodArgs -> V[]
                    else
		       (thisBaseAdr.copy,E[],false,rchain[])->ExpEval->V[]
	       if)if)
            exit(val,V[])
            #);
          mask1:
            (# len,left,M: @integer; neg: @boolean
            enter(len,left,neg)
            do (for i: len repeat
                    M*2 + 1 -> M
               for);
               (for i: left repeat M*2 -> M for);
               (if neg then (%bNot M) -> M if);
               (* newline; M -> puthex *)
            exit M
            #);
          putBitsForByteCode:
            (* (Val,pos,length)->R.%putbits
             * 
             * push R                 ; ..., Val",R
             * push M2                ; ..., Val",R,M2
             * and                    ; ..., Val, R'   R' bit field cleared
             * push Val               ; ..., Val
             * push M1                ; ..., Val,M1
             * and                    ; ..., Val'   bits left of pos cleared
             * push 32-len-pos  
             * sll                    ; ..., Val"   Val' in correct pos
             * or                     ; ..., R"        Val written in field
             * store R
             *)
            (# val,pos,length: @integer;
               V: ^evVal;
               isRep: @boolean
            enter(val,V[],pos,length,isRep)
            do (* duplicate adr of object with field addressed by A *)
               (if isRep then
                   (if isCLR then
                       1->trace(#
                               do 'putBitsForByteCode:FIX needed for CLR'->xT
                               #);
                   if);
                   (0,2) -> mch.duplicate
                else
                   mch.duplicate
               if);
               
               (A[],mch.dataTop[]) -> mch.ldVal;
               ((length,32-length-pos,true)->Mask1->mch.newCstOp
               ,mch.dataTop[]) 
                 -> mch.ldCst;
               (mch.dataTop[],mch.dataTop[],4)->mch.gAnd;
               (V[],val)->const2Reg->lDr[];
               ((length,0,false)->Mask1->mch.newCstOp,mch.dataTop[])
                 -> mch.ldCst;
               (mch.dataTop[],mch.dataTop[],4)->mch.gAnd;
               (32-length-pos->mch.newCstOp,mch.dataTop[]) -> mch.ldCst;
               (mch.dataTop[],mch.dataTop[])->mch.logicalShiftLeft;
               (mch.dataTop[],mch.dataTop[],4)->mch.gOr;
               (mch.dataTop[],A[]) -> mch.stVal; (*using adr from duplicate*)
            #);
	  ClrAndDeAlloc:
            (# ar: @mch.adrRegOperand
            enter ar
            do ar[]->mch.gClr; ar.deAlloc
            #)
       do 301->trace(#
                    do 'asgToNewPrim:'->display; xN;
                       EV[]->xA; 
                    #);
          EV.son-> EV1; EV1.son->EV1; Ev1.brother->op;
          (baseAdr.copy,EV1[],false,rchain[])->genAdr->A[];
          (if op[]->sematt.primitiveToNumber->opCode
           // 9 (* putByte *) then 
	      (if EV.evalKind = sematt.repValEval then 
                  1->inxPut
	       else 1->putBW
	      if)
           // 10 (* putShort *) then 
	      (if EV.evalKind = sematt.repValEval then 
                  2->inxPut
	       else 2->putBW
	      if)
           // 31 (* putLong *) then
	      (if EV.evalKind = sematt.repValEval then 
                  4->inxPut
	       else (* sematt.simpleEval, realVal, ... *) 
                  4->putBW
	      if)
           // 19 (* (pos,length)->R.%getBits    *)
           // 20 (* (pos,length)->getSignedBits *) then
	      (* address of R is in A *)
              (# dr: @mch.dataRegOperand; pos,length: @integer
              do dr.alloc; (A[],dr[])->mch.ldVal; A.freeAdr;
	         evl->scanList
                 (# E: @ASTindex;; i: @integer
                 do currentNode->E;
                    (if i+1->i
                     // 1 then (* pos *) E[]->getConst->(pos,V1[])
                     // 2 then (* length *) E[]->getConst->(length,V2[]);
                    if);
                 #) ;
	         (* V1[]=nil => pos is constant
	          * V2[]=nil => length is constant
	          *)                 
	         (if (V1[]<>none) or (V2[]<>none)  then
                     (V1[],pos)->const2Reg->pDr[];
                     (V2[],length)->const2Reg->wDr[];
                     (if opCode=19 then
                         (dr[],pDr[],wDr[])->mch.gGetBits
                      else
                         (dr[],pDr[],wDr[])->mch.gGetSignedBits
                     if)
                  else
	             (if opCode = 19 then 
                         (dr[],pos,length,dr[],none)->mch.getBits
	              else 
                         (dr[],pos,length,dr[],none)->mch.getSignedBits
	         if)if);
	         (dr,false,false,false)->mkComputedEvval->V[];
	      #)
           // 21 (* (Val,pos,length)->R.%putbits *) then 
              evl->scanList
              (# E: @ASTindex;; i: @integer
              do currentNode->E;
                 (if i+1->i
                  // 1 then (* val *) E[]->getConst->(val,V[])
                  // 2 then (* pos *) E[]->getConst->(pos,V1[])
                  // 3 then (* length *) E[]->getConst->(length,V2[])
                 if);
              #);
              (if switch182 then
                  (val,V[],pos,length,EV1.label=gram.indexed)
                    -> putBitsForByteCode
               else
	          A.toReg2->ar; ar.mkIndirect;
                  (V[],val)->const2Reg->lDr[];
                  (if v1[]=none then (* pos is constant *)
                      (if v2[]=NONE then (* pos and width are constant *)
                          (* the current case of putBits *)
                          (lDr[],pos,length,ar[],none)->mch.putBits
                       else (* length is variable *)
                          (* general case *)
                          (V1[],pos)->const2Reg->pDr[];
                          V2.toDataReg->wDr[];
                          (lDr[],pDr[],wDr[],ar[])->mch.gPutBits
                      if)
                   else 
                      V1.toDataReg->pDr[];
                      (if (v2[]=NONE) then
                          (V2[],length)->const2Reg->wDr[];
                          (lDr[],pDr[],wDr[],ar[])->mch.gPutBits
                       else 
                          (* pos is variable *)
                          (* general case *)
                          V2.todataReg->wDr[];
                          (lDr[],pDr[],wDr[],ar[])->mch.gPutBits
                  if)if);
              if);
              (lDr,false,false,false)->mkComputedEvval->V[];
              (* the following call is 'inherited' from the old primitive-code
               * from gen1body! It is a coincidence that it works,since ar 
               * is marked as indirect. This should generate set 0, [%ar].
               * It works since ar is transferred by value, which does NOT
               * transfer the inDirect flag!!!! Ugly:-(
               *)
              (if not switch182 then
                  ar->ClrAndDeAlloc
              if)
          if)
       #);
     pushCPar::<(#do 'ListPushCpar'->NotImpl #);
     FixBase:
       (# 
       do (if thisBaseAdr.regType//mch.thisO//mch.callO then
              INNER
           else
              (if switch180 then 
                  cError(#do 'listVal:FixBase:Wrong register'->xT #)
              if);
                  (*350->trace(#do 'PushThis8'-> xT #);*)
              pushThis; thisBaseAdr[]->toThis->thisBaseAdr[];
              INNER;
              popThis
       if)#);
     
     evl: ^ASTindex; 
     thisBaseAdr: ^mch.address;
     lChain: ^DH.SuperChain;
     (* evl must be evaluated relative to thisBaseAdr *)
  enter(evl[],thisBaseAdr[],lChain[])
  #);
