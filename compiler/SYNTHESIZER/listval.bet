ORIGIN 'evlib';
LIB_ITEM 'betacodegen';
INCLUDE '~beta/betaast/scanBetaText';
INCLUDE 'auxlib';
INCLUDE 'inlinNXitem';
INCLUDE 'storeReg';
INCLUDE 'computedval';
INCLUDE 'genlib_bytecode'
(*INCLUDE 'asgtoitem'*)
---mkListVal:descriptor---
(# LV: ^ListVal
do &ListVal[]->LV[]->V[]; (evl[],thisBaseAdr[],lChain[])->LV
#)
---EvalLib:attributes---
asgList2rep:
  (# baseAdr: ^mch.address;
     size,length: @integer;
     isValueRep: @boolean;
     lChain,rChain: ^DH.superChain;
     evl,rEV: ^ASTindex;
     V: ^evVal
  enter(baseAdr[],evl[],size,rEV[],lChain[],rChain[])
  do true -> isValueRep; (* FIXME! must be checked *)
     evl->scanList(# do length + 1 -> length #);
     (isValueRep,false,(*FIXME boolRep*)size,length,none(*not used*)) -> asgToNewRep
     (#
     do '++++1'->putline;
        evl->scanList
        (# EV: @AStindex; inx: @integer;
        do (if switch182 then 
               mch.duplicate;
               (inx->mch.newCstOp,&mch.dataRegOperand[])->mch.ldCst;
               inx+1->inx;                       
           if);
           '++++2'->putline;
           currentNode -> EV;
           (baseAdr[],EV[],false,lChain[](*rChain[]*))
             -> ExpEval
             -> V[];
           '++++3'->putline;
           (* OBS: Currently asgToRepElm is used, but we might
            * as well here decide whether to use asgToAdr,
            * asgToRealAdr, etc. And later also asgToRefAdr
            * when reference repetitions are supported
            *)
           (if stest then
               301->ctrace
               (#
               do 'listVal:asgToRepAdr:elm:'->xT;
                  V.display;
                  mch.dumpreg;
           #)if);
           (if switch182 then
               (# AI: @mch.InxRegAdr
               do sematt.charDesc[] (*rA.bAdr.localDesc[] FIXME *)
                    -> AI.bAdr.localDesc[];
                  '++++4'->putline;
                  (AI[],rEV[],rChain[]) -> V.asgToRepElm -> V[];
               #)
            else
               (NextElmAdr,rEV[],rChain[]) -> V.asgToRepElm -> V[];
           if);
           V.release;
        #);
     #);
  #);
ListVal: EvVal
  (# thisVal::
       (#V: @ListVal do (evl[],thisBaseAdr[],lChain[])->V; V[]->thisV[] #);
     evId:: (# do 'ListVal:' -> id[] #);
     display::
       (# 
       do 'evl='->xT; evl[]->xA; xN;
          'thisBaseAdr='->xT; thisBaseAdr.display->xT;
          (*lCHain[]->printChain*)
       #);
     loadVal::< (#do cError(#do 'listVal: loadVal'->xT #)#);
     loadVal2::< (#do cError(#do 'listVal: loadVal'->xT #)#);
     theReg::<(#do thisBaseAdr.theReg -> aR #);
     release::
       (#
       do (*179->trace(#do 'list1:'-> xT; mch.dumpreg #);*)
          thisBaseAdr.freeAdr; 
          none->evl[]; none->thisBaseAdr[]; none->lChain[];
          (*179->trace(#do 'list2:'-> xT; mch.dumpreg #);*)
       #);
     toTmp::
       (#
       do (if thisBaseAdr.useCallReg then
              thisBaseAdr.toTmp->thisBaseAdr[]; mch.decrCallReg if)
       #);
     elimReg:: (# do (elimThis,elimCall)->thisBaseAdr.elimReg #);
     asgToAdr:: (* (E1,E2,...)->rA *)
       (#do cError(#do 'ListVal:asgToAdr'->xT; evl[]->xA #)#);
     asgToRepAdr::
       (# length: @integer; isValueRep,unfreeze: @boolean
       do (if stest then
              301->trace(#do 'ListVal:asgToRepAdr;'->xT; evl[]->xA;
                           thisBaseAdr.display; xN;
                           100->SwitchOn;
                           rEv[]->xA;
                           100->SwitchOff
                        #)
          if);
          (if not thisBaseAdr.frozenReg then
              thisBaseAdr.freezeReg;
              true ->unfreeze
          if);
          evl->scanList(# do length + 1 -> length #);
          (* Value repetion is assumed, later ref rep should be supported *)
          
          (if rEV.son -> sematt.simpleOrRep 
           // gram.staticItem // gram.staticComponent then
              true -> isValueRep
           // gram.dynamicItem // gram.dynamicComponent then
              false -> isValueRep
          if);
          (isValueRep,false,(*FIXME boolRep*)rA.size,length,rA[]) -> asgToNewRep
          (#
          do evl->scanList
             (# EV: @AStindex; inx: @integer;
             do (if switch182 then 
                    mch.duplicate;
                    (inx->mch.newCstOp,&mch.dataRegOperand[])->mch.ldCst;
                    inx+1->inx;                       
                if);
                currentNode -> EV;
                (thisBaseAdr.copy,EV[],false,lChain[](*rChain[]*))
                  -> ExpEval
                  -> V[];
                (* OBS: Currently asgToRepElm is used, but we might
                 * as well here decide whether to use asgToAdr,
                 * asgToRealAdr, etc. And later also asgToRefAdr
                 * when reference repetitions are supported
                 *)
                (if stest then
                    301->ctrace
                    (#
                    do 'listVal:asgToRepAdr:elm:'->xT;
                       V.display;
                       mch.dumpreg;
                #)if);
                (if switch182 then
                    (# AI: @mch.InxRegAdr
                    do rA.bAdr.localDesc[] -> AI.bAdr.localDesc[];
                       (AI[],rEV[],rChain[]) -> V.asgToRepElm -> V[];
                    #)
                 else
                    (NextElmAdr,rEV[],rChain[]) -> V.asgToRepElm -> V[];
                if);
                V.release;
             #);
          #);
          (if unFreeze then false -> baseAdr.frozenReg if);
          rA.freeAdr;
          this(ListVal)[] -> V[]
       #);
     asgToItem::
       (* evl=(E1,E2,...)
        * E1 -> EV.n1; E2 -> EV.n2 ... *)
       (# nScan: @ | scanNadr;
          NA: ^Mch.Address; more,first,onStack: @boolean;
          theEVL : @ASTindex;
          nxLevel: @integer;
          isSimple: @boolean; hasCode: @boolean
       do (if switch182 then
              (for i:7 repeat mch.duplicate for)
          if);
          (if switch181 then
              evl.father -> theEVL;
              (theEVL[],false,lChain[]) -> sematt.NXdepth -> (nxLevel,hasCode);
              (if hasCode then
                  false -> isSimple;
                  (if rA.useCallReg then 
                      (if rA.isCallReg then mch.decrCallReg
                       else
                          '\n***evval2:listVal::asgToItem:rA is NOT callreg'
                            -> putline
                      if);
                      rA.toTmp -> rA[];
                      (* rA.freezeReg (* who will release it? *)
                  if)
               else
                  true -> isSimple;
              if);
              
              (rDesc[],rA[](*not used*),0,rChain[],true) -> nScan;
              
              (rDesc[],rA[],rchain[],nScan[],isSimple) -> asgToN
              (# V: ^evVal;
                 EH: @EvalHandler;
                 localDesc: ^ASTindex
              do (if nScan.N = 1 then
                     (if stest then
                         301->trace(#do 'listVal:asgToItem:N=1'->xT #)
                     if);
                     (rObjAdr[],this(ListVal)[],nscan.thisEv[],false,nScan.thisChain[])
                       -> EH.AssignValToEval 
                       -> V[];
                     (if V[] <> NONE then V.release
                      else '\nListVal:asgToItem-1:V_is_None'->putline
                     if);                        
                  else
                     evl -> scanList
                     (# EV: @ASTindex;
                        lV,V: ^evVal;
                        rObjTmp: @addressTmpHandler;
                     do currentNode -> EV;
                        (EV[],false,lChain[]) 
                          -> sematt.NXdepth 
                          -> (nxLevel,hasCode);
                        (if hasCode then rObjAdr[]->rObjTmp.save if);
                        (thisBaseAdr[],EV[],false,lChain[])
                          -> ExpEval
                          -> lV[];
                        rObjAdr.bAdr.localDesc[] -> localDesc[];
                        (rObjAdr[],nScanN.PL,rObjAdr[]) 
                          -> SetSuperDesc 
                          -> rObjAdr[]; (* rObjAdr is a new object! *)
                        rObjTmp.restore;
                        rObjTmp.deAlloc;
                        rObjAdr.freezeReg; (* OBS! Overrides a possible 
                                            * non-freeze in asgToN. Gave
                                            * adr-negative during clean-up,
                                            * but should be reconsidered
                                            *)
                        
                        (rObjAdr[],lV[],nscan.thisEv[],false,nScan.thisChain[])
                          -> EH.AssignValToEval 
                          -> V[];
                        (if stest then
                            301->ctrace(#do 'listVal:in:asgtoItem:'->xT;
                                          display; xN;
                                          'V='->xT; V.display
                        #)if);
                        localDesc[] -> rObjAdr.bAdr.localDesc[];       
                        (if V[] <> NONE then V.release
                         else '\nListVal:asgToItem:VISNone'->putline
                        if);
                        nextEnterEval;
                     #)
                 if);
              #)
                -> this(asgToItem).rAx[] -> this(asgToItem).rA[]
           else
              (if common.switch[125] then
                  '\n*** list2item' -> putline;
                  (rDesc[],rA[],0,rChain[],true) -> nScan -> more;
                  (if nScan.N = 1 then
                      this(ListVal)[] -> nScan.asgToNelm
                   else
                      evl -> scanList 
                      (# EV: @ASTindex
                      do currentNode -> EV;
                         (* chain is valid for Left-side, 
                          * rChain for right-side *)
                         (thisBaseAdr.copy,EV[],false,lChain[](*rChain[]*))
                           -> ExpEval
                           -> nScan.asgToNelm; 
                         nScan -> more;
                  #)if)   
               else                  
                  rA[] -> moveToCallReg
                  (# chain1: ^DH.SuperChain
                  do EHchain[] -> chain1[];
                     (if rA.isCallReg and thisBaseAdr.isCallReg then
                         (* why does this never happen?*)
                         cError(#do 'ListVal:asgToItem:CallReg conflict'-> xT #)
                     if);
                     (rDesc[],thisA[]->rA[],0,rChain[],true) -> nScan -> more;
                     (if nScan.N=1 then
                         this(ListVal)[] -> nScan.asgToNelm
                      else 
                         (if thisBaseAdr.regType // mch.thisO // mch.callO then
                             evl -> scanList 
                             (# EV: @ASTindex
                             do currentNode -> EV;
                                (* chain is valid for Left-side, 
                                 * rChain for right-side *)
                                (thisBaseAdr.copy,EV[],false,lChain[](*rChain[]*))
                                  -> ExpEval
                                  -> nScan.asgToNelm; 
                                nScan -> more;
                                (if stest then
                                    301->trace(#do 'ListVal:asgToItem2'->xT; mch.dumpreg#)
                                if);
                             #)
                          else
                             (* with NXoffSets, baseAdr of a list should always
                              * be thisReg.
                              *)
                             (if switch180 then 
                                 cError(#do'listVal:asgToItem:Wrong Register'->xT#)
                             if);
                             pushThis; 
                             thisBaseAdr[] -> toThis -> thisBaseAdr[];
                             evl -> scanList 
                             (# EV: @ASTindex
                             do currentNode->EV;
                                (thisBaseAdr.copy,EV[],false,lChain[](*rChain[]*))
                                  -> ExpEval
                                  -> nScan.asgToNelm; 
                                nScan -> more
                             #);
                             popThis
                     if)if);
                     nScan.reset;
                  #)->rA[]; (* 27.4.93 *)
                  (* this could be handled more efficient, since a push callReg by
                   * moveToCallReg should not restore until the item has been 
                   * executed. Not possible with current structure.
                   * Might perhaps be done by push/pop of rA in the calls to
                   * asgToItem in transferEnter in evLib?
                   *)
              if)
          if)
       #);
     asgToNxOffSets::
       (# off: @integer; isRef,toCall: @boolean; A: ^mch.address;
          V: ^evVal
       do (if stest then 178->trace(#do 'listVal:asgToNXoffSets:'-> xT #)if);
          (if rA.isCallReg then
              (* this is only necessary if some Ev in evl is an object
               * that has to be executed. Some simple way of testing
               * this is missing
               *)
              rA.toTmp -> rA[]; 
              rA.freezeReg; (* freeze seems necessary
                             * since someone makes a freeAdr. 
                             *)
              mch.decrCallReg;
              true -> toCall;
              (*178->trace(#
               do 'listVal:asgToNXoffSets2:'-> xT; 
               rA.display->xT;
               mch.dumpReg #);*)
          if);          
          evl->scanList
          (# Ev: @ASTindex
          do currentNode->Ev;
             (thisBaseAdr.copy,Ev[],false,lChain[])->ExpEval->V[];
             (rA[],NX[],inXpart) -> V.asgToNxOffSets -> rA[];
             (if stest then
                 178->trace(# do 'listVal:asgToNXoffSets2B:'-> xT; 
                              mch.dumpReg #)
             if);             
             V.release
          #);
          (if toCall then
              (if rA.isCallReg then
                  cError(#do 'listVal:asgToNXoffSets:callRegproblem'->xT #)
              if);
              false -> rA.frozenReg;
              mch.GetCallReg; (* can callReg be busy here - and should
                               * it then be pushed, and where will it 
                               * then be popped
                               *)
              rA.toCallReg -> rA[];
              (if stest then
                  178->trace(#do 'listVal:asgToNXoffSets3:'-> xT; mch.dumpReg #)
              if);
          if)              
       #);
     asgToMethod::
       (# V: ^ evVal
       do  301->trace(#
                     do 'listVal:asgToMethod:next:'->xT; next->xI; 
                        'type:'->xT; enterTypes[next]->xI; xN;
                        rDesc[] -> xA
                     #);
          
          (if false (*enterTypes[next] = 12*) (* repetition *)  then
              '\nlistVal:asgToMethod:toRep'->putline;
              (thisBaseAdr.copy,evl[]
              ,1 (* FIXME: we need the size *)
              ,none(* FIXME: ?*),lChain[],rChain[])
                -> asgList2Rep;
              next + 1 -> next
           else                    
              evl->scanList
              (# Ev: @ASTindex
              do currentNode->Ev;
                 301->trace(#
                           do 'listVal:asgToMethod:A:next:'->xT; next->xI; 
                              'type:'->xT; enterTypes[next]->xI 
                           #);
                 (thisBaseAdr.copy,Ev[],true,lChain[])->ExpEval->V[];
                 (if V[] = none then
                     '\nOBS! listVal:asgToMethod:V is none'->putline
                 if);
                 301->trace(#do 'listVal:asgToMethod:type'->xT; V.type -> xA;  #);
                 (enterTypes,noOfArgs,next,rDesc[],rChain[]) 
                   -> V.asgToMethod
                   -> next
          #)if)
       #);
     asgToExitArgs::
       (# xNo: @integer; V: ^evVal; xT: ^ExitTypes
       do (*'XA:listval:'->puttext;*)
          evl->scanList
          (# Ev: @ASTindex
          do currentNode->Ev;
             (thisBaseAdr.copy,Ev[],true,lChain[])->ExpEval->V[];
             301->trace(#do 'listVal:asgToExitArgs:'->xT; V.type -> xA #);
             (rDesc[],exitNo,originAdr[],rChain[]) 
               -> V.asgToExitArgs
               -> (xNo,xT[]);
             xT[] -> xTypes.concatenate -> xTypes[];
             exitNo + xNo -> exitNo;
          #);
       #);
     asgToInlineItem::
       (# inx: ^inlineNXitem
       do evl->scanList
          (# Ev: @ASTindex
          do currentNode->Ev;
             (thisBaseAdr.copy,Ev[],false,lChain[])->ExpEval->V[];
             (rDesc[],inlNX[],rChain[])->V.asgToInlineItem
          #);
          (*inlNX[]->inx[]; inx.eval->V[]*)
       #);
     asgToList::< (* assign evl=(le1,le2,...)->EV=(re1,re2,...) *)
       (# scanRevl: @ | 
            (# 
            do EV->scanList(#do currentNode->rEv; SUSPEND #)
            #);
          rEv: @ASTindex;
          W: @ListVal;
       do (if switch181 then
              evl->scanList
              (# EV: @ASTindex
              do currentNode->EV;
                 scanRevl;
                 (thisBaseAdr.copy,Ev[],false,lChain[])->ExpEval->V[];
                 (BA[],V[],rEv[],false,rChain[])->AssignValToEval->V[]; 
                 V.release
              #)
           else
              (if thisBaseAdr.regType//mch.thisO//mch.callO then
                  (if stest then
                      301->trace(#do 'ListVal:asgToList2:'->xT #)
                  if);
                  evl->scanList
                  (# EV: @ASTindex
                  do currentNode->EV;
                     scanRevl;
                     (thisBaseAdr.copy,Ev[],false,lChain[])->ExpEval->V[];
                     (BA[],V[],rEv[],false,rChain[])->AssignValToEval->V[];
                     V.release
                  #)
               else
                  (if switch180 then 
                      cError(#do 'listVal:asgToList:Wrong register'->xT #)
                  if);
                  BA[]->moveToCallReg
                  (#
                  do (*350->trace(#do 'PushThis6'-> xT #);*)
                     pushThis; 
                     thisBaseAdr[]->toThis->thisBaseAdr[];
                     evl->scanList
                     (# EV: @ASTindex
                     do currentNode->EV;
                        scanRevl;
                        (thisBaseAdr.copy,Ev[],false,lChain[])->ExpEval->V[];
                        (thisA[],V[],rEv[],false,rChain[])->AssignValToEval->V[]; 
                        V.release;
                     #);
                     thisA[]->BA[]; popThis
                  #)->BA[]; (* 27.4.93 - see asgToItem above *)
          if)if);
          (* return the right-side evalList, ev *)
          (ev[],BA[],rChain[])->W; W[]->V[]
       #);
     asgToDispatch::
       (# EL: [100] ^ASTindex; top: @integer;
          scanL:
            (# EV: ^ ASTindex; next,inc: @integer
            do (if sematt.cExt->mch.xParForward then 
                   1 -> inc; 1 -> next
                else -1 -> inc; top -> next
               if);
               (for i: top repeat
                    EL[next][] -> EV[];
                    INNER;
                    next + inc -> next
               for);                    
            #)
       do 301 -> ctrace
          (#
          do 'listVal:asgToDispatch:' -> xT; EV[] -> xA; xN;
             desc[]-> xA;
          #);
          evl->scanList
          (#
          do &ASTindex[]->EL[top+1->top][];
             currentNode->EL[top]
          #);
          (EV[],externalName[],desc[],extKind)
            -> GenCOMdispatch
          (#
          do scanL
             (# X: @integer
             do (thisBaseAdr.copy,EV[],false,lChain[]) -> ExpEval -> V[];
                V[] -> PushDispatchPar
             #);
          #) -> V[]
       #);
     asgToCproc::<
       (# CP: @ ExTernalCall; 
          EL: [100] ^ASTindex; top,max: @integer;
          chain1: ^DH.SuperChain; 
          inThis,popCall,popThis,arg2Saved: @boolean;
          savedArg2: @mch.dataRegOperand;
          callRegParNo: @integer
       do (if stest then
              301->ctrace(#do 'listVal:asgtoCproc:'->xT;  #);
          if);
          FixBase
          (#
          do EHchain[]->chain1[];
             (externalName,Desc[],extKind,EV.son)->CP; (* init *)
             evl->scanList
             (#
             do &ASTindex[]->EL[top+1->top][];
                currentNode->EL[top]
             #);
             (if extKind->mch.xParForward then
                 (* For some tstcproc.bet
                  * of the RISC's: mips, ppc, sparc (eventually),
                  * callReg is the same register as the 2nd argument register.
                  * (1) Before transferring external arguments, it must be
                  *     tested if callReg is busy, and if so, callReg MUST be
                  *     saved and later restored.
                  * (2) Evaluation of an argument may involve execution
                  *     of primitive operations, like AlloI, CopyT, etc; these
                  *     primitives may use argument registers; initPrimCall
                  *     will push possible busy arg. registers and getPrimRes
                  *     will restore them .....
                  * (3) Evaluation of arguments may call Beta procedures:
                  *     Eval of e.g. arg. 3:
                  *     Push arg1,arg2 (callreg)
                  *     AlloI -> callReg(arg2)
                  *     Pop arg1,arg2   - override callReg
                  *     .... transfer enter-params to callReg 
                  *     call M12FOO
                  *     We thus SAVE calReg(arg1) in a dataRegister when
                  *     it has been evaluated.
                  *     After AlloI we dont override callReg with arg. pop.
                  *     Before external call arg1 must be restored.
                  * RE 1. It seems that NO registers are ever stored before
                  * an external call? All busy registers should be saved?
                  * We now do it for MIPS/PPC - but should it be done
                  * in general?
                  *)
                 (if common.switch[61] then
                     (*mch.pushReg -> max; - dont work
                      * since some of the registers may have been released
                      * when the external is called. And then
                      * allocated after the call and then overwritten
                      * by mch.popReg
                      *)
                     (if extKind = sematt.VirtExt then
                         (* first arg. is theObject, so first eval
                          * in the list goes to callReg *)
                         1 -> callRegParNo
                      else
                         2 -> callRegParNo
                     if);                   
                     (if mch.callRegBusy and (top >= callRegParNo) then
                         (false,true) -> mch.pushThisOrCall;
                         true -> popCall;
                         (if thisBaseAdr.useCallReg then
                             (*350->trace(#do 'PushThis7'-> xT #);*)
                             pushThis;
                             true -> popThis;
			     thisBaseAdr[] -> toThis -> thisBaseAdr[];
                             (*'CallReg in use at ListVal:asgToCproc'
                              * ->systemError*)
                 if)if)if);
                 (if stest then
                     301->trace(#do 'ParNo: ' -> xT; callRegParNo -> xI;
                                  'extKind' -> xT; extKind -> xI#)
                 if);
                 (for i:top repeat
                      (thisBaseAdr.copy,EL[i][],false,lChain[])
                        -> ExpEval
                        -> V[];
                      (true->CP.getEnterP,extKind,CP.getEnterP.size
                      ,CP.pascExtProcInfo)
                        -> V.pushCpar;
                      (* arg2/callReg may be used during evaluation of 
                       * arg 3, 4, ... We thus save it and restore it
                       * when all arguments have been evaluated
                       *)
                      (if common.switch[61]
                          and (i = callRegParNo) and (top > callRegParNo) then
                          (* par no. 2 in callReg - MUST be saved *)
                          savedArg2.alloc; (* potentially dataReg overflow
                                            * if many nested C calls in
                                            * position of par. 2 of C-calls
                                            *)
                          (mch.callRegOp[],savedArg2[]) -> mch.cpReg;
                          true -> arg2Saved;
                          (* savedArg2[] -> mch.push (*data*)
                      if)
                 for);
              else                 
                 (for i:top repeat
                      (thisBaseAdr.copy,EL[top-i+1][],false,lChain[])
                        -> ExpEval
                        -> V[];
                      (false->CP.getEnterP,extKind,CP.getEnterP.size
                      
                      ,CP.pascExtProcInfo)
                        -> V.pushCpar;
                 for)
             if);
             (if arg2Saved then 
                 (*savedArg2[] -> mch.pop (*data*);
                 (savedArg2[],mch.callRegOp[]) -> mch.cpReg;
                 savedArg2.deAlloc
             if);
             CP.call;
             CP.getExitP->V[]; 
             (if popThis then (true,false) -> mch.popThisOrCall if);
             (if popCall then (false,true) -> mch.popThisOrCall if);
                 (*(if common.switch[61] then max -> mch.popReg if)*)
       #)#);
     asgToPrimitive::<
       (# CP: @primitiveCall; inThis: @boolean; chain1: ^DH.SuperChain
       do EHchain[]->chain1[];
          FixBase
          (# n: @integer
          do evl->scanlist(#do n+1->n (* this ONLY count 1 pr. elm!! *)#);
             (n,T[])->CP;
             evl->Scanlist
             (# EV: @ASTindex; V: ^EvVal
             do currentNode->EV;
                (thisBaseAdr.copy,EV[],false,lChain[])->ExpEval->V[];
                (3(* always long *),sematt.asmExt,0,0)->V.pushCpar;
             #);
             CP.call->V[];
       #)#);
     asgToInLinePrimitive::<
       (# xDr: [3] ^mch.dataRegOperand;  D: [3]@integer; Dmax,dRes: @integer;
          W: @ComputedEvVal; chain1: ^DH.SuperChain
       do EHchain[]->chain1[];
          FixBase
          (# dR1: ^mch.dataRegOperand
          do evl->scanList
             (# E: @ASTindex; V: ^evVal
             do currentNode->E; 
                (thisBaseAdr.copy,E[],false,lChain[])->ExpEval->V[];
                V.toDataReg->xDr[Dmax+1->Dmax][];
                xDr[Dmax]->D[Dmax]; (*V.release; !!*)
                (*350->trace(#do mch.dumpReg #)*)
             #);
             (opCode,I1,I2,D)->gen.inLinePrimitive->dRes->W.dr;
             W[]->V[];
             (for i: Dmax repeat
                  (if dRes = D[i] then else xDr[i].deAlloc if);
       for)#)#);
     asgToNewPrim::<
       (# EV1,EV2,op: @ASTindex; lv,rv,V1,V2: ^evVal; 
          opCode,pos,length,val: @integer;
	  dr,lDr,rDr,pDr,wDr: ^mch.dataRegOperand; 
          opT: ^text; A: ^mch.address;
	  ar: @mch.adrRegOperand;

          putBW:
            (* (val,byteNo)->A.putByte/Short *)
	    (* (@@A,val)->putByte/Short *) 
          (# size: @integer; bsNo: @integer
          enter size
          do (if switch182 then 
                 size -> putBWforByteCode
              else
                 evl->scanList
                 (# E: @ASTindex; i: @integer; dr1: ^mch.dataRegOperand
                 do currentNode->E;
                    (if i+1->i
                     // 1 then (* val *)
                        (baseAdr.copy,E[],false,rchain[])->ExpEval->lv[];
                     // 2 then (* byteNo *) 
                        E[]->getConst->(bsNo,V1[]); 
                        (if V1[] = none then
                            (if size = 2 then bsNo*2->bsNo if);
                            bsNo->A.addOff->A[]
                         else
                            V1.loadVal2->V1[]; (*Check this evrywhere*)
                            V1.toDataReg->dr1[];
                            (A[],dr1[],size)->primIndex->A[]
                        if)
                    if);
                 #) ;
                 lv.toDataReg->dr[];
                 (if size
                  // 1 then (dr[],A[])->mch.stByte
                  // 2 then (dr[],A[])->mch.stHalf
                  // 4 then (dr[],A[])->mch.stVal
                 if);
                 A.freeAdr; (* cleared if InxRegAdr *)
                 (dr,false,false,false)->mkComputedEvVal->V[]
                 (* A.aReg does NOT denote a real object - must be cleared *)
             if)
          #);
          putBWforBytecode:
            (# size,off: @integer; val,offSet: @ASTindex; V: ^evVal;
               eval:
                 (# shift: @integer
                 enter shift
                 do (baseAdr.copy,val[],false,rchain[])->ExpEval->lv[];
                    true -> lv.pushVal;
                    (if shift > 0 then
                        (mch.dataTop[],shift->mch.newCstOp)
                          -> mch.logicalShiftLeft;
                    if);
                    (mch.dataTop[],mch.dataTop[],4) -> mch.gOr
                 #)
            enter size
            do mch.duplicate;
               (A[],&mch.dataRegOperand[]) -> mch.ldVal;
               evl->scanList
               (# i: @integer
               do (if i+1 -> i
                   // 1 then currentNode -> val
                   // 2 then currentNode -> offSet
               if)#);
               offSet[] -> getConst -> (off,V[]);
               (if size
                // 1 then 
                   (if V[] = none then
                       (if off
                        // 0 then
                           (mch.DataTop[],0x00FFFFFF->mch.newCstOp,4) 
                             -> mch.gAnd;
                           24 -> eval
                        // 1 then
                           (mch.DataTop[],0xFF00FFFF->mch.newCstOp,4) 
                             -> mch.gAnd;
                           16 -> eval
                        // 2 then
                           (mch.DataTop[],0xFFFF00FF->mch.newCstOp,4)
                             -> mch.gAnd;
                           8 -> eval;
                        // 3 then
                           (mch.DataTop[],0xFFFFFF00->mch.newCstOp,4) 
                             -> mch.gAnd;
                           0 -> eval
                       if);
                    else
                       '\nBytecode:putBW: '
                       'missing implementation '
                       'for computed byte position'
                         -> putline
                   if)
                // 2 then
                   (if V[] = none then
                       (if off
                        // 0 then
                           (mch.DataTop[],0x0000FFFF->mch.newCstOp,4) 
                             -> mch.gAnd;
                           16 -> eval
                        // 1 then
                           (mch.DataTop[],0xFFFF0000->mch.newCstOp,4) 
                             -> mch.gAnd;
                           0 -> eval
                       if);
                    else
                       '\nBytecode:putBW: '
                       'missing implementation '
                       'for computed short position'
                         -> putline
                   if)
                   
               if);
               (mch.dataTop[],A[]) -> mch.stVal
            #); 
          inxPut:
	    (* (val,inx)->R.inxPut/byte/short/long *)
	    (* (R,inx,val) -> inxPut/byte/short/long 
             * R is a repetition
	     * D[1]=adr(R), D[2]=inx, D[3]=val 
             *)
          (# val: ^mch.dataRegOperand;      
             size: @integer (* 0=byte, 1=word, 2=long *);
             oldS14,oldS15: @boolean
          enter size
          do (if switch182 then
                 size -> inxPutForByteCode
              else
                 common.switch[14]->oldS14; common.switch[15]->oldS15;
             true->common.switch[14]->common.switch[15];
             evl->scanList
             (# E: @ASTindex;; i: @integer
             do currentNode->E;
                (if i+1->i
                 // 1 then
                    (baseAdr.copy,E[],false,rchain[])->ExpEval->lv[];
                    lv.toDataReg->val[];
                 // 2 then
                    (baseAdr.copy,E[],false,rchain[])->ExpEval->lv[];
                    lv.toDataReg->dr[];
                if);
             #);
             (dr,true,size)->A.index->A[];
             size->A.addOff->A[]; (* check that this works *)
             (if size
              // 1 then (val[],A[])->mch.stByte
              // 2 then (val[],A[])->mch.stHalf
              // 4 then (val[],A[])->mch.stVal
             if);
             oldS14->common.switch[14]; oldS15->common.switch[15];
             (* A.aReg does NOT denote a real object - must be cleared *)
             A.freeAdr; (* cleared if InxRegAdr *)
             (val,false,false,false)->mkComputedEvVal->V[]
             if)
          #);
          inxPutForByteCode:
            (# size: @integer;
               val,offSet: @ASTindex;
               AR: @mch.InxRegAdr;
               tA: ^mch.address;
               doIndex:
                 (# size,        (* 1: putByte
                                  * 2: putShort
                                  * 4: putLong
                                  *)
                    repElmSize: @integer (* element size of repetition *)
                 enter(size,repElmSize)
                 do A.receiverType[] -> AR.receiverType[];
                    'index' -> AR.fieldName[];
                    (if repElmSize
                     // 1 then 'C' -> AR.fieldType[];
                     // 2 then (theGen.int16value).asText  -> AR.fieldType[]
                     // 4 then (theGen.int32value).asText  -> AR.fieldType[]
                    if);
                    (* evaluate index *)
                    (baseAdr.copy,offset[],false,rchain[])->ExpEval->lv[];
                    lv.pushVal;
                    (* stack = [... rep,index 
                     *)
                    (* adjust index
                     * size 1: no adjustment
                     * size 2: multiply by 2
                     * size 4: multiply by 4
                     *)
                    (if size > 1 then
                        (size -> mch.newCstOp,mch.dataTop[],4) -> mch.gMult
                    if);
                        
                    mch.duplicate;
                    (repElmSize->mch.newCstOp,mch.dataTop[]) -> mch.ldCst;
                    (mch.dataTop[],&mch.doubleDataRegOperand[],false(*mod*)) 
                      -> mch.gDiv;
                    (if size < 4 then (* ??4 *)
                        (8->mch.newCstOp,mch.dataTop[]) -> mch.ldCst;
                        (mch.dataTop[],mch.dataTop[],4) -> mch.gMult;
                    if);
                    (* store in tmp *)
                    AR.fieldType[]
                      -> theGen.allocAndStoreTmp 
                      -> tA[];
                    (repElmSize->mch.newCstOp,mch.dataTop[]) -> mch.ldCst;
                    (mch.dataTop[],&mch.doubleDataRegOperand[],true(*div*)) 
                      -> mch.gDiv;
                    
                    (* duplicate rep & index *)
                    (0,true) -> mch.duplicate;
                    (AR[],mch.dataTop[]) -> mch.ldVal;
                    (if size
                     // 1 then
                        (0x00FFFFFF->mch.newCstOp,mch.dataTop[]) 
                          -> mch.ldCst;
                     // 2 then
                        (0x0000FFFF->mch.newCstOp,mch.dataTop[]) 
                          -> mch.ldCst;
                    if);
                    (tA[],mch.dataTop[]) -> mch.ldVal;
                    (mch.dataTop[],mch.dataTop[]) -> mch.rotateRight;
                    
                    (mch.dataTop[],mch.dataTop[],4) -> mch.gAnd;
                 #);
               eval:
                 (# size,repElmSize: @integer
                 enter(size,repElmSize)                    
                 do (baseAdr.copy,val[],false,rchain[])->ExpEval->lv[];
                    true->lv.pushVal;
                    (* stack = [ ...,rep,index,rep[index],val *)
                    (if true
                     // (size=1) and (repElmSize=4) then
                        (24->mch.newCstOp,mch.dataTop[]) -> mch.ldCst;
                        (tA[],mch.dataTop[]) -> mch.ldVal;
                        (mch.dataTop[],mch.dataTop[],4) -> mch.gSub;
                        (mch.dataTop[],mch.dataTop[]) 
                          -> mch.logicalShiftLeft;
                        (mch.dataTop[],mch.dataTop[],4) -> mch.gOr;
                     // (size=2) and (repElmSize=4) then
                        (16->mch.newCstOp,mch.dataTop[]) -> mch.ldCst;
                        (tA[],mch.dataTop[]) -> mch.ldVal;
                        (mch.dataTop[],mch.dataTop[],4) -> mch.gSub;
                        (mch.dataTop[],mch.dataTop[]) 
                          -> mch.logicalShiftLeft;
                        (mch.dataTop[],mch.dataTop[],4) -> mch.gOr;
                        
                    if)
                 #)
            enter size
            do (if not common.switch[188] then
                   1->trace
                   (#
                   do (if size
                       // 1 then
                          (if A.size
                           // 1 then
                              'PutInt8:in:int8'->putline
                           // 2 then
                              'PutInt8:in:int16'->putline
                           // 4 then
                              'PutInt8:in:int32'->putline
                           else
                              '\nA.size:undefined'->putline
                          if)
                       // 2 then
                          (if A.size
                           // 1 then
                              'PutInt16:in:int8'->putline
                           // 2 then
                              'PutInt16:in:int16'->putline
                           // 4 then
                              'PutInt16:in:int32'->putline
                           else
                              '\nA.size:undefined'->putline
                          if)
                       // 4 then
                       else
                          '\nsize:undefined'->putline
                      if)
                   #);
               if);
               evl->scanList
               (# i: @integer
               do (if i+1->i
                   // 1 then
                      currentNode -> val
                   // 2 then
                      currentNode -> offSet
                  if);
               #);
               (* load the repetition *)
               (A[],mch.dataTop[]) -> mch.ldVal;

               (if size
                   // 1 then
                      (if A.size
                       // 1 then 
                          (* no index adjustment;
                           * ad in fact we need not load, mask and or
                           * the value since it is putbyte to a byte array
                           *)
                          doIndex; 
                          (* stack = [ ...,rep,index,rep[index] *)
                          eval;
                          (* stack = [ ...,rep,index,rep[index],val *)
                          (mch.dataTop[],mch.dataTop[],4) -> mch.gOr;
                          (mch.dataTop[],AR[]) -> mch.stVal
                       // 2 then

                       // 4 then
                          (* we need to select the right int32 element
                           * of the repetition: offset div 4;
                           * and then the right part of the int32 word:
                           * offset mod 4 - +/- 1
                           *)
                          (1,4) -> doIndex; 
                          (* stack = [ ...,rep,index,rep[index] *)
                          (1,4) -> eval;
                          (* stack = [ ...,rep,index,rep[index],val *)

                          (mch.dataTop[],AR[]) -> mch.stVal
                       else
                          '\nA.size:undefined'->putline
                      if)
                // 2 then
                      (if A.size
                       // 1 then 
                          '\nR%.putShort where R: [e] @char/int8/int8u'
                          ' is not implemented' -> putline;
                       // 2 then
                          '\nR%.putShort where R: [e] @int16/int16u'
                          ' is not implemented' -> putline;
                       // 4 then
                          (* we need to select the right int32 element
                           * of the repetition: offset div 4;
                           * and then the right part of the int32 word:
                           * offset mod 4 - +/- 1
                           *)
                          (2,4) -> doIndex; 
                          (* stack = [ ...,rep,index,rep[index] *)
                          (2,4) -> eval;
                          (* stack = [ ...,rep,index,rep[index],val *)

                          (mch.dataTop[],AR[]) -> mch.stVal
                       else
                          '\nA.size:undefined'->putline
                      if)
                   
                // 4 then
                      (if A.size
                       // 1 then 
                          '\nR%.putLong where R: [e] @char/int8/int8u'
                          ' is not implemented' -> putline;
                       // 2 then
                          '\nR%.putLong where R: [e] @int16/int16u'
                          ' is not implemented' -> putline;
                       // 4 then
                          (* we need to select the right int32 element
                           * of the repetition: offset div 4;
                           * and then the right part of the int32 word:
                           * offset mod 4 - +/- 1
                           *)
                          (4,4) -> doIndex; 
                          (* stack = [ ...,rep,index,rep[index] *)
                          (4,4) -> eval;
                          (* stack = [ ...,rep,index,rep[index],val *)

                          (mch.dataTop[],AR[]) -> mch.stVal
                       else
                          '\nA.size:undefined'->putline
                      if)

                else
                   '\nsize:undefined'->putline
               if);
            #);
               
          getConst: 
            (# E: ^ASTindex; T: ^text; val: @integer; V: ^evVal
            enter E[]
            do (if E.label = gram.integerConst then
	           E.getText->T[]; 0->T.setPos; T.getInt->val
		else 
		   (thisBaseAdr.copy,E[],false,rchain[])->ExpEval->V[]
	       if)
            exit(val,V[])
            #);
	  ClrAndDeAlloc:
            (# ar: @mch.adrRegOperand
            enter ar
            do ar[]->mch.gClr; ar.deAlloc
            #)
       do 301->trace(#
                    do 'asgToNewPrim:'->display; xN;
                       EV[]->xA; 
                    #);
          EV.son-> EV1; EV1.son->EV1; Ev1.brother->op;
          (baseAdr.copy,EV1[],false,rchain[])->genAdr->A[];
          (if op[]->sematt.primitiveToNumber->opCode
           // 9 (* putByte *) then 
	      (if EV.evalKind = sematt.repValEval then 
                  1->inxPut
	       else 1->putBW
	      if)
           // 10 (* putShort *) then 
	      (if EV.evalKind = sematt.repValEval then 
                  2->inxPut
	       else 2->putBW
	      if)
           // 31 (* putLong *) then
	      (if EV.evalKind = sematt.repValEval then 
                  4->inxPut
	       else (* sematt.simpleEval, realVal, ... *) 
                  4->putBW
	      if)
           // 19 (* (pos,length)->R.%getBits    *)
           // 20 (* (pos,length)->getSignedBits *) then
	      (* address of R is in A *)
              (# dr: @mch.dataRegOperand; pos,length: @integer
              do dr.alloc; (A[],dr[])->mch.ldVal; A.freeAdr;
	         evl->scanList
                 (# E: @ASTindex;; i: @integer
                 do currentNode->E;
                    (if i+1->i
                     // 1 then (* pos *) E[]->getConst->(pos,V1[])
                     // 2 then (* length *) E[]->getConst->(length,V2[]);
                    if);
                 #) ;
	         (* V1[]=nil => pos is constant
	          * V2[]=nil => length is constant
	          *)                 
	         (if (V1[]<>none) or (V2[]<>none)  then
                     (V1[],pos)->const2Reg->pDr[];
                     (V2[],length)->const2Reg->wDr[];
                     (if opCode=19 then
                         (dr[],pDr[],wDr[])->mch.gGetBits
                      else
                         (dr[],pDr[],wDr[])->mch.gGetSignedBits
                     if)
                  else
	             (if opCode = 19 then 
                         (dr[],pos,length,dr[],none)->mch.getBits
	              else (dr[],pos,length,dr[],none)->mch.getSignedBits
	         if)if);
	         (dr,false,false,false)->mkComputedEvval->V[];
	      #)
           // 21 (* (Val,pos,length)->R.%putbits *) then 
	      evl->scanList
              (# E: @ASTindex;; i: @integer
              do currentNode->E;
                 (if i+1->i
                  // 1 then (* val *) E[]->getConst->(val,V[])
                  // 2 then (* pos *) E[]->getConst->(pos,V1[])
                  // 3 then (* length *) E[]->getConst->(length,V2[])
                 if);
              #);
	      A.toReg2->ar; ar.mkIndirect;
              (V[],val)->const2Reg->lDr[];
              (if v1[]=none then (* pos is constant *)
                  (if v2[]=NONE then (* pos and width are constant *)
                      (* the current case of putBits *)
                      (lDr[],pos,length,ar[],none)->mch.putBits
                   else (* length is variable *)
                      (* general case *)
                      (V1[],pos)->const2Reg->pDr[];
                      V2.toDataReg->wDr[];
                      (lDr[],pDr[],wDr[],ar[])->mch.gPutBits
                  if)
               else 
                  V1.toDataReg->pDr[];
                  (if (v2[]=NONE) then
                      (V2[],length)->const2Reg->wDr[];
                      (lDr[],pDr[],wDr[],ar[])->mch.gPutBits
                   else 
                      (* pos is variable *)
                      (* general case *)
                      V2.todataReg->wDr[];
                      (lDr[],pDr[],wDr[],ar[])->mch.gPutBits
              if)if);
              (lDr,false,false,false)->mkComputedEvval->V[];
              (* the following call is 'inherited' from the old primitive-code
               * from gen1body! It is a coincidence that it works,since ar 
               * is marked as indirect. This should generate set 0, [%ar].
               * It works since ar is transferred by value, which does NOT
               * transfer the inDirect flag!!!! Ugly:-(
               *)
              ar->ClrAndDeAlloc;
          if)
       #);
     pushCPar::<(#do 'ListPushCpar'->NotImpl #);
     FixBase:
       (# 
       do (if thisBaseAdr.regType//mch.thisO//mch.callO then
              INNER
           else
              (if switch180 then 
                  cError(#do 'listVal:FixBase:Wrong register'->xT #)
              if);
                  (*350->trace(#do 'PushThis8'-> xT #);*)
              pushThis; thisBaseAdr[]->toThis->thisBaseAdr[];
              INNER;
              popThis
       if)#);
     
     evl: ^ASTindex; 
     thisBaseAdr: ^mch.address;
     lChain: ^DH.SuperChain;
     (* evl must be evaluated relative to thisBaseAdr *)
  enter(evl[],thisBaseAdr[],lChain[])
  #);
