ORIGIN 'evlib';
BODY 'auxbody'
---EvalLib:attributes---
asgToNewRep:
  (* first version of 
   *       (e1,e2, ...) -> aRep
   * and
   *        e -> aRep
   * A repetition object is allocated;
   * - the elements in the evaluation (evl) are evaluated and assigned to 
   *   the corresponding elements of the repetition;
   * - during evaluation of evl, the address of the repetition 
   *   is in a register;
   * - for each element in evl, its value is stored relative to the
   *   repetition address;
   * - it is important that the register always refers the
   *   repetition and not its elements, since a GC may happen
   *   during evaluation of evl;
   * - after evaluation of evl, the register is stored
   *   back in the attribute (rA), since someone may have
   *   manipulated the repetitoon attribute, e.g. changed its
   *   range and the is no range check for assigning elements
   *   of evl to the repetition elements.
   * Missing:
   * - decide value or ref rep or general rep;
   *   not so easy, since asgToRepAdr is used for texts returned
   *   from external, etc.
   * - re-consider if we can run out of address registers,
   *   since aR and rA are busy during the evaluation of evl 
   *)
  (# isValueRep: @boolean; 
     size,theRange,inx: @integer;
     rA: ^mch.address;
     rAelm: @mch.RegAdr; 
     aR,RR: @mch.AdrRegOperand;
     restore_rA: @boolean;
     NextElmAdr: @
       (#
       do inx +1 -> inx;
          4*4 + (inx-1)*size -> rAelm.off;
       exit rAelm[]
       #);
  enter(isValueRep,size,theRange,rA[])
  <<SLOT asgToNewRep:doPart>>
  exit rA[]
  #);
loadAdrOp: 
  (* in cases like ch: @char; a,b: @integer;
   * a*b+ch, code like addByte,ch,dataReg has to be generated.
   * ch must be loaded to dataReg since addByte(ch),dataReg only will
   * operate on 8-bit of MC68 dataReg
   *)
  (# Ax: ^mch.address; op: ^mch.mOperand; drx: @mch.dataRegOperand
  enter Ax[]
  do (if Ax.size//1//2 then (* byte/word*)
         drx.alloc; (Ax[],drx[],AX.size)->mch.ldVl; drx[]->op[];
         INNER;
         drx.deAlloc
      else (*long*) Ax[]->op[]; INNER
     if)
  #);
const2Reg:
  (# V: ^evVal; val: @integer; dr: ^mch.dataRegOperand
  enter(V[],val)
  do (if V[]=none then
         &mch.dataRegOperand[]->dr[]; dr.alloc; 
         (val->mch.newCstOp,dr[])->mch.ldCst
      else
         V.toDataReg->dr[]
     if)
  exit dr[]
  #);
primIndex:
  (* used for implementing
   *    (val,e)->X.%putByte, etc where X is a simple integer, etc.
   * A  is the address of X and dr has the value of e.
   * primIndex returns an inxRegAdr denoting the byte, etc.
   *)
  (# A: ^mch.address; dr: ^mch.dataRegOperand; size: @integer;
     IA: @mch.inxRegAdr; RA: ^mch.regAdr; 
  enter(A[],dr[],size)
  do (if size=4 then leave primIndex if);
     (if size=2 then
         (1->mch.newCstOp,dr[])->mch.logicalShiftLeft
     if);
     (0x3->mch.newcstOp,dr[],4)->mch.gAnd; (* dr mod 4 -> dr *)
     (if A.access = common.direct then
         (if A## = mch.regAdr## then
             A[]->RA[];
             RA.reg->IA.aReg; RA.off->IA.off
          else 
             A.toReg2->IA.aReg
         if)
      else
         '\n***Indirect in primIndex: never tested!'->putLine;
         A.toReg2->IA.aReg; 
     if);
     dr->IA.dReg; A.frozenReg->IA.frozenReg; 
     (if size // 1 // 2 then
         1->IA.size; (* Note we set the size to 1 here!
                      * (x.%getByte) (x.%getShort)
                      * Note that we set size to 1 for byte AND short.
                      * The reason is that IA is a byte address,
                      * but the index HAS been multiplied by the size.
                      * Only Intel uses the size.
                      * This is ugly.
                      * This may be a problem elsewhere
                      *)
     if);
     IA[]->A[]
  exit A[]
  #);
primGet2:
  (* get mem[A + (dr mod 4 )]  *)
  (# A: ^mch.Address; dr: ^mch.dataRegOperand; 
     size: @integer; signed: @boolean;
     V: ^evVal;
     val: @mch.dataRegOperand; 
  enter(A[],dr[],size,signed)
  do val.alloc;
     (A[],dr[],size)->primIndex->A[]; signed -> A.signed;
     (if size
      // 1 then (*val[]->mch.gClr;*) (A[],val[])->mch.ldByte
      // 2 then (*val[]->mch.gClr;*) (A[],val[])->mch.ldHalf
      // 4 then (A[],val[])->mch.ldVal
     if);
     (if common.targetMachineId 
      // common.sun4s
      // common.nti_ms
      // common.nti_gnu
      // common.nti_bor
      // common.nti 
      // common.linux then
         (* sign extension is done in XXXmachine.LdByte etc. *)
      else
         (if signed then
             (if size
              // 1 then val[]->mch.SignExtByte
              // 2 then val[]->mch.SignExtWord
             if)
         if)
     if);
     (*A is NOT referring an object - must be cleared upon release *)
     A.freeAdr; (* is cleared if InxRegAdr - no clear needed for RegAdr *)
     (val,false,false,false)->mkComputedEvVal->V[]
  exit V[]
  #);
primGet:
  (# A: ^mch.Address; I1,size,reg: @integer; signed: @boolean;
     V: ^evVal; T0: @mch.dataRegOperand; 
  enter(A[],I1,size,signed)
  do T0.alloc;
     I1->A.addOff; signed -> A.signed;
     (if size
      // 1 then (*T0[]->mch.gClr;*) (A[],T0[])->mch.ldByte;
      // 2 then (*T0[]->mch.gClr;*) (A[],T0[])->mch.ldHalf
      // 4 then (A[],T0[])->mch.ldVal
     if);
     (if common.targetMachineId 
      // common.sun4s
      // common.nti_ms
      // common.nti_gnu
      // common.nti_bor
      // common.nti
      // common.linux then
         (* sign extension is done in XXXmachine for ldByte etc. *)
      else
         (if signed then
             (if size
              // 1 then T0[]->mch.SignExtByte
              // 2 then T0[]->mch.SignExtWord
             if)
         if)
     if);
     (T0,false,false,false)->mkComputedEvVal->V[];
     (* A.aReg should denote a real object - no clear needed! *)
  exit V[]
  #);
primInxGet:
  (* inx ->R.%inxGet/byte/short/long -> val
   * R is a repetition
   * dr: register with 'inx'
   * rA: address of R
   *)
  (# rA: ^mch.address;
     dr: ^mch.dataRegOperand; val: @mch.dataRegOperand; 
     size: @integer; signed: @boolean;
     V: ^evVal; oldS14,oldS15: @boolean
  enter(dr[],rA[],size,signed)
  do common.switch[14]->oldS14; common.switch[15]->oldS15;
     true->common.switch[14]->common.switch[15];
     val.alloc; 
     (if size
      // 1 then 
         (dr,true,1)->rA.index->rA[];
         1->rA.addOff->rA[];
         (*val[]->mch.gClr; *)
         signed -> rA.signed;
         (rA[],val[])->mch.ldByte
      // 2 then 
         (dr,true,2)->rA.index->rA[];
         2->rA.addOff->rA[];
         (*val[]->mch.gClr; *)
         signed -> rA.signed;
         (rA[],val[])->mch.ldHalf
      // 4 then 
         (dr,true,4)->rA.index->rA[];
         4->rA.addOff->rA[];
         signed -> rA.signed;
         (rA[],val[])->mch.ldVal
     if);
     (if common.targetMachineId 
      // common.sun4s
      // common.nti_ms
      // common.nti_gnu
      // common.nti_bor
      // common.nti
      // common.linux then
         (* sign extension is done in XXXmachine for ldByte etc *)
      else
         (if signed then
             (if size
              // 1 then val[]->mch.SignExtByte
              // 2 then val[]->mch.SignExtWord
             if)
         if)
     if);
     (* rA.aReg does NOT denote a real object - release *)
     rA.freeAdr; (* cleared if inxRegAdr which it is! *)
     (val,false,false,false)->mkComputedEvVal->V[];
     oldS14->common.switch[14]; oldS15->common.switch[15]

  exit V[]
  #);
CopyT:
  (# resType: @integer;
     dr: @mch.DataRegOperand;
     old61: @boolean;
     rA: ^mch.address;
  enter(rA[],resType)
  do 4 -> mch.initPrimCall;
    (* common.switch[61] -> old61; 
     true->common.switch[61];*)
     INNER;
     2 -> rA.pushRegAndOff;
     (* old61 -> common.switch[61];*)
     'CopyT'-> mch.callPrim;
     resType -> mch.getPrimRes -> dr
  exit dr
  #);
