ORIGIN 'bytecodeval'
---bytecodevalbody:dopart---
do EV.son -> VN;
   (if stest then
       301->trace(# 
                 do 'mkBytecodeCall: ' -> xT; EV[] -> xA; VN[] -> xA;
                    EV.sonRef -> xA
                 #)
   if);
   thisDesc -> theThisDesc;
   (if VN.label = gram.objectDescriptor then
       (* make sure that innerdesc.getID is defined *)
       (VN,common.itemKind,2,null)->DS.push;
   if);
   (EV.sonRef,chain[],true) -> sig.setMethodDesc; 
   &ASTindex[] -> receiverDesc[]; 

   (if VN.label 
    // gram.remote then
       (# md,org: @ASTindex; mdo: ^ASTindex
       do (* VN = R.foo *) 
          VN.son -> receiver;
          receiver.brother -> method;
          sig.thisMethodDesc.origin -> org;
          (if org.label = gram.attributesForm then
              true -> isStatic;
           else
              (if false then
                  (if receiver.label = gram.thisObject then
                   else
                      (* OBS receiver is NOT used anymore *)
                      receiver -> sematt.getName -> receiver; 
                  if);
                  (* receiver = R, method = foo *)  
                  (* NOTE! below is an alternative - and correct - method
                   * for computing the desc of the receiver; we just use
                   * the origin of the method desc. In most cases this is the
                   * same as above, but for virtual methods bound to global
                   * patterns, this is not the same; the above code should
                   * be removed
                   *)
              if);
              (* EV = R.foo 
               * NOTE: EV is reference or similar, and then
               *       EV.sonRef = (remote <R> <foo> )
               *)
              301->trace(#
                        do 'mkBytecodecall:remote:'->xT; 
                           EV[] -> xA;
                           ' sonRef: '->xT; EV.sonRef -> xA
                        #);
              (thisDesc[],EV.sonRef) 
                -> GetActualDesc 
                -> (md,descKind);
              301->trace(#
                        do 'mkBytCodeCall: ' -> xT; md[] -> xA
                        #);
              (* Problem with
               *   T: (# foo: (# ... #) #)
               *   TT: T(# #);
               *   R: ^TT
               *   R.foo
               * method:  (# ... #) i.e. desc of foo
               * receiver: origin(method) = T
               * it should be TT
               *   T: (# V:< A #);
               *   TT: T(# V:: AA #);
               *   TTT: TT (# #)
               *   S1: ^TT;
               *   S2: ^TTT
               *   S1.V;  - is reciever origin of AA or the most specific
               *   S2.V   - subpattern of origin of AA? 
               *            then it is complicated
               *)
              md[] -> sematt.descOrigin -> mdo[];
              301->trace(#
                        do 'mkByteCall:remote:mdo:'->xH; mdo[] -> xA; xN;
                           md[] -> xA
                        #);
              (EV.sonRef,mdo[],md[]) -> findReceiver -> mdo[];
              mdo -> receiverDesc;
              true -> isRemote;
              (if true then
                  (* compute receiver as actual desc of R in R.foo 
                   * previously we could not do this for virtuals
                   * bound to global patterns???
                   *)
                  
              if);
              (if (md->sematt.descKind) 
               // sematt.staticProcKind then
                  true -> isRealStatic;
                  sig.markRealStatic; (* isStatic is used for
                                       * patterns at outermost levels
                                       * in lib-files
                                       *)
               // sematt.consKind then
                  301->trace(#
                            do 'mkByteCodeCall:cons: '->xT;
                               'methodDesc: ' -> xT; md[] -> xA; xN;
                               'receiverDesc: '->xT; receiverDesc[] -> xA;
                            #);
                  (* Create instance of: receiverDesc
                   * with constructor  : methodDesc
                   *)
                  true -> isCons;
                  md -> method
              if);
              301 -> trace(# 
                          do 'mkByteCodeCall:remote:2: ' -> xH;
                             'methodDesc: ' -> xT; md[] -> xA; xN;
                             'receiverDesc: '->xT; receiverDesc[] -> xA;
                          #)
          if)
       #)
          
    // gram.nameApl then
       (* VN = foo 
        * means: originN....origin2.origin1.foo
        * N >= 0
        *)
       VN -> method;
       testLibLevel: (* is this a pattern at the outermost lib level *)
         (# org: @ASTindex
         do sig.thisMethodDesc.origin -> org;
            (* dont work if virtual?*)
            (if org.label = gram.attributesForm then
                301->trace(#
                          do 'Pattern: ' -> xT;
                             VN[] -> xA;
                             ' is at the outermost lib level' -> xT
                          #);
                true -> isStatic;
             else
                (* check the case where VN is as in
                 *     VN: @<<SLOT XXX:descriptor>>
                 *   do ...; VN; ...
                 *   ---XXX:descriptor---
                 *   (# ... enter(...) do ... exit ... #)
                 * I.e. the enter/exit-part is in the form;
                 *)
                (# D: @ASTindex
                do VN.descRef -> D;
                   (if D.isSlot then
                       D.slotOrigin -> D;
                       (if D.label = gram.attributesForm then
                           true -> isStatic;
                           leave testLibLevel
                   if)if)
                #);
                (* to find originN, go origin meth.N times *)
                thisDesc -> receiverDesc;
                (for i: method.on repeat
                     receiverDesc[] -> sematt.descOrigin -> receiverDesc[]
                for);
                (if false then
                    (* ok for calling V declared as V:: T
                     * not ok for     V declared as V:< T
                     *)
                    (# md: @AStindex; mdo: ^AStindex
                    do (thisDesc[],EV.sonRef) 
                         -> GetActualDesc 
                         -> (md,descKind);
                       md[] -> sematt.descOrigin -> mdo[];
                       mdo -> receiverDesc;                  
                #)if)
            if);
         #)
    // gram.objectDescriptor then
       301->trace(#
                 do 'objectdescriptor: ' -> xT;
                    VN[] -> xA;
                 #);
       VN -> method; (* NOTE: VN IS AN OBJECTDESCRIPTOR *)
       method -> receiverDesc;
       (* Here we need to find the right origin of the method *)
       receiverDesc[] -> sematt.descOrigin -> receiverDesc[];
       (if receiverDesc.label 
        // gram.descriptorForm 
        // gram.doPart then
           receiverdesc.xorigin -> receiverdesc;
           receiverdesc.slotOrigin -> receiverdesc;
       if);
       true -> isSingular;

    // gram.unExpanded then
       301->trace(#
                 do 'MkByteCodeCall:DescriptorSlot: ' -> xT; VN[] -> xA 
                 #);
       VN[] -> sematt.enclosingDesc -> receiverDesc[];
       
       receiverDesc[] -> theGen.descLocation -> sig.location[];
       301->trace(#
                 do 'mkByteCodeCall:unExpanded:receiverLocation: "' -> xT;
                    (if sig.location[] = none then 
                        'none' -> xT
                     else 
                        sig.location[] -> xT
                    if);
                    '"' -> put
                 #);
       VN -> method;
       (VN,common.itemKind,3,VN) -> DS.push;
       true -> isSingular (* hack *)
    // gram.computedRemote then
       (# MN,isVirt: @integer; xchain: ^DH.superChain;
          remEv,N,ref,refDesc: ^ASTindex;
          (* (E).method 
           * DOES NOT WORK
           *)
       do VN.son -> receiver;
          receiver.brother -> method;
          L: receiver->scanList(#do currentNode->receiver; leave L #);
          301->trace(#
                    do 'mkByteCodeCallX: ' -> xT;
                       VN[] -> xA
                    #);
          (VN[],DH[],chain[]) 
            -> sematt.chkComputedEval 
            -> (remEv[],N[],ref[],receiverDesc[],xchain[]);
          301->trace(#
                    do 'mkByteCodeCallY: ' -> xT;
                       receiverDesc[] -> xA
                    #);
       #)
    else
       '\n**** insert is NOT remote or nameApl'->putline
   if);
   (if isCons then
      (* 1->trace(#
                 do 'cons: ' -> xT; receiverdesc[]->xA #);*)
       (receiverDesc[],common.itemKind) -> theGen.newInstance
       (# 
       do (method[],false,chain[]) -> consSig.addConstructorDesc;
          (*1->trace(#
                  do 'X:'->xT; conssig.astext->xT; xN;
                     hasOrigin -> xB;
                     100->switchon;
                     method[]->xA;xN;
                     VN[] -> xA;
                     100->switchoff
                  #);*)
          false -> sig.isStatic;
          'olsen' -> sig.addMethod;
          method[] -> sig.addEnter;
          sig.setVoidXSig; 
          (*1->trace(#do sig.astext -> xT #);*)
          ((receiverDesc[],true) -> descName,receiverDesc[]) 
            -> sig.addReceiver;
          (if hasOrigin then '\ngenorg'->putline;
              (baseAdr.copy,theThisDesc[],VN[],EHchain[])
                -> genOrgAdrToOrgReg
                -> OA[];
          if);
          INNER MkByteCodeCall
       #);
       (mch.thisRegOp,false,EV[],chain[]) -> mkComputedRefEvVal -> W[]
    else
       (if not isStatic then
           ('G',receiverDesc[]) -> mkEntryPoint -> (class[],local);
           301->trace(#
                     do 'mkByteCodeCall:receiver: ' -> xT; class[] -> xT; xN;
                        receiverDesc[] -> xA
                     #);
           (class[],receiverDesc[]) -> sig.addReceiver;
       if);
       L:
         (if not isSingular then
             method.dclRef -> finalMethod;
             finalMethod.sort -> finalMethod;
             301 -> trace(#
                         do 'mkBytecodeCall:method.dclRef: ' -> xT;
                            finalMethod[] -> xA
                         #);

             (if finalMethod.label = gram.finalDecl then
                 true -> isFinal;
                 method.dclRef -> finalMethod;
                 (if not isRemote then
                     (# md: @AStindex; mdo: ^AStindex
                     do (thisDesc[],EV.sonRef) 
                          -> GetActualDesc 
                          -> (md,descKind);
                        md[] -> sematt.descOrigin -> mdo[];
                        mdo -> receiverDesc;                  
                        ((receiverDesc[],true) -> descName,receiverDesc[]) 
                          -> sig.addReceiver
             #)if)if);         
             method.descRef -> method;
             301 -> trace(#
                         do 'mkBytecodeCall:method.descref: ' -> xT;
                            method[] -> xA
                         #);
             LL: 
               (if method.label 
                // gram.objectDescriptor 
                // gram.unExpanded then
                   method -> receiverDesc
                // gram.finalDecl then (** ??? **)'FINAL'->putline;
                // gram.bindingDecl then

                   method.son -> method;
                   L:
                     method -> scanList
                   (# do currentNode -> method; leave L #);
                   method.virtDcl -> method;
                   method.sort -> method;
                   restart LL
                   
                // gram.virtualDecl then
                   method.son -> method;
                   method.brother -> method; (* assume desc here *)
                   false -> isStatic; (* V:< T never be in an attributes form *)
                   true -> isVirtual;
                   (* perhaps we should explicitly set the receiver? *)
                   (if (EV.sonRef).label = gram.nameApl then
                       (* are we sure the other cases are covered? *)
                       (*1->trace(#
                        do 'mkByteCodeCall:virtual: ' -> xT; EV[] -> xA; 
                        ' on:'->xT; (EV.sonRef).on -> xI; xN;
                        thisDesc[] -> xA
                        #);*)
                       thisDesc -> receiverDesc;
                       (for i: (EV.sonRef).on repeat 
                            receiverDesc[] -> sematt.DescOrigin -> receiverDesc[]
                       for);
                       (EV.sonRef,receiverDesc[],none) 
                         -> findReceiver -> receiverDesc[];
                       ((receiverDesc[],true)->descName,receiverDesc[]) 
                         -> sig.addReceiver;
                   if)
                // gram.variablePattern then
                   (* R: (# F: ##T
                    *    do ... F
                    * receiverDesc: R
                    * methodName  : F
                    * methodDesc  : T
                    *)
                   301->trace(#
                             do 'mkByteCodeCall:varPtn: ' -> xT;
                                EV[] -> xA;
                             #);
                   true -> isVarPtn;
                   false -> isStatic;
                   method[] -> sematt.EncDescOfNode -> receiverDesc[];
                   ((receiverDesc[],true)->descName,receiverDesc[]) 
                     -> sig.addReceiver;
                   sig.thisMethodDesc -> method;
                   301->trace(#
                             do 'mkByteCodeCall:varPtn:X: ' -> xH;
                                'receiver: '->xT; receiverDesc[] -> xA; xN;
                                'methodName: ' -> xT; VN.gettext -> xT; xN;
                                'methodDesc: ' -> xT; method[]->xA
                             #);
               if);
             301 -> trace(# 
                         do 'call2:'->xH; 
                            ' receiver: '->xT; receiverDesc[] -> xA; xN; 
                            'method: '->xT; method[] -> xA; 
                         #)   
         if);

       (if isStatic then
           ((method[],true) -> descName,method[]) -> sig.addReceiver;
           sig.markStatic
       if);
       (* set the name of the method *)
       (if isVarPtn then
           VN.gettext -> sig.addMethod;
        else 
           (if (sig.thisMethodDesc -> sematt.descKind) 
            // sematt.procKind 
            // sematt.staticProcKind then
               method[]  -> theGen.getExternalClassName -> sig.addMethod
            else
               (*1->trace(#do 'addMethod: ' -> xT; method[] -> xA; xN;
                'VN: ' -> xT; VN[] -> xA;
                'VN.text: ' -> xT; VN[] -> getDclName -> xT
                #);*)
               (if isFinal and isRemote then
                   VN[] -> getDclName -> sig.addMethod 
                else
                   (method[],false) -> descName -> sig.addMethod
               if)
           if)
       if);
       (* the following should be generalised? *)
       (*1->trace(#
        do 'isSlot: ' -> xT; method.isslot -> xB; xN;
        method[] -> xA; xN;
        sig.thismethoddesc[] -> xA
        #);*)

       (if method.isSlot then
           (if sig.thisMethodDesc.isSlot then
               (* probably only the second check is needed *)
               sig.noEnter
            else
               sig.addEnter
           if)
        else
           method[] -> sig.addEnter
       if);
       
       (if method.isSlot then
           sig.setVoidXSig
        else
           (# p,mp,att,n,doP,exitP,EV: ^ASTindex; S: ^text
           do sig.thisMethodDesc[] (* descriptor for method *)
                -> sematt.descSonsRef
                -> (p[],mp[],att[],n[],doP[],exitP[]);
              
              (if exitP[] <> none then
                  exitP[] -> sig.addExit
               else
                  sig.setVoidXSig
              if)
       #)if);
       sig.asText -> class[];
       301 ->trace(#do 'class: ' -> xT;  class[] -> xT #);
       (if not hasArguments 
           and (((sig.NNsig.top > 0) and not isStatic)
           or ((sig.NNsig.top > 1) and isStatic)) then
           (* is receiverDesc the right originDesc here?
            * is it ok with topDesc = none
            *)
           (# xD: @ASTindex; ba: ^mch.address;
              oldReturnSaved,oldInNDX: @boolean;
              mDesc: ^ASTindex;
           do thisDesc->xD;
              theThisDesc -> thisDesc;
              baseAdr.copy -> ba[];
              inEnterDoExitMethod -> oldInNDX;
              theGen.returnSaved -> oldReturnSaved;            
              (* instead of this clumsy save of global state,
               * we should make a new instance of theGen
               *)
              301 ->trace(#
                         do 'mkByteCodeCall:inlineMethod1:'->xT;
                            method[] -> xA; 
                            ' VN: ' -> xT; VN[] -> xA;
                            ' on: ' -> xT; VN.on -> xI;
                            xN;
                            'thisDesc: ' -> xT;
                            thisDesc[] -> xA; xN;
                            'theThisDesc: '->xT; 
                            theThisDesc[] -> xA; xN;
                            'baseAdr.bAdr.localDesc: ' -> xT;
                            baseAdr.bAdr.localDesc[] -> xA; xN;
                            baseadr.display->xT; 
                         #);
              (if isVirtual then
                  301->trace(#do 'Virtual:genPtnMethod: '->xT; method[]->xA #);
                  method[] -> mDesc[];
               else
                  sig.thisMethodDesc[] -> mDesc[]
              if);
              ('inline$',mDesc[]
              ,false,false,receiverDesc[],none(*?*)
              ,true,false,true)
                -> theGen.genPtnMethod
              (# 
              do xD -> thisDesc;
                 (baseAdr.copy,theThisDesc[],VN[],EHchain[])
                   -> genOrgAdrToOrgReg
                   -> OA[];
                 xD -> thisDesc;
                 ba[] -> baseAdr[];
              #);
              xD -> thisDesc;
              ba[] -> baseAdr[];
              oldInNDX -> inEnterDoExitMethod;
              301 ->trace(#
                         do 'mkByteCodeCall:inlineMethod2:'->xT; 
                            method[]->xA; xN;
                            baseAdr.bAdr.localDesc[] -> xA; xN;
                            baseadr.display->xT; xN;
                            thisDesc[] -> xA
                         #);
              (if thisDesc.label = gram.doPart then
                  (* we should probably always do this *)
                  theRealDesc[] -> theGen.InitGen
                  (#
                  do &ASTindex[] -> doP[]; 
                     thisDesc.son -> doP;                 
                     doP[] -> setDoP
                  #);
                  (theRealDesc[],true) -> theGen.initPtnGen;
                  xD -> thisDesc; (* is overwritten by initPtnGen *)
                  301->trace(#
                            do 'mkByteCodeCall:inlineMethod2:'->xT; 
                               'TheRealDesc: ' -> xT; theRealDesc[] -> xA; xN;
                               'FormDesc: ' -> xT; FormDesc[] -> xA; xN;
                               'ThisDesc: ' -> xT; thisDesc[] -> xA; xN;
                            #);
                  
                  
               else 
                  (thisDesc[],false) -> theGen.initPtnGen
              if);
              oldReturnSaved -> theGen.returnSaved; (* is set to false
                                                     * in initPtnGen
                                                     *)
           #)
        else
           (if isFinal and isRemote then
               (baseAdr.copy,VN.sonRef,false,EHchain[])->genAdr->OA[];
               (OA[],mch.adrTop[]) -> mch.ldVal
            else
               (baseAdr.copy,theThisDesc[],VN[],EHchain[])
                 -> genOrgAdrToOrgReg
                 -> OA[];
           if);
           INNER;         
           (class[]->mch.newTextOp,'M',local,isStatic or isRealStatic)
             -> mch.gJsr;  
       if);
       (if not hasExit and (sig.XXsig.elmType <> 10 (*void*)) then
           (if sig.XXsig.elmType = 6 (* real/double *) then
               true -> mch.popStack
            else
               mch.popStack
       if)if);
       301->trace(#
                 do 'mkByteCode:end: '->xT; sig.asText -> xT; sig.thischain
                 #);
       (sig[],sig.thisChain[]) -> methodCall -> W[]
   if);
