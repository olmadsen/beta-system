ORIGIN 'bytecodeval'
---bytecodevalbody:dopart---
do EV.son -> VN;
   (if stest then
       301->trace(# 
                 do 'mkBytecodeCall: ' -> xT; EV[] -> xA; VN[] -> xA;
                    EV.sonRef -> xA
                 #)
   if);
   thisDesc -> theThisDesc;
   (if VN.label = gram.objectDescriptor then
       (VN,common.itemKind,2,null)->DS.push       
   if);
   (EV.sonRef,chain[],true) -> sig.setMethodDesc; 
   &ASTindex[] -> receiverDesc[]; 

   (if VN.label 
    // gram.remote then
       (# md,org: @ASTindex; mdo: ^ASTindex
       do (* VN = R.foo *) 
          VN.son -> receiver;
          receiver.brother -> method;
          sig.thisMethodDesc.origin -> org;
          (if org.label = gram.attributesForm then
              true -> isStatic;
           else
              (if false then
                  (if receiver.label = gram.thisObject then
                   else
                      (* OBS receiver is NOT used anymore *)
                      receiver -> sematt.getName -> receiver; 
                  if);
                  (* receiver = R, method = foo *)  
                  (* NOTE! below is an alternative - and correct - method
                   * for computing the desc of the receiver; we just use
                   * the origin of the method desc. In most cases this is the
                   * same as above, but for virtual methods bound to global
                   * patterns, this is not the same; the above code should
                   * be removed
                   *)
              if);
              (* EV = R.foo 
               * NOTE: EV is reference or similar, and then
               *       EV.sonRef = (remote <R> <foo> )
               *)
              301->trace(#
                        do 'mkBytecodecall:remote:'->xT; 
                           EV[] -> xA;
                           ' sonRef: '->xT; EV.sonRef -> xA
                        #);
              (thisDesc[],EV.sonRef) 
                -> GetActualDesc 
                -> (md,descKind);
              301->trace(#
                        do 'mkBytCodeCall: ' -> xT; md[] -> xA
                        #);
              (* Problem with
               *   T: (# foo: (# ... #) #)
               *   TT: T(# #);
               *   R: ^TT
               *   R.foo
               * method:  (# ... #) i.e. desc of foo
               * receiver: origin(method) = T
               * it should be TT
               *   T: (# V:< A #);
               *   TT: T(# V:: AA #);
               *   TTT: TT (# #)
               *   S1: ^TT;
               *   S2: ^TTT
               *   S1.V;  - is reciever origin of AA or the most specific
               *   S2.V   - subpattern of origin of AA? 
               *            then it is complicated
               *)
              md[] -> sematt.descOrigin -> mdo[];
              301->trace(#
                        do 'mkByteCall:remote:mdo:'->xH; mdo[] -> xA; xN;
                           md[] -> xA
                        #);
              (EV.sonRef,mdo[],md[]) -> findReceiver -> mdo[];
              mdo -> receiverDesc;
              true -> isRemote;
              (if true then
                  (* compute receiver as actual desc of R in R.foo 
                   * previously we could not do this for virtuals
                   * bound to global patterns???
                   *)
                  
              if);
              (if (md->sematt.descKind) 
               // sematt.staticProcKind then
                  true -> isRealStatic;
                  sig.markRealStatic; (* isStatic is used for
                                       * patterns at outermost levels
                                       * in lib-files
                                       *)
               // sematt.consKind then
                  301->trace(#
                            do 'mkByteCodeCall:cons: '->xT;
                               'methodDesc: ' -> xT; md[] -> xA; xN;
                               'receiverDesc: '->xT; receiverDesc[] -> xA;
                            #);
                  (* Create instance of: receiverDesc
                   * with constructor  : methodDesc
                   *)
                  true -> isCons;
                  md -> method
              if);
              301 -> trace(# 
                          do 'mkByteCodeCall:remote:2: ' -> xH;
                             'methodDesc: ' -> xT; md[] -> xA; xN;
                             'receiverDesc: '->xT; receiverDesc[] -> xA;
                          #)
          if)
       #)
       
    // gram.nameApl then
       (* VN = foo 
        * means: originN....origin2.origin1.foo
        * N >= 0
        *)
       VN -> method;
       testLibLevel: (* is this a pattern at the outermost lib level *)
         (# org: @ASTindex
         do sig.thisMethodDesc.origin -> org;
            (* dont work if virtual?*)
            (if org.label = gram.attributesForm then
                301->trace(#
                          do 'Pattern: ' -> xT;
                             VN[] -> xA;
                             ' is at the outermost lib level' -> xT
                          #);
                true -> isStatic;
             else
                (* check the case where VN is as in
                 *     VN: @<<SLOT XXX:descriptor>>
                 *   do ...; VN; ...
                 *   ---XXX:descriptor---
                 *   (# ... enter(...) do ... exit ... #)
                 * I.e. the enter/exit-part is in the form;
                 *)
                (# D: @ASTindex
                do VN.descRef -> D;
                   (if D.isSlot then
                       D.slotOrigin -> D;
                       (if D.label = gram.attributesForm then
                           true -> isStatic;
                           leave testLibLevel
                   if)if)
                #);
                (* to find originN, go origin meth.N times *)
                thisDesc -> receiverDesc;
                (for i: method.on repeat
                     receiverDesc[] -> sematt.descOrigin -> receiverDesc[]
                for);
                (if false then
                    (* ok for calling V declared as V:: T
                     * not ok for     V declared as V:< T
                     *)
                    (# md: @AStindex; mdo: ^AStindex
                    do (thisDesc[],EV.sonRef) 
                         -> GetActualDesc 
                         -> (md,descKind);
                       md[] -> sematt.descOrigin -> mdo[];
                       mdo -> receiverDesc;                  
                #)if)
            if);
         #)
    // gram.objectDescriptor then
       301->trace(#
                 do 'objectdescriptor: ' -> xT;
                    VN[] -> xA;
                 #);
       VN -> method; (* NOTE: VN IS AN OBJECTDESCRIPTOR *)
       method -> receiverDesc;
       (* Here we need to find the right origin of the method *)
       receiverDesc[] -> sematt.descOrigin -> receiverDesc[];
       (if receiverDesc.label 
        // gram.descriptorForm 
        // gram.doPart then
           receiverdesc.xorigin -> receiverdesc;
           receiverdesc.slotOrigin -> receiverdesc;
       if);
       true -> isSingular;

    // gram.unExpanded then
       301->trace(#
                 do 'MkByteCodeCall:DescriptorSlot: ' -> xT; VN[] -> xA 
                 #);
       VN[] -> sematt.enclosingDesc -> receiverDesc[];
       
       receiverDesc[] -> theGen.descLocation -> sig.location[];
       301->trace(#
                 do 'mkByteCodeCall:unExpanded:receiverLocation: "' -> xT;
                    (if sig.location[] = none then 
                        'none' -> xT
                     else 
                        sig.location[] -> xT
                    if);
                    '"' -> put
                 #);
       VN -> method;
       (VN,common.itemKind,3,VN) -> DS.push;
       true -> isSingular (* hack *)
    // gram.computedRemote then
       (# MN,isVirt: @integer; xchain: ^DH.superChain;
          remEv,N,ref,refDesc: ^ASTindex;
          org: @AStindex;
          (* (E).method 
           * DOES NOT WORK
           *)
       do VN.son -> receiver;
          receiver.brother -> method;
          sig.thisMethodDesc.origin -> org;
          (if org.label = gram.attributesForm then
              true -> isStatic
          if);
          L: receiver->scanList(#do currentNode->receiver; leave L #);
          301->trace(#
                    do 'mkByteCodeCallX: ' -> xT;
                       VN[] -> xA
                    #);
          (VN[],DH[],chain[]) 
            -> sematt.chkComputedEval 
            -> (remEv[],N[],ref[],receiverDesc[],xchain[]);
          301->trace(#
                    do 'mkByteCodeCallY: ' -> xT;
                       receiverDesc[] -> xA
                    #);
       #)
    else
       '\n**** insert is NOT remote or nameApl'->putline
   if);
   (if isCons then
       (* 1->trace(#
        do 'cons: ' -> xT; receiverdesc[]->xA #);*)
       (receiverDesc[],common.itemKind) -> theGen.newInstance
       (# 
       do (method[],false,chain[]) -> consSig.addConstructorDesc;
          (*1->trace(#
           do 'X:'->xT; conssig.astext->xT; xN;
           hasOrigin -> xB;
           100->switchon;
           method[]->xA;xN;
           VN[] -> xA;
           100->switchoff
           #);*)
          false -> sig.isStatic;
          'olsen' -> sig.addMethod;
          method[] -> sig.addEnter;
          sig.setVoidXSig; 
          (*1->trace(#do sig.astext -> xT #);*)
          ((receiverDesc[],true) -> descName,receiverDesc[]) 
            -> sig.addReceiver;
          (if hasOrigin then '\ngenorg'->putline;
              (baseAdr.copy,theThisDesc[],VN[],EHchain[])
                -> genOrgAdrToOrgReg
                -> OA[];
          if);
          INNER MkByteCodeCall
       #);
       (mch.thisRegOp,false,EV[],chain[]) -> mkComputedRefEvVal -> W[]
    else
       (if not isStatic then
           ('G',receiverDesc[]) -> mkEntryPoint -> (class[],local);
           301->trace(#
                     do 'mkByteCodeCall:receiver: ' -> xT; class[] -> xT; xN;
                        receiverDesc[] -> xA
                     #);
           (class[],receiverDesc[]) -> sig.addReceiver;
       if);
       L:
         (if not isSingular then
             method.dclRef -> finalMethod;
             finalMethod.sort -> finalMethod;
             301 -> trace(#
                         do 'mkBytecodeCall:method.dclRef: ' -> xT;
                            finalMethod[] -> xA
                         #);

             (if finalMethod.label = gram.finalDecl then
                 true -> isFinal;
                 method.dclRef -> finalMethod;
                 (if not isRemote then
                     (# md: @AStindex; mdo: ^AStindex
                     do (thisDesc[],EV.sonRef) 
                          -> GetActualDesc 
                          -> (md,descKind);
                        md[] -> sematt.descOrigin -> mdo[];
                        mdo -> receiverDesc;                  
                        ((receiverDesc[],true) -> descName,receiverDesc[]) 
                          -> sig.addReceiver
             #)if)if);         
             method.descRef -> method;
             301 -> trace(#
                         do 'mkBytecodeCall:method.descref: ' -> xT;
                            method[] -> xAF
                         #);
             LL: 
               (if method.label 
                // gram.objectDescriptor 
                // gram.unExpanded then
                   method -> receiverDesc
                // gram.finalDecl then (** ??? **)'FINAL'->putline;
                // gram.bindingDecl then

                   method.son -> method;
                   L:
                     method -> scanList
                   (# do currentNode -> method; leave L #);
                   method.virtDcl -> method;
                   method.sort -> method;
                   restart LL
                   
                // gram.virtualDecl then
                   method.son -> method;
                   method.brother -> method; (* assume desc here *)
                   false -> isStatic; (* V:< T never be in an attributes form *)
                   true -> isVirtual;
                   (* perhaps we should explicitly set the receiver? *)
                   (if (EV.sonRef).label = gram.nameApl then
                       (* are we sure the other cases are covered? *)
                       (*1->trace(#
                        do 'mkByteCodeCall:virtual: ' -> xT; EV[] -> xA; 
                        ' on:'->xT; (EV.sonRef).on -> xI; xN;
                        thisDesc[] -> xA
                        #);*)
                       thisDesc -> receiverDesc;
                       (for i: (EV.sonRef).on repeat 
                            receiverDesc[] -> sematt.DescOrigin -> receiverDesc[]
                       for);
                       (EV.sonRef,receiverDesc[],none) 
                         -> findReceiver -> receiverDesc[];
                       ((receiverDesc[],true)->descName,receiverDesc[]) 
                         -> sig.addReceiver;
                   if)
                // gram.variablePattern then
                   (* R: (# F: ##T
                    *    do ... F
                    * receiverDesc: R
                    * methodName  : F
                    * methodDesc  : T
                    *)
                   301->trace(#
                             do 'mkByteCodeCall:varPtn: ' -> xT;
                                EV[] -> xA;
                             #);
                   true -> isVarPtn;
                   false -> isStatic;
                   method[] -> sematt.EncDescOfNode -> receiverDesc[];
                   ((receiverDesc[],true)->descName,receiverDesc[]) 
                     -> sig.addReceiver;
                   sig.thisMethodDesc -> method;
                   301->trace(#
                             do 'mkByteCodeCall:varPtn:X: ' -> xH;
                                'receiver: '->xT; receiverDesc[] -> xA; xN;
                                'methodName: ' -> xT; VN.gettext -> xT; xN;
                                'methodDesc: ' -> xT; method[]->xA
                             #);
               if);
             301 -> trace(# 
                         do 'call2:'->xH; 
                            ' receiver: '->xT; receiverDesc[] -> xA; xN; 
                            'method: '->xT; method[] -> xA; 
                         #)   
         if);

       (if isStatic then
           ((method[],true) -> descName,method[]) -> sig.addReceiver;
           sig.markStatic
       if);
       (* set the name of the method *)
       (if isVarPtn then
           VN.gettext -> sig.addMethod;
        else 
           (if (sig.thisMethodDesc -> sematt.descKind) 
            // sematt.procKind 
            // sematt.staticProcKind then
               method[]  -> theGen.getExternalClassName -> sig.addMethod
            else
               (*1->trace(#do 'addMethod: ' -> xT; method[] -> xA; xN;
                'VN: ' -> xT; VN[] -> xA;
                'VN.text: ' -> xT; VN[] -> getDclName -> xT
                #);*)
               (if isFinal and isRemote then
                   (if true then
                       (# VD: ^ASTindex; T : ^text;
                          getVirtDclName2:
                            (# VN,VD: ^ASTindex; N: @ASTindex; T: ^text
                            enter VN[]
                            do VN -> N;
                               L:
                                 (if N.label
                                  // gram.nameApl then
                                     N.dclref -> N;
                                     N[] -> getVirtDcl -> VD[];
                                     VD.gettext -> T[]
                                  // gram.remote then
                                     N.son -> N; N.brother -> N;
                                     restart L
                                  else
                                     '\ngetDclName: case not covered ' ->putline
                                 if)
                            exit T[]
                            #);

                       do VN[] -> getVirtDclName2 -> T[];
                               (*1->trace(#do T[] -> xT #);*)
                          T[] -> sig.addMethod 
                       #)
                    else
                       VN[] -> getDclName -> sig.addMethod 
                   if)
                else
                   (method[],false) -> descName -> sig.addMethod
               if)
           if)
       if);
       (* the following should be generalised? *)
       (*1->trace(#
        do 'isSlot: ' -> xT; method.isslot -> xB; xN;
        method[] -> xA; xN;
        sig.thismethoddesc[] -> xA
        #);*)

       (if method.isSlot then
           (if sig.thisMethodDesc.isSlot then
               (* probably only the second check is needed *)
               sig.noEnter
            else
               sig.addEnter
           if)
        else
           method[] -> sig.addEnter
       if);
       
       (if method.isSlot then
           sig.setVoidXSig
        else
           (# p,mp,att,n,doP,exitP,EV: ^ASTindex; S: ^text
           do sig.thisMethodDesc[] (* descriptor for method *)
                -> sematt.descSonsRef
                -> (p[],mp[],att[],n[],doP[],exitP[]);
              
              (if exitP[] <> none then
                  exitP[] -> sig.addExit
               else
                  sig.setVoidXSig
              if)
       #)if);
       sig.asText -> class[];
       301 ->trace(#do 'class: ' -> xT;  class[] -> xT #);
       (if not hasArguments 
           and (((sig.NNsig.top > 0) and not isStatic)
           or ((sig.NNsig.top > 1) and isStatic)) then
           (* is receiverDesc the right originDesc here?
            * is it ok with topDesc = none
            *)
           (# xD: @ASTindex; ba: ^mch.address;
              oldReturnSaved,oldInNDX: @boolean;
              mDesc: ^ASTindex;
           do thisDesc->xD;
              theThisDesc -> thisDesc;
              baseAdr.copy -> ba[];
              inEnterDoExitMethod -> oldInNDX;
              theGen.returnSaved -> oldReturnSaved;            
              (* instead of this clumsy save of global state,
               * we should make a new instance of theGen
               *)
              301 ->trace(#
                         do 'mkByteCodeCall:inlineMethod1:'->xT;
                            method[] -> xA; 
                            ' VN: ' -> xT; VN[] -> xA;
                            ' on: ' -> xT; VN.on -> xI;
                            xN;
                            'thisDesc: ' -> xT;
                            thisDesc[] -> xA; xN;
                            'theThisDesc: '->xT; 
                            theThisDesc[] -> xA; xN;
                            'baseAdr.bAdr.localDesc: ' -> xT;
                            baseAdr.bAdr.localDesc[] -> xA; xN;
                            baseadr.display->xT; 
                         #);
              (if isVirtual then
                  301->trace(#do 'Virtual:genPtnMethod: '->xT; method[]->xA #);
                  method[] -> mDesc[];
               else
                  sig.thisMethodDesc[] -> mDesc[]
              if);
              ('inline$',mDesc[]
              ,false,false,receiverDesc[],none(*?*)
              ,true,false,true)
                -> theGen.genPtnMethod
              (# 
              do xD -> thisDesc;
                 (baseAdr.copy,theThisDesc[],VN[],EHchain[])
                   -> genOrgAdrToOrgReg
                   -> OA[];
                 xD -> thisDesc;
                 ba[] -> baseAdr[];
              #);
              xD -> thisDesc;
              ba[] -> baseAdr[];
              oldInNDX -> inEnterDoExitMethod;
              301 ->trace(#
                         do 'mkByteCodeCall:inlineMethod2:'->xT; 
                            method[]->xA; xN;
                            baseAdr.bAdr.localDesc[] -> xA; xN;
                            baseadr.display->xT; xN;
                            thisDesc[] -> xA
                         #);
              (if thisDesc.label = gram.doPart then
                  (* we should probably always do this *)
                  theRealDesc[] -> theGen.InitGen
                  (#
                  do &ASTindex[] -> doP[]; 
                     thisDesc.son -> doP;                 
                     doP[] -> setDoP
                  #);
                  (theRealDesc[],true) -> theGen.initPtnGen;
                  xD -> thisDesc; (* is overwritten by initPtnGen *)
                  301->trace(#
                            do 'mkByteCodeCall:inlineMethod2:'->xT; 
                               'TheRealDesc: ' -> xT; theRealDesc[] -> xA; xN;
                               'FormDesc: ' -> xT; FormDesc[] -> xA; xN;
                               'ThisDesc: ' -> xT; thisDesc[] -> xA; xN;
                            #);
                  
                  
               else 
                  (thisDesc[],false) -> theGen.initPtnGen
              if);
              oldReturnSaved -> theGen.returnSaved; (* is set to false
                                                     * in initPtnGen
                                                     *)
           #)
        else
           (if isFinal and isRemote then
               (baseAdr.copy,VN.sonRef,false,EHchain[])->genAdr->OA[];
               301->trace(#
                         do 'mkBytecodeCall: ' -> xT;
                            VN[] -> xA; xN;
                            OA.receiverType[] -> xT; xN;
                            OA.fieldType[] -> xT; xN;
                            class[] -> xT; xN;
                            (if OA.bAdr.dclDesc[] = none then
                                'dclDesc:isNone'->xT; xN
                             else
                                OA.bAdr.dclDesc[] -> xAF; xN;
                            if);
                            OA.bAdr.localDesc[] -> xAF; 
                         #);
               (OA[],mch.adrTop[]) -> mch.ldVal;
               (if (OA.bAdr.dclDesc[] <> none)
                   and not (OA.bAdr.dclDesc -> OA.bAdr.localDesc.equal) then
                   (* A cast is probably needed *)
                   (* 1->trace(#do 'cast:' -> xT;  class[] -> xT #);*)
                   OA.bAdr.localDesc[]->theGen.mkSignature  -> mch.checkCast
               if);
            else
               (baseAdr.copy,theThisDesc[],VN[],EHchain[])
                 -> genOrgAdrToOrgReg
                 -> OA[];
           if);
           INNER;       
           (# isValueTypeCall: @boolean;
           do (if (sig[]<>NONE) and (sig.receiver[]<>NONE) then
                  (if common.isJVM then
                      (* inx 2 is used for JVM since fieldType = 'L@value...' *)
                      ((2->sig.receiver.inxGet)='@') -> isValueTypeCall
                  if);
                  (if common.isCLR then
                      ((1->sig.receiver.inxGet)='@') -> isValueTypeCall
                  if);
              if);
              (class[]->mch.newTextOp,'M',local,isStatic or isRealStatic, isValueTypeCall)
                -> mch.gJsr;  
           #);
       if);
       (if not hasExit and (sig.XXsig.elmType <> 10 (*void*)) then
           (if sig.XXsig.elmType = 6 (* real/double *) then
               true -> mch.popStack
            else
               mch.popStack
       if)if);
       301->trace(#
                 do 'mkByteCode:end: '->xT; sig.asText -> xT; sig.thischain
                 #);
       (sig[],sig.thisChain[]) -> methodCall -> W[]
   if);
---bytecodeval_methodArgs_asgToMethod:doPart---
do 301->trace(#
             do 'asgToMethod:'->display; xN;
                'next: ' -> xT; next -> xI; 
                ' noOfArgs:' -> xT; noOfArgs->xI; 
                (for i: noofArgs repeat
                     (if i <= enterTypes.range then
                         enterTypes[i]->xI
                      else
                         '# ' -> xT
                     if)
                for);
                xN;
                'rElm: ' -> xT; rElm[] -> xA;
                rChain
             #);
   (if llEV[] <> none then
       (*1->trace(#
        do 'eval:assignToList:'->xT; llEV.display; xN;
        lEv[] -> xA
        #);*)
       (baseAdr[],llEv[],lEv[],true,lChain[])
         -> assignValToEval
         -> V[]
    else          
       (baseAdr[],lEv[],true,lChain[])
         -> ExpEval
         -> V[];
   if);
   301->trace(#
             do 'asgToMethod2: '->display; V.display;
                rChain
             #);
   
   (enterTypes,noOfArgs,next,rElm[],rChain[]) 
     -> V.asgToMethod
     -> next;
   
---bytecodeval_methodCall_asgToExitArgs:doPart---
do 301->trace(#
             do 'asgToExit:'->display;
             #);
   (if sig.isMultiValExit then
       (* this(methodCall) returns a list of values *)
       sig.XXsig.asText -> theGen.AllocAndStoreTmp -> A[];
       (* we need to get the right values instead of
        * gen.thisRegAdr and thisSuperChain
        * from the place where methodCall is instantiated
        *)
       'exit_' -> destField[];
       'exit_' -> srcField[];
       (sig.thisMethodDesc[] -> theGen.fieldSignature).asText 
         -> aS.receiverType[];
       (rDesc[] -> theGen.fieldSignature).asText 
         -> aD.receiverType[];
       false -> notFirst; (* for some unknown reason notFirst is global
                           * in synthesizerbody but apparently only used here?
                           *)
       sig.scanExit
       (#
       do (if notFirst then 
              (originAdr[],none) -> mch.ldVal
          if);
          true -> notFirst;
          (A[],&mch.adrRegOperand[]) -> mch.ldVal;
          true -> aS.isField;
          true -> aD.isField;
          xNo + 1 
            -> xNo 
            -> (srcField.copy).putint 
            -> aS.fieldName[];
          current.theDesc 
            -> theGen.mkSignature 
            -> aS.fieldType[]
            -> aD.fieldType[](* -> puttext;*);
          (aS[],&mch.dataRegOperand[]) -> mch.ldVal;
          exitNo + 1 
            -> exitNo
            -> (destField.copy).putint 
            -> aD.fieldName[];
          (* OBS: missing handling os isRep *)
          (current.theDesc,false) -> xTypes.add;
          (&mch.dataRegOperand[],aD[]) -> mch.stVal;
       #);
   if)   
   
---bytecodeval_enterArgs_asgToRefAdr:doPart---
do (# rA: ^mch.address
   do 301 -> trace(#do 'asgToRefAdr:'->display #);
      (rAbase[],destEV.sonRef,false,rChain[]) -> genAdr -> rA[]; 
      (if destEv.label = gram.structureReference then
          (theGen.StructureSignatureId->theGen.specialSignature).asText 
            -> rA.fieldType[]
      if);
          (*      1->trace(#do rA.isInxRegAdr -> xB #);*)
      
      (isMultiple,true,false,rA.isInxRegAdr,rA.fieldType[],rA.bAdr.localDesc[]) 
        -> eval 
        -> V[];
      (rA[],destEV[],rChain[],false) -> V.asgToRefAdr -> V[];
      
      (if isMultiple and not isJava then mch.loadLocal if);
   #)
   
---bytecodeval_enterArgs_asgToItem:doPart---
do 301->trace(#do 'asgToItem:'->display; #);
   (if llEV[] <> none then
       301->trace(#
                 do 'asgToItem:Multiple:'->display; llEV.display; xN;
                    lEv[] -> xA
                 #);
       (baseAdr[],llEv[],lEv[],true,lChain[])
         -> assignValToEval
         -> V[]
    else
       (baseAdr[],lEv[],true,lChain[])
         -> ExpEval
         -> V[]
   if);
   (rDesc[],rChain[],false(*?*)) -> sig.setMethodDesc;
   rDesc[] -> sig.addEnter;
   sig.exitVoid;
   (# T: [sig.noOfEnterArgs] @integer;
      top: @integer
   do sig.scanEnter
      (#
      do current.elmType -> T[top+1 -> top]
      #);
      (T,top,1,rDesc[],rChain[]) -> V.asgToMethod
   #)
---bytecodeval_enterArgs_eval:doPart---
do (# isExternalString,doMarkMultiple: @boolean        
   do 301->trace(#
                do 'eval:'->display; xN;
                   'dup: ' -> xT; dup->xB;
                   'pushVal:'->xT; pushVal->xB;
                   'isSimpleVal:' ->xT; isSimpleVal -> xB;
                   'isRepAdr:'->xT; isRepAdr -> xB;
                   'rType:'->xT; rType[] -> xT; xN;
                   (if llEV[]<>none then 
                       'llEV:'->xT; llEV.display;; xN;
                   if);
                   'lEV:'->xT; lEV[] -> xA
                #);
      (if inEnter then false -> inEnterDoExitMethod if);
      (if llEV[] <> none then
          301->trace(#
                    do 'eval:assign:'->xT; llEV.display; xN;
                       lEv[] -> xA;
                       ' dup:'->xT; dup -> xB
                    #);
          (* Multiple assignment: llEV -> lEV
           * Case ente(a->b)
           *   llEV = enterArgs
           *   lEV  = a   or a -> b
           *   dup  = true
           *   The dup should be part of assignValToEval
           *   and not after 
           * llEv.pushVal -> llEv[]; - dont work since adr
           * of lEv is not computed
           *)
          (*llEV.markMultiple;*)
          (baseAdr[],llEv[],lEv[],true,lChain[])
            -> assignValToEval
            -> V[]
       else
          (baseAdr[],lEv[],true ,lChain[]) 
            -> ExpEval
            -> V[]
      if);
      (if false then
          1->trace(#
                  do 'string2text?: '->display;
                     V.type->xA; xN;
                     rType[] -> xT; xN; rDesc[] -> xA; xN;
                     'L/R: ' -> xT;
                     V.type = none -> xB; xN;
                     V.type->theGen.isExternalString -> xB;
                     (if rDesc[] <> none then
                         rDesc->sematt.textDesc.equal -> xB
      if)#)if);
      (if (rDesc[] <> none)
          and (V.type->theGen.isExternalString)
          and (rDesc->sematt.textDesc.equal) then
          (* In: 'exit S[] -> T[]' we should avoid
           * a dup of S[] - since we return a T[],
           * i.e. T[] should be duplicated - this must
           * take place in refEval.asgtoRefgAdr.
           * The same should probably also be done
           * for the text2string case
           *)
          (if dup then
              true -> doMarkMultiple;
              false -> dup
          if)
      if);
      (if false then
          (if (V.evType = 1 (* could be char*))
              and (rDesc[]<>none)
              and (sematt.repDesc->rDesc.equal) then
              (* could be 'a' -> R - in which case we should push 'a'
               * or R.foo -> R where foo returns a char literal and
               * here the value is already on the stack
               *)
              (* true -> pushVal -> isSimpleVal*)
      if)if);
      (if V[] = none then '\nMethodArgs:eval:V is none ' -> putline if);
      301->trace(#
                do 'eval2:'->display; 'dup:'->xT; dup->xB; xN; 
                   V.display 
                #);
      (if pushval then
          (* we need the rType here for text/const literals;
           * this is tricky and should be reconsidered;
           * also since dup_x1 does not exist on .NET
           *)
          (* reconsider structure of pushVal here and in txtcstval *)
          (rType[]<>none) 
          and ((isJava and ('java/lang/String' -> rType.equal)) 
          or ('class [mscorlib]System.String'->rType.equal))
            -> isExternalString;
          (if isExternalString then
              (* to avoid conversion to BETA text - clumsy *)
              true -> V.pushVal -> V[]
           else
              isSimpleVal -> V.pushVal -> V[]
          if);
          301->trace(#do 'eval3: V:'->display; V.display #);
          (if not isSimpleVal and not isExternalString then
              V.mkBetatext; (* reconsider *)
          if)    
      if);
      (* FIXME: the following is very messsy *)
      (if (V.evType = 1 ) and false
          and (rDesc[]<>none) 
          and (sematt.repDesc->rDesc.equal) then
          (if true then
              (common.char2rep,none) -> mch.callPrimNo
           else
              'char2rep' -> mch.callPrim
          if)
       else
          (if not isSimpleVal
              and (rType[]<>none) 
              and (rType.length > 0) (* from asgToRep *)
              and (V.evType<>4 (* strucref->Structure *))
              and (rDesc[] <> none) and not (sematt.textDesc->rDesc.equal)
              (* In X.get -> T[]
               * get may return externalString
               * and T may be a text;
               * here we avoid a text-cast
               * instead a coersion is made
               * in textVarVal; but ugly
               *)
              and not (V.type -> theGen.mkSignature -> rType.equal) then
              rType[] -> mch.checkCast
      if)if);
      (if dup then
          (if isJava then
              (if isRepAdr then
                  (2,0,none,none) -> mch.duplicate
               else
                  (if V.evType = 3 (* float *) then
                      (1,1,none,none) -> mch.duplicate
                   else
                      (1,0,none,none) -> mch.duplicate
                  if)
              if)
           else
              301->trace(#do 'eval4: V:'->display; V.display #);
              mch.duplicate;
              V.type -> theGen.mkSignature ->  mch.allocAndStoreLocal
          if)
      if);
      (if doMarkMultiple then V.markMultiple if);
      (if inEnter then
          true -> inEnterDoExitMethod
      if)
   #)
   
---bytecode_methodCall_exitValIsReal:doPart---
do (sig.XXsig.elmType = 6) (* real *)
   or (sig.XXsig.elmType = 7) (* real32 *)
     -> value
   
---bytecode_methodCall_thisExitVal:doPart--
do 301->trace(#
             do 'thisExitVal:'->display; 
                type -> xAF 
             #);
   (if exitValIsReal then
       mkReal -> V[]
    else
       (if sig.XXsig.isRef then
           this(methodCall)[] -> V[]; (* not logical, but
                                       * we don't have thisEV
                                       * in the next one below
                                       *)
           (*(0,false,EV[],chain[]) -> mkComputedRefEvVal -> V[]*)
        else
           (if false then
               (if sig.XXsig.elmType = 8 (* int64 *) then
                   mch.int64ToInt32
           if)if);
           (0,evType=2,false,false,type) -> mkComputedEvVal2 -> V[];
   if) if)
   
---bytecodeval_enterArgs_asgToMethod:doPart---
do 301->trace(#
             do 'asgToMethod:'->display;
                'noOfArgs: ' -> xT; noOfArgs -> xI;
                ' enterTypes.range: ' -> xT;
                enterTypes.range -> xI;
                ' next:'->xT; next -> xI;
                (if (next + noOfArgs) > enterTypes.range then
                    xN;
                    '(next + noOfArgs) > enterTypes.range '
                      -> xT;
                if); 
                xN;
                ' elms:'->xT;
                (for i: noOfArgs repeat
                     enterTypes[i] -> xI
                for)
             #);
   (if (next + noOfArgs - 1) > enterTypes.range then
       (* HACK: we assume that method is static
        * and that first argument - enlosing object -
        * has been pushed by genOrgAdr.
        * Ex:
        * ---lib:attributes---
        * descNo: (# N: @integer enter N do ... #);
        * descId: (# enter ((a,b),descNo) do ... #)
        *)
       noOfArgs - 1 -> max
    else
       noOfArgs -> max
   if);
   (for i: max repeat
        (if enterTypes[next] 
         // 11 // 12 // 13 // 14 then
            ('SomeClass', NONE) -> pushNext;
         // 6 (* real/double *) // 7 (* real32 *) then
            ('D', NONE) -> pushNext 
         // 8 (* long=int64*) then
            ('J', NONE) -> pushNext
         else
            (NONE, NONE)->pushNext 
        if);
        next + 1 -> next
   for);
   (* OBS. check that moved 'inner' in mkByteCodeCall is OK
    * We need the descriptor - it may be singular -
    * it must be called as a a method; i.e. 
    * treated like an inner pattern with method-version
    * and new-version
    *)
   next + max -> next 
   
---bytecode_methodCall_asgToRealAdr:doPart---
do 301->trace(#
             do 'asgToRealAdr: '->display; type -> xAF
             #);
   rA[] 
     -> ((&mch.floatRegOp[],type)->mkFloatEvVal).asgToRealAdr 
     -> V[]
   
---bytecode_methodCall_asgToRefAdr:doPart---
do (# EV: @ASTindex; ok: @boolean
   do 301 -> trace(#
                  do 'asgToRefAdr: '->display;
                     100 -> switchon;
                     sig.exitVal[] -> xA;
                     100 -> switchOff
                  #);
      (* the method, including exit-part has been executed
       * and a reference is returned on the stack. We must
       * get the type of the reference and assign it to destEv
       *)
      getExit:
        sig.exitVal[]->sematt.evCase
      (# objRef::
           (#
           do (0,false,EV.sonRef,chain[]) 
                -> mkComputedRefEvVal
                -> V[];
              true -> ok
           #);
         dynItemRef::
           (#
           do (0,false,EV.sonRef,chain[]) 
                -> mkComputedRefEvVal
                -> V[];
              true -> ok
           #);
         strucRef::
           (#
           do (0,false,EV.sonRef,chain[]) 
                -> mkComputedRefEvVal
                -> V[];
              true -> ok
           #);
         txtCst::
           (# T: ^text 
           do EV.gettext->T[]; 
              T->mkTxtCstEvVal->V[];
              true -> ok
           #);
         insert::
           (# xScan: @| scanXadr; gXl: ^| sematt.getNXlength
           do (sig.thisMethodDesc[],rAbase.copy,0,chain[]) -> xScan; 
              &|sematt.getNXlength[] -> gXl[];
              (xScan.thisEv[],false,xScan.thisChain[])
                -> gXl;
              301->trace(#
                        do 'insert: ' -> xT;
                           gXl.thisEv[] -> xA
                        #);
              (0,false,gXl.thisEv[],gXL.thisChain[]) 
                -> mkComputedRefEvVal
                -> V[];
              gXL;
              true -> ok
           #);
         assign::
           (#
           do EV2[] -> sig.exitVal[]; restart getExit (*hmmm???*)
           #)
      #);
      (if not ok then
          1-> trace(#
                   do 'asgToMethod:sig.ExitVal[]not handled: '->display;
                      xN;
                      sig.ExitVal[] -> xA
                   #)
      if);
      (* 1->trace(#
       do 'V.asgtoRefAdr: '->xT; V.display
       #);*)
      (# dum: @char
      do 
         (rAbase[],destEV[],rChain[],false) -> V.asgToRefAdr;
      #);
         (* 1->trace(#do 'after:'->xT #);*)
      
      (0,false,destEv[],rChain[]) -> mkComputedRefEvVal -> V[];
   #)
   
---bytecodeval_methodCall_asgToMethod:doPart---
do  (# checkText2ES:
         (# lDesc,rDesc: ^ASTindex;
            leftIsRep: @boolean;
         enter(lDesc[],rDesc[],leftIsRep)            
         do (if (rDesc[]<>none) then
                301->trace(#
                          do 'ct2e:'->xT;
                             lDesc[]->xAF; xN;
                             rDesc[] -> xAF;
                          #);
                (rDesc[],true,rChain[]) -> nxLeafScanner (* scan enter *)
                (#
                do (lDesc[],leftIsRep,rElm[],currentDesc[],isRep,rChain[],enterTypes,next)
                     -> checkCastX
                   (#
                   do (* inner is called if a value is assigned
                       * to a repetition
                       *)
                      (desc[],this(asgToMethod).rElm[],rChain[],rA[],true) -> asgVal2Rep
                   #)
                #)
            if)
         #);
       checkText2ExternalString:
         (# d: ^ASTindex;
            leftIsRep: @boolean;
            sourceClassName: ^text
         enter(d[],leftIsRep)
         do (if (d[]<>none) then
                301->trace(#
                          do 'ct2ex:'->xT;
                             d[]->xAF; xN;
                             rElm[] -> xAF;
                          #);
                (if true
                 // (d->sematt.textDesc.equal) 
                    and (enterTypes[next] = 13 (* external *)) then
                    (if true then
                        (common.BetaText2ExternalString,none)->mch.callPrimNo
                     else
                        'BetaText2ExternalString' -> mch.callprim 
                    if)
                 // ((d->sematt.descKind) = sematt.externalClassKind)
                    and (enterTypes[next] = 14 (* textDesc *) ) then
                    (if true then
                        (common.ExternalString2BetaText,none) -> mch.callPrimNo
                     else
                        'ExternalString2BetaText' -> mch.callprim
                    if)
                 // (d->sematt.textDesc.equal) 
                    and  (enterTypes[next] = 12 (* array *)) then
                    'text2char' -> mch.comment;
                    (if true then
                        (common.BetaText2BetaCharArray,none) -> mch.callPrimNo
                     else
                        'BetaText2BetaCharArray' -> mch.callPrim
                    if)
                 else
                    (if not leftIsRep
                        and (enterTypes[next] = 12 (* array *)) then
                        baseAdr.copy -> rA[];
                        (rElm[],rChain[],rA[]) -> getElmDesc -> desc[];
                        301->trace(#
                                  do rElm[]->xA; xN; 
                                     desc[]->xA; desc.size -> xI 
                                  #);
                        desc.size -> rA.size;
                        desc[] -> rA.bAdr.localDesc[];
                        (desc[],rElm[],rChain[],rA[],true) -> asgVal2Rep;
                     else
                        (* a cast may be needed - some clean-up should
                         * be done here - we have 
                         * sig.theDesc[] -> gNL.theDesc
                         * but we do not have hNL here -
                         * it is inside checkCast - unify and
                         * clean up
                         *)
                        d[] -> theGen.mkSignature -> sourceClassName[];
                        301 -> trace(#
                                    do 'cast: ' -> xT; xN;
                                       sourceClassName[] -> xT; xN;
                                       destClassName[] -> xT
                                    #);
                        (if (destClassName[] <> none) and
                            not (sourceClassName[]->destClassName.equal) then
                            destClassNAme[] -> mch.checkCast
                        if)
                    if)
            if)if)
         #);
       destClassName: ^text;
       isBetaText2ExternalString
       ,isExternalString2BetaText
       ,isRef2RepAsg: @boolean;     

       leftIsRep: @boolean
    do 301->trace(#
                 do 'MethodCall:asgToMethod: ' -> xT;
                    sig.asText -> xT; ' ' -> put;
                    noOfArgs -> xI; ':' -> put;
                    (for i: (noOfArgs,entertypes.range) -> min repeat
                         entertypes[i] -> xI; ' ' -> put;
                    for);
                 #);
       (if sig.isMultiValExit then
           sig.XXsig.asText -> theGen.AllocAndStoreTmp -> A[];
           (* we need to get the right values instead of
            * gen.thisRegAdr and thisSuperChain
            * from the place where methodCall is instantiated
            *)
           'exit_' -> srcField[];
           (if true then
               (*1->trace(#
                do 'exitDesc: ' -> xT; sig.exitDesc[]-> xAF 
                #);*)
               (sig.exitDesc[] -> theGen.fieldSignature).asText 
                 -> aS.receiverType[]
            else
               (sig.thisMethodDesc[] -> theGen.fieldSignature).asText 
                 -> aS.receiverType[]
           if);
           true -> aS.isField;
           sig.scanExit
           (# desc: ^ASTindex
           do (if not current.isNone then
                  (A[],&mch.adrRegOperand[]) -> mch.ldVal
              if);
              xNo + 1 
                -> xNo   
                -> (srcField.copy).putint 
                -> aS.fieldName[];
              (if (current.elmType = 12)->leftIsRep (* array *) then
                  '\nbingo'->putline;
                  current.theDesc 
                    -> desc[] 
                    -> theGen.mkArraySignature 
                    -> aS.fieldType[]
               else
                  current.theDesc 
                    -> desc[] 
                    -> theGen.mkSignature 
                    -> aS.fieldType[]
              if);
              (if current.isNone then
                  mch.ldNone
               else
                  (aS[],&mch.dataRegOperand[]) -> mch.ldVal;
              if);
              (desc[],leftIsRep) -> checkText2ExternalString;
              next + 1 -> next;                
           #)
        else
           (* we should clean-up and unify checkText2ES to
            * work in the multiExit case also
            *)
           (sig.XXsig.theDesc,rElm[],sig.XXsig.elmType=12(*array*))
             -> checkText2ES;
           next+1 -> next;              
       if)
    #)
---bytecodeVal_methodCall_asgToList:doPart--
   (* Assign
    *    M -> (E1,E2,...En)
    * where M  = this(methodCall)
    * and   EV = (E1,E2,...,En)
    *)   
do (# lEV: @ExitMultiVal; exitNo: @integer;
      nextEVlistElm: @|
        (# E: @ASTindex
        do EV -> scanList
           (#
           do currentNode -> E;
              SUSPEND
           #)
        exit E[]
        #);
      E: ^ASTindex
        
   do 301->trace(#
                do 'asgToList:'->display;
                   'Right: ' -> xT; EV[] -> xA 
                #);
      
      sig.XXsig.asText 
        -> lEV.class[]
        -> theGen.AllocAndStoreTmp 
        -> lEV.tA[];
      (* here we should probably use sig.scanExit
       * to get the correct type of the exit-elements;
       * we should use gNXL on each element Ei in EV
       * to enumerate the enter-elements of Ei;
       * this should fix the type problem in tstnxoff
       * - which does not run with sun-java but is ok
       * with gij
       *)
      sig.scanExit
      (# more: @boolean; 
         xNo: @integer;
         gNXL: ^| sematt.getNXlength
      do (if (xNo+1 -> xNo) = (exitNo+1) then
             nextEVListElm -> E[];
             301->trace(# do E[] -> xA #);
             &|sematt.getNXlength[] -> gNXL[];
             (E[],true,rChain[]) -> gNXL -> more; 
             L: (if more then 
                    exitNo+1 -> exitNo -> lEV;
                    301->trace(#
                              do 'exitNo: ' -> xT; exitNo->putInt; xN;
                                 'left:'->xT;
                                 current.asText -> xT; xN;
                                 'right: '->puttext; E[] -> xA; xN;
                                 'rLeafDesc: ' -> xT; xN;
                                 current.theDesc->xAF;
                              #);
                    current.theDesc -> lEV.elmDesc[];
                    current.elmType = 12 -> lEV.isRep;
                    (if lEV.isRep then
                        301->trace(#do 'isRep:'->xT #)
                    if);
                    (BA[],lEV[],E[],false,rChain[]) 
                      -> AssignValToEval 
                      -> V[];
                    C: (if (gNXL -> more) then
                           exitNo+1 -> exitNo;
                           restart C
                       if)
                if);
         if)
      #)
   #)
   
---bytecodeVal_exitMultiVal_asgToRefAdr:doPart--
do (# A: @mch.RegAdr; aS,rA: ^mch.address; 
      destClass: ^text; withQua: @boolean;
      aReg: @mch.adrRegOperand        
   do 301->trace(#
                do 'asgToRefAdr: '->display; 
                   'rAbase: ' -> xT;
                   rAbase.display->xT; xN;
                   'destEv: '->xT; 
                   destEv[] -> xA; 
                   rchain
                #);          
      (rAbase.copy,destEv.sonRef,false,rChain[])->genAdr->rA[];
      (tA[],&mch.adrRegOperand[]) -> mch.ldVal;
      (mkA->aS[],&mch.adrRegOperand[]) -> mch.ldVal; 
      (if isClr then
          1->trace(#
                  do 'exitMultiVal:asgToRefAdr:dup_x1: ' -> xT;
                     'topType: ' -> xT; aS.fieldType[] -> xT;
                     'belowTopType: ' -> xT;
                     tA.fieldType[] -> xT
                  #);
      if);
      (if isMultiple then 
          (1,0,aS.fieldType[],tA.fieldType[]) -> mch.duplicate
      if);
      
      true -> rA.isField;  
      true -> rA.isRef;
      (if destEv.label = gram.structureReference then
          (theGen.StructureSignatureId->theGen.specialSignature).asText 
            -> destClass[]
       else
          rA.bAdr.localDesc[] 
            -> theGen.mkSignature -> rA.fieldType[] -> destClass[];
      if);
      (if (destClass[] <> none) and (aS.fieldType[] <> none) then
          not (destClass[] -> aS.fieldType.equal) -> withQua;
       else
          '\nOBS! destClass[]=none) or (aS.fieldType[]=none)'
            -> putline
      if);
      mch.callO -> aReg; (* signal register on stack *)
      (aReg[],withQua,'???',destClass[]) -> rA.asgRefReg;
      (0,false,destEv[],rChain[]) -> mkComputedRefEvVal -> V[];
   #)
---bytecodeVal_exitMultiVal_asgToMethod:doPart---
do (#
   do 301 -> trace(# do ' asgToMethod: ' -> display #);
      (rElm[],true, rChain[]) -> nxLeafScanner
      (#
      do 301->trace(#
                   do 'nxScanner:'->display; xN;
                      currentDesc[] -> xA
                   #);
         (if (currentDesc-> sematt.descKind) = sematt.standardKind then
             (tA[],&mch.adrRegOperand[]) -> mch.ldVal;
             (mkA,&mch.dataRegOperand[]) -> mch.ldVal; 
          else
             1->trace(#
                     do 'asgToMethod:'->display;
                        'Missing implementation of assignment '
                        'to non-standard descriptor' -> xT
                     #)                        
         if);
      #)
   #)
   
---bytecodeVal_exitMultiVal_asgtoItem:doPart--
do (# gNl: ^| sematt.getNXlength;
      lMore: @boolean
   do 301->trace(#
                do 'asgToItem'->display;
                #);
      (rDesc[],rA[],0,rChain[],true) -> nScan -> more;
      L:
        (if more then
            &|sematt.getNXlength[] -> gNl[];
            (nScan.thisEv[],true,nScan.thisChain[]) -> gNl -> lMore;
            leaf:
              (if lMore then
                  gNL.elmDesc[] -> elmDesc[];
                  gNL.isRep -> isRep;
                  (* gNL.isNone -> ? *)
                  (tA[],&mch.adrRegOperand[]) -> mch.ldVal;
                  (mkA,&mch.dataRegOperand[]) -> mch.ldVal;
                  gNL -> lMore;
                  restart leaf;
              if);
            nScan -> more;
            restart L
        if) 
   #)
   
---bytecodeval_nxLeafScanner:doPart---
do (# scanLeafs:
        (# EV: ^ASTindex;
           isN: @boolean;
           chain: ^DH.superChain;
           gNXl: ^| sematt.getNXlength;     
           lMore: @boolean;
           currentDesc: ^ASTindex;
           isRep,isNone,isStruc: @boolean;
        enter(EV[],isN,chain[])
        do &|sematt.getNXlength[] -> gNXl[];
           (EV[],isN,chain[]) -> gNXl -> lMore;
           leaf:
             (if lMore then
                 gNXl.elmDesc[] -> currentDesc[];
                 gNXL.isRep -> isRep;
                 gNXL.isNone -> isNone;
                 gNXL.isStruc -> isStruc;
                 INNER scanLeafs;
                 gNXL -> lMore;                            
                 restart leaf
             if);
        #);      
      nxScan: @ | scanNXadr;
      more: @boolean;      
   do (if (elm.label = gram.objectDescriptor) then
          (if ((elm->sematt.descKind) = sematt.standardKind) then
              301->trace(#do 'nxLeafScanner:simple:'->xT; elm[] -> xAF #);
              elm[] -> currentDesc[];
              INNER nxLeafScanner;
           else
              301->trace(#do 'nxLeafScanner: ' -> xT; elm[] -> xAF #);
              isN -> nxScan.isN;
              (elm[],none(*not used*),0,chain[]) -> nxScan -> more;
              interior:
                (if more then
                    (nxScan.thisEv[],isN,nxScan.thisChain[]) -> scanLeafs
                    (#
                    do currentDesc[] -> this(nxLeafScanner).currentDesc[];
                       isRep -> this(nxLeafScanner).isRep;
                       isNone -> this(nxLeafScanner).isNone;
                       isStruc -> this(nxLeafScanner).isStruc;
                       INNER nxLeafScanner;
                    #);
                    nxScan -> more;
                    restart interior
          if)if)
       else
          301->trace(#
                    do 'nxLeafScanner:notDesc:label: ' -> xT; xN;
                       elm.label -> xI; xN;
                       elm[] -> xA; xN;
                       chain
                    #);
          (elm[],isN,chain[]) -> scanLeafs
          (#
          do currentDesc[] -> this(nxLeafScanner).currentDesc[];
             isRep -> this(nxLeafScanner).isRep;
             isNone -> this(nxLeafScanner).isNone;
             isStruc -> this(nxLeafScanner).isStruc;
             INNER nxLeafScanner;
          #)
      if)      
   #)
---byetcodeval_checkCast:doPart---
do (# pd: @integer;
      found: @boolean;

   do 301 -> trace(#
                  do 'checkCast:lIsRep: '->xT; lIsRep->xB; xN;
                     lDesc[] -> xAF; xN;
                     rDesc[] -> xAF; 
                  #);
      (if true 
       // (lDesc->sematt.textDesc.equal)
          and ((rDesc[] -> theGen.isExternalString)
          or (enterTypes[next] = 13 (* external *)))
          then
          (if true then              
              (common.BetaText2ExternalString,none) -> mch.callPrimNo
           else
              'BetaText2ExternalString' -> mch.callprim 
          if)
          
       // (lDesc[] -> theGen.isExternalString) 
          and ((rDesc->sematt.textDesc.equal) 
          or (enterTypes[next] = 14 (* textDesc *)))
          then
          (if true then
              (common.ExternalString2BetaText,none) -> mch.callPrimNo
           else
              'ExternalString2BetaText' -> mch.callprim
          if)
          
       // (lDesc->sematt.textDesc.equal)
          and rIsRep (*and (enterTypes[next] = 12 (* array )*) then
          (* using enterTypes is perhaps not so nice *)
          (* check this?*)
          (if true then
              (common.BetaText2BetaCharArray,none) -> mch.callPrimNo
           else
              'BetaText2BetaCharArray' -> mch.callPrim
          if)
       else
          (* needs clean-up *)
          (if not lIsRep
              and (enterTypes[next] = 12 (* array *)) then
              baseAdr.copy -> rA[];
              (rElm[],rChain[],rA[]) -> getElmDesc -> desc[];
              301->trace(#
                        do rElm[]->xA; xN; 
                           desc[]->xA; desc.size -> xI 
                        #);
              desc.size -> rA.size;
              desc[] -> rA.bAdr.localDesc[];
              INNER CheckCastX
           else
              (if (lDesc->sematt.descKind) <> sematt.standardKind then
                  (lDesc[],rDesc[]) -> sematt.ChkQua -> (pd,found);
               else
                  true -> found;
                  (if ((lDesc[]->sematt.type) = sematt.valType)
                      and
                      (rDesc -> sematt.realDesc.equal) then
                      mch.int2float
              if)if);
              (if not found then
                  301->trace(#
                            do 'cast: ' -> xT;
                               lDesc[] -> xAF; xN;
                               rDesc[] -> xAF;
                            #);
                  rDesc[]-> theGen.mkSignature -> mch.checkCast
      if)if)if)
   #);

