ORIGIN 'bytecodeval'
---bytecodevalbody:dopart---
do EV.son -> VN;
   (if stest then
       301->trace(# 
                 do 'mkBytecodeCall: ' -> xT; EV[] -> xA; VN[] -> xA;
                    EV.sonRef -> xA
                 #)
   if);
   thisDesc -> theThisDesc;
   (if VN.label = gram.objectDescriptor then
       (VN,common.itemKind,2,null)->DS.push       
   if);
   (EV.sonRef,chain[],true) -> sig.setMethodDesc; 
   &ASTindex[] -> receiverDesc[]; 

   (if VN.label 
    // gram.remote then
       (# md,org: @ASTindex; mdo: ^ASTindex
       do (* VN = R.foo *) 
          VN.son -> receiver;
          receiver.brother -> method;
          sig.thisMethodDesc.origin -> org;
          (if org.label = gram.attributesForm then
              true -> isStatic;
           else
              (if false then
                  (if receiver.label = gram.thisObject then
                   else
                      (* OBS receiver is NOT used anymore *)
                      receiver -> sematt.getName -> receiver; 
                  if);
                  (* receiver = R, method = foo *)  
                  (* NOTE! below is an alternative - and correct - method
                   * for computing the desc of the receiver; we just use
                   * the origin of the method desc. In most cases this is the
                   * same as above, but for virtual methods bound to global
                   * patterns, this is not the same; the above code should
                   * be removed
                   *)
              if);
              (* EV = R.foo 
               * NOTE: EV is reference or similar, and then
               *       EV.sonRef = (remote <R> <foo> )
               *)
              301->trace(#
                        do 'mkBytecodecall:remote:'->xT; 
                           EV[] -> xA;
                           ' sonRef: '->xT; EV.sonRef -> xA
                        #);
              (thisDesc[],EV.sonRef) 
                -> GetActualDesc 
                -> (md,descKind);
              301->trace(#
                        do 'mkBytCodeCall: ' -> xT; md[] -> xA
                        #);
              (* Problem with
               *   T: (# foo: (# ... #) #)
               *   TT: T(# #);
               *   R: ^TT
               *   R.foo
               * method:  (# ... #) i.e. desc of foo
               * receiver: origin(method) = T
               * it should be TT
               *   T: (# V:< A #);
               *   TT: T(# V:: AA #);
               *   TTT: TT (# #)
               *   S1: ^TT;
               *   S2: ^TTT
               *   S1.V;  - is reciever origin of AA or the most specific
               *   S2.V   - subpattern of origin of AA? 
               *            then it is complicated
               *)
              md[] -> sematt.descOrigin -> mdo[];
              301->trace(#
                        do 'mkByteCall:remote:mdo:'->xH; mdo[] -> xA; xN;
                           md[] -> xA
                        #);
              (EV.sonRef,mdo[],md[]) -> findReceiver -> mdo[];
              mdo -> receiverDesc;
              true -> isRemote;
              (if true then
                  (* compute receiver as actual desc of R in R.foo 
                   * previously we could not do this for virtuals
                   * bound to global patterns???
                   *)
                  
              if);
              (if (md->sematt.descKind) 
               // sematt.staticProcKind then
                  true -> isRealStatic;
                  sig.markRealStatic; (* isStatic is used for
                                       * patterns at outermost levels
                                       * in lib-files
                                       *)
               // sematt.consKind then
                  301->trace(#
                            do 'mkByteCodeCall:cons: '->xT;
                               'methodDesc: ' -> xT; md[] -> xA; xN;
                               'receiverDesc: '->xT; receiverDesc[] -> xA;
                            #);
                  (* Create instance of: receiverDesc
                   * with constructor  : methodDesc
                   *)
                  true -> isCons;
                  md -> method
              if);
              301 -> trace(# 
                          do 'mkByteCodeCall:remote:2: ' -> xH;
                             'methodDesc: ' -> xT; md[] -> xA; xN;
                             'receiverDesc: '->xT; receiverDesc[] -> xA;
                          #)
          if)
       #)
       
    // gram.nameApl then
       (* VN = foo 
        * means: originN....origin2.origin1.foo
        * N >= 0
        *)
       VN -> method;
       testLibLevel: (* is this a pattern at the outermost lib level *)
         (# org: @ASTindex
         do sig.thisMethodDesc.origin -> org;
            (* dont work if virtual?*)
            (if org.label = gram.attributesForm then
                301->trace(#
                          do 'Pattern: ' -> xT;
                             VN[] -> xA;
                             ' is at the outermost lib level' -> xT
                          #);
                true -> isStatic;
             else
                (* check the case where VN is as in
                 *     VN: @<<SLOT XXX:descriptor>>
                 *   do ...; VN; ...
                 *   ---XXX:descriptor---
                 *   (# ... enter(...) do ... exit ... #)
                 * I.e. the enter/exit-part is in the form;
                 *)
                (# D: @ASTindex
                do VN.descRef -> D;
                   (if D.isSlot then
                       D.slotOrigin -> D;
                       (if D.label = gram.attributesForm then
                           true -> isStatic;
                           leave testLibLevel
                   if)if)
                #);
                (* to find originN, go origin meth.N times *)
                thisDesc -> receiverDesc;
                (for i: method.on repeat
                     receiverDesc[] -> sematt.descOrigin -> receiverDesc[]
                for);
                (if false then
                    (* ok for calling V declared as V:: T
                     * not ok for     V declared as V:< T
                     *)
                    (# md: @AStindex; mdo: ^AStindex
                    do (thisDesc[],EV.sonRef) 
                         -> GetActualDesc 
                         -> (md,descKind);
                       md[] -> sematt.descOrigin -> mdo[];
                       mdo -> receiverDesc;                  
                #)if)
            if);
         #)
    // gram.objectDescriptor then
       301->trace(#
                 do 'objectdescriptor: ' -> xT;
                    VN[] -> xA;
                 #);
       VN -> method; (* NOTE: VN IS AN OBJECTDESCRIPTOR *)
       method -> receiverDesc;
       (* Here we need to find the right origin of the method *)
       receiverDesc[] -> sematt.descOrigin -> receiverDesc[];
       (if receiverDesc.label 
        // gram.descriptorForm 
        // gram.doPart then
           receiverdesc.xorigin -> receiverdesc;
           receiverdesc.slotOrigin -> receiverdesc;
       if);
       true -> isSingular;

    // gram.unExpanded then
       301->trace(#
                 do 'MkByteCodeCall:DescriptorSlot: ' -> xT; VN[] -> xA 
                 #);
       VN[] -> sematt.enclosingDesc -> receiverDesc[];
       
       receiverDesc[] -> theGen.descLocation -> sig.location[];
       301->trace(#
                 do 'mkByteCodeCall:unExpanded:receiverLocation: "' -> xT;
                    (if sig.location[] = none then 
                        'none' -> xT
                     else 
                        sig.location[] -> xT
                    if);
                    '"' -> put
                 #);
       VN -> method;
       (VN,common.itemKind,3,VN) -> DS.push;
       true -> isSingular (* hack *)
    // gram.computedRemote then
       (# MN,isVirt: @integer; xchain: ^DH.superChain;
          remEv,N,ref,refDesc: ^ASTindex;
          (* (E).method 
           * DOES NOT WORK
           *)
       do VN.son -> receiver;
          receiver.brother -> method;
          L: receiver->scanList(#do currentNode->receiver; leave L #);
          301->trace(#
                    do 'mkByteCodeCallX: ' -> xT;
                       VN[] -> xA
                    #);
          (VN[],DH[],chain[]) 
            -> sematt.chkComputedEval 
            -> (remEv[],N[],ref[],receiverDesc[],xchain[]);
          301->trace(#
                    do 'mkByteCodeCallY: ' -> xT;
                       receiverDesc[] -> xA
                    #);
       #)
    else
       '\n**** insert is NOT remote or nameApl'->putline
   if);
   (if isCons then
       (* 1->trace(#
        do 'cons: ' -> xT; receiverdesc[]->xA #);*)
       (receiverDesc[],common.itemKind) -> theGen.newInstance
       (# 
       do (method[],false,chain[]) -> consSig.addConstructorDesc;
          (*1->trace(#
           do 'X:'->xT; conssig.astext->xT; xN;
           hasOrigin -> xB;
           100->switchon;
           method[]->xA;xN;
           VN[] -> xA;
           100->switchoff
           #);*)
          false -> sig.isStatic;
          'olsen' -> sig.addMethod;
          method[] -> sig.addEnter;
          sig.setVoidXSig; 
          (*1->trace(#do sig.astext -> xT #);*)
          ((receiverDesc[],true) -> descName,receiverDesc[]) 
            -> sig.addReceiver;
          (if hasOrigin then '\ngenorg'->putline;
              (baseAdr.copy,theThisDesc[],VN[],EHchain[])
                -> genOrgAdrToOrgReg
                -> OA[];
          if);
          INNER MkByteCodeCall
       #);
       (mch.thisRegOp,false,EV[],chain[]) -> mkComputedRefEvVal -> W[]
    else
       (if not isStatic then
           ('G',receiverDesc[]) -> mkEntryPoint -> (class[],local);
           301->trace(#
                     do 'mkByteCodeCall:receiver: ' -> xT; class[] -> xT; xN;
                        receiverDesc[] -> xA
                     #);
           (class[],receiverDesc[]) -> sig.addReceiver;
       if);
       L:
         (if not isSingular then
             method.dclRef -> finalMethod;
             finalMethod.sort -> finalMethod;
             301 -> trace(#
                         do 'mkBytecodeCall:method.dclRef: ' -> xT;
                            finalMethod[] -> xA
                         #);

             (if finalMethod.label = gram.finalDecl then
                 true -> isFinal;
                 method.dclRef -> finalMethod;
                 (if not isRemote then
                     (# md: @AStindex; mdo: ^AStindex
                     do (thisDesc[],EV.sonRef) 
                          -> GetActualDesc 
                          -> (md,descKind);
                        md[] -> sematt.descOrigin -> mdo[];
                        mdo -> receiverDesc;                  
                        ((receiverDesc[],true) -> descName,receiverDesc[]) 
                          -> sig.addReceiver
             #)if)if);         
             method.descRef -> method;
             301 -> trace(#
                         do 'mkBytecodeCall:method.descref: ' -> xT;
                            method[] -> xA
                         #);
             LL: 
               (if method.label 
                // gram.objectDescriptor 
                // gram.unExpanded then
                   method -> receiverDesc
                // gram.finalDecl then (** ??? **)'FINAL'->putline;
                // gram.bindingDecl then

                   method.son -> method;
                   L:
                     method -> scanList
                   (# do currentNode -> method; leave L #);
                   method.virtDcl -> method;
                   method.sort -> method;
                   restart LL
                   
                // gram.virtualDecl then
                   method.son -> method;
                   method.brother -> method; (* assume desc here *)
                   false -> isStatic; (* V:< T never be in an attributes form *)
                   true -> isVirtual;
                   (* perhaps we should explicitly set the receiver? *)
                   (if (EV.sonRef).label = gram.nameApl then
                       (* are we sure the other cases are covered? *)
                       (*1->trace(#
                        do 'mkByteCodeCall:virtual: ' -> xT; EV[] -> xA; 
                        ' on:'->xT; (EV.sonRef).on -> xI; xN;
                        thisDesc[] -> xA
                        #);*)
                       thisDesc -> receiverDesc;
                       (for i: (EV.sonRef).on repeat 
                            receiverDesc[] -> sematt.DescOrigin -> receiverDesc[]
                       for);
                       (EV.sonRef,receiverDesc[],none) 
                         -> findReceiver -> receiverDesc[];
                       ((receiverDesc[],true)->descName,receiverDesc[]) 
                         -> sig.addReceiver;
                   if)
                // gram.variablePattern then
                   (* R: (# F: ##T
                    *    do ... F
                    * receiverDesc: R
                    * methodName  : F
                    * methodDesc  : T
                    *)
                   301->trace(#
                             do 'mkByteCodeCall:varPtn: ' -> xT;
                                EV[] -> xA;
                             #);
                   true -> isVarPtn;
                   false -> isStatic;
                   method[] -> sematt.EncDescOfNode -> receiverDesc[];
                   ((receiverDesc[],true)->descName,receiverDesc[]) 
                     -> sig.addReceiver;
                   sig.thisMethodDesc -> method;
                   301->trace(#
                             do 'mkByteCodeCall:varPtn:X: ' -> xH;
                                'receiver: '->xT; receiverDesc[] -> xA; xN;
                                'methodName: ' -> xT; VN.gettext -> xT; xN;
                                'methodDesc: ' -> xT; method[]->xA
                             #);
               if);
             301 -> trace(# 
                         do 'call2:'->xH; 
                            ' receiver: '->xT; receiverDesc[] -> xA; xN; 
                            'method: '->xT; method[] -> xA; 
                         #)   
         if);

       (if isStatic then
           ((method[],true) -> descName,method[]) -> sig.addReceiver;
           sig.markStatic
       if);
       (* set the name of the method *)
       (if isVarPtn then
           VN.gettext -> sig.addMethod;
        else 
           (if (sig.thisMethodDesc -> sematt.descKind) 
            // sematt.procKind 
            // sematt.staticProcKind then
               method[]  -> theGen.getExternalClassName -> sig.addMethod
            else
               (*1->trace(#do 'addMethod: ' -> xT; method[] -> xA; xN;
                'VN: ' -> xT; VN[] -> xA;
                'VN.text: ' -> xT; VN[] -> getDclName -> xT
                #);*)
               (if isFinal and isRemote then
                   VN[] -> getDclName -> sig.addMethod 
                else
                   (method[],false) -> descName -> sig.addMethod
               if)
           if)
       if);
       (* the following should be generalised? *)
       (*1->trace(#
        do 'isSlot: ' -> xT; method.isslot -> xB; xN;
        method[] -> xA; xN;
        sig.thismethoddesc[] -> xA
        #);*)

       (if method.isSlot then
           (if sig.thisMethodDesc.isSlot then
               (* probably only the second check is needed *)
               sig.noEnter
            else
               sig.addEnter
           if)
        else
           method[] -> sig.addEnter
       if);
       
       (if method.isSlot then
           sig.setVoidXSig
        else
           (# p,mp,att,n,doP,exitP,EV: ^ASTindex; S: ^text
           do sig.thisMethodDesc[] (* descriptor for method *)
                -> sematt.descSonsRef
                -> (p[],mp[],att[],n[],doP[],exitP[]);
              
              (if exitP[] <> none then
                  exitP[] -> sig.addExit
               else
                  sig.setVoidXSig
              if)
       #)if);
       sig.asText -> class[];
       301 ->trace(#do 'class: ' -> xT;  class[] -> xT #);
       (if not hasArguments 
           and (((sig.NNsig.top > 0) and not isStatic)
           or ((sig.NNsig.top > 1) and isStatic)) then
           (* is receiverDesc the right originDesc here?
            * is it ok with topDesc = none
            *)
           (# xD: @ASTindex; ba: ^mch.address;
              oldReturnSaved,oldInNDX: @boolean;
              mDesc: ^ASTindex;
           do thisDesc->xD;
              theThisDesc -> thisDesc;
              baseAdr.copy -> ba[];
              inEnterDoExitMethod -> oldInNDX;
              theGen.returnSaved -> oldReturnSaved;            
              (* instead of this clumsy save of global state,
               * we should make a new instance of theGen
               *)
              301 ->trace(#
                         do 'mkByteCodeCall:inlineMethod1:'->xT;
                            method[] -> xA; 
                            ' VN: ' -> xT; VN[] -> xA;
                            ' on: ' -> xT; VN.on -> xI;
                            xN;
                            'thisDesc: ' -> xT;
                            thisDesc[] -> xA; xN;
                            'theThisDesc: '->xT; 
                            theThisDesc[] -> xA; xN;
                            'baseAdr.bAdr.localDesc: ' -> xT;
                            baseAdr.bAdr.localDesc[] -> xA; xN;
                            baseadr.display->xT; 
                         #);
              (if isVirtual then
                  301->trace(#do 'Virtual:genPtnMethod: '->xT; method[]->xA #);
                  method[] -> mDesc[];
               else
                  sig.thisMethodDesc[] -> mDesc[]
              if);
              ('inline$',mDesc[]
              ,false,false,receiverDesc[],none(*?*)
              ,true,false,true)
                -> theGen.genPtnMethod
              (# 
              do xD -> thisDesc;
                 (baseAdr.copy,theThisDesc[],VN[],EHchain[])
                   -> genOrgAdrToOrgReg
                   -> OA[];
                 xD -> thisDesc;
                 ba[] -> baseAdr[];
              #);
              xD -> thisDesc;
              ba[] -> baseAdr[];
              oldInNDX -> inEnterDoExitMethod;
              301 ->trace(#
                         do 'mkByteCodeCall:inlineMethod2:'->xT; 
                            method[]->xA; xN;
                            baseAdr.bAdr.localDesc[] -> xA; xN;
                            baseadr.display->xT; xN;
                            thisDesc[] -> xA
                         #);
              (if thisDesc.label = gram.doPart then
                  (* we should probably always do this *)
                  theRealDesc[] -> theGen.InitGen
                  (#
                  do &ASTindex[] -> doP[]; 
                     thisDesc.son -> doP;                 
                     doP[] -> setDoP
                  #);
                  (theRealDesc[],true) -> theGen.initPtnGen;
                  xD -> thisDesc; (* is overwritten by initPtnGen *)
                  301->trace(#
                            do 'mkByteCodeCall:inlineMethod2:'->xT; 
                               'TheRealDesc: ' -> xT; theRealDesc[] -> xA; xN;
                               'FormDesc: ' -> xT; FormDesc[] -> xA; xN;
                               'ThisDesc: ' -> xT; thisDesc[] -> xA; xN;
                            #);
                  
                  
               else 
                  (thisDesc[],false) -> theGen.initPtnGen
              if);
              oldReturnSaved -> theGen.returnSaved; (* is set to false
                                                     * in initPtnGen
                                                     *)
           #)
        else
           (if isFinal and isRemote then
               (baseAdr.copy,VN.sonRef,false,EHchain[])->genAdr->OA[];
               301->trace(#
                       do 'mkBytecodeCall: ' -> xT;
                          VN[] -> xA; xN;
                          OA.receiverType[] -> xT; xN;
                          OA.fieldType[] -> xT; xN;
                            class[] -> xT; xN;
                            (if OA.bAdr.dclDesc[] = none then
                                'dclDesc:isNone'->xT; xN
                             else
                                OA.bAdr.dclDesc[] -> xAF; xN;
                            if);
                          OA.bAdr.localDesc[] -> xAF; 
                       #);
               (OA[],mch.adrTop[]) -> mch.ldVal;
               (if (OA.bAdr.dclDesc[] <> none)
                   and not (OA.bAdr.dclDesc -> OA.bAdr.localDesc.equal) then
                   (* A cast is probably needed *)
                  (* 1->trace(#do 'cast:' -> xT;  class[] -> xT #);*)
                   OA.bAdr.localDesc[]->theGen.mkSignature  -> mch.checkCast
               if);
            else
               (baseAdr.copy,theThisDesc[],VN[],EHchain[])
                 -> genOrgAdrToOrgReg
                 -> OA[];
           if);
           INNER;       
           (# isValueTypeCall: @boolean;
           do (if (sig[]<>NONE) and (sig.receiver[]<>NONE) then
                  (if common.isJVM then
                      (* inx 2 is used for JVM since fieldType = 'L@value...' *)
                      ((2->sig.receiver.inxGet)='@') -> isValueTypeCall
                  if);
                  (if common.isCLR then
                      ((1->sig.receiver.inxGet)='@') -> isValueTypeCall
                  if);
              if);
              (class[]->mch.newTextOp,'M',local,isStatic or isRealStatic, isValueTypeCall)
                -> mch.gJsr;  
           #);
       if);
       (if not hasExit and (sig.XXsig.elmType <> 10 (*void*)) then
           (if sig.XXsig.elmType = 6 (* real/double *) then
               true -> mch.popStack
            else
               mch.popStack
       if)if);
       301->trace(#
                 do 'mkByteCode:end: '->xT; sig.asText -> xT; sig.thischain
                 #);
       (sig[],sig.thisChain[]) -> methodCall -> W[]
   if);
---bytecodeval_methodArgs_asgToMethod:doPart---
do 301->trace(#
             do 'asgToMethod:'->display; xN;
                'next: ' -> xT; next -> xI; 
                ' noOfArgs:' -> xT; noOfArgs->xI; 
                (for i: noofArgs repeat
                     (if i <= enterTypes.range then
                         enterTypes[i]->xI
                      else
                         '# ' -> xT
                     if)
                for);
                xN;
                'rElm: ' -> xT; rElm[] -> xA;
                rChain
             #);
   (if llEV[] <> none then
       (*1->trace(#
        do 'eval:assignToList:'->xT; llEV.display; xN;
        lEv[] -> xA
        #);*)
       (baseAdr[],llEv[],lEv[],true,lChain[])
         -> assignValToEval
         -> V[]
    else          
       (baseAdr[],lEv[],true,lChain[])
         -> ExpEval
         -> V[];
   if);
   301->trace(#
             do 'asgToMethod2: '->display; V.display;
                rChain
             #);
   
   (enterTypes,noOfArgs,next,rElm[],rChain[]) 
     -> V.asgToMethod
     -> next;
   
---bytecodeval_enterArgs_asgToRefAdr:doPart---
do (# rA: ^mch.address
   do 301 -> trace(#do 'asgToRefAdr:'->display #);
      (rAbase[],destEV.sonRef,false,rChain[]) -> genAdr -> rA[]; 
      (if destEv.label = gram.structureReference then
          (theGen.StructureSignatureId->theGen.specialSignature).asText 
            -> rA.fieldType[]
      if);
(*      1->trace(#do rA.isInxRegAdr -> xB #);*)
      
      (isMultiple,true,false,rA.isInxRegAdr,rA.fieldType[],rA.bAdr.localDesc[]) 
        -> eval 
        -> V[];
      (rA[],destEV[],rChain[]) -> V.asgToRefAdr -> V[];
      
      (if isMultiple and not isJava then mch.loadLocal if);
   #)
   
---bytecodeval_enterArgs_asgToItem:doPart---
do 301->trace(#do 'asgToItem:'->display; #);
   (if llEV[] <> none then
       301->trace(#
        do 'asgToItem:Multiple:'->display; llEV.display; xN;
        lEv[] -> xA
        #);
       (baseAdr[],llEv[],lEv[],true,lChain[])
         -> assignValToEval
         -> V[]
    else
       (baseAdr[],lEv[],true,lChain[])
         -> ExpEval
         -> V[]
   if);
   (rDesc[],rChain[],false(*?*)) -> sig.setMethodDesc;
   rDesc[] -> sig.addEnter;
   sig.exitVoid;
   (# T: [sig.noOfEnterArgs] @integer;
      top: @integer
   do sig.scanEnter
      (#
      do current.elmType -> T[top+1 -> top]
      #);
      (T,top,1,rDesc[],rChain[]) -> V.asgToMethod
   #)
---bytecodeval_enterArgs_eval:doPart---
do (# isExternalString,doMarkMultiple: @boolean        
   do 301->trace(#
                do 'eval:'->display; xN;
                   'dup: ' -> xT; dup->xB;
                   'pushVal:'->xT; pushVal->xB;
                   'isSimpleVal:' ->xT; isSimpleVal -> xB;
                   'isRepAdr:'->xT; isRepAdr -> xB;
                   'rType:'->xT; rType[] -> xT; xN;
                   (if llEV[]<>none then 
                       'llEV:'->xT; llEV.display;; xN;
                   if);
                   'lEV:'->xT; lEV[] -> xA
                #);
      (if inEnter then false -> inEnterDoExitMethod if);
      (if llEV[] <> none then
          301->trace(#
                    do 'eval:assign:'->xT; llEV.display; xN;
                       lEv[] -> xA;
                       ' dup:'->xT; dup -> xB
                    #);
          (* Multiple assignment: llEV -> lEV
           * Case ente(a->b)
           *   llEV = enterArgs
           *   lEV  = a   or a -> b
           *   dup  = true
           *   The dup should be part of assignValToEval
           *   and not after 
           * llEv.pushVal -> llEv[]; - dont work since adr
           * of lEv is not computed
           *)
          (*llEV.markMultiple;*)
          (baseAdr[],llEv[],lEv[],true,lChain[])
            -> assignValToEval
            -> V[]
       else
          (baseAdr[],lEv[],true ,lChain[]) 
            -> ExpEval
            -> V[]
      if);
      (if false then
          1->trace(#
                  do 'string2text?: '->display;
                     V.type->xA; xN;
                     rType[] -> xT; xN; rDesc[] -> xA; xN;
                     'L/R: ' -> xT;
                     V.type = none -> xB; xN;
                     V.type->theGen.isExternalString -> xB;
                     (if rDesc[] <> none then
                         rDesc->sematt.textDesc.equal -> xB
      if)#)if);
      (if (rDesc[] <> none)
          and (V.type->theGen.isExternalString)
          and (rDesc->sematt.textDesc.equal) then
          (* In: 'exit S[] -> T[]' we should avoid
           * a dup of S[] - since we return a T[],
           * i.e. T[] should be duplicated - this must
           * take place in refEval.asgtoRefgAdr.
           * The same should probably also be done
           * for the text2string case
           *)
          (if dup then
              true -> doMarkMultiple;
              false -> dup
          if)
      if);
      (if false then
          (if (V.evType = 1 (* could be char*))
              and (rDesc[]<>none)
              and (sematt.repDesc->rDesc.equal) then
              (* could be 'a' -> R - in which case we should push 'a'
               * or R.foo -> R where foo returns a char literal and
               * here the value is already on the stack
               *)
              (* true -> pushVal -> isSimpleVal*)
      if)if);
      (if V[] = none then '\nMethodArgs:eval:V is none ' -> putline if);
      301->trace(#
                do 'eval2:'->display; 'dup:'->xT; dup->xB; xN; 
                   V.display 
                #);
      (if pushval then
          (* we need the rType here for text/const literals;
           * this is tricky and should be reconsidered;
           * also since dup_x1 does not exist on .NET
           *)
          (* reconsider structure of pushVal here and in txtcstval *)
          (rType[]<>none) 
          and ((isJava and ('java/lang/String' -> rType.equal)) 
          or ('class [mscorlib]System.String'->rType.equal))
            -> isExternalString;
          (if isExternalString then
              (* to avoid conversion to BETA text - clumsy *)
              true -> V.pushVal -> V[]
           else
              isSimpleVal -> V.pushVal -> V[]
          if);
          301->trace(#do 'eval3: V:'->display; V.display #);
          (if not isSimpleVal and not isExternalString then
              V.mkBetatext; (* reconsider *)
          if)    
      if);
      (* FIXME: the following is very messsy *)
      (if (V.evType = 1 ) and false
          and (rDesc[]<>none) 
          and (sematt.repDesc->rDesc.equal) then
          'char2rep' -> mch.callPrim
       else
          (if not isSimpleVal
              and (rType[]<>none) 
              and (rType.length > 0) (* from asgToRep *)
              and (V.evType<>4 (* strucref->Structure *))
              and (rDesc[] <> none) and not (sematt.textDesc->rDesc.equal)
              (* In X.get -> T[]
               * get may return externalString
               * and T may be a text;
               * here we avoid a text-cast
               * instead a coersion is made
               * in textVarVal; but ugly
               *)
              and not (V.type -> theGen.mkSignature -> rType.equal) then
              rType[] -> mch.checkCast
      if)if);
      (if dup then
          (if isJava then
              (if isRepAdr then
                  (2,0) -> mch.duplicate
               else
                  (if V.evType = 3 (* float *) then
                      (1,1) -> mch.duplicate
                   else
                      (1,0) -> mch.duplicate
                  if)
              if)
           else
              301->trace(#do 'eval4: V:'->display; V.display #);
              (0,0) -> mch.duplicate;
              V.type -> theGen.mkSignature ->  mch.allocAndStoreLocal
          if)
      if);
      (if doMarkMultiple then V.markMultiple if);
      (if inEnter then
          true -> inEnterDoExitMethod
      if)
   #)
---bytecodeval_enterArgs_asgToMethod:doPart---
do 301->trace(#
             do 'asgToMethod:'->display;
                'noOfArgs: ' -> xT; noOfArgs -> xI;
                ' enterTypes.range: ' -> xT;
                enterTypes.range -> xI;
                ' next:'->xT; next -> xI;
                (if (next + noOfArgs) > enterTypes.range then
                    xN;
                    '(next + noOfArgs) > enterTypes.range '
                      -> xT;
                if); 
                xN;
                ' elms:'->xT;
                (for i: noOfArgs repeat
                     enterTypes[i] -> xI
                for)
             #);
   (if (next + noOfArgs - 1) > enterTypes.range then
       (* HACK: we assume that method is static
        * and that first argument - enlosing object -
        * has been pushed by genOrgAdr.
        * Ex:
        * ---lib:attributes---
        * descNo: (# N: @integer enter N do ... #);
        * descId: (# enter ((a,b),descNo) do ... #)
        *)
       noOfArgs - 1 -> max
    else
       noOfArgs -> max
   if);
   (for i: max repeat
        (if enterTypes[next] 
         // 11 // 12 // 13 // 14 then
            'SomeClass' -> pushNext;
         // 6 (* real/double *) // 7 (* real32 *) then
            'D' -> pushNext 
         // 8 (* long=int64*) then
            'J' -> pushNext
         else
            pushNext 
        if);
        next + 1 -> next
   for);
   (* OBS. check that moved 'inner' in mkByteCodeCall is OK
    * We need the descriptor - it may be singular -
    * it must be called as a a method; i.e. 
    * treated like an inner pattern with method-version
    * and new-version
    *)
   next + max -> next 
   
---bytecodeval_methodCall_asgToMethod:doPart---
do  (# QQnxLeafScanner:
         (# elm: ^ASTindex;
            isN: @boolean;
            rChain: ^DH.superchain;
            currentDesc: ^ASTindex;
            isRep: @boolean;
            
            nxScan: @| scanNXadr;
            gNXl: ^| sematt.getNXlength;     
            more,lMore: @boolean
         enter(elm[],isN,rChain[])
         #);
       checkCastx:
         (# lDesc,rDesc: ^ASTindex;
            lIsRep,rIsRep: @boolean;
            pd: @integer;
            found: @boolean;
            
         enter(lDesc[],lIsRep,rDesc[],rIsRep)
         do 301 -> trace(#
                     do 'checkCast:lIsRep: '->xT; lIsRep->xB; xN;
                         lDesc[] -> xAF; xN;
                         rDesc[] -> xAF; 
                    #);
            (if true 
             // (lDesc->sematt.textDesc.equal)
                and ((rDesc[] -> theGen.isExternalString)
                      or (enterTypes[next] = 13 (* external *)))
                then
                'BetaText2ExternalString' -> mch.callprim 
                
             // (lDesc[] -> theGen.isExternalString) 
                and ((rDesc->sematt.textDesc.equal) 
                     or (enterTypes[next] = 14 (* textDesc *)))
                then
                'ExternalString2BetaText' -> mch.callprim
                
             // (lDesc->sematt.textDesc.equal)
                and rIsRep (*and (enterTypes[next] = 12 (* array )*) then
                (* using enterTypes is perhaps not so nice *)
                (* check this?*)
                'BetaText2BetaCharArray' -> mch.callPrim
             else
                (* needs clean-up *)
                (if not lIsRep
                    and (enterTypes[next] = 12 (* array *)) then
                    baseAdr.copy -> rA[];
                    (rElm[],rChain[],rA[]) -> getElmDesc -> desc[];
                    301->trace(#
                              do rElm[]->xA; xN; 
                                 desc[]->xA; desc.size -> xI 
                              #);
                    desc.size -> rA.size;
                    desc[] -> rA.bAdr.localDesc[];
                    (desc[],rElm[],rChain[],rA[],true) -> asgVal2Rep
                 else
                    (if (lDesc->sematt.descKind) <> sematt.standardKind then
                        (lDesc[],rDesc[]) -> sematt.ChkQua -> (pd,found);
                     else
                        true -> found
                    if);
                    (if not found then
                        301->trace(#
                                do 'cast: ' -> xT;
                                   lDesc[] -> xAF; xN;
                                   rDesc[] -> xAF;
                                #);
                        rDesc[]-> theGen.mkSignature -> mch.checkCast
            if)if)if)
         #);

       checkText2ES:
         (# lDesc,rDesc: ^ASTindex;
            leftIsRep: @boolean;

         enter(lDesc[],rDesc[],leftIsRep)            
         do (if (rDesc[]<>none) then
                301->trace(#
                          do 'ct2e:'->xT;
                             lDesc[]->xAF; xN;
                             rDesc[] -> xAF;
                          #);
                (rDesc[],true,rChain[]) -> nxLeafScanner (* scan enter *)
                (#
                do (lDesc[],leftIsRep,currentDesc[],isRep) -> checkCastX
                #)
            if)
         #);
       checkText2ExternalString:
         (# d: ^ASTindex;
            leftIsRep: @boolean;
            sourceClassName: ^text
         enter(d[],leftIsRep)
         do (if (d[]<>none) then
                301->trace(#
                          do 'ct2ex:'->xT;
                             d[]->xAF; xN;
                             rElm[] -> xAF;
                          #);
                (if true
                 // (d->sematt.textDesc.equal) 
                    and (enterTypes[next] = 13 (* external *)) then
                    'BetaText2ExternalString' -> mch.callprim 
                 // ((d->sematt.descKind) = sematt.externalClassKind)
                    and (enterTypes[next] = 14 (* textDesc *) ) then
                    'ExternalString2BetaText' -> mch.callprim
                 // (d->sematt.textDesc.equal) 
                    and  (enterTypes[next] = 12 (* array *)) then
                    'text2char' -> mch.comment;
                    'BetaText2BetaCharArray' -> mch.callPrim
                 else
                    (if not leftIsRep
                        and (enterTypes[next] = 12 (* array *)) then
                        baseAdr.copy -> rA[];
                        (rElm[],rChain[],rA[]) -> getElmDesc -> desc[];
                        301->trace(#
                                  do rElm[]->xA; xN; 
                                     desc[]->xA; desc.size -> xI 
                                  #);
                        desc.size -> rA.size;
                        desc[] -> rA.bAdr.localDesc[];
                        (desc[],rElm[],rChain[],rA[],true) -> asgVal2Rep
                     else
                        (* a cast may be needed - some clean-up should
                         * be done here - we have 
                         * sig.theDesc[] -> gNL.theDesc
                         * but we do not have hNL here -
                         * it is inside checkCast - unify and
                         * clean up
                         *)
                        d[] -> theGen.mkSignature -> sourceClassName[];
                        301 -> trace(#
                                    do 'cast: ' -> xT; xN;
                                       sourceClassName[] -> xT; xN;
                                       destClassName[] -> xT
                                    #);
                        (if (destClassName[] <> none) and
                            not (sourceClassName[]->destClassName.equal) then
                            destClassNAme[] -> mch.checkCast
                        if)
                    if)
            if)if)
         #);
       destClassName: ^text;
       isBetaText2ExternalString
       ,isExternalString2BetaText
       ,isRef2RepAsg: @boolean;     

       leftIsRep: @boolean
    do 301->trace(#
                 do 'MethodCall:asgToMethod: ' -> xT;
                    sig.asText -> xT; ' ' -> put;
                    noOfArgs -> xI; ':' -> put;
                    (for i: (noOfArgs,entertypes.range) -> min repeat
                         entertypes[i] -> xI; ' ' -> put;
                    for);
                 #);
       (if sig.isMultiValExit then
           sig.XXsig.asText -> theGen.AllocAndStoreTmp -> A[];
           (* we need to get the right values instead of
            * gen.thisRegAdr and thisSuperChain
            * from the place where methodCall is instantiated
            *)
           'exit_' -> srcField[];
           (sig.thisMethodDesc[] -> theGen.fieldSignature).asText 
             -> aS.receiverType[];
           true -> aS.isField;
           sig.scanExit
           (# desc: ^ASTindex
           do (if not current.isNone then
                  (A[],&mch.adrRegOperand[]) -> mch.ldVal
              if);
              xNo + 1 
                -> xNo   
                -> (srcField.copy).putint 
                -> aS.fieldName[];
              (if (current.elmType = 12)->leftIsRep (* array *) then
                  '\nbingo'->putline;
                  current.theDesc 
                    -> desc[] 
                    -> theGen.mkArraySignature 
                    -> aS.fieldType[]
               else
                  current.theDesc 
                    -> desc[] 
                    -> theGen.mkSignature 
                    -> aS.fieldType[]
              if);
              (if current.isNone then
                  mch.ldNone
               else
                  (aS[],&mch.dataRegOperand[]) -> mch.ldVal;
              if);
              (desc[],leftIsRep) -> checkText2ExternalString;
              next + 1 -> next;                
           #)
        else
           (* we should clean-up and unify checkText2ES to
            * work in the multiExit case also
            *)
           (sig.XXsig.theDesc,rElm[],sig.XXsig.elmType=12(*array*))
             -> checkText2ES;
           next+1 -> next;              
       if)
    #)
   
---bytecodeVal_exitMultiVal_asgtoItem:doPart--
do (# gNl: ^| sematt.getNXlength;
      lMore: @boolean
   do 301->trace(#
             do 'asgToItem'->display;
             #);
      (rDesc[],rA[],0,rChain[],true) -> nScan -> more;
      L:
        (if more then
            &|sematt.getNXlength[] -> gNl[];
            (nScan.thisEv[],true,nScan.thisChain[]) -> gNl -> lMore;
            leaf:
              (if lMore then
                  gNL.elmDesc[] -> elmDesc[];
                  gNL.isRep -> isRep;
                  (* gNL.isNone -> ? *)
                  (tA[],&mch.adrRegOperand[]) -> mch.ldVal;
                  (mkA,&mch.dataRegOperand[]) -> mch.ldVal;
                  gNL -> lMore;
                  restart leaf;
              if);
            nScan -> more;
            restart L
        if) 
   #)
   
---bytecodeval_nxLeafScanner:doPart---
do (# scanLeafs:
        (# EV: ^ASTindex;
           isN: @boolean;
           chain: ^DH.superChain;
           gNXl: ^| sematt.getNXlength;     
           lMore: @boolean;
           currentDesc: ^ASTindex;
           isRep,isNone,isStruc: @boolean;
        enter(EV[],isN,chain[])
        do &|sematt.getNXlength[] -> gNXl[];
           (EV[],isN,chain[]) -> gNXl -> lMore;
           leaf:
             (if lMore then
                 gNXl.elmDesc[] -> currentDesc[];
                 gNXL.isRep -> isRep;
                 gNXL.isNone -> isNone;
                 gNXL.isStruc -> isStruc;
                 INNER scanLeafs;
                 gNXL -> lMore;                            
                 restart leaf
             if);
        #);      
      nxScan: @ | scanNXadr;
      more: @boolean;      
   do (if (elm.label = gram.objectDescriptor)
          and ((elm->sematt.descKind) <> sematt.standardKind) then
          301->trace(#do 'nxLeafScanner: ' -> xT; elm[] -> xAF #);
          isN -> nxScan.isN;
          (elm[],none(*not used*),0,chain[]) -> nxScan -> more;
          interior:
            (if more then
                (nxScan.thisEv[],isN,nxScan.thisChain[]) -> scanLeafs
                (#
                do currentDesc[] -> this(nxLeafScanner).currentDesc[];
                   isRep -> this(nxLeafScanner).isRep;
                   isNone -> this(nxLeafScanner).isNone;
                   isStruc -> this(nxLeafScanner).isStruc;
                   INNER nxLeafScanner;
                #);
                nxScan -> more;
                restart interior
            if)
       else
          301->trace(#
                    do 'nxLeafScanner:notDesc:label: ' -> xT; xN;
                       elm.label -> xI; xN;
                       elm[] -> xA; xN;
                       chain
                    #);
          (elm[],isN,chain[]) -> scanLeafs
          (#
          do currentDesc[] -> this(nxLeafScanner).currentDesc[];
             isRep -> this(nxLeafScanner).isRep;
             isNone -> this(nxLeafScanner).isNone;
             isStruc -> this(nxLeafScanner).isStruc;
             INNER nxLeafScanner;
          #)
      if)      
   #)
