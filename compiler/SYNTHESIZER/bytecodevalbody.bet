ORIGIN 'bytecodeval'
---bytecodevalbody:dopart---
do EV.son -> VN;
   (if stest then
       301->trace(# 
                 do 'mkBytecodeCall: ' -> xT; EV[] -> xA; VN[] -> xA;
                    EV.sonRef -> xA
                 #)
   if);
   thisDesc -> theThisDesc;
   (if VN.label = gram.objectDescriptor then
       (* make sure that innerdesc.getID is defined *)
       (VN,common.itemKind,2,null)->DS.push;
   if);
   (EV.sonRef,chain[],true) -> sig.setMethodDesc; 
   &ASTindex[] -> receiverDesc[]; 

   (if VN.label 
    // gram.remote then
       (# md,org: @ASTindex; mdo: ^ASTindex
       do (* VN = R.foo *) 
          VN.son -> receiver;
          receiver.brother -> method;
          sig.thisMethodDesc.origin -> org;
          (if org.label = gram.attributesForm then
              true -> isStatic;
           else
              (if false then
                  (if receiver.label = gram.thisObject then
                   else
                      (* OBS receiver is NOT used anymore *)
                      receiver -> sematt.getName -> receiver; 
                  if);
                  (* receiver = R, method = foo *)  
                  (* NOTE! below is an alternative - and correct - method
                   * for computing the desc of the receiver; we just use
                   * the origin of the method desc. In most cases this is the
                   * same as above, but for virtual methods bound to global
                   * patterns, this is not the same; the above code should
                   * be removed
                   *)
              if);
              (* EV = R.foo 
               * NOTE: EV is reference or similar, and then
               *       EV.sonRef = (remote <R> <foo> )
               *)
              301->trace(#
                        do 'mkBytecodecall:remote:'->xT; 
                           EV[] -> xA;
                           ' sonRef: '->xT; EV.sonRef -> xA
                        #);
              (thisDesc[],EV.sonRef) 
                -> GetActualDesc 
                -> (md,descKind);
              301->trace(#
                        do 'mkBytCodeCall: ' -> xT; md[] -> xA
                        #);
              (* Problem with
               *   T: (# foo: (# ... #) #)
               *   TT: T(# #);
               *   R: ^TT
               *   R.foo
               * method:  (# ... #) i.e. desc of foo
               * receiver: origin(method) = T
               * it should be TT
               *   T: (# V:< A #);
               *   TT: T(# V:: AA #);
               *   TTT: TT (# #)
               *   S1: ^TT;
               *   S2: ^TTT
               *   S1.V;  - is reciever origin of AA or the most specific
               *   S2.V   - subpattern of origin of AA? 
               *            then it is complicated
               *)
              md[] -> sematt.descOrigin -> mdo[];
              301->trace(#
                        do 'mkByteCall:remote:mdo:'->xH; mdo[] -> xA; xN;
                           md[] -> xA
                        #);
              (EV.sonRef,mdo[],md[]) -> findReceiver -> mdo[];
              mdo -> receiverDesc;
              true -> isRemote;
              (if true then
                  (* compute receiver as actual desc of R in R.foo 
                   * previously we could not do this for virtuals
                   * bound to global patterns???
                   *)
                  
              if);
              (if (md->sematt.descKind) 
               // sematt.staticProcKind then
                  true -> isRealStatic;
                  sig.markRealStatic; (* isStatic is used for
                                       * patterns at outermost levels
                                       * in lib-files
                                       *)
               // sematt.consKind then
                  301->trace(#
                            do 'mkByteCodeCall:cons: '->xT;
                               'methodDesc: ' -> xT; md[] -> xA; xN;
                               'receiverDesc: '->xT; receiverDesc[] -> xA;
                            #);
                  (* Create instance of: receiverDesc
                   * with constructor  : methodDesc
                   *)
                  true -> isCons;
                  md -> method
              if);
              301 -> trace(# 
                          do 'mkByteCodeCall:remote:2: ' -> xH;
                             'methodDesc: ' -> xT; md[] -> xA; xN;
                             'receiverDesc: '->xT; receiverDesc[] -> xA;
                          #)
          if)
       #)
       
    // gram.nameApl then
       (* VN = foo 
        * means: originN....origin2.origin1.foo
        * N >= 0
        *)
       VN -> method;
       testLibLevel: (* is this a pattern at the outermost lib level *)
         (# org: @ASTindex
         do sig.thisMethodDesc.origin -> org;
            (* dont work if virtual?*)
            (if org.label = gram.attributesForm then
                301->trace(#
                          do 'Pattern: ' -> xT;
                             VN[] -> xA;
                             ' is at the outermost lib level' -> xT
                          #);
                true -> isStatic;
             else
                (* check the case where VN is as in
                 *     VN: @<<SLOT XXX:descriptor>>
                 *   do ...; VN; ...
                 *   ---XXX:descriptor---
                 *   (# ... enter(...) do ... exit ... #)
                 * I.e. the enter/exit-part is in the form;
                 *)
                (# D: @ASTindex
                do VN.descRef -> D;
                   (if D.isSlot then
                       D.slotOrigin -> D;
                       (if D.label = gram.attributesForm then
                           true -> isStatic;
                           leave testLibLevel
                   if)if)
                #);
                (* to find originN, go origin meth.N times *)
                thisDesc -> receiverDesc;
                (for i: method.on repeat
                     receiverDesc[] -> sematt.descOrigin -> receiverDesc[]
                for);
                (if false then
                    (* ok for calling V declared as V:: T
                     * not ok for     V declared as V:< T
                     *)
                    (# md: @AStindex; mdo: ^AStindex
                    do (thisDesc[],EV.sonRef) 
                         -> GetActualDesc 
                         -> (md,descKind);
                       md[] -> sematt.descOrigin -> mdo[];
                       mdo -> receiverDesc;                  
                #)if)
            if);
         #)
    // gram.objectDescriptor then
       301->trace(#
                 do 'objectdescriptor: ' -> xT;
                    VN[] -> xA;
                 #);
       VN -> method; (* NOTE: VN IS AN OBJECTDESCRIPTOR *)
       method -> receiverDesc;
       (* Here we need to find the right origin of the method *)
       receiverDesc[] -> sematt.descOrigin -> receiverDesc[];
       (if receiverDesc.label 
        // gram.descriptorForm 
        // gram.doPart then
           receiverdesc.xorigin -> receiverdesc;
           receiverdesc.slotOrigin -> receiverdesc;
       if);
       true -> isSingular;

    // gram.unExpanded then
       301->trace(#
                 do 'MkByteCodeCall:DescriptorSlot: ' -> xT; VN[] -> xA 
                 #);
       VN[] -> sematt.enclosingDesc -> receiverDesc[];
       
       receiverDesc[] -> theGen.descLocation -> sig.location[];
       301->trace(#
                 do 'mkByteCodeCall:unExpanded:receiverLocation: "' -> xT;
                    (if sig.location[] = none then 
                        'none' -> xT
                     else 
                        sig.location[] -> xT
                    if);
                    '"' -> put
                 #);
       VN -> method;
       (VN,common.itemKind,3,VN) -> DS.push;
       true -> isSingular (* hack *)
    // gram.computedRemote then
       (# MN,isVirt: @integer; xchain: ^DH.superChain;
          remEv,N,ref,refDesc: ^ASTindex;
          (* (E).method 
           * DOES NOT WORK
           *)
       do VN.son -> receiver;
          receiver.brother -> method;
          L: receiver->scanList(#do currentNode->receiver; leave L #);
          301->trace(#
                    do 'mkByteCodeCallX: ' -> xT;
                       VN[] -> xA
                    #);
          (VN[],DH[],chain[]) 
            -> sematt.chkComputedEval 
            -> (remEv[],N[],ref[],receiverDesc[],xchain[]);
          301->trace(#
                    do 'mkByteCodeCallY: ' -> xT;
                       receiverDesc[] -> xA
                    #);
       #)
    else
       '\n**** insert is NOT remote or nameApl'->putline
   if);
   (if isCons then
       (* 1->trace(#
        do 'cons: ' -> xT; receiverdesc[]->xA #);*)
       (receiverDesc[],common.itemKind) -> theGen.newInstance
       (# 
       do (method[],false,chain[]) -> consSig.addConstructorDesc;
          (*1->trace(#
           do 'X:'->xT; conssig.astext->xT; xN;
           hasOrigin -> xB;
           100->switchon;
           method[]->xA;xN;
           VN[] -> xA;
           100->switchoff
           #);*)
          false -> sig.isStatic;
          'olsen' -> sig.addMethod;
          method[] -> sig.addEnter;
          sig.setVoidXSig; 
          (*1->trace(#do sig.astext -> xT #);*)
          ((receiverDesc[],true) -> descName,receiverDesc[]) 
            -> sig.addReceiver;
          (if hasOrigin then '\ngenorg'->putline;
              (baseAdr.copy,theThisDesc[],VN[],EHchain[])
                -> genOrgAdrToOrgReg
                -> OA[];
          if);
          INNER MkByteCodeCall
       #);
       (mch.thisRegOp,false,EV[],chain[]) -> mkComputedRefEvVal -> W[]
    else
       (if not isStatic then
           ('G',receiverDesc[]) -> mkEntryPoint -> (class[],local);
           301->trace(#
                     do 'mkByteCodeCall:receiver: ' -> xT; class[] -> xT; xN;
                        receiverDesc[] -> xA
                     #);
           (class[],receiverDesc[]) -> sig.addReceiver;
       if);
       L:
         (if not isSingular then
             method.dclRef -> finalMethod;
             finalMethod.sort -> finalMethod;
             301 -> trace(#
                         do 'mkBytecodeCall:method.dclRef: ' -> xT;
                            finalMethod[] -> xA
                         #);

             (if finalMethod.label = gram.finalDecl then
                 true -> isFinal;
                 method.dclRef -> finalMethod;
                 (if not isRemote then
                     (# md: @AStindex; mdo: ^AStindex
                     do (thisDesc[],EV.sonRef) 
                          -> GetActualDesc 
                          -> (md,descKind);
                        md[] -> sematt.descOrigin -> mdo[];
                        mdo -> receiverDesc;                  
                        ((receiverDesc[],true) -> descName,receiverDesc[]) 
                          -> sig.addReceiver
             #)if)if);         
             method.descRef -> method;
             301 -> trace(#
                         do 'mkBytecodeCall:method.descref: ' -> xT;
                            method[] -> xA
                         #);
             LL: 
               (if method.label 
                // gram.objectDescriptor 
                // gram.unExpanded then
                   method -> receiverDesc
                // gram.finalDecl then (** ??? **)'FINAL'->putline;
                // gram.bindingDecl then

                   method.son -> method;
                   L:
                     method -> scanList
                   (# do currentNode -> method; leave L #);
                   method.virtDcl -> method;
                   method.sort -> method;
                   restart LL
                   
                // gram.virtualDecl then
                   method.son -> method;
                   method.brother -> method; (* assume desc here *)
                   false -> isStatic; (* V:< T never be in an attributes form *)
                   true -> isVirtual;
                   (* perhaps we should explicitly set the receiver? *)
                   (if (EV.sonRef).label = gram.nameApl then
                       (* are we sure the other cases are covered? *)
                       (*1->trace(#
                        do 'mkByteCodeCall:virtual: ' -> xT; EV[] -> xA; 
                        ' on:'->xT; (EV.sonRef).on -> xI; xN;
                        thisDesc[] -> xA
                        #);*)
                       thisDesc -> receiverDesc;
                       (for i: (EV.sonRef).on repeat 
                            receiverDesc[] -> sematt.DescOrigin -> receiverDesc[]
                       for);
                       (EV.sonRef,receiverDesc[],none) 
                         -> findReceiver -> receiverDesc[];
                       ((receiverDesc[],true)->descName,receiverDesc[]) 
                         -> sig.addReceiver;
                   if)
                // gram.variablePattern then
                   (* R: (# F: ##T
                    *    do ... F
                    * receiverDesc: R
                    * methodName  : F
                    * methodDesc  : T
                    *)
                   301->trace(#
                             do 'mkByteCodeCall:varPtn: ' -> xT;
                                EV[] -> xA;
                             #);
                   true -> isVarPtn;
                   false -> isStatic;
                   method[] -> sematt.EncDescOfNode -> receiverDesc[];
                   ((receiverDesc[],true)->descName,receiverDesc[]) 
                     -> sig.addReceiver;
                   sig.thisMethodDesc -> method;
                   301->trace(#
                             do 'mkByteCodeCall:varPtn:X: ' -> xH;
                                'receiver: '->xT; receiverDesc[] -> xA; xN;
                                'methodName: ' -> xT; VN.gettext -> xT; xN;
                                'methodDesc: ' -> xT; method[]->xA
                             #);
               if);
             301 -> trace(# 
                         do 'call2:'->xH; 
                            ' receiver: '->xT; receiverDesc[] -> xA; xN; 
                            'method: '->xT; method[] -> xA; 
                         #)   
         if);

       (if isStatic then
           ((method[],true) -> descName,method[]) -> sig.addReceiver;
           sig.markStatic
       if);
       (* set the name of the method *)
       (if isVarPtn then
           VN.gettext -> sig.addMethod;
        else 
           (if (sig.thisMethodDesc -> sematt.descKind) 
            // sematt.procKind 
            // sematt.staticProcKind then
               method[]  -> theGen.getExternalClassName -> sig.addMethod
            else
               (*1->trace(#do 'addMethod: ' -> xT; method[] -> xA; xN;
                'VN: ' -> xT; VN[] -> xA;
                'VN.text: ' -> xT; VN[] -> getDclName -> xT
                #);*)
               (if isFinal and isRemote then
                   VN[] -> getDclName -> sig.addMethod 
                else
                   (method[],false) -> descName -> sig.addMethod
               if)
           if)
       if);
       (* the following should be generalised? *)
       (*1->trace(#
        do 'isSlot: ' -> xT; method.isslot -> xB; xN;
        method[] -> xA; xN;
        sig.thismethoddesc[] -> xA
        #);*)

       (if method.isSlot then
           (if sig.thisMethodDesc.isSlot then
               (* probably only the second check is needed *)
               sig.noEnter
            else
               sig.addEnter
           if)
        else
           method[] -> sig.addEnter
       if);
       
       (if method.isSlot then
           sig.setVoidXSig
        else
           (# p,mp,att,n,doP,exitP,EV: ^ASTindex; S: ^text
           do sig.thisMethodDesc[] (* descriptor for method *)
                -> sematt.descSonsRef
                -> (p[],mp[],att[],n[],doP[],exitP[]);
              
              (if exitP[] <> none then
                  exitP[] -> sig.addExit
               else
                  sig.setVoidXSig
              if)
       #)if);
       sig.asText -> class[];
       301 ->trace(#do 'class: ' -> xT;  class[] -> xT #);
       (if not hasArguments 
           and (((sig.NNsig.top > 0) and not isStatic)
           or ((sig.NNsig.top > 1) and isStatic)) then
           (* is receiverDesc the right originDesc here?
            * is it ok with topDesc = none
            *)
           (# xD: @ASTindex; ba: ^mch.address;
              oldReturnSaved,oldInNDX: @boolean;
              mDesc: ^ASTindex;
           do thisDesc->xD;
              theThisDesc -> thisDesc;
              baseAdr.copy -> ba[];
              inEnterDoExitMethod -> oldInNDX;
              theGen.returnSaved -> oldReturnSaved;            
              (* instead of this clumsy save of global state,
               * we should make a new instance of theGen
               *)
              301 ->trace(#
                         do 'mkByteCodeCall:inlineMethod1:'->xT;
                            method[] -> xA; 
                            ' VN: ' -> xT; VN[] -> xA;
                            ' on: ' -> xT; VN.on -> xI;
                            xN;
                            'thisDesc: ' -> xT;
                            thisDesc[] -> xA; xN;
                            'theThisDesc: '->xT; 
                            theThisDesc[] -> xA; xN;
                            'baseAdr.bAdr.localDesc: ' -> xT;
                            baseAdr.bAdr.localDesc[] -> xA; xN;
                            baseadr.display->xT; 
                         #);
              (if isVirtual then
                  301->trace(#do 'Virtual:genPtnMethod: '->xT; method[]->xA #);
                  method[] -> mDesc[];
               else
                  sig.thisMethodDesc[] -> mDesc[]
              if);
              ('inline$',mDesc[]
              ,false,false,receiverDesc[],none(*?*)
              ,true,false,true)
                -> theGen.genPtnMethod
              (# 
              do xD -> thisDesc;
                 (baseAdr.copy,theThisDesc[],VN[],EHchain[])
                   -> genOrgAdrToOrgReg
                   -> OA[];
                 xD -> thisDesc;
                 ba[] -> baseAdr[];
              #);
              xD -> thisDesc;
              ba[] -> baseAdr[];
              oldInNDX -> inEnterDoExitMethod;
              301 ->trace(#
                         do 'mkByteCodeCall:inlineMethod2:'->xT; 
                            method[]->xA; xN;
                            baseAdr.bAdr.localDesc[] -> xA; xN;
                            baseadr.display->xT; xN;
                            thisDesc[] -> xA
                         #);
              (if thisDesc.label = gram.doPart then
                  (* we should probably always do this *)
                  theRealDesc[] -> theGen.InitGen
                  (#
                  do &ASTindex[] -> doP[]; 
                     thisDesc.son -> doP;                 
                     doP[] -> setDoP
                  #);
                  (theRealDesc[],true) -> theGen.initPtnGen;
                  xD -> thisDesc; (* is overwritten by initPtnGen *)
                  301->trace(#
                            do 'mkByteCodeCall:inlineMethod2:'->xT; 
                               'TheRealDesc: ' -> xT; theRealDesc[] -> xA; xN;
                               'FormDesc: ' -> xT; FormDesc[] -> xA; xN;
                               'ThisDesc: ' -> xT; thisDesc[] -> xA; xN;
                            #);
                  
                  
               else 
                  (thisDesc[],false) -> theGen.initPtnGen
              if);
              oldReturnSaved -> theGen.returnSaved; (* is set to false
                                                     * in initPtnGen
                                                     *)
           #)
        else
           (if isFinal and isRemote then
               (baseAdr.copy,VN.sonRef,false,EHchain[])->genAdr->OA[];
               (OA[],mch.adrTop[]) -> mch.ldVal
            else
               (baseAdr.copy,theThisDesc[],VN[],EHchain[])
                 -> genOrgAdrToOrgReg
                 -> OA[];
           if);
           INNER;         
           (class[]->mch.newTextOp,'M',local,isStatic or isRealStatic)
             -> mch.gJsr;  
       if);
       (if not hasExit and (sig.XXsig.elmType <> 10 (*void*)) then
           (if sig.XXsig.elmType = 6 (* real/double *) then
               true -> mch.popStack
            else
               mch.popStack
       if)if);
       301->trace(#
                 do 'mkByteCode:end: '->xT; sig.asText -> xT; sig.thischain
                 #);
       (sig[],sig.thisChain[]) -> methodCall -> W[]
   if);
---bytecodeval_methodArgs_asgToMethod:doPart---
do 301->trace(#
             do 'asgToMethod:'->display; xN;
                'next: ' -> xT; next -> xI; 
                ' noOfArgs:' -> xT; noOfArgs->xI; 
                (for i: noofArgs repeat
                     (if i <= enterTypes.range then
                         enterTypes[i]->xI
                      else
                         '# ' -> xT
                     if)
                for);
                xN;
                'rElm: ' -> xT; rElm[] -> xA;
                rChain
             #);
   (if llEV[] <> none then
       (*1->trace(#
        do 'eval:assignToList:'->xT; llEV.display; xN;
        lEv[] -> xA
        #);*)
       (baseAdr[],llEv[],lEv[],true,lChain[])
         -> assignValToEval
         -> V[]
    else          
       (baseAdr[],lEv[],true,lChain[])
         -> ExpEval
         -> V[];
   if);
   301->trace(#
             do 'asgToMethod2: '->display; V.display;
                rChain
             #);
   
   (enterTypes,noOfArgs,next,rElm[],rChain[]) 
     -> V.asgToMethod
     -> next;

---bytecodeval_enterArgs_asgToMethod:doPart---
do 301->trace(#
             do 'asgToMethod:'->display;
                'noOfArgs: ' -> xT; noOfArgs -> xI;
                ' enterTypes.range: ' -> xT;
                enterTypes.range -> xI;
                ' next:'->xT; next -> xI;
                (if (next + noOfArgs) > enterTypes.range then
                    xN;
                    '(next + noOfArgs) > enterTypes.range '
                      -> xT;
                if); 
                xN;
                ' elms:'->xT;
                (for i: noOfArgs repeat
                     enterTypes[i] -> xI
                for)
             #);
   (if (next + noOfArgs - 1) > enterTypes.range then
       (* HACK: we assume that method is static
        * and that first argument - enlosing object -
        * has been pushed by genOrgAdr.
        * Ex:
        * ---lib:attributes---
        * descNo: (# N: @integer enter N do ... #);
        * descId: (# enter ((a,b),descNo) do ... #)
        *)
       noOfArgs - 1 -> max
    else
       noOfArgs -> max
   if);
   (for i: max repeat
        (if enterTypes[next] 
         // 11 // 12 // 13 // 14 then
            'SomeClass' -> pushNext;
         // 6 (* real/double *) // 7 (* real32 *) then
            'D' -> pushNext 
         // 8 (* long=int64*) then
            'J' -> pushNext
         else
            pushNext 
        if);
        next + 1 -> next
   for);
   (* OBS. check that moved 'inner' in mkByteCodeCall is OK
    * We need the descriptor - it may be singular -
    * it must be called as a a method; i.e. 
    * treated like an inner pattern with method-version
    * and new-version
    *)
   next + max -> next 
   
---bytecodeval_methodCall_asgToMethod:doPart---
do  (# nxLeafScanner:
         (# elm: ^ASTindex;
            isN: @boolean;
            rChain: ^DH.superchain;
            currentDesc: ^ASTindex;
            isRep: @boolean;
            
            nxScan: @| scanNXadr;
            gNXl: ^| sematt.getNXlength;     
            more,lMore: @boolean
         enter(elm[],isN,rChain[])
         do (if (elm.label = gram.objectDescriptor)
                and ((elm->sematt.descKind) <> sematt.standardKind) then
                301->trace(#do 'nxLeafScanner: ' -> xT;
                           elm[] -> xAF
                        #);
                isN -> nxScan.isN;
                (elm[],none(*not used*),0,rChain[]) -> nxScan -> more;
                interior:
                  (if more then
                      &|sematt.getNXlength[] -> gNXl[];
                      (nxScan.thisEv[],true,nxScan.thisChain[]) 
                        -> gNXl -> lMore;
                      leaf:
                        (if lMore then
                            gNXl.elmDesc[] -> currentDesc[];
                            gNXL.isRep -> isRep;
                            INNER nxLeafScanner;
                            gNXL -> lMore;
                            restart leaf
                        if);
                      nxScan -> more;
                      restart interior
                  if)
             else
                301->trace(#
                          do 'nxLeafScanner:notDesc:label: ' -> xT; xN;
                             elm.label -> xI; xN;
                             elm[] -> xA; xN;
                             rChain
                          #);
                (* Get the descriptor of elm;- unify with code above *)
                &|sematt.getNXlength[] -> gNXl[];
                (elm[],true,rChain[]) -> gNXl -> lMore;
                leaf:
                  (if lMore then
                      gNXl.elmDesc[] -> currentDesc[];
                      gNXL.isRep -> isRep;
                      INNER nxLeafScanner;
                      gNXL -> lMore;
                      restart leaf
                  if);
            if);
         #);
       checkCastx:
         (# lDesc,rDesc: ^ASTindex;
            lIsRep,rIsRep: @boolean;
            pd: @integer;
            found: @boolean;
            
         enter(lDesc[],lIsRep,rDesc[],rIsRep)
         do 301 -> trace(#
                     do 'checkCast:lIsRep: '->xT; lIsRep->xB; xN;
                         lDesc[] -> xAF; xN;
                         rDesc[] -> xAF; 
                    #);
            (if true 
             // (lDesc->sematt.textDesc.equal)
                and ((rDesc[] -> theGen.isExternalString)
                      or (enterTypes[next] = 13 (* external *)))
                then
                'BetaText2ExternalString' -> mch.callprim 
                
             // (lDesc[] -> theGen.isExternalString) 
                and ((rDesc->sematt.textDesc.equal) 
                     or (enterTypes[next] = 14 (* textDesc *)))
                then
                'ExternalString2BetaText' -> mch.callprim
                
             // (lDesc->sematt.textDesc.equal)
                and rIsRep (*and (enterTypes[next] = 12 (* array )*) then
                (* using enterTypes is perhaps not so nice *)
                (* check this?*)
                'BetaText2BetaCharArray' -> mch.callPrim
             else
                (* needs clean-up *)
                (if not lIsRep
                    and (enterTypes[next] = 12 (* array *)) then
                    baseAdr.copy -> rA[];
                    (rElm[],rChain[],rA[]) -> getElmDesc -> desc[];
                    301->trace(#
                              do rElm[]->xA; xN; 
                                 desc[]->xA; desc.size -> xI 
                              #);
                    desc.size -> rA.size;
                    desc[] -> rA.bAdr.localDesc[];
                    (desc[],rElm[],rChain[],rA[],true) -> asgVal2Rep
                 else
                    (if (lDesc->sematt.descKind) <> sematt.standardKind then
                        (lDesc[],rDesc[]) -> sematt.ChkQua -> (pd,found);
                     else
                        true -> found
                    if);
                    (if not found then
                        301->trace(#
                                do 'cast: ' -> xT;
                                   lDesc[] -> xAF; xN;
                                   rDesc[] -> xAF;
                                #);
                        rDesc[]-> theGen.mkSignature -> mch.checkCast
            if)if)if)
         #);

       checkText2ES:
         (# lDesc,rDesc: ^ASTindex;
            leftIsRep: @boolean;

         enter(lDesc[],rDesc[],leftIsRep)            
         do (if (rDesc[]<>none) then
                301->trace(#
                          do 'ct2e:'->xT;
                             lDesc[]->xAF; xN;
                             rDesc[] -> xAF;
                          #);
                (rDesc[],true,rChain[]) -> nxLeafScanner (* scan enter *)
                (#
                do (lDesc[],leftIsRep,currentDesc[],isRep) -> checkCastX
                #)
            if)
         #);
       checkText2ExternalString:
         (# d: ^ASTindex;
            leftIsRep: @boolean;
            sourceClassName: ^text
         enter(d[],leftIsRep)
         do (if (d[]<>none) then
                301->trace(#
                          do 'ct2ex:'->xT;
                             d[]->xAF; xN;
                             rElm[] -> xAF;
                          #);
                (if true
                 // (d->sematt.textDesc.equal) 
                    and (enterTypes[next] = 13 (* external *)) then
                    'BetaText2ExternalString' -> mch.callprim 
                 // ((d->sematt.descKind) = sematt.externalClassKind)
                    and (enterTypes[next] = 14 (* textDesc *) ) then
                    'ExternalString2BetaText' -> mch.callprim
                 // (d->sematt.textDesc.equal) 
                    and  (enterTypes[next] = 12 (* array *)) then
                    'text2char' -> mch.comment;
                    'BetaText2BetaCharArray' -> mch.callPrim
                 else
                    (if not leftIsRep
                        and (enterTypes[next] = 12 (* array *)) then
                        baseAdr.copy -> rA[];
                        (rElm[],rChain[],rA[]) -> getElmDesc -> desc[];
                        301->trace(#
                                  do rElm[]->xA; xN; 
                                     desc[]->xA; desc.size -> xI 
                                  #);
                        desc.size -> rA.size;
                        desc[] -> rA.bAdr.localDesc[];
                        (desc[],rElm[],rChain[],rA[],true) -> asgVal2Rep
                     else
                        (* a cast may be needed - some clean-up should
                         * be done here - we have 
                         * sig.theDesc[] -> gNL.theDesc
                         * but we do not have hNL here -
                         * it is inside checkCast - unify and
                         * clean up
                         *)
                        d[] -> theGen.mkSignature -> sourceClassName[];
                        301 -> trace(#
                                    do 'cast: ' -> xT; xN;
                                       sourceClassName[] -> xT; xN;
                                       destClassName[] -> xT
                                    #);
                        (if (destClassName[] <> none) and
                            not (sourceClassName[]->destClassName.equal) then
                            destClassNAme[] -> mch.checkCast
                        if)
                    if)
            if)if)
         #);
       destClassName: ^text;
       isBetaText2ExternalString
       ,isExternalString2BetaText
       ,isRef2RepAsg: @boolean;     

       leftIsRep: @boolean
    do 301->trace(#
                 do 'MethodCall:asgToMethod: ' -> xT;
                    sig.asText -> xT; ' ' -> put;
                    noOfArgs -> xI; ':' -> put;
                    (for i: (noOfArgs,entertypes.range) -> min repeat
                         entertypes[i] -> xI; ' ' -> put;
                    for);
                 #);
       (if sig.isMultiValExit then
           sig.XXsig.asText -> theGen.AllocAndStoreTmp -> A[];
           (* we need to get the right values instead of
            * gen.thisRegAdr and thisSuperChain
            * from the place where methodCall is instantiated
            *)
           'exit_' -> srcField[];
           (sig.thisMethodDesc[] -> theGen.fieldSignature).asText 
             -> aS.receiverType[];
           true -> aS.isField;
           sig.scanExit
           (# desc: ^ASTindex
           do (A[],&mch.adrRegOperand[]) -> mch.ldVal;
              xNo + 1 
                -> xNo   
                -> (srcField.copy).putint 
                -> aS.fieldName[];
              (if (current.elmType = 12)->leftIsRep (* array *) then
                  '\nbingo'->putline;
                  current.theDesc 
                    -> desc[] 
                    -> theGen.mkArraySignature 
                    -> aS.fieldType[]
               else
                  current.theDesc 
                    -> desc[] 
                    -> theGen.mkSignature 
                    -> aS.fieldType[]
              if);
              (aS[],&mch.dataRegOperand[]) -> mch.ldVal;
              (desc[],leftIsRep) -> checkText2ExternalString;
              next + 1 -> next;                
           #)
        else
           (* we should clean-up and unify checkText2ES to
            * work in the multiExit case also
            *)
           (if true then
               (sig.XXsig.theDesc,rElm[],sig.XXsig.elmType=12(*array*))
                 -> checkText2ES
            else               
               (sig.XXsig.theDesc,none,rElm[],enterTypes[next],rChain[])
                 -> checkCast
                 -> (destClassName[]
               ,isBetaText2ExternalString
               ,isExternalString2BetaText
               ,isRef2RepAsg);
               (*1->trace(#
                do destClassName[] -> xT; 
                isBetaText2ExternalString->xB;
                isExternalString2BetaText -> xB;
                isRef2RepAsg -> xB
                #);*)
               (sig.XXsig.theDesc,sig.XXsig.elmType=12(*array*))
                 -> checkText2ExternalString;
           if);
           next+1 -> next;              
       if)
    #)
   
---bytecodeVal_checkCast:doPart-- (* not in use *)
do (# nScan: @ | scanNadr;
      gNl: ^| sematt.getNXlength;
      chain1: ^DH.superchain;
      elmDesc: @ASTindex
   do (if rElm.label = gram.objectDescriptor then
          (* we should generalize this one, to scan
           * the enter-list
           *)
          (relm[],A[](*not used*),0,rChain[],true) 
            -> nScan;
          (* we need the strong qualification here
           * i.e. the known type.
           *)
          (nScan.thisChain[],nScan.thisEv)
            -> DH.theDesc
            -> (elmDesc,chain1[]);
          &|sematt.getNXlength[] -> gNl[];
          
          (nScan.thisEv[],true,nScan.thisChain[])
            -> gNl;
          
          (if true 
              (* Avoid a cast if conversion between
               * externalString and text;
               *)
           // (lDesc->sematt.textDesc.equal)
              and (enterType = 13) (* externalString Class*)
              then
              true -> isBetaText2ExternalString
           // (lDesc[] -> theGen.isExternalString) 
              and (enterType = 14) (* textDesc *)
              then
              true -> isExternalString2BetaText
           else
              (if isRef2RepAsg then
                  gNL.elmDesc[] 
                    -> theGen.mkArraySignature 
                    -> destClassName[]
               else
                  gNL.elmDesc[] -> theGen.mkSignature -> destClassName[];
              if)
          if)
       else
          (*'\nref2method: not descriptor'->putline*)
      if);
   #)
