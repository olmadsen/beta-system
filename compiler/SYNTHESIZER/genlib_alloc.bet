ORIGIN 'genlib';
LIB_ITEM 'betacodegen';
INCLUDE 'evlib';
INCLUDE 'nxoffsetsval';
INCLUDE 'auxlib';
INCLUDE '../CHECKER/nxoffsets';
INCLUDE '../CHECKER/setnxoffsets';
INCLUDE 'genlib_bytecode';
---genlib_genPrefix:dopart---
do (# IsSpecialVirtual: (* ... 
                         *       V::< (# ... #);  *)
        (#
           special,rem: @boolean;
           preName,preX,preSort,realPreN: @ASTindex
        do 
           preDen->sematt.getName->preName;
           preName.dclRef->preSort;
           preSort.sort->preSort;
           (if preSort.label
            // gram.virtualDecl // gram.bindingDecl then
               (* thisDesc is V :: < (# ... #)                   
                * the super may then be  V :< (# ... #)
                *        no problems on generating origin
                * or                  V :< A
                *        special code for generating origin
                *        if A is not at the same level as V
                * or                   V:< R.A
                *        same as above
                *)
               preSort.son->realPre;
               realPre.brother->realPre;
               (if realPre.label
                // gram.objectDescriptor then
                   
                // gram.nameApl then (* V:< A *)
                   realPre->sematt.getName->realPreN;
                   (if (realPreN.on > 0) then true->special if)
                // gram.remote then
                   true->special
                else
                   'Unknown implicit super-pattern' 
                     -> thisTranslate.SystemException
               if);
               (if special then
                   thisDesc[]->semAtt.DescOrigin->thisDescOrigin[];
                   thisDescOrigin->preDescOrg;
                   ThisSuperChain->chain[];
                   chain[]->DH.ENC->chain[];
                   (for i: preName.pn repeat
                        preDescOrg.son->preX;
                        preX.son->sematt.Descrip-> preDescOrg;
                        chain[]->DH.PRE->chain[]
                   for);
                   
               if)
           if)
        exit special
        #);
      dest: ^mch.registerOperand;
   do 313->trace(#
                do 'GenPrefix:'->xT; pref[]->xA
                #);
      (if (thisDesc[]->Sematt.hasDo) then thisDesc[]->GS.thisPT.mainAdr if);
      L:
        (if hasPref then
            SaveReturn;
            pref.son->preDen->SemAtt.descrip-> prefDesc;
            (if (prefDesc->sematt.cProcdesc.equal) then
                false->hasPref; restart L (* dirty *)
            if);
            prefDesc[]->emitSuperGCtab->superOrgOff;
            (if superOrgOff <> ThisDescOrgOff then 
                (# prebase: ^mch.address;
                   originDesc: ^ASTindex;
                   PK: @integer
                do (* origin for prefix must be added one *)
                   Gen.ThisRegAdr->preBase[];
                   
                   (preBase[],preBase.copy,1,false) -> GoOrigin -> preBase[];
                   (if IsSpecialVirtual then
                       preDescOrg[]->preBase.bAdr.localDesc[];
                       (* originDesc is NONE here? *)
                       (preBase[],originDesc[],realPre[],chain[])
                         -> genOrgAdr
                         -> preBase[];
                    else
                       thisDesc[]
                         -> sematt.descOrigin
                         -> originDesc[]
                         -> preBase.bAdr.LocalDesc[];
                       thisSuperChain->chain[];
                       chain[]->DH.ENC->chain[];
                       (preBase[],originDesc[],preDen[],chain[])
                         -> genOrgAdr
                         -> preBase[];
                   if);
                   301->trace(#
                           do 'super: ' -> xT;
                              prefDesc -> sematt.descKind -> xI; xN;
                              prefDesc[] -> xA; xN;
                              thisDesc[] -> xA; xN;
                              'origin: ' ->xT;
                              originDesc[] -> xA; xN;
                             #);
                   (* COM GC FIX *)
                   (if ((prefDesc -> sematt.descKind->PK) = sematt.comKind)
                        or (PK = sematt.holderkind)
                        or
                          ((originDesc[] <> none)
                           and
                          ((originDesc->sematt.descKind) = sematt.comkind))
                       then
                       (* COM- and holder-Objects are allocated directly 
                        * in AOA - origin(s) may be in IOA 
                        *)
                       (prebase[],false,none,none)
                         -> (prefDesc.originOff->Gen.ThisRegAdr).asgRefAdr 
                         -> dest[] 
                         -> mch.chkHeap
                    else
                       preBase[] 
                         -> (prefDesc.originOff->Gen.ThisRegAdr).storeOrigin
                   if);
                   prebase.freeAdr;

                   thisDescOrgOff+orgTag->GS.thisPT.dyn.add
                #)
            if);
            INNER  GenPrefix
         else
            thisDescOrgOff+orgTag->GS.thisPT.dyn.add;
            sematt.superObject.descId->(prefFormId[],prefDescNo);
            sematt.superObject->thisPrefDesc (* used to generate prototypes *)
        if);
      (if common.switch[64] and ((thisDesc.returnOff->off) <> 0) then
          off->GS.thisPT.dyn.add
      if)
   #)
   
---genlib_PrefixAlloc:doPart---
do prefDesc.descId->(prefFormId[],prefDescNo);
   prefDesc->thisPrefDesc;
   (if prefDesc[] -> sematt.hasAcode then          
       (if common.switch[68] then
           (mch.thisRegOp[],2->mch.getPrimReg)->mch.cpReg; (* sun4s only*)
           (- 1->mch.newCstOp,1->mch.getPrimReg)->mch.ldCst;
           (* origin *)
           5 -> common.count; ('V',prefDesc[],3)->callEntry;
        else
           (mch.thisRegOp[],mch.callRegOp[])->mch.cpReg;
           ('G',prefDesc[],3)->callEntry 
       if)
   if);
   (if (prefDesc[]->Sematt.hasDo) then prefDesc[]->GS.thisPT.mainAdr if);
   prefDesc.son->&MainAdr

---genlib_alloc:doPart---
do (# GetAndSaveDescriptor: 
        (# es,desc,N: @ ASTindex; first: @ boolean;
        enter(es,first,N)
        do (if es.label = gram.objectDescriptor  then 
               es -> desc;
               (if not switch182 then
                   (* bytecode case is handled in genfields *)
                   (if first then (desc,0,1,N) -> DS.push if);
                   (* kind,cons are not correct *)
               if)
            else 
               (* why do we not used GetActulaDesc here?
                * see genfields
                *)
               es -> SemAtt.Descrip -> desc
           if)
        exit desc
        #);
      doStoreOrigin:
        (# encDesc: ^ASTindex; A,OA: ^mch.address
        enter(encDesc[],A[],OA[])
        do (if (encDesc->sematt.descKind) = sematt.comKind then
               (A[],false,none,none)
                 -> OA.asgRefAdr
                 -> mch.chkHeap
            else
               A[] -> OA.storeOrigin
           if);                                       
        #);
      SimpleAlloc:
        (# dataSpec,N,desc,es,son,VN: @ASTindex;
           first: @boolean;
           kind,descNo,PL,baseOff,Noff,max: @integer;
           formId: ^text;
           A,OA,A1: ^mch.address;
           newInStat:
             (# kind: @integer;
                A: ^mch.address;
                L: ^Text;
                A1: @mch.RegAdr;
                dest: ^mch.registerOperand;
                desc: ^ASTindex
             enter (kind,desc[])
             do (desc[],kind)->doLoadProtoAndAlloc;
                &synth_main.gen.thisRegAdr->A[];
                N.off->A.addOff->A[];
                A1.mkCall;
                (A1[],false,none,none)->A.asgRefAdr->dest[]->mch.chkHeap
             #);
           SlotOrComDesc:
             (# A1,OA: ^mch.address; refTag: @integer; Ax: @mch.RegAdr;
                EH: @EvalHandler
             enter refTag
             do (if switch182 then
                    theGen.pushThis; (* for storing ref later *)
                    (desc[],kind) -> theGen.newInstance
                    (#
                    do(if hasOrigin then
                          '!SlotOrComDesc:genOrigin1:'->mch.comment;
                          true -> inEnterDoExitMethod;
                          (Gen.ThisRegAdr,thisDesc[],es[],thisSuperChain)
                            -> genOrgAdr
                            -> A1[];
                          'origin' -> A1.fieldName[];
                          false -> inEnterDoExitMethod;
                          313->trace(#
                                    do 'genOrigin:'->xT; A1.display->xT
                                    #);
                          '!!SlotOrComDesc:genOrigin2:'->mch.comment;
                          (*(if es.label = gram.objectDescriptor then*)
                          (* messy: we should clean-up in
                           * genOrgAdr/genAdr such that
                           * it either loads or a load is 
                           * needed here
                           *)
                          (* we know es = gram.unExpanded; *)
                          (if es.label = gram.unExpanded then
                              true -> A1.isRef;
                              'origin' 
                                -> A1.fieldName[];
                              (A1[],none) -> mch.ldVal;
                          if);
                              (* if);*)
                          (*A1.toOriginReg;*)
                          '!!SlotOrComDesc:genOrigin3:'->mch.comment;
                      if)
                    #);
                    true -> Ax.isField;
                    thisDesc[]
                      -> theGen.mkSignature
                      -> Ax.receiverType[];
                    (* fieldType?*)
                    N.getText -> Ax.fieldName[];
                    (none,false,'' ,desc[] -> theGen.mkSignature)
                      -> Ax.asgRefReg                    
                 else
                    SaveReturn;
                    (Gen.ThisRegAdr,thisDesc[],es[],thisSuperChain)
                      -> genOrgAdr
                      -> A1[];
                    A1.toOriginReg;
                    (Kind,desc[])->newInStat;
                    N.off+refTag->GS.thisPT.Dyn.add
                if)
             #);
           isDirect: booleanValue
             (# D: ^ASTindex; Dkind: @integer
             enter(D[],Dkind)
             do (* D is descriptor of part-object in thisDesc*)
                (* don't confuse desc.descAcces with N.access *)
                (if (D[]->sematt.descAccess) = common.direct then
                        (* direct objects can potentially be 
                         * allocated inline *)
                        (if thisDesc -> sematt.descKind 
                         // sematt.comKind 
                         // sematt.holderKind then
                            (* thisDesc - enclosing object -
                             * is COM or holder
                             *)
                            (if Dkind = sematt.holderKind then
                                (* the part object is a holder
                                 * holder-objects are inline *)
                                true -> value
                             else
                                (* part object is not holder;
                                 * such objects are off line 
                                 * in COM- and holder objects
                                 *)
                                false -> value                            
                            if)
                         else
                            (* D is a part-object in a non 
                             * COM- or Holder-object *)
                            (if Dkind 
                             // sematt.comKind
                             // sematt.holderKind then
                                (* Holder-objects are offline in non
                                 * COM- or holder-objects
                                 *)
                                common.holderKind -> kind; (* NOTE: kind
                                                            * is global in
                                                            * SimpleAlloc
                                                            *)
                                (* NOTE! COM-objects are also offline;
                                 * ComKind is handled specially below
                                 *)
                             else
                                (* other objects are inline *)
                                true -> value
                            if)
                        if)
                    (*else return false *)
                if)
             #);
           descKind,K: @integer;
           xD: ^ASTindex
        enter (N,dataSpec,first) (* no allocation for dynIns *)
        do dataSpec.son -> es;
           (if es.label = gram.component then
               (* In genFields, the component is imported;
                * we may consider storing a ref to the component in the field
                * - if not in outer component, 
                *   we should generate a clone of the component
                *)
               leave SimpleAlloc;
           if);
           (es,first,N)-> GetAndSaveDescriptor -> desc;
           (if desc.label = gram.objectDescriptor then 
               desc->sematt.descKind->descKind
            else
               (* a virtual/patternVar is always generalKind! *)
               sematt.generalKind->descKind
           if);
           (if (dataSpec.label->kind)
            // gram.dynamicItem // gram.dynamicComponent 
            // gram.variablePattern
               then
               (if descKind
                // sematt.generalKind // sematt.standardKind
                // sematt.externalKind // sematt.callBackKind 
                // sematt.comKind // sematt.holderKind then
                   (* For references R: ^external; F: ##external,
                    * descKind is standardKind
                    *)
                   N.off->GS.thisPT.Dyn.add
               if);
               (if switch182 then
                   (if kind = gram.variablePattern then
                       N[] -> saveLocalDesc
               if)if)
            // gram.staticItem // gram.staticComponent then
               (if kind = gram.staticItem then common.itemKind->kind
                else
                   common.compKind->kind
               if);
               (if desc.label
                // gram.objectDescriptor then
                   (if desc->sematt.DescKind -> K
                    // sematt.standardKind then 
                       (if desc.size
                        // 4 then
                           N.off->GS.thisPT.longs.add
                        // 1 then
                           N.off->GS.thisPT.bytes.add
                        // 8 then
                           N.off->GS.thisPT.reals.add
                        // 2 then
                           N.off->GS.thisPT.shorts.add
                        else
                           Cerror
                           (# 
                           do 'Unkown size(standard descriptor):'->xT;
                              desc.size->xI
                           #)
                       if)
                    // sematt.constKind then
                           (* m:(#exit 4#); x:@m; y: @|m 
                            * seems to work fine!
                            *)                       
                    // sematt.generalKind 
                    // sematt.classKind
                    // sematt.holderKind (* OBS GC problem*) then
                       (* COM GC FIX *)
                       (if (desc[],K) -> isDirect then
                           SaveReturn;
                           &Gen.ThisRegAdr->A[];
                           N.off->Noff->A.addOff->A[];
                           (if kind = common.compKind then
                               (if common.switch[64] and NOT common.switch[65] then
                                   (# A1: ^mch.regAdr
                                   do (- 1->mch.newCstOp,A[],4)->mch.stCst;
                                      A.copy->A1[];
                                      4->A1.addOff->A1[];
                                      (- Noff div 4->mch.newCstOp,A1[],4)
                                        ->mch.stCst;
                                   #)
                               if);
                               (if not switch182 then
                                   common.compHeadSize*4->A.addOff->A[]
                               if);
                           if);
                           (if switch182 then
                               theGen.pushThis; (* for storing ref later *)
                               (desc[],kind) -> theGen.newInstance
                               (#
                               do (if hasOrigin then
                                      '!genOrigin1:'->mch.comment;
                                      true -> inEnterDoExitMethod;
                                      (Gen.ThisRegAdr,thisDesc[],es[],thisSuperChain)
                                        -> genOrgAdr
                                        -> A1[];
                                      'origin' -> A1.fieldName[];
                                      false -> inEnterDoExitMethod;
                                      313->trace(#
                                                do 'genOrigin:'->xT; A1.display->xT
                                                #);
                                      '!genOrigin2:'->mch.comment;
                                      (*true -> A1.isOrigin; *)
                                      (if es.label = gram.objectDescriptor then
                                          (* messy: we should clean-up in
                                           * genOrgAdr/genAdr such that
                                           * it either loads or a load is 
                                           * needed here
                                           *)
                                          true -> A1.isRef;
                                          'origin' 
                                            -> A1.fieldName[];
                                          (A1[],none) -> mch.ldVal;
                                      if);
                                      (*A1.toOriginReg;*)
                                      '!genOrigin3:'->mch.comment;
                                  if)
                               #)
                            else
                               (Gen.ThisRegAdr,thisDesc[],es[],thisSuperChain)
                                 -> genOrgAdr
                                 -> A1[];
                               313->trace(#
                                         do 'genOrigin:'->xT; A1.display->xT
                                         #);
                           if);
                           desc.descId->(formId[],descNo);
                           (if common.switch[68] then
                               (# p,m,at,n1,d,x: ^ASTindex;
                                  T: ^text;
                                  local: @boolean;
                                  dr: @mch.dataRegOperand
                               do desc[]
                                    ->sematt.descSonsRef
                                    ->(p[],m[],at[],n1[],d[],x[]);
                                  A.toCallReg->A[];
                                  &gen.callRegAdr -> OA[];
                                  4 -> OA.addOff -> OA[];
                                  (if common.switch[64] and not common.switch[65] then 
                                      (*for 68 AlloI inline
                                       * location and prototype
                                       *)
                                      (if kind = common.compKind then
                                          (- common.compHeadSize->mch.newCstOp,
                                          OA[],4)->mch.stCst
                                       else
                                          (- Noff div 4->mch.newCstOp,OA[],4)
                                            ->mch.stCst
                                  if)if);
                                  (*-4 -> OA.addOff -> OA[];*)
                                  (if desc[] -> sematt.hasAcode then
                                      desc.originOff - 4-> OA.addOff-> OA[];
                                      A1[] -> OA.storeOrigin;
                                   else
                                      desc.originOff -> A.addOff -> A[];
                                      A1[] -> A.storeOrigin;
                                  if);
                                  (if false (* inlining *) then
                                      (* store prototype *)
                                      ('T',desc[])->mkEntrypoint->(T[],local);
                                      (T[],local)->mch.importData;
                                      (T[]->mch.NewTextToDataOp,
                                      mch.callRegOp[])->mch.gLea;
                                      (mch.callRegOp[],OA[])->mch.stVal;
                                      
                                  if);
                                  A1.freeAdr;
                                  OA.freeAdr;
                                  (if false (* inlining *) then
                                      (* gen alloc for desc.Gpart *)
                                      (at,Noff,&RepList[])->&GenAlloc; 
                                   else
                                      (if desc[] -> sematt.hasAcode then
                                          1->mch.getPrimReg->mch.gClr;
                                          (* origin *)

                                          (mch.callRegOp[],2->mch.getPrimReg)
                                            ->mch.cpReg; (* sun4s only*)
                                          5->common.count; 
                                          ('V',desc[],2)->callEntry;
                                  if)if);
                               #)
                            else
                               (if switch182 then
                                   (# EH: @evalHandler; sort: @ASTindex
                                   do 1 -> A.onLevel; true -> A.isField;
                                      '!storePartObject:'->mch.comment;
                                      dataSpec.father -> sort;
                                      (if sort.label = gram.finalDecl then
                                          'FinalPartObj' -> putline
                                      if);
                                      thisDesc[]
                                        -> theGen.mkSignature
                                        -> A.receiverType[];
                                      (* fieldType?*)
                                      N.getText -> A.fieldName[];
                                      (none,false,''
                                      ,desc[] -> theGen.mkSignature)
                                        -> A.asgRefReg
                                   #)
                                else
                                   (if desc[]->sematt.hasAcode then
                                       A.toCallReg->A[];
                                       &gen.callRegAdr->OA[];
                                       desc.originOff->OA.addOff->OA[];
                                       (thisDesc[],A1[],OA[]) 
                                         -> doStoreOrigin;
                                       A1.freeAdr;
                                       OA.freeAdr;
                                       ('G',desc[],2)->callEntry
                                    else
                                       desc.originOff->A.addOff->A[];
                                       (thisDesc[],A1[],A[]) 
                                         -> doStoreOrigin;
                                       A1.freeAdr;
                                   if);
                               if);                                   
                               A.freeAdr;
                           if);
                        else
                           (* desc with mainPart of doPart slot *)
                           partRefTag -> SlotOrComDesc
                       if)
                    // sematt.comKind (*// sematt.holderKind*) then
                       common.comKind -> kind; (* common.comKind and 
                                                * sematt.comKind
                                                * is NOT the same! MESS!
                                                *)
                       0 -> SlotOrComDesc 
                       (* changes needed here! AT least the ref tag
                        * in the proto table must be changed*)
                       (*// sematt.holderKind then
                        ( * OBS! a holder object cannot be moved by the GC;
                        * we must handle this in a special way;
                        * )
                        common.holderKind -> kind; ( * see comkind case above* )
                        0 -> SlotOrComDesc    *)
                    // sematt.dataKind then (*skip*)
                    // sematt.externalKind then
                       cError
                       (#  do 'External part object not possible!'->xT #);
                   if)
                // gram.virtualDecl // gram.bindingDecl then
                   (* desc = (virtual <V> <BS>) | (bind <V> <BS>)
                    * N: @ es where es = <V>
                    * NO alloc code to be generated?
                    *)
                   saveReturn;
                   ES -> SemAtt.getname -> VN;
                   VN.dclref -> VN;
                   (if switch182 then
                       (# sigT: ^text; 
                          withQua: @boolean;
                          EH: @evalHandler
                       do '!virtualStatic:begin' -> mch.comment;
                          theGen.pushThis;
                          true -> inEnterDoExitMethod;
                          (Gen.ThisRegAdr,thisDesc[],ES[],thisSuperChain)
                            -> genOrgAdr
                            -> OA[];
                          true -> inEnterDoExitMethod;
                          'origin'->OA.fieldName[];
                          true -> OA.isOrigin; 
                          (* something odd here; cleanup is needed
                           * (OA[],none) -> mch.ldVal;
                           *)
                          '!virtualStatic:alloc' -> mch.comment;
                          301->trace(#
                                    do 'VB: ' -> xT; VN[] -> xA; es[] -> xA 
                                    #);
                          (VN[]->EH.getVirtDcl
                          ,OA[],ES[],kind) 
                            -> CallClassPtnMethod 
                            ->(sigT[],xD[]);
                          N.off -> gen.thisRegAdr -> A[];
                          1 -> A.onLevel; true -> A.isField;
                          N.getText -> A.fieldName[];
                          thisDesc[] 
                            -> theGen.mkSignature -> A.receiverType[];
                          308->trace(#
                                    do 'simpleAlloc:static:virtual:' -> xT;
                                       desc[] -> xA
                                    #);
                          (* in most cases V:<A needs no qua-chec,
                           * but in T::V; V:<X when calling T we
                           * get V:<X as desc - and a Qua-check is needed
                           * we should recognise the latter situation
                           * to avoid unnecessary qua-checks
                           *)
                          true or (desc.label = gram.bindingDecl) -> withQua;
                          (none,withQua,'',sigT[]) -> A.asgRefReg;
                          '!virtualStatic:end' -> mch.comment;
                       #)
                    else
                       (Gen.ThisRegAdr,thisDesc[],ES[],thisSuperChain)
                         -> genOrgAdr
                         -> OA[];
                       1->mch.initprimCall;
                       (OA[],VN.off,VN.access,false)->gen.NewVirt;
                       0->mch.getPrimRes;
                       mch.pushReg->max;
                       (if common.switch[68] then
                           (if kind
                            // common.itemKind then
                               mch.callRegOp[]->mch.jsrReg
                            // common.compKind then
                               ('AlloC',none )->mch.callAlloPrim
                           if)
                        else
                           (if kind
                            // common.itemKind then
                               ('AlloI',none )->mch.callAlloPrim
                            // common.compKind then
                               ('AlloC',none )->mch.callAlloPrim
                           if)
                       if);
                       N.off->Gen.ThisRegAdr->A[];
                       (# A2: @mch.regadr; dest: ^mch.registerOperand; 
                       do
                          A2.mkCall; 
                          (A2[],false,none,none)->A.asgRefAdr->dest[]->mch.chkHeap
                       #);
                       max->mch.popReg;
                       N.off+partRefTag->GS.thisPT.Dyn.add
                   if)
                // gram.unExpanded then
                   partRefTag -> SlotOrComDesc
               if)
           if)
        #);
      RepAlloc:
        (# repType:
             (* We have      R: [e] ^P
              * where    (1) P: sP(# ... #)
              * or       (2) P:< sP(# .... #)
              *              P::< sP (# ... #)
              * or       (3) P:< A;
              *              P::< A
              * In (1) and (2) type 'P'
              * In (3) type is 'A'
              *)
             (# desc: ^ASTindex;
                T: ^text;
                D: @ASTindex;
                dK: @integer
             enter desc[]
             do (if desc.label <> gram.objectDescriptor then
                    (* virtual, binding, etc *)
                    desc.son -> D;
                    D.brother -> D;
                    (thisDesc[],D[]) -> GetActualDesc -> (D,dK);
                 else 
                    desc -> D
                if);
                D[]->theGen.mkArraySignature -> T[];
             exit T[]
             #);
           dataSpec,index,N,desc,eval,spec: @ASTindex;
           first: @boolean;
           Noff,descKind,kind: @integer;
           EH: @EvalHandler;
           V: ^EH.EvVal;
           AllocRep:
             (# n,p: @integer;
                prim: @text;
                generalRep,pop: @boolean;
                LoadOriginAndProto:<
                  (# 
                  do (if mch.callRegBusy then
                         'genlib:generallib:callregbusy'
                           -> thisTranslate.systemException
                     if);
                     (if switch182 then true -> inEnterDoExitMethod if);
                     INNER;
                     (if switch182 then false -> inEnterDoExitMethod if);
                  #);
                callRegOnStack: @boolean
             enter n
             do 308->trace(#
                          do 'repAlloc:ObjKind:'->xT;
                             thisDesc->sematt.descKind->xI
                          #);
                n+1 (* SP *) ->mch.initPrimCall;
                INNER; 
                (if switch182 then 
                    pushThis;
                    'load range' -> mch.comment;
                    true -> inEnterDoExitMethod;
                    (gen.thisRegadr,eval[],false,ThisSuperChain)
                      -> EH.ExpEval
                      -> V[];
                    false -> inEnterDoExitMethod;
                if);
                (* parameters:
                 * simple:  p1 = off , 
                 *          p2 = range, 
                 *          p3 = this (SGI/PPC)
                 *          p4 = SP, (SGI/PPC)
                 * general  p1 = originReg = origin, 
                 *          p2 = callReg = proto, NOTE that on some platforms,
                 *                                e.g. sparc, p2 <> callReg
                 *                                so proto is then NOT in p2
                 *          p3 = off, 
                 *          p4 = range,
                 *          p5 = this (SGI/PPC)
                 *          p6 = SP   (SGI/PPC)
                 *)
                (if generalRep then 2->p else 0->p if);
                (if common.switch[61] then
                    (if mch.callRegBusy then
                        true->pop; (false,true)->mch.pushThisOrCall
                    if)
                if);
                (* p2/p4*)
                (* We override callReg *)
                p+2->V.toPrimDest;
                V.release;
                (* p1/p3 *)
                (*(Noff->mch.NewCstOp,p+1->mch.getPrimReg)->mch.ldCst;*)
                (if not switch182 then
                    p+1->(Noff->mch.NewCstOp).toPrimDest;
                if);
                (if common.switch[61] then (* 3/5 *)
                    p+3->mch.thisRegOp.toPrimDest;
                    (* 4/6 *)
                    (p+4,1)->mch.SPtoPrimReg;
                if);
                (if generalRep then
                    LoadOriginAndProto;
                    (if kind = gram.staticItem then
                        'I'->prim.put
                     else
                        'C'->prim.put
                    if)
                if);
                (if not switch182 then prim->mch.callPrim if);
                0->mch.getPrimRes;
                (if switch182 then
                    (# A: @mch.RegAdr; ar: @mch.adrRegOperand;
                       sourceClassName: ^text
                    do Noff -> A.addOff;
                       1 -> A.ONlevel; 
                       true -> A.isField;
                       (thisDesc[] 
                         -> theGen.fieldSignature).asText
                         -> A.receiverType[];
                       301->trace(#do 'array:'->xT; desc[] -> xA#);
                       (if kind = gram.variablePattern then
                           (*'\nVarPtn alloc' -> putline;*)
                           (theGen.StructureSignatureId
                             -> theGen.specialSignature
                             -> array).asText 
                             ->  sourceClassName[]
                        else
                           desc[]->repType -> sourceClassName[]
                       if);
                       (prim,sourceClassName[]) -> mch.callAlloPrim;
                       this(RepAlloc).N.gettext -> A.fieldName[];
                       (aR[],false,sourceClassName[],sourceClassName[])
                         -> A.asgRefReg;
                    #)
                if);
                (if pop then (false,true)->mch.popThisOrCall if)
             #)
        enter (N,index,dataSpec,first)
        do (* (repetition <nameList> <Index> <DataSpec>) *)
           (* <index> = (index <int-eval> )              *)
           (*         | (namedIndex <name> <int-eval>)   *)
                (*313->trace(#do dataSpec[]->A #);*)
           SaveReturn;
           (N.off -> Noff) + partRefTag -> GS.thisPT.Dyn.add;
           (if N[] -> reps.has then
               (*301->trace(#do '\nIn repList'-> xT; N[] -> xA #);*)
               leave RepAlloc
           if);
           index.son->eval;
           (if index.label // gram.namedIndex then eval.brother->eval if);
           (if not switch182 then
               (gen.thisRegadr,eval[],false,ThisSuperChain)->EH.ExpEval->V[]
           if);
           (if dataSpec.label->kind
            // gram.dynamicItem // gram.dynamicComponent // gram.variablePattern
               then
               (if switch182 then
                   (dataSpec.son->spec,first,N) -> GetAndSaveDescriptor -> desc;
               if);
               3 -> AllocRep(#do 'AlloRR'->prim #)
            // gram.staticItem // gram.staticComponent then
               (dataSpec.son->spec,first,N) -> GetAndSaveDescriptor -> desc;
               (if desc.label
                // gram.objectDescriptor then
                   desc->sematt.descKind->descKind;
                   (if desckind
                    // sematt.standardKind then 
                       3
                         ->AllocRep
                       (# 
                       do 
                          (if desc.size
                           // 1 then
                              (if switch182 then
                                  (if true
                                   // desc -> sematt.boolDesc.equal then
                                      'AlloVRZ'->prim
                                   // desc -> sematt.int8Desc.equal then
                                      'AlloVRB'->prim
                                   // desc -> sematt.int8uDesc.equal then
                                      (* NOTE! int8u is represented as int32,
                                       * we may do it with int16
                                       *)
                                      'AlloVR4'->prim
                                   else
                                      'AlloVR1'->prim
                                  if)
                               else
                                  'AlloVR1'->prim
                              if)
                           // 2 then
                              'AlloVR2'->prim
                           // 8 then
                              'AlloVR8'->prim
                           else
                              'AlloVR4'->prim
                          if)
                       #)
                    // sematt.generalKind then
                       5
                         ->AllocRep
                       (#
                          formId: ^text;
                          descNo: @integer;
                          OA: ^mch.address;
                          LoadOriginAndProto:: 
                            (# 
                            do
                               desc.descId->(formId[],descNo);
                               (gen.thisRegAdr,thisDesc[],spec[],
                               thisSuperChain)->genOrgAdr->OA[];
                               OA.toOriginReg;
                               desc[]-> doLoadProto
                            #)
                       do
                          'AlloVR'->prim;
                          true->generalRep (*'AlloORG'->prim;*)
                       #)
                   if)
                // gram.virtualDecl // gram.bindingDecl then
                   5
                     ->AllocRep
                   (#
                      OA: ^mch.address;
                      formId: ^text;
                      descNo: @integer;
                      VN: @ASTindex;
                      LoadOriginAndProto:: 
                        (# 
                        do
                           spec->semAtt.getName->VN;
                           VN.dclRef->VN;
                           (gen.thisRegAdr,thisDesc[],spec[],thisSuperChain)
                             ->genOrgAdr->OA[];
                           spec->sematt.getName->VN;
                           VN.dclRef->VN;
                           (OA[],VN.off,VN.access,false)->gen.newVirt;
                           
                        #);
                      
                   do 'AlloVR'->prim; true->generalRep
                   #)
                // gram.unExpanded then
                   5
                     ->AllocRep
                   (#
                      OA: ^mch.address;
                      formId: ^text;
                      descNo: @integer;
                      LoadOriginAndProto:: 
                        (# 
                        do
                           desc->sematt.getPostDesc->formId[];
                           1 -> descNo;
                           (gen.thisRegAdr,thisDesc[],spec[],thisSuperChain)
                             ->genOrgAdr->OA[];
                           OA.toOriginReg;
                           desc[]->doLoadProto
                           
                        #)
                   do 'AlloVR'->prim; true->generalRep
                   #)
               if)
           if)
        #);
   do
      att
        ->scanList
      (# dcl,nameL,ES,desc: @ASTindex; first: @boolean;        
      do
         currentNode->dcl;
         308->trace (# do 'genAlloc:' -> xT; dcl[]->xA #);
         (if common.switch[28] then dcl[]->gen.comment if);
         (if not dcl.isSlot then
             dcl.son->nameL;
             nameL.brother->ES;
             true->first;
             nameL
               ->scanList
             (# N: @currentNode
             do
                (if dcl.label
                 // gram.simpleDecl then
                    (N,ES,first)->simpleAlloc
                 // gram.repetitionDecl then
                    (N,ES,ES.brother,first)->repAlloc
                 // gram.patternDecl then
                    (if switch182 (*bytecode*) then
                        ES[] -> saveLocalDesc
                     else
                        (ES,0,0,N)->DS.push
                    if)
                 // gram.virtualDecl // gram.bindingDecl
                 // gram.finalDecl then
                    (if ES.label = gram.objectDescriptor then
                        (if switch182 (*bytecode*) then
                            ES[] -> saveLocalDesc
                         else
                            (ES,0,0,N)->DS.push
                        if)
                     else
                        (if switch182 (*bytecode*) then
                            (* as in V:< A *)
                            ES[] -> saveLocalDesc
                    if)if)
                if);
                false->first             
             #)            
         if)
      #)
   #)
--- genNpart:doPart---
do
   (# EH: @evalHandler;
      Vlab: ^text;
      nScan: @ | EH.scanNadr;
      more: @boolean; 
      NO: ^sematt.NXoffSets;
      NV: ^EH.NXoffSetsVal;
   do 307->trace(#do 'GenNpart: '->xT; thisDesc[] -> xA #);
      &sematt.NXoffSets[] -> NO[];
      (thisDesc[],true,thisDesc->DH.newSingle,thisDesc.returnOff) 
        -> NO.setNXOffSets;
      (if NO.top > 0 then 
          (* a descriptor may have an 'enter aVirtualPtn
           * where aVirtualPtn has an empty enter list;
           * the virtual may be extended with an enter list
           * in a subpattern; see example in tstnxoff2
           *)
          (for i: NO.top repeat
               (if NO.kind[i]
                // NO.refTmp // NO.repTmp then
                   NO.off[i] -> GS.thisPT.dyn.add
          if)for);
          
          ('N',thisDescNo,thisForm[],NOT common.switch[30])->gen.SysLab->Vlab[];
          (Vlab[],false) -> mch.GlobalLabelDef;
          mch.savereturn;
          
          (thisDesc[],gen.thisRegAdr,0,thisSuperChain,true) -> nScan -> more;
          0 -> nScan.case;
          (gen.thisRegAdr,thisDesc[],NO[],true) -> EH.mkNXOffSetsVal -> NV[];
          true -> NV.Exe.executedXpart;
          L: (# A: ^mch.address; off: @integer; isRef: @boolean
             do NV[] -> nScan.asgToNelm;
                (*NV.release;*)
                mch.releaseReg;         
                (if nScan-> more then restart L if)
             #);
          mch.return
      if);
      NO.startOff -> exitOffStart
   #)
---genXpart:doPart---
do
   (# EH: @evalHandler;
      Vlab: ^text;
      xScan: @ | EH.scanXadr;
      more: @boolean;
      NO,XO: ^sematt.NXoffSets;
      xStartOff: @integer
   do 307->trace(#do 'GenXpart: exitOffSet:'->xT; exitOffStart -> xI; 
                   XN; thisDesc[] -> xA ;                
                #);
      &sematt.NXoffSets[] -> NO[];
      (* optimize call of SetNoffset twice 
       (if thisDesc[] -> sematt.hasNcode then
       (thisDesc[],true,thisDesc->DH.newSingle,thisDesc.returnOff) 
       -> NO.setNXOffSets; 
       NO.startOff -> xStartOff
       else
       thisDesc.returnOff -> xStartOff
       if);
       178->trace(#do 'NO.startOff='->xT; xStartOff -> xI#);
       *)
      &sematt.NXoffSets[] -> XO[];
      (thisDesc[],false,thisDesc->DH.newSingle,exitOffstart) -> XO.setNXOffSets;
      (if XO.top > 0 then 
          (for i: XO.top repeat
               (if XO.kind[i]
                // XO.refTmp // XO.repTmp then
                   XO.off[i] -> GS.thisPT.dyn.add
          if)for);
          
          ('X',thisDescNo,thisForm[],NOT common.switch[30])->gen.SysLab->Vlab[];
          (Vlab[],false) -> mch.GlobalLabelDef;
          mch.savereturn;
          
          (thisDesc[],gen.thisRegAdr,0,thisSuperChain) -> xScan -> more;
          L: (# XV: ^EH.evVal
             do xScan.getExitVal -> XV[]; (* may be object or list *)
                (gen.thisRegAdr,XO[],true) -> XV.asgToNXoffSets;

                (* assign to offset *)
                XV.release;
                mch.releaseReg;
                (if stest then
                    178->trace(#do 'GenXpart2:'->xT; mch.dumpreg #)
                if);
                (if xScan-> more then restart L if)
             #);
          mch.return
      if)
   #)
   
