ORIGIN 'genlib';
INCLUDE 'auxlib';
BODY 'signaturebody'
---theGenLib:attributes---

use_dotnet_modules: 
  (# exit false #);
trace_sig:
  (# exit false #);

descLocation:
  (* Return the fragmentgroup (file location) of desc
   * 1.  location = ''    desc is in this group
   * 2.  location = 'foo' desc is declared in 'foo'
   * 3.  location = none  desc is slot and location
   *                          of the form for the slot
   *                          is not known. The slot is
   *                          a descriptor- doPart or 
   *                          mainpart-slot
   * Part of the code here is copied form mkEntryPoint;
   * this should be unified.
   *)
  (# desc: ^ASTindex; location: ^text;
     N: @ASTindex;
     formId: ^text; descNo: @integer;
     findSlashDash:
       (# N: ^text; pos,slashPos,dashPos: @integer
       enter N[] (* N= '/users/smith/.../foo-formName' *)
       do N.scanAll(#
                   do pos+1->pos;
                      (if ch = '-' then pos -> dashPos if);
                      (if ch = '/' then pos -> slashPos if)
                   #);
          (* 0 <= slashPos < dashPos < N.length *)
          inner;
       exit N[]
       #);
     stripForm: findSlashDash
       (# 
       do (if dashPos > 0 then (dashPos,N.length) -> N.delete -> N[] if)
       #);
     stripFile: findSlashDash
       (# 
       do (slashPos+1,dashPos) -> N.delete -> N[]
       #);
     stripFileAndForm: findSlashDash
       (# 
       do (slashPos+1,N.length) -> N.delete -> N[]
       #);
     slotLocation:
       (# d: ^ASTindex; L: ^text
       enter D[]
       do (D[],true) -> EH.descName -> mch.import;
          (* note we deliberately return L[] = none *)
       exit L[]
       #);
     EH: @evalHandler;
     S: ^text
  enter desc[]
  <<SLOT descLocation:doPart>>
  exit location[]
  #);


AddDotnetLocation:
  (# class, location, T, trace: ^Text;
     simple: @boolean;
     add_resolution:
       (# T, resolution: ^text;
       enter (T[], resolution[])
       do (if use_dotnet_modules then
              '[.module \'' -> T.append;
              resolution[] -> T.append;
              '.netmodule\']' -> T.append;
           else
              '[\'' -> T.append;
              resolution[] -> T.append;
              '\']' -> T.append;
          if);
       #);
     
  enter (class[], location[])
  do 
     (if trace_sig then
         ''->trace[];
         '/*AddDotnetLocation('->trace.append;
         class[]->trace.append;
         ', '->trace.append;
         location[]->trace.append;
         '*/'->trace.puttext;
     if);
     
     ''->T[]; 
     (if true 
      // '-' -> class.equal 
      // 'object' -> class.equal 
      // '[mscorlib]System.Object' -> class.equal 
      // 'class [mscorlib]System.Object' -> class.equal 
      // 'int32'   -> class.equal 
      // 'char'    -> class.equal 
      // 'void '   -> ((1,5)->class.sub).equal
      // 'int32 '  -> ((1,6)->class.sub).equal
      // 'char '   -> ((1,5)->class.sub).equal
      // 'char[]'  -> ((1,6)->class.sub).equal
      // 'int32[]' -> ((1,7)->class.sub).equal
         then (* nothing *)
         true -> simple;
      else
         (if location[]=NONE then
             (* Unknown file - put assembly in file with same name as class *)
             'class ' -> T.append;
             (if trace_sig then
                 '/* reference to class ' -> T.puttext; class[]->T.puttext; 
                 ' in unknown file */' -> T.puttext;
             if);
             (T[], class[]) -> add_resolution;
          else
             (if location.length=0 then
                 (* local *)
                 'class '->T.append;
                 (if trace_sig then
                     '/* reference to local class ' -> T.puttext; class[]->T.puttext;  '*/' -> T.puttext;
                 if);
              else
                 (* Nonlocal, known location *)
                 'class ' -> T.append;
                 (# e: @diskentry;
                 do location[] -> e.path;
                    e.path.name -> location[];
                 #);
                 (if trace_sig then
                     '/* reference to class ' -> T.puttext; class[]->T.puttext; 
                     ' in file ' -> T.puttext;
                     location[] -> T.puttext;
                     '*/' -> T.puttext;
                 if);
                 (T[], location[]) -> add_resolution;
             if)
         if);
     if);
     (if not simple then '\''-> T.append; if);
     class[] -> T.append;
     (if not simple then '\''-> T.append; if);
     (if trace_sig then
         trace[] -> T.append;
     if);
  exit T[]
  #);

Type: 
  (# isRef: < booleanValue;
     isList:< booleanValue;
     elmType:<  integerValue;
     
     asText:<
       (# T: ^text
       do inner;
          187->ctrace(# 
                     do 'Signature:'  ->xT; T[] -> xT;
                        ' location:'->xT;
                        (if location[] = none then
                            'unknown' -> xT
                         else
                            location[] -> xT
                     if)#);
       exit T[]
       #);
     location: ^text
  do inner
  exit this(Type)[]
  #);
int32Value: Type 
  (# elmType::(#do 1 -> value #);
     asText::
       (#
       do (if isJava then 'I'->T[] else 'int32'->T[] if)
       #)
  #);
charValue: Type 
  (# elmType::(#do 2 -> value #);
     asText::
       (#
       do (if isJava then 'C'->T[] else 'char'->T[] if)
       #)
  #);

Void: Type
  (# elmType::(# do 10 -> value #);
     asText:: 
       (#
       do (if isJava then 'V'->T[] else 'void'->T[] if)
       #)
  #);

Reference: Type 
  (# class: ^text;
     isRef:: TrueValue;
     elmType:: (# do 11 -> value #);
     
     asText::
       (# 
       do (if location[] <> none then (* only needed for .NET *)
              location[] -> mch.import
          if);

          (if isJava then
              'L' -> T[]; class[] -> T.append; ';'->T.put;
           else 
              (class[], location[]) -> AddDotnetLocation -> T[];
          if);
          (if stest then 
              187->trace(#
                        do 'descLocation:: '->xT; location[] -> xT
                        #)
          if);
         
       #)
  enter class[]
  do (if true
      // 'object' -> class.equalNCS 
      // 'Object' -> class.equalNCS then
         (if true
          // isJava then
             'java/lang/Object' -> class[]
          // isDotNet then
             'object' -> class[]
          else
             'Unknown_platform.Object' -> class[]
         if);
     if);
  #);
Array: Type
  (# element: ^Type;
     isRef:: trueValue;
     elmType:: (# do 12 -> value #);
     asText::
       (#
       do (if isJava then 
              '[' -> T[];
              element.asText -> T.append; 
           else (* FIXME *)
              element.asText -> T[]; '[]' -> T.append
          if)
       #)
  enter element[]
  #);
mkListSignature:
  (# T:  ^type; L:@ListSignature
  enter T[]
  do T[] -> L.append
  exit L[]
  #);
ListSignature: Type
  (# L: [3] ^Type; top: @integer;
     isList::trueValue;
     append:
       (# T: ^Type; TL: ^ListSignature
       enter T[]
       do (if T.isList then
              T[] -> TL[];
              TL.scan(# do current[] -> append #)
           else
              (if (top+1->top) > L.range then
                  L.range -> L.extend
              if);              
              T[]-> L[top][]
          if)
       #);
     scan:
       (# current: ^Type
       do (for i: top repeat
               L[i][] -> current[];
               INNER
          for)
       #);
     asText::
       (# 
       do &text[] -> T[];
          (if isJava then
              scan(#do current.asText -> T.append #);
           else
              scan
              (# addSep: @boolean;
              do (if addSep then ','->T.put if);
                 current.asText -> T.append;
                 true -> addSep;
              #);
          if)
       #)
  #);
BetaTextSignatureId: (# exit 1 #);
JavaStringSignatureId: (# exit 2 #);

specialSignature: Type
  (# sigId: @integer;
     astext::
       (#
       do &text[] -> T[];
          (if isJava then
              (if sigId
               // BetaTextSignatureId then
                  'Ltext;' -> T.append
               // JavaStringSignatureId then
                  'Ljava/lang/String;' -> T.append
               else
                  'LUnknowSpecialSignature;' -> T.append
              if)
           else
              (if sigId
               // BetaTextSignatureId then
                  'text' -> T.append
               // JavaStringSignatureId then
                  'string' -> T.append
               else
                  '>>>>>UnknowSpecialSignature' -> T.append
              if)
          if)
       #)
  enter sigId
  #);

valueSignature:
  (# desc: ^ASTindex; sig: ^Type
  enter desc[]
  do (if true 
      // desc -> sematt.integerDesc.equal then
         int32Value -> sig[]
      // desc -> sematt.charDesc.equal then
         charValue -> sig[]
      else
         int32Value -> sig[]
     if)
  exit sig[]
  #);

mkSignature:
  (# desc: ^ASTindex; sig: ^Type; tsig: ^text; 
     EH: @evalHandler
  enter desc[]
  do (if (desc -> sematt.descKind) = sematt.standardKind then
         (desc[] -> valueSignature -> sig[]).astext -> tsig[]
      else         
         (desc[],true) -> EH.descName -> Reference -> sig[];
         desc[] -> descLocation -> sig.location[];
         sig.asText -> tsig[];
     if);
     (if false and isJava then
         (* hack *)
         (if tsig.length > 2 then
             (2,tsig.length-1) -> tsig.sub -> tsig[]
         if)
     if)
  exit tsig[]
  #);
mkArraySignature:
  (* we should simplify mkSignature and this one *)
  (# desc: ^ASTindex; tsig: ^text;
     EH: @evalHandler
  enter desc[]
  do (if (desc -> sematt.descKind) = sematt.standardKind then
         (desc[] -> valueSignature ->array).astext -> tsig[]
      else
         ((desc[],true) -> EH.descName -> Reference->array).asText -> tsig[]
     if)
  exit tsig[]
  #);
ISignature:
  (# asText:<
       (# T: ^text
       do inner;
          (if isJava and common.switch[189] then
              (* to be able to debug locations using java bytecode *)
              '[\'' -> T.append;
              (if location[] = none then 
                  (* to be able to debug locations using java bytecode *)
                  '-unknown-' -> T.append
               else
                  location[] -> T.append;
              if);
              '\']' -> T.append
          if)
       exit T[]
       #);
     location: ^text
  do inner;
  exit this(ISignature)[]
  #);
Signature: ISignature
  (* Obs! ISignature has recently been introduced as a superclass
   * of Signature to handle requirements for distinguishing
   * between signatures for method-declarations, method-calls,
   * instance creation, superclasses, etc. Currently Signature
   * covers method-calls and method-declarations as described below:
   * A signature may have the following two abstract forms:
   * 1. Method def :           method, input arguments, return type;
   * 2. Method call: receiver, method, input arguments, return type
   * As can be seen the difference is the receiver present in
   * the method call
   *)
  (# receiver: ^text;         (* an optional receiver *)
     receiverDesc: ^ASTindex; (* descriptor for receiver *)
     isStatic: @boolean;
     method: ^text;           (* method name *)
     NNsig: ^ListSignature;   (* input arguments *)
     XXsig: ^Type;            (* return type *)
     
     
     thisMethodDesc: @ASTindex;(* descriptor of this method (pattern) *)
     location: ^text;          (* fragment group (file) where thisMethodDesc is 
                                * declared - see descLocation above
                                *)
     thisChain: ^DH.superChain;(* desc chain of def- or call-location *)
     
     setMethodDesc:
       (# EV: ^ASTindex; MN,vKind: @integer
       enter EV[]
       do (if EV.label = gram.unExpanded then
              EV -> thisMethodDesc
           else
              (thisSuperChain,EV) 
                -> DH.theDesc
                -> (thisMethodDesc,MN,thisChain[],vKind);
          if);
          (if false then 
          thisMethodDesc[] -> descLocation -> location[];
          313->trace(#
                    do 'signature:setDesc: "' -> xT; 
                       (if location[] = none then 
                           'none' -> xT
                        else
                           location[] -> xT; 
                       if);
                       '"' -> put; xN;
                       thisMethodDesc[] -> xA
                    #);
          (if location[] <> none then
              location[] -> mch.import
          if)if)
       #);
     markStatic: (# do true -> isStatic #);
     addReceiver: 
       (* only receiverDesc should be enter arg;
        * at all call sites, receiver is computed;
        * this can be done here
        *)
       (# 
       enter(receiver[],receiverDesc[])
       do (if (receiverDesc[] -> descLocation -> location[]) <> none then
              location[] -> mch.import
          if)
       #);     
     addMethod: (# enter method[] #);
     
     noOfEnterArgs: 
       (# N: @integer 
       do (if NNsig[] <> none then NNsig.top -> N if) 
       exit N 
       #);
     enterSig:
       (# noNsig: @boolean;
          T: @text
       enter noNsig
       do '('->T;
          (if not NoNsig then 
              NNsig.asText -> T.append;
          if);
          ')'->T.put;
       exit T[]
       #);
     exitSig:
       (# noXsig: @boolean; T: ^text
       enter noXsig
       do (if noXsig then voidExitSig -> T[] else XXsig.asText -> T[] if)
       exit T[]
       #);
     voidExitSig: 
       (# T: @text 
       do (if isJava then 'V' -> T else 'void'->T if);
       exit T[]
       #);
     asText::
       (* producec a textual representation of this signature *)
       (# noNsig,noXsig: @boolean;
       enter(noNsig,noXsig)          
       do (if isJava then
              (if receiver[] <> NONE then
                  (* method call signature *)
                  receiver[] -> T[];
                  '/' -> T.put
               else
                  &text[] -> T[];
                  (if isStatic then
                      'static ' -> T.append
                  if)
              if);
              (if method[] <> none then
                  method.copy -> T.append
               else
                  '\n*** method is none ' -> putline
              if);
              noNsig-> enterSig -> T.append;
              noXsig -> exitSig -> T.append;
              (if false then
              (# S: ^text
              do (if location[] <> none then
                     'location: ' -> (location.copy).prepend -> S[];
                     ': ' -> S.append
                  else
                     'location:none: ' -> S[]
                 if);
                 T[] -> S.append;
                 S->mch.comment
              #)
              if)
           else
              '' -> T[];
              (if isStatic then
                  'static ' -> T.append
              if);
              noXsig -> exitSig -> T.append;
              ' '->T.append;
              (if receiver[] <> none then
                  (* method call signature *)
                  (receiver[],location[]) -> AddDotnetLocation  -> T.append;
                  '::' -> T.append
              if);
              (if method[] <> none then
                  '\'' -> T.put; (* Quote to avoid clash with IL 
                                  * reserved words, e.g. add *)
                  method.copy -> T.append;
                  '\'' -> T.put;
               else
                  '\n*** method is none ' -> putline
              if);
              noNsig -> enterSig -> T.append
          if);
          187->ctrace(# 
                     do 'Signature:'  ->xT; T[] -> xT;
                        ' location:'->xT;
                        (if location[] = none then
                            'unknown' -> xT
                         else
                            location[] -> xT
                     if)#)
       #);

     noEnter: (# do ListSignature -> NNsig[] #);
     setEnter: (# enter NNsig[] #);
     addEnter:
       (# EH: @EvalHandler;
          nScan: @ | EH.scanNAdr;   
          nD: ^sematt.AttDesc; 
          theDesc: ^ASTindex;
          more: @boolean;
          sig: ^reference
       enter theDesc[]
       do 313->trace(#
                    do 'addEnter:'->xT; theDesc[] -> xA
                    #);
          ListSignature -> NNsig[];
          (if thisChain[] <> none then
              (if not (theDesc->thisMethodDesc.equal) then 
                  (if not common.switch[188] then
                      'addEnter:desc not equal'->putline
                  if)
              if);
              313->trace(#
                        do 'addEnter:theDesc(from enter):'->xT;
                           theDesc[]->xA; xN;
                           'thisMethodDesc( for setDesc): ' -> xT;
                           thisMethodDesc[] -> xA;
                           (if thisChain[] <> none then
                               thisChain
                           if) 
                        #);
              (if isStatic then (* should be origin of thisMethodDesc *)
                  (# org: ^ASTindex
                  do thisMethodDesc[] -> sematt.descOrigin -> org[];
                     (if org.isNull then
                         'object' -> reference -> sig[]
                      else
                         (org[] ,true)
                           -> EH.descName 
                           -> reference 
                           -> sig[]
                     if);
                     org[] -> descLocation -> sig.location[];
                     sig[] -> NNsig.append;
                  #)
              if);              
              (thisMethodDesc[],gen.thisRegAdr,0,thisChain[],true) -> nScan -> more;
           else
              (theDesc[],gen.thisRegAdr,0,thisSuperChain,true) -> nScan -> more;
          if);
          Loop:
            (if more then
                (nScan.thisEv[],theDesc[],true) -> getAttSig -> NNsig.append;
                313->trace(#do 'Nsig: '->xt; NNsig.asText -> xT #);
                nScan -> more;
                restart Loop
            if);
          313->trace(#do 'enterNsig: '->xT; NNsig.asText -> xT #);
       #);
     scanEnter:
       (# current: ^type; isRef,doInner,skip: @boolean
       do NNsig.scan
          (#
          do current[] -> this(scanEnter).current[];
             current.isRef -> isRef; 
             INNER scanEnter
          #)
       #);
     exitVoid: 
       (# 
       do setVoidXsig
       #);
     setVoidXsig: 
       (#
       do Void -> xxSig[]; 
       #);
     exitRef:
       (# desc: ^ASTindex;
          EH: @evalHandler
       enter desc[]
       do setVoidXsig;
          (if desc[] = none then thisMethodDesc[] -> desc[] if);
          (desc[],true) -> EH.descName -> Reference -> XXsig[];
          desc[] -> descLocation -> XXsig.location[];
       #);
     setExit: (# enter XXsig[] #);
     addExit:
       (# EH: @EvalHandler;
          xScan: @ | EH.scanXadr;
          exitP: ^ASTindex;    
          more: @boolean
       enter exitP[]
       do 313->trace(#
                    do 'Signature:addExit:'->xT; xN;
                       thisMethodDesc[]->xA; xN;
                       (if thisChain[] <> none then
                           thisChain
                       if)
                    #);
          
          setVoidXsig;

          (if thisChain[] <> none then
              (thisMethodDesc[],gen.thisRegAdr,0,thisChain[]) 
                -> xScan 
                -> more;
              (if not more then exitVoid; leave addExit if);
              loop:
                (if more then
                    (xScan.thisEv[]->exitVal[],thisMethodDesc[],false) 
                      -> getAttSig 
                      -> XXsig[];
                    xScan -> more;
                    (if more then
                        '\n***OBS! exit-part has more than one element'
                          ->putline
                    if);
                    restart loop
                if)
           else
              '\n***OBS. thisChain is none '->putline;
              (if (thisMethodDesc[](*exitP[]*)->theGen.scanXarg -> exitVal[]) <> NONE then
                  (exitVal[],thisMethodDesc[],false) -> theGen.getAttSig -> XXsig[];
          if)if);
          (if XXsig.isRef then
              2 -> exitId
           else
              1 -> exitId
          if);
       #);
     exitVal: ^ASTindex;
     exitId: @integer (* dirty *)
  #);
fieldSignature: Isignature
  (# desc: ^AStindex;
     fieldSig: ^text;
     asText::
       (# S: ^text
       do (if isJava then
              fieldSig[] -> T[]
           else
              (fieldSig[],location[]) -> AddDotnetLocation -> T[];
       if)#);
     sig: ^type;
     EH: @evalHandler
  enter desc[]
  do (if (desc -> sematt.descKind) = sematt.standardKind then
         (desc[] -> valueSignature -> sig[]).astext -> fieldSig[]
      else         
         (desc[],true) -> EH.descName -> fieldSig[];
         desc[] -> descLocation -> location[];
     if);
     313->trace(#do 'fieldSignature: '->xT; fieldSig[] -> xT; xN;
                  desc[] -> xA; xN; 'location: '->xT;
                  (if location[] <> none then location[] -> xT
               if)#);
     (* (if not (desc[] = none) and not desc.isNull then
         desc[] -> descLocation -> location[];
     if);*)
     (if location[] <> none then
         location[] -> mch.import
     if)
  #);
     
classSignature: ISignature
  (* used for instance generation in newInstance;
   * OBS! className should be eliminated as enter param
   * since it can be computed from desc; however, do
   * check all call-sites carefully before doing this
   *)
  (# desc: ^ASTindex;  (* descriptor for className *)
     className         (* perhaps unify with receiver in Signature?*)
     ,location : ^text;(* form location of class *) 
     setClass: (# enter className[] #);
     asText::
       (#
       do (if isJava then 
              className[] -> T[];
           else
              (className[],location[]) -> AddDotnetLocation -> T[];
              (if trace_sig then
                  '/*classsignature*/' -> T.append;
              if);
          if)
       #)
  enter(desc[],className[])
  do (if not (desc[] = none) and not desc.isNull then
         (if (desc[] -> descLocation -> location[]) <> none then
             location[] -> mch.import
         if)
     if);
     313->trace(#
               do 'classSignature: ' -> xT; className[] -> xT;
                  ' in: ' -> xT; 
                  (if location[] = none then
                      'UnKnown'->xT
                   else
                      location[] -> xT
                  if)
               #);          
  #);
superSignature: ISignature
  (* use for super class name *)
  (# desc: ^ASTindex;
     className: ^text; (* perhaps unify with receiver in Signature?*)
     setClass: (# enter className[] #);
     asText::
       (#
       do (if isJava then 
              className[] -> T[]
           else
              (className[],location[]) -> AddDotnetLocation -> T[];
          if)
       #)
  enter(desc[],className[])
  do (if desc[] <> none then
         (if (desc[] -> descLocation -> location[]) <> none then
             location[] -> mch.import
         if)if)
  #);
scanNargs:
  (# EH: @EvalHandler;
     nScan: @ | EH.scanNAdr;   
     nD: ^sematt.AttDesc; 
     theDesc: ^ASTindex;
     more: @boolean;
     xSig: ^ListSignature
  enter theDesc[]
  do (theDesc[],gen.thisRegAdr,0,ThisSuperChain,true) -> nScan -> more;
     ListSignature -> xSig[];
     Loop:
       (if more then
           313->trace(#
                     do 'scanNargs:elm:'->xT;
                        nScan.thisEv[]->xA
                     #);
           (nScan.thisEv[],theDesc[],true) -> getAttSig -> xSig.append;
           313->trace(#do 'sig: '->xt; xSig.asText -> xT #);
           nScan -> more;
           restart Loop
       if)
  exit xSig[]
  #);

ScanXarg:
  (# theDesc,exitP: ^ASTindex;
     EH: @evalHandler;
     xScan: @ | EH.scanXAdr;
     ex: ^ASTindex;
     more: @boolean
  enter theDesc[] (*exitP[]*)
  do (theDesc[],gen.thisRegAdr,0,theDesc -> DH.newSingle) -> xScan -> more;
     (if true then
         (if more then
             &ASTindex[] -> ex[];
             xScan.thisEv -> ex;
             xScan -> more;
             (if more then
                 '\nScanXarg: more than one exit element' -> putline;
             if)
         if)
      else
         (if exitP.label <> gram.empty then
             &ASTindex[] -> ex[];
             exitP.son -> ex; (* check that ONLY one exit elm *)          
         if)
     if)
  exit ex[]
  #);
getAttSig:
  (# EV: ^ASTindex;
     nD: ^sematt.AttDesc; EH: @EvalHandler;
     theDesc: ^ASTindex;
     desc: @ASTindex; 
     MN,isVirtual: @integer;
     EVchain: ^DH.superChain;
     xSig: ^Type;
     referenceSignature: (* unify with dynamicItem case in do-part below*)
       (# EV: ^ASTindex;
          sig: ^Type
       enter EV[]
       do EV[] -> sematt.AttDesc -> nD[];
          (*nD.display;*)
          (if nD.spec.label 
           // gram.dynamicItem // gram.staticItem then
              (theDesc->DH.newSingle,nD.apl)
                -> DH.theDesc
                -> (desc,MN,EVchain[],isVirtual);
              (if desc.label = gram.objectDescriptor then
                  (desc[] ,true)
                    -> EH.descName
                    -> Reference 
                    -> sig[];  
                  desc[] -> descLocation -> sig.location[];
               else 
                  ' ***??? not descriptor ' -> putline;
                  '?notDescriptor?'->Reference -> sig[];
              if)
           else
              '?notDynamicOrStaticItem?'->Reference -> sig[];
          if);
       exit sig[]
       #);
     isEnter: @boolean
  enter(EV[],theDesc[],isEnter)
  do 313->trace(#
               do 'getAttSig:'->xT;
                  EV[] -> xA;
                  ev.label -> xI;
                  ev.label -> sematt.evalClass -> xI
               #);
     (if EV.label
      // gram.insertedItem  then
         (# den: @ASTindex;
         do EV.son -> den;
            (if den.label = gram.objectDescriptor then                
                den[] -> scanNargs -> xSig[];
                313->trace(#do 'getAttSig:inserted:'->xT;  xSig.asText->xT#)
             else
                'unknownInsertedItem;'-> Reference -> xSig[]                
         if)#)
         (* // gram.objectDenotation then
          'LunknownObjectDenotation;'->sig[]*)
      // gram.objectReference 
      // gram.structureReference then
         EV[] -> referenceSignature -> xSig[];         
      // gram.thisObject then
         (# AD: @ASTindex
         do EV.son -> AD;
            AD.dclRef -> AD;
            AD.getText -> Reference -> xSig[]
         #)
      // gram.assignmentEvaluation then
         (* preliminary *)
         (if not common.switch[188] then
             '\nOBS! Incomplete signature of assignment' -> putline;
         if);
         sematt.integerDesc[] -> valueSignature -> xSig[]
      // gram.textConst then
         '\ntextconst' -> putline;
         (* we should make a pattern for the following code and also
          * use it in e.g. referenceSignature
          *)
         (sematt.textDesc[] ,true)
                    -> EH.descName
                    -> Reference 
                    -> xSig[];  
         sematt.textDesc[] -> descLocation -> xSig.location[];
      else
         (if (EV.label -> sematt.evalClass) = sematt.evalClass.binOp then
             int32Value -> xSig[]
          else
             EV[] -> sematt.AttDesc -> nD[];
             (*nD.display;*)

             (if nD.kind
              // sematt.standardKind then
                 (if nD.isRep then
                     nD.desc[] -> valueSignature -> Array -> xSig[]
                  else
                     nD.desc[] -> valueSignature -> xSig[]
                 if)
              // sematt.generalKind 
              // sematt.classKind then
                 (if isEnter then
                     nD.desc[] -> scanNargs -> xSig[] (*sig[]*)
                  else
                     (# xEV: ^ASTindex
                     do nD.desc[] -> scanXarg -> xEV[];
                        (* is thisDesc correct here? *)
                        (xEV[],thisDesc[],false) -> theGen.getAttSig -> Xsig[];
                     #)
                 if)
              else
                 (* don't work if virtual - we should get generalKind
                  * but ...
                  *)
                 (if nD.spec.label = gram.dynamicItem then
                     (theDesc->DH.newSingle,nD.apl)
                       -> DH.theDesc
                       -> (desc,MN,EVchain[],isVirtual);
                     (if desc.label = gram.objectDescriptor then
                         (desc[],true)
                           -> EH.descName
                           -> Reference 
                           -> xsig[];
                         desc[] -> descLocation -> xsig.location[]
                      else 
                         ' ***??? not descriptor ' -> putline;
                         '?notDescriptor?'->Reference -> xSig[];
                     if)
                  else
                     '?notDynamicItem?'->Reference -> xSig[];
                 if);
     if)if)if);
     313->trace(#do 'signature:addExit:'->xT; xSig.asText -> xT #)
  exit xsig[]
  #);
defaultSuperName:
     (# superName: ^text
     do (if true
      // common.targetMachineId = common.javabc then
         'java/lang/Object'->supername[];
      // common.targetMachineId = common.dotnet then
         '[mscorlib]System.Object'->supername[]; (*'/*1*/'->supername.append;*)
         (*'object' -> supername[];*)
      else
         'Unknown_platform.Object' -> supername[];
     if);
  exit superName[]
  #);
isBETAsubOfExternalClass: booleanValue
  (* test if desc is an interface to an external class
   * or a real BETA subclass of an externalclass.
   * if interface then no code should be generated;
   * if 'real' then code should be generated.
   * As a simple hack, a direct subclass of externalClass
   * is considered to be an interface.
   * Subclasses at level 2 and below are considerered 'real'.
   * A better means for specifying interface og real
   * should be invented
   *)
  (# desc: ^ASTindex;
     pref,preName,preDesc: @ASTindex;
     subLevel: @integer;
  enter desc[]
  do desc.son -> pref;
     (if pref.label = gram.prefix then
         pref.son -> preName;
         313 -> ctrace(#
                      do 'isBetaSubOfExternalClass:super:' -> xT;
                         preName.gettext -> xT
                      #);
         preName -> sematt.descChain -> (preDesc,subLevel);
         subLevel > 0 -> value;
     if)        
  #);
     
newInstance:
  (# desc: ^ASTindex; EH: @evalHandler;
  enter desc[]
  <<SLOT auxlib_newinstance:doPart>>
  #);
getExternalClassName:
  (# desc: ^ASTindex; class: ^text; extKind: @integer
  enter desc[]
  do (none,'???',desc[],0) -> sematt.cProcDecoder -> (class[],extKind);
  exit class[]
  #)
