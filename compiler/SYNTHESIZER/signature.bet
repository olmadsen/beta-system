ORIGIN 'genlib';
INCLUDE 'auxlib';
---theGenLib:attributes---

use_dotnet_modules: 
  (# exit false #);
trace_sig:
  (# exit false #);

descLocation:
  (* Return the fragmentgroup (file location) of desc
   * 1.  location = ''    desc is in this group
   * 2.  location = 'foo' desc is declared in 'foo'
   * 3.  location = none  desc is slot and location
   *                          of the form for the slot
   *                          is not known. The slot is
   *                          a descriptor- doPart or 
   *                          mainpart-slot
   * Part of the code here is copied form mkEntryPoint;
   * this should be unified.
   *)
  (# desc: ^ASTindex; location: ^text;
     N: @ASTindex;
     formId: ^text; descNo: @integer;
     findSlashDash:
       (# N: ^text; pos,slashPos,dashPos: @integer
       enter N[] (* N= '/users/smith/.../foo-formName' *)
       do N.scanAll(#
                   do pos+1->pos;
                      (if ch = '-' then pos -> dashPos if);
                      (if ch = '/' then pos -> slashPos if)
                   #);
          (* 0 <= slashPos < dashPos < N.length *)
          inner;
       exit N[]
       #);
     stripForm: findSlashDash
       (# 
       do (if dashPos > 0 then (dashPos,N.length) -> N.delete -> N[] if)
       #);
     stripFile: findSlashDash
       (# 
       do (slashPos+1,dashPos) -> N.delete -> N[]
       #);
     stripFileAndForm: findSlashDash
       (# 
       do (slashPos+1,N.length) -> N.delete -> N[]
       #);
     EH: @evalHandler;
     S: ^text
  enter desc[]
  do (if (desc[] <> none) and not desc.isNull then
         (desc[],true) -> EH.descName ->  S[];
      else
         'NoName!'->S[]
     if);
     316->trace(# 
                do 'location:'->xT; S[] -> xT;
                   xN; desc[] -> xA
                #);
     (if not desc.isNull then
         (if desc.label = gram.mainPart then
             desc[] -> sematt.MainPartDesc -> desc[]
         if);
         (if desc.label
          // gram.objectDescriptor then
             desc.descId -> (formId[],descNo);
             desc.son->N; N.brother->N;
             (if N.isSlot then 
                 (* desc has mainPart slot *)
                 NONE -> location[] (* is this what we want? *)
              else 
                 (* check if do-part is a slot *)
                 N.son->N;     (* att-part*)
                 N.brother->N; (* action-part*)
                 N.son->N;     (* enter-part*)
                 N.brother->N; (* do-part *)
                 (if N.isSlot then 
                     (* desc has do-part slot *)
                     NONE -> location[] (* is this what we want? *)
                  else
                     formId.makeUC;
                     (if false and ((formId[]->formSet.isLocal) <> 0) then
                         '' -> location[] 
                      else 
                         (if false then
                             (desc.frag[]).fullName -> stripForm -> location[]
                          else
                             (desc.frag[]).fullName -> location[];
                             (if false then
                                 (if desc.frag.category
                                  // gram.attributesForm then
                                     location[] -> stripForm -> location[]
                                  else
                                     location[] -> stripFile -> location[]
                                 if)
                              else
                                 (if desc.frag.category 
                                  // gram.attributesForm then
                                     location[] -> stripForm -> location[];
                                  else
                                     location[] -> stripFileAndForm -> location[];
                                     desc.frag.root[]->astAsAstIndex -> N;
                                     316 -> trace(#
                                                 do 'location:fragName:' -> xT;
                                                    N[] -> xA
                                                 #);
                                     (N[],true)
                                       -> EH.DescName 
                                       -> location.append
                                 if)
                         if)if)
                     if)
                 if)
             if)
          // gram.unExpanded then
             NONE -> location[]
     if)if);
     316->trace(#
               do 'is: ' -> xT;
                  (if location[]= none then
                      'unknown' -> xT
                   else 
                      (if location.length = 0 then 
                          'local' -> xT
                       else
                          location[] -> xT
                  if)if)#)
  exit location[]
  #);


AddDotnetLocation:
  (# class, location, T: ^Text;
  enter (class[], location[])
  do ''->T[]; 
     (if location[]=NONE then
         (if true 
          // 'object' -> class.equal 
          // '[mscorlib]System.Object' -> class.equal 
             then
          else
             (* Unknown file - put assembly in file with same name as class *)
             'class ' -> T.append;
             (if trace_sig then
                 '/* reference to class ' -> T.puttext; class[]->T.puttext; 
                 ' in unknown file */' -> T.puttext;
             if);
             (if use_dotnet_modules then
                 '[.module ' -> T.append;
                 class[] -> T.append;
                 '.netmodule]' -> T.append;
              else
                 '[' -> T.append;
                 class[] -> T.append;
                 ']' -> T.append;
             if);
         if);
      else
         (if location.length=0 then
             (* local *)
             'class '->T.append;
             (if trace_sig then
                 '/* reference to local class ' -> T.puttext; class[]->T.puttext;  '*/' -> T.puttext;
             if);
          else
             (* Nonlocal, known location *)
             'class ' -> T.append;
             (# e: @diskentry;
                 do location[] -> e.path;
                    e.path.name -> location[];
             #);
             (if trace_sig then
                 '/* reference to class ' -> T.puttext; class[]->T.puttext; 
                 ' in file ' -> T.puttext;
                 location[] -> T.puttext;
                 '*/' -> T.puttext;
             if);
             (if use_dotnet_modules then
                 '[.module ' -> T.append;
                 location[] -> T.append;
                 '.netmodule]' -> T.append;
              else
                 '[' -> T.append;
                 location[] -> T.append;
                 ']' -> T.append;
             if);
         if)
     if);
     class[] -> T.append;
  exit T[]
  #);

Type: 
  (# isRef: < booleanValue;
     isList:< booleanValue;
     elmType:<  integerValue;
     
     assembly_referred:
       (* an external assembly was referred (dotnet).
        * remember this and tell backend a apropriate time.
        *)
       (# 
          assembly: ^text;
       enter assembly[]
       do 'assembly_referred: '->puttext;
          assembly[] -> puttext;
          '. NYI' -> putline;
       #);
     asText:<
       (# T: ^text
       do inner;
          187->ctrace(# 
                     do 'Signature:'  ->xT; T[] -> xT;
                        ' location:'->xT;
                        (if location[] = none then
                            'unknown' -> xT
                         else
                            location[] -> xT
                     if)#);
          (# S: ^text
          do (if location[] <> none then
                 'location:' -> (location.copy).prepend -> S[];
                 ':'->S.put
              else
                 'location:none: ' -> S[];
             if);
             (if T[] <> none then
                 T[] -> S.append;
             if);
             S -> mch.comment
          #)
       exit T[]
       #);
     location: ^text
  do inner
  exit this(Type)[]
  #);
int32Value: Type 
  (# elmType::(#do 1 -> value #);
     asText::
       (#
       do (if isJava then 'I'->T[] else 'int32'->T[] if)
       #)
  #);
charValue: Type 
  (# elmType::(#do 2 -> value #);
     asText::
       (#
       do (if isJava then 'C'->T[] else 'char'->T[] if)
       #)
  #);

Void: Type
  (# elmType::(# do 10 -> value #);
     asText:: 
       (#
       do (if isJava then 'V'->T[] else 'void'->T[] if)
       #)
  #);

Reference: Type 
  (# class: ^text;
     isRef:: TrueValue;
     elmType:: (# do 11 -> value #);
     
     asText::
       (# 
       do (if location[] <> none then (* only needd for .NET *)
              location[] -> mch.import
          if);

          (if isJava then
              'L' -> T[]; class[] -> T.append; ';'->T.put;
           else 
              (class[], location[]) -> AddDotnetLocation -> T[];
          if);
          (if stest then 
              187->trace(#
                        do 'descLocation:: '->xT; location[] -> xT
                        #)
          if);
         
       #)
  enter class[]
  do (if 'object' -> class.equalNCS then
         (if true
          // isJava then
             'java/lang/Object' -> class[]
          // isDotNet then
             'object' -> class[]
          else
             'Unknown_platform.Object' -> class[]
         if);
     if);
  #);
Array: Type
  (# element: ^Type;
     isRef:: trueValue;
     elmType:: (# do 12 -> value #);
     asText::
       (#
       do (if isJava then 
              '[' -> T[];
              element.asText -> T.append; 
           else (* FIXME *)
              element.asText -> T[]; '[]' -> T.append
          if)
       #)
  enter element[]
  #);
mkListSignature:
  (# T:  ^type; L:@ListSignature
  enter T[]
  do T[] -> L.append
  exit L[]
  #);
ListSignature: Type
  (# L: [3] ^Type; top: @integer;
     isList::trueValue;
     append:
       (# T: ^Type; TL: ^ListSignature
       enter T[]
       do (if T.isList then
              T[] -> TL[];
              TL.scan(# do current[] -> append #)
           else
              (if (top+1->top) > L.range then
                  L.range -> L.extend
              if);              
              T[]-> L[top][]
          if)
       #);
     scan:
       (# current: ^Type
       do (for i: top repeat
               L[i][] -> current[];
               INNER
          for)
       #);
     asText::
       (# 
       do &text[] -> T[];
          (if isJava then
              scan(#do current.asText -> T.append #);
           else
              scan
              (# addSep: @boolean;
              do (if addSep then ','->T.put if);
                 current.asText -> T.append;
                 true -> addSep;
              #);
          if)
       #)
  #);
BetaTextSignatureId: (# exit 1 #);
JavaStringSignatureId: (# exit 2 #);

specialSignature: Type
  (# sigId: @integer;
     astext::
       (#
       do &text[] -> T[];
          (if isJava then
              (if sigId
               // BetaTextSignatureId then
                  'Ltext;' -> T.append
               // JavaStringSignatureId then
                  'Ljava/lang/String;' -> T.append
               else
                  'LUnknowSpecialSignature;' -> T.append
              if)
           else
              (if sigId
               // BetaTextSignatureId then
                  'text' -> T.append
               // JavaStringSignatureId then
                  'string' -> T.append
               else
                  '>>>>>UnknowSpecialSignature' -> T.append
              if)
          if)
       #)
  enter sigId
  #);

valueSignature:
  (# desc: ^ASTindex; sig: ^Type
  enter desc[]
  do (if true 
      // desc -> sematt.integerDesc.equal then
         int32Value -> sig[]
      // desc -> sematt.charDesc.equal then
         charValue -> sig[]
      else
         int32Value -> sig[]
     if)
  exit sig[]
  #);

mkSignature:
  (# desc: ^ASTindex; sig: ^Type; tsig: ^text;
     EH: @evalHandler
  enter desc[]
  do (if (desc -> sematt.descKind) = sematt.standardKind then
         (desc[] -> valueSignature -> sig[]).astext -> tsig[]
      else
         ((desc[],true) -> EH.descName -> Reference).asText -> tsig[];
         (*desc[] -> descLocation -> tsig.location[]*)
     if);
     (if isJava then
         (* hack *)
         (if tsig.length > 2 then
             (2,tsig.length-1) -> tsig.sub -> tsig[]
         if)
     if)
  exit tsig[]
  #);
mkArraySignature:
  (* we should simplify mkSignature and this one *)
  (# desc: ^ASTindex; tsig: ^text;
     EH: @evalHandler
  enter desc[]
  do (if (desc -> sematt.descKind) = sematt.standardKind then
         (desc[] -> valueSignature ->array).astext -> tsig[]
      else
         ((desc[],true) -> EH.descName -> Reference->array).asText -> tsig[]
     if)
  exit tsig[]
  #);
ISignature:
  (# asText:<
       (# T: ^text
       do inner
       exit T[]
       #)
  do inner
  exit this(ISignature)[]
  #);
Signature: ISignature
  (* Obs! ISignature has recently been introduced as a superclass
   * of Signature to handle requirements for distinguishing
   * between signatures for method-declarations, method-calls,
   * instance creation, superclasses, etc. Currently Signature
   * covers method-calls and method-declarations as described below:
   * A signature may have the following two abstract forms:
   * 1. Method def :           method, input arguments, return type;
   * 2. Method call: receiver, method, input arguments, return type
   * As can be seen the difference is the receiver present in
   * the method call
   *)
  (# receiver: ^text;         (* an optional receiver *)
     isStatic: @boolean;
     method: ^text;           (* method name *)
     NNsig: ^ListSignature;   (* input arguments *)
     XXsig: ^Type;            (* return type *)
     
     
     thisDesc: @ASTindex;      (* descriptor of this method (pattern) *)
     location: ^text;          (* fragment group (file) where thisDesc is 
                                * declared - see descLocation above
                                *)
     thisChain: ^DH.superChain;(* desc chain of def- or call-location *)
     
     setDesc:
       (# EV: ^ASTindex; MN,vKind: @integer
       enter EV[]
       do (thisSuperChain,EV) 
            -> DH.theDesc
            -> (thisDesc,MN,thisChain[],vKind);
          thisDesc[] -> descLocation -> location[];
       #);
     markStatic: (# do true -> isStatic #);
     addReceiver: (# enter receiver[] #);     
     addMethod: (# enter method[] #);
     
     noOfEnterArgs: 
       (# N: @integer 
       do (if NNsig[] <> none then NNsig.top -> N if) 
       exit N 
       #);
     enterSig:
       (# noNsig: @boolean;
          T: @text
       enter noNsig
       do '('->T;
          (if not NoNsig then 
              NNsig.asText -> T.append;
          if);
          ')'->T.put;
       exit T[]
       #);
     exitSig:
       (# noXsig: @boolean; T: ^text
       enter noXsig
       do (if noXsig then voidExitSig -> T[] else XXsig.asText -> T[] if)
       exit T[]
       #);
     voidExitSig: 
       (# T: @text 
       do (if isJava then 'V' -> T else 'void'->T if);
       exit T[]
       #);
     asText::
       (* producec a textual representation of this signature *)
       (# noNsig,noXsig: @boolean;
       enter(noNsig,noXsig)          
       do (if isJava then
              (if receiver[] <> NONE then
                  (* method call signature *)
                  receiver[] -> T[];
                  '/' -> T.put
               else
                  &text[] -> T[];
                  (if isStatic then
                      'static ' -> T.append
                  if)
              if);
              (if method[] <> none then
                  method.copy -> T.append
               else
                  '\n*** method is none ' -> putline
              if);
              noNsig-> enterSig -> T.append;
              noXsig -> exitSig -> T.append;
              (# S: ^text
              do (if location[] <> none then
                     'location: ' -> (location.copy).prepend -> S[];
                     ': ' -> S.append
                  else
                     'location:none: ' -> S[]
                 if);
                 T[] -> S.append;
                 S->mch.comment
              #)
           else
              '' -> T[];
              (if isStatic then
                  'static ' -> T.append
              if);
              noXsig -> exitSig -> T.append;
              ' '->T.append;
              (if receiver[] <> none then
                  (* method call signature *)
                  (receiver[],location[]) -> AddDotnetLocation  -> T.append;
                  '::' -> T.append
              if);
              (if method[] <> none then
                  '\'' -> T.put; (* Quote to avoid clash with IL 
                                  * reserved words, e.g. add *)
                  method.copy -> T.append;
                  '\'' -> T.put;
               else
                  '\n*** method is none ' -> putline
              if);
              noNsig -> enterSig -> T.append
          if);
          187->ctrace(# 
                     do 'Signature:'  ->xT; T[] -> xT;
                        ' location:'->xT;
                        (if location[] = none then
                            'unknown' -> xT
                         else
                            location[] -> xT
                     if)#)
       #);

     noEnter: (# do ListSignature -> NNsig[] #);
     setEnter: (# enter NNsig[] #);
     addEnter:
       (# EH: @EvalHandler;
          nScan: @ | EH.scanNAdr;   
          nD: ^sematt.AttDesc; 
          theDesc: ^ASTindex;
          more: @boolean;
          sig: ^reference
       enter theDesc[]
       do 313->trace(#
                    do 'addEnter:'->xT; theDesc[] -> xA
                    #);
          ListSignature -> NNsig[];
          (if thisChain[] <> none then
              (if not (theDesc->thisDesc.equal) then 
                  'addEnter:desc not equal'->putline
              if);
              313->trace(#
                        do 'addEnter:theDesc(from enter):'->xT;
                           theDesc[]->xA; xN;
                           'thisDesc( for setDesc): ' -> xT;
                           thisDesc[] -> xA;
                           (if thisChain[] <> none then
                               thisChain
                           if) 
                        #);
              (if isStatic then (* should be origin of thisDesc *)
                  (# org: ^ASTindex
                  do thisDesc[] -> sematt.descOrigin -> org[];
                     (if org.isNull then
                         'object' -> reference -> sig[]
                      else
                         (org[] ,true)
                           -> EH.descName 
                           -> reference 
                           -> sig[]
                     if);
                     org[] -> descLocation -> sig.location[];
                     sig[] -> NNsig.append;
                  #)
              if);              
              (thisDesc[],gen.thisRegAdr,0,thisChain[],true) -> nScan -> more;
           else
              (theDesc[],gen.thisRegAdr,0,thisSuperChain,true) -> nScan -> more;
          if);
          Loop:
            (if more then
                (nScan.thisEv[],theDesc[],true) -> getAttSig -> NNsig.append;
                313->trace(#do 'Nsig: '->xt; NNsig.asText -> xT #);
                nScan -> more;
                restart Loop
            if);
          313->trace(#do 'enterNsig: '->xT; NNsig.asText -> xT #);
       #);
     scanEnter:
       (# current: ^type; isRef,doInner,skip: @boolean
       do NNsig.scan
          (#
          do current[] -> this(scanEnter).current[];
             current.isRef -> isRef; 
             INNER scanEnter
          #)
       #);
     exitVoid: 
       (# 
       do setVoidXsig
       #);
     setVoidXsig: 
       (#
       do Void -> xxSig[]; 
       #);
     exitRef:
       (# desc: ^ASTindex;
          EH: @evalHandler
       enter desc[]
       do setVoidXsig;
          (desc[],true) -> EH.descName -> Reference -> XXsig[];
          desc[] -> descLocation -> XXsig.location[];
       #);
     setExit: (# enter XXsig[] #);
     addExit:
       (# EH: @EvalHandler;
          xScan: @ | EH.scanXadr;
          exitP: ^ASTindex;    
          more: @boolean
       enter exitP[]
       do 313->trace(#
                    do 'Signature:addExit:'->xT; xN;
                       thisDesc[]->xA; xN;
                       (if thisChain[] <> none then
                           thisChain
                       if)
                    #);
          
          setVoidXsig;

          (if thisChain[] <> none then
              (thisDesc[],gen.thisRegAdr,0,thisChain[]) 
                -> xScan 
                -> more;
              (if not more then exitVoid; leave addExit if);
              loop:
                (if more then
                    (xScan.thisEv[]->exitVal[],thisDesc[],false) 
                      -> getAttSig 
                      -> XXsig[];
                    xScan -> more;
                    (if more then
                        '\n***OBS! exit-part has more than one element'
                          ->putline
                    if);
                    restart loop
                if)
           else
              '\n***OBS. thisChain is none '->putline;
              (if (thisDesc[](*exitP[]*)->theGen.scanXarg -> exitVal[]) <> NONE then
                  (exitVal[],thisDesc[],false) -> theGen.getAttSig -> XXsig[];
          if)if);
          (if XXsig.isRef then
              2 -> exitId
           else
              1 -> exitId
          if);
       #);
     exitVal: ^ASTindex;
     exitId: @integer (* dirty *)
  #);
classSignature: ISignature
  (* used for instance generation in newInstance;
   * OBS! className should be eliminated as enter param
   * since it can be computed from desc; hwoever, do
   * check all call-sites carefully before doing this
   *)
  (# desc: ^ASTindex;  (* descriptor for className *)
     className         (* perhaps unify with receiver in Signature?*)
     ,location : ^text;(* form location of class *) 
     setClass: (# enter className[] #);
     asText::
       (#
       do (if isJava then 
              className[] -> T[]
           else
              (className[],location[]) -> AddDotnetLocation -> T[];
              (if trace_sig then
                  '/*classsignature*/' -> T.append;
              if);
          if)
       #)
  enter(desc[],className[])
  do (if not (desc[] = none) and not desc.isNull then
         desc[] -> descLocation -> location[];
     if);
     311->trace(#
               do 'classSignature: ' -> xT; className[] -> xT;
                  ' in: ' -> xT; 
                  (if location[] = none then
                      'UnKnown'->xT
                   else
                      location[] -> xT
                  if)
               #);          
  #);
superSignature: ISignature
  (* use for super class name *)
  (# className: ^text; (* perhaps unify with receiver in Signature?*)
     setClass: (# enter className[] #);
     asText::
       (#
       do (if isJava then 
              className[] -> T[]
           else
              className[] -> T[]
          if)
       #)
  enter className[]
  #);
scanNargs:
  (# EH: @EvalHandler;
     nScan: @ | EH.scanNAdr;   
     nD: ^sematt.AttDesc; 
     theDesc: ^ASTindex;
     more: @boolean;
     xSig: ^ListSignature
  enter theDesc[]
  do (theDesc[],gen.thisRegAdr,0,ThisSuperChain,true) -> nScan -> more;
     ListSignature -> xSig[];
     Loop:
       (if more then
           313->trace(#
                     do 'scanNargs:elm:'->xT;
                        nScan.thisEv[]->xA
                     #);
           (nScan.thisEv[],theDesc[],true) -> getAttSig -> xSig.append;
           313->trace(#do 'sig: '->xt; xSig.asText -> xT #);
           nScan -> more;
           restart Loop
       if)
  exit xSig[]
  #);

ScanXarg:
  (# theDesc,exitP: ^ASTindex;
     EH: @evalHandler;
     xScan: @ | EH.scanXAdr;
     ex: ^ASTindex;
     more: @boolean
  enter theDesc[] (*exitP[]*)
  do (theDesc[],gen.thisRegAdr,0,theDesc -> DH.newSingle) -> xScan -> more;
     (if true then
         (if more then
             &ASTindex[] -> ex[];
             xScan.thisEv -> ex;
             xScan -> more;
             (if more then
                 '\nScanXarg: more than one exit element' -> putline;
             if)
         if)
      else
         (if exitP.label <> gram.empty then
             &ASTindex[] -> ex[];
             exitP.son -> ex; (* check that ONLY one exit elm *)          
         if)
     if)
  exit ex[]
  #);
getAttSig:
  (# EV: ^ASTindex;
     nD: ^sematt.AttDesc; EH: @EvalHandler;
     theDesc: ^ASTindex;
     desc: @ASTindex; 
     MN,isVirtual: @integer;
     EVchain: ^DH.superChain;
     xSig: ^Type;
     referenceSignature: (* unify with dynamicItem case in do-part below*)
       (# EV: ^ASTindex;
          sig: ^Type
       enter EV[]
       do EV[] -> sematt.AttDesc -> nD[];
          (*nD.display;*)
          (if nD.spec.label = gram.dynamicItem then
              (theDesc->DH.newSingle,nD.apl)
                -> DH.theDesc
                -> (desc,MN,EVchain[],isVirtual);
              (if desc.label = gram.objectDescriptor then
                  (desc[] ,true)
                    -> EH.descName
                    -> Reference 
                    -> sig[];  
                  desc[] -> descLocation -> sig.location[];
               else 
                  ' ***??? not descriptor ' -> putline;
                  '?notDescriptor?'->Reference -> sig[];
              if)
           else
              '?notDynamicItem?'->Reference -> sig[];
          if);
       exit sig[]
       #);
     isEnter: @boolean
  enter(EV[],theDesc[],isEnter)
  do 313->trace(#
               do 'getAttSig:'->xT;
                  EV[] -> xA;
                  ev.label -> xI;
                  ev.label -> sematt.evalClass -> xI
               #);
     (if EV.label
      // gram.insertedItem  then
         (# den: @ASTindex;
         do EV.son -> den;
            (if den.label = gram.objectDescriptor then                
                den[] -> scanNargs -> xSig[];
                313->trace(#do 'getAttSig:inserted:'->xT;  xSig.asText->xT#)
             else
                'unknownInsertedItem;'-> Reference -> xSig[]                
         if)#)
         (* // gram.objectDenotation then
          'LunknownObjectDenotation;'->sig[]*)
      // gram.objectReference 
      // gram.structureReference then
         EV[] -> referenceSignature -> xSig[];         
      // gram.thisObject then
         (# AD: @ASTindex
         do EV.son -> AD;
            AD.dclRef -> AD;
            AD.getText -> Reference -> xSig[]
         #)
      // gram.assignmentEvaluation then
         (* preliminary *)
         (if not common.switch[188] then
             '\nOBS! Incomplete signature of assignment' -> putline;
         if);
         sematt.integerDesc[] -> valueSignature -> xSig[]
      else
         (if (EV.label -> sematt.evalClass) = sematt.evalClass.binOp then
             int32Value -> xSig[]
          else
             EV[] -> sematt.AttDesc -> nD[];
             (*nD.display;*)

             (if nD.kind
              // sematt.standardKind then
                 (if nD.isRep then
                     nD.desc[] -> valueSignature -> Array -> xSig[]
                  else
                     nD.desc[] -> valueSignature -> xSig[]
                 if)
              // sematt.generalKind 
              // sematt.classKind then
                 (if isEnter then
                     nD.desc[] -> scanNargs -> xSig[] (*sig[]*)
                  else
                     (# xEV: ^ASTindex
                     do nD.desc[] -> scanXarg -> xEV[];
                        (* is thisDesc correct here? *)
                        (xEV[],thisDesc[],false) -> theGen.getAttSig -> Xsig[];
                     #)
                 if)
              else
                 (* don't work if virtual - we should get generalKind
                  * but ...
                  *)
                 (if nD.spec.label = gram.dynamicItem then
                     (theDesc->DH.newSingle,nD.apl)
                       -> DH.theDesc
                       -> (desc,MN,EVchain[],isVirtual);
                     (if desc.label = gram.objectDescriptor then
                         (desc[],true)
                           -> EH.descName
                           -> Reference 
                           -> xsig[];
                         desc[] -> descLocation -> xsig.location[]
                      else 
                         ' ***??? not descriptor ' -> putline;
                         '?notDescriptor?'->Reference -> xSig[];
                     if)
                  else
                     '?notDynamicItem?'->Reference -> xSig[];
                 if);
     if)if)if);
     313->trace(#do 'signature:addExit:'->xT; xSig.asText -> xT #)
  exit xsig[]
  #);
