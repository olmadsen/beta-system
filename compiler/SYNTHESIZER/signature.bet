ORIGIN 'genlib';
INCLUDE 'auxlib';
BODY 'signaturebody'
---theGenLib:attributes---
BetaObject:
  (# exit 'BetaObject' #);
use_dotnet_modules: 
  (# exit false #);
trace_sig:
  (# exit false #);

defaultSuperName:
  (# superName: ^text
  do (if common.switch[320] then
         'BetaObject' -> superName[]
      else
         (if true
          // common.targetMachineId = common.javabc then
             'java/lang/Object'->supername[];
          // common.targetMachineId = common.dotnet then
             '[mscorlib]System.Object'->supername[]; (*'/*1*/'->supername.append;*)
             (*'object' -> supername[];*)
          else
             'Unknown_platform.Object' -> supername[];
         if);
     if)
  exit superName[]
  #);
platformSuperName:
  (# superName: ^text
  do (if true
      // common.targetMachineId = common.javabc then
         'java/lang/Object'->supername[];
      // common.targetMachineId = common.dotnet then
         '[mscorlib]System.Object'->supername[];
         (*'/*3*/'->supername.append;*)
      else
         'Unknown_platform.Object' -> supername[];
     if);
  exit superName[]
  #);
platFormSuperSignature:
  (# sig: @text
  do (if isJava then
         'L' -> sig;
         platformSuperName -> sig.append;
         ';' -> sig.put
      else
         platformSuperName -> sig.append
     if)
  exit sig[]
  #);

descLocation:
  (* Return the fragmentgroup (file location) of desc
   * 1.  location = ''    desc is in this group
   * 2.  location = 'foo' desc is declared in 'foo'
   * 3.  location = none  desc is slot and location
   *                          of the form for the slot
   *                          is not known. The slot is
   *                          a descriptor- doPart or 
   *                          mainpart-slot
   * Part of the code here is copied form mkEntryPoint;
   * this should be unified.
   *)
  (# desc: ^ASTindex; location: ^text;
     N: @ASTindex;
     formId: ^text; descNo: @integer;
     findSlashDash:
       (# N: ^text; pos,slashPos,dashPos: @integer
       enter N[] (* N= '/users/smith/.../foo-formName' *)
       do N.scanAll(#
                   do pos+1->pos;
                      (if ch = '-' then pos -> dashPos if);
                      (if ch = '/' then pos -> slashPos if)
                   #);
          (* 0 <= slashPos < dashPos < N.length *)
          inner;
       exit N[]
       #);
     stripForm: findSlashDash
       (# 
       do (if dashPos > 0 then (dashPos,N.length) -> N.delete -> N[] if)
       #);
     stripFile: findSlashDash
       (# 
       do (slashPos+1,dashPos) -> N.delete -> N[]
       #);
     stripFileAndForm: findSlashDash
       (# 
       do (slashPos+1,N.length) -> N.delete -> N[]
       #);
     slotLocation:
       (# d: ^ASTindex; L: ^text
       enter D[]
       do (D[],true) -> EH.descName -> mch.import;
          (* note we deliberately return L[] = none *)
       exit L[]
       #);
     EH: @evalHandler;
     S: ^text
  enter desc[]
  <<SLOT descLocation:doPart>>
  exit location[]
  #);

AddDotnetLocation:
  (# class, location, T, trace: ^Text;
     simple: @boolean;
     add_resolution:
       (# T, resolution: ^text;
       enter (T[], resolution[])
       do (if use_dotnet_modules then
              '[.module \'' -> T.append;
              resolution[] -> T.append;
              '.netmodule\']' -> T.append;
           else
              '[\'' -> T.append;
              resolution[] -> T.append;
              '\']' -> T.append;
          if);
          (* FIXME: This is probably too often *)
          resolution[] -> mch.import;
       #);
     
  enter (class[], location[])
  do 
     (if trace_sig then
         ''->trace[];
         '/*AddDotnetLocation('->trace.append;
         class[]->trace.append;
         ', '->trace.append;
         location[]->trace.append;
         '*/'->trace.puttext;
     if);
     
     ''->T[]; 
     (if true 
      // '' -> class.equal
      // '-' -> class.equal 
      // 'object' -> class.equal 
      // '[mscorlib]System.Object' -> class.equal 
      // 'class [mscorlib]System.Object' -> class.equal 
      // 'bool'     -> class.equal 
      // 'bool '    -> ((1,5)->class.sub).equal
      // 'bool,'    -> ((1,5)->class.sub).equal
      // 'bool[]'   -> ((1,6)->class.sub).equal
      // 'char'     -> class.equal 
      // 'char '    -> ((1,5)->class.sub).equal
      // 'char,'    -> ((1,5)->class.sub).equal
      // 'char[]'   -> ((1,6)->class.sub).equal
      // 'float64'  -> class.equal 
      // 'float64 ' -> ((1,8)->class.sub).equal
      // 'float64,' -> ((1,8)->class.sub).equal
      // 'float64[]'-> ((1,9)->class.sub).equal
      // 'float32'  -> class.equal 
      // 'float32 ' -> ((1,8)->class.sub).equal
      // 'float32,' -> ((1,8)->class.sub).equal
      // 'float32[]'-> ((1,9)->class.sub).equal
      // 'int8'     -> class.equal 
      // 'int8 '    -> ((1,5)->class.sub).equal
      // 'int8,'    -> ((1,5)->class.sub).equal
      // 'int8[]'   -> ((1,6)->class.sub).equal
      // 'int16'    -> class.equal 
      // 'int16 '   -> ((1,6)->class.sub).equal
      // 'int16,'   -> ((1,6)->class.sub).equal
      // 'int16[]'  -> ((1,7)->class.sub).equal
      // 'int32'    -> class.equal 
      // 'int32 '   -> ((1,6)->class.sub).equal
      // 'int32,'   -> ((1,6)->class.sub).equal
      // 'int32[]'  -> ((1,7)->class.sub).equal
      // 'void '    -> ((1,5)->class.sub).equal
         then (* nothing *)
         true -> simple;
      // 'valuetype [' -> ((1,11)->class.sub).equal
      // 'class [' -> ((1,7)->class.sub).equal then
         class[] -> importDotnetLocations;
         true -> simple;
      // '['       -> ((1,1)->class.sub).equal then
         class[] -> importDotnetLocations;
         'class ' -> T.append;
         true -> simple;
      // betaobject -> class.equal then
         'class ' -> T.append;
         (T[], common.betaenv.groupname) -> add_resolution;
      else
         (if location[]=NONE then
             (* Unknown file - put assembly in file with same name as class *)
             'class ' -> T.append;
             (if trace_sig then
                 '/* reference to class ' -> T.puttext; class[]->T.puttext; 
                 ' in unknown file */' -> T.puttext;
             if);
             (T[], class[]) -> add_resolution;
          else
             (if location.length=0 then
                 (* local *)
                 'class '->T.append;
                 (if trace_sig then
                     '/* reference to local class ' -> T.puttext; class[]->T.puttext;  '*/' -> T.puttext;
                 if);
              else
                 (* Nonlocal, known location *)
                 'class ' -> T.append;
                 (if (1->class.inxGet) <> '[' then
                     (# e: @diskentry;
                     do location[] -> e.path;
                        e.path.name -> location[];
                     #);
                     (if trace_sig then
                         '/* reference to class ' -> T.puttext; class[]->T.puttext; 
                         ' in file ' -> T.puttext;
                         location[] -> T.puttext;
                         '*/' -> T.puttext;
                     if);
                     (T[], location[]) -> add_resolution;
                 if)
             if)
         if);
     if);
     (if not simple then (*'/**/'->T.append;*) '\''-> T.append; if);
     class[] -> T.append;
     (if not simple then '\''-> T.append; if);
     (if trace_sig then
         (*trace[] -> screen.putline;*)
         trace[] -> T.append;
     if);
  exit T[]
  #);

Type: 
  (# isRef: < booleanValue;
     isList:< booleanValue;
     elmType:< integerValue;
     theDesc:<
       (# desc: ^ASTindex
       do INNER
       exit desc[]
       #);
     asText:<
       (# T: ^text
       do inner;
          187->ctrace(# 
                     do 'Signature:'  ->xT; T[] -> xT;
                        ' location:'->xT;
                        (if location[] = none then
                            'unknown' -> xT
                         else
                            location[] -> xT
                     if)#);
       exit T[]
       #);
     className:< 
       (* for a reference, the class name is returned;
        * for others the empty text
        *)
       (# value: ^text do &text[] -> value[]; inner exit value[] #);
     location: ^text
  do inner
  exit this(Type)[]
  #);
int32Value: Type 
  (# elmType::(#do 1 -> value #);
     theDesc:: (# do sematt.integerDesc[] -> desc[] #);
     asText::
       (#
       do (if isJava then 'I'->T[] else 'int32'->T[] if)
       #)
  #);

(* FIXME: we need to considered signed/unsiged int8 and int16 
 * For dotnet the names are just prepended 'unsigned '
 *)
int16Value: Type 
  (# elmType::(#do 4 -> value #);
     theDesc:: (# do sematt.integerDesc[] -> desc[] #);
     asText::
       (#
       do (if isJava then 'S'->T[] else 'int16'->T[] if)
       #)
  #);

int8Value: Type 
  (# elmType::(#do 5 -> value #);
     theDesc:: (# do sematt.integerDesc[] -> desc[] #);
     asText::
       (#
       do (if isJava then 'B'->T[] else 'int8'->T[] if)
       #)
  #);

charValue: Type 
  (# elmType::(#do 2 -> value #);
     theDesc:: (# do sematt.charDesc[] -> desc[] #);
     asText::
       (#
       do (if isJava then 'C'->T[] else 'char'->T[] if)
       #)
  #);
boolValue: Type 
  (# elmType::(#do 3 -> value #);
     theDesc:: (# do sematt.boolDesc[] -> desc[] #);
     asText::
       (#
       do (if isJava then 'Z'->T[] else 'bool'->T[] if)
       #)
  #);

realValue: Type 
  (# elmType::(#do 6 -> value #);
     theDesc:: (# do sematt.boolDesc[] -> desc[] #);
     asText::
       (#
       do (if isJava then 'D'->T[] else 'float64'->T[] if)
       #)
  #);
real32Value: Type 
  (# elmType::(#do 7 -> value #);
     theDesc:: (# do sematt.boolDesc[] -> desc[] #);
     asText::
       (#
       do (if isJava then 'F'->T[] else 'float32'->T[] if)
       #)
  #);

Void: Type
  (# elmType::(# do 10 -> value #);
     theDesc:: (# do sematt.integerDesc[] -> desc[] #);
     asText:: 
       (#
       do (if isJava then 'V'->T[] else 'void'->T[] if)
       #)
  #);

Reference: Type 
  (# class: ^text;
     isRef:: TrueValue;
     elmType:: 
       (# 
       do (if isExternalText then 
              13 -> value 
           else 
              (if this(reference).desc->sematt.textDesc.equal then
                  14 -> value 
               else
                  11 -> value 
          if)if) 
       #);
     isExternalClass, isExternalText: @boolean;
     theDesc:: (# do this(reference).desc[] -> desc[] #);
     className:: (# do class[] -> value[] #);
     asText::
       (# 
       do (if location[] <> none then (* only needed for .NET *)
              location[] -> mch.import
          if);

          (if isJava then
              'L' -> T[]; class[] -> T.append; ';'->T.put;
           else 
              (class[], location[]) -> AddDotnetLocation -> T[];
          if);
          (if stest then 
              187->trace(#
                        do 'descLocation:: '->xT; location[] -> xT
                        #)
          if);
         
       #);
     EH: @evalHandler;
     desc: ^ASTindex; 
  enter desc[] (*class[]*)
  do (if (desc[] <> none) and (not desc.isNull) then
         (if (desc -> sematt.descKind) = sematt.externalClassKind then
             desc[] -> getExternalClassName -> class[];
             not (desc[] -> isBETAsubOfExternalClass) -> isExternalClass;
             true -> isExternalText (* we should check that desc
                                     * is in fact an external text/string
                                     * like java/lang/String
                                     *)
          else
             (desc[],true) -> EH.descName -> class[]
         if);
         desc[] -> descLocation -> location[];
         (if isExternalClass then
             NONE -> location[]; (* force default location to be 
                                  * same as class name *)
          else
             desc[] -> descLocation -> location[];
         if);
         (if true
          // 'object' -> class.equalNCS 
          // 'Object' -> class.equalNCS then
             (if true
              // isJava then
                 'java/lang/Object' -> class[]
              // isDotNet then
                 'object' -> class[]
              else
                 'Unknown_platform.Object' -> class[]
             if);
             (* // 'java/lang/String' -> class.equal then*)
             (* we should generalize this in a better way *)
             
         if);
      else
         platformSuperName -> class[]
     if);
  #);
Array: Type
  (# element: ^Type;
     isRef:: trueValue;
     elmType:: (# do 12 -> value #);
     asText::
       (#
       do (if isJava then 
              '[' -> T[];
              element.asText -> T.append; 
           else (* FIXME *)
              element.asText -> T[]; '[]' -> T.append
          if)
       #)
  enter element[]
  #);
mkListSignature:
  (# T:  ^type; L:@ListSignature
  enter T[]
  do (T[],none) -> L.append
  exit L[]
  #);
ListSignature: Type
  (# L,dL: [3] ^Type; top: @integer;
     isList::trueValue;
     clear: (# do 0 -> top #);
     append:
       (# T,dclT: ^Type; TL: ^ListSignature
       enter(T[],dclT[])
       do (if T.isList then
              T[] -> TL[];
              TL.scan(# do (current[],dclCurrent[]) -> append #)
           else
              (if (top+1->top) > L.range then
                  L.range -> L.extend;
                  dL.range -> dL.extend
              if);              
              T[]-> L[top][];
              dclT[]-> dL[top][];
          if)
       #);
     scan:
       (# current,dclCurrent: ^Type
       do (for i: top repeat
               L[i][] -> current[];
               dL[i][] -> dclCurrent[];
               INNER
          for)
       #);
     asText::
       (# 
       do &text[] -> T[];
          (if isJava then
              scan(#do current.asText -> T.append #);
           else
              scan
              (# addSep: @boolean;
              do (if addSep then ','->T.put if);
                 current.asText -> T.append;
                 true -> addSep;
              #);
          if)
       #)
  #);
BetaTextSignatureId: (# exit 1 #);
JavaStringSignatureId: (# exit 2 #);

specialSignature: Type
  (# sigId: @integer;
     astext::
       (#
       do &text[] -> T[];
          (if isJava then
              (if sigId
               // BetaTextSignatureId then
                  'Ltext;' -> T.append
               // JavaStringSignatureId then
                  'Ljava/lang/String;' -> T.append
               else
                  'LUnknowSpecialSignature;' -> T.append
              if)
           else
              (if sigId
               // BetaTextSignatureId then
                  'text' -> T.append
               // JavaStringSignatureId then
                  'string' -> T.append
               else
                  '>>>>>UnknowSpecialSignature' -> T.append
              if)
          if)
       #)
  enter sigId
  #);

valueSignature:
  (# desc: ^ASTindex; sig: ^Type
  enter desc[]
  do (if desc.label = gram.mainPart then
         (failureTrace,'ValueSignature:mainPart') -> stop
     if);
     (if true 
      // desc -> sematt.integerDesc.equal 
      // desc -> sematt.int32Desc.equal then
         int32Value -> sig[]
      // desc -> sematt.charDesc.equal then
         charValue -> sig[]
      // desc -> sematt.boolDesc.equal then
         boolValue -> sig[]
      // desc -> sematt.int16Desc.equal then
         int16Value -> sig[]
      // desc -> sematt.int16uDesc.equal  (* problem here with 'u' *)
      // desc -> sematt.shortDesc.equal then
         (if not common.switch[188] then
             '\nint16u not implemented: converted to int16' -> putline
         if);
         int16Value -> sig[]
      // desc -> sematt.int8Desc.equal then
         int8Value -> sig[]         
      // desc -> sematt.int8uDesc.equal then
         (if not common.switch[188] then
             '\nint8u not implemented: converted to int32' -> putline
         if);
         int32Value -> sig[]  
      // desc -> sematt.realDesc.equal then
         realValue -> sig[]         
      // desc -> sematt.real32Desc.equal then
         real32Value -> sig[]    
      // desc -> sematt.int32uDesc.equal then
         (if not common.switch[188] then
             '\nint32u not implemented: converted to int32' -> putline
         if);
         int32Value -> sig[]   
      // desc -> sematt.int64Desc.equal
      // desc -> sematt.int64uDesc.equal then
         (if not common.switch[188] then
             '\nint64/int64u not implemented: converted to int32' -> putline
         if);
         int32Value -> sig[]         
      else
         'valueSignature: falling back on int32value for desc='->screen.puttext;
         desc.index->screen.putint; screen.newline;
         int32Value -> sig[]
     if)
  exit sig[]
  #);
mkSig:
  (# desc: ^ASTindex; 
     sig: ^Type
  enter desc[]
  do (* should be made nicer *)
     (if (desc[] <> none) and not desc.isNull then
         (if (desc -> sematt.descKind) = sematt.standardKind then
             desc[] -> valueSignature -> sig[]
          else  
             desc[] -> reference -> sig[]
         if)
      else
         desc[] -> reference -> sig[];
     if)
  exit sig[]
  #);

mkSignature:
  (# desc: ^ASTindex; sig: ^Type; tsig: ^text; 
     EH: @evalHandler
  enter desc[]
  do (if desc.label = gram.mainPart then
         (# D: @ASTindex
         do desc.father -> D;
            (if D.isNull then
                desc.xOrigin -> D;
                D.slotOrigin -> D;
            if);
            D[] -> desc[]
         #)
      if);

     (if (desc -> sematt.descKind) = sematt.standardKind then
         (desc[] -> valueSignature -> sig[]).astext -> tsig[]
      else  
         desc[] -> reference -> sig[];
         sig.asText -> tsig[];
     if);
     (if false and isJava then
         (* hack *)
         (if tsig.length > 2 then
             (2,tsig.length-1) -> tsig.sub -> tsig[]
         if)
     if)
  exit tsig[]
  #);
mkArraySig:
  (* we should simplify mkSignature and this one *)
  (# desc: ^ASTindex; sig: ^type;
     EH: @evalHandler
  enter desc[]
  do (if (desc -> sematt.descKind) = sematt.standardKind then
         desc[] -> valueSignature ->array ->  sig[]
      else
         (if true then
             desc[] -> Reference -> array -> sig[]
          else(*
             (desc[],true) -> EH.descName -> Reference -> array -> sig[]*)
         if)
     if)
  exit sig[]
  #);
mkArraySignature:
  (* we should simplify mkSignature and this one *)
  (# desc: ^ASTindex; tsig: ^text;
     EH: @evalHandler
  enter desc[]
  do (if (desc -> sematt.descKind) = sematt.standardKind then
         (desc[] -> valueSignature ->array).astext -> tsig[]
      else
         (desc[] -> reference -> array).asText -> tSig[];
         (*((desc[],true) -> EH.descName -> Reference->array).asText -> tsig[]*)
     if)
  exit tsig[]
  #);
ISignature:
  (# asText:<
       (# T: ^text
       do inner;
          (if isJava and common.switch[189] then
              (* to be able to debug locations using java bytecode *)
              '[\'' -> T.append;
              (if location[] = none then 
                  (* to be able to debug locations using java bytecode *)
                  '-unknown-' -> T.append
               else
                  location[] -> T.append;
              if);
              '\']' -> T.append
          if)
       exit T[]
       #);
     location: ^text;
     isMultiValExit: @boolean; (* more than oneelement in exit-list *)
  do inner;
  exit this(ISignature)[]
  #);
Signature: ISignature
  (* Obs! ISignature has recently been introduced as a superclass
   * of Signature to handle requirements for distinguishing
   * between signatures for method-declarations, method-calls,
   * instance creation, superclasses, etc. Currently Signature
   * covers method-calls and method-declarations as described below:
   * A signature may have the following two abstract forms:
   * 1. Method def :           method, input arguments, return type;
   * 2. Method call: receiver, method, input arguments, return type
   * As can be seen the difference is the receiver present in
   * the method call
   *)
  (# receiver: ^text;         (* an optional receiver *)
     receiverDesc: ^ASTindex; (* descriptor for receiver *)
     isStatic: @boolean;
     isPtnClassMethod: @boolean; (* the method is a PtnClassMethod:
                                  * a method which instatiates and
                                  * return an instance of the pattern
                                  *)
     method: ^text;           (* method name *)
     NNsig: ^ListSignature;   (* input arguments *)
     XXsig                    (* return type at point of declaration *)
     ,aplSig: ^Type;          (* return type at point of application *) 
     XXLsig: ^ListSignature;  (* if isMultiValExit then the list of 
                               * exit types similar to NNsig
                               *)
     
     
     thisMethodDesc: @ASTindex;(* descriptor of this method (pattern) *)
     location: ^text;          (* fragment group (file) where thisMethodDesc is 
                                * declared - see descLocation above
                                *)
     thisChain: ^DH.superChain;(* desc chain of def- or call-location *)
     
     setMethodDesc:
       (# EV: ^ASTindex; MN,vKind: @integer;
          chain,c: ^DH.superChain;
          addToChain: @boolean
       enter(EV[],chain[],addToChain)
       <<SLOT byteCode_signature:doPart>>
       #);
     markStatic: (# do true -> isStatic #);
     markAsPtnClassMethod: (# do true -> isPtnClassMethod #);
     addReceiver: 
       (* only receiverDesc should be enter arg;
        * at all call sites, receiver is computed;
        * this can be done here
        *)
       (# isExternalClass: @boolean;
       enter(receiver[],receiverDesc[])
       do (if (receiverDesc -> sematt.descKind) 
              = sematt.externalClassKind then
              receiverDesc[] -> getExternalClassName -> receiver[];
              not (receiverDesc[] -> isBETAsubOfExternalClass) -> isExternalClass;
          if);
          (if isExternalClass then
              NONE -> location[]; (* force default location to be same as class name *)
           else
              (if (receiverDesc[] -> descLocation -> location[]) <> none then
                  location[] -> mch.import
              if)
          if);
       #);     
     addMethod: (# enter method[] #);
     
     noOfEnterArgs: 
       (# N: @integer 
       do (if NNsig[] <> none then NNsig.top -> N if) 
       exit N 
       #);
     enterSig:
       (# noNsig: @boolean;
          T: @text
       enter noNsig
       do '('->T;
          (if not NoNsig then 
              NNsig.asText -> T.append;
          if);
          ')'->T.put;
       exit T[]
       #);
     exitSig:
       (# noXsig: @boolean; T: ^text
       enter noXsig
       do (if noXsig then voidExitSig -> T[] else XXsig.asText -> T[] if)
       exit T[]
       #);
     voidExitSig: 
       (# T: @text 
       do (if isJava then 'V' -> T else 'void'->T if);
       exit T[]
       #);
     hasNoEnterAndExitThis: booleanValue
       (* A pattern P with no enter-part and with exit this(P)[]
        * will get the same signature as the new-P method generated
        * for instantiating a P. To avoid this a '$' is appended
        * to the method-name (P).
        * This is also the case for patterns with no enter-part
        * and with a list of exit values, in which case this(p)[]
        * is returned.
        *)
       (#
       <<SLOT signature_hasNoEnterAndExitThis:dopart>>
       #);
     asText::
       (* producec a textual representation of this signature *)
       (# noNsig,noXsig: @boolean;
       enter(noNsig,noXsig)          
       <<SLOT signature_astext:doPart>>
       #);
     noEnter: (# do ListSignature -> NNsig[] #);
     setEnter: (# enter NNsig[] #);
     addEnter:
       (# EH: @EvalHandler;
          nScan: @ | EH.scanNAdr;   
          nD: ^sematt.AttDesc; 
          theDesc: ^ASTindex;
          more: @boolean;
          sig: ^reference
       enter theDesc[]
       <<SLOT signature_addEnter:doPart>>
       #);
     scanEnter:
       (# current: ^type; isRef: @boolean
       do NNsig.scan
          (#
          do current[] -> this(scanEnter).current[];
             current.isRef -> isRef; 
             INNER scanEnter
          #)
       #);
     scanExit:
       (# current: ^type
       do (if isMultiValExit then
              XXLsig.scan
              (#
              do current[] -> this(scanExit).current[];
                 INNER scanExit
              #)
           else
              XXsig[] -> current[];
              INNER
          if)
       #);
          
     exitVoid: 
       (# 
       do setVoidXsig
       #);
     setVoidXsig: 
       (#
       do Void -> xxSig[]; 
       #);
     exitRef:
       (# desc: ^ASTindex;
          EH: @evalHandler
       enter desc[]
       do setVoidXsig;
          (if desc[] = none then thisMethodDesc[] -> desc[] if);
          desc[] -> Reference -> XXsig[];
          (*(desc[],true) -> EH.descName -> Reference -> XXsig[];*)
          desc[] -> descLocation -> XXsig.location[];
       #);
     setExit: (# enter XXsig[] #);
     addExit:
       (# EH: @EvalHandler;
          xScan: @ | EH.scanXadr;
          exitP: ^ASTindex;    
          more: @boolean
       enter exitP[]
       <<SLOT signature_addExit:doPart>>
       #);

     exitVal: ^ASTindex;
     exitId: @integer (* dirty *)   
  #);
fieldSignature: Isignature
  (# desc: ^AStindex;
     fieldSig: ^text;
     isExternalClass: @boolean;
     asText::
       (# S: ^text
       do (if isJava then
              fieldSig[] -> T[]
           else
              (fieldSig[],location[]) -> AddDotnetLocation -> T[];
       if)#);
     sig: ^type;
     EH: @evalHandler
  enter desc[]
  do (if (desc -> sematt.descKind) = sematt.standardKind then
         (desc[] -> valueSignature -> sig[]).astext -> fieldSig[]
      else         
         (if (desc -> sematt.descKind) = sematt.externalClassKind then
             desc[] -> getExternalClassName -> fieldSig[];
             not (desc[] -> isBETAsubOfExternalClass) -> isExternalClass;
          else         
             (desc[],true) -> EH.descName -> fieldSig[];
         if);
         (if isExternalClass then
             NONE -> location[]; (* force default location to be same as class name *)
          else
             desc[] -> descLocation -> location[];
         if);
     if);
     313->trace(#do 'fieldSignature: '->xT; fieldSig[] -> xT; xN;
                  desc[] -> xA; xN; 'location: '->xT;
                  (if location[] <> none then location[] -> xT
               if)#);
     (* (if not (desc[] = none) and not desc.isNull then
         desc[] -> descLocation -> location[];
     if);*)
     (if location[] <> none then
         location[] -> mch.import
     if)
  #);
     
classSignature: ISignature
  (* used for instance generation in newInstance;
   * OBS! className should be eliminated as enter param
   * since it can be computed from desc; however, do
   * check all call-sites carefully before doing this
   *)
  (# desc: ^ASTindex;  (* descriptor for className *)
     className         (* perhaps unify with receiver in Signature?*)
     ,location : ^text;(* form location of class *) 
     setClass: (# enter className[] #);
     asText::
       (#
       do (if isJava then 
              className[] -> T[];
           else
              (className[],location[]) -> AddDotnetLocation -> T[];
              (if trace_sig then
                  '/*classsignature*/' -> T.append;
              if);
          if)
       #);
     isExternalClass: @boolean;
  enter(desc[],className[])
  do (if not (desc[] = none) and not desc.isNull then
         (if (desc -> sematt.descKind) = sematt.externalClassKind then
             desc[] -> getExternalClassName -> className[];
             not (desc[] -> isBETAsubOfExternalClass) -> isExternalClass;
         if);
         
         (if isExternalClass then
             NONE -> location[]; (* force default location to be same as class name *)
          else
             (if (desc[] -> descLocation -> location[]) <> none then
                 location[] -> mch.import
             if)
         if);
     if);
     313->trace(#
               do 'classSignature: ' -> xT; className[] -> xT;
                  ' in: ' -> xT; 
                  (if location[] = none then
                      'UnKnown'->xT
                   else
                      location[] -> xT
                  if)
               #);          
  #);
constructorSignature: ISignature
  (* signature of class constructor *)
  (# originDesc: ^ASTindex;
     originName,locations: ^text;
     sig: @ListSignature;
     addConstructorDesc:
       (# consDesc: ^ASTindex; 
          chain: ^DH.superChain;
          cSig: @signature;
          isDefaultConstructor: @boolean
       enter(consDesc[],isDefaultConstructor,chain[])
       do 313->trace(# c: ^DH.superChain;
                    do 'addConstructorDesc:'->xT; xN;
                       consDesc[] -> xA; xN;
                       consDesc->DH.newSingle -> c[]; c
                    #);
          (consDesc[],consDesc->DH.newSingle,false) 
            -> cSig.setMethodDesc;
          consDesc[] -> cSig.addEnter;
          (if isDefaultConstructor then sig.clear if);
          (cSig.NNsig[],none) -> sig.append
       #);
     asText::
       (#
       do (if isJava then
              (if '-' -> originName.equal then
                  '()V' -> T[]
               else
                  '(' -> T[];
                  sig.astext -> T.append;
                  ')V' -> T.append                  
              if)              
           else
              (if '-' -> originName.equal then
                  '' -> T[]
               else
                  (sig.asText,location[]) -> AddDotnetLocation -> T[];
              if)                  
          if)
       #);
     EH: @evalHandler
  enter(originDesc[],originName[]) (* eliminate originName[] as argument;
                                    * however, '-' must be handled in
                                    * some way
                                    *)
  <<SLOT signature_constructorSignature:doPart>>
  #);
superSignature: ISignature
  (* use for super class name *)
  (# desc: ^ASTindex;
     className: ^text; (* perhaps unify with receiver in Signature?*)
     setClass: (# enter className[] #);
     asText::
       (#
       do (if isJava then 
              className[] -> T[]
           else
              (className[],location[]) -> AddDotnetLocation -> T[];
          if)
       #)
  enter(desc[],className[])
  do (if desc[] <> none then
         (if (desc[] -> descLocation -> location[]) <> none then
             location[] -> mch.import
     if)if)     
  #);
scanNargs:
  (# EH: @EvalHandler;
     nScan: @ | EH.scanNAdr;   
     nD: ^sematt.AttDesc; 
     theDesc: ^ASTindex;
     more: @boolean;
     xSig: ^ListSignature;
     chain: ^DH.superChain
  enter(theDesc[],chain[])
  do (theDesc[],gen.thisRegAdr,0,chain[](*ThisSuperChain*),true) -> nScan -> more;
     ListSignature -> xSig[];
     Loop:
       (if more then
           313->trace(#
                     do 'scanNargs:elm:'->xT;
                        nScan.thisEv[]->xA
                     #);
           (nScan.thisEv[],theDesc[],true,nScan.thisChain[])
             -> getAttSig 
             -> xSig.append;
           313->trace(#do 'sig: '->xt; xSig.asText -> xT #);
           nScan -> more;
           restart Loop
       if)
  exit xSig[]
  #);
ScanXargs:
  (# EH: @EvalHandler;
     xScan: @ | EH.scanXAdr;   
     nD: ^sematt.AttDesc; 
     theDesc: ^ASTindex;
     more: @boolean;
     xSig: ^ListSignature;
     sig: ^Type;
     chain: ^DH.superChain
  enter(theDesc[],chain[])
  do (theDesc[],gen.thisRegAdr,0,chain[]) -> xScan -> more;
     ListSignature -> xSig[];
     Loop:
       (if more then
           313->trace(#
                     do 'scanXargs:elm:'->xT;
                        xScan.thisEv[]->xA
                     #);
           (xScan.thisEv[],theDesc[],false,xScan.thisChain[])
             -> getAttSig
             -> xSig.append;
           313->trace(#do 'sig: '->xt; xSig.asText -> xT #);
           xScan -> more;
           restart Loop
       if);
     (if xSig.top = 1 then 
         (* Avoid returning a list, since
          * a list signals a multiValExit
          *)
         xSig.L[1][] -> sig[]
      else
         xSig[] -> sig[]
     if)
  exit sig[]
  #);
     
ScanXarg:
  (# theDesc,exitP: ^ASTindex;
     EH: @evalHandler;
     xScan: @ | EH.scanXAdr;
     ex: ^ASTindex;
     more: @boolean
  enter theDesc[] (*exitP[]*)
  do (theDesc[],gen.thisRegAdr,0,theDesc -> DH.newSingle) -> xScan -> more;
     (if true then
         (if more then
             &ASTindex[] -> ex[];
             xScan.thisEv -> ex;
             xScan -> more;
             (if more then
                 '\nScanXarg: more than one exit element' -> putline;
             if)
         if)
      else
         (if exitP.label <> gram.empty then
             &ASTindex[] -> ex[];
             exitP.son -> ex; (* check that ONLY one exit elm *)          
         if)
     if)
  exit ex[]
  #);
getAttSig:
  (# EV: ^ASTindex;
     theDesc: ^ASTindex;
     isEnter: @boolean;
     chain: ^DH.superChain;
     aplSig,      (* signature know at point of application *)
     xSig: ^Type; (* signature known at point of declaration  *)
  enter(EV[],theDesc[],isEnter,chain[])
  <<SLOT signature_getAttSig:doPart>>
  exit(xsig[],aplSig[])
  #);

isBETAsubOfExternalClass: booleanValue
  (* test if desc is an interface to an external class
   * or a real BETA subclass of an externalclass.
   * if interface then no code should be generated;
   * if 'real' then code should be generated.
   * As a simple hack, a direct subclass of externalClass
   * is considered to be an interface.
   * Subclasses at level 2 and below are considerered 'real'.
   * A better means for specifying interface og real
   * should be invented
   *)
  (# desc: ^ASTindex;
  enter desc[]
  <<SLOT signature_isBETAsubOfExternalClass:dopart>>
  #);
     
newInstance:
  (# desc: ^ASTindex; 
     consSig: ^ConstructorSignature;
     hasOrigin: @boolean
  enter desc[]
  <<SLOT signature_newinstance:doPart>>
  #);
getExternalClassName:
  (# EH: @evalHandler;
     desc: ^ASTindex; class: ^text; extKind: @integer
  enter desc[]
  <<SLOT signature_getExternalClassName:doPart>>
  exit class[]
  #);
isExternalString: booleanValue
  (# desc: ^ASTindex
  enter desc[]
  <<SLOT signature_isExternalString:dopart>>
  #)
