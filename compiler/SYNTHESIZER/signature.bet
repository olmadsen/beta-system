ORIGIN 'genlib';
INCLUDE 'auxlib';
---theGenLib:attributes---

Type: 
  (# isRef: < booleanValue;
     isList:< booleanValue;
     elmType:<  integerValue;
     asText:<
       (# T: ^text
       do inner
       exit T[]
       #)
  do inner
  exit this(Type)[]
  #);
int32Value: Type 
  (# elmType::(#do 1 -> value #);
     asText::
       (#
       do (if isJava then 'I'->T[] else 'int32'->T[] if)
       #)
  #);
charValue: Type 
  (# elmType::(#do 2 -> value #);
     asText::
       (#
       do (if isJava then 'C'->T[] else 'char'->T[] if)
       #)
  #);

Void: Type
  (# elmType::(# do 10 -> value #);
     asText:: 
       (#
       do (if isJava then 'V'->T[] else 'void'->T[] if)
       #)
  #);

Reference: Type 
  (# class: ^text;
     isRef:: TrueValue;
     elmType:: (# do 11 -> value #);
     asText::
       (# 
       do (if isJava then
              'L' -> T[]; class[] -> T.append; ';'->T.put;
           else 
              ''->T[]; (*'class ' -> T[];*) class[] -> T.append
          if)
       #)
  enter class[]
  do (if 'object' -> class.equalNCS then
         (if true
          // isJava then
             'java/lang/Object' -> class[]
          // isDotNet then
             '[mscorlib]System.Object' -> class[]
          else
             'Unknown_platform.Object' -> class[]
         if);
     if);
  #);
Array: Type
  (# element: ^Type;
     isRef:: trueValue;
     elmType:: (# do 12 -> value #);
     asText::
       (#
       do (if isJava then 
              '[' -> T[];
              element.asText -> T.append; 
           else (* FIXME *)
              element.asText -> T[]; '[]' -> T.append
          if)
       #)
  enter element[]
  #);
mkListSignature:
  (# T:  ^type; L:@ListSignature
  enter T[]
  do T[] -> L.append
  exit L[]
  #);
ListSignature: Type
  (# L: [3] ^Type; top: @integer;
     isList::trueValue;
     append:
       (# T: ^Type; TL: ^ListSignature
       enter T[]
       do (if T.isList then
              T[] -> TL[];
              TL.scan(# do current[] -> append #)
           else
              (if (top+1->top) > L.range then
                  L.range -> L.extend
              if);              
              T[]-> L[top][]
          if)
       #);
     scan:
       (# current: ^Type
       do (for i: top repeat
               L[i][] -> current[];
               INNER
          for)
       #);
     asText::
       (# 
       do &text[] -> T[];
          (if isJava then
              scan(#do current.asText -> T.append #);
           else
              scan
              (# addSep: @boolean;
              do (if addSep then ','->T.put if);
                 current.asText -> T.append;
                 true -> addSep;
              #);
          if)
       #)
  #);
BetaTextSignatureId: (# exit 1 #);
JavaStringSignatureId: (# exit 2 #);

specialSignature: Type
  (# sigId: @integer;
     astext::
       (#
       do &text[] -> T[];
          (if isJava then
              (if sigId
               // BetaTextSignatureId then
                  'Ltext;' -> T.append
               // JavaStringSignatureId then
                  'Ljava/lang/String;' -> T.append
               else
                  'LUnknowSpecialSignature;' -> T.append
              if)
           else
              (if sigId
               // BetaTextSignatureId then
                  'text' -> T.append
               // JavaStringSignatureId then
                  'string' -> T.append
               else
                  '>>>>>UnknowSpecialSignature' -> T.append
              if)
          if)
       #)
  enter sigId
  #);

valueSignature:
  (# desc: ^ASTindex; sig: ^Type
  enter desc[]
  do (if true 
      // desc -> sematt.integerDesc.equal then
         int32Value -> sig[]
      // desc -> sematt.charDesc.equal then
         charValue -> sig[]
      else
         int32Value -> sig[]
     if)
  exit sig[]
  #);

mkSignature:
  (# desc: ^ASTindex; sig: ^Type; tsig: ^text;
     EH: @evalHandler
  enter desc[]
  do (if (desc -> sematt.descKind) = sematt.standardKind then
         (desc[] -> valueSignature -> sig[]).astext -> tsig[]
      else
         (desc[] -> EH.descName -> Reference).asText -> tsig[]
     if)
  exit tsig[]
  #);
mkArraySignature:
  (* we should simplify mkSignature and this one *)
  (# desc: ^ASTindex; tsig: ^text;
     EH: @evalHandler
  enter desc[]
  do (if (desc -> sematt.descKind) = sematt.standardKind then
         (desc[] -> valueSignature ->array).astext -> tsig[]
      else
         (desc[] -> EH.descName -> Reference->array).asText -> tsig[]
     if)
  exit tsig[]
  #);
  
Signature:
  (* A signature may have the following two abstract forms:
   * 1. Method def :           method, input arguments, return type;
   * 2. Method call: receiver, method, input arguments, return type
   * As can be seen the difference is the receiver present in
   * the method call
   *)
  (# receiver: ^text; (* an optional receiver *)
     method: ^text;   (* method name *)
     NNsig: ^ListSignature;    (* input arguments *)
     XXsig: ^Type;    (* return type *)
     
     
     thisDesc: @ASTindex;      (* descriptor of this method (pattern) *)
     thisChain: ^DH.superChain;(* desc chain of def- or call-location *)
     
     setDesc:
       (# EV: ^ASTindex; MN,vKind: @integer
       enter EV[]
       do (thisSuperChain,EV) 
            -> DH.theDesc
            -> (thisDesc,MN,thisChain[],vKind);
       #);
     addReceiver: (# enter receiver[] #);     
     addMethod: (# enter method[] #);
     
     noOfEnterArgs: 
       (# N: @integer 
       do (if NNsig[] <> none then NNsig.top -> N if) 
       exit N 
       #);
     enterSig:
       (# noNsig: @boolean;
          T: @text
       enter noNsig
       do '('->T;
          (if not NoNsig then NNsig.asText -> T.append if);
          ')'->T.put;
       exit T[]
       #);
     exitSig:
       (# noXsig: @boolean; T: ^text
       enter noXsig
       do (if noXsig then voidExitSig -> T[] else XXsig.asText -> T[] if)
       exit T[]
       #);
     voidExitSig: 
       (# T: @text 
       do (if isJava then 'V' -> T else 'void'->T if);
       exit T[]
       #);
     asText:
       (* producec a textual representation of this signature *)
       (# noNsig,noXsig: @boolean;
          T: ^text
       enter(noNsig,noXsig)          
       do (if isJava then
              (if receiver[] <> NONE then
                  (* method call signature *)
                  receiver[] -> T[];
                  '/' -> T.put
               else
                  &text[] -> T[]
              if);
              (if method[] <> none then
                  method.copy -> T.append
               else
                  '\n*** method is none ' -> putline
              if);
              noNsig-> enterSig -> T.append;
              noXsig -> exitSig -> T.append;
           else
              noXsig -> exitSig -> T[];
              ' '->T.append;
              (if receiver[] <> none then
                  (* method call signature *)
                  receiver[] -> T.append;
                  '::' -> T.append
              if);
              (if method[] <> none then
                  '\'' -> T.put; (* Quote to avoid clash with IL reserved words, e.g. add *)
                  method.copy -> T.append;
                  '\'' -> T.put;
               else
                  '\n*** method is none ' -> putline
              if);
              noNsig -> enterSig -> T.append
          if)
       exit T[]
       #);

     noEnter: (# do ListSignature -> NNsig[] #);
     setEnter: (# enter NNsig[] #);
     addEnter:
       (# EH: @EvalHandler;
          nScan: @ | EH.scanNAdr;   
          nD: ^sematt.AttDesc; 
          theDesc: ^ASTindex;
          more: @boolean;
       enter theDesc[]
       do 313->trace(#
                    do 'addEnter:'->xT; theDesc[] -> xA
                    #);
          ListSignature -> NNsig[];
          (if thisChain[] <> none then
              (if not (theDesc->thisDesc.equal) then 
                  'addEnter:desc not equal'->putline
              if);
              313->trace(#
                        do 'addEnter:theDesc(from enter):'->xT;
                           theDesc[]->xA; xN;
                           'thisDesc( for setDesc): ' -> xT;
                           thisDesc[] -> xA;
                           (if thisChain[] <> none then
                               thisChain
                           if) 
                        #);
              
              (thisDesc[],gen.thisRegAdr,0,thisChain[],true) -> nScan -> more;
           else
              (theDesc[],gen.thisRegAdr,0,thisSuperChain,true) -> nScan -> more;
          if);
          Loop:
            (if more then
                (nScan.thisEv[],theDesc[],true) -> getAttSig -> NNsig.append;
                313->trace(#do 'Nsig: '->xt; NNsig.asText -> xT #);
                nScan -> more;
                restart Loop
            if);
          313->trace(#do 'enterNsig: '->xT; NNsig.asText -> xT #);
       #);
     scanEnter:
       (# current: ^type; isRef,doInner,skip: @boolean
       do NNsig.scan
          (#
          do current[] -> this(scanEnter).current[];
             current.isRef -> isRef; 
             INNER scanEnter
          #)
       #);
     exitVoid: 
       (# 
       do setVoidXsig
       #);
     setVoidXsig: 
       (#
       do Void -> xxSig[]; 
       #);
     exitRef:
       (# desc: ^ASTindex;
          EH: @evalHandler
       enter desc[]
       do setVoidXsig;
          desc[] -> EH.descName -> Reference -> XXsig[];
       #);
     setExit: (# enter XXsig[] #);
     addExit:
       (# EH: @EvalHandler;
          xScan: @ | EH.scanXadr;
          exitP: ^ASTindex;    
          more: @boolean
       enter exitP[]
       do 313->trace(#
                    do 'Signature:addExit:'->xT; xN;
                       thisDesc[]->xA; xN;
                       (if thisChain[] <> none then
                           thisChain
                       if)
                    #);
          
          setVoidXsig;

          (if thisChain[] <> none then
              (thisDesc[],gen.thisRegAdr,0,thisChain[]) 
                -> xScan 
                -> more;
              (if not more then exitVoid; leave addExit if);
              loop:
                (if more then
                    (xScan.thisEv[]->exitVal[],thisDesc[],false) 
                      -> getAttSig 
                      -> XXsig[];
                    xScan -> more;
                    (if more then
                        '\n***OBS! exit-part has more than one element'
                          ->putline
                    if);
                    restart loop
                if)
           else
              '\n***OBS. thisChain is none '->putline;
              (if (thisDesc[](*exitP[]*)->theGen.scanXarg -> exitVal[]) <> NONE then
                  (exitVal[],thisDesc[],false) -> theGen.getAttSig -> XXsig[];
          if)if);
          (if XXsig.isRef then
              2 -> exitId
           else
              1 -> exitId
          if);
       #);
     exitVal: ^ASTindex;
     exitId: @integer (* dirty *)
  exit asText
  #);
scanNargs:
  (# EH: @EvalHandler;
     nScan: @ | EH.scanNAdr;   
     nD: ^sematt.AttDesc; 
     theDesc: ^ASTindex;
     more: @boolean;
     xSig: ^ListSignature
  enter theDesc[]
  do (theDesc[],gen.thisRegAdr,0,ThisSuperChain,true) -> nScan -> more;
     ListSignature -> xSig[];
     Loop:
       (if more then
           313->trace(#
                     do 'scanNargs:elm:'->xT;
                        nScan.thisEv[]->xA
                     #);
           (nScan.thisEv[],theDesc[],true) -> getAttSig -> xSig.append;
           313->trace(#do 'sig: '->xt; xSig.asText -> xT #);
           nScan -> more;
           restart Loop
       if)
  exit xSig[]
  #);

ScanXarg:
  (# theDesc,exitP: ^ASTindex;
     EH: @evalHandler;
     xScan: @ | EH.scanXAdr;
     ex: ^ASTindex;
     more: @boolean
  enter theDesc[] (*exitP[]*)
  do (theDesc[],gen.thisRegAdr,0,theDesc -> DH.newSingle) -> xScan -> more;
     (if true then
         (if more then
             &ASTindex[] -> ex[];
             xScan.thisEv -> ex;
             xScan -> more;
             (if more then
                 '\nScanXarg: more than one exit element' -> putline;
             if)
         if)
      else
         (if exitP.label <> gram.empty then
             &ASTindex[] -> ex[];
             exitP.son -> ex; (* check that ONLY one exit elm *)          
         if)
     if)
  exit ex[]
  #);
getAttSig:
  (# EV: ^ASTindex;
     nD: ^sematt.AttDesc; EH: @EvalHandler;
     theDesc: ^ASTindex;
     desc: @ASTindex; 
     MN,isVirtual: @integer;
     EVchain: ^DH.superChain;
     xSig: ^Type;
     referenceSignature: (* unify with dynamicItem case in do-part below*)
       (# EV: ^ASTindex;
          sig: ^Type
       enter EV[]
       do EV[] -> sematt.AttDesc -> nD[];
          (*nD.display;*)
          (if nD.spec.label = gram.dynamicItem then
              (theDesc->DH.newSingle,nD.apl)
                -> DH.theDesc
                -> (desc,MN,EVchain[],isVirtual);
              (if desc.label = gram.objectDescriptor then
                  desc[] 
                    -> EH.descName
                    -> Reference 
                    -> sig[];                         
               else 
                  ' ***??? not descriptor ' -> putline;
                  '?notDescriptor?'->Reference -> sig[];
              if)
           else
              '?notDynamicItem?'->Reference -> sig[];
          if);
       exit sig[]
       #);
     isEnter: @boolean
  enter(EV[],theDesc[],isEnter)
  do 313->trace(#
               do 'getAttSig:'->xT;
                  EV[] -> xA;
                  ev.label -> xI;
                  ev.label -> sematt.evalClass -> xI
               #);
     (if EV.label
      // gram.insertedItem  then
         (# den: @ASTindex;
         do EV.son -> den;
            (if den.label = gram.objectDescriptor then                
                den[] -> scanNargs -> xSig[];
                313->trace(#do 'getAttSig:inserted:'->xT;  xSig.asText->xT#)
             else
                'unknownInsertedItem;'-> Reference -> xSig[]                
         if)#)
         (* // gram.objectDenotation then
          'LunknownObjectDenotation;'->sig[]*)
      // gram.objectReference 
      // gram.structureReference then
         EV[] -> referenceSignature -> xSig[];         
      // gram.thisObject then
         (# AD: @ASTindex
         do EV.son -> AD;
            AD.dclRef -> AD;
            AD.getText -> Reference -> xSig[]
         #)
      // gram.assignmentEvaluation then
         (* preliminary *)
         '\nOBS! Incomplete signature of assignment' -> putline;
         sematt.integerDesc[] -> valueSignature -> xSig[]
      else
         (if (EV.label -> sematt.evalClass) = sematt.evalClass.binOp then
             int32Value -> xSig[]
          else
             EV[] -> sematt.AttDesc -> nD[];
             (*nD.display;*)

             (if nD.kind
              // sematt.standardKind then
                 (if nD.isRep then
                     nD.desc[] -> valueSignature -> Array -> xSig[]
                  else
                     nD.desc[] -> valueSignature -> xSig[]
                 if)
              // sematt.generalKind 
              // sematt.classKind then
                 (if isEnter then
                     nD.desc[] -> scanNargs -> xSig[] (*sig[]*)
                  else
                     (# xEV: ^ASTindex
                     do nD.desc[] -> scanXarg -> xEV[];
                        (* is thisDesc correct here? *)
                        (xEV[],thisDesc[],false) -> theGen.getAttSig -> Xsig[];
                     #)
                 if)
              else
                 (* don't work if virtual - we should get generalKind
                  * but ...
                  *)
                 (if nD.spec.label = gram.dynamicItem then
                     (theDesc->DH.newSingle,nD.apl)
                       -> DH.theDesc
                       -> (desc,MN,EVchain[],isVirtual);
                     (if desc.label = gram.objectDescriptor then
                         desc[] 
                           -> EH.descName
                           -> Reference 
                           -> xsig[];
                         
                      else 
                         ' ***??? not descriptor ' -> putline;
                         '?notDescriptor?'->Reference -> xSig[];
                     if)
                  else
                     '?notDynamicItem?'->Reference -> xSig[];
                 if);
     if)if)if);
     313->trace(#do 'signature:addExit:'->xT; xSig.asText -> xT #)
  exit xsig[]
  #);
