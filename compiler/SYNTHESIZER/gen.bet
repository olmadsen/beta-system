ORIGIN 'synthesizerbody';
LIB_ITEM 'betacodegen';
BODY 'gen1body' 'gen2body';
---generator: descriptor---
(#  <<SLOT genlib:attributes>>;
   
   GenTabLab,		  (* label for start of gen table *)
   TemplateLab,		  (* label for start of object template *)
   GCTableLab		  (* label for GC-table *)
   : @mch.localLab;  
   
   newAddress:
     (# localDesc: ^ASTindex; 
        theAdr: @mch.regAdr
     enter localDesc[]
     <<SLOT newAddress:doPart>>
     exit theAdr[]
     #);
   mkAddress: (* make regAdr from register aR *)
     (# aR: @mch.adrRegOperand; localDesc: ^ASTindex; A: ^mch.address
     enter(aR,localDesc[]) do <<SLOT mkAddress:descriptor>> exit A[] #);
   
   comment:
     (# node: ^ASTindex; T,T1: @text
     enter node[]
     do (node[],T[],100)->thePP;
        L: T.scanAll
          (#do (if ch//ascii.newline then leave L if);
             ch->T1.put
          #);
        T1->mch.comment
     #);
   DefineGlobEntry:
     (# xLab: ^Text; data: @boolean
     enter(xLab[],data) <<SLOT DefineGlobEntry:doPart>>
     #);
   SysLab:
     (# L: @char; descNo: @integer; formId: ^Text; global: @boolean;
        Lab: ^text
     enter(L,descNo,formId[],global)
     <<SLOT SysLAb:doPart>>
     exit lab[]
     #);
   InitialSeq:
     (* generate initial code sequence;
      * rootDescNo is the system descriptor no.
      * Alloc and execute system descriptor.
      *)
     (# rootDesc: ^ASTindex
     enter rootDesc[]
     do <<SLOT InitialSeq:descriptor>>
     #);
   TextConst: 
     (# T: ^Text; pNo: @integer; isWtext: @boolean
     enter(T[],pNo,isWtext)
     do <<SLOT TextConst:descriptor>>
     #);
   NewVirt:
     (* Generate an instance of a virtual 
      * pattern attribute V of a pattern P *)
     (# A: ^mch.address;  (* address of P-object *)
        virtOff           (* offset in virtual dispatch table *)
        ,access: @integer;(* A dispatch entry may be one of: 
                           * direct: The prototype for V; 
                           *         origin is then the A-object
                           * cstInd: Address of code that computes origin for
                           *         for V and its prototype 
                           *)
        final2virt: @boolean (* V is a final bound to a virtual *)
     enter(A[],virtOff,access,final2virt)
     do <<SLOT NewVirt:descriptor>>
     #);
   
   newRep:
     (* reuse this one in evbody: move to gen.bet.
      * In fact move all aux patterns to gen.bet
      *)
     (# elmDesc: ^AStindex; A: ^mch.address; 
        isExtend,isValueRep,isStaticItem,isBoolRep
        ,isList2rep: @boolean;  
        size: @integer;
        genRange:<object;
        (*(# do 3 -> (range -> mch.newCstOp).toPrimDest #);*)
     enter(elmDesc[],A[],isExtend,isValueRep,isStaticItem,size,isBoolRep,isList2rep)
     <<SLOT newRep:doPart>>
     #);
    
   ExeTop:
     (* datpete: 2/11/98: execute reference qualified with Object(?) *)
     (# A: ^mch.address
     enter A[]
     do <<SLOT exeTop:descriptor>>
     #);
   
   InLinePrimitive:
     (# OpCode,I1,I2: @integer; D: [1]@integer; (* dataReg with parameters *)
        dRes: @integer (* dRegister with possible result; -1 means void *)
     enter(OpCode,I1,I2,D)
     do <<SLOT InLinePrimitive:descriptor>>
     exit dRes
     #);
   
   EmitInt:  (# V: @ integer enter V#);
   ProtoHead:
     (# formIndex,astNumber: @integer;
        thisForm,preForm,externalEntryLab: ^text; 
        descNo,originOff,size,preDescNo: @Integer; desc2Alias: @boolean
     enter(formIndex,astNumber,thisForm[],descNo,originOff,size
        ,preForm[],preDescNo,externalEntryLab[],desc2Alias)
     do <<SLOT ProtoHead:descriptor>>
     #);
   formlab: @mch.localLab; (*label of ASCII text for THIS form *)
   SpecialInitDesc: 
     (# prefDesc: ^ASTindex
     enter(thisForm[],prefDesc[])
     do <<SLOT SpecialInitDesc:descriptor>>
     #);
   BeginAlloc: 
     (# thisFormName: ^text; thisForm: ^ Text; 
        descNo,formIndex,ASTref,size: @ integer;
        hasAcode: @boolean;
        objKind: @integer
     enter(thisFormName[],thisForm[],descNo,formIndex,ASTref,size,hasAcode,objKind)
     do <<SLOT beginAlloc:descriptor>>
     #);
   (** Allocation and execution of components **)
   (* Note: currently the code is just for the topmost prefix *)
   (* of the component. Only components without prefix will work *)
   doSuspend:
     (#
     do <<SLOT doSuspend:descriptor>>
     #);
   
   (*** private attributes ****)
   attach:
     (# descNo: @integer; formId: ^Text
     enter(descNo,formId[])
     do <<SLOT attach:descriptor>>
     #);
   descIdf:
     (# T: @text
     enter T
     do <<SLOT descIdf:descriptor>>
     #);
   CopyCtext: 
     (# cTxt: @mch.dataRegOperand;
        A: ^mch.address 
     enter cTxt
     do <<SLOT CopyCtext:descriptor>> 
     exit A[] 
     #);
   ThisRegAdr:
     (* return an adress describing offset `off` in THIS object *)
     (# off: @integer; A: @mch.regAdr
     enter off <<SLOT ThisRegAdr:doPart>> exit A[]
     #);
   CallRegAdr:
     (* Return an Mch.Address describing the register denoting the object
      * to be called, and denoting the object being returned from
      *)
     (# A: @mch.regAdr <<SLOT CallRegAdr:doPart>>  exit A[] #);
   
   UseTmpReg: booleanValue
     (# A: ^mch.address
     enter A[]
     do (if A.theReg // mch.thisO // mch.callO then
         else
            true -> value
     if)#);
   PositionMarker:
     (# a2s: ^theGroup.a2sHandle;
        N: ^ASTindex
     enter N[]
     <<SLOT gen_markPos:doPart>>
     #)
#)


