ORIGIN 'evlib';
LIB_ITEM 'betacodegen';
INCLUDE 'prototype'
        'gen'
'synthlib';
INCLUDE 'auxlib';
BODY 'genlibbody';
BODY 'genlib_alloc' 'genexternal';
BODY 'genlib_com';
BODY 'genlib_bindvirtuals';
BODY 'genlib_bytecode';
-- GS: Descriptor --
(#
   thisPT: ^ProtoType;
   (* must be dynamic *)
   
   externals: @
     (* Collection of external descriptors for generation
      * of external bytecode class
      *)
     (# L: [3] ^ASTindex; top: @integer;
        add:
          (# D: ^AStindex
          enter D[]
          do (if (top+1->top) > L.range then L.range -> L.extend if);
             &ASTindex[] -> L[top][];
             D -> L[top]
          #);
        scan:
          (# current: ^ASTindex;
          do (for i: top repeat
                  L[i][] -> current[];
                  inner
          for)#);
        display: 
          (#
          do '\nExternals: ' -> putline;
             scan(# do 1->trace(#do current[] -> xA #)#)
          #);
        
     #);
        
do none ->thisPT[]
#)  

-- TheGenLib: Attributes --
(* in the prototype, the offset of all dynamic references are included.
 * this offset is 4-byte aligned. i.e. the two least significant bits are not
 * used. These two bits are then used for tagging some of the references:
 * origin references are marked with tag 10
 * references to virtual/slot part objects are marked by 01
 *)
orgTag: (#  exit 2 #);
partRefTag: (#  exit 1 #);
GenSymbTable:
  (# nameId: ^text; Singular: @boolean; descName: ^text; 
  enter (nameId[],Singular)
  do
     theFormIndex->GS.thisPT.formIndex;
     thisDesc.nodeId->GS.thisPT.nodeId;
     thisForm[]->GS.thisPT.formId[];
     ThisDescNo->GS.thisPT.descNo;
     thisDesc.size->GS.thisPT.size;
     prefFormId[]->GS.thisPT.prefFormId[];
     prefDescNo->GS.thisPT.prefDescNo;
     externalEntryLab[]->GS.thisPT.externalEntryLab[];
     thisDescOrgOff->GS.thisPT.orgOff;
     thisDesc->GS.thisPT.desc;
     thisPrefDesc->GS.thisPT.prefDesc;
     pref->GS.thisPT.pref;
     att->GS.thisPT.att;
     (if nameId[] = none then
         '*'->descName[]->GS.thisPT.descId[]; (* singular insertion *) 
      else
         nameId.copy->descName[]->GS.thisPT.descId[];
         (if singular then '~'->descName.put else '#'->descName.put if)
     if);
     (if desc2Alias then
         (if thisDescNo = 2 then true->GS.thisPT.desc2Alias if)
     if)
  #);
BindVirtuals:
  (# pref,att: ^ASTindex     
  enter (pref[],att[])
  <<SLOT BindVirtuals:doPart>>
  #);
SaveReturn:
  (# 
  do (if not returnSaved then (*true->returnSaved; *)
         (if thisDesc[]->sematt.hasAcode->returnSaved then
             (true,thisDesc.returnOff)->mch.SaveReturn
         if)
     if)
  #);
EmitImpGCtab:
  (* no tmp. sto. is used for if-imp's any more, 
   * so this pattern may be eliminated *)
  (#
     scan:
       (# node: ^ASTindex; off: @integer
       enter node[]
       do
          node
            ->scanList
              (# imp: @ASTindex
              do
                 currentNode->imp;
                 (*313->trace(#do imp[]->A #);*)
                 (if imp.label
                  // gram.labelledImp // gram.forImp then
                     imp.son->imp; imp.brother->imp; imp[]->&scan
                  // gram.generalIfImp then
                     1->imp.getAttribute->off;
                     (if off < 0 then - off->GS.thisPT.dyn.add if);
                     imp.son->imp;
                     imp.brother->imp
                       ->scanList (*alternatives*)
                         (# im: @ASTindex
                         do
                            currentNode->im;
                            im.son->im;
                            im.brother->im;
                            im[]->&scan
                         #);
                     imp.brother->imp;
                     (if imp.label
                      // gram.elsePart then imp.son->imp; imp[]->&scan
                     if)
                 if)
              #)
       #);
     doP: ^ASTindex
  enter doP[]
  do (if doP.label <> gram.empty then doP[]->&scan if)
  #);
EmitSuperGCtab: (* emit GC table for superptn *)
  (#
     prefDesc,pref,mainP,att,enterP,doP,exitP: ^ASTindex;
     SD: @ASTindex;
     orgOff,superOrgOff,off: @integer;
     
  enter prefDesc[]
  do
     prefDesc[]->sematt.descSonsRef
       ->(pref[],mainP[],att[],enterP[],doP[],exitP[]);
     (if pref.label = gram.prefix then
         pref.son->sematt.descrip-> SD;
         (if not (SD->sematt.CprocDesc.equal) then
             SD[]->&emitSuperGCtab->superOrgOff; 
         if)
     if);
     (if (prefDesc.originOff->orgOff) <> superOrgOff then
         orgOff+orgTag->GS.thisPT.dyn.add
     if);
     (if common.switch[64] and ((prefDesc.returnOff->off) <> 0) then
         off->GS.thisPT.dyn.add
     if);
     att
       ->scanList
         (# dcl: @currentNode; dcl1,nameL,ES,desc: @ASTindex; 
         do
            dcl->dcl1;
            (if not dcl1.isSlot then
                dcl1.son->nameL;
                nameL.brother->ES;
                nameL
                  ->scanList
                    (# N: @currentNode; N1: @ASTindex; descKind: @integer
                    do
                       N->N1;
                       (if dcl1.label
                        // gram.simpleDecl then
                           ES.son->sematt.descrip-> desc;
                           (if desc.label
                            // gram.objectDescriptor then
                               desc->sematt.descKind->descKind
                            else
                           (* a virtual/patternVar is always generalKind! *)
                               sematt.generalKind->descKind
                           if);
                           (if ES.label
                            // gram.dynamicItem // gram.dynamicComponent
                            // gram.variablePattern then
                               (if descKind
                                // sematt.generalKind // sematt.standardKind
                                // sematt.externalKind // sematt.callBackKind
                                then
                                (* For references R: ^external; F: ##external,
                                 * descKind is standardKind
                                 *)
                                   N1.off->GS.thisPT.dyn.add
                               if)
                            else
                           (* static objects *)
                               (if desc.label
                                // gram.objectdescriptor then
                                   (if descKind
                                    // sematt.standardKind then
                                       (if desc.size
                                        // 4 then
                                           N1.off->GS.thisPT.longs.add
                                        // 1 then
                                           N1.off->GS.thisPT.bytes.add
                                        // 8 then
                                           N1.off->GS.thisPT.reals.add
                                        // 2 then
                                           N1.off->GS.thisPT.shorts.add
                                        else
                                           Cerror
                                             (# 
                                             do
                                                'Unkown size(standard descriptor prefix):'
                                                  ->xT;
                                                desc.size->xI
                                             #)
                                       if)
                                    // sematt.generalKind then
                                       (if desc[]->sematt.descAccess
                                        // common.direct then
                                        (*N1.off->GS.thisPT.Stat.add *)
                                        (* it seems that the stat-table is no
                                         * longer used. See instead
                                         * emitObjecTemplate where the static
                                         * objecttable is emitted
                                         *)
                                           
                                        else
                                       (* mainPart of doPart*)
                                           N1.off->GS.thisPT.dyn.add
                                       if)
                                   if)
                                else
                                   N1.off+partRefTag->GS.thisPT.Dyn.add
                               if)
                           if)
                        // gram.repetitionDecl then
                           N1.off+partRefTag->GS.thisPT.dyn.add
                       if)
                    #)
            if)
         #);
     
  exit orgOff
  #);
MainAdr:
  (# PD,SD: @ASTindex
  enter PD
  do
     (if PD.label = gram.prefix then
         PD.son->SemAtt.descrip-> SD;
         (if (SD[]->Sematt.HasDo) then SD[]->GS.thisPT.mainAdr if);
         (if not (SD->sematt.cProcDesc.equal) then SD.son->&MainAdr if)
     if)
  #);
GenPrefix: 
  (# pref: @ASTindex;
     kind: @integer;
     
     prefDesc,preDen,realPre: @ASTindex;
     thisDescOrigin: ^ASTindex;
     preDescOrg: @ASTindex;
      superOrgOff,off: @integer;
     chain: ^DH.SuperChain

  enter (pref,kind)
  <<SLOT genlib_genPrefix:doPart>>
  #);

PrefixAlloc: GenPrefix(#<<SLOT genlib_PrefixAlloc:doPart>>#);
       
GenAlloc:
  (# att: @ASTindex;
     base: @integer; (*  base only when switch[64] *)
     reps: ^RepList; (* Only for COM objects *)
     saveLocalDesc:< (* for bytecode generation *)
       (# D: ^ASTindex enter D[] do inner #);

  enter (att,base,reps[])
  <<SLOT genlib_alloc:doPart>>
  #);
GetSingular: (* find possible singular descs in enter/exit-parts *)
  (# N: @ASTindex
  enter N
  do
     (if not N.isNull then
         (*301->trace(#do 0->&N.lispPrint #);*)
         (if N.label
          // gram.objectDescriptor then
             (*'Singular found'->tracestream.puttext;*)
             (N,common.itemKind,0(*common.insCons*),null)->DS.push;
             (* kind,cons are not correct !!!*)
             N.brother->&getSingular             
          // gram.nameApl // gram.nameDcl // gram.textConst
          // gram.integerConst // gram.codeString // gram.empty then
          else
             (if not N.isSlot then
                 (if N.nodeClass
                  // kinds.cons then
                     N.son->&GetSingular; N.brother->&GetSingular
                  // kinds.list then
                     N->scanList (#  do currentNode->&GetSingular #)
                  // kinds.dummy then
                     N.son->&GetSingular
                 if)
             if)
         if)
     if)
  #);
GenNpart:
  (# exitOffStart: @integer
    <<SLOT genNpart:doPart>>
  exit exitOffStart
  #);
GenDo:
  (* generate code for the do-part.
   * If size>0 then this is a code gen for a dopart slot,
   * where tmp. attributes are needed
   *)
  (# <<SLOT GenDoLib:attributes>>;
     scan:
       (# node: @ ASTindex;
       enter node
       <<SLOT genDo_scan:doPart>>
       #);
          
     topReturn,isDoPartForm: @boolean;
     restartLab: @mch.localLab;
     
     size: @integer; insertDo: ^ASTindex; 
     evalChain: ^DH.superChain; 
     globalMlab,isComVirtual: @boolean;
     descName,signature: ^text
  enter(size,insertDo[],evalChain[],globalMlab,isComVirtual,descName[],signature[])
  <<SLOT genDo:DoPart>>
  #);
GenXPart:
  (# exitOffStart: @integer
  enter exitOffStart
  <<SLOT genXpart:doPart>>
  #);
singularData: (#exit 1 #);
dynamicObj: (#exit 2 #);
inForm: (# exit 0 #); (* a descriptor inside some form: the normal kind*)
doPartForm: (# exit 1 #); (* a doPart form *)
mainPartForm: (# exit 2 #); (* a mainPartForm *)
GenObj:
  (* generate code for a descriptor used as an item *)
  (# R: ^ProtoType; hasAcode: @boolean; N: @ASTindex;
     objKind2: @integer;
     isComVirtual,local: @boolean;
     
     objKind,formKind: @integer;
     EH: @evalHandler;
     T: ^text
  enter(objKind,formKind)
  <<SLOT genlib_genObj:dopart>>
  #);

GenCom: <<SLOT GenCom:descriptor>>;

GenComVirtual: <<SLOT genComVirtual:descriptor>>;

GenByteCode: 
  (# thisDesc: ^ASTindex; isDoPartForm: @boolean
  enter(thisDesc[],isDoPartForm)
     <<SLOT GenByteCode:doPart>>
  #);
genPtnMethod:
  (# path,patternName: ^text;
     desc: ^ASTindex;
     isStatic,isVarPtn,inLine,withN,withX: @boolean;
     originDesc,topDesc: ^ASTindex
  enter
     (patternName[],desc[],isStatic,isVarPtn,originDesc[],topDesc[],inLine,withN,withX)
  <<SLOT genPtnMethod:doPart>>
  #);
genPtnClass:
  (# path,patternName: ^text;
     desc: ^ASTindex;
     blockLevel: @integer;
     originDesc: ^ASTindex
  enter(patternName[],desc[],originDesc[])
  <<SLOT genPtnClass:doPart>>
  #);
genClass:
  (# path,className: ^text;
     desc: ^ASTindex;
     blockLevel: @integer;
     isDoPartForm: @boolean
  enter(path[],className[],desc[],blockLevel,isDoPartForm)
  <<SLOT genClass:doPart>>
  #);
genExternalClass:
  (# path,className: ^text;
     desc: ^ASTindex;
     blockLevel: @integer
  enter(path[],className[],desc[],blockLevel)
  <<SLOT genExternalClass:doPart>>
  #);
genMethod:
  (# methodName: ^text; desc: ^ASTindex
  enter(methodName[],desc[])
  <<SLOT genMethod:doPart>>
  #);
genEnterMethod:
  (# desc: ^ASTindex
  enter desc[]
  <<SLOT genEnterMethod:doPart>>
  #);
genDoMethod:
  (# desc: ^ASTindex; 
     isDoPartForm,                     (* do-method of a doPart form *)
     simpleEnter,simpleExit: @boolean; (* enter/exit-arguments are 
                                        * simple procedure arguments
                                        *)
     subLevel: @integer
  enter(desc[],isDoPartForm,simpleEnter,simpleExit,subLevel)
  <<SLOT genDoMethod:doPart>>
  #);  
genExitMethod:
  (# desc,superDesc: ^ASTindex; 
  enter(desc[],superDesc[])
  <<SLOT genExitMethod:doPart>>
  #);
ScanCOMArgs: 
  (# noOfCOMargs,dataByValueByteSize: @integer;
     RL: @RepList;     
     EH: @EvalHandler;
     arg: ^EH.evVal;
     nScan: @ | EH.scanNAdr;
  do <<SLOT ScanCOMargs:descriptor>>;
  exit(noOfCOMargs,dataByValueByteSize,RL[])
  #);
  
GenCallBack: <<SLOT genCallBack:Descriptor>>;

ImportClrLocations:
  (# class: ^text;
     startloc, endloc: @integer;
     location: ^text;
     i: @integer;
  enter class[]
  do 1 -> i;
     scanForLocations:
       (if i<class.lgth then
           (if class.T[i] 
            // '[' then 
               i+1->startloc;
            // ']' then
               i-1->endloc;
               (if startloc<endloc then
                   (startloc,endloc) -> class.sub -> location[];
                   (if not ('mscorlib' -> location.equal) then
                       location[] -> mch.import;
                       (if false then
                           'ImportClrLocations: importing location: '
                             -> screen.puttext;
                           location[] -> screen.puttext;
                           ' from class ' -> screen.puttext;
                           class[] -> screen.putline;
                       if);
                   if);
                else
                   'ImportClrLocations: non-matching brackets in '->screen.puttext;
                   class[] -> screen.putline;
               if);
           if);
           i+1 -> i;
           restart scanForLocations;
       if);
  #);
