ORIGIN 'synthesizerbody';
LIB_ITEM 'betacodegen';
INCLUDE '../CHECKER/nxoffsets';
INCLUDE 'compilerlist';
BODY 'synthlibbody' 'evbody';
INCLUDE 'gen';
---SynthesizerBodyLib:attributes---
cError: trace
  (# msg: ^text
  enter msg[]
  do xN; 'Should NOT happen:'->xT; msg[]->xT;
     INNER; 
     xN
  #);
cTrace: trace
  (# 
  do (if no > 0 then
         '' -> mch.comment;(* comment will print thePC *) 
         ': ' -> xT;      
     if);
     INNER 
  #);
GoOrigin:
  (# thisA,A1: ^mch.RegAdr;
     on: @integer;
     isOrigin: @boolean;
     A2: ^mch.RegAdr;
  enter(thisA[],A1[],on,isOrigin)
  <<SLOT GoOrigin:doPart>>
  exit A2[]
  #);

SetSuperDesc:
  (# pn: @integer;
     thisA,destA,A: ^mch.address;     
  enter(thisA[],pn,destA[])
  <<SLOT SetSuperDesc:doPart>>
  exit A[]
  #);

StandardDen: 
  (# den,desc: @ ASTindex; std: @boolean
  enter den
  do den.son -> den;
     den -> SemAtt.Descrip -> desc;
     false -> std;
     (if desc.label = gram.objectDescriptor then
         (desc->sematt.DescKind)=sematt.standardKind -> std
     if);
  exit std
  #);
EncDescOrgOff:
  (* compute originDescOff for enclosing desciptor at level 'on' *)
  (# on: @integer; desc: ^ASTindex
  enter on
  do thisDesc[]->desc[];
     (for i: on repeat desc[]->semAtt.descOrigin->desc[] for)
  exit desc.originOff
  #);
GenLocalAdr:
  (# ad: ^ASTindex; isOrigin: @boolean; A: ^Mch.Address;
     chain: ^DH.SuperChain
  enter(ad[],isOrigin,chain[])
  do <<SLOT GenLocalAdr:descriptor>>
  exit A[]
  #);
GenAdr:
  (* Compute addres of 'ad';
   * isOrigin: true if Mch.Address of origin is computed 
   *)
  (# A: ^Mch.Address; ad: ^ASTindex; isOrigin: @boolean;
     chain: ^DH.SuperChain;
     toOrgReg: @boolean; (* a hack; used as extra enter parameter in
                          * genOrgAdrToOrgReg
                          *)
  enter(A[],ad[],isOrigin,chain[])
  do <<SLOT GenAdr:descriptor>>
  exit A[]
  #);
GenOrgAdr:
  (# desc,ES: ^ASTindex; baseAdr,A: ^mch.address;
     chain: ^DH.SuperChain
  enter(baseAdr[],desc[],ES[],chain[])
  do <<SLOT GenOrgAdr:descriptor>>
  exit A[]
  #);
GenOrgAdrToOrgReg:
  (# desc,ES: ^ASTindex; baseAdr,A: ^mch.address;
     chain: ^DH.SuperChain
  enter(baseAdr[],desc[],ES[],chain[])
  do <<SLOT GenOrgAdrToOrgReg:descriptor>>
  exit A[]
  #);
GenVirtOrgAdr:
  (# desc,ES,LocalDesc: ^ASTindex; A: ^mch.address; originOff: @integer;
     chain: ^DH.SuperChain
  enter(desc[],ES[],originOff,LocalDesc[],chain[])
  do <<SLOT GenVirtOrgAdr:descriptor>>
  exit A[]
  #);
TopVirtDesc:
  (# desc: @ASTindex
  enter desc
  do (if desc.label // gram.bindingDecl // gram.virtualDecl then
         desc.son->desc; 
         desc.brother -> &SemAtt.descrip-> desc
     if);
     desc -> SemAtt.TopDesc -> desc
  exit desc
  #);   
callEntry:
  (# L: @char; desc: ^ASTindex; kind: @integer;
     chain:< 
       (# c: ^DH.superChain
       do inner;
          (if c[] = none then thisSuperChain -> c[] if)
       exit c[]
       #)    
  enter(L,desc[],kind)
  do <<SLOT callEntry:descriptor>>
  #);  
mkEntryPoint:
  (# L: @char; desc: ^ASTindex; 
     descNo: @integer; formId,EP: ^text;
     local: @boolean
  enter(L,desc[])
  do <<SLOT mkEntryPoint:descriptor>>
  exit(EP[],local)
  #);
doLoadProto:
  (# desc: ^ASTindex
  enter desc[]
  do <<SLOT doLoadProto:descriptor>>
  #);  
doLoadProtoAndAlloc:
  (# desc: ^ASTindex; kind: @integer
  enter(desc[],kind)
  do <<SLOT doLoadProtoAndAlloc:descriptor>>
  #);
ProtectCallReg:
  (* On some architectures (e.g. mips), primReg2 and
   * callreg is the same register; code like
   *    1->V1.toPrimDest;
   *    2->V2.toPrimDest;
   *    3->V3.toPrimDest;
   * may give problems, if V3 uses callReg, 
   * since 2->V2.toPrimDest will destroy callReg.
   * The above code should be written as:
   *    1->V1.toPrimDest;
   *    3->V3.toPrimDest;
   *    protectCallReg(#do 2->V2.toPrimDest #)
   * Note: V2 may perhaps also use callReg, but callReg
   * is well-defined to protectCallReg, and only the
   * final instruction assigning to primReg2 destroys callReg.
   *)
  (# <<SLOT ProtectCallReg:dopart>> #);


EvalHandler:
  (* EvalHandler is a context for evaluating evaluations;
   * an evaluation is evaluated relative to a
   *    - BaseAdr: the (base) address of the object where this evaluation
   *               has to be evaluated
   * and an
   *    - EHchain: the superChain describing the point in the AST
   *               of the evaluation
   * 
   * BaseAdr and EHchain are passed to various other routines during
   * codegeneration of an evaluation; sometimes the reference is passed
   * and sometimes a copy is passed; this is not done in a consistent matter;
   * too often a copy is passed; in general a copy must be passed if 
   * baseAdr/EHchain is modified or a new object-context is created;
   * patterns genAdr, exeObj, etc modifies their baseAdr parameter;
   * for further calls of GenEval, ExpEval, AssignValToEval, it should
   * not be necessary to copy if we are in the same object-context.
   * In some places a new EvalHandler is instantiated, but may be superflous.
   * A clean-up of this should be made; perhaps baseAdr should not
   * be a parameter to ExpEval, etc. It may be better to explicitly
   * instantiate new evalHandlers with appropriate baseAdr/EHchain when
   * needed
   *)
  (# <<SLOT EvalLib:attributes>>;

     BaseAdr: ^mch.address;
     EHchain: ^DH.superChain;
     
     GenEval: 
       (# eval: ^ASTindex; way: @ integer; 
       enter(baseAdr[],eval[],way,EHchain[])
       do <<SLOT evalBody: descriptor>>
       #); (* genEval *)
     ExpEval:
       (# EV: ^ASTindex;
          doExit: @Boolean; (* evaluate possible exit-part *)
          RV: ^EvVal
       enter(baseAdr[],EV[],doExit,EHchain[])
       do <<SLOT ExpEval:descriptor>>
       exit RV[]
       #);
     AssignValToEval:
       (# lEV,RV: ^EvVal;        
          doExit: @Boolean; (* evaluate possible exit-part *)
          EV: ^ASTindex
       enter(baseAdr[],lEV[],EV[],doExit,EHchain[])
       do <<SLOT AssignValToEval:descriptor>>
       exit RV[]
       #);
     BoolExpEval:
       (# EV: ^ASTindex;
          doExit: @Boolean; (* evaluate possible exit-part *)
          V: ^EvVal; lab: ^mch.localLab; jmpCond: @boolean
       enter(baseAdr[],EV[],doExit,EHchain[],lab[],jmpCond)
       <<SLOT BoolExpEval:doPart>>
       exit V[]
       #);
     ExitTypes: compilerlist(# element::ASTindex #);
     
     EvVal: (*EvVal DEF *) 
       (# thisVal:<
            (* a COPY of this evVal; it should have been a reference;
             * this is NOT implemented; instead released is assigned TRUE
             *)
            (# thisV: ^evVal;
            do INNER; released->thisV.released; true->released;
            exit thisV[](* this(EvVal)[]*)
            #);
          evId:< (# id: ^text do 'Unknown:' -> id[]; INNER exit id[] #);
          display:< TraceIF
            (# opId: ^text
            enter opId[]
            do evId -> xT; opId[] -> xH;
               INNER display
            #);
          evType:< (# type: @integer do INNER exit type #);
          (* 0=undefined, 1=simple, 2=ref. 3=real, 4=struc *)
          type:< (* bytecode *)
            (# D: @ASTindex; desc: ^ASTindex
            do sematt.integerDesc -> D; (* avoid overriding of integerDesc*)
               D[] -> desc[]; 
               inner
            exit desc[]
            #);
          cond:(# val: @boolean do INNER exit val (*false pr. default*)#);
          sourceIsRef: @boolean;
          (* this is a hack
           * This boolean is set to true in evbody:objRef and used in
           * txtcstval:asgToAdr
           *) 
          release:< (* release all resources used by THIS EvVal *)
            (# 
            do (if not released then
                   (if stest then
                       301->trace(#do 'EvVal:release:'->xT; display #)
                   if);
                   INNER; 
                   true -> released;
               if)
            #);
          hardRelease:< (* needed for NXoffsetsVal *) (# do inner #);
          reAlloc:<
            (* used by dobody:genIf to reallocate possible register used for
             * holding EV0 in (if EVo ...   if)
             *)
            (# do INNER; false->released #);
          released: @boolean; (* might be avoided by careful programming *)
          theReg:< (# aR: @mch.adrRegOperand do inner exit aR #);
          needExtraAreg:< booleanValue
            (* used by switch181;
             * true: this evVal may use additional A-registers
             *)
            (#
            do true -> value; (* default that may be overwritten during inner*)
               INNER
            #);
          mkReal:< (# V: ^evVal do INNER exit V[] #);
          loadVal:<
            (* used by evbody.binOp to make sure that the value does not
             * use other address registerd than thisReg and callReg *)
            (# V: ^evVal do INNER exit V[] #);
          loadVal2:<
            (* used by dobody.genif to load value into register.
             * A constant is NOT loaded into a register
             *)
            (# V: ^evVal do INNER exit V[] #);
          pushVal:<
            (* used by bytecode generator;
             * push any value on stack:
             * implemented as load to a register
             *)
            (# V: ^evVal;
               isSimpleVal: @boolean; (* distinguish char and 
                                       * text in textval
                                       *)
            enter isSimpleVal
            do this(evVal)[] -> V[]; INNER exit V[] 
            #);
          mkBetatext:< (# do inner #);
          toTmp:< 
            (* if this evVal is an object, 
             * then move its adr. from callReg to tmp. reg *)
            (# tmpPreferred: @boolean (* switch 181 *)
            enter tmpPreferred do INNER 
            #);          
          restoreTmp:< Object;
          elimReg:<
            (* eliminate thisReg and/or callReg 
             *from possible address used in V *)
            (# elimThis,elimCall: @boolean
            enter(elimThis,elimCall)
            do INNER
            #);
          toDataRegA:< Object; (* put eval in register that is to be returned
                                * to external languages such as C
                                *)
          toDataRegX:< Object;
          toDataRegY:< Object;
          toRangeReg:< Object; (* caller must release this(evVal) *)
          toDataReg:< 
            (# dReg: @mch.dataRegOperand do dReg.alloc; INNER exit dReg[] #);
          toDreg:< (* only bound in ComputedEvVal *)
            (# A: ^mch.address enter A[] do INNER #);
          toPrimDest:<
            (# pNo: @integer; primDest: ^mch.mOperand
            enter pNo
            do pNo->mch.getPrimReg->primDest[];
               INNER
            #);
          getRefAdr:<
            (* used for computed remote and switch 181 *)
            (# V: ^evVal; A: ^mch.address do INNER exit A[] #);
          getRefEval:< 
            (* used for implementing computedRemote. this(EvVal) must define a 
             * reference. The most common case is an object that exits exactly
             * one element, whcih must be a reference
             *)
            (# V: ^evVal do INNER exit V[] #);
          theAdr:< (* also used for computedRemote *)
            (# AV: ^mch.address do INNER exit AV[] #);
          adrVal: 
            (# rA: ^mch.address; V: ^evVal enter rA[] do INNER exit V[] #);
          asgToSimpleEv:<
            (#  rEvAdr:
                 (# A: ^mch.Address
                 do (rBaseAdr.copy,rEv.sonRef,false,rChain[]) 
                      -> genAdr 
                      -> A[];
                    true -> inInner
                 exit A[]
                 #); 
               rBaseAdr: ^mch.address; 
               rEv: ^ASTindex;
               V: ^evVal;
               rChain: ^DH.superChain;
               inInner: @boolean
            enter(rBaseAdr[],rEv[],rChain[])
            do (if false then INNER; if);
               loadVal -> V[];
               rEvAdr -> V.asgToAdr -> V[]
               (*(if not inInner then
                   '\*** asgToSimpleEv: no binding:'->  thisSystem.systemException
                if)*)
            exit V[]
            #);
          asgToAdr:< adrVal;
          (* assign THIS evVal to the address rA;
           * rA is the address of a simple evVal
           *)
          asgToRefAdr:< 
            (# rAbase: ^mch.address; destEV: ^ASTindex; V: ^evVal;
               rChain: ^DH.SuperChain
            enter(rAbase[],destEV[],rChain[]) do INNER 
            exit V[]
            #);
          asgToRealAdr:< adrVal; (*like asgToAdr, but rA is a real *)
          asgToRepAdr:< (* like asgToAdr, but rA is a repetition *)
            (# repSize:
                 (# error:
                      (#
                      do 'asgToRepAdr: unknown repetition size'
                           -> thisTranslate.systemException
                      #);
                    size: @integer
                 do (if rEv[] <> none then
                        (if rEv.sonRef -> sematt.repSize
                         // '1' then 1 -> size
                         // '2' then 2 -> size
                         // '4' then 4 -> size
                         // '8' then 8 -> size
                         else
                            error
                        if)
                     else
                        error
                    if)
                 exit size
                 #);
               asgToSingleElmBytecodeArray:
                 (# AI: @mch.InxRegAdr
                 do mch.duplicate; (* duplicate the array reference *)
                    (* load index 0 *)
                    (0-> mch.newCstOp,&mch.dataRegOperand[])
                      -> mch.ldCst;
                    rA.bAdr.localDesc[] 
                      -> AI.bAdr.localDesc[];
                    rA.size -> AI.size;
                    INNER;
                    (AI[],rEV[],rChain[]) -> asgToRepElm -> V[];
                 #);
               rA: ^mch.address; rEv: ^ASTindex; 
               rChain,chain1: ^DH.superChain;
               elmDesc: @ASTindex;
               V: ^evVal
            enter(rA[],rEV[],rChain[]) 
            do (rChain[],rEV.son) 
                 -> DH.theDesc 
                 -> (elmDesc,chain1[]);
               INNER
            exit V[]
            #);
          asgToRepElm:< (* assign to repetition element;
                         * used in (e1,e2,e3) -> aRep
                         *)
            (# rA: ^mch.address; rEv: ^ASTindex; rChain: ^DH.superChain;
               V: ^evVal
            enter(rA[],rEv[],rChain[])
            do inner
            exit V[]
            #);
          asgToSingleElmArray:
            (# rEV: ^ASTindex; rChain: ^DH.superChain; rA: ^mch.address;
               AI: @mch.InxRegAdr;
               V: ^evVal
            enter(rEv[],rChain[],rA[])          
            do mch.duplicate; (* duplicate the array reference *)
               (* load index 0 *)
               (0-> mch.newCstOp,&mch.dataRegOperand[])
                 -> mch.ldCst;
               rA.bAdr.localDesc[] -> AI.bAdr.localDesc[];
               rA.size -> AI.size;
               INNER;
               (AI[],rEV[],rChain[]) -> asgToRepElm -> V[];
            #);
          asgToDataReg:< 
            (# destDR: ^mch.dataRegOperand; V: ^evVal 
            enter destDR[] do INNER exit V[] 
            #);
          asgToItem:<
            (* assign this evVal to item:
             *   rDesc, its descriptor;
             *   rA,    its Mch.Address
             *)
            (# dump: TraceIf
                 (#
                 do 301 -> cTrace
                    (#
                    do 'asgToItem:' -> this(evVal).display;
                        xN;
                        '------->'->xH;
                        'rDesc='->xT; rDesc[]->xA; xN;
                        'rA='->xT; rA.display->xT; xN;
                        rChain.print;
                        mch.dumpReg
                 #)#);
               rBaseReg: @mch.AdrRegOperand; 
               rDesc: ^ASTindex;  
               rA: ^mch.address; 
               rChain: ^DH.SuperChain;
               rAx: ^mch.address
            enter(rBaseReg,rDesc[],rA[],rChain[])
            do (if stest then dump if);
               INNER;
               (if switch181 then rAx[] -> rA[] if) 
            exit rA[] (* rA may be modified *)
            #);
          asgToMethod:< (* bytecode generation - switch 182 *)
            (# enterTypes: [1]@integer; noOfArgs,next: @integer;
               rElm: ^ASTindex; rChain: ^DH.SuperChain;
            enter(enterTypes,noOfArgs,next,rElm[],rChain[])
            do inner 
            exit next
            #);
          asgToExitArgs:<
            (# rDesc: ^ASTindex; exitNo: @integer; originAdr: ^mch.address;
               rChain: ^DH.SuperChain;
               xTypes: ^ExitTypes
            enter(rDesc[],exitNo,originAdr[],rChain[])
            do &ExitTypes[]-> xTypes[]; inner                
            exit(exitNo,xTypes[])
            #); 
          asgToNXoffSets:<
            (# rA: ^mch.address; NX: ^sematt.NXoffSets; inXpart: @boolean
            enter(rA[],NX[],inXpart)
            do INNER asgToNXoffSets
            exit rA[]
            #);
          asgToInlineItem:<
            (# rDesc: ^ASTindex;  inlNX: ^evVal; rChain: ^DH.SuperChain;
               V: ^evVal
            enter(rDesc[],inlNX[],rChain[])
            do INNER  
            exit V[]
            #);
          asgToList:< (* assign THIS EvVal to the evaluation list EV*)
            (# dump: TraceIF
                 (#
                 do 301 -> cTrace
                    (#
                    do 'asgToList:' -> this(evVal).display;
                       xN;
                        '-------> EV=' -> xT; EV[] -> xA; xN;
                        'BA='->xT; BA.display->xT; xN;
                        rChain.print;
                        mch.dumpReg
                 #)#);
               toListOne: (* the list has only one element *)
                 (#
                 do EV.son->scanList
                    (# E: @ASTindex
                    do currentNode->E; 
                       (BA[],thisVal,E[],false(*OBS!*),rChain[])
                         -> AssignValToEval
                         -> V[]
                 #)#);
               BA: ^mch.address; EV: ^ASTindex; V: ^evVal;
               rChain: ^DH.SuperChain
            enter(BA[],EV[],rChain[])
            do (if stest then dump if);
               INNER
            exit V[]
            #);
          asgToCproc:< 
            (# EV,desc: ^ASTindex; V: ^evVal; 
               N: @ASTindex; externalName: ^text; extKind: @integer
            enter(EV[],externalName[],desc[],extKind)
            do INNER
            exit V[]
            #);
          asgToDispatch:<
            (# EV,desc: ^ASTindex; 
               externalName: ^text; extKind: @integer;
               V: ^evVal; 
            enter(EV[],externalName[],desc[],extKind)
            do INNER
            exit V[]
            #);
          asgToDispatchPar:<
            (# type,extKind: @integer; V: ^evVal
            enter(type,extKind)
            do inner
            #);
          asgToNewPrim:<
            (# baseA: ^mch.address;
               ev: ^ASTindex; rchain: ^DH.superChain; V: ^evVal 
            enter(baseA[],ev[],rchain[]) do INNER exit V[] 
            #);
          asgToPrimitive:<(# T: ^text; V: ^evVal enter T[] do INNER exit V[] #);
          asgToInLinePrimitive:<
            (# opCode,I1,I2: @integer; V: ^evVal
            enter(opCode,I1,I2)
            do INNER
            exit V[]
            #);
          pushCpar:< 
            (# type,extKind: @integer; size: @Mch.CstOperand; 
               univProcInfo: @Integer
            enter(type,extKind,size,univProcInfo) 
            do (if sTest then 301->trace(#do 'pushCpar:'->display #)if);
               INNER
            #);
          unMinus:< (# res: ^EvVal do INNER exit res[] #);
          notExp:< (# res: ^EvVal do INNER exit res[] #);
          mkTrue:< (* only bound in computedEvVal *)
            (# d1: @mch.dataRegOperand
            enter d1
            do INNER
            #);
          cmpBoolAndJmp:< (* generate code to test the value of this evVal
                  * such that a conditional jump may be generated
                  * as the next instruction
                  *)
            (# lab: ^mch.localLab; cond: @integer
            enter(lab[],cond)do INNER #);
          relOp:< (* only bound in computedEvVal *)
            (# op: @integer enter op do INNER #);
          cmpSig: (* lV CMP THIS value *)
            (# lV: ^evVal; op: @integer; res: ^EvVal; isref: @boolean 
            enter(lv[],op,isRef) do INNER 
            exit res[]#);
          cmp:< cmpSig  (* lV CMP THIS value *) 
            (# doCmp:(*to be exe. by all cmp-extensions except in itemEvVal*)
                 (# op1: ^mch.mOperand; op2: ^mch.registerOperand; 
                    size: @integer; deAllocOp1,deAllocOp2: @boolean;
                    dr: @mch.dataRegOperand;
                    isRef: @boolean;
                    cond: @integer
                 enter(op1[],op2[],size,deAllocOp1,deAllocOp2,isRef)
                 do dr.alloc; 
                    (dr,false,false,false)->&mkComputedEvVal->res[]; 
                    (if op
                     // 0 then 
                        (* op=0 if called from dobody:genif.
                         * no dealloc should be made
                         *)
                        dr.deAlloc; (* not used *)
                        (jmpCond,op1[],op2[],size,lab[],isRef)->mch.cmpAndJmp
                     else 
                        (if op
                         // gram.eqExp then 1 -> cond
                         // gram.neExp then 2 -> cond
                         // gram.ltExp then 3 -> cond
                         // gram.leExp then 4 -> cond
                         // gram.gtExp then 5 -> cond
                         // gram.geExp then 6 -> cond
                        if);
                        (cond,op1[],op2[],dr[],size,isRef)->mch.cmpToBool
                    if);
                    (* the deallocation is included also for
                     * if-imps. There was a problem with e.g.
                     * (if true //e1 no dealloc was made here then
                     *          //e2 then ...
                     *)
                    (* this deallocation seems complicated?*)
                    (if deAllocOp1 then
                        (# dx: ^mch.registerOperand
                        do op1[]->dx[]; dx.deAlloc (* dirty *)
                    #)if);
                    (if deAllocOp2 then op2.deAlloc if)
                 #);
               jmpCond: @integer; lab: ^mch.localLab
            enter(jmpCond,lab[])
            do INNER;
            #);
          cmpSig2:
            (# op1(*,op2*): ^mch.mOperand; op2: ^mch.registerOperand;
               size: @integer; 
               deAllocOp1,deAllocOp2: @boolean;
               isRef: @boolean
            do INNER
            exit(op1[],op2[],size,deAllocOp1,deAllocOp2,isRef)
            #);
          adrCmp:< cmpSig2 (* THIS[value] CMP rA *)
            (# rA: ^mch.address enter rA[] do INNER #);
          cstCmp:< cmpSig2(# rC: @Mch.CstOperand enter rC do INNER #);
          regCmp:< cmpSig2(# rReg: @mch.dataRegOperand enter rReg do INNER #);
          add:< BinOp; adrAdd:< AdrOp; cstAdd:< CstOp; regAdd:<RegOp;
          sub:< BinOp; adrSub:< AdrOp; cstSub:< CstOp; regSub:< RegOp;
          times:< binOp; adrTimes:< adrOp; cstTimes:< cstOp; regTimes:< regOp;
          divMod:< (* lV div/mod THIS evVal -> res *)
            (# lV: ^evVal; isDiv: @boolean; res: ^EvVal
            enter(lV[],isDiv) do INNER exit res[] #);
          adrDivMod:<
            (# rA: ^mch.address; isDiv: @boolean; 
               ddr: @mch.doubleDataRegOperand; W: ^EvVal
            enter(rA[],isDiv)
            do INNER;
               (if isDiv then
                   (ddr.dNo2,false,false,false)->mkComputedEvVal->W[]; 
                   ddr.dNo1.deAlloc
                else 
                   (ddr.dNo1,false,false,false)->mkComputedEvVal->W[]; 
                   ddr.dNo2.deAlloc
               if)
            exit W[]
            #);
          cstDivMod:<
            (# rN: @Mch.CstOperand; isDiv: @boolean; V: ^evVal 
            enter(rN,isDiv) do INNER exit V[] #);
          regDivMod:<
            (# rReg: @mch.dataRegOperand; isDiv: @boolean;
               ddr: @mch.doubleDataRegOperand; W: ^EvVal
            enter(rReg,isDiv)
            do INNER;
               (if isDiv then
                   (ddr.dNo2,false,false,false)->mkComputedEvVal->W[]; 
                   ddr.dNo1.deAlloc
                else 
                   (ddr.dNo1,false,false,false)->mkComputedEvVal->W[]; 
                   ddr.dNo2.deAlloc
               if)
            exit W[]
            #);
          orr:< binOp; adrOr:< adrOp; cstOr:< cstOp; regOr:< regOp;
          andd:< binOp; adrAnd:< adrOp; cstAnd:< cstOp; regAnd:< regOp;
          binOp: (# lV,res: ^EvVal enter lV[] do INNER exit res[] #);
          adrOp: (# rA: ^mch.address; V: ^evVal enter rA[] do INNER exit V[] #);
          cstOp: (# rN: @Mch.CstOperand; V: ^evVal enter rN do INNER exit V[] #);
          regOp:
            (# rReg: @mch.dataRegOperand; V: ^evVal
            enter rReg do INNER exit V[] #);
          sCmp:< cmpSig (* compare struc *)
            (# doCmp:
                 (# T: @text; withSP,pop: @boolean
                 do (if op
                     // gram.eqExp then 'eqS'->T
                     // gram.neExp then 'neS'->T
                     // gram.ltExp then 'ltS'->T; true->withSP
                     // gram.leExp then 'leS'->T; true->withSP
                     // gram.gtExp then 'gtS'->T; true->withSP
                     // gram.geExp then 'geS'->T; true->withSP
                    if);
                    (if mch.callRegBusy and common.switch[61] then
                        (false,true) -> mch.pushThisOrCall;
                        true -> pop
                    if);
                    (if withSP and common.switch[61] then
                        3 -> mch.initPrimCall;
                     else 2 -> mch.initPrimCall
                    if);
                    1->lV.toPrimDest;
                    INNER;
                    (*lv.release; release; 6.12.93; problmes in dobody:ifimp
                     * for (if R## // ... ) if R is an object
                     *)
                    (3,1)->mch.SPtoPrimReg;
                    T->mch.callPrim;
                    (1->mch.getPrimRes,false,false,false)
                      -> mkComputedEvval
                      -> res[];
                    (if pop then (false,true) -> mch.popThisOrCall if);
                 #)
            do INNER
            #);
          loadFloat:<(# res: ^ mch.floatRegOp do INNER exit res[] #);
          getFloatArg:<
            (# F: ^mch.mOperand (* address or FloatReg*); inFreg: @boolean
            do INNER exit(F[],inFreg)
            #);
          relRealOp:< (* only bound in computedEvVal *)
            (# op: @integer enter op do INNER #);
          rCmp:< cmpSig (* compare real *)
            (# doCmp:(*to be exe. by all cmp-extensions except in itemEvVal*)
                 (# op1: ^mch.mOperand; op2: ^mch.floatRegOp; 
                    size: @integer; deAllocOp1,deAllocOp2: @boolean;
                    dr: @mch.dataRegOperand;
                 enter(op1[],op2[],size,deAllocOp1,deAllocOp2)
                 do dr.alloc; 
                    (dr,false,false,false)->&mkComputedEvVal->res[]; 
                    (if op
                     // 0 then 
                        dr.deAlloc;  (*not used*)
                        (jmpCond,op1[],op2[],lab[],false)->mch.cmpAndJmpFloat
                     // gram.eqExp then (1,op1[],op2[],dr[])->mch.cmpToBoolFloat
                     // gram.neExp then (2,op1[],op2[],dr[])->mch.cmpToBoolFloat
                     // gram.ltExp then (3,op1[],op2[],dr[])->mch.cmpToBoolFloat
                     // gram.leExp then (4,op1[],op2[],dr[])->mch.cmpToBoolFloat
                     // gram.gtExp then (5,op1[],op2[],dr[])->mch.cmpToBoolFloat
                     // gram.geExp then (6,op1[],op2[],dr[])->mch.cmpToBoolFloat
                    if);
                    (if deAllocOp1 then
                        (# dx: ^mch.registerOperand
                        do op1[]->dx[]; dx.deAlloc (* dirty *)
                    #)if);
                    (if deAllocOp2 then op2.deAlloc if)
                 #);
               jmpCond: @integer; lab: ^mch.localLab
            enter(jmpCond,lab[])
            do INNER;
            #);
          rAdd:< binOp; (* add real *)
          rSub:< binOp; (* sub real *)
          rMult:< binOp; (* mult real *)
          rDiv:< binOp; (* div real *)
       #);

     mkConstVal:
       (# C: @Mch.CstOperand; V: ^evVal
       enter C
       do <<SLOT mkConstVal:descriptor>>
       exit V[]
       #);
     mkSimpleVal:
       (# A: ^mch.address; V: ^evVal
       enter A[]
       do <<SLOT mkSimpleVal:descriptor>>
       exit V[]
       #);
     mkRealEvVal:
       (# A: ^mch.address; V: ^evVal
       enter A[]
       do <<SLOT mkRealEvVal:descriptor>>
       exit V[]
       #);
     mkFloatEvVal:
       (# FR: ^mch.floatRegOp; V: ^evVal
       enter FR[]
       do <<SLOT mkFloatEvVal:descriptor>>
       exit V[]
       #);
     mkItemEvVal:
       (# lEV,lES,lDesc: ^ASTindex; lChain: ^DH.SuperChain;
          lA: ^Mch.Address; V: ^evVal
       enter(lEV[],lES[],lDesc[],lA[],lChain[])
       do <<SLOT mkItemEvVal:descriptor>>
       exit V[]
       #);
     mkInlineItemEval:
       (# lEv,lDesc,callingDesc: ^ASTindex; 
          lA: ^mch.address; lChain: ^DH.SuperChain;
          V: ^evVal
       enter(lEv[],lDesc[],lA[],lChain[],callingDesc[])
       <<SLOT mkInlineitemEval:doPart>>
       exit V[]
       #);
     mkRefEvVal:
       (# A: ^Mch.Address;strucRef: @boolean; sourceEv: ^ASTindex;
          lChain: ^DH.SuperChain; V: ^evVal
       enter(A[],strucRef,sourceEv[],lChain[])
       do <<SLOT mkRefEvVal:descriptor>>
       exit V[]
       #);
     mkComputedRefEvVal:
       (# Areg: @mch.adrRegOperand; strucRef: @boolean; 
          sourceEv: ^ASTindex; lChain: ^ DH.superChain; V: ^evVal
       enter(Areg,strucRef,sourceEv[],lChain[])
       do <<SLOT mkComputedRefEvVal:descriptor>>
       exit V[]
       #);
     mkListVal:
       (# evl: ^ASTindex; thisBaseAdr: ^mch.address; 
          V: ^evVal; lChain: ^DH.SuperChain;
          (* evl must be evaluated relative to thisBaseAdr *)
       enter(evl[],thisBaseAdr[],lChain[])
       do <<SLOT mkListVal:descriptor>>
       exit V[]
       #);
     mkComputedEvVal:
       (# dr: @Mch.DataRegOperand; 
          isAreg,strucRef,comTxt: @boolean; 
          V: ^evVal
       enter(dr,isAreg,strucRef,comTxt)
       do <<SLOT mkComputedEvVal:descriptor>>
       exit V[]
       #);
     
     mkComputedEvVal2:
       (# dr: @Mch.DataRegOperand; 
          isAreg,strucRef,comTxt: @boolean; 
          V: ^evVal;
          lDesc: ^ASTindex; (* type needed by bytecode *)
       enter(dr,isAreg,strucRef,comTxt,lDesc[])
       do <<SLOT mkComputedEvVal2:descriptor>>
       exit V[]
       #);
     
     mkComputedAdrVal:
       (# dr: ^mch.RegisterOperand; isAreg,strucRef: @boolean; V: ^evVal
       enter(dr[],isAreg,strucRef)
       do <<SLOT mkComputedAdrVal:descriptor>>
       exit V[]
       #);
     mkTxtCstEvVal:
       (# T: @text; V: ^ EvVal
       enter T
       do <<SLOT mkTxtCstEvVal:descriptor>>
       exit V[]
       #);
     mkTxtCstEvVal2:
       (# T: @text; 
          cTxt: ^mch.dataRegOperand; isCallBack: @boolean;
          V: ^EvVal; 
       enter(T,cTxt[],isCallBack)
       do <<SLOT mkTxtCstEvVal2:descriptor>>
       exit V[]
       #);
     mkTxtVarEvVal:
       (# A:^mch.address; evalKind: @integer; (* repValEval or repRefEval *)
          lowEv,highEv: @mch.dataRegOperand; V: ^evVal;
          EV: ^ASTindex; slice: @boolean
       enter(A[],EV[],evalKind,slice)
       do <<SLOT mkTxtVarEvVal:descriptor>> 
       exit V[]
       #);
     mkDoubleEvVal:
       (# drX,drY: @mch.dataRegOperand; V: ^evVal
       enter(drX,drY)
       do <<SLOT mkDoubleEvVal:descriptor>>	
       exit V[]
       #);
     mkNXoffSetsVal:
       (# baseAdr: ^mch.address; thisVal: ^ASTindex; 
          NXO: ^sematt.NXOffSets;
          V: ^evVal;
          isEnter: @boolean
       enter(baseAdr[],thisVal[],NXO[],isEnter)
       do <<SLOT mkNXoffSetsVal:descriptor>>
       exit V[]
       #)
  do INNER
  #);
