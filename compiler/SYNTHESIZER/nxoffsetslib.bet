ORIGIN '../CHECKER/sematt';
LIB_ITEM 'betacodegen';
---NXoffSetsLib:attributes---
SetOffSets:
  (# desc: ^ASTindex;
     isEnter: @boolean;
     chain: ^BV.superChain
  enter(desc[],isEnter,chain[])
  do (*desc->BV.newSingle -> chain[];*)
     (desc[],isEnter,true,chain[]) -> GeneralDesc;
     178->trace
     (#
     do (if isEnter then 'SetNOffSets:\n'->xT else 'SetXoffSets:\n'->xT if);
        desc[]->xA; dump 
     #)
  #);
GeneralDesc:
  (# NXscan: @NXscanner;
     
     AllocPrefNX: @
       (* perhaps tricky - see docheck:GetPreDesc *)
       (# preDesc: @ASTindex; 
       do (if pref.label = gram.prefix then
              chain[] -> BV.ENC -> chain1[];
              (*(pref.son,chain1[]) -> GetTheDesc -> (preDesc,chain1[]);*)

              pref.son -> sematt.descrip -> preDesc;
              
              chain[] -> BV.PRE -> chain1[];
              
              (preDesc[],isN,outer,chain1[]) -> GeneralDesc
          if)
       #);
     pref,mainP,att,entP,doP,exitP: ^ASTindex;
     desc,EV: ^ASTindex; E1: @ASTindex;
     isN,outer: @boolean;
     chain,chain1: ^BV.superChain;
     PL: @integer
  enter(desc[],isN,outer,chain[])
  do 179->trace(#do 'GeneralDesc:'->xT; desc[] -> xA; (*chain.print*) #);
     desc[]
       -> DescSonsRef
       -> (pref[],mainP[],att[],entP[],doP[],exitP[]);
     AllocPrefNX;
     (if isN then
         (if entP.label <> gram.empty then
             (if outer then entP.NXoff -> startOff if);
             entP.son -> E1;
             (E1[],true,desc[],chain[],outer) -> AllocNXtmp;
         if)
      else
         (if exitP.label <> gram.empty then
             (if outer then exitP.NXoff -> startOff if);
             exitP.son -> E1;
             (E1[],false,desc[],chain[],outer) -> AllocNXtmp;
     if)if)
  #);

AllocNXtmp:
  (# EV,encDesc: ^ASTindex; EVx: @ASTindex; isN: @boolean;
     AllocForObj: 
       (# E: ^ASTindex;
          E1,desc: @ASTindex;  MN: @integer; isV: @integer;
          pref,mainP,att,entP,doP,exitP: ^ASTindex;
          chain1: ^BV.superChain
       enter E[]
       do 179->trace(#do 'AllocForObj:'-> xT; E[]->xA #);
          E.son -> E1;
          (if E1.label = gram.remotePrimitive then
              (E[],chain[]) -> AllocVal
           else
              (*(encDesc,E1) -> ActualDesc -> (desc,MN);*)
              (* E1 -> sematt.descrip -> (desc,mn);
               (if desc.label
               // gram.virtualDecl // gram.bindingDecl 
               // gram.unExpanded // gram.variablePattern then
               (encDesc,E1) -> BV.ActualDesc -> (desc,mn)
               if);*)
              (chain[],E1) -> BV.theDesc -> (desc,MN,chain1[],isV);
              (if (E1->sematt.SimpleOrRep)
               // gram.dynamicItem // gram.dynamicComponent
               // gram.variablePattern
               // gram.staticItem //gram.staticComponent then 
                  179->trace(#do 'IsRep:'-> xT; E1[]-> xA #);
                  (E[],chain[]) -> AllocRep
               else
                  L:
                    (if (desc -> sematt.descKind) 
                     // sematt.standardKind // sematt.constKind then
                        (# D: @ASTindex
                        do E.son -> D;
                           (if outer and (D.label = gram.nameApl) then
                               (if D.on = 0 then 
                                   D.dclRef -> D;
                                   (E[],none,D.off,Desc.size) -> MarkVal;
                                   leave L
                        if)if)#);
                        (E[],chain[]) -> AllocVal
                     else
                        (desc[],isN,false,chain1[]) -> GeneralDesc
          if)if)if)
       #);
     chain: ^BV.superChain; outer: @boolean
  enter(EV[],isN,encDesc[],chain[],outer)
  do 179->trace(#do 'AllocNXtmp:'-> xT; EV[]-> xA; (*chain.print*) #);
     L:
       (if EV.label 
        // gram.assignmentEvaluation then
           (* allocate simple value or list of simple values??*)
           EV.son -> EV;
           (if not isN then EV.brother -> EV if);
           (*(EVx[],true,encDesc[],chain[],outer) -> AllocNXtmp*)
           179->trace(#do 'AllocNXtmp2:'-> xT; EV[]-> xA;#);           
           restart L
        // gram.insertedItem 
        // gram.objectDenotation 
        // gram.dynamicItemGeneration 
        // gram.dynamicComponentGeneration then
           (* where do we store the list of offsets?
            * the following call will override in object EV
            * and not in the object with the enter/exit element.
            * We probably have to enumerate whenever being used
            *)
           EV[] -> AllocForObj
        // gram.computedObjectEvaluation then 
           'AllocNXtmp:ComputedEv'->putline
        // gram.objectReference 
        // gram.structureReference then
           (# D: @ASTindex
           do EV.son -> D; D.son->D;
              178->trace(#do 'nxOff:ref:'->xT; outer->xB; D.on->xI; 
                           100->switchOn; D[]->xA; 100->switchOff 
                        #);
              (if outer AND (D.label = gram.nameApl) AND (D.on = 0) then
                  D.dclRef -> D;
                  (if D.access = common.direct then
                      (EV[],chain[]) -> AllocRef
                   else
                      (EV[],chain[],D.off) -> MarkRef
                  if)
               else 
                  (EV[],chain[]) -> AllocRef
           if)#)
        // gram.evalList then 
           EV.son -> EVx; 
           EVx -> scanList
           (# E: ^ASTindex 
           do &ASTindex[] -> E[]; currentNode-> E; 
              (E[],isN,encDesc[],chain[],outer) -> AllocNXtmp ;;
              179->trace(#do 'List:'->xT; (*chain.print*) #)
           #)
       // gram.integerConst // gram.noneExp then 
          (* skip if outer level - no attribute space reserved.
           * Check this for other categories as well
           *)
          (EV[],chain[]) -> AllocVal
        // gram.textConst then
           (EV[],chain[]) -> AllocVal
        // gram.repetitionSlice then
           (EV[],chain[]) -> AllocRef
        // gram.notExp (* perhaps just alloc a boolean *)
        // gram.unaryMinusExp // gram.unaryPlusExp then
           (EV[],chain[]) -> AllocVal
        // gram.unaryPrimitiveExp 
        // gram.primitive then
           (EV[],chain[]) -> AllocVal
        else
           (if (EV.label -> EvalClass) = EvalClass.binOp then
               (EV[],chain[]) -> AllocVal
            else
               'NXtmp NOT found' -> putline
           if)
       if)
  #)
