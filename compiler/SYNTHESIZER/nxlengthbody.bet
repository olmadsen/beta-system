ORIGIN 'nxlength'
---getnxlength:dopart---
do (# 
      getGeneralDescLength: integerValue
        (# (*NXscan: @NXscanner;*)
           
           GetSuperNXlength: @ integerValue
             (* perhaps tricky - see docheck:GetPreDesc *)
             (# preDesc: @ASTindex; 
             do (if pref.label = gram.prefix then
                    chain[] -> BV.ENC -> chain1[];
                    (*(pref.son,chain1[]) -> GetTheDesc -> (preDesc,chain1[]);*)

                    pref.son -> sematt.descrip -> preDesc;
                    
                    chain[] -> BV.PRE -> chain1[];
                    
                    (preDesc[],isN,chain1[]) -> getGeneralDescLength -> value
                if)
             #);
           pref,mainP,att,entP,doP,exitP: ^ASTindex;
           desc,EV: ^ASTindex; E1: @ASTindex;
           isN: @boolean;
           chain,chain1: ^BV.superChain;
           superLength: @integer;
           gNXl: ^ |getNXlength; more: @boolean
        enter(desc[],isN,chain[])
        do 179->trace(#
                     do 'GeneralDesc:'->xT; desc[] -> xA;
                        'isN: ' -> xT; isN -> xB;
                        (*chain.print*)
                     #);
           (if desc->sematt.descKind
            // sematt.standardKind then 
               1 -> value;
               (if true then
                   desc[] -> elmDesc[]
                else
                   sematt.integerDesc[] -> elmDesc[];
               if);
             (*  SUSPEND*)
            // sematt.constKind then
               1 -> value;
               sematt.integerDesc[] -> elmDesc[];
               1->trace(#
                       do 'nxlength:elmDesc for constDesc'
                          ' may not be correct: ' -> xT;
                          desc[] -> xAF
                       #);
              (* SUSPEND;*)
            else
               desc[]
                 -> DescSonsRef
                 -> (pref[],mainP[],att[],entP[],doP[],exitP[]);
               GetSuperNXlength -> superLength;
               &|getNXlength[] -> gNXl[];
               (if isN then
                   (if entP.label <> gram.empty then
                       entP.son -> E1;
                       (E1[],true,chain[]) -> gNXl -> more;
                       L: (if more then
                              gNXl.elmDesc[] -> elmDesc[]; 
                              gNXL.thisEV[] -> thisEV[];
                              gNXL.thisChain[] -> thisChain[];
                              gNXL.isRep -> isRep;
                              gNXL.isStruc -> isStruc;
                              SUSPEND;
                              false -> isRep -> isStruc; 
                              gNXL -> more;
                              restart L
                          if)   
                   if)
                else
                   (if exitP.label <> gram.empty then
                       exitP.son -> E1;
                       179->trace(#
                                 do 'gdlA:'->xT; E1[] -> xA;
                                    'isN: ' -> xT; isN -> xB;
                                 #);
                       (E1[],false,chain[]) -> gNXl -> more;
                       L: (if more then
                              179->trace(#
                                        do 'gdl:'->xT; gNXl.thisEV[] ->xA;
                                           gNXl.elmDesc[] -> xAF;
                                           'isN: ' -> xT; isN -> xB;
                                        #);
                              gNXl.elmDesc[] -> elmDesc[];
                              gNXl.thisEV[] -> thisEV[];
                              gNXL.thisChain[] -> thisChain[];
                              gNXL.isRep -> isRep;
                              gNXL.isStruc -> isStruc;
                              SUSPEND;
                              179->trace(#
                                        do 'gdl:after:suspend:'-> xT
                                        #);
                              false -> isRep -> isStruc;
                              gNXL -> more;
                              restart L
                          if);
                       179->trace(#do 'gdl:end:'->xT; 'isN: ' -> xT; isN -> xB;#);
               if)if);
               superLength + value -> value
           if)
        #);

      xAllocForObj: integerValue
        (# E: ^ASTindex;
           E1,desc: @ASTindex;  
           pref,mainP,att,entP,doP,exitP: ^ASTindex;
           chain1: ^BV.superChain
        enter E[]
        do 179->trace(#do 'AllocForObj:'->xT; E[]->xA; 'isN:'->xT; isN->xB #);
           E.son -> E1;
           (if E1.label = gram.remotePrimitive then
               1 -> value
            else
               (chain[],E1) -> BV.theDesc -> (desc,chain1[]);
               (if (E1->sematt.SimpleOrRep)
                // gram.dynamicItem // gram.dynamicComponent
                // gram.variablePattern
                // gram.staticItem //gram.staticComponent then 
                   179->trace(#do 'IsRep:'-> xT; E1[]-> xA #);
                   1 -> value; 
                   &ASTindex[] -> elmDesc[];
                   desc -> elmDesc;
                   true -> isRep;
                   SUSPEND;
                   false -> isRep;
                else
                   L:
                     (if (desc -> sematt.descKind) 
                      // sematt.standardKind // sematt.constKind then
                         1 -> value;
                         desc[] -> elmDesc[];
                         179->trace(#
                                   do 'AllocForObj:simple:'->xT;
                                      elmDesc[] -> xAF;
                                      'isN: ' -> xT; isN -> xB;
                                   #);
                         SUSPEND;
                         179->trace(#
                                   do 'AllocForObj:simple:after:suspend: '->xT;
                                      'isN: ' -> xT; isN -> xB;
                                   #)
                      else
                         (desc[],isN,chain1[]) 
                           -> getGeneralDescLength
                           -> value
           if)if)if)
        #);
      
   do 179->trace(#
                do 'AllocNXtmp:'-> xT; EV[]-> xA;
                   'isN: ' -> xT; isN -> xB;
                   EV.label -> xI
                   (*chain.print*) 
                #);
      (* default values that may be overwritten *)
      true -> more;
      EV -> EVa;
      EV[] -> thisEV[];
      chain[] -> thisChain[];
      L:
        (if EVa.label 
         // gram.assignmentEvaluation then
            (* allocate simple value or list of simple values??*)
            EVa.son -> EVa;
            (if not isN then EVa.brother -> EVa if);
            restart L
         // gram.insertedItem 
         // gram.objectDenotation 
         // gram.dynamicItemGeneration 
         // gram.dynamicComponentGeneration then
            (* where do we store the list of offsets?
             * the following call will override in object EVa
             * and not in the object with the enter/exit element.
             * We probably have to enumerate whenever being used
             *)
            EVa[] -> xAllocForObj -> value;
            179->trace(#do 'after:AllocForObj:'->xT;'isN: ' -> xT; isN -> xB; #)
         // gram.computedObjectEvaluation then 
            'AllocNXtmp:ComputedEv'->putline
         // gram.objectReference then
            1 -> value;
            &ASTindex[] -> elmDesc[];
            301 -> trace(#
                        do 'nxlength:EVa:'->xT; EVa[] -> xA;
                        #);
            (chain[],(EVa.sonRef).son)->BV.theDesc->(elmDesc,LC[]);
            
            301 -> trace(#
                        do 'nxlength:elmDesc:'->xT; elmDesc[] -> xA
                        #);
            SUSPEND
         // gram.structureReference then
            1 -> value;
            &ASTindex[] -> elmDesc[];
            301 -> trace(#
                        do 'nxlength:EVa:strucRef:'->xT; EVa[] -> xA;
                        #);
            (chain[],EVa.son) -> BV.theDesc -> (elmDesc,LC[]);
            
            301 -> trace(#
                        do 'nxlength:StrucRef:elmDesc:'->xT; elmDesc[] -> xA
                        #);
            true -> isStruc;
            SUSPEND
         // gram.evalList then 
            (# EVx: @ASTindex
            do 179->trace(#
                         do 'List:'->xT; EVa[] -> xA;'isN: ' -> xT; isN -> xB;
                         #);
               EVa.son -> EVx; 
               EVx -> scanList
               (# E: ^ASTindex ; V: @integer; 
                  gNXl: ^| getNXlength; more: @boolean
               do &ASTindex[] -> E[]; currentNode-> E;
                  179->trace(#
                            do 'listElm:A:'->xT; E[] -> xA;'isN: ' -> xT; isN -> xB;
                            #);
                  &|getNXlength[] -> gNXl[];
                  (E[],isN,chain[]) -> gNXl -> more;
                  L:
                    (if more then
                        179->trace(#
                                  do 'listElm:B:'->xT; 
                                     gNXL.thisEV[] -> xA;
                                     gNXl.elmDesc[] -> xAF;
                                     'isN: ' -> xT; isN -> xB;
                                  #);
                        gNXl.elmDesc[] -> elmDesc[];
                        gNXL.thisEV[] -> thisEV[];
                        gNXL.isRep -> isRep;
                        gNXL.isStruc -> isStruc;
                        SUSPEND;
                        false -> isRep -> isStruc;
                        gNXL->more;
                        restart L
                    if);
                  value + V -> value;
                  179->trace(#do 'EndList:'->xT;
                               'isN: ' -> xT; isN -> xB; (*chain.print*) 
                            #)
            #)#)
         // gram.integerConst then 
            (* skip if outer level - no attribute space reserved.
             * Check this for other categories as well
             *)
            1 -> value;
            sematt.integerDesc[] -> elmDesc[];
            SUSPEND
         // gram.noneExp then 
            1 -> value;
            sematt.superObject[] -> elmDesc[];
            true -> isNone;
            SUSPEND;
            false -> isNone;
         // gram.textConst then
            1 -> value;
            sematt.charDesc[] -> elmDesc[];
            SUSPEND;
         // gram.repetitionSlice then
            (* EVa = <AttDen> '[' <eval> ':' <eval> ']' *)
            1 -> value;
            &ASTindex[] -> elmDesc[];
            (chain[],EVa.son) -> BV.theDesc -> (elmDesc,chain1[]);
            true -> isRep;
            SUSPEND;
            false -> isRep
         // gram.notExp (* perhaps just alloc a boolean *)
         // gram.unaryMinusExp // gram.unaryPlusExp 
         // gram.unaryPrimitiveExp 
         // gram.primitive then
            1 -> value;
            sematt.integerDesc[] -> elmDesc[];
            SUSPEND
         else
            (if (EVa.label -> EvalClass) = EvalClass.binOp then
                (# gNXl1,gNXl2: ^|sematt.getNXlength; 
                   xmore: @boolean;
                   EV1,EV2: @ASTindex
                do EV.son -> EV1; EV1.brother -> EV2;
                   &|sematt.getNXlength[] -> gNXl1[];
                   (EV1[],false,chain[])
                     -> gNXl1;
                   &|sematt.getNXlength[] -> gNXl2[];
                   (EV1[],false,chain[])
                     -> gNXl2;
                   (if true (* not the best way *)
                    // (gNXl1.elmDesc[]<>none)
                       and 
                       (gNXl1.elmDesc->sematt.charDesc.equal)
                    // (gNXl2.elmDesc[]<>none)
                       and
                       (gNXl2.elmDesc->sematt.charDesc.equal) then
                       sematt.charDesc[] -> elmDesc[]
                    else
                       sematt.integerDesc[] -> elmDesc[];
                   if);
                   1 -> value;

                   SUSPEND   
                #);
             else 
                'NXtmp NOT found' -> putline
            if)
        if);
      false -> more;
      179->trace(#do 'end:getNXlength:'->xT;'isN: ' -> xT; isN -> xB; #);
   #)
   
