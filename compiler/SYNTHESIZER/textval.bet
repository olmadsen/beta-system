ORIGIN 'evlib';
LIB_ITEM 'betacodegen';
INCLUDE 'auxlib';
INCLUDE 'computedval';
INCLUDE 'signature';
---mkTxtCstEvVal:descriptor---
(# TV: ^TxtCstVal
do &TxtCstVal[]->TV[]->V[]; T->TV.T; 
#)
---mkTxtCstEvVal2:descriptor---
(# TV: ^TxtCstVal
do &TxtCstVal[]->TV[]->V[]; 
   T->TV.T; cTxt[] -> TV.cTxt[]; isCallBack -> TV.callback
#)
---mkTxtVarEvVal:descriptor---
(# TV: ^TxtVarVal
do &TxtVarVal[]->TV[]->V[]; 
   (if A.access <> common.direct then 
       (if not (switch180 or switch181) then 
           'mkTxtVarVal:base:indirect:notSwitch180/181'
             -> thisTranslate.systemException
       if);
       A.toTmp->A[]
   if);
   (A[],EV[],evalKind,slice)->TV
#)
---EvalLib:attributes---
TxtCstVal: EvVal
  (# thisVal::<(#V: @TxtCstVal do T->V.T; evalKind->V.evalKind; V[]->thisV[]#);
     evId:: (# do 'TxtCstVal:'-> id[] #);
     display::< (#do ThisT->xT #); 
     thisT: (#exit T[]#);
     release::(#do (if cTxt[] <> NONE then cTxt.deAlloc if)#);
     loadVal::<(#do this(TxtCstVal)[]->V[] #);
     loadVal2::<(#do this(TxtCstVal)[]->V[] #);
     valuePushed: @boolean;
     pushVal:: 
       (# pushtext:< (# do inner #);
       do '!TxtCstVal:pushVal'->mch.comment;
          (if isSimpleVal and not T.isBetaChar then 
              (* we sometimes don't know if the type is char or text *)
              (if not common.switch[188] then
                  '\nOBS! textval:pushVal: converted type char to text'
                    -> putline;
              if);
              false -> isSimpleVal 
          if);
          (if isSimpleVal then
              true -> this(txtCstVal).isSimpleVal;
              (1,sematt.cExt,0,0) -> pushCpar;
              (0,false,false,false) -> mkComputedEvVal -> V[];
           else
              (common.textXpar,sematt.cExt,0,0) -> pushCpar;
              (if true then 
                  (if not valuePushed then
                      pushText;
                      true -> valuePushed;
                  if)
               else
                  'ExternalString2BetaText'->mch.callPrim;
              if)
          if)
       #);
     mkBetaText::
       (# 
       do (if not isSimpleVal then
              'ExternalString2BetaText'->mch.callPrim
          if)
       #);
     toDataRegA::<(#do (thisChOp,mch.DataRegA[])->mch.ldCst#);
     toDataRegX::<(#do (thisChOp,mch.DataRegX[])->mch.ldCst#);
     toDataRegY::<(#do (thisChOp,mch.DataRegY[])->mch.ldCst#);
     toRangeReg::<
       (#do (thisCh->mch.newCstOp,mch.dataRegB[])->mch.ldCst#);
     toDataReg::< (#do (thisCh->mch.newCstOp,dReg[])->mch.ldCst #);
     toPrimDest::
       (# 
       do pNo->primDest.toPrimDest
          (*(if primDest.isPrimRegOp then
              (thisCh->mch.newCstOp,primDest[])->mch.ldCst
           else
              (thisCh->mch.NewCstOp,primDest[],4) -> mch.stCst
          if)*)
       #);
     evType::<
       (#
       do (if T.length = 1 then
              1 -> type (* char assumed *)
           else
              5 -> type (* char rep *)
          if)
       #);
     type:: 
       (# 
       do (if T.length = 1 then
              sematt.charDesc[] -> desc[] 
           else
              sematt.textDesc[] -> desc[] 
          if)
       #);
     mkReal::< 
       (# T: @text; thisInt: @(# I: @integer do thisCh->I exit I #)
       do thisCh->T.putInt; '.0'->T.puttext; 
          (T[],thisInt) -> mch.floatConst->mkFloatEvVal->V[] 
       #);
     asgToAdr::<
       (# max: @integer; pop: @boolean; EH: @evalHandler
       do 301->trace(#
                  do 'asgToAdr:rA: ' -> display; rA.display->xT
                  #);
          (if not sourceIsRef then
              (if switch182 then
                  (rA.bAdr.localDesc[]->theGen.fieldSignature).asText
                    -> rA.fieldType[]
              if);
              301->trace(#
                        do rA.display -> xT
                        #);
              mch.nop;
              (thisChOp,rA[],rA.size)->mch.stCst;
              this(TxtCstVal)[]->V[];
              rA.freeAdr
           else
              rA[] -> loadtextConst;
              (rA[],false,none,EHchain[])->mkRefEvval->V[]
              (* do we ever come here? In this case chain is for the left-side,
               * NOT for the right-side - this may be a problem??
               * However, the constructed RefEvVal will have sourceEV=none
               * (here destEV here), chain will probably never be used?
               *)
          if);
          (*rA.freeAdr - see FEJL/text2ref.bet *)
       #);
     asgToRefAdr::<
       (# rA: ^mch.address; dEV,dDesc: @ASTindex; mn,dKind,max: @integer;
          RC: ^DH.superChain; found,pop: @boolean;
          textSig: ^text
       do 301->trace(#
                    do 'txtcstval:asgToRefAdr:'->xT; destEv[] -> xA; xN;
                       rAbase.display -> xT;
                    #);
          (***** skud!! *)
          (if not sourceIsRef and not switch182 then 
              (* assign to a char var - not possible? *)
              
              cError(#do 'txtCstVal:asgToRefAdr'->xT #);
              this(TxtCstVal)[]->V[]
           else
              destEV.son->dEV;
              (if not switch182 then
                  (rAbase.copy,dEV[],false,rChain[]) -> genAdr -> rA[];
                  rA[] -> loadTextConst;
                  (rChain[],dEV) -> DH.theDescForm -> (dDesc,mn,RC[],dKind);
               else
                  rAbase.copy -> rA[];
                  (rChain[],dEV) -> DH.theDescForm -> (dDesc,mn,RC[],dKind);
                  (*'ExternalString2BetaText'->mch.callPrim;*)
                  '!txtcstval:asgRefAdr1'->mch.comment;
                  (if switch182 then
                      (if dDesc -> sematt.textDesc.equal then
                          sematt.textDesc[]
                            -> theGen.mkSignature 
                            -> textSig[];
                       else
                          (* we should perhaps test that this is in fact 
                           * an external String
                           *)
                          (if isJava then
                              'Ljava/lang/String;' -> textSig[]
                           else
                              '[mscorlib]System.String'-> textSig[]
                          if)
                      if);
                      (none,false,textSig[],textSig[]) 
                        -> rA.asgRefAdr;
                  if);
                  '!txtcstval:asgRefAdr2'->mch.comment;
              if);

              (if RC.ptnForm >= sematt.virtualForm then 
                  (* virtual QUA-check is needed *)
                  (dEV[],dDesc[],raBase[],rchain[])
                    -> virtualQua
                  (# doAssign::
                       (# dest: @mch.adrRegOperand
                       do this(asgToRefAdr).rA[] -> rAx[]; 
                          (*check why the rA of doAssign must be overwritten!*)
                          common.direct->rAx.access;
                          rAx.toReg2->dest;
                          dest[]->destX[]
                       #)
                  do
                   #)
               else
                  (*312->trace(#do 'txtcst:asgtorefadr'->xT; 
                   sematt.textDesc[] -> xA; dDesc[] -> xA #);*)
                  (sematt.textDesc[],dDesc[])->sematt.chkQua->(mn,found);
                  (if not found then 
                      (if not 
                          (switch182 and (dDesc[]->theGen.isExternalString))
                          then
                          (* qua-check is needed, but should NEVER happen! *)
                          cError(#do 'text2ref:missing qua-check'->xT #);
                  if)if)
              if);
              (if switch182 then
                  (0,false,dEv[],rChain[])->mkComputedRefEvVal->V[];
               else
                  (rA[],false,sematt.textDesc[],rChain[])->mkRefEvval->V[]
              if)
          if);
          (*rA.freeAdr -- see FEJL/text2ref.bet *)
          (*312->trace(#do 'txtcst:asgtorefadr2'->xT; 
           sematt.textDesc[] -> xA; dDesc[] -> xA #);*)
       #);
     asgToRepAdr::<
       (# max: @integer; isWtext: @boolean;
       do (if stest then
              301->trace(#do 'txtcstval:asgToRepAdr: '->xT;
                           'rEv='->xT; rEv[]->xA; 
                           ' rA='->xT; rA.display->xT; 
          #)if);
          false -> isWtext; (* currently no handling of wText *);
          (if T.isBetaChar then (*rA.size > 1 then*)
              (rA[],rEV[],rChain[]) -> ((thisChOp).C -> mkConstVal).asgToRepAdr
           else
              (if common.switch[61] then
                  protectCallReg
                  (# dr: @mch.DataRegOperand;
                     A: @mch.RegAdr
                  do release; (* we MUST dealloc cTxt before pushReg, since
                               * this will confuse callBack
                               * (Inconsistent stack frame size for CB entry)
                               *)
                     mch.pushReg -> max; (* 6.12.95 *)
                     
                     (if (cTxt[] = NONE) and not callBack then
                         (rA[],0) -> CopyT
                         (#
                         do (T[],1,isWtext)->gen.TextConst;
                            (4,1) -> mch.SPtoPrimReg
                         #)
                      else
                         (* (cTxt[] <> NONE) or callBack *)
                         (rA[],3) -> CopyT
                         (#
                         do 1 -> cTxt.toPrimDest;
                            (* Set BetaStackTop *)
                            A.reg.alloc;
                            ('BetaStackTop' -> mch.newTextOp,A.reg[]) 
                              -> mch.gLea;
                            4 -> A.toPrimDest;
                            A.freeAdr
                         #)-> dr;
                         (* copy dr to callReg and thisReg *)
                         (dr[],mch.callRegOp[]) -> mch.cpReg;
                         (dr[],mch.thisRegOp[]) -> mch.cpReg
                     if); 
                     max->mch.popReg 
                  #)
               else
                  (if switch182 then
                      pushVal
                      (# pushText::(#do 'Text2CharArray'->mch.callPrim #)#);
                      rA.bAdr.localDesc[] 
                        -> theGen.mkArraySignature 
                        -> rA.fieldType[];
                      (&mch.dataRegOperand[],rA[]) -> mch.stVal
                   else
                      (rA[],0) -> CopyT(#do (T[],1,isWtext)->gen.TextConst #)
                  if)
          if)if); 
          this(TxtCstVal)[]->V[]; rA.freeAdr
       #);
     asgToRepElm::<
       (# elmDesc: ^ASTindex
       do (if stest then 
              301->trace(# 
                        do 'asgToRepElm: '-> display;
                           '  rEv: ' -> xT; rEv[]->xA; xN;
                           rA.bAdr.localDesc[] -> xAF; xN;
                           'rA: ' -> xT; rA.display -> xT;
                        #)
          if);
          (if switch182 (*and (rEV[]=none)*) then
              (rEV[],rChain[],rA[]) -> getElmDesc -> elmDesc[];
              301->trace(#
                      do 'elmDesc:'->xT; elmDesc[] -> xAF
                      #);
              (if elmDesc.label = gram.objectDescriptor then
                  (if elmDesc->sematt.isStandard then
                      (* text6 assumed *)
                      rA[] -> asgToAdr ;
                   else
                      (common.textXpar,sematt.cExt,0,0) -> pushCpar;
                      'ExternalString2BetaText'->mch.callPrim;
                      (mch.adrTop[],rA[]) -> mch.stVal
                  if)
               else
                  1->trace(#do 'asgToRepElm:Illegal descriptor' -> display #)
              if)
           else
              (if rEv.son -> sematt.SimpleOrRep
               // gram.dynamicItem then               
                  (* we assume R: [e] ^text *)
                  rA[] -> loadTextConst
               // gram.staticItem then        
                  (* we assume R: [e] @char *)
                  rA[] -> asgToAdr 
               else
                  (if switch182 then
                      (* we assume a call from asgToMethod, but ?? *)
                      rA[] -> asgToAdr 
                   else
                      'TxtCstVal:asgToRepElm:illegalRepetition'
                        -> thisTranslate.systemException
                  if)
          if)if);
          this(TxtCstVal)[] -> V[]
       #);
     asgToItem::<
       (* C -> EV.N1 *)
       (# nScan: @ | scanNadr; 
       do (rDesc[],rA[],0,rChain[],true) -> nScan;
          this(TxtCstVal)[] -> nScan.AsgToNelm -> rAx[];  
          nScan.reset
       #);
     asgToMethod::
       (# desc: ^ASTindex; rA: ^mch.address
       do 301 -> trace(#
                      do 'asgToMethod:rElm'->display; rElm[] -> xA; xN;
                         'next:'->xT; next->xI;
                         'range: '->xT; enterTypes.range -> xI;
                         'type: ' -> xT; enterTypes[next] -> xI; 
                         (for i:enterTypes.range repeat
                              ', entertype'->xT;
                              i->xI;
                              '='->xT;
                              enterTypes[i]->xI;
                         for);
                      #);
          (if (0 < next) and (next <= enterTypes.range) then
              (if enterTypes[next]
               // 2  (* char *)  // 1 (* int32 *)   then
                  '! BETA char' -> mch.comment;
                  thisChOp -> mch.pushClong
               // 11 (* we may apparently sometimes get a reference
                      * even if it is a text ????
                      *)
               // 14 (* text ref *) then
                  '! push text const and convert to beta text' 
                    -> mch.comment;
                  pushVal
                  (# pushtext::(#do 'ExternalString2BetaText'->mch.callPrim#)#);
               // 12 (* repetition *) then
                  baseAdr.copy -> rA[];
                  (rElm[],rChain[],rA[]) -> getElmDesc -> desc[];
                  301->trace(#
                            do 'asgTomethod:rep:rElm:'->xT; rElm[] -> xA; xN;
                               'desc: ' -> xT; desc[] -> xAF
                            #);
                  (if sematt.charDesc->desc.equal then
                      '!Char rep ' -> mch.comment;
                      pushVal
                      (# pushtext:: (#do 'Text2CharArray'->mch.callPrim #)#);
                   else
                      desc.size -> rA.size;
                      desc[] -> rA.bAdr.localDesc[];
                      (desc[],true,false,rA.size,1,rA[],true) -> asgToNewRep
                      (#
                      do 301->trace(# 
                                   do 'asgToNewRep: ' -> xT;
                                      rA.bAdr.localDesc[] -> xAF
                                   #);
                         (rElm[],rChain[],rA[]) -> asgToSingleElmArray
                         (#
                         do AI.bAdr.localDesc[]
                              -> theGen.mkSignature 
                              -> AI.fieldType[];
                         #)
                  #)if);
               // 13 (* java/lang/String *) then
                  (T.copy,0,false) -> mch.emitTextConst
               else
                  (failuretrace,
                  'OBS! Unknown enter type (txtCstVal:asgToMethod): ' 
                    -> (enterTypes[next]->(&text[]).putint->qua(#as::text#)).prepend
                  ) -> stop;
              if)
           else
              '\nOBS! textVal:asgToMethod:index error' -> puttext;
              next -> putint; '/'->put; 
              enterTypes.range -> putint; newline
          if);
          next+1 -> next
       #);
     asgToExitArgs::
       (#
       do (*'\ntextCstVal:asgToItem:'->puttext;*)
          (if T.length = 1 then 
              (* Indufficient - should be either text or char *)
              (*sematt.integerDesc[] -> xTypes.append*)
              (sematt.charDesc[],false) -> xTypes.add
           else
              (sematt.textDesc[],false) -> xTypes.add
          if)
       #);
     asgToNXoffSets::
       (# off: @integer; A: ^mch.address; N: ^ASTindex
       do (* sourceISrRef means assignment to a Text-reference;
           * False means that a char is assigned to a char
           *)
          (if stest then 179->trace(#do 'TxtCstVal:asgToNXoffsest:'->xT#)if);
          NX.getNext -> off;
          off -> (rA.copy).addOff -> A[]; 
          (if NX.getKInd
           // NX.refTmp // NX.refOff then
              NX.getNode->N[]; N.son->N;
              true->SourceISRef; (* why is thus necessary?*)
              (baseAdr.copy,N[],NX.getChain) -> asgToRefAdr
           // NX.repTmp // NX.repOff then
              (A[],none,none) -> asgToRepAdr (* OBS Fix 2. and 3. argument*)
           else
              NX.getSize -> A.size;
              (thisChOp,A[],A.size) -> mch.stCst;
          if);
          A.freeAdr;

          (if stest then
              179->trace(#do 'TxtCstVal:asgToNXoffSets:'->xT; off->xI; thisCh->put#)
          if);
       #);
     asgToInlineItem::
       (# inx: ^inlineNXitem
       do inlNX[] -> inx[];
          thisCh -> inx.newConstToN;
          (*inx.eval->V[]*)
       #);

     asgToList::<(#do toListOne #);
     asgToDispatch::
       (# 
       do (if stest then
              301 -> cTrace(#do 'TxtCstVal:asgToDispatch:'->xT; EV[]->xA#)
          if);
          (EV[],externalName[],desc[],extKind)
            -> GenCOMdispatch
          (# 
          do this(txtCstVal)[] -> PushDispatchPar
          #) -> V[]
       #);
     asgToCproc::<
       (# CP: @ExTernalCall
       do (if stest then 301->ctrace
              (#
              do 'txtCstVal:asgToCproc: '->xT; T[] -> xT
          #)if);
          
          (externalname[],Desc[],extKind,EV.son)->CP; (* init *)
          (CP.getEnterP,extKind,CP.getEnterP.size,CP.pascExtProcInfo)
            -> pushCpar;
          CP.call;
          CP.getExitP->V[];
       #);
     asgToInLinePrimitive::< (*!!!!!!!!! only CHAR not TEXT !!!!! *)
       (# D: [1]@integer; dRes: @integer;
          W: @ComputedEvVal;
          dr: @mch.dataRegOperand
       do dr.alloc; dr -> D[1]; (* mch.getData->D[1]; *)
          (thisChOp,dr[] (*D[1]->mch.NewDataRegOp*))->mch.ldCst;
          (opCode,I1,I2,D)->gen.inLinePrimitive->dRes->W.dr;
          W[]->V[];
          (if dRes <> D[1] then D[1] -> dr; dr.deAlloc (* D[1]->mch.freeData*) if)
       #);
     pushCpar::< 
       (# S: @text; isWtext: @boolean
       do 301->trace(#
                    do 'pushCpar:'->display
                    #);
          (if type
           // 1 then thisChOp->mch.pushCbyte
           // 2 then thisChOp->mch.pushCword
           // 3 then thisChOp->mch.pushClong
           // common.textXpar // common.wtextXpar then
              (type = common.wtextXpar) -> isWtext;
              
              (if (common.targetMachineId = common.ppcmac) OR (common.targetMachineId = common.macosx) then
                  (if extKind 
                   // sematt.pascExt
                   // semAtt.pascTrapExt then
                      T.scanAll(#do size + 1 -> size #);
                      (if size < 255 then
                          size -> S.put;
                          S[] -> T.prePend;
                         (* 301 -> trace
                          (#do 1 -> T.inxGet -> xI; ':'->put;
                             (for i: T.length-1 repeat
                                  i+1 -> T.inxGet -> put
                             for);
                          newline
                          #)*)
                       else
		          'Pascal Text constant longer than 255 chars!' 
                            -> thisTranslate.systemException
                      if);
                  if);
                  (T[],-1,isWtext) ->gen.TextConst;
               else 
                  (T[],-1,isWtext) ->gen.TextConst;
                  (* OBS! textConst is used BOTH for C-par and primitive arg;
                   * -1 means external argument
                   *)
                  (if extKind // sematt.pascExt//semAtt.pascTrapExt then
                      0->mch.initPrimCall; 
                      protectCallReg(#do 'PpkCT'->mch.callPrim #); 
                      0->mch.getPrimRes
                      (*else 'PackConstTextToC'->mch.jsrT *)
                  if)
              if);
           // common.externalStringXpar then
              false -> pushVal (* very indirect way og doing this
                                 * we come back to pishCpar with textPar
                                 *)
           else
              (# T: ^text
              do 'Unknown type for txtCstVal:pushCpar: ' -> T[];
                 type -> T.putint;
                 T[] -> thisTranslate.systemException
          #)if);
       #);
     cmp::< (#do thisCh->lV.cstCmp->doCmp (*gCmp(#do thisCh->lV.cstCmp #)*)#);
     cstCmp::<
       (# dn: @mch.dataRegOperand
       do dn.alloc; (thisChOp,dn[])->mch.ldCst;
          (*(rC[],dn[],4)->mch.gCmp; dn.deAlloc*)
          rC[]->op1[];dn[]->op2[];4->size;true->deAllocOp2
       #);
     adrCmp::<
       (# dn: @mch.dataRegOperand;
       do dn.alloc; (thisChOp,dn[])->mch.ldCst;
          (*(rA[],dn[],rA.size)->mch.gCmp; dn.deAlloc*)
          rA[]->op1[];dn[]->op2[];rA.size->size;true->deAllocOp2
       #);
     regCmp::<
       (# dn: @mch.dataRegOperand
       do dn.alloc; (thisChOp,dn[])->mch.ldCst;
          (*(rReg[],dn[],4)->mch.gCmp; dn.deAlloc*)
          rReg[]->op1[];dn[]->op2[];4->size;true->deAllocOp2
       #);
     add::< (# do  thisCh->lV.cstAdd->res[] #);
     cstAdd::< (#do rN+thisCh->mkConstVal->V[] #);
     adrAdd::< 
       (# W: @ComputedEvVal
       do W.dr.alloc; (rA[],W.dr[],rA.size)->mch.ldVl;
	  (thisChOp,W.dr[],4)->mch.gAdd; W[]->V[]
       #);
     regAdd::<
       (# W: @computedEvVal
       do rReg->W.dr.reUse; (thisChOp,rReg[],4)->mch.gAdd; W[]->V[] #);
     sub::<(#do thisCh->lV.cstSub->res[] #);
     cstSub::< (#do (thisCh-rN)->mkConstVal->V[] #);
     adrSub::< 
       (# W: @ComputedEvVal 
       do W.dr.alloc; (thisChOp,W.dr[])->mch.ldCst;
	  rA[]->loadAdrOp(#do (op[],W.dr[],4)->mch.gSub#); W[]->V[] 
       #);
     regSub::< (* thisCh-lReg->W *)
       (# W1: @ComputedEvVal
       do W1.dr.alloc; (thisChOp,W1.dr[])->mch.ldCst;
	  (rReg[],W1.dr[],4)->mch.gSub; W1[]->V[]
       #);
     times::< (#do thisCh->lV.cstTimes->res[] #);
     adrTimes::< (# W: ^evVal do mkConstEv->W[]; rA[]->W.adrTimes->V[] #);
     cstTimes::< (#do (rN*thisCh)->mkConstVal->V[] #);
     regTimes::<
       (# W: @computedEvVal
       do rReg->W.dr.reUse; 
          (thisChOp,rReg[],4)->mch.gMult; (* datpete 22/7/94: cstMult here??? *)
          W[]->V[]
       #);
     divMod::< (#do (thisCh,isDiv)->lV.cstDivMod->res[] #);
     adrDivMod::< (* rA div C *)
       (#
       do ddr.alloc; (thisChOp,ddr.dNo2[])->mch.ldCst;
          (if rA.size//4 then (rA[],ddr[],isDiv)->mch.gDiv;
           else(* MC680x0 only accepts long for div*)
              (# dl: @mch.dataRegOperand
              do dl.alloc; (rA[],dl[],rA.size)->mch.ldVl;
                 (dl[],ddr[],isDiv)->mch.gDiv; dl.deAlloc
       #)if)#);
     cstDivMod::<
       (# ddr: @mch.doubleDataRegOperand;
          dr: @mch.dataRegOperand;
       do (* kjm: fixed if rN is 0 *)
          (if rN//0 then
              ddr.alloc;
              dr.alloc;
              (thisCh->mch.newCstOp,ddr.dNo2[])->mch.ldCst;
              (0->mch.newCstOp,dr[])->mch.ldCst;
              (dr[],ddr[],isDiv)->mch.gDiv;
              dr.dealloc;
           else
              (if isDiv then (thisCh div rN)->mkConstVal->V[]
               else (thisCh mod rN)->mkConstVal->V[]
              if)
          if);
       #);
     regDivMod::<
       (# 
       do ddr.alloc; (thisChOp,ddr.dNo2[])->mch.ldCst;
          (*Reg->ddr.dNo1.reUse;*)
          (rReg[],ddr[],isDiv)->mch.gDiv; (* C div rReg *)
       #);
     
     thisCh:
       (# c: @Char
       do (if T.isBetaChar then T.scanBeta(#do ch->c #)
           else ' OOPS char expected here!'->bugstream.putline if)
       exit c
       #);
     mkConstEv:
       (# V: ^evVal
       do thisCh->mkConstVal->V[]
       exit V[]
       #);
     thisChOp: (# C: @mch.cstOperand do thisCh->C exit C[] #);
     loadTextConst:
       (# rA: ^mch.Address; max: @integer; isWtext: @boolean (* must be handled *)
       enter rA[]
       do (if common.switch[61] then
              protectCallReg
              (#
              do mch.pushReg->max;
                 4 -> mch.initPrimCall;
                 (T[],1,isWtext) -> gen.textConst; (* FIX this one to primReg *)
                 2 -> rA.pushRegAndOff;
                 (4,1) -> mch.SPtoPrimReg;
                 'MkTO'->mch.callPrim;
                 0->mch.getPrimRes;
                 max->mch.popReg;
              #)
           else
              mch.pushReg->max;
              3 -> mch.initPrimCall;
              (T[],1,isWtext)->gen.textConst; 
              rA.pushRegAndOff;
              'MkTO'->mch.callPrim;
              0->mch.getPrimRes;
              max->mch.popReg;
          if);
       #);
     T: @Text; evalKind: @integer; 
     cTxt: ^mch.dataRegOperand; (* if cTxt[] <> NONE then this(TxtCstVal)
                                   * represents a text returned from C.
                                   * cTxt is a register denoting the txt.
                                   * The txt may be a callback parameter or
                                   * the result of an external call.
                                   * callBack is true if callBack
                                   *)
     callback: @boolean;
     isSimpleVal: @boolean; (*Hack: bytecode - set by pushVal *)
  enter T
  #);
TxtVarVal: EvVal
  (# thisVal::<
       (# V: @TxtVarVal 
       do (baseAdr[],EV[],evalKind,slice)->V ; V[]->thisV[] 
       #);
     evId:: (# do 'TxtVarVal:'-> id[] #);
     display::< 
       (#
       do 'EV='->xT; EV[]->xA; xN;
          'baseAdr=' -> xT; baseAdr.display->xT 
       #); 
     type:: (# do sematt.textDesc[] -> desc[] #);
     theReg:: (#do baseAdr.theReg -> aR #);
     release::<
       (# delay: @boolean
       enter delay
       do baseAdr.freeAdr; 
          (if not delay then none->baseAdr[]; none->EV[] if)
       #);
     loadVal::< (#do cError(#do 'TxtVarVal:loadVal'->xT #)#);
     loadVal2::< (#do cError(#do 'TxtVarVal:loadVal2'->xT #)#);
     pushVal::
       (# 
       do 'TxtVal:pushVal' -> mch.comment;
          (if true then
              copyRep
           else
              toDataReg;
          if);
          (0,false,false,false) -> mkComputedEvVal -> V[];
       #);
     copyRep:
       (* Just for bytecode *)
       (# EV0,EV1,EV2: @ASTindex;
          V1,V2: ^EvVal;
          A: ^mch.address;
          chain: ^DH.SuperChain;
          T: @text; c: @char
       do EHchain[]->chain[];
          EV.son->EV0; 
          (if slice then
              EV0.brother->EV1; EV1.brother->EV2;  
              (baseAdr.copy,Ev1[],false,chain[])->ExpEval->V1[];
              V1.pushVal;
              (baseAdr.copy,Ev2[],false,chain[])->ExpEval->V2[];
              V2.pushVal;
          if);
          (* compute address of EV/EV0 *)
          baseAdr.copy -> A[];
          (A[],EV0[],false,chain[]) -> genAdr -> A[];
          common.direct->A.access;  
          4->A.size; (* ugly, fix for SPARC *)
          (A[],&mch.dataRegOperand[]) -> mch.ldVal;
          EV0[] -> sematt.RepSize -> c; 
          (if not slice then 
              (if evalKind 
               // sematt.repValEval then 'CopyVR'->T; c -> T.put; 
               // sematt.repRefEval then 'CopyRR'->T; 
              if);
           else
              (if evalKind 
               // sematt.repValEval then 'CopySVR'->T; c -> T.put; 
               // sematt.repRefEval then 'CopySRR'->T;
              if);
          if);
          (if switch182 and (evalKind = sematt.repRefEval) then
              common.BetaArrayLocation -> mch.import;
              (T,A.fieldType[]) -> mch.callAlloPrim
           else
              (if switch182 then
                  common.BetaArrayLocation -> mch.import;
              if);
              T -> mch.callPrim;          
          if)
       #);
     toTmp::<
	(# 
	do (if baseAdr.useCallReg then
               baseAdr.toTmp->baseAdr[];
           if)
	#);
     elimReg::< (# do (elimThis,elimCall)->baseAdr.elimReg #);
     toDataRegA:: (* return txt from COM virtual *)
       (# 
       do PushCpar(#do 4 -> returnType #)
       #);
     toDataReg::<
	(# A: ^mch.address; EV1: @ASTindex
	do EV.son->EV1; 
           (baseAdr.copy,EV1[],false,EHchain[])->genAdr->A[];
           301->trace
           (#
           do 'txtVarVal:ToDataReg'->xT; A.display->xT
           #);
	   common.cstInd->A.access; 
           4->A.size; (* ugly, fix for SPARC *)
           (if switch182 then 
               (if true then
                   A.bAdr.localDesc[] 
                     -> theGen.mkArraySignature
                     -> A.fieldType[]
                else                   
                   (A.bAdr.localDesc[] 
                     -> theGen.valueSignature 
                     -> theGen.array).asText
                     -> A.fieldType[]
               if)
           if);
           (A[],dReg[])->mch.ldVal; 
           A.freeAdr; 
           release; (*!!*)
	#);
     asgToRepAdr::< 
	(* rA is the address of a repetition;
	 * assign the repetition denoted by A to rA 
	 *)
	(# EV0,EV1,EV2: @ASTindex; V1,V2: ^evVal; W: @computedEvVal;
	   A: ^mch.address; callRegOnStack,pop,old61,unFreeze: @boolean;
           dR1: ^mch.dataRegOperand; chain1: ^DH.SuperChain;
           pDest: ^mch.mOperand; p: @integer; c: @char; T: @text
	do (if stest then 
               301->ctrace
               (# 
               do 'TxtVarVal:asgToRepAdr: EV=' -> xT; EV[]-> xA; xN;
                  'baseAdr=' -> xT; baseadr.display->xT;
                  mch.dumpreg;
                  EHchain.print
               #)
           if);
           (if EHchain[] = NONE then cError(#Do 'EHchain is none'-> xT #)if);
           (if false (*switch182*) then
               EHchain[]->chain1[];
               EV.son->EV0;                
               (baseAdr.copy,EV0[],false,chain1[]) -> genAdr -> A[];
               common.direct->A.access;  
               4->A.size; (* ugly, fix for SPARC *)
               (A[],&mch.dataRegOperand[]) -> mch.ldVal;
               (&mch.dataRegOperand[],rA[]) -> mch.stVal
            else
               EHchain[]->chain1[];
               (if not switch182 then
                   (if baseAdr.regType // mch.thisO // mch.callO then 
                    else
                       (if switch180 or switch181 then
                           (if not baseAdr.frozenReg then 
                               baseAdr.freezeReg; 
                               (* 11/5/99: used to be freeReg??*)
                               true -> unFreeze
                           if)
                        else
                           AllocCallReg -> callRegOnstack;
                           baseAdr.toCallReg->baseAdr[]
               if)if)if);
	       EV.son->EV0; 
               (* Note: in the computation of ev1,ev2 below, V1 and V2 may 
                * be addressed via callReg, which may be destroyed/released 
                * during generation of genAdr. GenAdr has been moved to
                * after if-imp
                *)
               6 -> mch.initPrimCall ;
               (if slice then
                   EV0.brother->EV1; EV1.brother->EV2;  
	           (baseAdr.copy,Ev1[],false,chain1[])->ExpEval->V1[];
                   V1.toDataReg->dR1[]; dR1->W.dr;
                   (baseAdr.copy,Ev2[],false,chain1[])->ExpEval->V2[];
                   
                   4->W.dr.toPrimDest;
                   W.release;
                   5->V2.toPrimDest;
                   V2.release;
                   (* NOTE: toPrimDest should do the release, but this
                    * gives problems in dobody:if; see scmp in synthlib.bet
                    *)
                   6->p
                else 4->p
               if);
               (* compute address of EV/EV0 *)
               baseAdr.copy -> A[];
               (A[],EV0[],false,chain1[]) -> genAdr -> A[];
               common.direct->A.access;  
               4->A.size; (* ugly, fix for SPARC *)
               (if switch182 then
                   (A[],&mch.dataRegOperand[]) -> mch.ldVal
                else                   
                   1 -> A.toPrimDest;
                   (if mch.callRegInPrimReg2 and mch.callRegBusy then
                       (false,true) -> mch.pushThisOrCall;
                       true->pop
                   if);

                   common.switch[61] -> old61; true->common.switch[61];
                   2 -> rA.pushRegAndOff; (* 2 - 3 *)
                   old61 -> common.switch[61];
               if);
               EV0[] -> sematt.RepSize -> c; 
	       (if not slice then 
	           (if evalKind 
	            // sematt.repValEval then 'CopyVR'->T; c -> T.put; 
	            // sematt.repRefEval then 'CopyRR'->T; 
	           if);
                   (p,1) -> mch.SPtoPrimReg;
	        else
                   (if evalKind 
	            // sematt.repValEval then 'CopySVR'->T; c -> T.put; 
	            // sematt.repRefEval then 'CopySRR'->T;
	           if);
                   (if not switch182 and common.switch[79] then
                       (p,1) -> mch.SPtoPrimReg;
                   if)
               if);
	       A.freeAdr; rA.freeAdr;
               
               (if switch182 and (evalKind = sematt.repRefEval) then
                   common.BetaArrayLocation -> mch.import;
                   (T,A.fieldType[]) -> mch.callAlloPrim
                else
                   (if switch182 then
                       common.BetaArrayLocation -> mch.import;
                   if);
                   T -> mch.callPrim;
               if);
               (* double CallReg push/pop may happen here: 
                * one for  A and one for rA - should be cleaned up
                *)
               (if pop then (false,true) -> mch.popThisOrCall if);
               0->mch.getPrimRes; (* must match initPrimCall *)
	       callRegOnStack->PopCall;
               (if unFreeze then false -> baseAdr.frozenReg if);
               (*1->trace(#
                       do 'CopyRep: ' -> xT; rA.display -> xT
                       #);*)
               (if switch182 then
                   (&mch.dataRegOperand[],rA[]) -> mch.stVal
               if)
           if);
	   this(TxtVarVal)[]->V[]; 
           (if stest then
               179->trace(#do 'txtVarVal:AsgToRepAdr:exit:'->xT;mch.dumpreg#)
           if)
        #);
     asgToRepElm::<
       (#
       do (if stest then
              301->trace(#do 'TxtVarVal:asgToRepElm: '-> xT #)
          if);
          (rA[],none,rChain[]) -> asgToRefAdr; (*rA[] -> asgToAdr;*)
          this(TxtVarVal)[] -> V[]
       #);
     asgToDispatch::
       (# 
       do (if stest then
              301 -> cTrace(#do 'TxtVarVal:asgToDispatch:'->xT; EV[]->xA#)
          if);
          (EV[],externalName[],desc[],extKind)
            -> GenCOMdispatch
          (# 
          do this(txtVarVal)[] -> PushDispatchPar
          #) -> V[]
       #);
     asgToCproc::<
       (* 'A' cannot be an InxRegAdr! *)
       (# CP: @ExTernalCall
       do true->release; 
          (externalname[],Desc[],extKind,EV.son)->CP; (* init *)
          (CP.getEnterP,extKind,CP.getEnterP.size,CP.pascExtProcInfo)
            ->pushCpar;
          CP.call;
          CP.getExitP->V[];
       #);
     pushCpar:: (* type = 4 for text *)
       (# EV0,EV1,EV2: @ASTindex; A: ^mch.address; V1,V2: ^evVal; 
          pReg: ^mch.mOperand; chain1: ^DH.SuperChain;
          returnType: @integer;
          isWtext: @boolean;
          mkEntry: @
            (# T: @text
            enter T
            do (if isWtext then
                   '_W' -> T.append
               if)
            exit T
            #);
               
       do (if type
           // common.textXpar then
           // common.wtextXpar then
              true -> isWtext;
              '\n*** Warning: external enter type "[...]@wchar" may not'
              ' have been implemented!(txtvarval:pushCpar)' -> putline
           else
              'TxtVarVal:pushCpar:unKnownType'
                -> thisTranslate.systemException
          if);
          EHchain[]->chain1[];
          (* common.cstInd->A.access; !!!!*)
          (if released then reAlloc if);
          EV.son->EV0;
	  (if slice then 
              EV0.brother->EV1; EV1.brother->EV2;
              (baseAdr.copy,Ev1[],false,chain1[])->ExpEval->V1[];
              (baseAdr.copy,Ev2[],false,chain1[])->ExpEval->V2[];
              (if common.switch[61] then 4->mch.initPrimCall 
               else 3->mch.initPrimCall
              if)
           else 
              (if common.switch[61] then 2->mch.initPrimCall
               else 1->mch.initPrimCall
              if)
	  if);
          EV.son->EV1; 
          (if false (*switch182*) then
              'CharArray2String' -> mch.CallPrim
          if);
          (baseAdr.copy,EV1[],false,chain1[]) -> genAdr -> A[];
          '!textVal:pushCpar1' -> mch.comment;
          4 -> A.size; (* ugly, fix for SPARC *)
          1 -> mch.getPrimReg -> pReg[];   
          (if switch182 then
              A.bAdr.localDesc[] -> theGen.mkArraySignature -> A.fieldType[]
          if);
          (A[],pReg[]) -> mch.ldVal;
          A.freeAdr; (* OLM: 2/5/99 *)
          '!textVal:pushCpar2' -> mch.comment;
          (if not slice then
              (if common.switch[79(*61*)] then (2,0) -> mch.SpToPrimReg if);
              protectCallReg
              (#
              do (if extKind 
                  // sematt.pascExt // semAtt.pascTrapExt then
                     'PpkVT' -> mkEntry -> mch.callPrim
                  else 
                     (if switch182 then
                         'CharArray2String' -> mch.CallPrim
                      else
                         'CpkVT' -> mkEntry -> mch.callprim 
              if)if)#)
           else (* OBS new primitive OPs to be called here *)
              (* Note: on some architectures (e.g. mips), primReg2 and
               * callreg is the same register; V2 may use callReg and
               * 2->V1.toPrimDest should therefore protect callReg.
               * See synthlib:EvVal:ProtectCallReg
               *)
              3->V2.toPrimDest;  
              ProtectCallReg
              (#
              do 2->V1.toPrimDest;
                 (* should V1, V2 be  released? Perhaps also in asgToRepAdr?*)
                 (if common.switch[79(*61*)] then (4,0) -> mch.SpToPrimReg if);
	         (if extKind 
                  // sematt.pascExt // semAtt.pascTrapExt then
                     'PpkSVT' -> mkEntry -> mch.callPrim
	          else 
                     'CpkSVT' -> mkEntry -> mch.callprim 
                 if)
              #)
          if);
          
          2 -> returnType;
          INNER; (* added to handle return from COM virtual;
                  * called from toDataReg will overwrite returnType
                  *)
          returnType -> mch.getPrimRes;
          none->baseAdr[];
       #);
     toPrimDest::<
       (# A: ^mch.address; EV1: @ASTindex;
          dr: ^mch.dataRegOperand
       do EV.son->EV1; (baseAdr.copy,EV1[],false,EHchain[])->genAdr->A[];
          common.cstInd->A.access; 
          4->A.size; (* ugly, fix for SPARC *)
          pNo->A.toPrimDest;
          (*(if primDest.isPrimRegOp then
              (A[],primDest[])->mch.ldVal
           else
              (if ((A[],primDest[]) -> mch.cpMem -> dr[]) <> NONE then
                  dr.deAlloc
              if)
          if);*)
          A.freeAdr
	#);
     asgToItem::<
        (* A -> EV.N1 *)
	(# nScan: @ | scanNadr
	do (rDesc[],rA[],0,rChain[],true)->nScan; 
           this(TxtVarVal)[]->nScan.asgToNelm -> rAx[];
           nScan.reset
	#);
     asgToMethod::
       (#
       do 301 -> trace(#
                      do 'asgToMethod:'->display;
                      #);
          (if (0 < next) and (next <= enterTypes.range) then
              (if enterTypes[next]
               // 2  (* char *)     then
                  '! BETA char' -> mch.comment;
                  (*77-> mch.cstOperand -> mch.pushClong*)
               // 14 (* text ref *) then
                  '! push text const and convert to beta text' 
                    -> mch.comment;
                  pushVal;
                  'CharRep2BetaText'->mch.callPrim 
               // 12 (* char rep *) then
                  '!Char rep ' -> mch.comment;
                  (if false then pushVal
                   else
                      copyRep
                  if)
               // 13 (* java.lang.String *) then
                  'Missing: txtVarVal:asgToMethod:String' -> putline
               else
                  '\nOBS Unknown enter type (txtCstVal:asgToMethod)' 
                    -> putline
              if)
           else
              '\nOBS! txtVarVal:asgToMethod:index error' -> puttext;
              next -> putint; '/'->put; 
              enterTypes.range -> putint; newline
          if);
          next+1 -> next
       #);
     asgToExitArgs::
       (#
       do (sematt.textDesc[],false) -> xTypes.add
       #);

     asgToNXoffSets::
       (* baseadr = basis address for this(txtVarVal)
        * rA = address in enter part (nxoffSets)
        *)
       (# off: @integer; rAx: ^mch.address; dr: ^mch.dataRegOperand 
       do (if stest then
              179->trace
              (#
              do 'TxtVarVal:asgToNXoffSets: '-> xT; EV[] -> xA;
                 xN; 'baseAdr = ' -> xT; baseAdr.display->xT;
                 xN; 'rA = ' -> xT; rA.display -> xT 
              #)
          if);
          NX.getNext -> off;
          off -> (rA.copy).addOff -> rAx[]; 
          (if stest then
              179->trace
              (#do 'TxtVarVal:asgToNXoffSets2: '-> xT; off->xI; 
                 '\n\t rAx = ' -> xT; rAx.display->xT
              #)
          if);
          (*common.varInd -> rAx.access;*)
          (**** see nxoffsetsval:asgToNxOffSet: repTmp case *****)
          (* Is baseAdr for this(txtVarVal) the address of EV
           * or a baseAdr to be used to compute the adrress of EV.
           * For some cases that latter is true ie it is OK to call
           * asgToRepAdr; in other cases the latter is true and
           * cpMem should be called
           *)
          (if NX.getKind
           // NX.repTmp // NX.repOff then 
              (rAx[],none,none) -> asgToRepAdr (*OBS. Fix 2. and 3. argument *)
           // NX.refTmp // NX.refOff then
              cError(#do 'TxtVarVal:asgToNXoffSets:notRep,butRef'-> xT #)
           else
              cError(#do 'TxtVarVal:asgToNXoffSets:not rep'-> xT #)
          if);
          baseAdr.freeAdr;
          (* rA is exited *)
       #);
     asgToList::<(#do toListOne #);
     baseAdr: ^mch.address; 
     evalKind: @integer; (* repValEval or repRefEval *)
     EV: ^ASTindex; 
     slice: @ Boolean;
  enter(baseAdr[],EV[],evalKind,slice)
  #);
