ORIGIN 'evlib';
LIB_ITEM 'betacodegen';
INCLUDE 'auxlib';
INCLUDE 'computedval';
INCLUDE 'signature'
---mkTxtCstEvVal:descriptor---
(# TV: ^TxtCstVal
do &TxtCstVal[]->TV[]->V[]; T->TV.T; 
#)
---mkTxtCstEvVal2:descriptor---
(# TV: ^TxtCstVal
do &TxtCstVal[]->TV[]->V[]; 
   T->TV.T; cTxt[] -> TV.cTxt[]; isCallBack -> TV.callback
#)
---mkTxtVarEvVal:descriptor---
(# TV: ^TxtVarVal
do &TxtVarVal[]->TV[]->V[]; 
   (if A.access <> common.direct then 
       (if not (switch180 or switch181) then 
           'mkTxtVarVal:base:indirect:notSwitch180/181'
             -> thisTranslate.systemException
       if);
       A.toTmp->A[]
   if);
   (A[],EV[],evalKind,slice)->TV
#)
---EvalLib:attributes---
TxtCstVal: EvVal
  (# thisVal::<(#V: @TxtCstVal do T->V.T; evalKind->V.evalKind; V[]->thisV[]#);
     evId:: (# do 'TxtCstVal:'-> id[] #);
     display::< (#do ThisT->xT #); 
     thisT: (#exit T[]#);
     release::(#do (if cTxt[] <> NONE then cTxt.deAlloc if)#);
     loadVal::<(#do this(TxtCstVal)[]->V[] #);
     loadVal2::<(#do this(TxtCstVal)[]->V[] #);
     valuePushed: @boolean;
     pushVal:: 
       (# pushtext:< (# do inner #);
       do '!TxtCstVal:pushVal'->mch.comment;
          (if isSimpleVal then
              (1,sematt.cExt,0,0) -> pushCpar;
              (0,false,false,false) -> mkComputedEvVal -> V[];
           else
              (common.textXpar,sematt.cExt,0,0) -> pushCpar;
              (if true then 
                  (if not valuePushed then
                      pushText;
                      true -> valuePushed;
                  if)
               else
                  'Text2BetaText'->mch.callPrim;
              if)
          if)
       #);
     mkBetaText::(# do 'Text2BetaText'->mch.callPrim; #);
     toDataRegA::<(#do (thisChOp,mch.DataRegA[])->mch.ldCst#);
     toDataRegX::<(#do (thisChOp,mch.DataRegX[])->mch.ldCst#);
     toDataRegY::<(#do (thisChOp,mch.DataRegY[])->mch.ldCst#);
     toRangeReg::<
       (#do (thisCh->mch.newCstOp,mch.dataRegB[])->mch.ldCst#);
     toDataReg::< (#do (thisCh->mch.newCstOp,dReg[])->mch.ldCst #);
     toPrimDest::
       (# 
       do pNo->primDest.toPrimDest
          (*(if primDest.isPrimRegOp then
              (thisCh->mch.newCstOp,primDest[])->mch.ldCst
           else
              (thisCh->mch.NewCstOp,primDest[],4) -> mch.stCst
          if)*)
       #);
     evType::<(#do 1->type (* if char?*)#);
     type:: (# do sematt.textDesc[] -> desc[] #);
     mkReal::< 
       (# T: @text; thisInt: @(# I: @integer do thisCh->I exit I #)
       do thisCh->T.putInt; '.0'->T.puttext; 
          (T[],thisInt) -> mch.floatConst->mkFloatEvVal->V[] 
       #);
     asgToAdr::<
       (# max: @integer; pop: @boolean; EH: @evalHandler
       do (if not sourceIsRef then
              (if switch182 then
                  (if false then
                      (rA.bAdr.localDesc[],true)
                        -> EH.descName -> rA.fieldType[]
                   else
                      (rA.bAdr.localDesc[]->theGen.fieldSignature).asText
                        -> rA.fieldType[]
                  if)
              if);
              (thisChOp,rA[],rA.size)->mch.stCst;
              this(TxtCstVal)[]->V[];
              rA.freeAdr
           else
              rA[] -> loadtextConst;
              (rA[],false,none,EHchain[])->mkRefEvval->V[]
              (* do we ever come here? In this case chain is for the left-side,
               * NOT for the right-side - this may be a problem??
               * However, the constructed RefEvVal will have sourceEV=none
               * (here destEV here), chain will probably never be used?
               *)
          if);
          (*rA.freeAdr - see FEJL/text2ref.bet *)
       #);
     asgToRefAdr::<
       (# rA: ^mch.address; dEV,dDesc: @ASTindex; mn,dKind,max: @integer;
          RC: ^DH.superChain; found,pop: @boolean;
          textSig: ^text
       do 311->trace(#
                    do 'txtcstval:asgToRefAdr:'->xT; destEv[] -> xA; xN;
                       rAbase.display -> xT;
                    #);
          (***** skud!! *)
          (if not sourceIsRef and not switch182 then 
              (* assign to a char var - not possible? *)
              
              cError(#do 'txtCstVal:asgToRefAdr'->xT #);
              this(TxtCstVal)[]->V[]
           else
              destEV.son->dEV;
              (if not switch182 then
                  (rAbase.copy,dEV[],false,rChain[]) -> genAdr -> rA[];
                  rA[] -> loadTextConst;
               else
                  rAbase.copy -> rA[];
                  (*'Text2BetaText'->mch.callPrim;*)
                  '!txtcstval:asgRefAdr1'->mch.comment;
                  (if true then
                      sematt.textDesc[]-> theGen.mkSignature -> textSig[];
                      (none,false,textSig[],textSig[]) -> rA.asgRefAdr;
                   else
                      (none,false,'text','text') -> rA.asgRefAdr;
                  if);
                  '!txtcstval:asgRefAdr2'->mch.comment;
              if);
              (rChain[],dEV) -> DH.theDesc -> (dDesc,mn,RC[],dKind);
              (if RC.ptnForm >= sematt.virtualForm then 
                  (* virtual QUA-check is needed *)
                  (dEV[],dDesc[],raBase[],rchain[])
                    -> virtualQua
                  (# doAssign::
                       (# dest: @mch.adrRegOperand
                       do this(asgToRefAdr).rA[] -> rAx[]; 
                          (*check why the rA of doAssign must be overwritten!*)
                          common.direct->rAx.access;
                          rAx.toReg2->dest;
                          dest[]->destX[]
                       #)
                  do
                   #)
               else
                  (*312->trace(#do 'txtcst:asgtorefadr'->xT; 
                   sematt.textDesc[] -> xA; dDesc[] -> xA #);*)
                  (sematt.textDesc[],dDesc[])->sematt.chkQua->(mn,found);
                  (if not found then 
                      (* qua-check is needed, but should NEVER happen! *)
                      cError(#do 'text2ref:missing qua-check'->xT #);
              if)if);
              (if switch182 then
                  (0,false,dEv[],rChain[])->mkComputedRefEvVal->V[];
               else
                  (rA[],false,sematt.textDesc[],rChain[])->mkRefEvval->V[]
              if)
          if);
          (*rA.freeAdr -- see FEJL/text2ref.bet *)
          (*312->trace(#do 'txtcst:asgtorefadr2'->xT; 
           sematt.textDesc[] -> xA; dDesc[] -> xA #);*)
       #);
     asgToRepAdr::<
       (# max: @integer; isWtext: @boolean;
       do (if stest then
              301->trace(#do 'txtcstval:asgToRepAdr: '->xT;
                           'rEv='->xT; rEv[]->xA; 
                           ' rA='->xT; rA.display->xT; 
          #)if);
          false -> isWtext; (* currently no handling of wText *);
          (if T.isBetaChar then (*rA.size > 1 then*)
              (rA[],rEV[],rChain[]) -> ((thisChOp).C -> mkConstVal).asgToRepAdr
           else
              (if common.switch[61] then
                  protectCallReg
                  (# dr: @mch.DataRegOperand;
                     A: @mch.RegAdr
                  do release; (* we MUST dealloc cTxt before pushReg, since
                               * this will confuse callBack
                               * (Inconsistent stack frame size for CB entry)
                               *)
                     mch.pushReg -> max; (* 6.12.95 *)
                     
                     (if (cTxt[] = NONE) and not callBack then
                         (rA[],0) -> CopyT
                         (#
                         do (T[],1,isWtext)->gen.TextConst;
                            (4,1) -> mch.SPtoPrimReg
                         #)
                      else
                         (* (cTxt[] <> NONE) or callBack *)
                         (rA[],3) -> CopyT
                         (#
                         do 1 -> cTxt.toPrimDest;
                            (* Set BetaStackTop *)
                            A.reg.alloc;
                            ('BetaStackTop' -> mch.newTextOp,A.reg[]) 
                              -> mch.gLea;
                            4 -> A.toPrimDest;
                            A.freeAdr
                         #)-> dr;
                         (* copy dr to callReg and thisReg *)
                         (dr[],mch.callRegOp[]) -> mch.cpReg;
                         (dr[],mch.thisRegOp[]) -> mch.cpReg
                     if); 
                     max->mch.popReg 
                  #)
               else
                  (if switch182 then
                      '?' -> puttext;
                      pushVal
                      (# pushText::(#do '!' -> put; 'Text2CharArray'->mch.callPrim #)#);
                      rA.bAdr.localDesc[] 
                        -> theGen.mkArraySignature 
                        -> rA.fieldType[];
                      (&mch.dataRegOperand[],rA[]) -> mch.stVal
                   else
                      (rA[],0) -> CopyT(#do (T[],1,isWtext)->gen.TextConst #)
                  if)
          if)if); 
          this(TxtCstVal)[]->V[]; rA.freeAdr
       #);
     asgToRepElm::<
       (#
       do (if stest then 
              301->trace(#do 'TxtCstVal:asgToRepElm: '-> xT;
                           display;
                           rEv[]->xA
                        #)
          if);
          (if rEv.son -> sematt.SimpleOrRep
           // gram.dynamicItem then
              (* we assume R: [e] ^text *)
              rA[] -> loadTextConst
           // gram.staticItem then        
              (* we assume R: [e] @char *)
              rA[] -> asgToAdr 
           else
              'TxtCstVal:asgToRepElm:illegalRepetition'
                -> thisTranslate.systemException
          if);
          this(TxtCstVal)[] -> V[]
       #);
     asgToItem::<
       (* C -> EV.N1 *)
       (# nScan: @ | scanNadr; 
       do (rDesc[],rA[],0,rChain[],true) -> nScan;
          this(TxtCstVal)[] -> nScan.AsgToNelm -> rAx[];  
          nScan.reset
       #);
     asgToMethod::
       (#
       do (if true then 
              (* 'asgToMethod:range:'->puttext; enterTypes.range -> putint;
               * ' '->put; next->putint; 
               *)
              
              (if (0 < next) and (next <= enterTypes.range) then
                  (* ' '->put; enterTypes[next] -> putint; newline; *)
                  (if enterTypes[next]
                   // 2  (* char *)     then
                      '! BETA char' -> mch.comment;
                      thisChOp -> mch.pushClong
                   // 11 (* text ref *) then
                      '! push text const and convert to beta text' 
                        -> mch.comment;
                      pushVal
                      (# pushtext::(#do 'Text2BetaText'->mch.callPrim#)#);
                   // 12 (* char rep *) then
                      '!Char rep ' -> mch.comment;
                      pushVal
                      (# pushtext:: (#do 'Text2CharArray'->mch.callPrim #)#)
                   else
                      '\nOBS Unknown enter type (txtCstVal:asgToMethod)' 
                        -> putline
                  if)
               else
                  '\nOBS! textVal:asgToMethod:index error' -> puttext;
                  next -> putint; '/'->put; 
                  enterTypes.range -> putint; newline
              if)
           else
              (if T.isBetaChar then
                  'OOPS! this may a text with one element and not a char' 
                    -> mch.comment
                  ;thisChOp -> mch.pushClong
               else
                  pushVal
                  (# pushtext::(#do 'Text2CharArray'->mch.callPrim  #)#)
          if)if)
       #);
     asgToNXoffSets::
       (# off: @integer; A: ^mch.address; N: ^ASTindex
       do (* sourceISrRef means assignment to a Text-reference;
           * False means that a char is assigned to a char
           *)
          (if stest then 179->trace(#do 'TxtCstVal:asgToNXoffsest:'->xT#)if);
          NX.getNext -> off;
          off -> (rA.copy).addOff -> A[]; 
          (if NX.getKInd
           // NX.refTmp // NX.refOff then
              NX.getNode->N[]; N.son->N;
              true->SourceISRef; (* why is thus necessary?*)
              (baseAdr.copy,N[],NX.getChain) -> asgToRefAdr
           // NX.repTmp // NX.repOff then
              (A[],none,none) -> asgToRepAdr (* OBS Fix 2. and 3. argument*)
           else
              NX.getSize -> A.size;
              (thisChOp,A[],A.size) -> mch.stCst;
          if);
          A.freeAdr;

          (if stest then
              179->trace(#do 'TxtCstVal:asgToNXoffSets:'->xT; off->xI; thisCh->put#)
          if);
       #);
     asgToInlineItem::
       (# inx: ^inlineNXitem
       do inlNX[] -> inx[];
          thisCh -> inx.newConstToN;
          (*inx.eval->V[]*)
       #);

     asgToList::<(#do toListOne #);
     asgToDispatch::
       (# 
       do (if stest then
              311 -> cTrace(#do 'TxtCstVal:asgToDispatch:'->xT; EV[]->xA#)
          if);
          (EV[],externalName[],desc[],extKind)
            -> GenCOMdispatch
          (# 
          do this(txtCstVal)[] -> PushDispatchPar
          #) -> V[]
       #);
     asgToCproc::<
       (# CP: @ExTernalCall
       do (if stest then 301->ctrace
              (#
              do 'txtCstVal:asgToCproc: '->xT; T[] -> xT
          #)if);
          
          (externalName,Desc[],extKind,EV.son)->CP; (* init *)
          (CP.getEnterP,extKind,CP.getEnterP.size,CP.pascExtProcInfo)
            -> pushCpar;
          CP.call;
          CP.getExitP->V[];
       #);
     asgToInLinePrimitive::< (*!!!!!!!!! only CHAR not TEXT !!!!! *)
       (# D: [1]@integer; dRes: @integer;
          W: @ComputedEvVal;
          dr: @mch.dataRegOperand
       do dr.alloc; dr -> D[1]; (* mch.getData->D[1]; *)
          (thisChOp,dr[] (*D[1]->mch.NewDataRegOp*))->mch.ldCst;
          (opCode,I1,I2,D)->gen.inLinePrimitive->dRes->W.dr;
          W[]->V[];
          (if dRes <> D[1] then D[1] -> dr; dr.deAlloc (* D[1]->mch.freeData*) if)
       #);
     pushCpar::< 
       (# S: @text; isWtext: @boolean
       do '!txtCstVal:pushCpar'->mch.comment;
          (if type
           // 1 then thisChOp->mch.pushCbyte
           // 2 then thisChOp->mch.pushCword
           // 3 then thisChOp->mch.pushClong
           // common.textXpar // common.wtextXpar then
              (type = common.wtextXpar) -> isWtext;
              
              (if (common.targetMachineId = common.ppcmac) OR (common.targetMachineId = common.macosx) then
                  (if extKind 
                   // sematt.pascExt
                   // semAtt.pascTrapExt then
                      T.scanAll(#do size + 1 -> size #);
                      (if size < 255 then
                          size -> S.put;
                          S[] -> T.prePend;
                         (* 301 -> trace
                          (#do 1 -> T.inxGet -> xI; ':'->put;
                             (for i: T.length-1 repeat
                                  i+1 -> T.inxGet -> put
                             for);
                          newline
                          #)*)
                       else
		          'Pascal Text constant longer than 255 chars!' 
                            -> thisTranslate.systemException
                      if);
                  if);
                  (T[],-1,isWtext) ->gen.TextConst;
               else 
                  (T[],-1,isWtext) ->gen.TextConst;
                  (* OBS! textConst is used BOTH for C-par and primitive arg;
                   * -1 means external argument
                   *)
                  (if extKind // sematt.pascExt//semAtt.pascTrapExt then
                      0->mch.initPrimCall; 
                      protectCallReg(#do 'PpkCT'->mch.callPrim #); 
                      0->mch.getPrimRes
                      (*else 'PackConstTextToC'->mch.jsrT *)
                  if)
              if);
           else
              'Unknown type for txtCstVal:pushCpar' 
                -> thisTranslate.systemException
          if);
       #);
     cmp::< (#do thisCh->lV.cstCmp->doCmp (*gCmp(#do thisCh->lV.cstCmp #)*)#);
     cstCmp::<
       (# dn: @mch.dataRegOperand
       do dn.alloc; (thisChOp,dn[])->mch.ldCst;
          (*(rC[],dn[],4)->mch.gCmp; dn.deAlloc*)
          rC[]->op1[];dn[]->op2[];4->size;true->deAllocOp2
       #);
     adrCmp::<
       (# dn: @mch.dataRegOperand;
       do dn.alloc; (thisChOp,dn[])->mch.ldCst;
          (*(rA[],dn[],rA.size)->mch.gCmp; dn.deAlloc*)
          rA[]->op1[];dn[]->op2[];rA.size->size;true->deAllocOp2
       #);
     regCmp::<
       (# dn: @mch.dataRegOperand
       do dn.alloc; (thisChOp,dn[])->mch.ldCst;
          (*(rReg[],dn[],4)->mch.gCmp; dn.deAlloc*)
          rReg[]->op1[];dn[]->op2[];4->size;true->deAllocOp2
       #);
     add::< (# do  thisCh->lV.cstAdd->res[] #);
     cstAdd::< (#do rN+thisCh->mkConstVal->V[] #);
     adrAdd::< 
       (# W: @ComputedEvVal
       do W.dr.alloc; (rA[],W.dr[],rA.size)->mch.ldVl;
	  (thisChOp,W.dr[],4)->mch.gAdd; W[]->V[]
       #);
     regAdd::<
       (# W: @computedEvVal
       do rReg->W.dr.reUse; (thisChOp,rReg[],4)->mch.gAdd; W[]->V[] #);
     sub::<(#do thisCh->lV.cstSub->res[] #);
     cstSub::< (#do (thisCh-rN)->mkConstVal->V[] #);
     adrSub::< 
       (# W: @ComputedEvVal 
       do W.dr.alloc; (thisChOp,W.dr[])->mch.ldCst;
	  rA[]->loadAdrOp(#do (op[],W.dr[],4)->mch.gSub#); W[]->V[] 
       #);
     regSub::< (* thisCh-lReg->W *)
       (# W1: @ComputedEvVal
       do W1.dr.alloc; (thisChOp,W1.dr[])->mch.ldCst;
	  (rReg[],W1.dr[],4)->mch.gSub; W1[]->V[]
       #);
     times::< (#do thisCh->lV.cstTimes->res[] #);
     adrTimes::< (# W: ^evVal do mkConstEv->W[]; rA[]->W.adrTimes->V[] #);
     cstTimes::< (#do (rN*thisCh)->mkConstVal->V[] #);
     regTimes::<
       (# W: @computedEvVal
       do rReg->W.dr.reUse; 
          (thisChOp,rReg[],4)->mch.gMult; (* datpete 22/7/94: cstMult here??? *)
          W[]->V[]
       #);
     divMod::< (#do (thisCh,isDiv)->lV.cstDivMod->res[] #);
     adrDivMod::< (* rA div C *)
       (#
       do ddr.alloc; (thisChOp,ddr.dNo2[])->mch.ldCst;
          (if rA.size//4 then (rA[],ddr[],isDiv)->mch.gDiv;
           else(* MC680x0 only accepts long for div*)
              (# dl: @mch.dataRegOperand
              do dl.alloc; (rA[],dl[],rA.size)->mch.ldVl;
                 (dl[],ddr[],isDiv)->mch.gDiv; dl.deAlloc
       #)if)#);
     cstDivMod::<
       (# ddr: @mch.doubleDataRegOperand;
          dr: @mch.dataRegOperand;
       do (* kjm: fixed if rN is 0 *)
          (if rN//0 then
              ddr.alloc;
              dr.alloc;
              (thisCh->mch.newCstOp,ddr.dNo2[])->mch.ldCst;
              (0->mch.newCstOp,dr[])->mch.ldCst;
              (dr[],ddr[],isDiv)->mch.gDiv;
              dr.dealloc;
           else
              (if isDiv then (thisCh div rN)->mkConstVal->V[]
               else (thisCh mod rN)->mkConstVal->V[]
              if)
          if);
       #);
     regDivMod::<
       (# 
       do ddr.alloc; (thisChOp,ddr.dNo2[])->mch.ldCst;
          (*Reg->ddr.dNo1.reUse;*)
          (rReg[],ddr[],isDiv)->mch.gDiv; (* C div rReg *)
       #);
     
     thisCh:
       (# c: @Char
       do (if T.isBetaChar then T.scanBeta(#do ch->c #)
           else ' OOPS char expected here!'->bugstream.putline if)
       exit c
       #);
     mkConstEv:
       (# V: ^evVal
       do thisCh->mkConstVal->V[]
       exit V[]
       #);
     thisChOp: (# C: @mch.cstOperand do thisCh->C exit C[] #);
     loadTextConst:
       (# rA: ^mch.Address; max: @integer; isWtext: @boolean (* must be handled *)
       enter rA[]
       do (if common.switch[61] then
              protectCallReg
              (#
              do mch.pushReg->max;
                 4 -> mch.initPrimCall;
                 (T[],1,isWtext) -> gen.textConst; (* FIX this one to primReg *)
                 2 -> rA.pushRegAndOff;
                 (4,1) -> mch.SPtoPrimReg;
                 'MkTO'->mch.callPrim;
                 0->mch.getPrimRes;
                 max->mch.popReg;
              #)
           else
              mch.pushReg->max;
              3 -> mch.initPrimCall;
              (T[],1,isWtext)->gen.textConst; 
              rA.pushRegAndOff;
              'MkTO'->mch.callPrim;
              0->mch.getPrimRes;
              max->mch.popReg;
          if);
       #);
     T: @Text; evalKind: @integer; 
     cTxt: ^mch.dataRegOperand; (* if cTxt[] <> NONE then this(TxtCstVal)
                                   * represents a text returned from C.
                                   * cTxt is a register denoting the txt.
                                   * The txt may be a callback parameter or
                                   * the result of an external call.
                                   * callBack is true if callBack
                                   *)
     callback: @boolean;
  enter T
  #);
TxtVarVal: EvVal
  (# thisVal::<
       (# V: @TxtVarVal 
       do (baseAdr[],EV[],evalKind,slice)->V ; V[]->thisV[] 
       #);
     evId:: (# do 'TxtVarVal:'-> id[] #);
     display::< 
       (#
       do 'EV='->xT; EV[]->xA; xN;
          'baseAdr=' -> xT; baseAdr.display->xT 
       #); 
     type:: (# do sematt.textDesc[] -> desc[] #);
     theReg:: (#do baseAdr.theReg -> aR #);
     release::<
       (# delay: @boolean
       enter delay
       do baseAdr.freeAdr; 
          (if not delay then none->baseAdr[]; none->EV[] if)
       #);
     loadVal::< (#do cError(#do 'TxtVarVal:loadVal'->xT #)#);
     loadVal2::< (#do cError(#do 'TxtVarVal:loadVal2'->xT #)#);
     pushVal::
       (# 
       do 'TxtVal:pushVal' -> mch.comment;
          toDataReg
       #);
     toTmp::<
	(#
	do (if baseAdr.useCallReg then
               baseAdr.toTmp->baseAdr[];
           if)
	#);
     elimReg::< (# do (elimThis,elimCall)->baseAdr.elimReg #);
     toDataRegA:: (* return txt from COM virtual *)
       (# 
       do PushCpar(#do 4 -> returnType #)
       #);
     toDataReg::<
	(# A: ^mch.address; EV1: @ASTindex
	do EV.son->EV1; 
           (baseAdr.copy,EV1[],false,EHchain[])->genAdr->A[];
	   common.cstInd->A.access; 
           4->A.size; (* ugly, fix for SPARC *)
           (if switch182 then 
               (A.bAdr.localDesc[] 
                 -> theGen.valueSignature 
                 -> theGen.array).asText
                 -> A.fieldType[]
           if);
           (A[],dReg[])->mch.ldVal; 
           A.freeAdr; 
           release; (*!!*)
	#);
     asgToRepAdr::< 
	(* rA is the address of a repetition;
	 * assign the repetition denoted by A to rA 
	 *)
	(# EV0,EV1,EV2: @ASTindex; V1,V2: ^evVal; W: @computedEvVal;
	   A: ^mch.address; callRegOnStack,pop,old61,unFreeze: @boolean;
           dR1: ^mch.dataRegOperand; chain1: ^DH.SuperChain;
           pDest: ^mch.mOperand; p: @integer; c: @char; T: @text
	do (if stest then 
               301->ctrace
               (# 
               do 'TxtVarVal:asgToRepAdr: EV=' -> xT; EV[]-> xA; xN;
                  'baseAdr=' -> xT; baseadr.display->xT;
                  mch.dumpreg;
                  EHchain.print
               #)
           if);
           (if EHchain[] = NONE then
               cError(#Do 'EHchain is none'-> xT #)
           if);
           EHchain[]->chain1[];
           (if baseAdr.regType // mch.thisO // mch.callO then 
            else
               (if switch180 or switch181 then
                   (if not baseAdr.frozenReg then (* 27.12.97: v5.4 *)
                       baseAdr.freezeReg; (* 11/5/99: used to be freeReg??*)
                       true -> unFreeze
                   if)
                else
                   AllocCallReg -> callRegOnstack;
                   baseAdr.toCallReg->baseAdr[]
               if)
           if);
	   EV.son->EV0; 
           (* Note: in the computation of ev1,ev2 below, V1 and V2 may be 
            * addressed via callReg, which may be destroyed/released during
            * generation of genAdr. GenAdr has been moved to after if-imp
            *)
           6 -> mch.initPrimCall ;
           (if slice then
               EV0.brother->EV1; EV1.brother->EV2;  
	       (baseAdr.copy,Ev1[],false,chain1[])->ExpEval->V1[];
               V1.toDataReg->dR1[]; dR1->W.dr;
               (baseAdr.copy,Ev2[],false,chain1[])->ExpEval->V2[];
               
               4->W.dr.toPrimDest;
               W.release;
               5->V2.toPrimDest;
               V2.release;
               (* NOTE: toPrimDest should do the release, but this
                * gives problems in dobody:if; see scmp in synthlib.bet
                *)
               6->p
            else 4->p
           if);
           (* compute address of EV/EV0 *)
           baseAdr.copy -> A[];
           (A[],EV0[],false,chain1[]) -> genAdr -> A[];
           common.direct->A.access;  
           4->A.size; (* ugly, fix for SPARC *)
           
           1 -> A.toPrimDest;
           (if mch.callRegInPrimReg2 and mch.callRegBusy then
               (false,true) -> mch.pushThisOrCall;
               true->pop
           if);

           common.switch[61] -> old61; true->common.switch[61];
           2 -> rA.pushRegAndOff; (* 2 - 3 *)
           old61 -> common.switch[61];
           

           EV0[] -> sematt.RepSize -> c; 
	   (if not slice then 
	       (if evalKind 
	        // sematt.repValEval then 'CopyVR'->T; c -> T.put; 
	        // sematt.repRefEval then 'CopyRR'->T; 
	       if);
               (p,1) -> mch.SPtoPrimReg;
	    else
               (if evalKind 
	        // sematt.repValEval then 'CopySVR'->T; c -> T.put; 
	        // sematt.repRefEval then 'CopySRR'->T;
	       if);
               (if common.switch[79] then
                   (p,1) -> mch.SPtoPrimReg;
               if)
           if);
	   A.freeAdr; rA.freeAdr;
           
           T -> mch.callPrim;
           (* double CallReg push/pop may happen here: 
            * one for  A and one for rA - should be cleaned up
            *)
           (if pop then (false,true) -> mch.popThisOrCall if);
           0->mch.getPrimRes; (* must match initPrimCall *)
	   callRegOnStack->PopCall;
           (if unFreeze then false -> baseAdr.frozenReg if);
	   this(TxtVarVal)[]->V[]; 
           (if stest then
               179->trace(#do 'txtVarVal:AsgToRepAdr:exit:'->xT; mch.dumpreg #)
           if)
        #);
     asgToRepElm::<
       (#
       do (if stest then
              301->trace(#do 'TxtVarVal:asgToRepElm: '-> xT #)
          if);
          (rA[],none,rChain[]) -> asgToRefAdr; (*rA[] -> asgToAdr;*)
          this(TxtVarVal)[] -> V[]
       #);
     asgToDispatch::
       (# 
       do (if stest then
              311 -> cTrace(#do 'TxtVarVal:asgToDispatch:'->xT; EV[]->xA#)
          if);
          (EV[],externalName[],desc[],extKind)
            -> GenCOMdispatch
          (# 
          do this(txtVarVal)[] -> PushDispatchPar
          #) -> V[]
       #);
     asgToCproc::<
       (* 'A' cannot be an InxRegAdr! *)
       (# CP: @ExTernalCall
       do true->release; 
          (externalName,Desc[],extKind,EV.son)->CP; (* init *)
          (CP.getEnterP,extKind,CP.getEnterP.size,CP.pascExtProcInfo)
            ->pushCpar;
          CP.call;
          CP.getExitP->V[];
       #);
     pushCpar:: (* type = 4 for text *)
       (# EV0,EV1,EV2: @ASTindex; A: ^mch.address; V1,V2: ^evVal; 
          pReg: ^mch.mOperand; chain1: ^DH.SuperChain;
          returnType: @integer;
          isWtext: @boolean;
          mkEntry: @
            (# T: @text
            enter T
            do (if isWtext then
                   '_W' -> T.append
               if)
            exit T
            #);
               
       do (if type
           // common.textXpar then
           // common.wtextXpar then
              true -> isWtext;
              '\n*** Warning: external enter type "[...]@wchar" may not'
              ' have been implemented!(txtvarval:pushCpar)' -> putline
           else
              'TxtVarVal:pushCpar:unKnownType'
                -> thisTranslate.systemException
          if);
          EHchain[]->chain1[];
          (* common.cstInd->A.access; !!!!*)
          (if released then reAlloc if);
          EV.son->EV0;
	  (if slice then 
              EV0.brother->EV1; EV1.brother->EV2;
              (baseAdr.copy,Ev1[],false,chain1[])->ExpEval->V1[];
              (baseAdr.copy,Ev2[],false,chain1[])->ExpEval->V2[];
              (if common.switch[61] then 4->mch.initPrimCall 
               else 3->mch.initPrimCall
              if)
           else 
              (if common.switch[61] then 2->mch.initPrimCall
               else 1->mch.initPrimCall
              if)
	  if);
          EV.son->EV1; 
          (if false (*switch182*) then
              'CharArray2String' -> mch.CallPrim
          if);
          (baseAdr.copy,EV1[],false,chain1[]) -> genAdr -> A[];
          '!textVal:pushCpar1' -> mch.comment;
          4 -> A.size; (* ugly, fix for SPARC *)
          1 -> mch.getPrimReg -> pReg[];   
          (if switch182 then
              A.bAdr.localDesc[] -> theGen.mkArraySignature -> A.fieldType[]
          if);
          (A[],pReg[]) -> mch.ldVal;
          A.freeAdr; (* OLM: 2/5/99 *)
          '!textVal:pushCpar2' -> mch.comment;
          (if not slice then
              (if common.switch[79(*61*)] then (2,0) -> mch.SpToPrimReg if);
              protectCallReg
              (#
              do (if extKind 
                  // sematt.pascExt // semAtt.pascTrapExt then
                     'PpkVT' -> mkEntry -> mch.callPrim
                  else 
                     (if switch182 then
                         'CharArray2String' -> mch.CallPrim
                      else
                         'CpkVT' -> mkEntry -> mch.callprim 
              if)if)#)
           else (* OBS new primitive OPs to be called here *)
              (* Note: on some architectures (e.g. mips), primReg2 and
               * callreg is the same register; V2 may use callReg and
               * 2->V1.toPrimDest should therefore protect callReg.
               * See synthlib:EvVal:ProtectCallReg
               *)
              3->V2.toPrimDest;  
              ProtectCallReg
              (#
              do 2->V1.toPrimDest;
                 (* should V1, V2 be  released? Perhaps also in asgToRepAdr?*)
                 (if common.switch[79(*61*)] then (4,0) -> mch.SpToPrimReg if);
	         (if extKind 
                  // sematt.pascExt // semAtt.pascTrapExt then
                     'PpkSVT' -> mkEntry -> mch.callPrim
	          else 
                     'CpkSVT' -> mkEntry -> mch.callprim 
                 if)
              #)
          if);
          
          2 -> returnType;
          INNER; (* added to handle return from COM virtual;
                  * called from toDataReg will overwrite returnType
                  *)
          returnType -> mch.getPrimRes;
          none->baseAdr[];
       #);
     toPrimDest::<
       (# A: ^mch.address; EV1: @ASTindex;
          dr: ^mch.dataRegOperand
       do EV.son->EV1; (baseAdr.copy,EV1[],false,EHchain[])->genAdr->A[];
          common.cstInd->A.access; 
          4->A.size; (* ugly, fix for SPARC *)
          pNo->A.toPrimDest;
          (*(if primDest.isPrimRegOp then
              (A[],primDest[])->mch.ldVal
           else
              (if ((A[],primDest[]) -> mch.cpMem -> dr[]) <> NONE then
                  dr.deAlloc
              if)
          if);*)
          A.freeAdr
	#);
     asgToItem::<
        (* A -> EV.N1 *)
	(# nScan: @ | scanNadr
	do (rDesc[],rA[],0,rChain[],true)->nScan; 
           this(TxtVarVal)[]->nScan.asgToNelm -> rAx[];
           nScan.reset
	#);
     asgToMethod::
       (#
       do  
          (if (0 < next) and (next <= enterTypes.range) then
              (if enterTypes[next]
               // 2  (* char *)     then
                  '! BETA char' -> mch.comment;
                  (*77-> mch.cstOperand -> mch.pushClong*)
               // 11 (* text ref *) then
                  '! push text const and convert to beta text' -> mch.comment;
                  pushVal;
                  'CharRep2BetaText'->mch.callPrim 
               // 12 (* char rep *) then
                  '!Char rep ' -> mch.comment;
                  pushVal;
               else
                  '\nOBS Unknown enter type (txtCstVal:asgToMethod)' 
                    -> putline
              if)
           else
              '\nOBS! txtVarVal:asgToMethod:index error' -> puttext;
              next -> putint; '/'->put; 
              enterTypes.range -> putint; newline
          if)
       #);
     asgToNXoffSets::
       (* baseadr = basis address for this(txtVarVal)
        * rA = address in enter part (nxoffSets)
        *)
       (# off: @integer; rAx: ^mch.address; dr: ^mch.dataRegOperand 
       do (if stest then
              179->trace
              (#
              do 'TxtVarVal:asgToNXoffSets: '-> xT; EV[] -> xA;
                 xN; 'baseAdr = ' -> xT; baseAdr.display->xT;
                 xN; 'rA = ' -> xT; rA.display -> xT 
              #)
          if);
          NX.getNext -> off;
          off -> (rA.copy).addOff -> rAx[]; 
          (if stest then
              179->trace
              (#do 'TxtVarVal:asgToNXoffSets2: '-> xT; off->xI; 
                 '\n\t rAx = ' -> xT; rAx.display->xT
              #)
          if);
          (*common.varInd -> rAx.access;*)
          (**** see nxoffsetsval:asgToNxOffSet: repTmp case *****)
          (* Is baseAdr for this(txtVarVal) the address of EV
           * or a baseAdr to be used to compute the adrress of EV.
           * For some cases that latter is true ie it is OK to call
           * asgToRepAdr; in other cases the latter is true and
           * cpMem should be called
           *)
          (if NX.getKind
           // NX.repTmp // NX.repOff then 
              (rAx[],none,none) -> asgToRepAdr (*OBS. Fix 2. and 3. argument *)
           // NX.refTmp // NX.refOff then
              cError(#do 'TxtVarVal:asgToNXoffSets:notRep,butRef'-> xT #)
           else
              cError(#do 'TxtVarVal:asgToNXoffSets:not rep'-> xT #)
          if);
          baseAdr.freeAdr;
          (* rA is exited *)
       #);
     asgToList::<(#do toListOne #);
     baseAdr: ^mch.address; 
     evalKind: @integer; (* repValEval or repRefEval *)
     EV: ^ASTindex; slice: @ Boolean
  enter(baseAdr[],EV[],evalKind,slice)
  #);
