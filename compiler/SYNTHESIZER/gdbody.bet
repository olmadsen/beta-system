ORIGIN 'synthesizerbody';
LIB_ITEM 'betacodegen';
INCLUDE 'gen';
INCLUDE 'synthlib';
INCLUDE 'evlib';
INCLUDE 'genlib';
INCLUDE 'prototype'
-------------------------SpecialInitCall:descriptor--------------------------
(* A descriptor slot may have one of the forms:
 *  ---X:descriptor--- (# .... #)
 *  ---Y:descriptor--- P(# ... #)
 * In case X, the descriptor gets descNo=1 and generation/invocation
 * will use the entry-points: G1X and M1X.
 * In case Y, the descriptor gets descNo=2, generation /invocation 
 * will still use the entry-points: G1Y/M1Y, since at the point of
 * the slots it is not know whether cas X or Y applies.
 * For case Y, special entry-points G1Y/M1Y have to be generated.
 * They have the form:
 * G1Y: jmp G2Y
 * M1Y: jmp M2Y - NO! - we jump to M_super_Y which is M_P
 * These are generated by This(SpecialInitCall).
 *)
(# prefDesc: @ASTindex; PL: @integer
do (*309->trace(#do 'Descriptor slot has super pattern!'->T #);*)
   NONE->externalEntryLab[];
   formDesc.son->prefDesc; prefDesc.son->SemAtt.descChain->(prefDesc,PL);
   true->desc2Alias;
   (thisForm[],prefDesc[])->gen.SpecialInitDesc
#)
-----------------synthesizerBody_InitGen:doPart-------------
do desc[]
     -> Sematt.descSonsRef
     -> (pref[],mainP[],att[],enterP[],doP[],exitP[]);
   desc.originOff -> ThisDescOrgOff;
   (pref.label = gram.prefix) -> hasPref; 
   desc.attSize -> attSize -> offCount;
   desc.descId -> (thisForm[],ThisDescNo);
   thisForm.makeUC;
   false -> returnSaved; 
   NONE-> externalEntryLab[];
   INNER initGen

-----------------------GenDescBody: descriptor--------------------
(* generate code for a descriptor.
 * A descriptor may be translated in the following ways:
 * - const: No code is generated
 * - item:  Code for using the descriptor as an item!!!!!!!!!!
 *)
(# 
   objKind: @integer
   (*enter(ThisDesc,singular,nameId) *)
do L:
     (if ThisDesc.label = gram.unExpanded then
         (if false then
             (* switch182 may puhs slots - we just ignore them
              * for the 'normal' compiler'
              * *)
             'GDBody called with DescSlot!' -> thisTranslate.systemException
         if)
      else
         307->trace(#
                   do 'GenDesc: kind:'->xT; 
                      ThisDesc->sematt.DescKind->sematt.kindAstext->xT;
                      xN;
                      ThisDesc[]->xA 
                   #);
         thisDesc[] -> InitGen;
         (if mainP.isSlot  then leave L if);
         (if (theGroup.Origin = none) and (ThisDescNo=1)  then
             (*initial BETAenv*) 
             (if not common.switch[182] (* if not bytecode *) then
                 thisDesc[]->gen.initialSeq
             if);
         if);
         (if (ThisDesc->sematt.DescKind->objKind)
	  // sematt.generalKind 
          // sematt.classKind
          // sematt.holderkind
          // sematt.stateKind then 
             (if switch182 then
                 (thisDesc[],false) -> GenByteCode
              else
                 (objKind,inForm) -> GenObj
             if)
          // sematt.procKind 
          // sematt.consKind
          // sematt.staticProcKind 
          // sematt.staticConsKind then
             (* ignored by standard compilers;
              * pattern proc is currently not checked
              * so GenObj will fail on procname: text
              *)
             (if switch182 then (thisDesc[],false) -> GenByteCode if)
          // sematt.externalClassKind then
             (* ignored by standard compilers;
              * pattern externaClass is currently not checked
              * so GenObj will fail on classname: text
              *)
             (if switch182 then (thisDesc[],false) -> GenByteCode if)
          // sematt.comKind 
          // sematt.dispatchKind        then 
             (# dum: @integer do GenCom #)
          // sematt.externalVirtualKind 
          // sematt.dispatchVirtualKind then
             (# dum: @ integer do  GenComVirtual #)
	  // sematt.callBackKind        then 
             (# dum: @ integer do  GenCallBack #)
          // sematt.externalKind then 
             thisDesc[] -> GS.externals.add
             (* else no code generation for standardKind and constKind *)
         if)
     if)
#)
-------------------------GenDoPart:descriptor------------------------
(* codegeneration for DoPart slot.
 * FormDesc: the BETA AST of the form. This always a doPart AST.
 * ThisDesc: the AST of the descriptor containing the doPart slot,
 * 		but during codegeneration, this AST is denoting the
 * 		doPart AST. This is needed during codegen for eg. goOrigin.
 * theRealDesc: denotes always the AST of the descriptor with the dopart slot
 *)
(# (*theRealDesc,*)theSlot,preDen:@ ASTindex; 
   R: ^ProtoType; 
do NONE -> externalEntryLab[];
   FormDesc.xOrigin -> theSlot; 
   theSlot.slotOrigin -> thisDesc -> theRealDesc;

   (* protype not generated - see below
    * &ProtoType[]->R[]; ProtoHead[]->R.succ[];R[]->GS.thisPT[]->Protohead[];
    *)
   
   ThisDesc[]
     -> Sematt.descSonsRef
     -> (pref[],mainP[],att[],enterP[],doP[],exitP[]);
   &ASTindex[] -> doP[]; 
   FormDesc.son -> doP; 
   ThisDesc.originOff -> ThisDescOrgOff;
   ThisDesc.descId -> (thisForm[],ThisDescNo);
   
   (if pref.label = gram.prefix then
       true -> hasPref;
       pref.son -> preDen -> SemAtt.descrip -> thisPrefDesc;
    else
       false -> hasPref
   if);

   (if formDesc[] -> sematt.doPartHasTmP then 
       FormDesc -> ThisDesc; (* OBS: ThisDesc denotes the doPart AST *)
   if);
   307->trace(#
             do 'GenDoPartForm:' -> xT;
                ' formDesc.descNo:' -> xT; formdesc.descNo -> xI;
                ' descKind: ' -> xT; theRealDesc -> sematt.descKind -> xI; XN;
                theRealDesc[] -> xA;
             #);
   (if theRealDesc -> sematt.descKind 
    // sematt.externalVirtualKind then
       (FormDesc.descNo(* size of dopart *), NONE,none,true,true,none,none)
         -> genDo
    else
       (if switch182 then
           (theRealDesc[],true) -> GenByteCode
        else
           (FormDesc.descNo(* size of dopart *)
           , NONE,none,true,false,none,none)
             -> genDo
       if)
   if);
   theRealDesc -> ThisDesc; (* OBS: ThisDesc again the descriptor *)

#)
-------------------------GenMainPart:descriptor---------------------
(# 
do NONE->externalEntryLab[];
   false -> returnSaved;
   (* thisDesc = a mainPart form  (# ... #) in ---F1:mainPart-- (# ... #) *)
   thisDesc[] 
     -> sematt.mainPartSons 
     -> (thisDesc,pref[],att[],enterP[],doP[],exitP[]);
   (* thisDesc = theDescriptor  F0<<SLOT F1:mainPart>> *)
   
   (pref.label=gram.prefix)->hasPref;
   ThisDesc.originOff->ThisDescOrgOff;
   ThisDesc.descId->(thisForm[],ThisDescNo);
   
   307->trace
   (#
   do 'GenMainPart-a: ' -> xT; xN;
      'formDesc: descNo=' -> xT; formDesc.descNo -> xI; xN;
      formDesc[]->xA; xN;  
      'thisDesc: thisDescNo=' -> xT; thisDescNo->xI; xN;; 
      thisDesc[]->xA; xN;
      'thisForm: ' -> xT; thisForm[] -> xT; 
   #); 
   formDesc.descNo -> thisDesc.size; 
   (if false then
       (* kind is NOT defined for a mainpart!
        * we cannot save kind for a mainpart;
        * see comment in chkform.bet at mainp.isSlot;
        * be aware that other kind-attributes may be missing!!!
        *)
       formDesc.kind_attrib -> thisDesc.kind_attrib; (* same comment as for size *)
   if);
   (* Note: this overwrites size of a possible checked descriptor;
    * the new size is NOT intended to be stored with the AST;
    * consider however
    * (1) when separate compilation of slot and form; should be OK
    * and
    * (2) when slot and form compiled together; may not be OK since
    * the real size may be stored with the AST: CHECK AGAIN!
    *)
   307->trace
   (#
   do 'GenMainPart-b: ' -> xT; xN;
      thisDesc.size -> xI;
      thisDesc[] -> sematt.hasAcode -> xB;
      thisDesc[] -> sematt.hasDo -> xB;
      thisDesc[] -> sematt.hasInner -> xB;
      thisDesc[] -> sematt.hasOnlyInner -> xB;
   #);
   (if switch182 then
       (thisDesc[],false) -> GenByteCode
    else
       (sematt.generalKind,mainPartForm) -> GenObj;
   if)
#)
---handleNestedDescriptors:dopart---
do loop:
     (# thisDescNo: @integer; thisForm: ^Text; ID: ^ASTindex
     do DS.pop -> (currentDesc[],currentKind,currentCons,ID[]);
        (*1->trace(#
         do 'pop: ' -> xT; currentCons -> xI;xN;
         currentDesc[] -> xA
         #);*)
        (if currentDesc[] <> NONE then (* skip *)
            (if currentDesc.label = gram.unExpanded then
                INNER HandleNestedDescriptors
             else
                (if (currentDesc->sematt.DescKind)
                 // sematt.standardKind // sematt.constKind then
                 else 
                    (* bytecode compiler cannot handle
                     *  (currentDesc.descId
                     *     -> (thisForm[],thisDescno)
                     *     -> descSet.notTranslated)
                     * below
                     *)
                    currentDesc.descId -> (thisForm[],thisDescno);
                    (if switch182 and (currentCons > 1) or 
                        (* This is probably not correct,
                         * gave multiple entry points
                         * with standard compiler - the problem
                         * is that singular descriptors in enter/exit-parts
                         * in decriptors in non-local fragments may be
                         * pushed during codegeneration of evaluations
                         * using these descriptors. We need some mechanism
                         * to handle this.
                         *)
                        (* see comment above
                         (currentDesc.descId
                         -> *) ((thisForm[],thisDescno)
                          -> descSet.notTranslated) then
                        (if ID.isNull then 
                            none -> currentId[]
                         else 
                            ID.getText -> currentId[]
                        if);
                        (* DS-pop in synthesizerbody has
                         * a problem with singular descriptors
                         * in the dopart of patterns in
                         * the origin of a dopart-fragment
                         * 
                         *    foo.bet:
                         *    origin ...;
                         *    body 'foobody'
                         *    --lib:attributes-
                         *     f: (# g: (# do D: (# ... #) #)
                         *        <<SLOT f:doPart>>
                         *        #)
                         * 
                         *    foobody.bet
                         *    origin 'foo'
                         *    ---f:dopart---
                         *    do ...
                         * 
                         * Codegeneration for g and D is first done
                         * when compiling foobody. And DS.pop
                         * will skip D since it is not in a local
                         * fragment. 'g' is handled since it is saved
                         * in locals. We cannot easily save D in locals
                         * since locals is not visible at the point
                         * of push
                         *)
                        INNER HandleNestedDescriptors;
            if)if)if);
            restart loop
        if)
     #)
   
